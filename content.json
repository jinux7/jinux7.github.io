{"meta":{"title":"jinux","subtitle":null,"description":"前端 学习 javascript","author":"jinux","url":""},"pages":[{"title":"categories","date":"2018-08-20T08:19:43.000Z","updated":"2018-08-29T00:57:48.167Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"nodejs"},{"title":"tags-test","date":"2018-08-20T08:18:58.000Z","updated":"2018-08-27T06:24:35.212Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"tag-jquery"}],"posts":[{"title":"vue双向绑定的简单实现","slug":"vue双向绑定的简单实现","date":"2018-08-30T03:13:39.000Z","updated":"2018-08-30T06:10:51.099Z","comments":true,"path":"2018/08/30/vue双向绑定的简单实现/","link":"","permalink":"/2018/08/30/vue双向绑定的简单实现/","excerpt":"","text":"vue双向绑定的简单实现&emsp;&emsp;首先，这篇文章并非我的原创，在网上看到了很多写vue原理的文章，感觉这篇写的层次结构清晰，容易理解，所以留作收藏。废话不多说，开始。 1.原理&emsp;&emsp;Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过 Object对象的defineProperty属性，重写data的set和get函数来实现的,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。添加网上的一张图 2.实现页面结构很简单，如下：1234567&lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button ype=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt;&lt;/div&gt; 包含：1.一个input，使用v-model指令2.一个button，使用v-click指令3.一个h3，使用v-bind指令。我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释：1234567891011var app = new myVue(&#123; el:'#app', data:&#123; number:0 &#125;, methods:&#123; increment:function()&#123; this.number++; &#125;, &#125; &#125;) 首先我们需要定义一个myVue构造函数：123function myVue(options)&#123;&#125; 为了初始化这个构造函数，给它添加一 个_init属性123456789function myVue(options) &#123; this._init(options);&#125;myVue.prototype._init = function (options) &#123; this.$options = options; // options 为上面使用时传入的结构体，包括el,data,methods this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素 this.$data = options.data; // this.$data = &#123;number: 0&#125; this.$methods = options.methods; // this.$methods = &#123;increment: function()&#123;&#125;&#125; &#125; 接下来实现_obverse函数，对data进行处理，重写data的set和get函数并改造_init函数12345678910111213141516171819202122232425262728293031323334myVue.prototype._obverse = function (obj) &#123; // obj = &#123;number: 0&#125; var value; for (key in obj) &#123; //遍历obj对象 if (obj.hasOwnProperty(key)) &#123; value = obj[key]; if (typeof value === 'object') &#123; //如果值还是对象，则遍历处理 this._obverse(value); &#125; Object.defineProperty(this.$data, key, &#123; //关键 enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; &#125; &#125; &#125;) &#125; &#125; &#125;myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._obverse(this.$data); &#125; 接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新12345678910111213function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。 &#125; 更新_init函数以及_obverse函数1234567891011121314151617181920212223242526272829myVue.prototype._init = function (options) &#123; //... this._binding = &#123;&#125;; //_binding保存着model与view的映射关系，也就是我们前面定义的Watcher的实例。当model改变时，我们会触发其中的指令类更新，保证view也能实时更新 //... &#125; myVue.prototype._obverse = function (obj) &#123; //... if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; // 按照前面的数据，_binding = &#123;number: _directives: []&#125; _directives: [] &#125;; //... var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; //... set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; // 当number改变时，触发_binding[number]._directives 中的绑定的Watcher类的更新 item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; 那么如何将view与model进行绑定呢？接下来我们定义一个_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 myVue.prototype._init = function (options) &#123; //... this._complie(this.$el); &#125; myVue.prototype._complie = function (root) &#123; root 为 id为app的Element元素，也就是我们的根元素 var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; // 对所有元素进行遍历，并进行处理 this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++ node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); //bind是使data的作用域与method函数的作用域保持一致 &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件 node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); //_this._binding['number']._directives = [一个Watcher实例] // 其中Watcher.prototype.update = function () &#123; // node['vaule'] = _this.$data['number']; 这就将node的值保持与number一致 // &#125; _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定 &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可 var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; 至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图 附上全部代码，不到150行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 &lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;myVue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #app &#123; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button type=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function myVue(options) &#123; this._init(options); &#125; myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._binding = &#123;&#125;; this._obverse(this.$data); this._complie(this.$el); &#125; myVue.prototype._obverse = function (obj) &#123; var value; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; _directives: [] &#125;; value = obj[key]; if (typeof value === 'object') &#123; this._obverse(value); &#125; var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; myVue.prototype._complie = function (root) &#123; var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; &#125; window.onload = function() &#123; var app = new myVue(&#123; el:'#app', data: &#123; number: 0 &#125;, methods: &#123; increment: function() &#123; this.number ++; &#125;, &#125; &#125;) &#125;&lt;/script&gt; 以上就是所有内容，这个代码不是我创造的，我只是代码的搬运工。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"webSocket","slug":"webSocket项目中的使用","date":"2018-08-29T01:23:54.000Z","updated":"2018-08-29T03:00:13.906Z","comments":true,"path":"2018/08/29/webSocket项目中的使用/","link":"","permalink":"/2018/08/29/webSocket项目中的使用/","excerpt":"","text":"webSocket在项目中的使用&emsp;&emsp;webSocket,这个技术相信大家都已经很熟悉了，就是前端浏览器与后端服务器一直保持连通状态，我们在项目中，经常会遇到这样的需求，一个数据图表展示页面，产品的需求是每隔5秒钟页面刷新一次，传统的做法是请求轮询机制，也就是setInterval这个定时器，一遍又一遍的请求后端接口，这个方法简单（特别是后端简单），但是如果前端页面有大量的这种需求，会影响性能，所以，webSocket是现在最好的选择。&emsp;&emsp;其实webSocket现在还是比较重要的，一般在面试的时候，被问到的几率还是很大的。我之前在项目中没有用到过，但是自己写过webSocket的demo，浏览器配合nodejs来写，也是参考了网上的代码，还是很简单的webSocket详细代码看这里。在面试时被问到的时候，也是实话实说，有可能面试官也是小白，基本上都没往下问，但是，确实是这么简单吗？答案显然不是，待我慢慢道来。&emsp;&emsp;首先，我在最近两个项目中，都用到了webSocket，所以还是有发言权的。如果，产品提出了webSocket的需求，对于我们前端来说，并不是直接写个原生的webSocket就可以，而是需要看后端小伙伴们的脸色，什么意思？就是说得看后端用的是什么webSocket库，我接触的有两种，第一个是stomp,说是webSocket的子协议，后端选了这个库之后，我们前端也得相应的选择与后端相配合的前端库，一般情况下，官网很明确的给出了后端和前端相配合写法，当然，写法也是很简单，跟原生差不多。第二个是，sockjs这个库，当然，也是后端小伙伴选好了之后，告诉我，我相应的在前端也用的跟后端一样库。&emsp;&emsp;最后总结一下，webSocket技术并不难（对于我们前端来说，当然，nodejs的后端也很简单，java就不知道了，每次调起来看他们都是一脸懵逼的样子），无论是面试还是在实际工作中，问道这个问题时，我们首先想到的应该是，后端选择的是什么库，我们前端应该跟后端小伙伴保持一致，可别需求以来，觉得简单直接开些，等联调的时候，我靠，为什么连不上呢？你们前后端不在一个频道上，怎么连接啊。所以，我们要说，我做过的项目是这样这样滴，不知道这次我们后端小伙伴用到的webSocket库是什么呢？","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webSocket","slug":"webSocket","permalink":"/tags/webSocket/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"nodejs代理服务器","slug":"nodejs代理服务器","date":"2018-08-27T06:51:52.000Z","updated":"2018-08-29T00:52:30.372Z","comments":true,"path":"2018/08/27/nodejs代理服务器/","link":"","permalink":"/2018/08/27/nodejs代理服务器/","excerpt":"","text":"nodejs代理服务 最近在与后台同事联调的时候，出现了点故障，跨域，这个经常碰到很好解决的问题，但是一般情况下需要前后端一起配合来解决，比如jsonp，或者h5后端在返回头加上允许跨域的头设置，但是如果后台同事是个小白，问啥啥不明白，也是没招了。我之前还用过将chrome的跨域设置给禁掉的方法，但是这次不知道为啥，也不好使了。最后，只能是用代理这种方式，我现在用的是vue框架，其实vue的脚手架已经集成了跨域功能，只需要配置一下就可以，但是，现在框架这么多，前一阵子还react，angular的项目，最近有换成vue，配置的话，肯定要去查看api，记不住啊，而且，版本不同，设置方法也不同，不如自己写一个，这样多简单，需要的时候把代理服务开启就搞定了。于是乎，自己写一个，当然，稍微想一下就知道，代理的原理，就是利用nodejs在中间做一次请求以及数据返回，不过自己写还得思考，上网找一下多简单，baidu一搜索，哇靠，第一个映入眼帘的就是nodejs代理服务8行代码，嗯，就是这么简单，废话不多说，上代码,当然，自己还得加工一下哦。123456789101112131415161718192021var express = require('express');var request = require('request');var app = express();const proxyUrl = process.argv[2] || 'http://127.0.0.1:8888'; // 如果有传入的代理url，使用它app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") res.send(200); // 让options请求快速返回 else next();&#125;);app.use('/', function(req, res) &#123; var url = proxyUrl + req.url; req.pipe(request(url)).pipe(res);&#125;);app.listen(process.env.PORT || 3000, ()=&gt;&#123; console.log('代理服务器，在3000端口已经开启');&#125;); 再把package.json文件内容贴出来12345678910111213141516&#123; &quot;name&quot;: &quot;node-proxy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;node server http://127.0.0.1:9000&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.3&quot;, &quot;request&quot;: &quot;^2.88.0&quot; &#125;&#125; 源码在这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端代理服务","slug":"后端代理服务","permalink":"/tags/后端代理服务/"}]}]}