{"meta":{"title":"jinux","subtitle":null,"description":"前端 学习 javascript","author":"jinux","url":""},"pages":[{"title":"tags-test","date":"2018-08-20T08:18:58.000Z","updated":"2024-01-11T07:00:59.294Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"tag-jquery"},{"title":"categories","date":"2018-08-20T08:19:43.000Z","updated":"2024-01-11T07:00:59.293Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"javascriptnodejscss计算机原理少儿编程"}],"posts":[{"title":"Tensorflow.js实战之Py与Js模型互转","slug":"Tensorflow-js实战之Py与Js模型互转","date":"2025-06-04T06:31:13.000Z","updated":"2025-06-05T05:04:44.641Z","comments":true,"path":"2025/06/04/Tensorflow-js实战之Py与Js模型互转/","link":"","permalink":"/2025/06/04/Tensorflow-js实战之Py与Js模型互转/","excerpt":"Tensorflow.js-Py与Js模型互转","text":"Tensorflow.js-Py与Js模型互转 Python模型通过Python版本的Tensorflow/Keras生成的模型。包括：Tensorflow Saved Model、Keras HDF5 Model等 Javascript模型可以在Tensorflow.js中运行的模型。包括：tfjs_layers_model、tfjs_graph_model等 模型互转Py模型转Js模型使用Tensorflow.js-converter工具转换 安装Python环境使用conda创建一个Python环境1conda create --name tfjs python=3.6.8 安装Tensorflow.js-converter包1pip install tensorflowjs==2.8.4 -i https://pypi.tuna.tsinghua.edu.cn/simple 转换模型tf_saved_model-&gt;tfjs_graph_model下载tf_saved_model模型12// 转换命令tensorflowjs_converter --input_format=tf_saved_model --output_format=tfjs_graph_model --signature_name=serving_default --saved_model_tags=serve D:\\jinux\\github\\tensorflow.js-tutorial\\code\\Py与Js模型互转\\source\\model\\Py\\saveModel D:\\jinux\\github\\tensorflow.js-tutorial\\code\\Py与Js模型互转\\source\\model\\Js\\graphModel 见source/example目录下引用转换后模型的案例。 目前其他格式转换报错，还在研究中…… Js模型转Py模型很少会用到这种转换 Js模型转jS模型分片、量化、加速 源码Source Code","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"},{"name":"Tensorflow.js","slug":"Tensorflow-js","permalink":"/tags/Tensorflow-js/"}]},{"title":"Tensorflow.js实战之预训练模型使用","slug":"Tensorflow-js实战之预训练模型使用","date":"2025-06-04T06:29:07.000Z","updated":"2025-06-05T05:00:33.627Z","comments":true,"path":"2025/06/04/Tensorflow-js实战之预训练模型使用/","link":"","permalink":"/2025/06/04/Tensorflow-js实战之预训练模型使用/","excerpt":"Tensorflow.js使用预训练模型","text":"Tensorflow.js使用预训练模型这里列举了一些利用Tensorflow.js框架使用预训练模型的例子。 图像分类Source Code 视频识物Source Code 语音识别Source Code 面部定位Source Code","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"},{"name":"Tensorflow.js","slug":"Tensorflow-js","permalink":"/tags/Tensorflow-js/"}]},{"title":"Tensorflow.js实战之训练模型","slug":"Tensorflow-js实战之训练模型","date":"2025-06-04T06:27:48.000Z","updated":"2025-06-05T01:34:13.752Z","comments":true,"path":"2025/06/04/Tensorflow-js实战之训练模型/","link":"","permalink":"/2025/06/04/Tensorflow-js实战之训练模型/","excerpt":"Tensorflow.js自己训练模型","text":"Tensorflow.js自己训练模型这里列举了一些从头开始利用Tensorflow.js框架训练模型的例子。 线性回归Source Code 线性回归归一化Source Code 逻辑回归Source Code 多层神经网络XORSource Code 多分类Source Code 手写数字识别Source Code 迁移学习-图像分类Source Code 迁移学习-语音识别Source Code","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"},{"name":"Tensorflow.js","slug":"Tensorflow-js","permalink":"/tags/Tensorflow-js/"}]},{"title":"Tensorflow.js入门","slug":"Tensorflow-js入门","date":"2025-06-04T06:25:15.000Z","updated":"2025-06-04T06:50:06.357Z","comments":true,"path":"2025/06/04/Tensorflow-js入门/","link":"","permalink":"/2025/06/04/Tensorflow-js入门/","excerpt":"Tensorflow.js简单入门教程","text":"Tensorflow.js简单入门教程 机器学习基础什么是机器学习？ 机器学习是对能通过经验自动改进的计算机算法的研究。 机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。 机器学习如何运作？ 神经网络。 决策树，支持向量机，贝叶斯分类器，强化学习等。 什么是神经网络？ 神经网络指的是人工神经网络 人工神经网络是一种运算模型（就是输入输出的映射），由大量的节点（或称神经元）之间相互联接构成。 神经网络的训练概括 给大量输入和输出，算出神经网络里所有神经元的权重，偏置，然后给定新的输入，可以算出新的输出。 在机器学习里输入输出被称为特征和标签，大量输入输出被称为训练集。 细节 初始化：随机生成一些权重和偏置。 计算损失：给定特征，计算出标签，得到它与真实标签差得多远。 优化：微调权重和偏置，使损失变小。 计算损失 使用损失函数 损失函数有均方误差，对数损失，交叉熵等。 优化 使用优化器 优化器有随机梯度下降（SGD），Adam等。 Tensorflow.js基础Tensorflow.js是什么？ 一个用javascript实现的机器学习库。 可以直接在浏览器和Node.js中使用机器学习技术。 具体功能 运行现有模型。 重新训练现有模型。 使用javascript从0开发机器学习模型。 安装在浏览器中安装使用script标签引入TensorFlow.js。123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;!-- Load TensorFlow.js --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Place your code in the script tag below. You can also use an external .js file --&gt; &lt;script&gt; // Notice there is no &apos;import&apos; statement. &apos;tf&apos; is available on the index-page // because of the script tag above. // Define a model for linear regression. const model = tf.sequential(); model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;)); // Prepare the model for training: Specify the loss and the optimizer. model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;); // Generate some synthetic data for training. const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]); const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]); // Train the model using the data. model.fit(xs, ys).then(() =&gt; &#123; // Use the model to do inference on a data point the model hasn&apos;t seen before: // Open the browser devtools to see the output model.predict(tf.tensor2d([5], [1, 1])).print(); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 使用NPM包安装，并使用Parcel，Webpack，vite等构建工具。1npm install @tensorflow/tfjs 123456789101112131415161718import * as tf from &apos;@tensorflow/tfjs&apos;;//定义一个线性回归模型。const model = tf.sequential();model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);// 为训练生成一些合成数据const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);// 使用数据训练模型model.fit(xs, ys, &#123;epochs: 10&#125;).then(() =&gt; &#123; // 在该模型从未看到过的数据点上使用模型进行推理 model.predict(tf.tensor2d([5], [1, 1])).print(); // 打开浏览器开发工具查看输出&#125;); 在Node.js中安装安装带有原生C++绑定的TensorFlow.js123npm install @tensorflow/tfjs-node或npm install @tensorflow/tfjs-node-gpu 安装纯javascript版本，这个性能比较慢。1npm install @tensorflow/tfjs 张量(Tensor)TensorFlow.js中数据的中心单位是张量：一组数值形成一个或多个维度的数组。 张量实例具有定义数组形状的形状属性。Tensorflow.js中数据的主要表现形式就是tensor（张量）：由 一组数值形成一维或多维数组。一个Tensor实例有一个shape属性来定义这一组数值如何组成张量,而最主要的Tensor实例的构造函数就是 tf.tensor 函数，如下所示：123456789101112// 2x3 Tensorconst shape = [2, 3]; // 2 行, 3 列const a = tf.tensor([1.0, 2.0, 3.0, 10.0, 20.0, 30.0], shape);a.print(); // 打印张量值// 输出: [[1 , 2 , 3 ],// [10, 20, 30]]// shape也可以用下面的方式实现:const b = tf.tensor([[1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]);b.print();// 输出: [[1 , 2 , 3 ],// [10, 20, 30]] 但是，为了构造低秩张量，我们推荐使用下面的函数来增强代码的可读性：tf.scalar（零维）, tf.tensor1d（一维）, tf.tensor2d（二维）, tf.tensor3d（三维）、tf.tensor4d（四维）以及 tf.ones（值全是1）或者tf.zeros（值全是0） ，如下所示：1234567891011const a = tf.scalar(3.14);a.print(); // 输出零维张量const b = tf.tensor2d([[2, 3, 4], [5, 6, 7]]);b.print(); // 输出二维张量const c = tf.zeros([2, 3]);c.print(); // 输出2行3列的值全是0的张量const d = tf.ones([3, 5]);d.print(); // 输出3行5列的值全是1的张量 在TensorFlow.js中，张量是不变的; 一旦创建你就不能改变它们的值。 但是，您可以对它们执行操作来生成新的张量。 变量(variables)Variables变量是通过张量进行初始化得到的。不像Tensor的值不可变，变量的值是可变的。你可以使用变量的assign方法分配一个新的tensor到这个变量上，这是变量就会改变：1234567const initialValues = tf.zeros([5]);const biases = tf.variable(initialValues); // 初始化biasesbiases.print(); // 输出: [0, 0, 0, 0, 0]const updatedValues = tf.tensor1d([0, 1, 0, 1, 0]);biases.assign(updatedValues); // 更新 biases的值biases.print(); // 输出: [0, 1, 0, 1, 0] 如上所示，首先使用tf.zeros得到一个张量，然后利用这个张量初始化得到一个变量，接着我们就可以打印这个变量，并且通Object.prototype.toString.call(biases)方法可以判断变量也是一个对象，接着，我们再生成一个张量，然后变量调用assign方法传入这个张量，就可以得到一个新的变量了，如下：由此我们可以得出一个结论：变量由张量生成，且张量不可变而变量可变。以上就是Tensorflow.js 张量和变量的相关介绍，希望对大家有所帮助。 操作(operations)ensors 可以用保存数据，而 operations 可以操作数据。TensorFlow.js 提供了多种适用于张量的线性代数和机器学习的运算的 operations。由于张量是不可改变的，所以 operations 操作并不会改变 tensors 的值，而是返回新的张量。 operations 提供了类似 square 等一元运算1234567const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);x.square().print(); // or tf.square(x)// [1, 4, 1.9999999, 1]const x = tf.tensor1d([1, 2, 4, -1]);x.sqrt().print(); // or tf.sqrt(x)// [1, 1.4142135, 2, NaN] operations 提供了类似 add、sub 等二元运算12345const a = tf.tensor1d([1, 2, 3, 4]);const b = tf.tensor1d([10, 20, 30, 40]);a.add(b).print(); // or tf.add(a, b)// [11, 22, 33, 44] 支持链式操作123456789const e = tf.tensor2d([[1.0, 2.0], [3.0, 4.0]]);const f = tf.tensor2d([[5.0, 6.0], [7.0, 8.0]])const sq_sum = e.add(f).square();sq_sum.print();// Output: [[36 , 64 ],// [100, 144]]// 所有的操作都暴露在函数的命名空间中，也可以进行下面操作，得到相同的结果const sq_sum = tf.square(tf.add(e, f)); 模型(model)机器学习中，一个 model 是一个带有可训练参数的函数。这个函数将输入转化为输出。通俗的来说，这个函数表达了输入和输出之间的变换关系。我们通过在数据集上训练模型来获得最佳参数。训练好的模型可以精确的将输入数据转换为我们想得到的输出。TensorFlow.js 有两种创建机器学习的方法：用 Layers API（用 layers 来创建模型）用 Core API（底端算子，例如 tf.matMul() 或 tf.add() 等）来建立模型我们首先会用高层API：Layers API来建立模型。然后，我们会展示如何用Core API来搭建相同的模型。 用Layers API创建模型Layers API有两种方式创建模型：第一种是创建 sequential 模型，第二种是创建 functional 模型。下面两段会分别解释这两种模型创建方式。 使用sequential model最常见的模型是 Sequential 模型。Sequential 模型将网络的每一层简单的叠在一起。您可以将需要的层按顺序写在一个列表里，然后将列表作为 sequential() 函数的输入：123456const model = tf.sequential(&#123; layers: [ tf.layers.dense(&#123;inputShape: [784], units: 32, activation: &apos;relu&apos;&#125;), tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;), ]&#125;); 或用 add() 方法：123const model = tf.sequential();model.add(tf.layers.dense(&#123;inputShape: [784], units: 32, activation: &apos;relu&apos;&#125;));model.add(tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;)); 注意：模型的第一层需要“输入形状”参数（inputShape）。不要在“输入型状”中包含 batch size（批次大小）。假设您要向模型输入一个形状为[B, 784]的张量（B 是任意batch size），您只需要将“输入型状”设为[784]。 您可以通过model.layers来使用模型中的每一层。例如，您可以用 model.inputLayers 和 model.outputLayers 来调用输入层和输出层。 使用functional model我们也可以通过 tf.model() 来创建 LayersModel。tf.model() 和 tf.sequential() 的主要区别为，您可以用 tf.model() 来创建任何非闭环的计算图。以下是一段如何用 tf.model() API 建立和上文相同模型的列子：12345// 用apply()方法创建任意计算图const input = tf.input(&#123;shape: [784]&#125;);const dense1 = tf.layers.dense(&#123;units: 32, activation: &apos;relu&apos;&#125;).apply(input);const dense2 = tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;).apply(dense1);const model = tf.model(&#123;inputs: input, outputs: dense2&#125;); 我们在每一层用 apply() 将上一层的输出作为本层的输入。apply() 返回一个 SymbolicTensor（类似于张量，但不包含任何数值）不同于 sequential model 使用 inputShape 来定义第一层的输入，我们用 tf.input() 创建的 SymbolicTensor 作为第一层的输入如果您向 apply() 输入一个数值张量，它会进行计算并返还一个数值张量：123const t = tf.tensor([-2, 1, 0, 5]);const o = tf.layers.activation(&#123;activation: &apos;relu&apos;&#125;).apply(t);o.print(); // [0, 1, 0, 5] 这个方式适用于单独测试每一层并检查它们的输出。和 sequential model 一样，您可以通过 model.layers 来使用模型中的每一层。例如，您可以用 model.inputLayers 和 model.outputLayers 来调用输入层和输出层。 验证Sequential model和functional model都属于 LayersModel类。使用 LayersModels 让验证更方便：它要求您定义输入形状，并用您定义的形状来验证您对模型的输入。LayersModel 会自动计算模型中所有张量的形状。知道张量的形状后，模型就可以自动创建它所需要的参数。您也可以用形状信息来判断两层相邻的层是否相互兼容。 模型总览使用 model.summary() 可以显示很多模型的重要信息，包括： 每一层的名字和类型 每一层的输出形状 每一层的权重数量 每一层的输入 一个模型拥有的可训练参数总量，和不可训练参数总量 用前面定义的模型来做例子，我们可以在命令行中得到以下信息： Layer(type) Output shape Param # dense_Dense1 (Dense) [null,32] 25120 dense_Dense2 (Dense) [null,10] 330 Total params: 25450 Trainable params: 25450 Non-trainable params: 0 注意：每一层的输出形状中都含有 null 值。模型的输入形状包含了批次大小，而批次大小是可以灵活更变的，所以批次的值在张量形状中以 null 显示。 序列化相对于底端API而言，使用 LayersModel的另一个好处是方便存储、加载模型。LayersModel 包含如下信息： 可用于重建模型的模型架构信息 模型的权重 训练配置（例如损失函数，优化器和评估方式） 优化器的状态（可用于继续训练模型） 存储和加载模型只需要一行代码：12const saveResult = await model.save(&apos;localstorage://my-model-1&apos;);const model = await tf.loadLayersModel(&apos;localstorage://my-model-1&apos;); 在这个例子中，模型被存储在浏览器的本地存储里。请访问 model.save() 和 save and load 了解如何把模型保存在不同的媒介中（例如 file storage, IndexedDB, 触发下载到浏览器等等）。 自定义层层是创建模型的基础。如果您的模型需要定制化计算模块，您可以写一个自定义层并插入模型中。下面的例子是一个计算平方和的自定义层：12345678910111213class SquaredSumLayer extends tf.layers.Layer &#123; constructor() &#123; super(&#123;&#125;); &#125; // In this case, the output is a scalar. computeOutputShape(inputShape) &#123; return []; &#125; // call() is where we do the computation. call(input, kwargs) &#123; return input.square().sum();&#125; // Every layer needs a unique name. getClassName() &#123; return &apos;SquaredSum&apos;; &#125;&#125; 可以用 apply() 方法在一个张量上测试这个自定义层123const t = tf.tensor([-2, 1, 0, 5]);const o = new SquaredSumLayer().apply(t);o.print(); // prints 30 注意：如果您在模型中包含了自定义层，模型将不能序列化 用Core API创建模型本文开头提到了两种在 TensorFlow.js 中建立模型的方法。最常用的方式是使用 Layers API，因为它的模式是基于广泛应用的 Keras API（详情见 best practices and reduces cognitive load）。Layers API 提供了大量方便的工具，例如权重初始化，模型序列化，训练监测，可迁移性和安全检查。当您遇到如下情况时，可能会需要使用 Core API： 您需要更多灵活性和控制 您不需要序列化或可以创造自己的序列化方法 用 Core API 写的模型包含了一系列的函数。这些函数以一个或多个张量作为输入，并输出另一个张量。我们可以用 Core API 来重写之前定义的模型：123456789// The weights and biases for the two dense layers.const w1 = tf.variable(tf.randomNormal([784, 32]));const b1 = tf.variable(tf.randomNormal([32]));const w2 = tf.variable(tf.randomNormal([32, 10]));const b2 = tf.variable(tf.randomNormal([10]));function model(x) &#123; return x.matMul(w1).add(b1).relu().matMul(w2).add(b2).softmax();&#125; 在 Core API 中，我们需要自己创建和初始化权重。每个权重都是一个 Variable，TensorFlow.js 会把 Variable 权重设为可训练张量。您可以用 tf.variable() 创建 Variable 或把一个已存在的张量放到 Variable 中。 内存管理(dispose&amp;tidy)因为TensorFlow.js使用了GPU来加速数学运算，因此当tensorflow处理张量和变量时就有必要来管理GPU内存。在TensorFlow.js中，我们可以通过dispose 和 tf.tidy这两种方法来管理内存。 dispose您可以在张量或变量上调用dispose来清除它并释放其GPU内存：12345const x = tf.tensor2d([[0.0, 2.0], [4.0, 6.0]]);const x_squared = x.square();x.dispose();x_squared.dispose(); tf.tidy进行大量的张量操作时使用dispose可能会很麻烦。 TensorFlow.js提供了另一个函数tf.tidy，它对JavaScript中的常规范围起到类似的作用，不同的是它针对GPU支持的张量。tf.tidy执行一个函数并清除所有创建的中间张量，释放它们的GPU内存。 它不清除内部函数的返回值。12345678const average = tf.tidy(() =&gt; &#123; const y = tf.tensor1d([1.0, 2.0, 3.0, 4.0]); const z = tf.ones([4]); return y.sub(z).square().mean();&#125;);average.print() 使用tf.tidy将有助于防止应用程序中的内存泄漏。它也可以用来更谨慎地控制内存何时回收。 两个重要的注意事项传递给tf.tidy的函数应该是同步的，并且不会返回Promise。我们建议在tf.tidy内不要有更新UI或在发出远程请求的代码。tf.tidy不会清理变量。变量通常持续到机器学习模型的整个生命周期，因此TensorFlow.js不会清理它们，即使它们是在tidy中创建的。不过，您可以手动调用dispose处理它们。 Tensorflow.js实战例子TensorFlow.js的工作依然是围绕神经网络展开的，基本的工作过程包含了如下几个典型步骤：下面将通过TensorFlow.js官方网站提供的数据拟合的示例来了解整个流程。 DefineDefine 阶段是使用TensorFlow.js的第一步，这个阶段中需要初始化神经网络模型，你可以在TensorFlow的tf.layers对象上找到具备各种功能和特征的隐藏层，通过模型实例的add方法将其逐层添加到神经网络中，从而实现张量变形处理、卷积神经网络、循环神经网络等复杂模型，当内置模型无法满足需求时，还可以自定义模型层，TensorFlow的高阶API可以帮助开发者以声明式的编码来完成神经网络的结构搭建，示例代码如下：1234567/*创建模型*/function createModel() &#123; const model = tf.sequential(); model.add(tf.layers.dense(&#123;inputShape: [1], units: 1, useBias: true&#125;)); model.add(tf.layers.dense(&#123;units: 1, useBias: true&#125;)); return model;&#125; CompileCompile阶段需要对训练过程进行一些参数预设，你可以先温习一下上一章中介绍过的BP神经网络的工作过程，然后再来理解下面的示例代码：12345model.compile(&#123; optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: [&apos;mse&apos;],&#125;); loss（损失）用于定义损失函数，它是神经网络的实际输出和期望输出之间偏差的量化评估标准，最常用的损失函数就是均方差损失（tf.losses.meanSquaredError），其他损失函数可以在TensorFlow的API文档中进行查看；optimizer(优化器)是指误差反向传播结束后，神经网络进行权重调整时所使用的的算法。权重调整的目的就是为了使损失函数达到极小值，所以通常采用“梯度下降”的思想来进行逼近，梯度方向是指函数在某一点变化最显著的方向，但实际的情况往往并没有这么简单，假设下图是一个神经网络的损失函数曲线：可以看到损失函数的形态、初始参数的位置以及优化过程的步长等都可能对训练过程和训练结果产生影响，这就需要在optimizer配置项中指定优化算法来达到较好的训练效果；metrics配置项用于指定模型的度量指标，大多数情况下可以直接使用损失函数来作为度量标准。 FitFit 阶段执行的是模型训练的工作（fit本身是拟合的意思），通过调用模型的fit方法就可以启动训练循环，官方示例代码如下(fit方法接收的参数分别为输入张量集、输出张量集和配置参数)：12345678910111213const batchSize = 32;const epochs = 50;await model.fit(inputs, labels, &#123; batchSize, epochs, shuffle: true, callbacks: tfvis.show.fitCallbacks( &#123; name: &apos;Training Performance&apos; &#125;, [&apos;loss&apos;, &apos;mse&apos;], &#123; height: 200, callbacks: [&apos;onEpochEnd&apos;] &#125; )&#125;); 相关参数说明如下（其他参数可参考官方开发文档）： batchSize（批大小）指每个循环中使用的样本数，通常取值为32~512 epochs指定整个训练集上的数据的总循环次数 shuffle指是否在每个epochs中打乱训练样本的次序 callbacks指定了训练过程中的回调函数 神经网络的训练是循环进行的，假设总训练样本大小为320个，那么上面的示例代码所描述的训练过程是：先使用下标为0^31的样本来训练神经网络，然后使用optimizer来更新一次权重，再使用下标为32^63的样本进行训练，再更新权重，直到总样本中所有数据均被使用过一次，上述过程被称为一个epoch，接着打乱整个训练样本的次序，再重复共计50轮，callbacks回调函数参数直接关联了tfvis库，它是TensorFlow提供的专用可视化工具模块。 EvaluateEvaluate阶段需要对模型的训练结果进行评估，调用模型实例的evaluate方法就可以使用测试数据来获得损失函数和度量标准的数值。你可能已经注意到TensorFlow在定制训练过程时更加关注如何使用样本数据，而并没有将“度量指标小于给定阈值”作为训练终止的条件（例如brain.js中就可以通过设置errorthresh参数），在复杂神经网络的构建和设计中，开发者很可能需要一边构建一边进行非正式的训练测试，度量指标最终并不一定能够降低到给定的阈值以下，以此作为训练终止条件很可能会使训练过程陷入无限循环，所以使用固定的训练次数配合可视化工具来观察训练过程就更为合理。 PredictPredict阶段是使用神经网络模型进行预测的阶段，这也是前端工程师参与度最高的部分，毕竟模型输出的结果只是数据，如何利用这些预测结果来制作一些更有趣或者更加智能化的应用或许才是前端工程师更应该关注的问题。从前文的过程中不难看出，TensorFlow.js提供的能力是围绕神经网络模型展开的，应用层很难直接使用，开发者通常都需要借助官方模型仓库中提供的预训练模型或者使用其他基于TensorFlow.js构建的第三方应用，例如人脸识别框架face-api.js（它可以在浏览器端和Node.js中实现快速的人脸追踪和身份识别），语义化更加明确的机器学习框架ml5.js（可以直接调用API来实现图像分类、姿势估计、人物抠图、风格迁移、物体识别等更加具体的任务），可以实现手部跟踪的handtrack.js等等，如果TensorFlow的相关知识让你觉得过于晦涩，也可以先尝试使用这些更高层的框架来构建一些有趣的程序。 总结以上是对Tensorflow.js的简单介绍，下边列出几个常用的链接，对学习Tensorflow.js有更加详细的了解TensorFlow.js中文官网w3cschoolTensorFlow.js模型下载训练数据集","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"},{"name":"Tensorflow.js","slug":"Tensorflow-js","permalink":"/tags/Tensorflow-js/"}]},{"title":"使用 Rust 锈化前端工具链","slug":"使用-Rust-锈化前端工具链","date":"2025-06-03T06:12:23.000Z","updated":"2025-06-03T06:54:08.055Z","comments":true,"path":"2025/06/03/使用-Rust-锈化前端工具链/","link":"","permalink":"/2025/06/03/使用-Rust-锈化前端工具链/","excerpt":"使用Rust构建前端工具链","text":"使用Rust构建前端工具链 前言近年来，Rust的受欢迎程度不断上升。首先，在操作系统领域，Rust 已成为 Linux 内核官方认可的开发语言之一，Windows 也宣布将使用 Rust 来重写内核，并重写部分驱动程序。此外，国内手机厂商 Vivo 也宣布使用 Rust 开发了名为“蓝河”的操作系统。除此之外，Rust 在图形渲染、游戏开发、中间件开发、边缘计算、计算安全等领域也是遍地开花，可以说，Rust 正在以惊人的速度重塑着各个领域的发展，让人不禁感叹 Rust 已经在重写万物了。 那回到前端领域，正在进行一场构建工具的革命，除了老牌的 Babel 竞争对手swc，一些新兴的前端构建工具也都在使用 Rust 进行开发，例如Turbopack、Parcel，对标 Webpack 的Rspack，对标 Vite 的Farm等等。所以，对于广大前端同胞来说，C/C++ 太难，学习和掌握 Rust 是一个不错的选择，虽然 Rust 也不见得容易许多，它有着陡峭的学习曲线，但它或许是我们突破闭塞的前端区间的一把钥匙，帮助我们打开通往新世界的大门。 锈化开发工具的方式虽说 Rust 的学习曲线可能相对陡峭，但笔者认为这是对于要全面掌握 Rust 这门语言而言的，而我们学习语言的目的最重要的是掌握一项可以帮我们解决问题的技能，因此，对于 Rust 不需要抱有太多的恐惧和敬畏之心，只需要摒除杂念立马开始学习 + 撸码，剩下的就交给时间来慢慢积累经验。此外，对于不是那么复杂应用来说，熟悉 Rust 基本语法和数据结构，翻过「所有权机制」和「生命周期」两座大山，基本也足以应付了。 本文建立在读者已经有一定的 Rust 知识基础上，对于 Rust 基本语法就不做赘述了。当前，大部分前端研发都是在 Node 环境下进行的，所以我们通过 Rust 来改造开发工具，主要有两种形式： 使用 WASM 的方式，基于wasm-pack，将 Rust 代码编译成 WASM，以供 Node 调用 将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于napi-rs和neon来实现 在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么此时就应该选择 Node addons 的方式了。而napi-rs和neon的选择的话，napi-rs相对而言比较简单和轻量，而且针对不同版本的 Node 不需要重新编译，所以我们考虑选择napi-rs作为锈化开发工具的方式。 初识 NAPI-RS我们可以通过 napi-rs 的开发工具 @napi-rs/cli以及项目模板来初始化一个应用，这里推荐使用项目模板，因为经过笔者的测试，开发工具创建的项目内容上相较于模板比较落后，对于后续深入使用上会造成一定的困惑。 从 napi-rs 项目模板内容上看，可以发现项目结构完善，工程化相关能力非常齐全，提供了构建工具、测试用例编写、Github CI 工作流等等必须的能力，我们只需要关注编码就可以了。 我们先来关注一下生成的 napi-rs 项目文件。从package.json和npm分析可以看出，一个 napi-rs 项目主要是由主包和 npm 下的针对不同平台的编译构建结果子包组成，napi-rs 会根据用户的配置，将用户的 Rust 代码构建为不同平台下的 Node 扩展 binding 文件，这些文件会放到 npm 下对应的平台目录中，再由 package.json 中 main 字段指定导出，用户在安装主包的时候，会根据用户电脑情况加载对应构建结果子包。 12345678910111213141516171819&#123; &quot;name&quot;: &quot;@tarojs/parse-css-to-stylesheet-darwin-x64&quot;, &quot;version&quot;: &quot;0.0.25&quot;, &quot;os&quot;: [ &quot;darwin&quot; ], &quot;cpu&quot;: [ &quot;x64&quot; ], &quot;main&quot;: &quot;parse-css-to-stylesheet.darwin-x64.node&quot;, &quot;files&quot;: [ &quot;parse-css-to-stylesheet.darwin-x64.node&quot; ], &quot;license&quot;: &quot;MIT&quot;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 10&quot; &#125;, &quot;repository&quot;: &quot;https://github.com/NervJS/parse-css-to-stylesheet&quot;&#125; 而在主包入口index.js中将根据用户宿主平台，加载对应的扩展文件。123456789101112131415161718192021222324...switch (platform) &#123; case &apos;win32&apos;: switch (arch) &#123; case &apos;x64&apos;: localFileExisted = existsSync( join(__dirname, &apos;parse-css-to-stylesheet.win32-x64-msvc.node&apos;) ) try &#123; if (localFileExisted) &#123; nativeBinding = require(&apos;./parse-css-to-stylesheet.win32-x64-msvc.node&apos;) &#125; else &#123; nativeBinding = require(&apos;@tarojs/parse-css-to-stylesheet-win32-x64-msvc&apos;) &#125; &#125; catch (e) &#123; loadError = e &#125; break ... &#125; break ...&#125;... 从@napi-rs/triples这个包中可以看到所有支持的平台列表，而对于常规性的 Node 应用来说，我们不需要构建这么多平台，一般来说构建x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台也足够了，这样也能减少 CI 的构建时间。 napi-rs 默认构建的平台是x86_64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu，在这里可以看到，所以为了增加 MAC Book M 系列电脑的支持，我们需要增加aarch64-apple-darwin的配置，可以在 package.json 中napi字段中添加，配置如下：123456789&quot;napi&quot;: &#123; &quot;binaryName&quot;: &quot;taro&quot;, &quot;triples&quot;: &#123; &quot;default&quot;: true, &quot;additional&quot;: [ &quot;aarch64-apple-darwin&quot; ] &#125;&#125;, 接下来就可以开始我们的编码之旅咯！ 基于 NAPI-RS 开发 Node 扩展基于 napi-rs 开发 Node 扩展，除了 Rust 编码本身外，无非需要关注两种情况，即 JavaScript 调用 Rust 和 Rust 调用 JavaScript。 JavaScript 调用 Rust调用 Rust 函数这是最常见的用法，因为我们一般使用 Rust 开发 Node 扩展，也是为了将一些 CPU 密集型任务的任务使用 Rust 来实现，再暴露给 JS 来调用，从而达到提升应用性能的目的，最为常见的是 Rust 暴露方法给到 JS 调用，通过项目模板生成的 napi-rs 示例也可以看到。1234567// src/lib.rs use napi_derive::napi;#[napi]pub fn plus_100(input: u32) -&gt; u32 &#123; input + 100&#125; 如上代码，通过给plus_100函数添加#[napi]属性宏，这样可以标记该函数，表示该函数可以通过 N-API 在 Node.js 中调用，在项目编译后的 typing 文件中，我们能看到对应生成了 JS 函数.1export function plus100(input: number): number 可以看到这里生成 JS 函数名是 napi-rs 自己的规则，我们也可以自定义暴露的函数名，通过js_name属性可以指定。1234#[napi(js_name = &quot;plus_100&quot;)]pub fn plus_100(input: u32) -&gt; u32 &#123; input + 100&#125; 当然，除了暴露函数这一基本操作之外，我们还可以暴露常量、对象、类、enum 等等给到 JS 侧去调用，这些可以通过 napi-rs 的官方文档可以查阅到。 以 Object 作为参数而在 JS 调用 Rust 编码中，最需要关注的是调用函数时，JS 侧给 Rust 传对象作为参数，这里为了提升性能，建议提前在 Rust 中定义好传递对象的数据结构，在 JS 中以引入该数据结构定义，规范数据传递即可。12345678910111213141516171819// 定义好数据结构// napi(object) 表示紧随其后的 struct （结构体）将通过 N-API 以 JavaScript 对象的形式暴露出去#[napi(object)]pub struct Project &#123; pub project_root: String, pub project_name: String, pub npm: NpmType, pub description: Option, pub typescript: Option, pub template: String, pub css: CSSType, pub auto_install: Option, pub framework: FrameworkType, pub template_root: String, pub version: String, pub date: Option, pub compiler: Option, pub period: PeriodType,&#125; JS 中调用1234567891011121314151617181920// 函数定义，其中 Project 由 Rust binding 中暴露export function createProject(conf: Project)// 函数调用createProject(&#123; projectRoot: projectDir, projectName, template, npm, framework, css: this.conf.css || CSSType.None, autoInstall: autoInstall, templateRoot: getRootPath(), version: getPkgVersion(), typescript: this.conf.typescript, date: this.conf.date, description: this.conf.description, compiler: this.conf.compiler, period: PeriodType.CreateAPP,&#125;) Rust 调用 JavaScript而 Rust 中也可以调用 JS 提供的方法，这在做 Node 开发工具的时候非常有用，因为有时候我们需要读取开发人员的配置代码给到 Rust 调用，其中就可能会遇到 Rust 调用 JavaScript 中函数的情况。 一个调用 JS 函数的简单例子在 napi-rs 中调用 JS 函数主要通过ThreadsafeFunction来实现，请看例子：12345678910#[napi]pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123; for n in 0..100 &#123; let tsfn = callback.clone(); thread::spawn(move || &#123; tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking); &#125;); &#125; Ok(())&#125; 在上述例子中，call_threadsafe_function函数接受了一个类型为ThreadsafeFunction的参数，这表明call_threadsafe_function被编译为 JS 函数后将接受一个回调函数作为参数，而该回调函数的有效参数为u32即number类型，而在call_threadsafe_function函数体中，通过thread::spawn开辟子线程，以阻塞的方式调用这个传入的回调函数。 通过ThreadsafeFunction的call方法可以调用到传入的 JS 回调函数，但是我们会发现它拿不到返回值，如果我们需要获取到 JS 回调函数的返回值时，我们需要使用call_with_return_value和call_async两个方法。 获取 JS 函数的返回值对比call与call_with_return_value的实现可以看出，call_with_return_value比call多一个回调函数参数，并且可以指定 JS 回调函数返回值的类型，并且该类型需要满足FromNapiValue这个 trait，因为call_with_return_value在处理 JS 回调函数时会调用它的from_napi_value方法将 JS 数据转为 Rust 的数据类型。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// https://github.com/napi-rs/napi-rs/blob/main/crates/napi/src/threadsafe_function.rs#L428pub fn call(&amp;self, value: Result, mode: ThreadsafeFunctionCallMode) -&gt; Status &#123; self.handle.with_read_aborted(|aborted| &#123; if aborted &#123; return Status::Closing; &#125; unsafe &#123; sys::napi_call_threadsafe_function( self.handle.get_raw(), Box::into_raw(Box::new(value.map(|data| &#123; ThreadsafeFunctionCallJsBackData &#123; data, call_variant: ThreadsafeFunctionCallVariant::Direct, callback: Box::new(|_d: Result| Ok(())), &#125; &#125;))) .cast(), mode.into(), ) &#125; .into() &#125;)&#125;pub fn call_with_return_value Result&lt;()&gt;&gt;( &amp;self, value: Result, mode: ThreadsafeFunctionCallMode, cb: F,) -&gt; Status &#123; self.handle.with_read_aborted(|aborted| &#123; if aborted &#123; return Status::Closing; &#125; unsafe &#123; sys::napi_call_threadsafe_function( self.handle.get_raw(), Box::into_raw(Box::new(value.map(|data| &#123; ThreadsafeFunctionCallJsBackData &#123; data, call_variant: ThreadsafeFunctionCallVariant::WithCallback, callback: Box::new(move |d: Result| &#123; d.and_then(|d| D::from_napi_value(d.0.env, d.0.value).and_then(cb)) &#125;), &#125; &#125;))) .cast(), mode.into(), ) &#125; .into() &#125;)&#125; call_with_return_value的使用方式如下：12345678#[napi]pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123; callback.call_with_return_value(Ok(1), ThreadsafeFunctionCallMode::Blocking, move |result: u32| &#123; println!(&quot;callback: &#123;result:?&#125;&quot;); Ok(()) &#125;); Ok(())&#125; 可以看出，JS 回调函数的返回值是在call_with_return_value的第三个回调函数参数中获取到的，这就导致如果我们需要依赖这个 JS 函数返回值的话，我们后续的逻辑代码只能写在call_with_return_value的第三个回调函数参数中，对我们的代码逻辑书写造成诸多不便，代码可读性降低，所以推荐使用call_async方法来执行 JS 函数，并获取参数。 使用call_async获取 JS 函数返回值从call_async的实现可以看出，它首先使用了tokio创建了一个 one-shot 通道，让 JS 函数以不阻塞的方式异步运行，并在执行完成后通过sender 发送操作结果，而使用receiver进行等待执行结果，并将结果返回，同时要使用call_async方法，需要在Cargo.toml中为napi依赖打开tokio_rt特性。12345678910111213141516171819202122232425262728293031323334353637383940414243#[cfg(feature = &quot;tokio_rt&quot;)]pub async fn call_async(&amp;self, value: Result) -&gt; Result &#123; let (sender, receiver) = tokio::sync::oneshot::channel::&gt;(); self.handle.with_read_aborted(|aborted| &#123; if aborted &#123; return Err(crate::Error::from_status(Status::Closing)); &#125; check_status!( unsafe &#123; sys::napi_call_threadsafe_function( self.handle.get_raw(), Box::into_raw(Box::new(value.map(|data| &#123; ThreadsafeFunctionCallJsBackData &#123; data, call_variant: ThreadsafeFunctionCallVariant::WithCallback, callback: Box::new(move |d: Result| &#123; sender .send(d.and_then(|d| D::from_napi_value(d.0.env, d.0.value))) .map_err(|_| &#123; crate::Error::from_reason(&quot;Failed to send return value to tokio sender&quot;) &#125;) &#125;), &#125; &#125;))) .cast(), ThreadsafeFunctionCallMode::NonBlocking.into(), ) &#125;, &quot;Threadsafe function call_async failed&quot; ) &#125;)?; receiver .await .map_err(|_| &#123; crate::Error::new( Status::GenericFailure, &quot;Receive value from threadsafe function sender failed&quot;, ) &#125;) .and_then(|ret| ret)&#125; 可见call_async使用时将引入 Rust 的异步编程，我们可以使用async/await关键字来进行调用，使用方式如下：123456789101112#[napi]pub async fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result &#123; let result = match callback.call_async::(Ok(1)).await &#123; Ok(res) =&gt; res, Err(e) =&gt; &#123; println!(&quot;Error: &#123;&#125;&quot;, e); 0 &#125; &#125;; println!(&quot;result: &#123;result:?&#125;&quot;); Ok(result)&#125; 此时生成的 JS 函数定义为如下，可以看出callThreadsafeFunction变成了一个异步函数：1export function callThreadsafeFunction(callback: (err: Error | null, value: number) =&gt; any): Promise&lt;number&gt; 所以在 JS 中调用方式及输出结果为：12345678const result = await callThreadsafeFunction((err, value) =&gt; &#123; return value + 1&#125;)console.log(result)// 输出结果// result: 2// 2 正确处理 JS 函数的返回值从前面call_async的实现可以看出，call_async返回的数据，也即 JS 函数返回值需要满足如下泛型约束D: ‘static + FromNapiValue，而 napi-rs 默认会为数值、字符串、布尔等基本 JS 数据类型实现FromNpiValuetrait，但是如果我们的 JS 回调想要返回一个对象时，则需要自己手动实现FromNpiValuetrait，这样可以让call_async获取到 JS 返回数据时自动调用FromNpiValuetrait 的from_napi_value方法将 JS 返回数据转换为 Rust 的数据格式，以下是一个简单的示例。 假如需要在 Rust 调用一个 JS 函数，JS 函数会返回一个对象，包含三个字段： 12345&#123; setPageName?: string, changeExt?: boolean, setSubPkgName?: string&#125; 我们需要在 Rust 中获取到返回的对象，并转为 Rust 数据，那么首先我们可以定义一个类似的数据结构：123456#[derive(Debug)]pub struct JSReturnObject &#123; pub set_page_name: Option, pub change_ext: Option, pub set_sub_pkg_page_name: Option,&#125; 同时为它实现FromNpiValuetrait 就可以了：1234567891011121314151617181920212223impl FromNapiValue for JSReturnObject &#123; unsafe fn from_napi_value(env: napi_env, napi_val: napi_value) -&gt; Result &#123; let obj = JsObject::from_napi_value(env, napi_val)?; let mut js_return_object = JSReturnObject &#123; set_page_name: None, change_ext: None, set_sub_pkg_page_name: None, &#125;; let has_set_page_name = obj.has_named_property(&quot;setPageName&quot;)?; let has_change_ext = obj.has_named_property(&quot;changeExt&quot;)?; let has_set_sub_pkg_page_name = obj.has_named_property(&quot;setSubPkgName&quot;)?; if has_set_page_name &#123; js_return_object.set_page_name = Some(obj.get_named_property::(&quot;setPageName&quot;)?); &#125; if has_set_sub_pkg_page_name &#123; js_return_object.set_sub_pkg_page_name = Some(obj.get_named_property::(&quot;setSubPkgName&quot;)?); &#125; if has_change_ext &#123; js_return_object.change_ext = Some(obj.get_named_property::(&quot;changeExt&quot;)?); &#125; Ok(js_return_object) &#125;&#125; 在上述代码中，先调用JsObject::from_napi_value方法将传入数据转为JsObject，然后调用 JsObject的has_named_property方法获取到对应的属性值，经过处理后可以构建出JSReturnObject结构体数据，并进行返回。而使用的时候，为call_async指定泛型参数类型为JSReturnObject，接下来就可以获取到 JS 返回值进行处理了。1234let result: JSReturnObject = js_handler .call_async(Ok(options.clone())) .await .with_context(|| format!(&quot;模板自定义函数调用失败: &#123;&#125;&quot;, file_relative_path))?; 使用 VSCode 进行调试我们可以使用 VSCode 来调试我们的 napi-rs 应用，我们可以参考Taro 项目，在项目的 .vscode 目录下新增 launch.json 配置如下：123456789101112131415161718192021222324&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;lldb&quot;, // 调试器类型，这里指定为lldb，通常用于C/C++/Rust等语言 &quot;request&quot;: &quot;launch&quot;, // 请求类型，可以是&apos;launch&apos;或&apos;attach&apos;，&apos;launch&apos;表示启动一个新的调试会话 &quot;name&quot;: &quot;debug-init&quot;, // 配置名称，显示在VS Code的启动配置下拉菜单中 &quot;sourceLanguages&quot;: [&quot;rust&quot;], // 指定源码语言，此处为Rust &quot;program&quot;: &quot;node&quot;, // 要调试的程序，这里是指Node.js的可执行文件 &quot;args&quot;: [ // 程序参数，这里指定了使用node运行taro-cli包的初始化命令，创建一个名为test_pro的新项目 &quot;$&#123;workspaceFolder&#125;/packages/taro-cli/bin/taro&quot;, &quot;init&quot;, &quot;test_pro&quot; ], &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 当前工作目录，这里指工作区根目录 &quot;preLaunchTask&quot;: &quot;build binding debug&quot;, // 调试前需要执行的任务的名称，这里指定了一个任务以在调试前构建项目 &quot;postDebugTask&quot;: &quot;remove test_pro&quot; // 调试后需要执行的任务的名称，此处指定了一个任务以在调试后清理或删除test_pro项目 &#125;, ]&#125; 在上述配置中，指定调试器类型为lldb，启动一个新的调试会话来调试我们用 Rust 编写的程序，该程序主要通过 Node.js 来执行一个初始化新项目 test_pro 的命令，在调试开始前后会飞别执行 Rust binding 的构建以及 test_pro 项目的删除。 然后在要调试的代码处添加断点，然后执行调试即可。 构建发布napi-rs 的项目模板默认基于 Github Action 来实现自动构建产物及发布，并且已经有相当完整的配置了，从Github Action配置文件中可以看到 CI 具体执行的任务，CI 任务首先会执行 package.json 中的构建命令，构建出各个端的 binding，并会actions/upload-artifact@v3action 将构建产物上传，然后会对构建产物执行相关测试，测试通过后会将构建产物下载下来，并执行artifacts命令将构建产物移动到目的文件夹下，最后会进行发布，当 git 提交信息为semver规范版本号时，将会触发 CI 发布，将包发到 NPM 中去。1$ git commit -m &apos;0.0.1&apos; 前面提到我们一般只需要针对x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台进行构建，所以我们可以调整 Github Action 配置，去掉不需要构建的平台以提升 CI 速度。 此外，当我们有特殊需求的时候，例如不需要重新生成胶水 JS 代码、需要将构建产物移动到其他目录（默认是当前目录下的 npm 目录）下等等，可以查看@napi-rs/cli的文档进行相应调整。 不需要重新生成胶水 JS 代码，可以通过在napi build命令下添加–no-js实现：123456&quot;scripts&quot;: &#123; ... &quot;build&quot;: &quot;napi build --platform --release --no-js --dts binding.d.ts&quot;, &quot;build:debug&quot;: &quot;napi build --platform --no-js --dts binding.d.ts&quot; ...&#125; 需要将构建产物移动到其他目录，可以通过在napi artifacts命令下添加 –cwd 和 –npm-dir 参数来实现，前者指定工作目录，后者指定要移动的目录的相对路径12345&quot;scripts&quot;: &#123; ... &quot;artifacts&quot;: &quot;napi artifacts --npm-dir ../../npm2 --cwd ./&quot;, ...&#125; 总结Rust 在前端领域的应用无疑将成为未来的重要发展趋势，随着越来越多的公司和团队开始投入到这一领域，我们看到了 Rust 在前端研发生态构建中的独特优势和潜力，Rust 的高效性和安全性使其成为优化 Node 工具的理想选择。本文简单介绍了如何使用 NAPI-RS 来开发、调试和发布 Node 扩展，可以有效地优化我们的开发工具，并提升其性能。 在未来，我们可以预见 Rust 与前端结合的可能性将会更加广泛。随着 WebAssembly（WASM）的发展，我们可以期待 Rust 将在前端应用的性能优化、复杂应用的开发以及多线程等领域发挥更大的作用。同时，Rust 的出色的内存管理和错误处理机制也将帮助前端开发者构建更加健壮、安全的应用。 当然，Rust 与前端的结合并不仅仅限于性能优化，Rust 的优秀特性，如模式匹配、类型推断和零成本抽象，也为前端开发带来了新的编程范式和思维方式，这将有助于提升前端代码的可读性和可维护性，为前端开发提供了新的思考角度和工具，并可能引领前端开发进入一个全新的阶段。 来自","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"/tags/Rust/"}]},{"title":"solidity进阶","slug":"solidity进阶","date":"2025-03-11T01:56:30.000Z","updated":"2025-03-11T05:33:38.778Z","comments":true,"path":"2025/03/11/solidity进阶/","link":"","permalink":"/2025/03/11/solidity进阶/","excerpt":"solidity进阶-ERC20代币开发","text":"solidity进阶-ERC20代币开发 什么是ERCERC 全称是“Ethereum Request for Comment”，表示以太坊的意见征求稿，ERC 中包含技术和组织等注意事项及标准。这套标准其实不光由以太坊官方提出，还由一些以太坊爱好者提出。是以太坊生态系统中被广泛使用的关键标准。 代币(token)标准 ERC-20 - 同质化（可互换）代币的标准接口，比如投票代币、质押代币或虚拟货币。 ERC-721 - 非同质化代币的标准接口，比如艺术作品或歌曲的契约。 ERC-777 - 关于 ERC-20 的代币标准改进。 ERC-1155 - 一个能包括同质化和非同质化资产的代币标准。 ERC-20 代币千言万语汇成一句话：造钱 什么叫做代币 代替货币 代币可以在以太坊中表示任何东西： 在线平台中的信誉积分 游戏中一个角色的技能 彩票 金融资产类似于公司股份的资产 像美元一样的法定货币 一克黄金 以及更多 ERC-20以太坊代币标准是创建与更广泛的以太坊网络兼容的可替换代币的蓝图。以太坊，或称Ethereum，是一种加密货币，允许创建各种应用，包括代币，与大多数传统应用不同，它不需要中心化服务机构就可以运作。 简单来说，ERC-20就是一套基于以太坊网络的标准代币发行协议。有了ERC-20，开发者们得以高效、可靠、低成本地创造专属自己项目的代币；我们甚至可以将ERC-20视为以太坊网络为早期区块链世界做出的最重要贡献，也是以太坊网络第一个真正意义上的杀手级应用。 如果我们把众多区块链项目的开发者，看作是在一个小区门口商铺里，经营不同业态的众多商户。这些商户根据自己的专长提供各自不同的商品和服务，也都希望发行自己店铺专属的消费储值卡。方便消费者光顾的同时，也能提升用户的体验和粘性 以太坊就像是运营这个小区底商的物业公司，它提供一整套标准化的储值卡发放协议和配套服务。借助这套叫做ERC-20的整体解决方案，每个商户（开发者）都可以傻瓜式地发行专属于自己店铺的消费储值卡，同时由于这种储值卡采用了统一的协议，可以非常方便地和其他商户的储值卡做无缝兑换。 于是借助ERC-20，用户可以通过持有其中一种储值卡（token）很方便地享受整个生态的各种服务；商户（开发者）则节约了开发运营成本、同时提升了获取用户的效率；而物业公司（以太坊基金会和矿工）则可以通过做大生态体量实现更多的租金（ETH增值）和储值卡结算手续费（Gas费用）收入。 ERC-20就是用这种做大生态价值的方式，实现了用户、开发者和以太坊网络三方面的共赢。 ERC-20的应用案例 为了让你对ERC-20有更具象化的认识，这里援引 Alyssa Hertig 在 What is the ERC-20 Ethereum Token Standard? 中列举的一些比较知名的基于ERC-20协议代币： Tether (USDT)Chainlink (LINK)Binance coin (BNB)USD coin (USDC)Wrapped bitcoin (WBTC)Dai (DAI) 需要特别指出的是，这上面提到的Tether发行的稳定币USDT除了基于ERC-20协议的版本之外，其实还有基于其他公链发行的多个版本，只不过ERC-20版的发行量最大，知名度也最高。 openzeppelin 智能合约库官网：https://www.openzeppelin.com/ GitHub：https://github.com/OpenZeppelin/openzeppelin-contracts OpenZeppelin 是一个使用以太坊智能合约语言 Solidity 进行构建的开发框架，可以简化智能合约和 Dapp 的开发。 OpenZeppelin合约和库已成为行业标准，其开源代码模板经历了以太坊及其他区块链的实战考验，帮助开发者最大限度降低风险。OpenZeppelin代码包括使用度最高的ERC标准及拓展部署，已被社区在各类指南以及操作教程中大量使用。 Contract WizardOpenZeppelin开发了一种基于网络的线上智能合约交互式工具，它可能是使用OpenZeppelin代码编写智能合约最简单快捷的方式。这一工具称为Contracts Wizard。 ERC-20 代币实现https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol https://www.openzeppelin.com/contracts https://ethereum.org/zh/ https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions ERC-20（以太坊意见征求 20）由 Fabian Vogelsteller 提出于 2015 年 11 月。这是一个能实现智能合约中代币的应用程序接口标准。 ERC-20 的功能示例包括： 将代币从一个帐户转到另一个帐户 获取帐户的当前代币余额 获取网络上可用代币的总供应量 批准一个帐户中一定的代币金额由第三方帐户使用 如果智能合约实施了下列方法和事件，它可以被称为 ERC-20 代币合约， 一旦部署，将负责跟踪以太坊上创建的代币。 方法 123456789function name() public view returns (string)function symbol() public view returns (string)function decimals() public view returns (uint8)function totalSupply() public view returns (uint256)function balanceOf(address _owner) public view returns (uint256 balance)function transfer(address _to, uint256 _value) public returns (bool success)function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)function approve(address _spender, uint256 _value) public returns (bool success)function allowance(address _owner, address _spender) public view returns (uint256 remaining) 事件 12event Transfer(address indexed _from, address indexed _to, uint256 _value)event Approval(address indexed _owner, address indexed _spender, uint256 _value) 代币112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;contract QfCoin &#123; event Transfer(address, address, uint256); event Approval(address, address, uint256); mapping(address =&gt; uint256) public balanceOf; // override 重载 mapping(address =&gt; mapping(address =&gt; uint256)) public allowance; uint256 public totalSupply; string public name; string public symbol; uint8 public decimals = 18; constructor(string memory _name, string memory _symbol) &#123; name = _name; symbol = _symbol; &#125; // transfer() 函数 IERC20 中的 transfer 函数， Token 实现。调用方 amount 币会增加 Token 数量，接收方此函数相应的狗改土，加入、分红、抽奖等。 // 转账函数 function transfer(address recipient, uint256 amount) public returns (bool) &#123; balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true; &#125; // approve 函数 // approve() 函数：IERC20 的 approve 函数， Token 授权逻辑。被授权方 spender 可以控制授权方的 amount 数量的 Token 。 function approve(address spender, uint256 amount) public returns (bool) &#123; allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; &#125; // transferFrom() 功能：IERC20 中的 transferFrom 函数，授权逻辑。被授权方将授权方实现 sender 的 amount 数量的 Token 授权给接收方 recipient。 function transferFrom( address sender, address recipient, uint256 amount ) public returns (bool) &#123; allowance[sender][msg.sender] -= amount; balanceOf[sender] == amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; &#125; function mint(uint256 amount) public &#123; balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount); &#125;&#125; 代币2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// SPDX-License-Identifier: MITpragma solidity ^0.8.9;contract MyToken &#123; /* &#123; addressA: 90, addressB: 0, addressC: 20, &#125; */ event Transfer(address _from, address _to, uint256 _value); event Approval(address _owner, address _spender, uint256 _value); // 代币的名字与标识 数量 uint256 _totalSupply; string _name; string _symbol; uint8 _decimals; // 创建地址与余额的映射 mapping(address =&gt; uint256) _balanceOf; // 创建授权额度的结构 mapping(address =&gt; mapping(address =&gt; uint256)) _allowance; /* address1 : &#123; address11:1000w address22:200w &#125; address3:&#123; address11:1000w address22:200w &#125; */ constructor() &#123; _name = &quot;HeHeCoin&quot;; _symbol = &quot;HHC&quot;; _decimals = 18; _totalSupply = 100 * 10000 * 10**_decimals; _balanceOf[msg.sender] += _totalSupply; &#125; // 获取一下代币的名字 function name() public view returns (string memory) &#123; return _name; &#125; function symbol() public view returns (string memory) &#123; return _symbol; &#125; function decimals() public view returns (uint8) &#123; return _decimals; &#125; function totalSupply() public view returns (uint256) &#123; return _totalSupply; &#125; // 根据地址获取余额 function balanceOf(address _owner) public view returns (uint256) &#123; return _balanceOf[_owner]; &#125; // 转账 function transfer(address _to, uint256 _value) public returns (bool success) &#123; _balanceOf[msg.sender] -= _value; _balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; &#125; // token的逻辑授权 给被授权方一定的权限 可以直接转移授权方的同肯 function approve(address _spender, uint256 _value) public returns (bool success) &#123; // 调用这个方法的人 _allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; &#125; // 查看额度 function allowance(address _owner, address _spender) public view returns (uint256) &#123; return _allowance[_owner][_spender]; &#125; // 被给与额度的账户主动的 划走代币 function transferFrom( address _from, address _to, uint256 _value ) public returns (bool success) &#123; // 额度减少 _allowance[_from][_to] -= _value; // 被划走账户余额减少 _balanceOf[_from] -= _value; // 划走账户的余额添加 _balanceOf[_to] += _value; return true; &#125;&#125;/*0x5B38Da6a701c568545dCfcB03FcB875f56beddC40xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb20x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB&#123; 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 : &#123; 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2: 100w, 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db: 50w, &#125; 0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB : &#123; 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2:666, 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db:777, &#125;&#125;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 100w 授权 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 666授权 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db 777*/ ERC-20代币部署 将环境切换切MetaMask钱包环境并选择钱包账户 点击Deploy ，输入代币的名字和表示 部署合约 部署成功结果 合约地址 0x639DfECe957A8D705f028D1950890598C30789ed 交易hash 0x28aa84834efc9c787c4cd584128f456e16b933eddf250859833b395656153847 在metaMask 添加代币 智能合约初始化的时候没有规定代币的数量，所以添加结果为0MTC 后续通过mint 铸造方法，添加货币 接下来就可以在测试网络中进行代币转账了 Web3.js 和 ether.js 介绍Web3.js 和 ethers.js 都是 JavaScript 库，其作用是使开发者可以与以太坊区块链交互。这两个库都很实用，都能满足大多数以太坊开发者的需求。下面将重点围绕 Web3.js 和 Ethers.js 的相同点和不同点来对它们进行比较，以便你能更好地理解它们的细微区别。 什么是 web3.js？ Web3.js 是一个由以太坊基金会开发和维护的开源JavaScript库，使用HTTP或 IPC(Inter-Process Communication进程间通信) 连接 或 WebSocket 来和本地或远程以太坊节点进行交互的库。类比于 JavaScript库 axios 对 Web 服务器进行 Ajax 调用，您可以使用Web3.js来读取和写入以太坊区块链。 web3.js。因此，有更广泛的支持，因为有更多的开发人员支持它。 Web3.js 库由一系列模块的集合，服务于以太坊生态系统的各个功能，如： ●web3-eth 用来与以太坊区块链及合约的交互； ●web3-shh Whisper 协议相关，进行p2p通信和广播； ●web3-bzz swarm 协议（去中心化文件存储）相关； ●web3-utils 包含一些对 DApp 开发者有用的方法。 官网：https://web3js.org GitHub: https://github.com/web3/web3.js 什么是 ethers.js？ ETHERS.JS ethers.js库旨在为以太坊区块链及其生态系统提供一个小而完整的 JavaScript API 库，ethers.js 对比使用 web3.js 代码量更少，接口也更简洁。 可以通过JSON-RPC、INFURA、Etherscan、Alchemy、Cloudflare或MetaMask连接到以太坊节点。 与 web3.js 相似，ethers.js 常用模块有: ●Ethers.provider 封装与以太坊区块链的连接。它可以用于签发查询和发送已签名的交易，这将改变区块链的状态。 ●Ethers.contract 部署智能合约并与它交互。具体来说，该模块中的函数用于侦听从智能合约发射的事件、调用智能合约提供的函数、获取有关智能合约的信息，以及部署智能合约。 ●Ethers.utils 提供用于格式化数据和处理用户输入的实用程序函数。Ethers.utils 的作用方式与 web3-utils 相似，能够简化去中心化应用的构建流程。 ●Ethers.wallets 提供的功能与我们目前讨论过的其他模块截然不同。Ethers.wallet 的作用是使你可以与现有钱包（以太坊地址）建立连接、创建新钱包以及对交易签名。 官网：https://ethers.org GitHub：https://github.com/ethers-io/ethers.js web3.js 和 ethers.js 该如何选择 作者对比 Web3.js 所有者是以太坊基金会 ethers.js 所有者是Richard Moore 两个库都能够完成任务。Ethers.js 在近两年来越来越受欢迎，下载量和项目使用量都不断增加。Web3.js 一直以来都作为标杆存在，并且仍然拥有许多开发者共享资源。后面将介绍如何连接到 Infura API 并使用 web3.js 和 ethers.js 发送交易。 web3 与智能合约 获取合约部署后的配置文件 在 artifacts 下的的 合约名.json文件 https://web3js.readthedocs.io/en/v1.8.1/ window.ethereum APIMetaMask会向网页注入一个全局的API变量window.ethereum，出于历史遗留原因， 这个全局API变量也可以使用window.web3.currentProvider来访问。该API允许 网站请求用户登录，可以从用户接入的区块链读取数据，并切能够提示用户签名 要提交的交易。 你可以使用这个API来检测一个浏览器是否注入了window.ethereum： 123if (typeof window.ethereum !== 'undefined') &#123; console.log('MetaMask is installed!');&#125; ethereum API本身很简单，它同时也封装了以太坊JSON-RPC消息，就像那些流行的库例如web3、 truffle、ethjs、Embark等等一样。 ethereum.isConnected()如果提供者连接到当前链返回true，否则返回false。 如果提供商未连接，则必须重新加载页面才能重新建立连接。 eth_requestAccounts - 请求用户授权12345678910//调用方式1ethereum.request(&#123; method: 'eth_requestAccounts' &#125;) .then(function (accounts) &#123; // You now have an array of accounts! // Currently only ever one: // ['0xFDEa65C8e26263F459A1B5de9555D2931A33b825'] &#125;) .catch(function (reason) &#123; console.log(reason === \"User rejected provider access\") &#125;) ethereum.selectedAddress - 获取当前用户账号ethereum.selectedAddress 属性返回表示用户当前选择的以太坊账号，16进制字符串表示 ethereum.isMetaMask - 检测是否使用MetaMaskethereum.isMetaMask返回true或false，表示当前用户是否安装了MetaMask。 ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新当用户切换网络时，MetaMask扩展会自动刷新。 ethereum.autoRefreshOnNetworkChange这个实验性质的属性允许你关闭 默认的网络切换自动刷新功能。 ethereum.on() - 监听MetaMask事件ethereum.on()方法用来监听MetaMask的事件，其原型如下： 1ethereum.on(eventName, callback) 其中： eventName：要监听的事件名称 callback：事件触发时的回调函数 目前支持下列事件： accountsChanged：当用户选中账号变化时触发 networkChanged：当所连接网络ID变化时触发 注意：networkChanged事件只有当你禁用ethereum.autoRefreshOnNetworkChange属性时才有用。 下面的代码在用户切换MetaMask账号后输出新账号到控制台： 123ethereum.on('accountsChanged', function (accounts) &#123; console.log(accounts[0])&#125;) 调用智能合约(MetaMask)实例web3123456const Web3 = require(\"web3\");import mtcContract from \"./contracts/contract_Ballot.json\";// 链接上web3 格尔丽的环境const geerliWS = \"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb\";var web3 = new Web3(Web3.givenProvider || geerliWS); 账户链接1const account = await web3.eth.requestAccounts(); 实例合约12345new web3.eth.Contract(智能合约abi,合约地址)this.votoContract = new web3.eth.Contract( mtcContract.abi, \"0x1D108E4B9162668e1adACD07727b3de749818d0a\" ); 方法 不需要消耗gas的方法 call (不修改数据的) 1myContract.methods.myMethod([param1[, param2[, ...]]]).call(options [, defaultBlock] [, callback]) 12345678910// using the callbackmyContract.methods.myMethod(123).call(&#123;from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'&#125;, function(error, result)&#123; ...&#125;);// using the promisemyContract.methods.myMethod(123).call(&#123;from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'&#125;).then(function(result)&#123; ...&#125;); 修改数据消耗gas的方法 send 1myContract.methods.myMethod([param1[, param2[, ...]]]).send(options[, callback]) 12345678910// using the callbackmyContract.methods.myMethod(123).send(&#123;from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'&#125;, function(error, transactionHash)&#123; ...&#125;);// using the promisemyContract.methods.myMethod(123).send(&#123;from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'&#125;).then(function(receipt)&#123; // receipt can also be a new contract instance, when coming from a \"contract.deploy(&#123;...&#125;).send()\"&#125;); 注意:数据修改完成后根据需求监听receipt事件 事件1myContract.events.MyEvent([options][, callback]) 12345678910111213141516myContract.events.MyEvent(&#123; filter: &#123;myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'&#125;, // Using an array means OR: e.g. 20 or 23 fromBlock: 0&#125;, function(error, event)&#123; console.log(event); &#125;).on(\"connected\", function(subscriptionId)&#123; console.log(subscriptionId);&#125;).on('data', function(event)&#123; console.log(event); // same results as the optional callback above&#125;).on('changed', function(event)&#123; // remove event from local database&#125;).on('error', function(error, receipt) &#123; // If the transaction was rejected by the network with a receipt, the second parameter will be the receipt. ...&#125;); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div&gt; &lt;h1&gt;web3 与智能合约&lt;/h1&gt; &lt;h1&gt;代币信息&lt;/h1&gt; 名称: &#123;&#123; name &#125;&#125; &lt;br&gt; 标识: &#123;&#123; symbol &#125;&#125; &lt;br&gt; 发行量 &#123;&#123; web3.utils.fromWei(totalSupply,&quot;ether&quot; ) &#125;&#125; &lt;br&gt; &lt;hr&gt; &lt;h2&gt;账户信息&lt;/h2&gt; 地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br&gt; 余额: &#123;&#123;web3.utils.fromWei(balanceOf,&quot;ether&quot;)&#125;&#125; &lt;br&gt; &lt;hr&gt; &lt;h2&gt;操作&lt;/h2&gt; 收款方: &lt;input type=&quot;text&quot; v-model=&quot;toAddress&quot;&gt; &lt;br&gt; 金额:&lt;input type=&quot;text&quot; v-model=&quot;money&quot;&gt; &lt;br&gt; &lt;button @click=&quot;send&quot;&gt;转账&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const Web3 = require(&quot;web3&quot;);import &#123; abi &#125; from &quot;./contracts/HHC.json&quot;;console.log(abi);export default &#123; data() &#123; return &#123; name:&quot;&quot;, symbol:&quot;&quot;, totalSupply: &quot;&quot;, balanceOf: &quot;&quot;, accounts:[], toAddress: &quot;0xE251ddBe6191594922bfd3d338529EC9C613eB67&quot;, money:1, &#125; &#125;, methods: &#123; // 初始化web3实例 async initWeb3() &#123; const geerliWS = &quot;wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;; this.web3 = new Web3(Web3.givenProvider || geerliWS); // 获取metamask钱包使用的用户 this.accounts = await this.web3.eth.requestAccounts(); console.log( this.accounts) this.initContract(); &#125;, // 初始化智能合约 initContract() &#123; // 代币 hhc 智能合约地址 this.HccCont = new this.web3.eth.Contract( abi, &quot;0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5&quot; ); this.getCoinInfo(); this.addEvents(); &#125;, // 获取代币的信息 async getCoinInfo() &#123; // 不修改状态数据 不消耗gas this.name = await this.HccCont.methods.name().call(); this.symbol = await this.HccCont.methods.symbol().call(); this.totalSupply = await this.HccCont.methods.totalSupply().call(); this.balanceOf = await this.HccCont.methods.balanceOf(this.accounts[0]).call(); &#125;, send() &#123; // 修改状态数据 const weiNum = this.web3.utils.toWei(String(this.money), &apos;ether&apos;); console.log(weiNum) this.HccCont.methods.transfer(this.toAddress,weiNum).send(&#123; from: this.accounts[0], &#125;) .on(&apos;receipt&apos;, function(receipt)&#123; console.log(&quot;交易成功&quot;) console.log(receipt) &#125;) &#125;, addEvents() &#123; this.HccCont.events.Transfer(&#123; filter: &#123;&#125;, fromBlock: 8161338, &#125;) .on(&quot;data&quot;,(event) =&gt; &#123; console.log(&quot;events transfer&quot;); console.log(event) &#125;) &#125; &#125;, created() &#123; if (typeof window.ethereum !== &quot;undefined&quot;) &#123; console.log(&quot;MetaMask is installed!&quot;); &#125; this.initWeb3(); &#125;,&#125;;&lt;/script&gt; 调用智能合约(纯web3) 调用智能合约也相当于是通过web3 发起一个交易 核心在于 web3.eth.sendSignedTransaction(transHash) 在构建hash数据时候将调用的合约信息添加进入 构建调用智能合约交易hash将智能合约的方法调用 通过encodeABI进行转化 1const contractData = await contract.methods.transfer(\"转账地址\",web3.utils.toWei('转账金额')).encodeABI() 123456789101112131415161718192021222324252627282930313233// 构建交易hashasync createTransationHx(key, fromAddress, toAddress, money) &#123; // key 私钥 // fromAddress 发送方地址 // toAddress 接受方地址 // money 转账金额 // 当前地址交易次数 const nonce = await web3.eth.getTransactionCount(fromAddress); var privateKey = new Buffer(key, \"hex\"); // 获取预计转账gas费 let gasPrice = await web3.eth.getGasPrice(); // 转账金额以wei为单位 let balance = await web3.utils.toWei(money);const contractData = await contract.methods.transfer(\"0x9B0DbF610175F5c783ec169DAdDa5E8B17055626\",web3.utils.toWei('30000')).encodeABI() // 转账的记录对象 var rawTx = &#123; from: fromAddress, nonce: nonce, gasPrice: gasPrice, to:\"\",//智能合约地址, value: 0, data: contractData, //转Token代币会用到的一个字段 &#125;; //需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中 let gas = await web3.eth.estimateGas(rawTx); rawTx.gas = gas; // 通过tx实现交易对象的加密操作 var tx = new Tx(rawTx); tx.sign(privateKey); var serializedTx = tx.serialize(); var transationHx = \"0x\" + serializedTx.toString(\"hex\"); return transationHx;&#125;, 常规转账发起1234567891011121314151617181920212223242526272829303132333435363738async sendToken() &#123; let pass = prompt(\"请输入密码\"); let keystore = this.walletInfo.keystore; let wallet; try &#123; wallet = await ethwallet.fromV3(keystore, pass); &#125; catch (error) &#123; alert(\"密码错误\"); return false; &#125; let prikey = wallet.getPrivateKey().toString(\"hex\"); console.log(prikey) const from = this.walletInfo.lowerCaseAddress; const to = this.to; const money = this.money; // 获取交易hx const transHash = await this.createTransationHx(prikey,from,to,money) // 发布交易信息 web3.eth .sendSignedTransaction(transHash) .on(\"transactionHash\", (txid) =&gt; &#123; console.log(\"交易成功,请在区块链浏览器查看\"); console.log(\"交易id\", txid); console.log(`https://goerli.etherscan.io/tx/$&#123;txid&#125;`); &#125;) .on(\"receipt\", (ret) =&gt; &#123; console.log(\"receipt\", ret); const &#123; transactionHash &#125; = ret; // 从区块节点中获取交易hash this.createOrderData(transactionHash); &#125;) .on('confirmation', (ret)=&gt;&#123; console.log('confirmation',ret) &#125;) .on(\"error\", (err) =&gt; &#123; console.log(\"error:\" + err); &#125;); &#125;, 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190&lt;template&gt; &lt;div&gt; &lt;h1&gt;web3 与智能合约&lt;/h1&gt; &lt;h1&gt;代币信息&lt;/h1&gt; 名称: &#123;&#123; name &#125;&#125; &lt;br /&gt; 标识: &#123;&#123; symbol &#125;&#125; &lt;br /&gt; 发行量 &#123;&#123; web3.utils.fromWei(totalSupply, \"ether\") &#125;&#125; &lt;br /&gt; &lt;hr /&gt; &lt;h2&gt;账户信息&lt;/h2&gt; 地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br /&gt; eth余额: &#123;&#123; web3.utils.fromWei(ethBalance, \"ether\") &#125;&#125;&lt;br /&gt; 代币余额: &#123;&#123; web3.utils.fromWei(balanceOf, \"ether\") &#125;&#125; &lt;br /&gt; &lt;hr /&gt; &lt;h2&gt;操作&lt;/h2&gt; 收款方: &lt;input type=\"text\" v-model=\"toAddress\" /&gt; &lt;br /&gt; 金额:&lt;input type=\"text\" v-model=\"money\" /&gt; &lt;br /&gt; &lt;button @click=\"send\"&gt;代币转账&lt;/button&gt; &lt;button @click=\"sendEth\"&gt;转账Eth&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const Web3 = require(\"web3\");const Tx = require(\"ethereumjs-tx\");import &#123; abi &#125; from \"./contracts/HHC.json\";console.log(abi);export default &#123; data() &#123; return &#123; name: \"\", symbol: \"\", totalSupply: \"\", balanceOf: \"\", accounts: [], toAddress: \"0xE251ddBe6191594922bfd3d338529EC9C613eB67\", money: \"1\", ethBalance: \"0\", &#125;; &#125;, methods: &#123; // 初始化web3实例 async initWeb3() &#123; const geerliWS = \"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb\"; this.web3 = new Web3(Web3.givenProvider || geerliWS); // 获取metamask钱包使用的用户 this.accounts = await this.web3.eth.requestAccounts(); console.log(this.accounts); this.ethBalance = await this.web3.eth.getBalance(this.accounts[0]); console.log(this.ethBalance); this.initContract(); &#125;, // 初始化智能合约 initContract() &#123; // 代币 hhc 智能合约地址 this.HccCont = new this.web3.eth.Contract( abi, \"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5\" ); this.getCoinInfo(); this.addEvents(); &#125;, // 获取代币的信息 async getCoinInfo() &#123; // 不修改状态数据 不消耗gas this.name = await this.HccCont.methods.name().call(); this.symbol = await this.HccCont.methods.symbol().call(); this.totalSupply = await this.HccCont.methods.totalSupply().call(); this.balanceOf = await this.HccCont.methods .balanceOf(this.accounts[0]) .call(); &#125;, // 通过metamask 调用智能合约 send() &#123; // 修改状态数据 const weiNum = this.web3.utils.toWei(String(this.money), \"ether\"); console.log(weiNum); this.HccCont.methods .transfer(this.toAddress, weiNum) .send(&#123; from: this.accounts[0], &#125;) .on(\"receipt\", function (receipt) &#123; console.log(\"交易成功\"); console.log(receipt); &#125;); &#125;, // 生成交易的hash 数据 async createTransationHx(prikey,from,to,money) &#123; console.log(\"money\",typeof money, money) // 当前地址交易次数 const nonce = await this.web3.eth.getTransactionCount(from); var privateKey = new Buffer(prikey, \"hex\"); // 获取预计转账gas费 let gasPrice = await this.web3.eth.getGasPrice(); // 转账金额以wei为单位 let value = await this.web3.utils.toWei(money); // 转账的记录对象 var rawTx = &#123; from, nonce: nonce, gasPrice: gasPrice, to,//智能合约地址, value: value, data:\"\", //转Token代币会用到的一个字段 &#125;; //需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中 let gas = await this.web3.eth.estimateGas(rawTx); rawTx.gas = gas; // 通过tx实现交易对象的加密操作 var tx = new Tx(rawTx); tx.sign(privateKey); var serializedTx = tx.serialize(); var transationHx = \"0x\" + serializedTx.toString(\"hex\"); return transationHx; &#125;, // 代币转账 async createCoinTransationHx(prikey,from,to,money) &#123; console.log(\"money\",typeof money, money) // 当前地址交易次数 const nonce = await this.web3.eth.getTransactionCount(from); var privateKey = new Buffer(prikey, \"hex\"); // 获取预计转账gas费 let gasPrice = await this.web3.eth.getGasPrice(); // 转账金额以wei为单位 let value = await this.web3.utils.toWei(money); // 转账的记录对象 // 代币转账 const contractAbi = await this.HccCont.methods.transfer(to,value).encodeABI(); var rawTx = &#123; from, nonce: nonce, gasPrice: gasPrice, to:'0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5',//eth 转账 to 目标地址 ，智能合约 to 智能合约地址 value: 0, //eth 转账 数量 data:contractAbi, //智能合约方法的abi编码 &#125;; //需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中 let gas = await this.web3.eth.estimateGas(rawTx); rawTx.gas = gas; // 通过tx实现交易对象的加密操作 var tx = new Tx(rawTx); tx.sign(privateKey); var serializedTx = tx.serialize(); var transationHx = \"0x\" + serializedTx.toString(\"hex\"); return transationHx; &#125;, // 通过纯web3调用智能合约 async sendEth() &#123; const prikey = \"71676f2ff44e36e78a276b16ac389ee8536790c8dfb12392c002050d6f162902\"; // 获取转账的hash const from = this.accounts[0]; // 代币hash const transHash = await this.createCoinTransationHx(prikey, from, this.toAddress, this.money); // 珠链币的hash // const transHash = await this.createTransationHx(prikey, from, this.toAddress, this.money); console.log(\"transHash\",transHash); // 发起交易 this.web3.eth .sendSignedTransaction(transHash) .on(\"transactionHash\", (txid) =&gt; &#123; console.log(\"交易成功,请在区块链浏览器查看\"); console.log(\"交易id\", txid); console.log(`https://goerli.etherscan.io/tx/$&#123;txid&#125;`); &#125;) .on(\"receipt\", (ret) =&gt; &#123; console.log(\"receipt\", ret); &#125;); &#125;, addEvents() &#123; this.HccCont.events .Transfer(&#123; filter: &#123;&#125;, fromBlock: 8161338, &#125;) .on(\"data\", (event) =&gt; &#123; console.log(\"events transfer\"); console.log(event); &#125;); &#125;, &#125;, created() &#123; if (typeof window.ethereum !== \"undefined\") &#123; console.log(\"MetaMask is installed!\"); &#125; this.initWeb3(); &#125;,&#125;;&lt;/script&gt; 以上内容来自千锋教育，并无商业用途，仅供学习使用。","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"WEB3","slug":"WEB3","permalink":"/tags/WEB3/"}]},{"title":"solidity入门","slug":"solidity入门","date":"2025-03-11T01:53:27.000Z","updated":"2025-03-11T05:23:41.472Z","comments":true,"path":"2025/03/11/solidity入门/","link":"","permalink":"/2025/03/11/solidity入门/","excerpt":"solidity语法基础入门","text":"solidity语法基础入门 Solidity 开发环境 Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。 以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常用的以太坊开发环境包括Truffle、Embark和Buidler （Hardhat）。 以太坊虚拟机：以太坊虚拟机（Ethereum Virtual Machine，EVM）是以太坊区块链的运行环境，用于在以太坊区块链上运行智能合约。常用的以太坊虚拟机包括ganache-cli和geth。 以太坊浏览器：以太坊浏览器是一种用于浏览、搜索和交互以太坊区块链数据的工具。常用的以太坊浏览器包括Etherscan、Etherchain和Blockchain Explorer。 Hardhathttps://hardhat.org/ Hardhat是目前最好的框架之一，支持快速测试，同时提供了最好的教程和最简单的集成。 老实说，每个喜欢JS框架的人都应该在某个时候试用Hardhat。它真的很容易上手，具有快速的测试， 而且入门非常简单。Hardhat的Discord也总是非常迅速地回答问题，因此，如果遇到问题，你 总是可以寻求帮助。Hathat使用Waffle和Ethers.js进行测试 —— 可以说是更好的JavaScript 智能合约框架 —— 开发人员的生活质量确实能得到一些改善。 Hardhat还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 这个项目给人一种很棒的感觉：很干净。它会执行你想要的操作。真的很快。该项目正在不断改进， Hardhat显然致力于使智能合约开发人员的生活更轻松。 Hardhat概要： ETH基金会资助的项目，以前的名字是Builder技术：Javascript，Web3.js和Ethers.js插件，OpenZeppelin可升级合同插件， Etherscan插件，区块链分叉区块链：Hardhat运行时环境/本地、测试网、主网测试支持：Waffle维护：非常活跃支持：活跃开源 Trufflehttps://trufflesuite.com/ 几年来Truffle一直是以太坊智能合约的默认开发框架，这是有充分理由的。 Truffle是一个强大的框架，为其他许多人树立了标准。你很容易找到使用此平台的项目， 因此查找示例很容易。Truffle也可以很容易地与它的姊妹工具Drizzle和Ganache集成在一起。 特别是Ganache，它是工程师运行本地区块链的最流行方法之一。对于那些正在寻找更多工具的人， 你可以为升级的Truffle团队帐户付费，并可以访问智能合约的持续集成，可视化部署和监视。 Truffle还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 Truffle的开发团队显然是一群有才华的工程师，他们想要使世界成为一个更好的智能合约场所。 Truffle测试的运行速度不如hardhat那样快，并且由于用户数量众多，获得支持可能很困难。 我很期待看到被ConsenSys收购后他们将如何改善这个项目。Truffle的文档质量似乎开始下降 并且很难遵循，但是如果你用Google搜索遇到的错误，则很可能会遇到遇到该错误并已解决的人。 我发现改善项目的一些最佳方法是在GitHub上发布问题。无论如何，保持生态系统不断壮大是我们 的开源职责！ 由于几乎每个人都熟悉它，因此获得同行的支持通常很容易。我真的希望看到团队在这个项目 上获得更多支持，因为他们有这么多用户。我希望他们能看到本文并致力于改善其文档，以使 其能够继续作为测试和部署智能合约的首选平台之一。 Truffle概要： 使用最广泛的平台；最近被ConsenSys收购（2020年11月）技术：Javascript，Web3.js，OpenZeppelin可升级合同插件，Etherscan插件，区块链分叉区块链：Ganache /本地，测试网，主网有测试维护：非常活跃支持：活跃开源，可以付费升级 EmbarkEmbark是整个DAPP框架。这是一个全栈的区块链平台。在Gitter的 一些帮助下，我能够将Chainlink合约部署到Kovan网络。它带有一个UI，允许你在GUI中与区块链 和合约进行交互。Embark有一段学习曲线，我没有花足够的时间来克服，但它展示了其潜力。这就是 为什么我想将其包括在这里的原因，因为我觉得我没有完全消化很多东西。 我希望看到人们更多地尝试该框架并看到其功能。由于在项目中花费的时间有限，我觉得我可能 无法在这里做到公正。我确实认为将前端与后端解耦仍然是最佳做法，但是如果你需要启动一个 具有良好前端的项目并且不关心解耦，那么您应该100％尝试这个项目。 这是一个很酷的项目，如果有人喜欢Hardhat和Truffle，并且又想与全栈解决方案集成，那么我愿意 推荐Embark给他。 Embark概要： 具有大量功能的JavaScript框架用于前端开发技术：JavaScript，Web3.js，代理合约支持区块链：Ganache /本地，测试网，主网支持测试维护：轻度活跃支持：活跃开源 Remix基本使用Remix 是以太坊智能合约编程语言Solidity IDE，其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。官网 https://remix.ethereum.org/。 Remix基本功能 合约创建 如上图创建一个空的工作空间 在工作空间下创建一个智能合约文件,ex: HelloWord.sol 智能合约文件以.sol结尾， 文件名采用大驼峰命名法 文件名和合约名保持一致 编写合约代码 12345678910111213// SPDX-License-Identifier: MIT; // 智能合约的许可协议pragma solidity ^0.8.7;// 智能合约的适用版本contract HelloWord &#123; string name; function get() public view returns (string memory)&#123; return name; &#125; function set (string memory _name) public &#123; name = _name; &#125;&#125; 合约编译 编译结果： 目录产生一个artifacts 文件夹 合约部署 通过第四个菜单进入部署界面 选择部署环境 选择部署合约的账户地址 设置gas限制 选择要部署的合约 deploy按钮进行部署 部署成功效果 合约调试 通过函数的返回值查看变量 event Log ​ solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables &#123; event Log(address); event Log(uint); function doSomething() public &#123; uint timestamp = block.timestamp; // Current block timestamp address sender = msg.sender; // address of the caller emit Log(timestamp); emit Log(sender); &#125;&#125; 本地部署ReMix IDE在线Remix访问缓慢，如果你有很好的网络环境也可以本地部署一套。在本地部署Remix需要准备两个东西：一个是Remix-project，可以理解为Remix的前端；另一个是Remixd，可以理解为Remix的后端，它们的Github仓库地址分别是：https://github.com/ethereum/remix-projecthttps://github.com/ethereum/remix-project/tree/master/libs/remixd Docker方式安装如果要运行合并到主分支中的最新更改，请运行： 12docker pull remixproject/remix-ide:latestdocker run -p 8080:80 remixproject/remix-ide:latest 如果你想运行最新的 remix-live 版本运行。 12docker pull remixproject/remix-ide:remix_livedocker run -p 8080:80 remixproject/remix-ide:remix_live docker-compose方式安装12docker-compose pulldocker-compose up -d 部署 RemixdRemixd 的安装使用步骤如下： 1.通过 npm 或者 yarn 安装 Remixd（建议用yarn） npm 命令： 12npm install -g @remix-project/remixdyarn add global @remix-project/remixd 2.启动 Remix-IDE 1remixd -s ./shared_project -u http://localhost:8080 3.在 Remix-IDE 上点两下 一个点 Solidity，选择相应环境；另一个点 Connect to Localhost，连接本地环境 Solidity基础介绍认识一个最简单的存储合约 123456789101112131415161718// SPDX-License-Identifier: MIT; // 智能合约的许可协议pragma solidity ^0.8.7;// 智能合约的适用版本import &quot;&quot;;// 导入contract HelloWord &#123; string name; // 状态变量 // 函数 function get() public view returns (string memory)&#123; return name; &#125; function set (string memory _name) public &#123; name = _name; &#125;&#125; 授权协议 默认情况下，在发布源代码时加入机器可读许可证说明是很重要的。由于提供源代码总是涉及版权方面的法律问题，Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符,比如：// SPDX-License-Identifier: MIT 至于什么是SPDX 大家可以参考如下资料： 首先是SPDX，这是个组织名，其网站为：SPDX 许可证列表 |软件包数据交换 （SPDX）SPDX-License-Identifier 组合起来就是在指SPDX的许可证列表后面的格式为 ：+ SPDX的许可证列表中的某个许可证 比如上面例子中的MIT 许可： MIT 基本信息全名：MIT License 麻省理工学院许可证 标志符：MITMIT的具体内容特此免费授予获得（“软件”）副本的任何人不受限制地处理本软件的许可，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或出售本软件副本的权利 Solidity版本限制 第二行是告诉编译器源代码所适用的Solidity版本为&gt;=0.7.0 及 &lt;0.9.0 。这样的说明是为了确保合约不会在新的编译器版本中发生异常的行为。关键字 pragma 是告知编译器如何处理源代码的通用指令 执行原理在一个去中心化的世界，我们的程序并不紧紧活一台机器的CPU 上, 在一个去中心化的世界是由很多节点组成的P2P 网络。合约代码会在各节点上[Full Node]单独运行，而事实上P2P的各节点相互之间都不信任的，所以每个节点都会存一份自己的状态（Distributed Ledger,分布式账本），在该示例就是name，当调用set()的时候，大家都改变了name，此时需要一种共识机制（PoS），如果PoS认为name合法，此次调用完成。 否则回滚上一个name的值，因此每一次改变状态变量的调用都是以一个事务Transcation来执行。 Api文档https://solidity-by-example.org/ 变量 局部变量 在函数内部声明 不存储到链上 状态变量 在函数外部声明 状态变量是永久地存储在链上的值。 全局变量 内置提供有关区块链的信息比如block、msg等 全局变量 这些是全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息。 名称 返回 blockhash(uint blockNumber) returns (bytes32) 给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。 block.coinbase (address payable) 当前区块矿工的地址 block.difficulty (uint) 当前区块的难度 block.gaslimit (uint) 当前区块的gaslimit block.number (uint) 当前区块的number block.timestamp (uint) 当前区块的时间戳，为unix纪元以来的秒 gasleft() returns (uint256) 剩余 gas msg.data (bytes calldata) 完成 calldata msg.sender (address payable) 消息发送者 (当前 caller) msg.sig (bytes4) calldata的前四个字节 (function identifier) msg.value (uint) 当前消息的wei值 now (uint) 当前块的时间戳 tx.gasprice (uint) 交易的gas价格 tx.origin (address payable) 交易的发送方 1234567891011121314// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables &#123; function doSomething() public view returns(uint, address) &#123; // 内置全局变量 uint timestamp = block.timestamp; // 获取区块时间戳 address sender = msg.sender; // 获取区块地址 return (timestamp,sender); &#125;&#125; 状态变量 12345678910// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables &#123; uint public nun = 123; function doSomething() public&#123; nun ++; &#125;&#125; 局部变量 1234567891011// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables &#123; function doSomething() public pure returns(uint)&#123; uint num = 123; num ++; // 局部变量不保存每次使用都重置 return num; &#125;&#125; 在为变量命名时，请记住以下规则。 不应使用 Solidity 保留关键字作为变量名。例如，break或boolean变量名无效。 不应以数字(0-9)开头，必须以字母或下划线开头。例如，123test是一个无效的变量名，但是_123test是一个有效的变量名。 变量名区分大小写。例如，Name和name是两个不同的变量。 Solidity 可见性修饰符1.public – 所有合约与账号都可以调用2.private -只有在定义该函数的合约可以调用3.internal- 当前合约或者继承该合约的，类似java 里面的protected 关键字。4.external – 只有其他合约或者账号可以调用,定义该函数的合约不能调用,除非使用 this 关键字 函数 函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。 123456789101112// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.8.0 &lt;0.9.0;contract Storage &#123; function set() public &#123; // 定义函数 // ... &#125;&#125;function OutsideFunc(uint x) pure returns (uint) &#123; return x * 2;&#125; Solidity有两个关键字与函数输出相关：return和returns，他们的区别在于： returns加在函数名后面，用于声明返回的变量类型及变量名。 return用于函数主体中，返回指定的变量。 view和pure的用法 getter 类型的函数可以被view 或者 pure 修饰。 view 修饰的函数不能改变状态变量。pure 则既不能改变状态变量，也不取读取状态变量。 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract ViewPureTest &#123; uint public x = 1; // 不能改变状态变量. function addToX(uint y) public view returns (uint) &#123; return x + y; &#125; //函数中没有任何状态变量出现。 function add(uint i, uint j) public pure returns (uint) &#123; return i + j; &#125;&#125; 在我们无法确定该用view还是pure时，remix会给我们完善的提示信息 错误Errors 12&gt; assert(bool condition)&gt; − 如果不满足条件，此方法调用将导致一个无效的操作码，对状态所做的任何更改将被还原。这个方法是用来处理内部错误的。 require(bool condition) − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。 require(bool condition, string memory message) − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。它提供了一个提供自定义消息的选项。 revert() − 此方法将中止执行并将所做的更改还原为执行前状态。 revert(string memory reason) − 此方法将中止执行并将所做的更改还原为执行前状态。它提供了一个提供自定义消息的选项。 回退状态：但是gas费用是需要消耗 assert 合约内部错误 require 外部参数错误 1参数被2整除 assert 内部错误 Solidity 为应对失败，允许用户定义 error 来描述错误的名称和数据。 跟用错误字符串相比， error 更便宜并且允许你编码额外的数据，还可以用 NatSpec 为用户去描述错误。 1234567891011121314// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.4;error NotFoundUser(address account, uint256 uid);contract Token &#123; mapping(address =&gt; uint256) users; function getUser(address _account, uint256 _uid) public view &#123; uint256 uid = users[msg.sender]; if (uid &lt; _uid) &#123; revert NotFoundUser(_account, _uid); &#125; // ... 事件Event事件是能方便地调用以太坊虚拟机日志功能的接口。 solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract Variables &#123; event Log(address); event Log(uint); function doSomething() public &#123; uint timestamp = block.timestamp; // Current block timestamp address sender = msg.sender; // address of the caller emit Log(timestamp); emit Log(sender); &#125;&#125; 变量的数据位置数据位置在合约中声明和使用的变量都有一个数据位置，指明变量值应该存储在哪里。合约变量的数据位置将会影响Gas消耗量。 Solidity 提供4种类型的数据位置。 Storage Memory Calldata Stack Storage该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。 保存在存储区(Storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。 存储中的数据是永久存在的。存储是一个key/value库 存储中的数据写入区块链，因此会修改状态，这也是存储使用成本高的原因。 占用一个256位的槽需要消耗20000 gas 修改一个已经使用的存储槽的值，需要消耗5000 gas 当清零一个存储槽时，会返还一定数量的gas 存储按256位的槽位分配，即使没有完全使用一个槽位，也需要支付其开销 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract DataLocations &#123; struct MyStruct &#123; uint256 foo; &#125; mapping(uint256 =&gt; MyStruct) public myStructs; function funcStorage(uint8 _idx, uint _val) public &#123; // 从映射中获取结构体,storage 变量改变会影响状态变量的值 MyStruct storage myStruct = myStructs[_idx]; myStruct.foo = _val; &#125;&#125; Memory内存位置是临时数据，比存储位置便宜。它只能在函数中访问。 通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。 内存是一个字节数组，槽大小位256位（32字节） 数据仅在函数执行期间存在，执行完毕后就被销毁 读或写一个内存槽都会消耗3gas 为了避免矿工的工作量过大，22个操作之后的单操作成本会上涨 12345678910111213141516// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract DataLocations &#123; struct MyStruct &#123; uint256 foo; &#125; mapping(uint256 =&gt; MyStruct) public myStructs; function funcStorage(uint8 _idx, uint _val) public view returns (MyStruct memory) &#123; // 从映射中获取结构体,storage 变量改变会影响状态变量的值 MyStruct memory myStruct = myStructs[_idx]; myStruct.foo = _val; return myStruct; &#125;&#125; CalldataCalldata是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，Calldata是外部函数的参数(而不是返回参数)的默认位置。 Stack堆栈是由EVM (Ethereum虚拟机)维护的非持久性数据。EVM使用堆栈数据位置在执行期间加载变量。堆栈位置最多有1024个级别的限制。 可以看到，要永久性存储，可以保存在存储区(Storage)。 数据位置规则规则1 – 状态变量状态变量总是存储在存储区中。 12345678pragma solidity ^0.5.0; contract DataLocation &#123; // storage uint stateVariable; uint[] stateArray; &#125; 此外，不能显式地标记状态变量的位置。 1234567pragma solidity ^0.5.0; contract DataLocation &#123; uint storage stateVariable; // 错误 uint[] memory stateArray; // 错误 &#125; 规则2 – 函数参数与返回值函数参数包括返回参数都存储在内存中。 123456789101112pragma solidity ^0.5.0; contract DataLocation &#123; // storage uint stateVariable; uint[] stateArray; function calculate(uint num1, uint num2) public pure returns (uint result) &#123; return num1 + num2 &#125;&#125; 此处，函数参数 uint num1 与 uint num2，返回值 uint result 都存储在内存中。 规则3 – 局部变量值类型的局部变量存储在内存中。但是，对于引用类型，需要显式地指定数据位置。 12345678910111213141516171819202122232425pragma solidity ^0.5.0; contract Locations &#123; /* 此处都是状态变量 */ // 存储在storage中 bool flag; uint number; address account; function doSomething() public &#123; /* 此处都是局部变量 */ // 值类型 // 所以它们被存储在内存中 bool flag2; uint number2; address account2; // 引用类型，需要显示指定数据位置，此处指定为内存 uint[] memory localArray; &#125; &#125; 不能显式覆盖具有值类型的局部变量。 123456789function doSomething() public &#123; /* 此处都是局部变量 */ // 值类型 bool memory flag2; // 错误 uint Storage number2; // 错误 address account2; &#125; 规则4 – 外部函数的参数外部函数的参数(不包括返回参数)存储在Calldata中。 赋值的数据位置规则Solidity数据类型Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。 Solidity中，变量类型有以下几大类： 值类型 地址类型 引用类型 值类型 类型 保留字 取值 布尔型 bool true/false 整型 int/uint 有符号整数/无符号整数。 整型 int8 to int256 8位到256位的带符号整型数。int256与int相同。 整型 uint8 to uint256 8位到256位的无符号整型。uint256和uint是一样的。 定长浮点型 fixed/unfixed 有符号和无符号的定长浮点型 定长浮点型 fixedMxN 带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。 定长浮点型 ufixedMxN 无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。 地址类型地址类型表示以太坊地址，长度为20字节。地址可以使用.balance方法获得余额，也可以使用.transfer方法将余额转到另一个地址。 12345address x = 0x212;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); 复制 引用类型/复合数据类型Solidity中，有一些数据类型由值类型组合而成，相比于简单的值类型，这些类型通常通过名称引用，被称为引用类型。 引用类型包括： 数组 (字符串与bytes是特殊的数组，所以也是引用类型) struct (结构体) map (映射) “undefined”或“null”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。 要处理任何意外的值，应该使用错误处理来恢复整个交易，或者返回一个带有第二个bool 值的元组表示成功。 bool/布尔类型布尔值的取值范围为 true 和 false 。 默认值：false 123456789101112pragma solidity ^0.8.0;contract TestBool &#123; error NotEqual(bool A,bool B); bool public A; // false bool public B = true; //true // require(A==B,&quot;A not equal B&quot;); if (A != B) &#123; error NotEqual(A,B); &#125;&#125; 运算符：●!（逻辑非）●&amp;&amp; （逻辑与， “and” ）●|| （逻辑或， “or” ）●== （等于）●!= （不等于） int、uint/整数类型 int/uint：变长的有符号或无符号整型。变量支持的步长以8递增，支持从uint8到uint256，以及int8到int256。需要注意的是，uint和int默认代表的是uint256和int256。 int 有符号整型(包含负数) 默认为int256 不同位长的整形范围如下： int8 取值范围：-(2 7)到 2 7 -1 int16取值范围：-(2 15)到 2 15 -1 … intX取值范围：-(2X-1)到 2(X-1) -1 int256取值范围：-(2 255)到 2 255 -1 uint 无符号整型 默认为uint256 不同位长的整形范围如下： uint8取值范围：0 到 2 ** 8 - 1 uint16取值范围：0 到 2 ** 16 - 1 … uintX取值范围：0 到 2 ** X - 1 uint256取值范围：0 到 2 ** 256 - 1 对于整形 X，可以使用 type(X).min 和 type(X).max 去获取这个类型的最小值与最大值。 1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract TestIntval &#123; int8 public i8 = -1; int public i256 = 456; int public i = -123; // int 等同于 int256 // int 的最大最小值 int public minInt = type(int).min; int public maxInt = type(int).max; uint8 public u8 = 1; uint256 public u256 = 456; uint public u = 123; // uint 等同于 uint256 // uint 的最大最小值 uint public minUInt = type(uint).min; uint public maxUInt = type(uint).max; function mini() public pure returns(uint8)&#123; return type(uint8).max; &#125;&#125; address/地址默认值: 0x0000000000000000000000000000000000000000 20字节的16进制地址用来表示一个账户 或者合约地址 12345678910111213141516171819// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract TestAddress &#123; //与其他机器语言相区别的类型就是这个address 类型，160-bit/20byte address public myAddr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; //合约自己的地址 address contractAddress = address(this); //跟普通的地址类型一样，但多了两个方法 transfer/send 这两个方法后面章节会讲到 // address sender = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4); //可以使用 balance 属性来查询一个地址的余额 function getBalance() public view returns (uint256, uint256) &#123; require(myAddr.balance &lt; contractAddress.balance, &quot;1 must lg 2&quot;); return (myAddr.balance, contractAddress.balance); &#125;&#125; bytes/字节数组在计算机中的最小存储单位是 bit(位) 1byte等于8位 Solidity中，byte可以赋值为 16进制数字 单引号的单个或多个字符 定长字节数组 bytes1 后面数字1是表示1字节 bytes默认等于bytes1Bytes2 后面数字2是表示2字节Bytes3 后面数字3是表示3字节bytes4 后面数字4是表示4字节 … bytes32 后面数字32是表示32字节 bytes32 等价于 int256或uint256 的位数 成员变量 .length 表示这个字节数组的长度（只读） string/字符串 中文特殊字符需要用unicode编码 通过concat 方法进行拼接 bytes 和 string之间转化 string字符串不能通过length方法获取其长度。 keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))可以通过这个方法比较两个字符串是否相等。 abi.encodePacked(s1, s2):通过这个方法进行字符串合并拼接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract TestAddress &#123; string public str1 = &quot;123&quot;; // 中文不适用unicode编码报错 // string public str2 = =&quot;你好&quot;; string public str2 = unicode&quot;abc&quot;; function concat() public view returns(string memory) &#123; string memory result = string.concat(str1,str2); return result; &#125; function caoncat2(string memory _a, string memory _b) public pure returns(string memory) &#123; return string.concat(_a,_b); &#125; function caoncat3(string memory _a, string memory _b) public pure returns(bytes memory) &#123; bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); return bytes.concat(_ba,_bb); &#125; function caoncat4(string memory _a, string memory _b) public pure returns(string memory) &#123; bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); return string(bytes.concat(_ba,_bb)); &#125; // 比较s1和s2是否相等，相等返回true，不相等返回false function compareEqual(string memory s1, string memory s2) public pure returns (bool) &#123; // 不支持字符直接比较 return s1 == s2; // return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2)); &#125; // 将s1和s2合并为一个字节数组 function mergeS1AndS2ReturnBytes(string memory s1, string memory s2) public pure returns (bytes memory) &#123; return abi.encodePacked(s1, s2); &#125; // 将s1和s2合并为一个字节数组转换为string function mergeS1AndS2ReturnString(string memory s1, string memory s2) public pure returns (string memory) &#123; return string(abi.encodePacked(s1, s2)); &#125;&#125; Enum(枚举)枚举将一个变量的取值限制为几个预定义值中的一个。精确使用枚举类型有助于减少代码中的bug。 1234567891011121314151617181920212223242526ontract UserState &#123; // 枚举 //默认值是列表中的第一个元素 enum State &#123; Online, // 0 Offline, // 1 Unknown // 2 &#125; State public status; function get() public view returns (State) &#123; return status; &#125; // 通过将uint传递到输入来更新状态 function set(State _status) public &#123; status = _status; &#125; // 也可以是这样确定属性的更新 function off() public &#123; status = State.Offline; &#125; // delete 将枚举重置为其第一个值 0 function reset() public &#123; delete status; &#125;&#125; array/数组 T[k]: 元素类型为T，固定长度为K的数组 uint[5] T[]: 元素类型为T, 长度可以动态调整 一、固定长度的数组（Arrays）12345678910111213141516171819202122232425262728293031323334353637383940// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract MappingTest &#123; // 创建定长数组 uint256[5] public arr = [1, 2, 3, 4, 5]; // 定长数组求和 function getAll() public view returns (uint256) &#123; uint256 num = 0; for (uint256 i = 0; i &lt; arr.length; i++) &#123; num += arr[i]; &#125; return num; &#125; function get() public view returns (uint256[5] memory) &#123; return arr; &#125; // 获取定长数组长度 function getLenth() public view returns (uint256) &#123; return arr.length; &#125; // 修改长度失败 function changeLenth() public &#123; // arr.length = 7; &#125; // 修改内部数据 function change(uint256 _idx, uint256 _val) public &#123; arr[_idx] = _val; &#125; // push 修改 // function change(uint256 _val) public &#123; // arr.push(_val); // &#125;&#125; 二、可变长度的Arraysuint [] T = [1,2,3,4,5]，这句代码表示声明了一个可变长度的T数组，因为我们给它初始化了5个无符号整数，所以它的长度默认为5。 &gt;=0.5.0的版本中length方法只读，不可修改。 5版本之前支持length属性修改，缺失的以0补位 1uint [] T = [1,2,3,4,5]; 三、二维数组 - 数组里面放数组123456789101112131415161718// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract C &#123; uint256[2][3] T = [[1, 2], [3, 4], [5, 6]]; function T_len() public view returns (uint256) &#123; return T.length; // uint256: 3 &#125; function getT() public view returns (uint256[2][3] memory) &#123; return T; &#125; function change() public &#123; T[1][0] = 55; &#125;&#125; uint [2][3] T = [[1,2],[3,4],[5,6]]这是一个三行两列的数组，你会发现和Java、C语言等的其它语言中二位数组里面的列和行之间的顺序刚好相反。在其它语言中，上面的内容应该是这么存储uint [2][3] T = [[1,2,3],[4,5,6]]。 上面的数组T是storage类型的数组，对于storage类型的数组，数组里面可以存放任意类型的值（比如：其它数组，结构体，字典／映射等等）。对于memory类型的数组，如果它是一个public类型的函数的参数，那么它里面的内容不能是一个mapping(映射／字典)，并且它必须是一个ABI类型。 四、数组字面量 Array Literals / 内联数组 Inline Arrays12345678910111213// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract C &#123; function f() pure public &#123; g([1, 2, 3]); g([uint(1),2,3]) &#125; function g(uint[3] memory _data) pure public &#123; // ... &#125;&#125; 结构体 struct 通过基本数据类型来组合成自定义复杂的数据类型 语法结构: 12345struct 关键字 结构体名称 &#123; 类型1 属性名1; 类型2 属性名2； ....&#125; 声明结构体 12345struct Person &#123; uint8 age; string id; string name;&#125; 创建结构变量 12345结构体 变量名 = 结构体(属性1，属性2，...)结构体 变量名 = 结构体(&#123;属性1：value1，属性2：value2Ï&#125;)Person student1 = Person(18,1,&quot;柯南&quot;)；Person student2 = Person(&#123;age:17, id: 2, name: &quot;迪迦Ï&quot;&#125;) 修改结构体变量 1234function setStudent(uint _age, string _name) public &#123; student1.age = _age student1.name = _name&#125; 函数中返回结构体 123function getStudent() public view returns(Person) &#123; return student1&#125; 1234567891011121314151617181920212223242526contract Structs &#123; struct Todo &#123; string text; bool completed; &#125; // 结构体数组 Todo[] public todos; // 初始化结构的3种方法 function create(string calldata _text) public &#123; // 1.像函数一样调用它 todos.push(Todo(_text, false)); // 2. 键值对 todos.push(Todo(&#123;text: _text, completed: false&#125;)); // 3.初始化一个空结构，然后更新它 Todo memory todo; todo.text = _text; todos.push(todo);// completed 没有定义,默认为 false &#125; //通过索引获取结构体数组中一个元素,并更新内部的属性 function update(uint _index) public &#123; Todo storage todo = todos[_index]; todo.completed = !todo.completed; &#125;&#125; 字典／映射（Mappings) 与数组和结构体一样，映射也是引用类型。 是一个一对一键值存储关系。 可以理解成js中的对象 1mapping(_KeyType =&gt; _ValueType) _KeyType – 可以是任何内置类型，或者bytes和字符串。不允许使用引用类型或复杂对象。 _ValueType – 可以是任何类型。 注意 映射的数据位置(data location)只能是storage，通常用于状态变量。 映射可以标记为public，Solidity 自动为它创建getter。 mapping 不能直接在函数返回 创建mapping 123456789101112contract MappingTest &#123; mapping(address =&gt; uint256) public balances; function update(uint256 _amount) public &#123; balances[msg.sender] = _amount; &#125; function getAmount() public view returns(uint)&#123; return balances[msg.sender]; &#125;&#125; 1234567891011121314contract LedgerBalance &#123; mapping(address =&gt; uint) public balances; function updateBalance(uint newBalance) public &#123; balances[msg.sender] = newBalance; &#125;&#125;contract Updater &#123; function updateBalance() public returns (uint) &#123; LedgerBalance ledgerBalance = new LedgerBalance(); ledgerBalance.updateBalance(10); return ledgerBalance.balances(address(this)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243contract Mapping &#123; //从地址到uint的映射 mapping(address =&gt; uint) public myMap; function get(address _addr) public view returns (uint) &#123; //映射始终返回一个值。 //如果从未设置该值，它将返回默认值。 return myMap[_addr]; &#125; // 更新此地址的值 function set(address _addr, uint _i) public &#123; myMap[_addr] = _i; &#125; function remove(address _addr) public &#123; //将值重置为默认值 delete myMap[_addr]; &#125;&#125;//嵌套 mappingcontract NestedMapping &#123; //嵌套映射（从地址映射到另一个映射） mapping(address =&gt; mapping(uint =&gt; bool)) public nested; function get(address _addr1, uint _i) public view returns (bool) &#123; // 可以从嵌套映射中获取值 return nested[_addr1][_i]; &#125; function set( address _addr1, uint _i, bool _boo ) public &#123; nested[_addr1][_i] = _boo; &#125; // 删除 mapping 的一个元素 function remove(address _addr1, uint _i) public &#123; delete nested[_addr1][_i]; &#125;&#125; Solidity运算符算术 序号 运算符与描述 1 + (加) 求和 例: A + B = 30 2 – (减) 相减 例: A – B = -10 3 * (乘) 相乘 例: A * B = 200 4 / (除) 相除 例: B / A = 2 5 % (取模) 取模运算 例: B % A = 0 6 ++ (递增) 递增 例: A++ = 11 7 — (递减) 递减 例: A– = 9 比较 序号 运算符与描述 1 == (等于) 2 != (不等于) 3 &gt; (大于) 4 &lt; (小于) 5 &gt;= (大于等于) 6 &lt;= (小于等于) 逻辑 序号 运算符与描述 1 &amp;&amp; (逻辑与) 如果两个操作数都非零，则条件为真。 例: (A &amp;&amp; B) 为真 2 **\\ \\ (逻辑或) 如果这两个操作数中有一个非零，则条件为真。 例:** (A \\ \\ B) 为真 3 ! (逻辑非) 反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。 例: ! (A &amp;&amp; B) 为假 位运算符 序号 运算符与描述 1 &amp; (位与) 对其整数参数的每个位执行位与操作。 例: (A &amp; B) 为 2. 2 **\\ (位或) 对其整数参数的每个位执行位或操作。 例:** (A \\ B) 为 3. 3 ^ (位异或) 对其整数参数的每个位执行位异或操作。 例: (A ^ B) 为 1. 4 ~ (位非) 一元操作符，反转操作数中的所有位。 例: (~B) 为 -4. 5 &lt;&lt; (左移位)) 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由0填充。将一个值向左移动一个位置相当于乘以2，移动两个位置相当于乘以4，以此类推。 例: (A &lt;&lt; 1) 为 4. 6 &gt;&gt; (右移位) 左操作数的值向右移动，移动位置数量由右操作数指定 例: (A &gt;&gt; 1) 为 1. 赋值solidity 支持的赋值运算符，如下表所示： 序号 运算符与描述 1 = (简单赋值) 将右侧操作数的值赋给左侧操作数 例: C = A + B 表示 A + B 赋给 C 2 += (相加赋值) 将右操作数添加到左操作数并将结果赋给左操作数。 例: C += A 等价于 C = C + A 3 −= (相减赋值) 从左操作数减去右操作数并将结果赋给左操作数。 例: C -= A 等价于 C = C – A 4 *= (相乘赋值) 将右操作数与左操作数相乘，并将结果赋给左操作数。 例: C = A 等价于 C = C A 5 /= (相除赋值) 将左操作数与右操作数分开，并将结果分配给左操作数。 例: C /= A 等价于 C = C / A 6 %= (取模赋值) 使用两个操作数取模，并将结果赋给左边的操作数。 例: C %= A 等价于 C = C % A 注意 – 同样的逻辑也适用于位运算符，因此它们将变成&lt;&lt;=、&gt;&gt;=、&gt;&gt;=、&amp;=、|=和^=。 条件运算符 序号 运算符与描述 1 ? : (条件运算符 ) 如果条件为真 ? 则取值X : 否则值Y Solidity循环语句while123while (表达式) &#123; 被执行语句(如果表示为真)&#125; 1234567891011121314// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.0;contract TestBool &#123; uint256 public num = 10; function test(int max) public &#123; int256 start = 1; while (start &lt;= max) &#123; start++; num++; &#125; &#125;&#125; do…whileSolidity 中， do…while循环的语法如下： 1234do &#123; 被执行语句(如果表示为真)&#125; while (表达式);注意: 不要漏掉do后面的分号。 1234567891011121314// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.0;contract TestBool &#123; uint public num = 10; function test () public returns(uint) &#123; int start = 1; int max = 10; do&#123; start ++; num ++; &#125;while(start &lt;=max); return num; &#125;&#125; for123for (初始化; 测试条件; 迭代语句) &#123; 被执行语句(如果表示为真)&#125; 123456789contract TestBool &#123; uint256 public num = 10; function test(int max) public &#123; for(int256 start = 1; start&lt;max; start ++) &#123; num ++; &#125; &#125;&#125; break 与 continue12345678910111213141516// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.0;contract TestBool &#123; uint256 public num = 10; function test(int max) public &#123; for(int256 start = 1; start&lt;max; start ++) &#123; if(start == 1) &#123; // break; // 跳出循环 num 10 continue; // 跳出本次循环 &#125; num ++; &#125; &#125;&#125; Solidity条件语句Solidity支持条件语句，让程序可以根据条件执行不同的操作。条件语句包括： if if...else if...else if Solidity中的函数函数修饰符 函数修饰符用于修改函数的行为。例如，向函数添加条件限制。 修饰符定义中出现特殊符号_的地方，用于插入函数体。如果在调用此函数时，满足了修饰符的条件，则执行该函数，否则将抛出异常。 123456789101112131415161718192021222324252627// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Owner &#123; address owner; uint256 price = 10; constructor() &#123; owner = msg.sender; &#125; // 定义修饰符 onlyOwner 不带参数 modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; // 使用修饰符 onlyOwner 限制只有发布者才能调用 function changePrice(uint256 _price) public view onlyOwner returns (address, uint256) &#123; return (owner, _price); &#125;&#125; 视图函数（view） View(视图)函数 使用状态变量，但是不修改状态 如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。 修改状态变量。 触发事件。 创建合约。 使用selfdestruct。 发送以太。 调用任何不是视图函数或纯函数的函数 使用底层调用 使用包含某些操作码的内联程序集。 Getter方法是默认的视图函数。声明视图函数，可以在函数声明里，添加view关键字。 123456789101112// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.0;contract Test &#123; function getResult() public view returns (uint256, uint256) &#123; uint256 a = 1; // 局部变量 uint256 b = 2; uint256 product = a * b; uint256 sum = a + b; return (product, sum); &#125;&#125; 纯函数（Pure） Pure(纯)函数不读取或修改状态。 声明纯函数，可以在函数声明里，添加pure关键字。 如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告 读取状态变量。 访问 address(this).balance 或 &lt;address&gt;.balance 访问任何区块、交易、msg等特殊变量(msg.sig 与 msg.data 允许读取)。 调用任何不是纯函数的函数。 使用包含特定操作码的内联程序集。 如果发生错误，纯函数可以使用revert()和require()函数来还原潜在的状态更改。 函数重载 同一个作用域内，相同函数名可以定义多个函数。这些函数的参数(参数类型或参数数量)必须不一样。仅仅是返回值不一样不被允许。 12345678910111213141516// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.0;contract Test &#123; function getSum(uint256 a, uint256 b) public pure returns (uint256) &#123; return a + b; &#125; function getSum( uint256 a, uint256 b, uint256 c ) public pure returns (uint256) &#123; return a + b + c; &#125;&#125; 加密函数 Solidity 提供了常用的加密函数。以下是一些重要函数： keccak256(bytes memory) returns (bytes32) 计算输入的Keccak-256散列。 sha256(bytes memory) returns (bytes32) 计算输入的SHA-256散列。 ripemd160(bytes memory) returns (bytes20) 计算输入的RIPEMD-160散列。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)从椭圆曲线签名中恢复与公钥相关的地址，或在出错时返回零。函数参数对应于签名的ECDSA值: r – 签名的前32字节; s: 签名的第二个32字节; v: 签名的最后一个字节。这个方法返回一个地址。 12345contract Test &#123; function callKeccak256() public pure returns(bytes32 result)&#123; return keccak256(&quot;ABC&quot;); &#125; &#125; 智能合约合约继承 就像Java、C++中，类的继承一样，Solidity中，合约继承是扩展合约功能的一种方式。Solidity支持单继承和多继承。 Solidity中，合约继承的重要特点： 派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用this。 如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。 可以使用super关键字或父合同名称调用父合同的函数。 在多重继承的情况下，使用super的父合约函数调用，优先选择被最多继承的合约。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.0;contract Base &#123; uint256 private data; uint256 public info; constructor() &#123; info = 10; &#125; function increment(uint256 a) private pure returns (uint256) &#123; return a + 1; &#125; function updateData(uint256 a) public &#123; data = a; &#125; function getData() public view returns (uint256) &#123; return data; &#125; function compute(uint256 a, uint256 b) internal pure returns (uint256) &#123; return a + b; &#125;&#125;contract Test is Base &#123; uint256 private result; Base private base; constructor() &#123; base = new Base(); &#125; function getComputedResult() public &#123; result = compute(3, 5); &#125; function getResult() public view returns (uint256) &#123; return result; &#125;&#125; 构造函数 构造函数是使用construct关键字声明的特殊函数，用于初始化合约的状态变量。合约中构造函数是可选的，可以省略。 构造函数有以下重要特性： 一个合约只能有一个构造函数。 构造函数在创建合约时执行一次，用于初始化合约状态。 在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。 构造函数可以是公共的，也可以是内部的。 内部构造函数将合约标记为抽象合约。 如果没有定义构造函数，则使用默认构造函数。 以上内容来自千锋教育，并无商业用途，仅供学习使用。","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"WEB3","slug":"WEB3","permalink":"/tags/WEB3/"}]},{"title":"以太坊钱包开发","slug":"以太坊钱包开发","date":"2025-03-10T08:48:28.000Z","updated":"2025-03-11T04:12:09.781Z","comments":true,"path":"2025/03/10/以太坊钱包开发/","link":"","permalink":"/2025/03/10/以太坊钱包开发/","excerpt":"使用vue开发以太坊钱包","text":"使用vue开发以太坊钱包 准备工作项目创建版本信息: Node 16.14 安装vue-cli 1npm install -g @vue/cli 验证vue-cli 安装 123$ vue -V// 结果 出现vue版本号 安装成功@vue/cli 5.0.8 通过vue-cli创建项目 1234567$ vue create &lt;项目名称&gt;// 选择配置Vue CLI v5.0.8? Please pick a preset: Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) ❯ Manually select features `选择该项` 选择自定义配置 1234567891011? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed) ◉ Babel `选择该项` ◯ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router `选择该项` ◯ Vuex❯◉ CSS Pre-processors `选择该项` ◯ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 选择vue版本 1234? Choose a version of Vue.js that you want to start the project with (Use arrow keys)❯ 3.x 2.x 选择路由设置 12? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) y `输入y或者n` 选择预处理语言 12345? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with dart-sass) ❯ Less Stylus 选择配置文件存放目录 123? Where do you prefer placing config for Babel, ESLint, etc.? ❯ In dedicated config files In package.json 安装成功后 运行测试 12$ cd 项目名称$ npm run serve 成功界面 第三方包安装web3相关第三方包1npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet 注： ethereumjs-tx 使用1.3.7 版本 node-polyfill 兼容文件配置 下载polyfill 插件 1npm install node-polyfill-webpack-plugin -D 在vue.config.js 文件中配置插件 1234567891011const &#123; defineConfig &#125; = require('@vue/cli-service')// 引入插件++ const NodePolyfillWebpackPlugin = require(\"node-polyfill-webpack-plugin\");module.exports = defineConfig(&#123; transpileDependencies: true,++ configureWebpack: &#123;++ plugins: [++ new NodePolyfillWebpackPlugin() ], &#125;,&#125;) 配置vant-ui ui组件库https://vant-contrib.gitee.io/vant/#/zh-CN 安装 12$ npm i vant$ npm i unplugin-vue-components -D 在vue.config.js 文件中配置插件 123456789101112131415const &#123; defineConfig &#125; = require(\"@vue/cli-service\");// 引入插件const NodePolyfillWebpackPlugin = require(\"node-polyfill-webpack-plugin\");// vant++ const &#123; VantResolver &#125; = require('unplugin-vue-components/resolvers');++ const ComponentsPlugin = require('unplugin-vue-components/webpack');module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: &#123; plugins: [ new NodePolyfillWebpackPlugin(),++ ComponentsPlugin(&#123; resolvers: [VantResolver()]&#125;), ], &#125;,&#125;); 测试 在app.vue文件添加代码 1234&lt;template&gt; &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt; &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;&lt;/template&gt; 通过vw配置响应式https://www.cnblogs.com/hongrun/p/16130707.html 安装 1npm install postcss-px-to-viewport -D 在根目录下创建 名为 postcss.config.js 文件 12345678910111213141516module.exports = &#123; plugins: &#123; \"postcss-px-to-viewport\": &#123; unitToConvert: \"px\", // 要转化的单位 viewportWidth: 375, // UI设计稿的宽度 unitPrecision: 6, // 转换后的精度，即小数点位数 propList: [\"*\"], // 指定转换的css属性的单位，*代表全部css属性的单位都进行转换 viewportUnit: \"vw\", // 指定需要转换成的视窗单位，默认vw fontViewportUnit: \"vw\", // 指定字体需要转换成的视窗单位，默认vw selectorBlackList: [\"wrap\"], // 指定不转换为视窗单位的类名， minPixelValue: 1, // 默认值1，小于或等于1px则不进行转换 mediaQuery: true, // 是否在媒体查询的css代码中也进行转换，默认false replace: true, // 是否转换后直接更换属性值 exclude: [/node_modules/], // 设置忽略文件，用正则做目录名匹配 &#125;, &#125;,&#125;; web3连接到以太坊网络（测试网、主网） 什么是web3web3是以太坊官方开提供的一个连接以太坊区块链的模块，允许您使用HTTP或IPC与本地或远程以太坊节点进行交互，它包含以太坊生态系统的几乎所有功能。web3模块主要连接以太坊暴露出来的RPC层。开发者利用web3连接RPC层，可以连接任何暴露了RPC接口的节点，从而与区块链交互。web3是一个集合库，支持多种开发语言使用wbe3，其中的JavaScript API叫做web3.js、另外还有web3.py、web3j，web3.js将是我们钱包开发项目的重点。 web3.eth：用于与以太坊区块链和智能合约之间的交互。 web3.utils：包含一些辅助方法。 web3.shh：用于协议进行通信的P2P和广播。 web3.bzz：用于与群网络交互的Bzz模块。 github地址：https://github.com/web3/web3.js/tree/v1.0.0-beta.34 web3.js开发文档：https://web3js.readthedocs.io/en/v1.8.1/ web3.js 中文文档 : https://learnblockchain.cn/docs/web3.js/ 实例化web3对象web3要与以坊节点进行交互，需要创建一个web3对象，下面看看如何创建。 123var Web3 = require('web3');// \"Web3.providers.givenProvider\" will be set if in an Ethereum supported browser.var web3 = new Web3(Web3.givenProvider || 'ws://some.local-or-remote.node:8546'); 根据API可知需要指定节点地址，我们将ws://some.local-or-remote.node:8546换成其它连接到以太坊网络的节点的地址，以此来确定连接的以太坊的网络。那么连接到以太坊网络的节点的地址是多少呢？这里我们需要使用到infura。 获取连接到以太坊网络的节点地址infura提供公开的 Ethereum主网和测试网络节点，到infura.io网站注册后即可获取各个网络的地址。请按照如下步骤获取地址。 第一步：打开 infura网站地址：https://infura.io/dashboard，使用邮箱注册后登陆 第二步：点击上图标记的“create new project”按钮创建一个新项目。然后弹出如下弹框，在输入框输入项目名，如”MyEtherWallet“，然后点击“create project”按钮创建。 第三步：然后会显示如下界面，点击下图中的选择框，可以看到提供主网、Kovan测试网络、Ropsten测试网络、GoerLi测试网络的节点地址。 第四步：选择GoerLi测试网络，然后复制地址，将获取到类似这样的地址：https://kovan.infura.io/v3/d93f......cd67，如下。 连接到以太坊GoerLi测试网络现在将复制的地址替换掉实例化web对象的地址，如下 123var Web3 = require(\"web3\")var web3 = new Web3(Web3.givenProvider || 'wss://goerli.infura.io/ws/v3/cb7e63cf28244e4499b4b6fb6162e746');console.log(\"Web3:\", web3) 连接到以太坊主网与GoerLi测试网络一样的，只需复制主网节点的地址去实例化web3即可。由于在主网上交易需要花费gas，因此我们基于GoerLi测试网络进行开发，后续开发完成后可再切换到主网。 Web3js 高频 Api账号创建 创建账号需要使用web3.js的如下API API 1web3.eth.accounts.create([entropy]); 参数： entropy - String (可选): 它是一个可选项，是一个随机字符串，将作为解锁账号的密码。如果没有传递字符串，则使用random生成随机字符串。 返回值： Object：包含以下字段的一个帐户对象： address- string：帐户地址。 privateKey- string：帐户私钥。前端永远不应该在localstorage中以未加密的方式共享或存储！ signTransaction(tx [, callback])- Function：签名交易的方法。 sign(data)- Function：签名二进制交易的方法。 例子 1web3.eth.accounts.create('2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'); 12345678web3.eth.accounts.create('2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567');&#123;address: \"0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4\",privateKey: \"0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098\",signTransaction: function(tx)&#123;...&#125;,sign: function(data)&#123;...&#125;,encrypt: function(password)&#123;...&#125;&#125; 获取地址使用APIweb3.eth.accounts.create()创建了新账户后生成了一个账户对象，在该对象中拥有addreds属性，即账户的私钥。 123let account = web3.eth.accounts.create(\"123456\")let address = account.address//address：0xfF0B5A0AA68249cD161b606679DB49CBD9a12cd0 3.获取私钥 使用APIweb3.eth.accounts.create()创建了新账户后生成了一个账户对象，在该对象中拥有privateKey属性，即账户的私钥。 123let account = web3.eth.accounts.create()let privateKey = account.privateKey//privateKey:0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709 余额获取根据地址获取以wei为单位余额 123web3.eth.getBalance(address).then((ret) =&gt; &#123; console.log(ret)&#125;); 单位转换 Eth 转为 wei 12345# Web3 或者实例后的web3对象都可以const num = Web3.utils.toWei(\"0.3\");const num = web3.utils.toWei(\"0.3\");console.log(num)// 300000000000000000 wei 转为Eth 123# Web3 或者实例后的web3对象都可以 this.balance = Web3.utils.fromWei(ret, \"ether\"); this.balance = web3.utils.fromWei(ret, \"ether\"); Eth转账API 1web3.eth.sendSignedTransaction(signedTransactionData [, callback]) 参数 signedTransactionData-String：以HEX格式签名的交易数据。 交易数据对象可以包含如下字段： from- String|Number：发送帐户的地址。如果未指定，则使用web3.eth.defaultAccount属性。或web3.eth.accounts.wallet中本地钱包的地址。 to- String:(可选）消息的目标地址，若未定义则为合同发送消息。 value- Number|String|BN|BigNumber:(可选）为wei中的交易转移的数量，如果是合约发送消息，则是捐赠给合约地址。 gas - Number:(可选，默认：待定）用于交易的gas（未使用的gas会退还）。 gasPrice- Number|String|BN|BigNumber:(可选）此交易的gas价格，以wei为单位，默认为web3.eth.gasPrice。 data- String:(可选）包含合同上函数调用数据的ABI字节字符串。 nonce- Number:(可选）随机数的整数。 callback-Function：（可选）可选回调，将错误对象作为第一个参数返回，结果作为第二个参数返回。 返回 PromiEvent：promise组合的事件，将在交易完成时调用。包含以下事件 &quot;transactionHash&quot;返回String：在发送事务并且事务哈希可用之后立即触发。 &quot;receipt&quot;返回Object：在交易确认时触发。 &quot;confirmation&quot;返回Number，Object：每次确认都会被调用，直到第12次确认。接收确认编号作为第一个参数，将数据作为第二个参数。 &quot;error&quot;返回Error：如果在发送过程中发生错误，则会触发。 构建转账参数 区块链转账和支付宝转账类似，需要 发送方 、接收方、金额、密码 另外需要添加部分区块链参数：矿工费gas、地址转账交易次数 1234567891011121314// 获取账户交易次数 let nonce = await web3.eth.getTransactionCount(fromaddress); // 获取预计转账gas费 let gasPrice = await web3.eth.getGasPrice(); // 转账金额以wei为单位 let balance = await web3.utils.toWei(number); var rawTx = &#123; from: fromaddress, nonce: nonce, gasPrice: gasPrice, to: toaddress, value: balance, data: \"0x00\", //转Token代币会用到的一个字段 &#125;; 通过转账参数计算最终gas费用，并将通过私钥将转账参数进行编码加密 ethereumjs-tx 第三方库请选择1.3.7版本 12345678910import Tx from \"ethereumjs-tx\"; // 将私钥去除“ox”后进行hex转化 var privateKey = new Buffer(privatekey.slice(2), \"hex\"); //需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中 let gas = await web3.eth.estimateGas(rawTx); rawTx.gas = gas; // 通过 ethereumjs-tx 实现私钥加密Ï var tx = new Tx(rawTx); tx.sign(privateKey); var serializedTx = tx.serialize(); 通过 sendSignedTransaction api发送转账交易，并且获取交易id 12345678910111213web3.eth .sendSignedTransaction(\"0x\" + serializedTx.toString(\"hex\")) .on(\"transactionHash\", (txid) =&gt; &#123; console.log(\"交易成功,请在区块链浏览器查看\"); console.log(\"交易id\", txid); console.log(`https://goerli.etherscan.io/tx/$&#123;txid&#125;`); &#125;) // .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;) // .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;) .on(\"error\", (err) =&gt; &#123; console.log(\"error:\" + err); &#125;); 区块链浏览器或者目标钱包产看转账结果 goerli区块链浏览器 https://goerli.etherscan.io/tx/交易id 账户系统简介 在前面的教程中我们对以太坊钱包已经有了一定的认识，上一章也重点介绍了账号地址的生成过程，在以太坊钱包中一个重点就是账户系统，在这个模块中很多初学同学不是很清楚密码、keystore、助记词与私钥它们之间的关系。下面我们来看看它们之间到底有着怎样的爱恨情仇，让大家琢磨不透。 密码 密码不是私钥，它是在创建账户时候的密码（可以修改） 密码在以下情况下会使用到： 作为转账的支付密码 用keystore导入钱包的时候需要输入的密码，用来解锁keystore的 私钥 Private Key 私钥由64位长度的十六进制的字符组成，比如：0xA4356E49C88C8B7AB370AF7D5C0C54F0261AAA006F6BDE09CD4745CF54E0115A，一个账户只有一个私钥且不能修改。通常一个钱包中私钥和公钥是成对出现的，有了私钥，我们就可以通过一定的算法生成公钥，再通过公钥经过一定的算法生成地址，这一过程都是不可逆的。私钥一定要妥善保管，若被泄漏别人可以通过私钥解锁账号转出你的该账号的数字货币。 公钥 Public Key 公钥(Public Key)是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。 Keystore Keystore常见于以太坊钱包，它是将私钥以加密的方式保存为一份 JSON 文件，这份 JSON 文件就是 keystore，所以它就是加密后的私钥。Keystore必须配合钱包密码才能导入并使用该账号。当黑客盗取 Keystore 后，在没有密码情况下, 有可能通过暴力破解 Keystore 密码解开 Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。 助记词 Mnemonic 私钥是64位长度的十六进制的字符，不利于记录且容易记错，所以用算法将一串随机数转化为了一串12 ~ 24个容易记住的单词，方便保存记录。注意： 助记词是私钥的另一种表现形式 助记词=私钥，这是不正确的说法，通过助记词可以获取相关联的多个私钥，但是通过其中一个私钥是不能获取助记词的，因此助记词≠私钥。 BIP 要弄清楚助记词与私钥的关系，得清楚BIP协议，是Bitcoin Improvement Proposals的缩写，意思是Bitcoin 的改进建议，用于提出 Bitcoin 的新功能或改进措施。BIP协议衍生了很多的版本，主要有BIP32、BIP39、BIP44。 BIP32 BIP32是 HD钱包的核心提案，通过种子来生成主私钥，然后派生海量的子私钥和地址，种子是一串很长的随机数。 BIP39 由于种子是一串很长的随机数，不利于记录，所以我们用算法将种子转化为一串12 ~ 24个的单词，方便保存记录，这就是BIP39，它扩展了 HD钱包种子的生成算法。 BIP44 BIP44 是在 BIP32 和 BIP43 的基础上增加多币种，提出的层次结构非常全面，它允许处理多个币种，多个帐户，每个帐户有数百万个地址。 在BIP32路径中定义以下5个级别： 1m/purpse&apos;/coin_type&apos;/account&apos;/change/address_index purpose：在BIP43之后建议将常数设置为44’。表示根据BIP44规范使用该节点的子树。 Coin_type：币种，代表一个主节点（种子）可用于无限数量的独立加密币，如比特币，Litecoin或Namecoin。此级别为每个加密币创建一个单独的子树，避免重用已经在其它链上存在的地址。开发人员可以为他们的项目注册未使用的号码。 Account：账户，此级别为了设置独立的用户身份可以将所有币种放在一个的帐户中，从0开始按顺序递增。 Change：常量0用于外部链，常量1用于内部链，外部链用于钱包在外部用于接收和付款。内部链用于在钱包外部不可见的地址，如返回交易变更。 Address_index：地址索引，按顺序递增的方式从索引0开始编号。 BIP44的规则使得 HD钱包非常强大，用户只需要保存一个种子，就能控制所有币种，所有账户的钱包，因此由BIP39 生成的助记词非常重要，所以一定安全妥善保管，那么会不会被破解呢？如果一个 HD 钱包助记词是 12 个单词，一共有 2048 个单词可能性，那么随机的生成的助记词所有可能性大概是5e+39，因此几乎不可能被破解。 HD钱包 通过BIP协议生成账号的钱包叫做HD钱包。这个HD钱包，并不是Hardware Wallet硬件钱包，这里的 HD 是Hierarchical Deterministic的缩写，意思是分层确定性，所以HD钱包的全称为比特币分成确定性钱包 。 密码、私钥、keystore与助记词的关系 钱包的核心：私钥基于以上的分析，我们对以太坊钱包的账号系统有了一个很好的认识，那么我们在使用钱包的过程中，该如何保管自己的钱包呢？主要包含以下几种方式： 私钥（Private Key） Keystore+密码（Keystore+Password） 助记词（Mnemonic code） 通过以上三种中的一种方式都可以解锁账号，然后掌控它，所以对于每种方式中的数据都必须妥善包括，如有泄漏，请尽快转移数字资产。 我们可以得到以下总结： 通过私钥+密码可以生成keystore，即加密私钥； 通过keystore+密码可以获取私钥，即解密keystore。 通过助记词根据不同的路径获取不同的私钥，即使用HD钱包将助记词转化成种子来生成主私钥，然后派生海量的子私钥和地址。 可以看出这几种方式的核心其实都是为了获得私钥，然后去解锁账号，因此钱包的核心功能是私钥的创建、存储和使用。 参考资料 https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.htmlhttps://github.com/bitcoin/bips/blob/master/bip-0032.mediawikihttps://github.com/bitcoin/bips/blob/master/bip-0044.mediawikihttps://github.com/ethereum/EIPs/issues/84https://github.com/ethereum/EIPs/issues/85 创建账户 从无到有创建一个新的账户 web3 直接创建账户1web3.eth.accounts.create('2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'); 助记词 创建账户需要使用bip39协议将助记词转换成种子，再通过ethereumjs-wallet库生成hd钱包，根据路径的不同从hd钱包中获取不同的keypair，keypair中就包含有公钥、私钥，再通过ethereumjs-util库将公钥生成地址，从而根据助记词获取所有关联的账号，能获取到公钥、私钥、地址等数据信息。 1. 依赖库需要用到三个库：bip39、ethereumjs-wallet/hdkey、ethereumjs-util。先安装依赖库，cd到项目跟路径运行命令npm i bip39 ethereumjs-wallet ethereumjs-util。 bip39：随机产生新的 mnemonic code，并可以将其转成 binary 的 seed。 ethereumjs-wallet：生成和管理公私钥，下面使用其中 hdkey 子套件来创建 HD 钱包。 ethereumjs-util：Ethereum 的一个工具库。 https://iancoleman.io/bip39/ 2. 通过助记词创建账号 创建助记词 1234567// 引入bip39模块import * as bip39 from \"bip39\";// 创建助记词 let mnemonic = bip39.generateMnemonic();console.log(mnemonic);// 结果 12位助记词// vote select solar shy embrace immense lizard stamp scrub vague negative forward 根据助记词生成密钥对 keypair 123456789 // 导入分层钱包模块import &#123; hdkey &#125; from \"ethereumjs-wallet\"; //1.将助记词转成seed let seed = await bip39.mnemonicToSeed(\"12位助记词\"); //3.通过hdkey将seed生成HD Wallet let hdWallet = hdkey.fromMasterSeed(seed); //4.生成钱包中在m/44'/60'/0'/0/i路径的keypair let keypair = hdWallet.derivePath(\"m/44'/60'/0'/0/0\"); console.log(keypair); keypair 密钥对 3. 由keypair 获取钱包地址和私钥12345678910111213141516// 获取钱包对象let wallet = keypair.getWallet();// 获取钱包地址let lowerCaseAddress = wallet.getAddressString();// 获取钱包校验地址let CheckSumAddress = wallet.getChecksumAddressString();// 获取私钥let prikey = wallet.getPrivateKey().toString(\"hex\"); console.log(\"lowerCaseAddress\", lowerCaseAddress); console.log(\"CheckSumAddress\", CheckSumAddress); console.log(\"prikey\", prikey);/*lowerCaseAddress 0xd9fc0fd4412616c7075e68b151ab3a7bcb9a3f54CheckSumAddress 0xd9fC0FD4412616c7075E68b151ab3A7bcB9A3f54prikey 3fc11495517f1f015bbcb6c311da66e3b26b23e4c91c1285ccc4b69d9d274002*/ 导出账户 一个已经存在的账户导出 私钥 和 keystore 通过分层钱包对象 + 密码 创建keystore 1let keystore = await wallet.toV3(data.pass1); // 参数必须为 字符串 通过私钥和密码创建 keystore 1const keystore = await web3.eth.accounts.encrypt(\"账户私钥\",\"密码\"); 1234567891011121314151617181920212223// 模拟keystore数据const keystoreJsonV3 = &#123; version: 3, id: \"dbb70fb2-52ad-4e1f-9c19-0b50329f89c3\", address: \"445b469888528dacd9b87246c5ce70407adaa411\", crypto: &#123; ciphertext: \"1e53e7e775644422600188b8134907992db40d278064ea3a966da4dcdf80db64\", cipherparams: &#123; iv: \"f9d2b047019674eee449b316f4a21491\" &#125;, cipher: \"aes-128-ctr\", kdf: \"scrypt\", kdfparams: &#123; dklen: 32, salt: \"153e074d78d0ba36fae3e46e582c42e53f61653cb5d4f1a3a3f68094e6ca0160\", n: 8192, r: 8, p: 1, &#125;, mac: \"e91456c59b2505c16b80c2495ab7b4633273c2ae366cb6953f27de8cfebad629\", &#125;, &#125;; const res = web3.eth.accounts.decrypt(keystoreJsonV3, \"1235\"); console.log(res); 通过keystore解密私钥 12345678910import ethwallet from \"ethereumjs-wallet\"; let pass = prompt(\"请输入密码\"); let wallet; try &#123; wallet = await ethwallet.fromV3(keystore, pass); &#125; catch (error) &#123; alert(\"密码错误\"); return false; &#125; let key = wallet.getPrivateKey().toString(\"hex\"); 导入账户 通过 私钥、助记词、keystore 导入一个已经存在的钱包账户 地址 和 私钥 通过keystore获取 私钥和地址 1234567891011import ethwallet from \"ethereumjs-wallet\"; let pass = prompt(\"请输入密码\"); let wallet; try &#123; wallet = await ethwallet.fromV3(keystore, pass); &#125; catch (error) &#123; alert(\"密码错误\"); return false; &#125;let key = wallet.getPrivateKey().toString(\"hex\");let address = wallet.getAddressString() 通过助记词 获取地址和私钥 123456789101112let mnemonic=prompt(\"请输入助记词\")let seed = bip39.mnemonicToSeed(mnemonic)let hdwallet = hdkey.fromMasterSeed(seed)let keypair = hdWallet.derivePath(\"m/44'/60'/0'/0/0\");// 获取钱包对象let wallet = keypair.getWallet();// 获取钱包地址let lowerCaseAddress = wallet.getAddressString();// 获取钱包校验地址let CheckSumAddress = wallet.getChecksumAddressString();// 获取私钥let prikey = wallet.getPrivateKey().toString(\"hex\"); 通过私钥获取 地址 12345import ethwallet from \"ethereumjs-wallet\"; let privatekey=new Buffer( prompt(\"请输入私钥\"), 'hex' )let wallet = ethwallet.fromPrivateKey(privatekey)// 获取钱包地址let lowerCaseAddress = wallet.getAddressString(); 区块链钱包项目流程 1.项目准备​ 直接采用随堂demo创建的项目 不需要重新创建 web3相关第三方包1npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet 注： ethereumjs-tx 使用1.3.7 版本 node-polyfill 兼容文件配置 下载polyfill 插件 1npm install node-polyfill-webpack-plugin -D 在vue.config.js 文件中配置插件 1234567891011const &#123; defineConfig &#125; = require('@vue/cli-service')// 引入插件++ const NodePolyfillWebpackPlugin = require(\"node-polyfill-webpack-plugin\");module.exports = defineConfig(&#123; transpileDependencies: true,++ configureWebpack: &#123;++ plugins: [++ new NodePolyfillWebpackPlugin() ], &#125;,&#125;) 配置vant-ui ui组件库https://vant-contrib.gitee.io/vant/#/zh-CN 安装 12$ npm i vant$ npm i unplugin-vue-components -D 在vue.config.js 文件中配置插件 123456789101112131415const &#123; defineConfig &#125; = require(\"@vue/cli-service\");// 引入插件const NodePolyfillWebpackPlugin = require(\"node-polyfill-webpack-plugin\");// vant++ const &#123; VantResolver &#125; = require('unplugin-vue-components/resolvers');++ const ComponentsPlugin = require('unplugin-vue-components/webpack');module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: &#123; plugins: [ new NodePolyfillWebpackPlugin(),++ ComponentsPlugin(&#123; resolvers: [VantResolver()]&#125;), ], &#125;,&#125;); 测试 在app.vue文件添加代码 1234&lt;template&gt; &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt; &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;&lt;/template&gt; 通过vw配置响应式https://www.cnblogs.com/hongrun/p/16130707.html 安装 1npm install postcss-px-to-viewport -D 在根目录下创建 名为 postcss.config.js 文件 12345678910111213141516module.exports = &#123; plugins: &#123; \"postcss-px-to-viewport\": &#123; unitToConvert: \"px\", // 要转化的单位 viewportWidth: 375, // UI设计稿的宽度 unitPrecision: 6, // 转换后的精度，即小数点位数 propList: [\"*\"], // 指定转换的css属性的单位，*代表全部css属性的单位都进行转换 viewportUnit: \"vw\", // 指定需要转换成的视窗单位，默认vw fontViewportUnit: \"vw\", // 指定字体需要转换成的视窗单位，默认vw selectorBlackList: [\"wrap\"], // 指定不转换为视窗单位的类名， minPixelValue: 1, // 默认值1，小于或等于1px则不进行转换 mediaQuery: true, // 是否在媒体查询的css代码中也进行转换，默认false replace: true, // 是否转换后直接更换属性值 exclude: [/node_modules/], // 设置忽略文件，用正则做目录名匹配 &#125;, &#125;,&#125;; 封装缓存函数整个项目为了保证钱包的安全性，所有账户相关的操作，不经过中心化服务器，只在缓存使用 在这里可以参考webstorage增加过期时间，cookie 等的封装 创建 src/utils/storage.js 文件 123456789101112131415class Storage &#123; setItem(key, val) &#123; localStorage.setItem(key, JSON.stringify(val || \"\")); &#125; getItem(key) &#123; let val; try &#123; val = JSON.parse(localStorage.getItem(key)); &#125; catch &#123; val = null; &#125; return val; &#125;&#125;export default new Storage(); app.vue 文件引入在app.vue 引入文件并且初始化web3.js 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt; qf - eth -wallet&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// import * as util from &quot;ethereumjs-util&quot;;import ethwallet from &quot;ethereumjs-wallet&quot;; import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;import * as bip39 from &quot;bip39&quot;;import Tx from &quot;ethereumjs-tx&quot;;import Web3 from &quot;web3&quot;;import storage from &quot;@/utils/storage&quot;;var web3 = new Web3( Web3.givenProvider || &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;);&lt;/script&gt; 2.通过Mnemonic助记词创建钱包 判断缓存是否有 钱包对象 有钱包对象显示钱包信息 地址 私钥 余额 没有钱包对象显示创建钱包按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt;qf - eth -wallet&lt;/h3&gt; &lt;h4&gt;创建钱包&lt;/h4&gt; &lt;van-button type=&quot;primary&quot; @click=&quot;createWallet&quot;&gt; 创建钱包 &lt;/van-button&gt; &lt;van-button type=&quot;primary&quot; @click=&quot;importWallet&quot;&gt; 导入钱包-助记词 &lt;/van-button&gt; &lt;h4&gt;钱包信息&lt;/h4&gt; &#123;&#123; wallet &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// import * as util from &quot;ethereumjs-util&quot;;import ethwallet from &quot;ethereumjs-wallet&quot;;import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;import * as bip39 from &quot;bip39&quot;;import Tx from &quot;ethereumjs-tx&quot;;import storage from &quot;@/utils/storage&quot;;import Web3 from &quot;web3&quot;;import &#123; reactive &#125; from &quot;vue&quot;;var web3 = new Web3( Web3.givenProvider || &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;);const wallet = reactive(storage.getItem(&quot;wallet&quot;) || &#123;&#125;);console.log(wallet);async function createWallet() &#123; const pass = prompt(&quot;请输入您的钱包密码&quot;); if (!pass) return false; let mnemonic = bip39.generateMnemonic(); alert(&quot;您的助记词为:&quot; + mnemonic); const checkMnemonic = prompt(&quot;请输入您的助记词&quot;); if (mnemonic === checkMnemonic) &#123; //1.将助记词转成seed let seed = await bip39.mnemonicToSeed(mnemonic); //3.通过hdkey将seed生成HD Wallet let hdWallet = hdkey.fromMasterSeed(seed); //4.生成钱包中在m/44&apos;/60&apos;/0&apos;/0/i路径的keypair let keyPair = hdWallet.derivePath(&quot;m/44&apos;/60&apos;/0&apos;/0/0&quot;); // 获取钱包对象 let wallet = keyPair.getWallet(); // 获取钱包地址 let lowerCaseAddress = wallet.getAddressString(); // 获取钱包校验地址 let CheckSumAddress = wallet.getChecksumAddressString(); // 获取私钥 let prikey = wallet.getPrivateKey().toString(&quot;hex&quot;); let keystore = await wallet.toV3(pass); console.log(keystore); // 保存钱包信息 const walletInfo = &#123; address: lowerCaseAddress, prikey, keystore, balance: 0, mnemonic, // 助记词不应该记录下来仅仅是为了便于演示 &#125;; storage.setItem(&quot;wallet&quot;, walletInfo); wallet = walletInfo; &#125; else &#123; alert(&quot;助记词错误请重新输入&quot;); &#125;&#125;&lt;/script&gt; 3.显示余额1234567891011const balance = ref(\"0\");// 获取余额async function getBalance() &#123; if(!wallet.address) return false; // 根据地址查询余额 web3.eth.getBalance(wallet.address).then((ret) =&gt; &#123; balance.value = web3.utils.fromWei(ret, \"ether\"); &#125;);&#125;getBalance() 4.转账交易123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551. 获取用户输入金额 与 地址 2. 调用send 方法async function send() &#123; const keystore = storage.getItem(\"wallet\").keystore; let pass = prompt(\"请输入密码\"); let walletobj; try &#123; walletobj = await ethwallet.fromV3(keystore, pass); &#125; catch (error) &#123; alert(\"密码错误\"); return false; &#125; let key = walletobj.getPrivateKey().toString(\"hex\"); var privateKey = new Buffer(key, \"hex\"); // console.log(privateKey); const fromaddress = wallet.address; // 获取账户交易次数 let nonce = await web3.eth.getTransactionCount(fromaddress); // 获取预计转账gas费 let gasPrice = await web3.eth.getGasPrice(); // 转账金额以wei为单位 console.log(number.value, typeof number.value); let balance = Web3.utils.toWei(number.value); console.log(222); var rawTx = &#123; from: fromaddress, nonce: nonce, gasPrice: gasPrice, to: toaddress.value, value: balance, data: \"0x00\", //转Token代币会用到的一个字段 &#125;; //需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中 let gas = await web3.eth.estimateGas(rawTx); rawTx.gas = gas; // 通过 ethereumjs-tx 实现私钥加密Ï var tx = new Tx(rawTx); tx.sign(privateKey); var serializedTx = tx.serialize(); web3.eth .sendSignedTransaction(\"0x\" + serializedTx.toString(\"hex\")) .on(\"transactionHash\", (txid) =&gt; &#123; console.log(\"交易成功,请在区块链浏览器查看\"); console.log(\"交易id\", txid); console.log(`https://goerli.etherscan.io/tx/$&#123;txid&#125;`); &#125;) // .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;) // .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;) .on(\"error\", (err) =&gt; &#123; console.log(\"error:\" + err); &#125;);&#125; 5.导出账户信息 导出私钥 123456789101112async function exportKey() &#123; let pass = prompt(\"请输入密码\"); let walletObj; try &#123; walletObj = await ethwallet.fromV3(wallet.keystore, pass); &#125; catch (error) &#123; alert(\"密码错误\"); return false; &#125; let key = walletObj.getPrivateKey().toString(\"hex\"); alert(key)&#125; 导出keystore 1234缓存对象function exportKeyStore() &#123; alert(JSON.stringify(wallet.keystore))&#125; 6.解锁账户信息 助记词解锁 1234567891011121314151617181920212223242526272829303132添加助记词导入钱包方法async function importWallet() &#123; const mnemonic = prompt(\"请输入助记词\"); const pass = prompt(\"请输入您的钱包密码\"); if (!pass) return false; //1.将助记词转成seed let seed = await bip39.mnemonicToSeed(mnemonic); //3.通过hdkey将seed生成HD Wallet let hdWallet = hdkey.fromMasterSeed(seed); //4.生成钱包中在m/44'/60'/0'/0/i路径的keypair let keyPair = hdWallet.derivePath(\"m/44'/60'/0'/0/0\"); // 获取钱包对象 let wallet = keyPair.getWallet(); // 获取钱包地址 let lowerCaseAddress = wallet.getAddressString(); // 获取钱包校验地址 let CheckSumAddress = wallet.getChecksumAddressString(); // 获取私钥 let prikey = wallet.getPrivateKey().toString(\"hex\"); let keystore = await wallet.toV3(pass); console.log(keystore); // 保存钱包信息 const walletInfo = &#123; address: lowerCaseAddress, prikey, keystore, balance: 0, mnemonic, // 助记词不应该记录下来仅仅是为了便于演示 &#125;; storage.setItem(\"wallet\", walletInfo); wallet = walletInfo; &#125; 私钥解锁 1234567891011121314151617async function importByPrivateKey() &#123; const key = prompt(\"请输入私钥\") let privatekey=new Buffer(key , 'hex' ) let pass = prompt(\"请输入密码\"); let wallet = ethwallet.fromPrivateKey(privatekey) let keystore = await wallet.toV3(pass); // 获取钱包地址 let lowerCaseAddress = wallet.getAddressString(); const walletInfo = &#123; address: lowerCaseAddress, prikey: key, keystore, balance: 0, &#125;; console.log(walletInfo) storage.setItem(\"wallet\", walletInfo);&#125; 未来展望 通过uniapp 、rn、electron 将项目变为app和桌面端应用 app添加扫码转账功能 增加erc20代币转账功能 增加nft数字藏品商城功能 增加Dao 应用 智能合约 通过智能合约文件 获取abi 1import &#123; abi &#125; from \"@/contract/HHC.json\"; 在web3实例的基础上创建智能合约实例 1234const hhc = new this.web3.eth.Contract( abi, \"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5\"); 通过智能合约实例获取代币余额 12 let num = await hhc.methods.balanceOf(address).call();Web3.utils.fromWei(num, \"ether\"); 智能合约交易hash 创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849async createCoinTransationHx(contractInstance, method, to, value) &#123; let pass = prompt(\"请输入密码\"); let wallet; try &#123; wallet = await ethwallet.fromV3(keystore, pass); &#125; catch (error) &#123; alert(\"密码错误\"); return false; &#125; let key = wallet.getPrivateKey().toString(\"hex\"); const from = this.ownerAddress; // 当前地址交易次数 const nonce = await this.instance.eth.getTransactionCount(from); var privateKey = new Buffer(key, \"hex\"); // 获取预计转账gas费 let gasPrice = await this.instance.eth.getGasPrice(); // 转账金额以wei为单位 let weiValue = await Web3.utils.toWei(value); // 转账的记录对象 // 代币转账 // this.HccCont = new this.web3.eth.Contract( // abi, // \"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5\" // ); const contractAbi = await contractInstance.methods[method]( to, weiValue ).encodeABI(); // console.log(contractAbi); // console.log(contractInstance._address); // return false; var rawTx = &#123; from: this.ownerAddress, nonce: nonce, gasPrice: gasPrice, to: contractInstance._address, //eth 转账 to 目标地址 ，智能合约 to 智能合约地址 value: 0, //eth 转账 数量 data: contractAbi, //智能合约方法的abi编码 &#125;; //需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中 let gas = await this.instance.eth.estimateGas(rawTx); rawTx.gas = gas; // 通过tx实现交易对象的加密操作 var tx = new Tx(rawTx); tx.sign(privateKey); var serializedTx = tx.serialize(); var transationHx = \"0x\" + serializedTx.toString(\"hex\"); return transationHx; &#125; 智能合约代币转账 1234567891011121314151617181920this.web3.eth .sendSignedTransaction(hx) .on(\"transactionHash\", (txid) =&gt; &#123; console.log(\"交易成功,请在区块链浏览器查看\"); console.log(\"交易id\", txid); console.log(`https://goerli.etherscan.io/tx/$&#123;txid&#125;`); &#125;) .on(\"receipt\", (ret) =&gt; &#123; cb &amp;&amp; cb(ret); console.log(\"receipt\", ret); const &#123; transactionHash &#125; = ret; this.createOrderData(transactionHash); &#125;) .on(\"latestBlockHash\", (...arg) =&gt; &#123; console.log(\"latestBlockHash\", arg); &#125;) .on(\"error\", (err) =&gt; &#123; console.log(\"error:\"); console.log(err); &#125;); 以上内容来自千锋教育，并无商业用途，仅供学习使用。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"WEB3","slug":"WEB3","permalink":"/tags/WEB3/"}]},{"title":"RAG系统搭建(基础版)","slug":"RAG系统搭建-基础版","date":"2025-02-20T07:32:05.000Z","updated":"2025-02-21T06:11:52.607Z","comments":true,"path":"2025/02/20/RAG系统搭建-基础版/","link":"","permalink":"/2025/02/20/RAG系统搭建-基础版/","excerpt":"简单的搭建一个大语言模型的RAG系统","text":"简单的搭建一个大语言模型的RAG系统RAG（Retrieval-Augmented Generation）系统是一种结合了信息检索（Retrieval）和文本生成（Generation）能力的框架，通过将传统的基于检索的方法与现代的生成模型相结合，来提升对任务的回答质量和准确性。 python环境搭建安装使用Anaconda来安装python环境，可以直接在系统的应用商店中安装。 环境配置打开Anaconda PowerShell Prompt1.创建环境1conda create --name envName python=3.10 // 目前最好使用3.10版本，对各种库的兼容性比较好 2.激活环境1conda activate envName 3.查看当前环境列表1conda env list 4.卸载环境12// 确保当前激活环境非要删除的envNameconda env remove --name envName 5.安装依赖12345// 安装单个包pip install package_name// 根据requirements.txt文件安装所有依赖pip install -r requirements.txt 6.更换镜像1234pip install package_name -i https://pypi.tuna.tsinghua.edu.cn/simple清华：https://pypi.tuna.tsinghua.edu.cn/simple华为云：https://repo.huaweicloud.com/repository/pypi/simple 7.查看当前环境都安装了哪些依赖库1conda list 模型下载HuggingFace模型，这个网站需要科学上网，所以国内使用modelscope 安装modelscope依赖库1pip install modelscope -i https://repo.huaweicloud.com/repository/pypi/simple Sentence Transformer模型下载在进行RAG之前，需要使用词向量模型进行Embedding，将文本进行向量化处理，执行下述命令下载模型123456# 模型下载from modelscope import snapshot_download# model_id 模型的id# cache_dir 模型下载路径model_dir = snapshot_download(model_id=&apos;Ceceliachenen/paraphrase-multilingual-MiniLM-L12-v2&apos;, cache_dir=&apos;D:/jinux/models&apos;) LLM模型下载这里选择千问0.5B大模型123from modelscope import snapshot_downloadmodel_dir = snapshot_download(model_id=&apos;Qwen/Qwen2.5-0.5B-Instruct&apos;, cache_dir=&apos;D:/jinux/models&apos;) 安装依赖库下边案例所需要的依赖库1234pip install llama_index -i https://repo.huaweicloud.com/repository/pypi/simplepip install llama_index.llms.huggingface -i https://repo.huaweicloud.com/repository/pypi/simplepip install transformers -i https://repo.huaweicloud.com/repository/pypi/simplepip install llama_index.embeddings.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple 调用本地模型进行推理测试执行代码12345678910111213from llama_index.llms.huggingface import HuggingFaceLLMfrom llama_index.core.llms import ChatMessage# 使用HuggingFace 加载本地大模型llm = HuggingFaceLLM( # 给定的是本地模型的全路径 model_name=r&quot;D:\\jinux\\models\\Qwen\\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字 tokenizer_name=r&quot;D:\\jinux\\models\\Qwen\\Qwen2___5-0___5B-Instruct&quot;, # 模型名字 model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;, tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;)rsp = llm.chat(messages=[ChatMessage(content=&quot;请简单的介绍一下jinux&quot;)])print(rsp) 测试结果12345# 1Jenkins 是一个开源的自动化构建工具，它允许开发者......# 2 JLinux 是一种基于 Linux 的开源操作系统，由阿里云...... 推理结果每次都是错的。 创建知识库(RAG)执行代码12345678910111213141516171819202122232425262728293031323334353637383940from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settingsfrom llama_index.embeddings.huggingface import HuggingFaceEmbeddingfrom llama_index.llms.huggingface import HuggingFaceLLM# 初始化一个HuggingFaceEmbedding对象，用于将文本转换为向量表示# 指定了一个预训练的sentence-transformer模型的路径embed_model = HuggingFaceEmbedding( model_name=r&quot;D:\\jinux\\models\\Ceceliachenen\\paraphrase-multilingual-MiniLM-L12-v2&quot;)# 将创建的嵌入模型赋值给全局设置的embed_model属性，# 这样在后续的索引构建过程中就会使用这个模型。Settings.embed_model = embed_model# 推理模型（生成模型）llm = HuggingFaceLLM( # 给定的是本地模型的全路径 model_name=r&quot;D:\\jinux\\models\\Qwen\\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字 tokenizer_name=r&quot;D:\\jinux\\models\\Qwen\\Qwen2___5-0___5B-Instruct&quot;, # 模型名字 model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;, tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;)# 设置全局的llm属性，这样在索引查询时会使用这个模型Settings.llm = llm# RAG 系统构建过程# 从指定目录读取所有文档，并加载数据到内存中，required_exts 只加载指定扩展名的文档documents = SimpleDirectoryReader(&quot;./documents&quot;, required_exts=[&quot;.txt&quot;]).load_data()# 创建一个VectorStoreIndex，并使用之前加载的文档来构建索引# 此索引将文档转换为向量，并存储这些向量以便于快速检索# 默认是存储在内存中的index = VectorStoreIndex.from_documents(documents)# 创建一个查询引擎，这个引擎可以接收查询并返回相关文档的响应query_engine = index.as_query_engine()response = query_engine.query(&quot;请简单的介绍一下jinux&quot;)print(response) 测试结果12他是一个大龄前端程序员。他的工作经历和职业背景主要集中在工作中遇到的年龄危机以及他正在学习AI方面知识上。由于他是一位大龄程序员，他在工作中可能会面临一些挑战，比如可能被裁员的风险。因此，他需要不断学习新的技能和知识来应对这些风险。 测试结果是正确的，因为提供的文档中有这些信息。 原理上述代码原理见下图 总结这个RAG系统非常简单，但是基本原理是这样的，通过向量化的方式，将文本转换为向量，然后通过向量检索的方式，找到最相似的文本，最后再交给LLM模型进行推理，得到最终的答案。源码","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"}]},{"title":"docker基础教程","slug":"docker基础教程","date":"2025-02-06T06:58:27.000Z","updated":"2025-03-05T06:07:35.720Z","comments":true,"path":"2025/02/06/docker基础教程/","link":"","permalink":"/2025/02/06/docker基础教程/","excerpt":"docker基础入门教程","text":"docker基础入门教程 本文章运行环境是window11专业版 版本号24H2 安装系统设置 任务栏搜索”功能”，点击”启用或关闭windows功能” 勾选”适用于Linux的Windows子系统”和”虚拟机平台”,点击确定后重启电脑 安装wsl2 使用管理员身份打开CMD 输入命令wsl --set-default-version 2 输入命令wsl --update也可以wsl --update --web-download 下载docker docker官网 下载后安装(intel core处理器下载AMD的安装文件) 安装后可在CMD中执行docker --version查看docker版本 镜像（image）Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。12345# 列出本机的所有 image 文件。docker image ls# 删除 image 文件docker image rm [imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。 实例（hello world）下面，我们通过最简单的 image 文件”hello world“，感受一下 Docker。 需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站。 1.右键点击系统托盘（右下角）的 Docker 图标，选择 Settings（或直接打开 Docker Desktop）。 2.进入 Docker Engine 配置页面。 3.在编辑框中修改 registry-mirrors 字段，添加国内镜像源地址 { “builder”: { “gc”: { “defaultKeepStorage”: “20GB”, “enabled”: true } }, “experimental”: false, “registry-mirrors”: [ “https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;, “https://docker.m.daocloud.io&quot;, “https://hub-mirror.c.163.com&quot;, “https://mirror.baidubce.com&quot;, “https://your_preferred_mirror&quot;, “https://dockerhub.icu&quot;, “https://docker.registry.cyou&quot;, “https://docker-cf.registry.cyou&quot;, “https://dockercf.jsdelivr.fyi&quot;, “https://docker.jsdelivr.fyi&quot;, “https://dockertest.jsdelivr.fyi&quot;, “https://mirror.aliyuncs.com&quot;, “https://dockerproxy.com&quot;, “https://mirror.baidubce.com&quot;, “https://docker.m.daocloud.io&quot;, “https://docker.nju.edu.cn&quot;, “https://docker.mirrors.sjtug.sjtu.edu.cn&quot;, “https://docker.mirrors.ustc.edu.cn&quot;, “https://mirror.iscas.ac.cn&quot;, “https://docker.rainbond.cc&quot; ] } 4.点击 Apply &amp; Restart，等待 Docker 重启生效。 首先，运行下面的命令，将 image 文件从仓库抓取到本地。1docker image pull library/hello-world 上面代码中，docker image pull是抓取 image 文件的命令。library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。1docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了。1docker image ls 现在，运行这个 image 文件。1docker container run hello-world docker container run命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。12hello from Docker!This message shows that your installation appears to be working correctly. 输出这段提示以后，hello world就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。1docker container run -it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。1docker container kill [containID] 容器文件image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。12345# 列出本机正在运行的容器docker container ls# 列出本机所有容器，包括终止运行的容器docker container ls --all 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的docker container kill命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm命令删除。1docker container rm [containerID] 运行上面的命令之后，再使用docker container ls --all命令，就会发现被删除的容器文件已经消失了。 Dockerfile 文件学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 实例（制作自己的 Docker 容器）下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码。12git clone https://github.com/jinux7/koa-demos.gitcd koa-demos 编写 Dockerfile 文件首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。123.gitnode_modulesnpm-debug.log 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。12345FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000 上面代码一共五行，含义如下。12345FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。WORKDIR /app：指定接下来的工作路径为/app。RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 创建 image 文件有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。123docker image build -t koa-demo .# 或者docker image build -t koa-demo:0.0.1 . 上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件koa-demo了。1docker image ls 生成容器docker container run命令会从 image 文件生成容器。123docker container run -p 8000:3000 -it koa-demo /bin/bash# 或者docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下：1234-p参数：容器的 3000 端口映射到本机的 8000 端口。-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。1root@66d80f4aaf1e:/app# 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。1root@66d80f4aaf1e:/app# node demos/01.js 这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found”，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用docker container kill终止容器运行。12345# 在本机的另一个终端窗口，查出容器的 IDdocker container ls# 停止指定的容器运行docker container kill [containerID] 容器停止运行之后，并不会消失，用下面的命令删除容器文件。12345# 查出容器的 IDdocker container ls --all# 删除指定的容器文件docker container rm [containerID] 也可以使用docker container run命令的--rm参数，在容器终止运行后自动删除容器文件。1docker container run --rm -p 8000:3000 -it koa-demo /bin/bash CMD 命令上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。123456FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000CMD node demos/01.js 上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。 你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。 注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。1docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 发布 image 文件容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com注册一个账户。然后，用下面的命令登录。1docker login 接着，为本地的 image 标注用户名和版本。123docker image tag [imageName] [username]/[repository]:[tag]# 实例docker image tag koa-demos:0.0.1 jinux/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。1docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。1docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 这里的imageName是镜像名，username/repository是用户名下的仓库名，tag版本对用着imageName镜像，一般来说一个仓库下包含着一个镜像的不同版本。 其他有用的命令docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。 docker container start前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。1docker container start [containerID] docker container stop前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。1docker container stop [containerID] 这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 docker container logsdocker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。1docker container logs [containerID] docker container execdocker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。1docker container exec -it [containerID] /bin/bash docker container cpdocker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。1docker container cp [containID]:[/path/to/file] .","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"/tags/docker/"}]},{"title":"element-plus全局设置组件默认属性","slug":"element-plus全局设置组件默认属性","date":"2025-01-09T08:17:43.000Z","updated":"2025-01-09T08:30:49.193Z","comments":true,"path":"2025/01/09/element-plus全局设置组件默认属性/","link":"","permalink":"/2025/01/09/element-plus全局设置组件默认属性/","excerpt":"element-plus全局设置组件默认属性","text":"element-plus全局设置组件默认属性以Dialog组件的close-on-click-modal属性为例，默认是true，通过点击modal可以关闭Dialog。现在全局把它设置成false 方法一1234import ElementPlus, &#123; ElDialog &#125; from &quot;element-plus&quot;;ElDialog.props.closeOnclickModal.default = false;const app = Vue.createApp(App);app.use(ElementPlus); ElDialog.props.closeOnclickModal.default = false;这句来修改默认属性 方法二1234import ElementPlus from &quot;element-plus&quot;;const app = Vue.createApp(App);app.use(ElementPlus);app._context.components.ElDialog[&apos;props&apos;].closeOnClickModal.default = false; app._context.components.ElDialog[&#39;props&#39;].closeOnClickModal.default = false;这句来修改默认属性 总结以上举例了ElDialog组件，其他组件也可以这样设置。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"nodejs通过usb库调用tspl协议控制标签打印机GODEX(G500-U)","slug":"nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U","date":"2024-11-12T07:30:31.000Z","updated":"2024-11-13T08:20:37.181Z","comments":true,"path":"2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/","link":"","permalink":"/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/","excerpt":"nodejs通过usb库调用tspl协议控制标签打印机GODEX","text":"nodejs通过usb库调用tspl协议控制标签打印机GODEX 一首先要下载Zadig，下载地址传送门，他是一个usb通用驱动程序，因为GODEX官方驱动执行device.open会报错。 二接上打印机并开机，然后按照下图做，以达到驱动能被open的目的。 三安装nodejs依赖，方法为npm install usb 四代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const usb = require('usb');/** * 你的设备的vendorId和productId * 这两个id可以通过Zadig工具获取，也可以通过usb.getDeviceList()方法获取 */const vendorId = 0x195F;const productId = 0x1;// 打印方法function PrintLabel(cmds) &#123; let device = usb.findByIds(vendorId, productId) device.open() for (let i = 0, len = device.interfaces.length ; i &lt; len ; i++) &#123; for (let j = 0, len2 = device.interfaces[i].endpoints.length ; j &lt; len2 ; j++) &#123; if (device.interfaces[i].endpoints[j].direction == 'out') &#123; device.interfaces[i].claim() // 找到了要用的对象后，首先要声明所有权 let outEndpoint = device.interfaces[i].endpoints[j] outEndpoint.transferType = 2 // bulk 批量传输 outEndpoint.transfer(cmds, (err) =&gt; &#123; if (err) &#123; console.log(err) &#125; device.close() &#125;) return &#125; &#125; &#125; device.close()&#125;let commands = ` ^Q30,3 ^W50 ^H5 ^P1 ^S2 ^AT ^C1 ^R0 ~Q+0 ^O0 ^D0 ^E12 ~R200 ^XSET,ROTATION,0 ^L Dy2-me-dd Th:m:s BQ,26,15,2,46,40,0,0,WS003 AE,25,130,1,1,0,0,WS00301002 AD,90,178,1,1,0,0,WS003 AB,310,114,1,1,0,0,1241 XRB26,65,4,0,10 WS00301002 XRB325,71,4,0,4 1241 E`// 调用打印方法PrintLabel(commands)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"打印","slug":"打印","permalink":"/tags/打印/"}]},{"title":"Web移动端在线IDE(online-editor)","slug":"Web移动端在线IDE-online-editor","date":"2024-09-18T07:36:51.000Z","updated":"2024-09-18T11:09:55.061Z","comments":true,"path":"2024/09/18/Web移动端在线IDE-online-editor/","link":"","permalink":"/2024/09/18/Web移动端在线IDE-online-editor/","excerpt":"web在线编辑器，适配移动端","text":"web在线编辑器，适配移动端 常用的在线编辑器有：codesandboxcodepenstackblitzplaycodejsfiddle IDE组成在线编辑器由编辑区，预览区，打印输出区三部分组成。对应的组件分别是：Editor,Preview,Console1234567891011// Layout.vue&lt;template&gt; &lt;div class=&quot;layout-wrap&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class=&quot;content-wrap&quot;&gt; &lt;Editor&gt;&lt;/Editor&gt; &lt;Preview&gt;&lt;/Preview&gt; &lt;Console&gt;&lt;/Console&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Editor编辑区就是输入代码的地方，前端常用的代码编辑工具是vsCode，vsCode有一个在线库monaco-editor，这个库是微软专门为浏览器开发的一个在线vsCode，功能与在本地使用的vsCode基本一样，所以，在编辑功能这里使用这个工具库。monaco-editor的具体使用可以参考官网monaco-editor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Editor.vue&lt;template&gt; &lt;div class=&quot;editor-wrap&quot;&gt; &lt;div v-if=&quot;$store.languageType===1&quot;&gt; &lt;div ref=&quot;refHtml&quot; class=&quot;html-wrap&quot;&gt;html&lt;/div&gt; &lt;div ref=&quot;refJs&quot; class=&quot;js-wrap&quot;&gt;js&lt;/div&gt; &lt;div ref=&quot;refCss&quot; class=&quot;css-wrap&quot;&gt;css&lt;/div&gt; &lt;/div&gt; &lt;div v-else ref=&quot;refVue&quot; class=&quot;vue-wrap&quot;&gt;vue&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted, ref, getCurrentInstance, watch, nextTick &#125; from &apos;vue&apos;;import * as monaco from &apos;monaco-editor/esm/vs/editor/editor.api&apos;import &#123; languageMap &#125; from &apos;@/config/constants&apos;const &#123; proxy &#125; = getCurrentInstance();const refHtml = ref(null);const refJs = ref(null);const refCss = ref(null);const refVue = ref(null);const editorArr = [];const createEditor = async (el, language) =&gt; &#123; const editor = monaco.editor.create(el, &#123; model: null, minimap: &#123; enabled: false // 关闭小地图 &#125;, wordWrap: &apos;on&apos;, // 代码超出换行 theme: &apos;vs-dark&apos;, // 主题 fontSize: 14, fontFamily: &apos;Microsoft YaHei&apos;, contextmenu: false, // 不显示右键菜单 fixedOverflowWidgets: true, // 让语法提示层能溢出容器 readOnly: false &#125;) // 设置文档内容 updateDoc(editor, proxy.$store[languageMap[language]], language) // 支持textMate语法解析 // wire(language, editor) // 监听编辑事件 editor.onDidChangeModelContent(() =&gt; &#123; // console.log(&apos;code-change&apos;, editor.getValue()) proxy.$store[languageMap[language]] = editor.getValue(); &#125;) // 监听失焦事件 editor.onDidBlurEditorText(() =&gt; &#123; // console.log(&apos;blur&apos;, editor.getValue()) &#125;) // editor添加入数组保存 editorArr.push(editor);&#125;// 更新编辑器文档模型const updateDoc = (editor, code, language) =&gt; &#123; language = language===&apos;vue&apos;?&apos;html&apos;:language; let oldModel = editor.getModel(); let newModel = monaco.editor.createModel(code, language); editor.setModel(newModel); if (oldModel) &#123; oldModel.dispose(); &#125;&#125;onMounted(()=&gt; &#123;&#125;);watch(()=&gt; proxy.$store.languageType, async ()=&gt; &#123; if(proxy.$store.languageType===1) &#123; await nextTick(()=&gt; &#123; createEditor(refHtml.value, &apos;html&apos;); createEditor(refJs.value, &apos;javascript&apos;); createEditor(refCss.value, &apos;css&apos;); &#125;); &#125;else if(proxy.$store.languageType===2) &#123; await nextTick(()=&gt; &#123; createEditor(refVue.value, &apos;vue&apos;); &#125;); &#125;&#125;, &#123; immediate: true &#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.editor-wrap &#123; .html-wrap, .js-wrap, .css-wrap, .vue-wrap &#123; min-height: 30vh; border: 1px solid #eeeeee; margin: 5px; &#125; .vue-wrap &#123; min-height: 50vh; &#125;&#125;&lt;/style&gt; Preview预览区域应该与主页面隔绝，避免预览的代码污染主体页面。所以需要弄一个沙箱环境，这里选择最简单的iframe来实现。123456789101112131415161718192021222324// Preview.vue&lt;template&gt; &lt;div class=&quot;preview-wrap&quot;&gt; &lt;p&gt;预览&lt;/p&gt; &lt;iframe v-if=&quot;$store.iframeShow&quot; :srcdoc=&quot;$store.docContent&quot; :key=&quot;$store.docContent&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.preview-wrap &#123; height: 50vh; border: 1px solid #eeeeee; margin: 5px; iframe &#123; width: 100%; height: 100%; border: none; &#125;&#125;&lt;/style&gt; iframe的srcdoc内容是点击运行按钮生成的，这段代码在Header组件内：1234567891011121314151617181920212223242526272829303132333435// Header.vue// vanilla代码生成const createHtml = (htmlStr=&apos;&apos;, jsStr=&apos;&apos;, cssStr=&apos;&apos;)=&gt; &#123; if(proxy.$store.languageType===1) &#123; let head = ` &lt;title&gt;预览&lt;\\/title&gt; &lt;style type=&quot;text/css&quot;&gt; $&#123;cssStr&#125; &lt;\\/style&gt; `; let jsContent = ` &lt;script&gt; $&#123;jsStr&#125; &lt;\\/script&gt; `; let body = ` $&#123;htmlStr&#125; $&#123;jsContent&#125; `; return `&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; $&#123;head&#125; &lt;\\/head&gt; &lt;body&gt; &lt;script src=&quot;/onlineEditor/lib/console.js&quot;&gt;&lt;\\/script&gt; $&#123;body&#125; &lt;\\/body&gt; &lt;\\/html&gt; `; &#125;else if(proxy.$store.languageType===2) &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// vue代码生成const createVue = (sfcStr)=&gt; &#123; return `&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; \\/&gt; &lt;title&gt;预览&lt;\\/title&gt; &lt;\\/head&gt; &lt;body&gt; &lt;script src=&quot;/onlineEditor/lib/vue.runtime.global.prod.js&quot;&gt;&lt;\\/script&gt; &lt;script src=&quot;/onlineEditor/lib/vue3-sfc-loader.js&quot;&gt;&lt;\\/script&gt; &lt;script src=&quot;/onlineEditor/lib/console.js&quot;&gt;&lt;\\/script&gt; &lt;script&gt; /* &lt;!-- */ const config = &#123; files: &#123; &apos;\\/main.vue&apos;: \\`$&#123;sfcStr&#125;\\`, &#125; &#125;; /* --&gt; */ const options = &#123; devMode: true, moduleCache: &#123; vue: Vue, &#125;, async getFile(url) &#123; if ( config.files[url] ) return config.files[url]; const res = await fetch(url); if ( !res.ok ) throw Object.assign(new Error(res.statusText + &apos; &apos; + url), &#123; res &#125;); return &#123; getContentData: asBinary =&gt; asBinary ? res.arrayBuffer() : res.text(), &#125; &#125;, addStyle(textContent) &#123; const style = Object.assign(document.createElement(&apos;style&apos;), &#123; textContent &#125;); const ref = document.head.getElementsByTagName(&apos;style&apos;)[0] || null; document.head.insertBefore(style, ref); &#125;, handleModule: async function (type, getContentData, path, options) &#123; switch (type) &#123; case &apos;.png&apos;: return getContentData(true); &#125; &#125;, log(type, ...args) &#123; console[type](...args); &#125; &#125; const app = Vue.createApp(Vue.defineAsyncComponent(() =&gt; window[&apos;vue3-sfc-loader&apos;].loadModule(&apos;/main.vue&apos;, options))) app.mount(document.body); &lt;\\/script&gt; &lt;\\/body&gt; &lt;\\/html&gt;`;&#125; Console打印输出，首先要把预览iframe里的console的所有方法拦截，之后用window.parent.postMessage方法，把信息发送给主页面。当然，主页面也需要注册message事件。123456// App.vuewindow.addEventListener(&apos;message&apos;, (ev) =&gt; &#123; if(ev.data.type === &apos;console&apos;) &#123; proxy.$store.consoleContent.push(ev.data); &#125;&#125;) iframe中的拦截console代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// public/lib/console.jsfunction ProxyConsole() &#123;&#125;;// 拦截console的所有方法[ &apos;debug&apos;, &apos;clear&apos;, &apos;error&apos;, &apos;info&apos;, &apos;log&apos;, &apos;warn&apos;, &apos;dir&apos;, &apos;props&apos;, &apos;group&apos;, &apos;groupEnd&apos;, &apos;dirxml&apos;, &apos;table&apos;, &apos;trace&apos;, &apos;assert&apos;, &apos;count&apos;, &apos;markTimeline&apos;, &apos;profile&apos;, &apos;profileEnd&apos;, &apos;time&apos;, &apos;timeEnd&apos;, &apos;timeStamp&apos;, &apos;groupCollapsed&apos;].forEach((method) =&gt; &#123; let originMethod = console[method] // 设置原型方法 ProxyConsole.prototype[method] = function (...args) &#123; // 发送信息给父窗口 window.parent.postMessage(&#123; type: &apos;console&apos;, method, data: any2str(args) &#125;) // 调用原始方法 originMethod.apply(ProxyConsole, args) &#125;&#125;)// 覆盖原console对象window.console = new ProxyConsole()// 处理console的参数转字符串const any2str = (arr)=&gt; &#123; let str = &apos;&apos;; arr.forEach(item=&gt; &#123; str += change2str(item) + &apos; &apos;; &#125;); return str;&#125;const type = arg=&gt; &#123; return Object.prototype.toString.call(arg).slice(7, -1);&#125;const change2str = content=&gt; &#123; let contentType = type(content) switch (contentType) &#123; case &apos;boolean&apos;: // 布尔值 content = content ? &apos;true&apos; : &apos;false&apos; break; case &apos;null&apos;: // null content = &apos;null&apos; break; case &apos;undefined&apos;: // undefined content = &apos;undefined&apos; break; case &apos;symbol&apos;: // Symbol，Symbol不能直接通过postMessage进行传递，会报错，需要转成字符串 content = content.toString() break; default: break; &#125; return content; &#125; 总结界面截图： 本实例使用vue3+webpack开发，monaco-editor在vite中的兼容性不是很好，所以选择webpack。本实例代码","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"TypeScript教程(二)","slug":"TypeScript教程-二","date":"2024-08-01T06:37:21.000Z","updated":"2024-08-02T02:52:25.948Z","comments":true,"path":"2024/08/01/TypeScript教程-二/","link":"","permalink":"/2024/08/01/TypeScript教程-二/","excerpt":"TypeScript进阶教程","text":"TypeScript进阶教程 Type-Challenges介绍在学习完TypeScript一些基础知识后，已经可以熟练使用一些基本类型定义了，但对于TypeScript的高级用法却依旧无法入门，为了更有趣的学习TypeScript高级用法，选择Type-Challenges类型挑战来作为我们学习的目标。 在Type-Challenges中，可以从简单(easy)、中等(medium)、困难(hard)以及地狱(extreme)难度，循序渐进的学习TypeScript高级技巧。 如果你需要选择其它的方向来深入学习TypeScript高级技巧，这里也有一些推荐的开源项目： 官方内置：在lib.es5.d.ts文件中，TypeScript官方默认内置了一些辅助工具函数，例如：Partial、Required、Pick以及Record等等。 其它开源库：utility-types、ts-toolbelt、SimplyTyped 核心知识点加号和减号 tip加号和减号的用法类似。 在一些内置工具中，可能会出现+或者-这些符号，例如：12345678910type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P]&#125;type Person = &#123; name: string; age?: number;&#125;// 结果：&#123; name: string; age: number; &#125;type result = Required&lt;Person&gt; 观察以上结果可以得出结论：-?是去掉类型中属性后面的?，整个Required的实际效果是去掉T类型中所有属性键后面的?，让所有属性变成必填的。 keyof 和 inkeyof和in经常会连在一起使用，当它们连在一起使用时，通常表示一个迭代的过程。 keyof在TS中，keyof T这段代码表示获取T类型中所有属性键，这些属性键组合成一个联合类型，例如：123456type Person = &#123; name: string; age: number;&#125;// 结果：'name' | 'age'type result = keyof Person TS中的keyof T，它有点类似JavaScript中的Object.keys()，它们的共同点都是获取属性键的集合，只不过keyof T得到的结果是一个联合类型，而Object.keys()得到的是一个数组。 inin操作符的右侧通常跟一个联合类型，可以使用in来迭代这个联合类型，如下：12345// 仅演示使用, K为每次迭代的项K in 'name' | 'age' | 'sex'K = 'name' // 第一次迭代结果K = 'age' // 第二次迭代结果K = 'sex' // 第三次迭代结果 根据keyof和in的特点，我们可以撰写一些辅助工具，这里以Readonly为例。123456789type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P]&#125;type Person = &#123; name: string; age: number;&#125;// 结果：&#123; readony name: string; readonly age: number; &#125;type result = Readonly&lt;Person&gt; 代码详解： [P in keyof T]：这段代码表示遍历T中的每一个属性键，每次遍历时属性键取名为P，这和JavaScript中的for in非常类似：12345// ts中的迭代P in keyof T// js中的迭代for (let key in obj) typeofTS中的typeof，可以用来获取一个JavaScript变量的类型，经常用于获取一个普通对象或者一个函数的类型，如下：123456789101112const add = (a: number, b: number): number =&gt; &#123; return a + b&#125;const obj = &#123; name: 'AAA', age: 23&#125;// 结果：(a: number, b:number) =&gt; numbertype t1 = typeof add// 结果：&#123; name: string; age: number; &#125;type t2 = typeof obj nevernever类型表示永远不会有值的一种类型。 例如，如果一个函数抛出一个错误，那么这个函数就可以用never或者void来表示其返回值，如下：12345678// never更适合用来表示永远没有返回值的函数function handlerError(message: string): never &#123; throw new Error(message)&#125;// void适合用来表示返回值为空的函数function handlerError(message: string): void &#123; throw new Error(message)&#125; 关于never的另外一个知识点是：如果一个联合类型中存在never，那么实际的联合类型并不会包含never，如下：1234// 定义type test = 'name' | 'age' | never// 实际type test = 'name' | 'age' extendsextends关键词，一般有两种用法：类型约束和条件类型。 类型约束类型约束经常和泛型一起使用：12// 类型约束U extends keyof T keyof T是一个整体，它表示一个联合类型。U extends Union这一整段表示U的类型被收缩在一个联合类型的范围内。例如： U extends &#39;name&#39; | &#39;age&#39;，则表示U只能为name或者age二者其中之一。 条件类型常见的条件类型表现形式如下：1T extends U ? 'Y' : 'N' 我们发现条件类型有点像JavaScript中的三元表达式，事实上它们的工作原理是类似的，例如：1234type result1 = true extends boolean ? true : false // truetype result2 = 'name' extends 'name' | 'age' ? true : false // truetype result3 = [1, 2, 3] extends &#123; length: number; &#125; ? true : false // truetype result4 = [1, 2, 3] extends Array&lt;number&gt; ? true : false // true 在条件类型中，有一个特别需要注意的东西就是：分布式条件类型，如下：12345678910111213// 内置工具：交集type Extract&lt;T, U&gt; = T extends U ? T : never;type type1 = 'name'|'age'type type2 = 'name'|'address'|'sex'// 交集结果：'name'type result = Extract&lt;type1, type2&gt;// 推理步骤'name'|'age' extends 'name'|'address'|'sex' ? T : neverstep1： ('name' extends 'name'|'address'|'sex' ? 'name' : never) =&gt; 'name'step2: ('age' extends 'name'|'address'|'sex' ? 'age' : never) =&gt; neverresult: 'name' | never =&gt; 'name' 代码详解： T extends U ? T : never：因为T是一个联合类型，所以这里适用于分布式条件类型的概念。根据其概念，在实际的过程中会把T类型中的每一个子类型进行迭代，如下： 1234// 第一次迭代：'name' extends 'name'|'address'|'sex' ? 'name' : never// 第二次迭代：'age' extends 'name'|'address'|'sex' ? 'age' : never 在迭代完成之后，会把每次迭代的结果组合成一个新的联合类型(根据never类型的特点，最后的结果会剔除掉never)，如下： 1type result = 'name' | never =&gt; 'name' inferinfer关键词的作用是延时推导，它会在类型未推导时进行占位，等到真正推导成功后，它能准确的返回正确的类型。 为了更好的理解infer关键词的用法，我们使用ReturnType这个例子来说明，ReturnType是一个用来获取函数返回类型的工具。 1234567type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : neverconst add = (a: number, b: number): number =&gt; &#123; return a + b&#125;// 结果: numbertype result = ReturnType&lt;typeof add&gt; 代码详解： T extends (...args: any) =&gt; infer R：如果不看infer R，这段代码实际表示：T是不是一个函数类型。 (...args: any) =&gt; infer R：这段代码实际表示一个函数类型，其中把它的参数使用args来表示，把它的返回类型用R来进行占位。如果T满足是一个函数类型，那么我们返回其函数的返回类型，也就是R；如果不是一个函数类型，就返回never。 TS中的infer占位更像JavaScript中的模板字符串：12345// 函数的返回类型使用R占位表示(...args: any) =&gt; info R// 模板字符串中的值，使用变量name占位表示const str = `hello, $&#123;name&#125;` &amp; 符号在TS中有两种类型值得我们重点关注：联合类型和交叉类型。 联合类型一般适用于基本类型的合并，它使用|符号进行连接，如下：1type result = 'name' | 1 | true | null 而交叉类型则适用于对象或者函数的合并，它使用&amp;符号进行连接，如下：1type result = T &amp; U T &amp; U表示一个新的类型，其中这个类型包含T和U中所有的键，这和JavaScript中的Object.assign()函数的作用非常类似。 根据交叉类型的概念，我们可以封装一个合并对象的merge函数，如下：123456789101112131415161718192021// ts v4.8.4以上版本function merge&lt;T, U, K extends T &amp; U&gt;(to: T, from: U): K &#123; for (let key in from) &#123; ;(to as unknown as K)[key] = from[key] as any &#125; return to as unknown as K&#125;// ts v4.8.4以下版本function merge&lt;T, U, K extends T &amp; U&gt;(to: T, from: U): K &#123; for (let key in from) &#123; ;(to as K)[key] = from[key] as any &#125; return to as K&#125;const obj1 = &#123; name: 'AAA' &#125;const obj2 = &#123; age: 23 &#125;// js结果：&#123; name：'AAA'; age: 23; &#125;// ts结果：&#123; name: string; age: number; &#125;const result = merge(obj1, obj2) 初级内置Pick(选取) 用法Pick表示从一个类型中选取指定的几个字段组合成一个新的类型，用法如下：12345678type Person = &#123; name: string; age: number; address: string; sex: number;&#125;// 结果: &#123; name: string; address: string; &#125;type PickResult = Pick&lt;Person, 'name' | 'address'&gt; 实现方式123type MyPick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P]&#125; 代码详解： K extends keyof T：表示K只能是keyof T的子类型，如果我们在使用Pick的时候传递了不存在于T的字段，会报错：12// 报错：phone无法分配给keyof Ttype result = MyPick&lt;Person, 'name' | 'phone'&gt; 内置Readonly(只读) 用法Readonly是用来让所有属性变为只读，其用法为：1234567type Person = &#123; readonly name: string; age: number;&#125;// 结果：&#123; readonly name: string; readonly age: number; &#125;type result = MyReadonly&lt;Person&gt; 实现方式123type MyReadonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P]&#125; TupleToObject(元组转对象) 用法TupleToObject&lt;T&gt;是用来把一个元组转换成一个key/value相同的对象，例如：1234// 类型：readonly ['msg', 'name']const tuple = ['msg', 'name'] as const// 结果：&#123; msg: 'msg'; name: 'name'; &#125;type result = TupleToObject&lt;typeof tuple&gt; 实现方式123type TupleToObject&lt;T extends readonly any[]&gt; = &#123; [P in T[number]]: P&#125; 代码详解： as const：常用来进行常量断言，在此处表示将[&#39;msg&#39;,&#39;name&#39;]推导常量元组，表示其不能新增、删除、修改元素，可以使用as readonly来辅助理解。 T[number]：表示返回数组中所有数字型索引的元素，形成一个联合类型，例如：&#39;msg&#39;|&#39;name&#39;。 First(数组第一个元素) 用法First&lt;T&gt;用来返回数组的第一个元素，用法如下：1234// 结果：3type result1 = First&lt;[3, 2, 1]&gt;// 结果：nevertype result2 = First&lt;[]&gt; 实现方式1234// 索引实现方式type First&lt;T extends any[]&gt; = T extends [] ? never : T[0]// 占位实现方式type First&lt;T extends any[]&gt; = T extends [infer R, ...infer L] ? R : never 代码详解： T extends []：用来判断T是否是一个空数组。 T[0]：根据下标取数组第一个元素。 infer R： 表示数组第一个元素的占位。 ...infer L: 表示数组剩余元素的占位。 Length(元组的长度) 用法Length&lt;T&gt;用来获取一个数组(包括类数组)的长度，用法如下：1234// 结果：3type result1 = Length&lt;[1, 2, 3]&gt;// 结果：10type result2 = Length&lt;&#123; 5: '5', length: 10 &#125;&gt; 实现方式1type Length&lt;T extends any&gt; = T extends &#123; length: number; &#125; ? T['length'] : never 代码详解： T extends { length: number; }：判断T是否是{ length: number; }的子类型，如果是则代表T为数组或者类数组。 T[&#39;length&#39;]：取T对象的length属性的值(注意，在TypeScript中不能使用T.length来取值，而应该使用T[&#39;length&#39;])。 内置Exclude(排除) 用法Exclude是排除的意思，它从T类型中排除属于U类型的子集，可以理解成取T对于U的差集，用法如下：12// 结果：'name'|'age'type ExcludeResult = Exclude&lt;'name'|'age'|'sex', 'sex'|'address'&gt; 实现方式1type MyExclude&lt;T, U&gt; = T extends U ? never : T T extends U：这段代码会从T的子类型开始分发，例如：12345678T extends U =&gt; 'name'|'age'|'sex' extends 'sex'|'address'=&gt; ( 'name' extends 'sex'|'address' ? never : 'name' | 'age' extends 'sex'|'address' ? never : 'age' | 'sex' extends 'sex'|'address' ? never : 'sex')=&gt; 'name'|'age' PromiseType(promise包裹类型) 用法PromiseType是用来获取Promise包裹类型的，例如：123456789function getInfo (): Promise&lt;string|number&gt; &#123; return Promise.resolve(1)&#125;// 结果：(） =&gt; Promise&lt;string|number&gt;type funcType = typeof getInfo// 结果：Promise&lt;string|number&gt;type returnResult = ReturnType&lt;funcType&gt;// 结果：string|numbertype PromiseResult = PromiseType&lt;returnResult&gt; 实现方式123456type PromiseType&lt;T&gt; = T extends Promise&lt;infer R&gt; ? R extends Promise&lt;any&gt; ? PromiseType&lt;R&gt; : R : never 代码详解： T extends Promise&lt;infer R&gt;：判断T是否是Promise&lt;infer R&gt;的子类型，也就是说T必须满足Promise&lt;any&gt;的形式。 If(判断) 用法If&lt;C, T, F&gt;用来表示根据C的值来返回T或者F，如果C为true，则返回T；如果C为false，则返回F，例如：1234// 结果：'a'type result1 = If&lt;true, 'a', 'b'&gt;// 结果：'b'type result2 = If&lt;false, 'a', 'b'&gt; 根据上案例，我们可以直观的发现If&lt;C, T, F&gt;的作用有点类似JavaScript中的三元表达式：C ? T : F。 实现方式1type If&lt;C extends boolean, T, F&gt; = C extends true ? T : F 代码详解： C extends boolean：表示C为boolean类型的子类型，既C只能为true或者false，传递其它值报错。 C extends true：如果用JavaScript来表示的话，相当于C===true. Concat(数组concat方法) 用法Concat&lt;T, U&gt;用来将两个数组合并起来，类似实现数组的concat方法，使用方式如下：12// 结果：[1, 2, 3, 4]type result = Concat&lt;[1, 2], [3, 4]&gt; 实现方式1type Concat&lt;T extends any[], U extends any[]&gt; = [...T, ...U] 代码详解： T extends any[]：用来限制T是一个数组，如果传递非数组会报错，U也是一样的道理。 [...T, ...U]：可以理解成JavaScript的扩展运算符...。 Includes(数组includes方法) 用法Includes&lt;T, U&gt;用来判断U是否在数组T中，类似实现数组的includes方法，用法如下：1234// 结果：truetype result1 = Includes&lt;[1, 2, 3], 1&gt;// 结果：falsetype result2 = Includes&lt;[1, 2, 3], '1'&gt; 实现方式12345678910111213type Equal&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : false// 简单版type MyIncludes&lt;T extends readonly any[], U&gt; = U extends T[number] ? true : false// 完善版type MyIncludes&lt;T extends readonly any[], U&gt; = T extends [infer R, ...infer L] ? Equal&lt;R, U&gt; extends true ? true : MyIncludes&lt;L, U&gt; : false 代码详解： T[number]：它返回数组中所有数字类型键对应的值，将这些值构造成一个联合类型，例如：1 | 2 | 3。 U extends T[number]：判断U是否是某个联合类型的子类型，例如：1 extends 1 | 2 | 3。 Equal：是用来判断两个值是否相等的辅助方法。 Push(数组push方法) 用法12// 结果：[1, 2, 3, 4]type result = Push&lt;[1, 2, 3], 4&gt; 实现方式12// Push实现type Push&lt;T extends any[], K&gt; = [...T, K] Unshift(数组unshift方法) 与pop和push方法相似的另外一对方法叫shift和unshift，它们的实现思路是一样的。 用法12// 结果：[0, 1, 2, 3]type result = Unshift&lt;[1, 2, 3], 0&gt; 实现方式12// Unshift实现type Unshift&lt;T extends any[], K&gt; = [K, ...T] 内置Parameters(函数的参数类型) 用法Parameters是用来获取一个函数的参数类型的，其中获取的结果是一个元组，用法如下：123const add = (a: number, b: string): void =&gt; &#123;&#125;// [number, string]type result = MyParameters&lt;typeof add&gt; 实现方式1type MyParameters&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer R) =&gt; any ? R : never 内置Partial(可填)和内置Required(必填) tip此题不属于type-challenges类型挑战题 用法Partial和Required一个是让所有属性可填、另外一个是让所有属性必填，用法如下：12345678910type Person = &#123; name: string; age?: number;&#125;// 结果: &#123; name?: string; age?: number; &#125;type PartialResult = MyPartial&lt;Person&gt;// 结果: &#123; name: string; age: number; &#125;type RequiredResult = MyRequired&lt;Person&gt; 实现方式123456type MyPartial&lt;T&gt; = &#123; [P in keyof T]?: T[P]&#125;type MyRequired&lt;T&gt; = &#123; [P in keyof T]-?: T[P]&#125; 内置Record(构造) tip此题不属于type-challenges类型挑战题 用法Record&lt;K, T&gt;用来将K的每一个键(k)指定为T类型，这样由多个k/T组合成了一个新的类型，用法如下：123456789101112131415161718type keys = 'Cat'|'Dot'type Animal = &#123; name: string; age: number;&#125;type Expected = &#123; Cat: &#123; name: string; age: number; &#125;; Dog: &#123; name: string; age: number; &#125;&#125;// 结果：Expectedtype RecordResult = Record&lt;keys, Animal&gt; 实现方式123type MyRecord&lt;K extends keyof any, T&gt; = &#123; [P in K]: T&#125; 代码详解： K extends keyof any：此代码表示K是keyof any任意类型其所有键的子类型，例如：123456789// K为 'Dog'|'cat'type UnionKeys = 'Dog' | 'Cat'// K为'name'|'age'type Person = &#123; name: string; age: number;&#125;type TypeKeys = keyof Person 内置Extract(交集) tip此题不属于type-challenges类型挑战题 用法Extract&lt;T, U&gt;用来取联合类型T和U的交集，用法如下：12345678type Person = &#123; name: string; age: number; address: string;&#125;// 结果：'age'|'address'type ExtractResult = Extract&lt;keyof Person, 'age'|'address'|'sex'&gt; 实现方式1type MyExtract&lt;T, U&gt; = T extends U ? T : never 代码详解： T extends U：此代码会自动将T的子类型进行分发，例如：12345678T extends U=&gt; 'name'|'age'|'address' extends 'age'|'address'|'sex' ? T : never=&gt; ( 'name' extends 'age'|'address'|'sex' ? 'name' : never | 'age' extends 'age'|'address'|'sex' ? 'age' : never | 'address' extends 'age'|'address'|'address' ? 'age' : never)=&gt; 'age'|'address' 中级内置ReturnType(函数返回类型) 用法ReturnType&lt;T&gt;是用来获取一个函数的返回类型的，例如：12345function getRandom (): number &#123; return Math.random()&#125;// 结果：numbertype result = ReturnType&lt;typeof getRandom&gt; 实现方式1type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : never 代码详解： T extends (...args: any) =&gt; infer R：判断T类型是否是一个函数的子类型，既T是不是一个函数。 infer R：表示待推导的函数返回类型为R，后续可以在表达式中使用R来代替真正的返回类型。 内置Omit(移除) 用法Omit是移除的意思，它用来在T类型中移除指定的字段，用法如下：12345678type Person = &#123; name?: string; age: number; address: string;&#125;// 结果：&#123; name？: string; age: number; &#125;type OmitResult = Omit&lt;Person, 'address'&gt; 实现方式Omit可以借助在上面已经实现过的Pick和Exclude配合来实现，如下：12// Omit实现type MyOmit&lt;T, K&gt; = MyPick&lt;T, MyExclude&lt;keyof T, K&gt;&gt; 代码详解： 使用MyExclude&lt;keyof T, K&gt;，可以从T中移除指定的字段，移除后得到一个新的联合类型：&#39;name&#39;|&#39;age&#39; 使用MyPick&lt;T, &#39;name&#39;|&#39;age&#39;&gt;，可以从T中选取这两个字段，组合成一个新的类型。 Readonly(按需Readonly) 用法不同于初级实现中的Readonly，在中级实现的Readonly中，如果我们传递了指定的字段，那么Readonly会表现为按需实现readonly，用法如下。123456789101112131415161718192021222324252627282930interface Todo &#123; title: string; desc?: string; completed: boolean;&#125;interface Expected1 &#123; readonly title: string; readonly desc?: string; readonly completed: boolean;&#125;interface Expected2 &#123; title: string; readonly desc?: string; readonly completed: boolean;&#125;// 结果：Expected1type ReadonlyResult1 = Readonly&lt;Todo&gt;// 结果：Expected2type ReadonlyResult2 = Readonly&lt;Todo, 'desc'|'completed'&gt;// 测试：const obj: ReadonlyResult2 = &#123; title: 'AAA', desc: '23', completed: true&#125;obj.title = 'aaa'obj.desc = '32' // errorobj.completed = false // error 实现方式12345678// ts v4.4+版本可直接用type Readonly&lt;T, K extends keyof T = keyof T&gt; = T &amp; &#123; readonly [P in K]: T[P]&#125;// ts v4.5+版本必须用type Readonly&lt;T, K extends keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123; readonly [P in K]: T[P]&#125; 代码详解： K extends keyof T = keyof T：如要传递了K，那么只能是T中已经存在的属性，不存在则报错；如果不传递，则默认值为keyof T，意味着全部属性都添加readonly。 T &amp; U：在本例中表示将T和U中的字段结合起来，如果没有&amp;会丢失一些属性，例如title。 DeepReadonly(深度Readonly) 用法DeepReadonly用来将一个嵌套对象类型中所有字段全部添加readonly关键词，例如：123456789101112131415161718// 类型：type X = &#123; b: string c: &#123; d: boolean e: undefined, f: null &#125;&#125;// 结果：type Y = &#123; readonly b: string readonly c: &#123; readonly d: boolean readonly e: undefined, readonly f: null &#125;&#125; 实现方式123type DeepReadonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] extends &#123; [key: string]: any &#125; ? DeepReadonly&lt;T[P]&gt; : T[P]&#125; 代码详解： T[P] extends { [key: string]: any }：这段表示T[P]是否是一个包含索引签名的字段，如果包含我们认为它是一个嵌套对象，就可以递归调用DeepReadonly。 TupleToUnion(元组转联合类型) 用法TupleToUnion是用来将一个元组转换成联合类型的，其用法如下：12// 结果：'1' | '2' | '3'type result = TupleToUnion&lt;['1', '2', '3']&gt; 实现方式1234567// way1: T[number]type TupleToUnion&lt;T extends readonly any[]&gt; = T[number]// way2: 递归type TupleToUnion&lt;T extends readonly any[]&gt; = T extends readonly [infer R, ...infer args] ? R | TupleToUnion&lt;args&gt; : never 代码详解： T[number]：它会自动迭代元组的数字型索引，然后将所有元素组合成一个联合类型。 R | TupleToUnion&lt;args&gt;：R表示每一次迭代中的第一个元素，它的迭代过程可以用下面伪代码表示：1234567891011121314// 第一次迭代const R = '1'const args = ['2', '3']const result = '1' | TupleToUnion&lt;args&gt;// 第二次迭代const R = '2'const args = ['3']const result = '1' | '2' | TupleToUnion&lt;args&gt;// 第三次迭代const R = '3'const args = ['']const result = '1' | '2' | '3' Chainable(可串联构造器) 用法Chainable是用来让一个对象可以进行链式调用的，用法如下：1234567891011121314type Expected = &#123; foo: number bar: &#123; value: string &#125; name: string&#125;declare const obj: Chainable&lt;&#123;&#125;&gt;// 结果：Expectedconst result = obj .options('foo', 123) .options('bar', &#123; value: 'Hello' &#125;) .options('name', 'TypeScript') .get() 实现方式1234type Chainable&lt;T&gt; = &#123; options&lt;K extends string, V&gt;(key: K, value: V): Chainable&lt;T &amp; &#123;[k in K]: V&#125;&gt; get(): T&#125; 代码详解： {[k in K]: V}：每次调用options时，把key/value构造成一个对象，例如：{ foo: 123 }。 T &amp; U：此处使用到&amp;关键词，用来合并T和U两个对象中的所有key。 Chainable&lt;&gt;：递归调用Chainable，赋予新对象以链式调用的能力。 Last(数组最后一个元素) 用法Last是用来获取数组中最后一个元素的，它和我们之前已经实现的First思路很相似。12// 结果：3type result = Last&lt;[1, 2, 3]&gt; 实现方式Last的实现方式很巧妙，因为它既可以在索引上做文章来实现，也可以用占位的思想来实现。1234// way1：索引思想type Last&lt;T extends any[]&gt; = [any, ...T][T['length']]// way2: 后占位思想type Last&lt;T extends any[]&gt; = T extends [...infer R, infer L] ? L : never 代码详解： [any, ...T]：此代码表示我们构建了一个新数组，并添加了一个新元素到第一个位置，然后把原数组T中的元素依次扩展到新数组中，可以用以下伪代码表示： 123456// 原数组const T = [1, 2, 3]// 新数组const arr = [any, 1, 2, 3]// 结果: 3const result = arr[T['length']] T[&#39;length&#39;]：这里我们获取到的是原始T数组的长度，例如[1, 2, 3]，长度值为3。而在新数组中，索引为3的位置正好是最后一个元素的索引，通过这种方式就能达到我们的目的。 T extends [...infer R, infer L]：这段代码表示，我们将原数组中最后一个元素使用L进行占位，而其它元素我们用一个R数组表示。这样，如果数组满足这种格式，就能正确返回最后一个元素的值。 Pop(数组Pop方法) 继续沿用以上处理索引思想或占位的思想，我们能快速实现数组pop方法。 用法1234// 结果1：[1, 2]type result1 = Pop&lt;[1, 2, 3]&gt;// 结果2：[]type result2 = Pop&lt;[]&gt; 实现方式1234567// Pop实现type Pop&lt;T extends any[]&gt; = T extends [] ? [] : T extends [...infer Rest, infer L] ? Rest : never PromiseAll返回类型 用法PromiseAll是用来取Promise.all()函数所有返回的类型，其用法如下12345678910111213const result1 = PromiseAll([1, 2, 3] as const)const result2 = PromiseAll([1, 2, Promise.resolve(3)] as const)const result3 = PromiseAll([1, 2, Promise.resolve(3)])const result4 = PromiseAll&lt;Array&lt;number | Promise&lt;number&gt;&gt;&gt;([1, 2, 3])// 结果1： Promise&lt;[1, 2, 3]&gt;type t1 = typeof result1// 结果2： Promise&lt;[1, 2, number]&gt;type t2 = typeof result2// 结果3： Promise&lt;[number, number, number]&gt;type t3 = typeof result3// 结果4： Promise&lt;number[]&gt;type t4 = typeof result4 实现方式与之前的例子不同，PromiseAll我们声明的是一个function而不是type。12345// Awaited为内置类型type PromiseAllType&lt;T&gt; = Promise&lt;&#123; [P in keyof T]: Awaited&lt;T[P]&gt;&#125;&gt;declare function PromiseAll&lt;T extends any[]&gt;(values: readonly [...T]): PromiseAllType&lt;T&gt; 代码详解： 因为Promise.all()函数接受的是一个数组，因此泛型T限制为一个any[]类型的数组。 PromiseAllType的实现思路有点像之前的PromiseType，只不过这里多了一层Promise的包裹，因为Promise.all()的返回类型也是一个Promise。 LookUp(查找) 用法LookUp是用来根据类型值查type找类型的，其用法如下：123456789101112interface Cat &#123; type: 'cat' color: 'black' | 'orange' | 'gray'&#125;interface Dog &#123; type: 'dog' color: 'white' name: 'wang'&#125;// 结果：Dogtype result = LookUp&lt;Cat | Dog, 'dog'&gt; 实现方式1234type LookUp&lt; U extends &#123; type: string; &#125;, T extends string&gt; = U extends &#123; type: T &#125; ? U : never 代码详解： U extends { type: string; }：这段代码限制U的类型必须是具有属性为type的对象。 U extends { type: T }：如果把T的值实际带入，为U extends { type: &#39;dog&#39; }，表示判断U中的type值是不是dog，是则返回U。 Trim、TrimLeft以及TrimRightTrimLeft：TrimRight：Trim： 用法Trim、TrimLeft以及TrimRight这几个工具比较好理解，它们都是用来移除字符串中的空白符的。123type t1 = TrimLeft&lt;' str'&gt; // 'str'type t2 = Trim&lt;' str '&gt; // 'str'type t3 = TrimRight&lt;'str '&gt; // 'str' 实现方式1234type Space = ' ' | '\\n' | '\\t'type TrimLeft&lt;S extends string&gt; = S extends `$&#123;Space&#125;$&#123;infer R&#125;` ? TrimLeft&lt;R&gt; : Stype Trim&lt;S extends string&gt; = S extends (`$&#123;Space&#125;$&#123;infer R&#125;` | `$&#123;infer R&#125;$&#123;Space&#125;`) ? Trim&lt;R&gt; : Stype TrimRight&lt;S extends string&gt; = S extends `$&#123;infer R&#125;$&#123;Space&#125;` ? TrimRight&lt;R&gt; : S 代码详解： TrimLeft和TrimRight的实现思路是相同的，区别在于空白符的占位出现在左侧还是右侧。 Trim的实现就是把TrimLeft和TrimRight所做的事情结合起来。 Capitalize(首字母大写)和UnCapitalize(首字母小写) 用法Capitalize是用来将一个字符串的首字母变成大写的，而UnCapitalize所做的事情跟它相反，其用法如下：12type t1 = Capitalize&lt;'hello'&gt; // 'Hello'type t2 = UnCapitalize&lt;'Hello'&gt; // 'hello' 实现方式12type Capitalize&lt;S extends string&gt; = S extends `$&#123;infer char&#125;$&#123;infer L&#125;` ? `$&#123;Uppercase&lt;char&gt;&#125;$&#123;L&#125;` : Stype UnCapitalize&lt;S extends string&gt; = S extends `$&#123;infer char&#125;$&#123;infer L&#125;` ? `$&#123;Lowercase&lt;char&gt;&#125;$&#123;L&#125;` : S 代码详解： 无论是Capitalize还是UnCapitalize，它们都依赖内置的工具函数Uppercase或者Lowercase。对于Capitalize而言，我们只需要把首字母隔离出来，然后调用Uppercase即可。对于UnCapitalize而言，我们把首字母调用Lowercase即可。 Replace 用法Replace是用来将字符串中第一次出现的某段内容，使用指定的字符串进行替换，而ReplaceAll是全部替换，其用法如下：1234// 结果1：'foofoobar'type t1 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;// 结果2： foobarbartype t2 = Replace&lt;'foobarbar', '', 'foo'&gt; 实现方式123456789type Replace&lt; S extends string, from extends string, to extends string&gt; = S extends `$&#123;infer L&#125;$&#123;from&#125;$&#123;infer R&#125;` ? from extends '' ? S : `$&#123;L&#125;$&#123;to&#125;$&#123;R&#125;` : S ReplaceAll 用法ReplaceAll是用来将字符串中指定字符全部替换的，其用法如下：12// 结果：'foofoofoo'type t = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt; 实现方式123456789type ReplaceAll&lt; S extends string, from extends string, to extends string&gt; = S extends `$&#123;infer L&#125;$&#123;from&#125;$&#123;infer R&#125;` ? from extends '' ? S : `$&#123;ReplaceAll&lt;L, from, to&gt;&#125;$&#123;to&#125;$&#123;ReplaceAll&lt;R, from, to&gt;&#125;` : S AppendArgument(追加参数) 用法AppendArgument是用来向一个函数追加一个参数的，其用法如下：12// 结果：(a: number, b: number) =&gt; numbertype result = AppendArgument&lt;(a: number) =&gt; number, number&gt; 实现方式1type AppendArgument&lt;Fn, A&gt; = Fn extends (...args: infer R) =&gt; infer T ? (...args: [...R, A]) =&gt; T : never 代码详解： 我们首先利用infer关键词得到了Fn函数的参数类型以及返回类型，然后把新的参数添加到参数列表，并原样返回其函数类型。 Permutation(排列组合) 用法Permutation是用来将联合类型中的每一个类型进行排列组合，其用法如下：1234// 结果1：['A', 'B'] | ['B', 'A']type result1 = Permutation&lt;'A' | 'B'&gt;// 结果2：['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']type result2 = Permutation&lt;'A' | 'B' | 'C'&gt; 实现方式123456type Permutation&lt;T, U = T&gt; = [T] extends [never] ? [] : T extends U ? [T, ...Permutation&lt;Exclude&lt;U, T&gt;&gt;] : never 代码详解： [T] extends [never]：这段代码主要是为了处理联合类型为空的情况。 T extends U：这段代码主要是需要使用分布式条件类型这个知识点，当T extends U成立时，在其后的判断语句中，T代表当前迭代的类型。 &lt;Exclude&lt;U, T&gt;：因为此时的T代表当前迭代的类型，所以我们从原始联合类型中排除当前类型，然后递归调用Permutation。当T为A时，递归调用Permutation&lt;&#39;B&#39; | &#39;C&#39;&gt;, 此时结果为[&#39;A&#39;] + [&#39;B&#39;, &#39;C&#39;] 或 [&#39;A&#39;] + [&#39;C&#39;, &#39;B&#39;]。 LengthOfString(字符串的长度) 用法LengthOfString是用来计算一个字符串长度的，其用法如下：1type result = LengthOfString&lt;'Hello'&gt; // 5 实现方式123456type LengthOfString&lt; S extends string, T extends string[] = []&gt; = S extends `$&#123;infer Char&#125;$&#123;infer R&#125;` ? LengthOfString&lt;R, [...T, Char]&gt; : T['length'] 代码详解： 我们通过一个泛型的辅助数组来帮计算字符串的长度，在第一次符合条件时，将其第一个字符添加到数组中，在后续的递归过程中，如果不符合条件，直接返回T[&#39;length&#39;]，这个过程可以用如下代码表示：12345678910// 第一次递归const T = ['H'], S = 'hello', R = 'ello'// 第二次递归const T = ['H','e'], S = 'ello', R = 'llo'// 第三次递归const T = ['H','e','l'], S = 'llo', R = 'lo'// 第四次递归const T = ['H','e','l','l'], S = 'lo', R = 'o'// 第五次递归const T = ['H','e','l','l', 'o'], S = 'o', R = '' Flatten(数组降维) 用法Flatten是用来将多维数组进行降维的，其用法如下：12// 结果：[1, 2, 3]type result = Flatten&lt;[1, 2, [3]]&gt; 实现方式1234567type Flatten&lt; T extends any[]&gt; = T extends [infer L, ...infer R] ? L extends any[] ? [...Flatten&lt;L&gt;, ...Flatten&lt;R&gt;] : [L, ...Flatten&lt;R&gt;] : [] 代码详解：Flatten数组降维的主要思路是，遍历数组中的每一个元素，判断其是否为一个数组，如果是，则递归调用Flatten，进行降维。 AppendToObject(对象添加新属性) 用法AppendToObject是用来向指定对象添加一个额外的属性(key/value)，其用法如下：12// 结果：&#123; id: number; name: string; &#125;type result = AppendToObject&lt;&#123; id: number; &#125;, 'name', string&gt; 实现方式1234type basicKeyType = string | number | symboltype AppendToObject&lt;T, K extends basicKeyType, V&gt; = &#123; [P in keyof T | K]: P extends keyof T ? T[P] : V&#125; 代码详解： basicKeyType：在JavaScript中，因为一个对象的属性只能是string、number或者symbol这三种类型，所以我们限定K必须满足此条件。 keyof T | K：这里表示keyof T的联合类型和K，组合成一个新的联合类型。 Absolute(绝对值) 用法Absolute是用来取一个数的绝对值的，其用法如下：1234// 结果1：\"531\"type result1 = Absolute&lt;-531&gt;// 结果2：\"9999\"type result2 = Absolute&lt;9_999n&gt; 实现方式12type NumberLike = number | string | biginttype Absolute&lt;T extends NumberLike&gt; = `$&#123;T&#125;` extends `-$&#123;infer N&#125;` ? N : `$&#123;T&#125;` 代码详解： NumberLike：我们认为&#39;1&#39;和1都是一个合法的数字，所以定义一个辅助的NumberList联合类型。 ${T} extends -${infer N}：这里判断我们传递的数字是否为负数，如果是则直接取其正数部分，否则直接返回。 注意：这里说到的取绝对值，最后的结果之所以是一个字符串类型，是因为TS对递归次数有限制。如果你想要真正的数字类型，可以考虑实现一个MakeArray辅助方法，使用此方法可以将字符串类型的数字，转换成一个真正的数字类型，如下：1234567type MakeArray&lt;N extends string, T extends any[] = []&gt; = N extends `$&#123;T['length']&#125;` ? T : MakeArray&lt;N, [...T, 0]&gt;// 结果：3type result = MakeArray&lt;'3'&gt;['length'] StringToArray(字符串转数组) tip此题不属于type-challenges类型挑战题 用法StringToArray是用来将一个字符串转换成一个数组的，其用法如下：12// 结果：['h', 'e', 'l', 'l', 'o']type result = StringToArray&lt;'hello'&gt; 实现方式123456type StringToArray&lt; S extends string, U extends any[] = []&gt; = S extends `$&#123;infer Char&#125;$&#123;infer R&#125;` ? StringToArray&lt;R, [...U, Char]&gt; : U 代码详解：StringToArray的实现主要是使用了递归的思想，它每次拿到字符串中一个字符，然后存入一个辅助数组中，当字符串为空时，直接返回这个辅助数组。 StringToUnion(字符串转联合类型) 用法在实现StringToArray后，我们能够很容易实现StringToUnion，其用法如下：12// 结果：'h' | 'e' | 'l' | 'l' | 'o'type result = StringToUnion&lt;'hello'&gt; 实现方式12345678// way1: 递归思想type StringToUnion&lt; S extends string&gt; = S extends `$&#123;infer Char&#125;$&#123;infer R&#125;` ? Char | StringToUnion&lt;R&gt; : never// way2: 借用StringToArraytype StringToUnion&lt;S extends string&gt; = StringToArray&lt;S&gt;[number] 代码详解：StringToArray&lt;S&gt;返回的是一个数组，T[number]表示对一个数组进行数字类型索引迭代，其迭代结果是每个元素组合成的一个联合类型。 Merge(类型合并) 用法Merge是用来合并两个类型，如果有重复的字段类型，则第二个的字段类型覆盖第一个的，其用法如下：1234567891011type Foo = &#123; a: number; b: string;&#125;type Bar = &#123; b: number; c: boolean;&#125;// 结果：&#123; a: number; b: number; c: boolean; &#125;type result = Merge&lt;Foo, Bar&gt; 实现方式123type Merge&lt;F, S&gt; = &#123; [P in keyof F | keyof S]: P extends keyof S ? S[P] : P extends keyof F ? F[P] : never&#125; 代码详解： keyof F | keyof S：这段代码的含义是将F和S这两个对象的键组合成一个新的联合类型。 P extends：这里进行了两次extends判断，其中第二次不能直接写成F[P]，而应该多判断一次，当满足条件时才使用F[P]，这是因为P的类型判断无法作用于:符号后面。 KebabCase(字符串转连字符) 用法KebabCase是用来将驼峰形式字符串，转成连字符形式字符串的，其用法如下：12// 结果：foo-bar-baztype result = KebabCase&lt;'FooBarBaz'&gt; 实现方式1234567type KebabCase&lt; S extends string&gt; = S extends `$&#123;infer S1&#125;$&#123;infer S2&#125;` ? S2 extends Uncapitalize&lt;S2&gt; ? `$&#123;Uncapitalize&lt;S1&gt;&#125;$&#123;KebabCase&lt;S2&gt;&#125;` : `$&#123;Uncapitalize&lt;S1&gt;&#125;-$&#123;KebabCase&lt;S2&gt;&#125;` : S Diff(类型差异部分) 用法Diff是用来获取两个类型的不同部分的，其用法如下：12345678910111213type Foo = &#123; id: number; name: string; age: string;&#125;type Bar = &#123; name: string; age: string; gender: number;&#125;// 结果：&#123; id: number; gender: number; &#125;type result = Diff&lt;Foo, Bar&gt; 实现方式1234type DiffKeys&lt;T, U&gt; = Exclude&lt;keyof T | keyof U, keyof (T | U)&gt;type Diff&lt;T, U&gt; = &#123; [K in DiffKeys&lt;T, U&gt;]: K extends keyof T ? T[K] : K extends keyof U ? U[K] : never&#125; 代码详解： keyof Foo | keyof Bar：这段代码是把T和U中的所有属性组合成一个新的联合类型。 keyof (T | U)：这段代码是取T和U的公共属性。 Exclude&lt;K1, K2&gt;：这段代码主要是用来从K1中排除K2，带入以上例子也就是排除掉所有公共属性。 Diff&lt;T, U&gt;：在获取到DiffKeys后，就可以迭代的方式获取到每个属性key，它所对应的类型了。 K extends keyof U：额外再判断一次，是因为K不能在三元表达式右侧使用。 AnyOf(数组元素真值判断) 用法AnyOf用来判断数组元素真假值的，如果任一值为真，返回true；数组为空或者全部为false，才返回false，其用法如下：1234// 结果1：truetype result1 = AnyOf&lt;[0, false, 0, &#123; name: 'name' &#125;]&gt;// 结果2：falsetype result2 = AnyOf&lt;[0, '', false, [], &#123;&#125;]&gt; 实现方式12type FalsyType = 0 | '' | false | undefined | null | [] | &#123; [key: string]: never &#125;type AnyOf&lt;T extends readonly any[]&gt; = T[number] extends FalsyType ? false : true 代码详解：因为我们就是要区分true/false，所以我们把所有为false的值全部列举出来，然后使用T[number]索引迭代，依次去跟FalsyType比较，其中{ [key: string]: never }表示空对象{}。 IsNever(是否是Never类型) 用法IsNever是用来判断是否为never类型，其用法如下：123456// 结果1：falsetype result1 = IsNever&lt;undefined&gt;// 结果2：truetype result2 = IsNever&lt;never&gt;// 结果3：falsetype result3 = IsNever&lt;never | string&gt; 实现方式12345678910export type Equal&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : false// way1: 类型数组type IsNever&lt;T&gt; = T[] extends never[] ? true : false// way2: 数组值type IsNever&lt;T&gt; = [T] extends [never] ? true : false// way3: 值比较type IsNever&lt;T&gt; = Equal&lt;T, never&gt; IsUnion(是否联合类型) 用法IsUnion是用来判断一个类型是否为联合类型的，其用法如下：123456// 结果1：truetype result1 = IsUnion&lt;string|number|boolean&gt;// 结果2：falsetype result2 = IsUnion&lt;string&gt;// 结果3：falsetype result2 = IsUnion&lt;never&gt; 实现方式1234567891011121314151617// way1: 排除法type IsUnion&lt;T, U = T&gt; = [T] extends [never] ? false : T extends U ? [Exclude&lt;U, T&gt;] extends [never] ? false : true : false// way2: 正反对比法type IsUnion&lt;T, U = T&gt; = (T extends U ? U extends T ? true : unknown : false ) extends true ? false : true 代码详解：上面的实现虽然代码不多，但可能无法一下子就弄明白，为了更好的理解这种实现方式，我们来看如下两个案例分析：12345678910111213// 案例一type T = string | numberstep1: string | number extends string | numberstep2: string extends string | number =&gt; [number] extends [never] =&gt; truestep3: number extends string | number =&gt; [string] extends [never] =&gt; truestep4: true | trueresult: true// 案例二type T = stringstep1: string extends stringstep2: [never] extends [never] =&gt; falseresult: false 根据之前我们学到的分布式条件类型知识，T extends U的时候，会把T进行子类型分发。 如案例一的step3、step4，在分发后会把每次迭代的结果联合起来，组合成最终的结果。 ReplaceKeys(类型替换) 用法ReplaceKeys是用来在一个类型中，使用指定的Y类型来替换已经存在的T类型的，其用法如下：12// 结果：&#123; id: number; name: boolean; &#125;type result = ReplaceKeys&lt;&#123; id: number; name: string; &#125;, 'name', &#123; name: boolean; &#125;&gt; 实现方式12345678type ReplaceKeys&lt;U, T, Y&gt; = &#123; [P in keyof U]: P extends T ? P extends keyof Y ? Y[P] : never : U[P]&#125; RemoveIndexSignature(移除索引签名) 用法RemoveIndexSignature是用来移除一个类型中的索引签名的，其用法如下：1234567type Foo = &#123; [key: string]: any; foo(): void;&#125;// 结果：&#123; foo(): void; &#125;type result = RemoveIndexSignature&lt;Foo&gt; 实现方式1234type CheckIndexSignature&lt;T, P&gt; = P extends T ? true : falsetype RemoveIndexSignature&lt;T, K = PropertyKey&gt; = &#123; [P in keyof T as (CheckIndexSignature&lt;P, K&gt; extends false ? P : never)] : T[P]&#125; 代码详解： CheckIndexSignature：因为索引签名有一个特点，为string | number | symbol，所以我们通过P extends T ? true : false形式排除此索引签名。其原理如下： 1234567891011121314151617181920type FooKeys = string | 'foo'// 第一次迭代example1: T = 'foo', P = string | number | symbolstep1: (string | number | symbol) extends 'foo' ? true : falsestep2: (string extends 'foo' ? true : false) | (number extends 'foo' ? true : false) | (symbol extends 'foo' ? true : false) |step3: false | false | falsestep4: false// 第二次迭代example2: T = string, P = string | number | symbolstep1: (string | number | symbol) extends string ? true : falsestep2: (string extends string ? true : false) | (number extends string ? true : false) | (symbol extends string ? true : false) |step3: true | false | falsestep4: true | falsestep5: boolean as xxx：在之前的案例中，我们介绍过as的用法，在这里有加工或再次断言的意思。在使用in操作符进行迭代时，对每一个P再使用CheckIndexSignature加工一下，如果是索引签名，这里的结果为never，为never时表示跳过当前迭代，进而达到排除索引签名的目的。 123456789101112// 第一次迭代 P = 'foo' CheckIndexSignature&lt;P, K&gt; extends false ? P : never=&gt; false extends false ? P : never=&gt; P// 第二次迭代 P = string CheckIndexSignature&lt;P, K&gt; extends false ? P : never=&gt; boolean extends false ? P : never=&gt; never// 最终结果type result = &#123; foo(): void; &#125; PercentageParser(百分比解析) 用法PercentageParser是用来解析百分比字符串的，其用法如下：123type result1 = PercentageParser&lt;'+85%'&gt; // ['+', '85', '%']type result2 = PercentageParser&lt;'-85%'&gt; // ['-', '85', '%']type result3 = PercentageParser&lt;'85'&gt; // ['', '85', ''] 实现方式1234567type CheckPrefix&lt;S extends string&gt; = S extends '+' | '-' ? S : nevertype CheckSuffix&lt;S extends string&gt; = S extends `$&#123;infer L&#125;%` ? [L, '%'] : [S, '']type PercentageParser&lt;S extends string&gt; = S extends `$&#123;CheckPrefix&lt;infer L&gt;&#125;$&#123;infer R&#125;` ? [L, ...CheckSuffix&lt;R&gt;] : ['', ...CheckSuffix&lt;S&gt;] 代码详解： CheckPrefix是用来处理百分比字符串前面的符号的，如果存在+或者-，则原样返回，如果不存在则返回never，表示没有符号。 CheckSuffix是用来处理百分比字符串后面的百分比符号的，如果存在，则返回一个数组(最后一项固定为百分比符号)；如果不存在，则返回的数组最后一个元素固定为空字符串。 DropChar(移除字符) 用法DropChar是用来在字符串中移除指定字符的，其用法如下：12// 结果：butterfly!type result = DropChar&lt;' b u t t e r f l y ! ', ' '&gt; 实现方式12345678type DropChar&lt; S extends string, C extends string&gt; = C extends '' ? S : S extends `$&#123;infer L&#125;$&#123;C&#125;$&#123;infer R&#125;` ? DropChar&lt;`$&#123;L&#125;$&#123;R&#125;`, C&gt; : S 代码详解：DropChar和ReplaceAll的实现思路非常相似，首先需要判断待移除的字符是不是空字符串，如果是，则直接返回原始字符串；如果不是，先判断字符串中是否包含待移除的字符，包含则递归调用；不包含则直接返回原始字符串。 MinusOne(减一) MinusOne是用来实现数字减一的，其用法如下： 用法12// 结果：99type result = MinusOne&lt;100&gt; 实现方式12345678type MinusOne&lt; N extends number, T extends any[] = []&gt; = N extends T['length'] ? T extends [infer F, ...infer Rest] ? Rest['length'] : never : MinusOne&lt;N, [0, ...T]&gt; 代码详解：在实现MinusOne的时候，借用了一个空数组，首先判断数组的长度是否等于传递的数字N，如果相等则从数组中随意移除一位，然后返回剩下数组的长度即可；如果不相等，则往数组中添加一个元素，再递归调用MinusOne。 注意：由于TS在递归调用时存在最大递归调用次数，所以对于比较大的数字会提示错误。 PickByType(根据类型选取) 用法PickByType是用来根据类型选取属性的，其用法如下：12345678interface Model &#123; name: string count: number isReadonly: boolean isEnable: boolean&#125;// 结果：&#123; isReadonly: boolean, isEnable: boolean &#125;type result = PickByType&lt;Model, boolean&gt; 实现方式123type PickByType&lt;T, U&gt; = &#123; [P in keyof T as T[P] extends U ? P : never]: T[P]&#125; 代码详解：PickByType的实现，可以使用as进行第二次断言，当类型满足时就返回当前迭代的P，不满足类型时就返回never，因为never最后会被排除，所以最后的迭代结果只有满足类型的键。 StartsWith(字符串startsWith方法) 用法StartsWith是用来实现JavaScript中字符串的startsWith功能，其用法如下：12// 结果：truetype result = StartsWith&lt;'abc', 'ab'&gt; 实现方式1234type StartsWith&lt; S extends string, C extends string&gt; = S extends `$&#123;C&#125;$&#123;string&#125;` ? true : false EndsWith(字符串endsWith方法) 用法EndsWith是用来实现JavaScript中字符串的endsWith功能，其用法如下：12// 结果：truetype result = endsWith&lt;'abc', 'bc'&gt; 实现方式1234type EndsWith&lt; S extends string, C extends string&gt; = S extends `$&#123;string&#125;$&#123;C&#125;` ? true : false PartialByKeys(按需可选) 用法PartialByKeys是用来实现按需可选的，其用法如下：12345678910111213interface User &#123; name: string age: number address: string&#125;interface UserPartialName &#123; name?: string, age: number address: string &#125;// 结果：UserPartialNametype result = PartialByKeys&lt;User, 'name'&gt; 实现方式123456789type CopyKeys&lt;T&gt; = &#123; [P in keyof T]: T[P]&#125;type PartialByKeys&lt; T, K extends keyof T = keyof T&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123; [P in K]?: T[P]&#125;&gt; 代码详解： Omit部分：根据之前介绍的Omit的知识，Omit&lt;T, K&gt;表示从T中剔除含有K的类型。 CopyKeys部分：如果不使用CopyKeys，最后的结果为T &amp; U形式，它实际上与使用CopyKeys的结果是一样的。这里使用CopyKeys，很大程度上是为了测试。12// 使用CopyKeys，结果为true；不使用，结果为falsetype result1 = Equal&lt;PartialByKeys&lt;User, 'name'&gt;, UserPartialName&gt; RequiredByKeys(按需必填) 在实现PartialByKeys后，很容易按照相同的思路去实现RequiredByKeys。 用法RequiredByKeys是用来实现按需必填的，其用法如下：1234567891011121314interface User &#123; name?: string age?: number address?: string&#125;interface UserRequiredName &#123; name: string age?: number address?: string &#125;// 结果：UserRequiredNametype result = RequiredByKeys&lt;User, 'name'&gt; 实现方式123456789type CopyKeys&lt;T&gt; = &#123; [P in keyof T]: T[P]&#125;type RequiredByKeys&lt; T, K extends keyof T = keyof T&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123; [P in K]-?: T[P]&#125;&gt; 代码详解：实现思路参考PartialByKeys。 Mutable(可改) 用法Mutable是用来让所有属性变为可改的(移除readonly关键词)，其用法为：123456type Person = &#123; readonly name: string; age: number;&#125;// 结果：&#123; name: string; age: number; &#125;type MutableResult = MyMutable&lt;Person&gt; 实现方式123type MyMutable&lt;T&gt; = &#123; -readonly [P in keyof T]: T[P]&#125; 代码解读： -readonly：表示把readonly关键词去掉，去掉之后此字段变为可改的。 OmitByType(按类型移除) OmitByType的实现思路和PickByType类似。 用法OmitByType是用来按照类型移除的，其用法如下：12345678910111213interface Model &#123; name: string count: number isReadonly: boolean isEnable: boolean&#125;interface ModelOmitBoolean &#123; name: string; count: number&#125;// 结果：ModelOmitBooleantype result = OmitByType&lt;Model, boolean&gt; 实现方式123type OmitByType&lt;T, U&gt; = &#123; [P in keyof T as U extends T[P] ? never : P]: T[P]&#125; 代码解析：实现思路参考PickByType。 ObjectEntries 用法ObjectEntries是用来实现JavaScript中的Object.entries()方法，其用法如下：123456789interface Model &#123; name: string; age: number; locations?: string[] | null;&#125;type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null];// 结果：ModelEntriestype result = ObjectEntries&lt;Model&gt; 实现方式1234type RemoveUndefined&lt;T&gt; = [T] extends [undefined] ? T : Exclude&lt;T, undefined&gt;type ObjectEntries&lt;T&gt; = &#123; [P in keyof T]-?: &#123;&#125; extends Pick&lt;T, P&gt; ? [P, RemoveUndefined&lt;T[P]&gt;] : [P, T[P]]&#125;[keyof T] 代码详解： RemoveUndefined：当T仅为undefined，表示原始类型就是undefined; 当T为联合类型时，移除联合类型中的undefined。 [P in keyof T]-?: 表示移除可选属性。 {} extends Pick&lt;T, P&gt;: 判断当前的P是否为可选属性，是的话就是使用RemoveUndefined移除其中的undefined，否则取原始类型。123456type Person = &#123; name?: string &#125;// 结果都为truetype result1 = &#123;&#125; extends Person ? true : falsetype result2 = &#123; name: string; &#125; extends Person ? true : false Shift(数组shift方法) 用法12// Shift结果：[2, 3]type shiftResult = Shift&lt;[1, 2, 3]&gt; 实现方式12// Shift实现type Shift&lt;T extends any[]&gt; = T extends [infer F, ...infer R] ? R : [] TupleToNestedObject(元组转嵌套对象) 用法TupleToNestedObject是用来将元组转成嵌套对象的，其用法如下：12// 结果：&#123; a: &#123; b: string; &#125; &#125;type result = TupleToNestedObject&lt;['a', 'b'], string&gt; 实现方式1234type TupleToNestedObject&lt;T extends any[], U&gt; = T extends [infer F, ...infer R] ? &#123; [P in F &amp; string]: TupleToNestedObject&lt;R, U&gt; &#125; : U 代码详解： F &amp; string: 等价于如下代码：1F &amp; string = F extends string ? F : never Reverse 用法Reverse是用来实现数组的reverse()方法的，其用法如下：12// 结果：['b', 'a']type result = Reverse&lt;['a', 'b']&gt; 实现方式1234type Reverse&lt;T extends any[]&gt; = T extends [...infer R, infer L] ? [L, ...Reverse&lt;R&gt;] : [] FlipArguments(反转函数参数类型) 借助上面的Reverse方法，可以很容易实现函数参数的反转。 用法FlipArguments是用来实现反转函数参数类型的，其用法如下：12// 结果：(a: number, b: string) =&gt; string | numbertype result = FlipArguments&lt;(a: string, b: number) =&gt; string | number&gt; 实现方式1234type FlipArguments&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer A) =&gt; infer R ? (...args: Reverse&lt;A&gt;) =&gt; R : never FlattenDepth(数组按深度降维) 用法FlattenDepth是用来按深度进行数组降维的，其用法如下：12// 结果：[1, 2, 3, 4, [5]]type result = FlattenDepth&lt;[1, 2, [3, 4], [[[5]]]], 2&gt; 实现方式1234567891011type FlattenDepth&lt; T extends any[], D extends number = 1, U extends any[] = []&gt; = T extends [infer F, ...infer R] ? U['length'] extends D ? T : F extends any[] ? [...FlattenDepth&lt;F, D, [0, ...U]&gt;, ...FlattenDepth&lt;R, D&gt;] : [F, ...FlattenDepth&lt;R, D, U&gt;] : T 代码详解：FlattenDepth的实现思路和Flatten基本一致，区别是按深度降维时需要一个数组去记录降维的次数(深度)。 BEM 用法BEM是用来将字符串连接成CSS BEM格式的，其用法如下：12// 结果：'btn__primary--small' | 'btn__primary--mini' type result = BEM&lt;'btn', ['primary'], ['small', 'mini']&gt; 实现方式12345678910type ArrayToString&lt; T extends any[], P extends string&gt; = T extends [] ? '' : `$&#123;P&#125;$&#123;T[number]&#125;`type BEM&lt; B extends string, E extends string[], M extends string[]&gt; = `$&#123;B&#125;$&#123;ArrayToString&lt;E, '--'&gt;&#125;$&#123;ArrayToString&lt;M, '__'&gt;&#125;` 代码详解：实现BEM的思路并不复杂，只需要记住如下两个知识点： 判断是一个空数组，可以使用T extends []或者T[&#39;length&#39;] extends 0。 T[number]会自动迭代数组，例如：12// 结果: 'A__B' | 'A__C' | 'A__D'type result = `A__$&#123;['B', 'C', 'D'][number]&#125;` InOrderTraversal(中序遍历) 先序遍历：PreOrderTraversal先访问根节点，然后访问左节点，最后访问右节点。中序遍历：InOrderTraversal先访问左节点，然后访问根节点，最后访问右节点。后序遍历：PostOrderTraversal先访问左节点，然后访问右节点，最后访问根节点。 用法InOrderTraversal是用来实现二叉树中序遍历的，其用法如下：12345678910111213141516const tree = &#123; val: 1, left: null, right: &#123; val: 2, left: &#123; val: 3, left: null, right: null, &#125;, right: null, &#125;,&#125;// 结果: [1, 3, 2]type result = InOrderTraversal&lt;typeof tree&gt; 实现方式123456789101112131415161718192021222324// 一个二叉树节点interface TreeNode &#123; val: number; left: TreeNode | null; right: TreeNode | null;&#125;// 先序遍历实现type PreOrderTraversal&lt; T extends TreeNode | null&gt; = [T] extends [TreeNode] ? [T['val'], ...PreOrderTraversal&lt;T['left']&gt;, ...PreOrderTraversal&lt;T['right']&gt;] : []// 中序遍历实现type InOrderTraversal&lt; T extends TreeNode | null&gt; = [T] extends [TreeNode] ? [...InOrderTraversal&lt;T['left']&gt;, T['val'], ...InOrderTraversal&lt;T['right']&gt;] : []// 后序遍历实现type PostOrderTraversal&lt; T extends TreeNode | null&gt; = [T] extends [TreeNode] ? [...PostOrderTraversal&lt;T['left']&gt;, ...PostOrderTraversal&lt;T['right']&gt;, T['val']] : [] 代码详解： [T] extends [TreeNode]: 使用此形式而不用T extends TreeNode，这是因为T是一个TreeNode | null，在左侧会进行分布式条件类型，判断两次： 123// 如果Tree嵌套比较深的话，ts会报错TreeNode extends TreeNode |null extends TreeNode 遍历方式：根据先序遍历PreOrderTraversal、中序遍历InOrderTraversal、后序遍历PostOrderTraversal的定义，只需要在递归的时候处理其访问顺序即可。 FlipObject(对象键值交换) 用法FlipObject是用来将对象的键值交换的，其用法如下：12// 结果：&#123; pi: 'a' &#125;type result = FlipObject&lt;&#123; a: 'pi' &#125;&gt; 实现方式1234type BasicType = string | number | booleantype FlipObject&lt;T extends Record&lt;string, BasicType&gt;&gt; = &#123; [P in keyof T as `$&#123;T[P]&#125;`]: P&#125; Fibonacci(斐波那契数列) 菲波那切数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144… 用法Fibonacci是用来实现斐波那契数列的，用法如下：1type result = Fibonacci&lt;5&gt; 实现方式12345678type Fibonacci&lt; N extends number, Index extends any[] = [1], Prev extends any[] = [], Current extends any[] = [1]&gt; = Index['length'] extends N ? Current['length'] : Fibonacci&lt;N, [...Index, 1], Current, [...Prev, ...Current]&gt; 代码详解： Index：标记当前数列是第几项，从1开始。 Prev：存储数列上一次计算的值，从0开始。 Current: 标记当前数列的值，根据数列的特点，第N项的值，等于N - 1项 + N - 2项的值，即：Current = [...Prev, ...Current] AllCombinations(全排列) 用法AllCombinations是用来列举全部排列组合可能性的，其用法如下：12// 结果：'' | 'A' | 'AB' | 'B' | 'BA'type result = AllCombinations&lt;'AB'&gt; 实现方式1234567891011121314type StringToUnion&lt;S extends string&gt; = S extends `$&#123;infer F&#125;$&#123;infer R&#125;` ? F | StringToUnion&lt;R&gt; : nevertype Combination&lt; S extends string, U extends string = '', K = S&gt; = [S] extends [never] ? U : K extends S ? Combination&lt;Exclude&lt;S, K&gt;, U | `$&#123;U&#125;$&#123;K&#125;`&gt; : Utype AllCombinations&lt;S extends string&gt; = Combination&lt;StringToUnion&lt;S&gt;&gt; 代码详解： StringToUnion是用来将字符串变成一个联合类型的，例如： 12// 结果： 'A' | 'B'type result = StringToUnion&lt;'AB'&gt; Combination是用来将联合类型进行排列组合的，以以上&#39;A&#39; | &#39;B&#39;这个联合类型为例，步骤如下： 123456789101112// 第一步：从'A' | 'B这个联合类型中排除当前迭代的字符'A'K = 'A' S = 'A' | 'B' =&gt; Exclude&lt;'A' | 'B', 'A'&gt;// 第一步子递归：Combination&lt;'B', '' | 'A'&gt; =&gt; '' | 'A' | `$&#123;'' | 'A'&#125;B` =&gt; '' | 'A' | 'B' | 'AB'// 第二步：从'A' | 'B'这个联合类型中排除当前迭代的字符'B'K = 'B' S = 'A' | 'B' =&gt; Exclude&lt;'A' | 'B', 'B'&gt;// 第二步子递归：Combination&lt;'A', '' | 'B'&gt; =&gt; '' | 'B' | `$&#123;'' | 'B'&#125;A` =&gt; '' | 'B' | 'A' | 'BA'// 结果：剔除相同元素result = '' | 'A' | 'AB' | 'B' | 'BA' GreaterThan(大于) 用法GreaterThan&lt;T, N&gt;是来用判断正整数T是否大于正整数N的，其用法如下：12// 结果：truetype result = GreaterThan&lt;2, 1&gt; 实现方式12345678910// 如果比较的数比较大，会提示：Type instantiation is excessively deep and possibly infinitetype GreaterThan&lt; T extends Number, N extends Number, R extends any[] = []&gt; = T extends R['length'] ? false : N extends R['length'] ? true : GreaterThan&lt;T, N, [...R, 0]&gt; 代码详解：使用一个空数组来辅助，每次递归添加一个元素，如果正整数T先等于这个数组的长度，则为false；如果正整数N先等于这个数组的长度，则为true。 Zip(按位置匹配) 用法Zip是用来将两个元组按照相同索引位置组合成一个新数组的，用法如下：12// 结果：[[1, true], [2, false]]type result = Zip&lt;[1, 2], [true, false]&gt; 实现方式12345678type Zip&lt; T extends readonly any[], U extends readonly any[]&gt; = T extends [infer First, ...infer Rest] ? U extends [infer Head, ...infer Tail] ? [[First, Head], ...Zip&lt;Rest, Tail&gt;] : [] : [] IsTuple(是否为元组) 用法IsTuple是用来判断是否为一个元组的，用法如下：12// 结果：truetype result = IsTuple&lt;[number]&gt; 实现方式12345678type IsTuple&lt;T&gt; = [T] extends [never] ? false : T extends readonly any[] ? number extends T['length'] ? false : true : false 代码解析：以上代码中，比较关键的代码是number extends T[&#39;length&#39;]，这里不能写成T[&#39;length&#39;] extends number，如下：1234567891011121314// case1：需要返回false，因为它不定长，违反了元组的定义type result1 = IsTuple&lt;number[]&gt;// case2：需要返回true，因为它定长，只不过长度为0type result2 = IsTuple&lt;[]&gt;// case1计算逻辑，T['length']返回的是number，不是一个确定的值number extends T['length']=&gt; number extends number=&gt; true// case2计算逻辑，T['length']返回的是0number extends T['length']=&gt; number extends 0=&gt; false Chunk(lodash分割数组) Lodash Chunk: 将一个数组分割成长度为N的多个小数组。 用法12// 结果：[[1, 2], [3, 4]]type result = Chunk&lt;[1, 2, 3, 4], 2&gt; 实现方式1234567891011type Chunk&lt; T extends any[], Size extends number, R extends any[] = []&gt; = R['length'] extends Size ? [R, ...Chunk&lt;T, Size&gt;] : T extends [infer F, ...infer L] ? Chunk&lt;L, Size, [...R, F]&gt; : R['length'] extends 0 ? [] : [R] 代码详解：实现Chunk大体思路是：借助一个辅助空数组，在遍历数组时往这个辅助数组中添加元素，一直到等于指定长度，然后进行下一次相同操作。 Fill(数组fill方法) 用法Fill是用来在一个数组中，用指定元素，替换开始索引和结束索引元素的。12// 结果：[1, true, true]type result = Fill&lt;[1, 2, 3], true, 1, 3&gt; 实现方式1234567891011121314type Fill&lt; T extends unknown[], N extends number, Start extends number = 0, End extends number = T['length'], Count extends any[] = [], Flag extends boolean = Count['length'] extends Start ? true : false&gt; = Count['length'] extends End ? T : T extends [infer F, ...infer L] ? Flag extends false ? [F, ...Fill&lt;L, N, Start, End, [...Count, 0]&gt;] : [N, ...Fill&lt;L, N, Start, End, [...Count, 0], true&gt;] : T 代码详解： Count: 遍历标志位，从数组第一项开始，当等于End时，结束替换。 Flag：遍历标志位，从数组第一项开始，当等于Start是，开始替换。12345678910111213// 结果：[1, true, true]type result = Fill&lt;[1, 2, 3], true, 1, 3&gt;// 第一次遍历 Count = [], Flag = false, T = [1, 2, 3]// 满足Flag extends false条件，Count = [0]// 第二次遍历 Count = [0], Flag = true(计算而言)，T = [1, 2, 3]// 不满足Flag extends false条件，开始替换，Count = [0, 0], T = [1, true, 3]// 第三次遍历 Count = [0, 0], Flag = true(主动传递), T =[1, true, 3]// 不满足Flag extends false条件，开始替换，Count = [0, 0, 0], T = [1, true, true]// 最后一次判断 Count = [0, 0, 0]，长度等于End，结束，T = [1, true, true] Without(移除) 用法Without是用来从数组中移除指定元素的，其用法如下：12// 结果：[3]type result = Without&lt;[1, 2, 1, 2, 3], [1, 2]&gt; 实现方式1234567891011type ToUnion&lt;T&gt; = T extends any[] ? T[number] : Ttype Without&lt; T extends any[], F, U = ToUnion&lt;F&gt;, R extends any[] = []&gt; = T extends [infer First, ...infer Rest] ? First extends U ? Without&lt;Rest, F, U, [...R]&gt; : Without&lt;Rest, F, U, [...R, First]&gt; : R 代码详解：因为F支持单数字和数组，所以定义一个ToUion来统一处理成联合类型。随后直接遍历数组，如果当前迭代的元素在联合类型中，则直接跳过进行下一次迭代；否则，把当前迭代元素添加到R辅助数组中。 Trunc(Math.trunc取整) 用法Trunc是用来实现Math.trunc()方法的，其用法如下：1234// 结果1：100type result1 = Trunc&lt;100.32&gt;// 结果2：0type result2 = Trunc&lt;.3&gt; 实现方式1234567type Trunc&lt; T extends number | string&gt; =`$&#123;T&#125;` extends `$&#123;infer L&#125;.$&#123;string&#125;` ? L extends '' ? '0' : L : `$&#123;T&#125;` IndexOf(数组indexOf方法) 用法IndexOf是用来实现数组indexOf方法的，其用法如下：12// 结果：2type result = IndexOf&lt;[1, 2, 3, 4], 3&gt; 实现方式12345678910111213type IsEqual&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : falsetype IndexOf&lt; T extends any[], U, Index extends any[] = []&gt; = T extends [infer First, ...infer Rest] ? IsEqual&lt;U, First&gt; extends true ? Index['length'] : IndexOf&lt;Rest, U, [...Index, 0]&gt; : -1 代码详解：需要借助IsEqual来判断两个值是否相等，原因考虑如下案例：12type result1 = IsEqual&lt;1, number&gt; // falsetype result2 = IsEqual&lt;'a', string&gt; // false Join(数组join方法) 用法Join是用来实现数组join方法的，其用法如下：12// 结果：'a-p-p-l-e'type result = Join&lt;['a', 'p', 'p', 'l', 'e'], '-'&gt; 实现方式123456789type Join&lt; T extends any[], U extends string | number, R extends string = ''&gt; = T extends [infer First, ...infer Rest] ? Rest['length'] extends 0 ? `$&#123;R extends '' ? '' : `$&#123;R&#125;$&#123;U&#125;`&#125;$&#123;First&amp;string&#125;` : Join&lt;Rest, U, `$&#123;R extends '' ? '' : `$&#123;R&#125;$&#123;U&#125;`&#125;$&#123;First&amp;string&#125;`&gt; : R LastIndexOf(数组lastIndexOf方法) 借助IndexOf的实现思路，很容易实现lastIndexOf方法。 用法LastIndexOf是用来实现数组lastIndexOf方法的，其用法如下：12// 结果：3type result = LastIndexOf&lt;[1, 2, 3, 4, 5], 4&gt; 实现方式1234567891011type IsEqual&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : falsetype LastIndexOf&lt; T extends any[], U&gt; = T extends [...infer Rest, infer Last] ? IsEqual&lt;Last, U&gt; extends true ? Rest['length'] : LastIndexOf&lt;Rest, U&gt; : -1 Unique(数组去重) 用法Unique是用来实现数组去重的，其用法如下：12// 结果：[1, 2, 3]type result = Unique&lt;[1, 1, 2, 2, 3, 3]&gt; 实现方式借助IsEqual和Includes，很容易实现Unique数组去重。1234567891011121314151617181920type IsEqual&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : falsetype Includes&lt; T extends any[], U&gt; = T extends [infer First, ...infer Last] ? IsEqual&lt;First, U&gt; extends true ? true : Includes&lt;Last, U&gt; : falsetype Unique&lt; T extends any[], R extends any[] = []&gt; = T extends [infer First, ...infer Last] ? Includes&lt;R, First&gt; extends true ? Unique&lt;Last, R&gt; : Unique&lt;Last, [...R, First]&gt; : R MapTypes(类型转换) 用法MapTypes是用来根据指定类型进行替换的，其用法如下：12// 结果：&#123; type: number; age: number; &#125;type result = MapTypes&lt;&#123; type: string; age: number; &#125;, &#123; mapFrom: string;mapTo: number; &#125;&gt; 实现方式12345678type GetMapType&lt; T, R, Type = R extends &#123; mapFrom: T, mapTo: infer To &#125; ? To : never&gt; = [Type] extends [never] ? T : Typetype MapTypes&lt;T, R&gt; = &#123; [P in keyof T]: GetMapType&lt;T[P], R&gt;&#125; 代码详解：在以上的实现中，最核心的代码是获取Type类型。 R extends { mapFrom: T, mapTo: infer To }：这段代码表示，R是不是右边的子类型，我们以以上案例来说明：123456789101112// 当P = 'type'时，T[P] = string, R = &#123; mapFrom: string;mapTo: number; &#125;=&gt; &#123; mapFrom: string; mapTo: number; &#125; extends &#123; mapFrom: string, mapTo: infer To &#125;=&gt; To = number=&gt; &#123; type: number &#125;// 当P = 'age'时T[P] = number, R = &#123; mapFrom: string;mapTo: number; &#125;=&gt; &#123; mapFrom: string; mapTo: number; &#125; extends &#123; mapFrom: number, mapTo: infer To &#125;=&gt; never=&gt; GetMapType&lt;T[P], R&gt; = number=&gt; &#123; age: number &#125; ConstructTuple(构造元组) 用法ConstructTuple是用来构造指定长度的元组的，其用法如下：12// 结果：[unknown, unknown]type result = ConstructTuple&lt;2&gt; 实现方式123456type ConstructTuple&lt; L extends number, R extends any[] = []&gt; = R['length'] extends L ? R : ConstructTuple&lt;L, [...R, unknown]&gt; NumberRange(限定范围数字) 用法NumberRange是用来返回指定范围内的数字的，其返回的是一个联合类型，用法如下：12// 结果：2 | 3 | 4 | 5 | 6 | 7 | 8 | 9type result = NumberRange&lt;2, 9&gt; 实现方式实现思路参考：数组Fill方法。12345678910type NumberRange&lt; L, H, I extends any[] = [], F = I['length'] extends L ? true : false&gt; = I['length'] extends H ? I[number] | H : F extends false ? NumberRange&lt;L, H, [...I, never]&gt; : NumberRange&lt;L, H, [...I, I['length']], true&gt; Subsequence(元组子序列) 用法Subsequence是用来根据指定数组生成元组子序列的，其用法如下：12// 结果：[] | [1] | [2] | [1, 2]type result = Subsequence&lt;[1, 2]&gt; 实现方式123456type Subsequence&lt; T extends any[], R extends any[] = []&gt; = T extends [infer First, ...infer Last] ? Subsequence&lt;Last, R | [...R, First]&gt; : R 代码详解： R | [...R, First]: 在一个数组中，对一个联合类型的数组使用...扩展时，会自动进行元素分发，例如：12// 结果：['a', 'b'] | ['a', 'c']type result = ['a', ...(['b'] | ['c'])] CheckRepeatedChars(是否包含相同字符) 用法CheckRepeatedChars是用来检查字符串中是否存在重复字符的，其用法如下：1234// 结果1：false type result1 = CheckRepeatedChars&lt;'abc'&gt;// 结果2：truetype result2 = CheckRepeatedChars&lt;'abb'&gt; 实现方式1234567type CheckRepeatedChars&lt; S extends string&gt; = S extends `$&#123;infer First&#125;$&#123;infer Last&#125;` ? Last extends `$&#123;string&#125;$&#123;First&#125;$&#123;string&#125;` ? true : CheckRepeatedChars&lt;Last&gt; : false 代码详解： ${string}${First}${string}：表示字符串包含First，也可以用infer来代替：${infer Left}${First}${infer Right}。 FirstUniqueCharIndex(字符串中第一个唯一字符) 用法FirstUniqueCharIndex是用来获取字符串中第一个唯一字符的索引的，其用法如下：1234// 结果1： 0(字符l)type result1 = FirstUniqueCharIndex&lt;'leetcode'&gt;// 结果2： 2(字符v)type result2 = FirstUniqueCharIndex&lt;'loveleetcode'&gt; 实现方式借助CheckRepeatedChars的实现思路，很容易实现FirstUniqueCharIndex。123456789101112type FirstUniqueCharIndex&lt; S extends string, R extends any[] = []&gt; = S extends '' ? -1 : S extends `$&#123;infer First&#125;$&#123;infer Last&#125;` ? First extends R[number] ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt; : Last extends `$&#123;string&#125;$&#123;First&#125;$&#123;string&#125;` ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt; : R['length'] : -1 代码详解：此题的实现思路和FirstUniqueCharIndex类似，只是多了一层判断，以上面案例为例：1234567891011121314// 结果： 2(字符v)type result = FirstUniqueCharIndex&lt;'loveleetcode'&gt;// 第一次迭代时：S = loveleetcode R = [] R[number] = never First = l=&gt; 'l' extends never 不满足，'oveleetcode' extends `$&#123;string&#125;l$&#123;string&#125;`满足// 第二次迭代时：S = oveleetcode R = ['l'] R[number] = 'l' First = o=&gt; 'o' extends 'l' 不满足，'veleetcode' extends `$&#123;string&#125;o$&#123;string&#125;`满足// 第三次迭代时：S = veleetcode R = ['l', '0'] R[number] = 'l' | 'o' First = v=&gt; 'v' extends 'l' | 'o' 不满足，'eleetcode' extends `$&#123;string&#125;v$&#123;string&#125;`不满足// 结果：R['length']=&gt; 2 ParseUrlParams(解析url路径参数) 用法ParseUrlParams是用来解析url上参数名的，其用法如下：12// 结果：'id' | 'user'type result = ParseUrlParams&lt;'posts/:id/:user'&gt; 实现方式1234567type ParseUrlParams&lt; S extends string&gt; = S extends `$&#123;string&#125;:$&#123;infer Last&#125;` ? Last extends `$&#123;infer Left&#125;/$&#123;infer Right&#125;` ? Left | ParseUrlParams&lt;Right&gt; : Last : never GetMiddleElement(数组中位数) 用法GetMiddleElement是用来取数组中位数的，其用法如下：1234// 结果1： [2]type result1 = GetMiddleElement&lt;[1, 2, 3]&gt;// 结果2： [2, 3]type result2 = GetMiddleElement&lt;[1, 2, 3, 4]&gt; 实现方式1234567type GetMiddleElement&lt; T extends any[]&gt; = T['length'] extends 0 | 1 | 2 ? T : T extends [any, ...infer Middle, any] ? GetMiddleElement&lt;Middle&gt; : never 代码详解： T[&#39;length&#39;] extends 0 | 1 | 2：当数组长度小于等于而时，其中位数就是自身。 T extends [any, ...infer Middle, any]: 当长度大于2时，每次迭代去掉首、尾元素，直至数组长度小于等于2，返回。 FindOnlyElements(数组只出现一次的元素) 用法FindOnlyElements是用来获取数组中只出现一次的元素，其用法如下：1234// 结果1： [1, 2, 3]type result1 = FindOnlyElements&lt;[1, 2, 3]&gt;// 结果2： [1]type result2 = FindOnlyElements&lt;[1, 2, 3, 2, 3]&gt; 实现方式123456789type FindOnlyElements&lt; T extends any[], U extends any[] = [], R extends any[] = []&gt; = T extends [infer First, ...infer Last] ? First extends [...U, ...Last][number] ? FindOnlyElements&lt;Last, [...U, First], R&gt; : FindOnlyElements&lt;Last, [...U, First], [...R, First]&gt; : R CountArrayElement(计数数组中元素出现的次数) 用法CountArrayElement是用来实现计算数组中元素出现次数的，其用法如下：1234// 结果1: &#123; 1: 1, 2: 1, 3: 1 &#125;type result1 = CountArrayElement&lt;[1, 2, 3]&gt;// 结果2: &#123; 1: 2, 2: 2, 3: 1 &#125;type result2 = CountArrayElement&lt;[1, 2, 2, 1, 3]&gt; 实现方式12345678910111213141516171819202122232425type Flatten&lt; T extends any[], R extends any[] = []&gt; = T extends [infer First, ...infer Last] ? [First] extends [never] ? Flatten&lt;Last, R&gt; : First extends any[] ? Flatten&lt;Last, [...R, ...Flatten&lt;First&gt;]&gt; : Flatten&lt;Last, [...R, First]&gt; : Rtype ObjectCount&lt; T extends any[], R extends Record&lt;string | number, any[]&gt; = &#123;&#125;&gt; = T extends [infer First extends string | number, ...infer Last] ? First extends keyof R ? ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [...R[First], 0]&gt;&gt; : ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [0]&gt;&gt; : &#123; [P in keyof R]: R[P]['length'] &#125;type CountArrayElement&lt; T extends any[]&gt; = ObjectCount&lt;Flatten&lt;T&gt;&gt; 代码详解： Flatten：实现Flatten，用来处理传递多维数组的情况，例如：CountArrayElement&lt;[1, [1, 2], 3, [4, [5]]]&gt; First extends keyof R: 如果当前数组的遍历项是R对象中的一个键，则表明需要计数加一；如果不是，则代表是新项，需要计数为1； [P in keyof R]: R[P][&#39;length&#39;]: 因为最后结果需要返回数组，而非数组，所以迭代R对象，返回其每个属性的数组长度即可。 Integer(数字整数) 用法Integer是用来返回数字的整数部分的，如果传入的数子包含小数，则返回never，其用法如下：1234// 结果1：1type result1 = Integer&lt;1&gt;// 结果2：nevertype result1 = Integer&lt;1.1&gt; 实现方式根据JavaScript中BigInt的用法，其不能包含小数。所以实现方式如下：1type Integer&lt;T extends number&gt; = `$&#123;T&#125;` extends `$&#123;bigint&#125;` ? T : never 代码详解： ${T} extends ${bigint}：这里转成字符串形式比较，不能直接比较，因为number和bigint是两个不同的类型。123// 结果：都是falsetype result1 = number extends bigint ? true : falsetype result2 = bigint extends number ? true : false ToPrimitive(转化基本类型) 用法ToPrimitive是用来返回一个对象的类型的，其用法如下：12345678910111213141516171819202122232425262728type PersonInfo = &#123; name: 'Tom' age: 30 married: false addr: &#123; home: '123456' phone: '13111111111' &#125; hobbies: ['sing', 'dance'] readonlyArr: readonly ['test'] fn: () =&gt; any&#125;type Expected = &#123; name: string age: number married: boolean addr: &#123; home: string phone: string &#125; hobbies: [string, string] readonlyArr: readonly [string] fn: Function&#125;// 结果：Expectedtype result = ToPrimitive&lt;PersonInfo&gt; 实现方式1234567type ToPrimitive&lt; T&gt; = T extends object ? T extends (...args: any[]) =&gt; any ? Function : &#123; [P in keyof T]: ToPrimitive&lt;T[P]&gt; &#125; : T extends &#123; valueOf: () =&gt; infer R &#125; ? R : T 代码详解： 对于函数来说：当满足T extends (...args: any[]) =&gt; any条件时，直接返回Function。 对于嵌套对象来说，递归调用ToPrimitive即可。 对于普通类型来说，判断其是否满足T extends { valueOf: () =&gt; infer R }，是则返回其类型。123// ts中的valueOf是js中的valueOf一样const num = 123console.log(num.valueOf()) // 123 DeepMutable(深度Mutable) 用法DeepMutable是用来深度移除属性readonly修饰符的，其用法如下：1234567891011121314151617181920interface Test &#123; readonly title: string readonly description: string readonly completed: boolean readonly meta: &#123; readonly author: string &#125;&#125;interface Expected &#123; title: string description: string completed: boolean meta: &#123; author: string &#125;&#125;// 结果：Expectedtype result = DeepMutable&lt;Test&gt; 实现方式12345type DeepMutable&lt; T&gt; = T extends (...args: any[]) =&gt; any ? T : &#123; - readonly [P in keyof T]: DeepMutable&lt;T[P]&gt; &#125; AllMatch(数组元素是否与给定元素完全相同) 用法AllMatch是用来判断，数组元素是否与给定元素完全相同的，其用法如下：1234// 结果1：truetype result1 = AllMatch&lt;[1, 1, 1], 1&gt;// 结果2：falsetype result2 = AllMatch&lt;[1, 1, 2], 1&gt; 实现方式123456789101112131415161718192021222324// 不考虑边界情况，简易实现方法type errTest1 = AllMatch&lt;[any], unknown&gt; // falsetype errTest2 = AllMatch&lt;[unknown], any&gt; // falsetype errTest3 = AllMatch&lt;[1, 2], 1 | 2&gt; // falsetype AllMatch&lt; T extends any[], U&gt; = T[number] extends U? true: false;// 考虑边界情况：完整实现type IsEqual&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends (&lt;T&gt;() =&gt; T extends Y ? 1 : 2) ? true : falsetype AllMatch&lt; T extends any[], U&gt; = T extends [infer First, ...infer Rest] ? IsEqual&lt;First, U&gt; extends true ? AllMatch&lt;Rest, U&gt; : false : true Filter(数组过滤) 用法Filter是用来实现数组过滤方法的，其用法如下：1234// 结果1：[2]type result1 = Filter&lt;[0, 1, 2], 2&gt;// 结果2：[1, 2]type result2 = Filter&lt;[0, 1, 2], 1 | 2&gt; 实现方式12345678type Filter&lt; T extends any[], P&gt; = T extends [infer First, ...infer Rest] ? First extends P ? [First, ...Filter&lt;Rest, P&gt;] : Filter&lt;Rest, P&gt; : [] FindAllIndex(查找数组中给定元素所有索引) 用法FindAllIndex是用来返回字符串中所有匹配索引的，其用法如下：123456// 结果1：[11]type result1 = FindAllIndex&lt;'TypeScript type challenges', 'type'&gt;// 结果2：[2, 13]type result2 = FindAllIndex&lt;'TypeScript type challenges', 'pe'&gt;// 结果3：[]type result3 = FindAllIndex&lt;'TypeScript type challenges', ''&gt; 实现方式123456789101112type FindAll&lt; T extends string, P extends string, R extends any[] = [], I extends any[] = []&gt; = P extends '' ? [] : T extends `$&#123;string&#125;$&#123;infer Last&#125;` ? T extends `$&#123;P&#125;$&#123;string&#125;` ? FindAll&lt;Last, P, [...R, I['length']], [...I, 0]&gt; : FindAll&lt;Last, P, R, [...I, 0]&gt; : R 代码详解： I extends any[] = []: 设置索引，字符串每迭代移除，I数组长度增加一。 T extends ${P}${string}: 当满足条件时，向结果数组R中添加当前索引即可。 CombKeys(组合键) 用法CombKeys是用来实现组合键的，其用法如下：12// 结果：'cmd ctrl' | 'cmd opt' | 'cmd fn' | 'ctrl opt' | 'ctrl fn' | 'opt fn'type result = CombKeys&lt;['cmd', 'ctrl', 'opt', 'fn']&gt; 实现方式12345type CombKeys&lt; T extends any[]&gt; = T extends [infer First extends string, ...infer Last extends string[]] ? `$&#123;First&#125; $&#123;Last[number]&#125;` | CombKeys&lt;Last&gt; : never ReplaceFirst(替换元组中第一个匹配项) 用法ReplaceFirst是用来替换元组中第一个匹配项，其用法如下：12// 结果：[1, 2, 4]type result = ReplaceFirst&lt;[1, 2, 3], 3, 4&gt; 实现方式123456789type ReplaceFirst&lt; T extends readonly unknown[], From, To&gt; = T extends [infer First, ...infer Rest] ? First extends From ? [To, ...Rest] : [First, ...ReplaceFirst&lt;Rest, From, To&gt;] : T 困难SimpleVue(简单Vue类型) 用法实现方式Currying(柯里化) 在JavaScript中Currying是用来实现函数柯里化的，其用法如下：12345const add = (a: number, b: number) =&gt; a + bconst three = add(1, 2)const curriedAdd = Currying(add)const five = curriedAdd(2)(3) 用法Currying是用来实现JavaScript中的柯里化的，其用法如下：123const func = Currying((a: number, b: string, c: boolean) =&gt; true)// 结果：(a: string) =&gt; (a: number) =&gt; (a: boolean) =&gt; truetype funcType = typeof func 实现方式123456789101112131415type CurryFunction&lt; P extends any[], R&gt; = P extends [] ? () =&gt; R : P extends [infer First, ...infer Rest] ? Rest['length'] extends 0 ? (a: First) =&gt; R : (a: First) =&gt; CurryFunction&lt;Rest, R&gt; : Rdeclare function Currying&lt;F&gt;(fn: F): F extends (...args: infer P) =&gt; infer R ? CurryFunction&lt;P, R&gt; : never 代码详解： P：P为调用Currying函数时传递函数参数的参数数组，以上面为例，其值为：[number, string, boolean]。 P extends [infer First, ...infer Rest]: 遍历参数列表，依次返回一个函数即可。 UnionToIntersection(元组取交集) 在实现UnionToIntersection之前，我们先来回顾一下TS中&amp;符号的作用：123456// 结果：nevertype result1 = 1 &amp; 'foo' &amp; true// 结果：&#123; a: number; b: number; c: boolean; &#125;type result2 = &#123; a: number; b: number; &#125; &amp; &#123; b: string | number; c: boolean; &#125;// 结果：(a: boolean | number) =&gt; stringtype result3 = ((a: boolean) =&gt; string | number) &amp; ((a: number) =&gt; string) 案例解析： 案例一：因为1、foo以及true，没有交集部分，所以这里结果为never。 案例二：对于a和c属性而言，它们只存在于自身类型，所以交集部分是自身；对于b属性而言，它在两个类型中都存在，且其属性的类型存在交集部分，既：number。 案例三：对于函数的交叉类型，我们从函数参数、函数返回值这两个部分来说明。对于函数参数而言，取其联合类型；对于函数返回值而言，取其交叉类型。 从以上几个案例中可以看出，TS中的&amp;符号是取交集的意思，也叫交叉类型。 用法UnionToIntersection所做的事情和&amp;符号是一样的，其用法如下：123456// 结果：nevertype result1 = UnionToIntersection&lt;1 | 'foo' | true&gt;// 结果：&#123; a: number; b: number; c: boolean; &#125;type result2 = UnionToIntersection&lt;&#123; a: number; b: number; &#125; | &#123; b: string | number; c: boolean; &#125;&gt;// 结果：(a: boolean | number) =&gt; stringtype result3 = UnionToIntersection&lt;((a: boolean) =&gt; string | number) | ((a: number) =&gt; string)&gt; 实现方式1234567type UnionToIntersection&lt;U&gt; = (U extends any ? (x: U) =&gt; any : never ) extends (x: infer V) =&gt; any ? V : never 代码详解： U extends any ? X : Y： 这里把U类型处理成(x: U) =&gt; any的函数类型。 T extends (x: infer V) =&gt; any ? V : never：这里的T就是上一步的函数类型，如果extends成立，则返回V，此时的V必然满足U &amp; V。 RequiredKeys(所有必填字段) 用法RequiredKeys是用来返回一个类型中所有必填字段，其用法如下：123456789type Person = &#123; name: string; age: number; sex?: undefined; address?: string;&#125;// 结果：'name' | 'age'type result = RequiredKeys&lt;Person&gt; 实现方式123type RequiredKeys&lt;T&gt; = keyof &#123; [P in keyof T as (&#123;&#125; extends Pick&lt;T, P&gt; ? never : P)]: P&#125; 代码详解： {} extends Pick&lt;T, P&gt; ? never : P：是用来判断当前遍历键是否可选键的。12// nevertype result = &#123;&#125; extends &#123;&#125; | &#123; sex: undefined &#125; ? never : 'sex' GetRequired(必填字段组成的类型) 用法GetRequired是用来取一个类型中那些由必填字段组成的一个新类型的，其用法如下：123456789type Person = &#123; name?: string; age: number; address?: string; sex: undefined;&#125;// 结果：&#123; age: number; sex: undefined; &#125;type result = GetRequired&lt;Person&gt; 实现方式按照RequiredKeys的实现思路，能够很容易的实现GetRequired。123type GetRequired&lt;T&gt; = &#123; [P in keyof T as (T[P] extends Required&lt;T&gt;[P] ? P : never)]: T[P]&#125; 代码详解： T[P] extends Required&lt;T&gt;[P] ? P : never：用来判断当前遍历键的类型是否一致，一致则是必填类型。12345// P为name时type result1 = string | undefined extends string ? 'name' : never// P为age时type result2 = number extends number ? 'age' : never OptionalKeys(所有可选字段) OptionalKeys和RequiredKeys所做的事情相反，其获取的是所有可选字段。 用法123456789type Person = &#123; name: string; age: number; sex?: undefined; address?: string;&#125;// 结果：'sex' | 'address'type result = OptionalKeys&lt;Person&gt; 实现方式123type OptionalKeys&lt;T&gt; = keyof &#123; [P in keyof T as (&#123;&#125; extends Pick&lt;T, P&gt; ? P : never)]: P&#125; 代码详解：从上面代码中可以看出，它和RequiredKeys实现思路是一样的，区别只是在extends关键词后面的处理不同。 GetOptional(可选字段组成的类型) 用法按照OptionalKeys的实现思路，能够很容易的实现GetOptional。123456789type Person = &#123; name: string; age: number; sex?: undefined; address?: string;&#125;// 结果：&#123; sex?: undefined; address?: string; &#125;type result = GetOptional&lt;Person&gt; 实现方式123type GetOptional&lt;T&gt; = &#123; [P in keyof T as (T[P] extends Required&lt;T&gt;[P] ? never : P)]: T[P]&#125; CapitalizeWords(所有单词首字母大写) 用法CapitalizeWords是用来把一个字符串中所有单词，变为大写字母的，其中这个字符串以固定的分隔符分割，用法如下：1234// 结果：'Foobar'type t1 = CapitalizeWords&lt;'foobar'&gt;// 结果：'Foo Bar.Hello,World'type t2 = CapitalizeWords&lt;'foo bar.hello,world'&gt; 实现方式12345678type CapitalizeWords&lt; S extends string, R extends string = ''&gt; = S extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? Uppercase&lt;First&gt; extends Lowercase&lt;First&gt; ? `$&#123;Capitalize&lt;`$&#123;R&#125;$&#123;First&#125;`&gt;&#125;$&#123;CapitalizeWords&lt;Rest&gt;&#125;` : CapitalizeWords&lt;Rest, `$&#123;R&#125;$&#123;First&#125;`&gt; : Capitalize&lt;R&gt; 代码详解： Uppercase&lt;First&gt; extends Lowercase&lt;First&gt;：为了找到连串的大写字符串，例如：123456// S = foo bar.hello,worldR = 'foo' First = ' ' Rest = 'bar.hello,world'=&gt; `$&#123;Capitalize&lt;`foo `&gt;&#125;$&#123;CapitalizeWords&lt;'bar.hello,world'&gt;&#125;`=&gt; `Foo $&#123;CapitalizeWords&lt;'bar.hello,world'&#125;`=&gt; ...=&gt; 'Foo Bar.Hello,World' CamelCase(下划线字符串转小驼峰) 用法与中级章节实现不同，此章节中CamelCase是用来将下划线字符串转小驼峰的，其用法如下：12// 结果：'fooBarHelloWorld'type result = CamelCase&lt;'foo_bar_hello_world'&gt; 实现方式1234567891011121314type IsLetter&lt;S extends string&gt; = Uppercase&lt;S&gt; extends Lowercase&lt;S&gt; ? false : truetype CamelCase&lt; S extends string, R extends string = ''&gt; = S extends `$&#123;infer First&#125;$&#123;infer Rest&#125;` ? CamelCase&lt; Rest, IsLetter&lt;First&gt; extends true ? R extends `$&#123;infer P&#125;_` ? `$&#123;P&#125;$&#123;Uppercase&lt;First&gt;&#125;` : `$&#123;R&#125;$&#123;Lowercase&lt;First&gt;&#125;` : `$&#123;R&#125;$&#123;First&#125;` &gt; : R 代码详解： IsLetter: 用来判断是否为字母的。 12type result1 = IsLetter&lt;'$'&gt; // falsetype result2 = IsLetter&lt;'A'&gt; // true IsLetter&lt;L&gt; extends true: 如果是字母的话，则根据是否以下划线结尾，如果是，则只需要紧邻下划线的字母L大写即可，否小写。 ParsePrintFormat(获取字符串格式化参数) 用法ParsePrintFormat是用来获取字符串格式化参数的，其用法如下：12345678910111213// 参数映射表type ControlMap = &#123; 'c': 'char', 's': 'string', 'd': 'dec', 'o': 'oct', 'h': 'hex', 'f': 'float', 'p': 'pointer'&#125;// 结果：['string', 'dec']type result = ParsePrintFormat&lt;'Hello %s: score is %d'&gt; 实现方式12345678910111213141516171819202122232425262728type ControlMap = &#123; 'c': 'char', 's': 'string', 'd': 'dec', 'o': 'oct', 'h': 'hex', 'f': 'float', 'p': 'pointer'&#125;// way1: 借助辅助数组type ParsePrintFormat&lt; S extends string, R extends string[] = []&gt; = S extends `$&#123;infer S1&#125;%$&#123;infer Char&#125;$&#123;infer S2&#125;` ? Char extends keyof ControlMap ? ParsePrintFormat&lt;S2, [...R, ControlMap[Char]]&gt; : ParsePrintFormat&lt;S2, R&gt; : R// way2: 不借助辅助数组type ParsePrintFormat&lt; S extends string&gt; = S extends `$&#123;string&#125;%$&#123;infer Char&#125;$&#123;infer Rest&#125;` ? Char extends keyof ControlsMap ? [ControlsMap[Char], ...ParsePrintFormat&lt;Rest&gt;] : ParsePrintFormat&lt;Rest&gt; : [] 代码详解：在以上实现方法中，借用了辅助数组的思想，拿上面案例来说，具体迭代分析如下：1234567891011// 第一次迭代S满足条件 R = [] S1 = 'Hello ' Char = 's' S2 = ': score is %d'// 第二次迭代S满足条件 R = ['string'] S1 = ': score is ' Char = 'd' S2 = ''// 最后一次迭代S不满足条件 R = ['string', 'dec']// 结果result = R = ['string', 'dec'] VueBasicProps(Vue的Props类型) 用法实现方式IsAny和NotAny 用法IsAny是用来判断一个类型是否为any的，NotAny和它做的事情相反。1234567type t1 = IsAny&lt;undefined&gt; // falsetype t2 = IsAny&lt;never&gt; // falsetype t3 = IsAny&lt;any&gt; // truetype t4 = NotAny&lt;undefined&gt; // truetype t5 = NotAny&lt;never&gt; // truetype t6 = NotAny&lt;any&gt; // false 实现方式12type IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : falsetype NotAny&lt;T&gt; = true extends IsAny&lt;T&gt; ? false : true 代码详解：1 &amp; T的结果只能是：1、never或者any。当使用0 extends这三个结果的时候，只有any判断为真。123456// 结果：falsetype t1 = 0 extends 1 ? true : false// 结果：falsetype t2 = 0 extends never ? true : false// 结果：truetype t3 = 0 extends any ? true : false Get(字符串路径取值) 用法Get是用来进行字符串路径取值的，其用法如下：1234567891011121314151617181920type Data = &#123; foo: &#123; bar: &#123; value: 'foobar', count: 6, &#125;, include: true, &#125;, 'foo.baz': false hello: 'world'&#125;// 结果：worldtype t1 = Get&lt;Data, 'hello'&gt;// 结果：foobartype t2 = Get&lt;Data, 'foo.bar.value'&gt;// 结果：falsetype t3 = Get&lt;Data, 'foo.baz'&gt;// 结果：nevertype t4 = Get&lt;Data, 'no.exits'&gt; 实现方式12345678type Get&lt; T, K extends string&gt; = K extends keyof T ? T[K] : K extends `$&#123;infer S1&#125;.$&#123;infer S2&#125;` ? Get&lt;T[S1 &amp; keyof T], S2&gt; : T[K &amp; keyof T] 代码详解：对于Get的实现，主要分为两部分：含有.符号的字符串和不含.符号的字符串。 含有.符号的字符串：对于这种情况，我们先判断.符号左侧部分是否满足为T类型的某个key，如果满足，则递归调用Get；如果不满足，则直接返回never。 1234// S1如果是T的属性键，则返回S1；如果不是，则返回neverGet&lt;T[S1 &amp; keyof T], S2&gt;// 等价于S1 extends keyof T ? Get&lt;T[S1], S2&gt; : never 不含有.符号的字符串：对于这种情况，我们只需要判断它是否为T类型中的某个key，如果是，则直接取值；如果不是，则返回never。 1234// K如果是T的属性键，则返回K；如果不是，则返回neverT[K &amp; keyof T]// 等价于S extends keyof T ? T[S] : never StringToNumber(字符串数字转数字) 用法StringToNumber是用来将字符串形式的数字转换成真正数字类型数字的，其用法如下：12// 结果：123type result = StringToNumber&lt;'123'&gt; 实现方式在JavaScript中，我们可以很方便的调用Number()方法或者parseInt()方法来将字符串类型的数字，转换成数字类型的数字。但在TS中，并没有这样的方法，需要我们来手动实现。 StringToNumber的实现并不容易理解，我们需要将其进行拆分，一步步来完善，其实现思路如下： 第一步：可以很容易获取字符串&#39;123&#39;中每一位字符，我们将其存储在辅助数组T中，如下： 1234567type StringToNumber&lt;S extends string, T extends any[] = []&gt; = S extends `$&#123;infer S1&#125;$&#123;infer S2&#125;` ? StringToNumber&lt;S2, [...T, S1]&gt; : T// 结果：['1', '2', '3']type result = StringToNumber&lt;'123'&gt; 第二步：我们需要将单个字符串类型的数字，转换成真正数字类型的数字，可以借助中间数组来帮忙，例如： 12345'1' =&gt; [0]['length'] =&gt; 1'2' =&gt; [0,0]['length'] =&gt; 2'3' =&gt; [0,0,0]['length'] = 3...'9' =&gt; [0,0,0,0,0,0,0,0,0]['length'] =&gt; 9 根据以上规律，我们封装一个MakeArray方法，它的实现代码如下：12345type MakeArray&lt;N extends string, T extends any[] = []&gt; = N extends `$&#123;T['length']&#125;` ? T : MakeArray&lt;N, [...T, 0]&gt;type t1 = MakeArray&lt;'1'&gt; // [0]type t2 = MakeArray&lt;'2'&gt; // [0, 0]type t3 = MakeArray&lt;'3'&gt; // [0, 0, 0] 第三步：现在有了百位，十位和个位的数字，我们应该运用算术把它们按照一定的规律累加起来，如下：1234567891011const arr = [1, 2, 3]let target = 0// 第一次迭代target = 10 * 0 + 1 = 1// 第二次迭代target = 10 * 1 + 2 = 12// 第三次迭代target = 10 * 12 + 3 = 123// 迭代规律target = 10 * target + N 根据以上思路，我们还需要一个乘十的工具函数，对应到实际需求，就是需要把一个数组copy十次，因此我们封装一个Multiply10工具，其实现代码如下：123type Multiply10&lt;T extends any[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]type result = Multiply10&lt;[1]&gt; // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 第四步：根据前几步的分析，把所有东西串联起来，StringToNumber完整实现代码如下： 12345678910type Digital = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'type Multiply10&lt;T extends any[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]type MakeArray&lt;N extends string, T extends any[] = []&gt; = N extends `$&#123;T['length']&#125;` ? T : MakeArray&lt;N, [...T, 0]&gt;type StringToNumber&lt;S extends string, T extends any[] = []&gt; = S extends `$&#123;infer S1&#125;$&#123;infer S2&#125;` ? S1 extends Digital ? StringToNumber&lt;S2, [...Multiply10&lt;T&gt;, ...MakeArray&lt;S1&gt;]&gt; : never : T['length'] 第五步：为了更好的理解递归的过程，我们拆解成如下步骤来说明： 12345678910111213141516type result = StringToNumber&lt;'123'&gt;// 第一次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足DigitalS = '123' S1 = '1' S2 = '23' T = [0] T['length'] = 1// 第二次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足DigitalS = '23' S1 = '2' S2 = '3' T = [0,....0] T['length'] = 10// 第三次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足DigitalS = '3' S1 = '3' S2 = '' T = [0,....0] T['length'] = 120// 第四次递归，S不满足$&#123;infer S1&#125;$&#123;infer S2&#125; T['length']取值S = '' T = [0,....0] T['length'] = 123// 结果：type result = StringToNumber&lt;'123'&gt; // 123 FilterOut(数组元素过滤) 用法FilterOut是用来从数组中移除指定元素的，其用法如下：12// 结果：[2]type result = FilterOut&lt;[1, 'a', 2], 'a' | 1&gt; 实现方式123456789type FilterOut&lt; T extends any[], F, K extends any[] = []&gt; = T extends [infer R, ...infer args] ? [R] extends [F] ? FilterOut&lt;args, F, [...K]&gt; : FilterOut&lt;args, F, [...K, R]&gt; : K 代码详解： 第一步：我们借用赋值函数来存放最后的结果。 第二步：迭代数组T，拿每一个元素去和指定的F进行判断，如果R是F的子类型，则不添加此元素到结果数组中，反之添加。 第三步：当迭代完毕时，直接返回结果数组K。 TupleToEnum(元组转枚举) 用法TupleToEnum是用来将元组转换为枚举的，其用法如下：12345678910111213141516const OperatingSystem = ['macOs', 'Windows', 'Linux'] as consttype Expected1 = &#123; readonly MacOs: 'macOs'; readonly Windows: 'Windows'; readonly Linux: 'Linux'&#125;type Expected2 = &#123; readonly MacOs: 0; readonly Windows: 1; readonly Linux: 2&#125;// 结果：Expected1type result1 = TupleToEnum&lt;typeof OperatingSystem&gt;// 结果：Expected2type result2 = TupleToEnum&lt;typeof OperatingSystem, true&gt; 实现方式在实现TupleToEnum之前，我们先来实现TupleKeys，它是用来获取所有元组索引组合成的联合类型的。12345678type TupleKeys&lt; T extends readonly any[]&gt; = T extends readonly [infer R, ...infer args] ? TupleKeys&lt;args&gt; | args['length'] : never// 结果：0 | 1 | 2type keys = TupleKeys&lt;typeof OperatingSystem&gt; 在有了以上keys后，就能很容易实现TupleToEnum了，如下：123456type TupleToEnum&lt; T extends readonly string[], N extends boolean = false&gt; = &#123; readonly [K in TupleKeys&lt;T&gt; as Capitalize&lt;T[K]&gt;]: N extends true ? K : T[K]&#125; Format(字符串格式化函数类型) %s表示格式化为(x: string) =&gt; any形式，%d表示格式化为(x: number) =&gt; any形式。 用法Format是将字符串格式化为指定函数类型的，用法如下：123456// 结果1：(x: string) =&gt; stringtype result1 = Format&lt;'a%sbc'&gt;// 结果2：(x: number) =&gt; stringtype result2 = Format&lt;'a%dbc'&gt;// 结果3：(x: number) =&gt; (x: string) =&gt; string&gt;type result3 = Format&lt;'a%dbc%s'&gt; 实现方式1234567891011type FormatMaps = &#123; 's': string; 'd': number;&#125;type Format&lt; S extends string&gt; = S extends `$&#123;infer S1&#125;%$&#123;infer P&#125;$&#123;infer S2&#125;` ? P extends keyof FormatMaps ? (x: FormatMaps[P]) =&gt; Format&lt;S2&gt; : string : string LengthOfString(字符串的长度) 我们之前在中级大章节中已经实现过LengthOfString，但它面临的问题是，如果字符有上百个，由于TS对于递归的次数存在限制，会提示嵌套过深。 用法12// 结果：91type result = LengthOfString&lt;'1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901'&gt; 实现方式12345678type LengthOfString&lt; S extends string, R extends any[] = []&gt; = S extends `$&#123;infer S0&#125;$&#123;infer S1&#125;$&#123;infer S2&#125;$&#123;infer S3&#125;$&#123;infer S4&#125;$&#123;infer S5&#125;$&#123;infer S6&#125;$&#123;infer S7&#125;$&#123;infer S8&#125;$&#123;infer S9&#125;$&#123;infer Rest&#125;` ? LengthOfString&lt;Rest, [...R, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]&gt; : S extends `$&#123;infer S1&#125;$&#123;infer S2&#125;` ? LengthOfString&lt;S2, [...R, S1]&gt; : R['length'] 代码解析：这里我们巧妙的使用占位的思想，S extends ${infer S1}${infer S2}${infer S3}，如果S满足这个占位形式，则表示S的长度至少为2，带入到上面的例子，解析步骤如下：123456789// 第一次递归S满足至少10个字符的长度，R = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]// 第二弟递归S满足至少10个字符的长度，R = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]// 省略// 最后一次递归S = '1'不满足至少10个字符的长度，R = [1, ....., 1]// 最后结果R['length'] = 91 UnionToTuple(联合类型转元组) 用法UnionToTuple是用来将联合类型转成元组的，用法如下：123456// 结果1：['a', 'b']type result1 = UnionToTuple&lt;'a'&gt;// 结果2：['a', 'b']type result2 = UnionToTuple&lt;'a' | 'b'&gt;// 结果3：['a', 'b']type result3 = UnionToTuple&lt;'a' | 'b' | never&gt; 实现方式12345678910111213141516171819202122type UnionToIntersection&lt;U&gt; = ( U extends any ? (x: U) =&gt; any : never) extends (x: infer R) =&gt; any ? R : nevertype LastUnion&lt;U&gt; = UnionToIntersection&lt; U extends any ? (x: U) =&gt; 0 : never&gt; extends (x: infer R) =&gt; 0 ? R : nevertype UnionToTuple&lt; T, Last = LastUnion&lt;T&gt;&gt; = [T] extends [never] ? [] : [...UnionToTuple&lt;Exclude&lt;T, Last&gt;&gt;, Last] 代码详解： UnionToIntersection: 联合类型取交集，在之前已经实现过，这里不再赘述。主要理解以下案例：1234567type f1 = (x: 1) =&gt; 0type f2 = (x: 2) =&gt; 0// 函数重载结果// function (x: 1): 0;// function (x: 2): 0;type result = UnionToIntersection&lt;f1 | f2&gt; 对于函数参数的交集而言，不是简单的把参数取交集，而是”联合”起来，也就是构造一个新的函数类型，即：函数重载 LastUnion: 取联合类型最后的一个元素，如果一个函数存在重载的情况，TS会取最后一个函数签名，例如：1234567type f1 = (x: 1) =&gt; 0type f2 = (x: 2) =&gt; 0// 结果1：2type result1 = f1 &amp; f2 extends (x: infer R) =&gt; 0 ? R : never// 结果2：1type result2 = f2 &amp; f1 extends (x: infer R) =&gt; 0 ? R : never Join(字符串拼接) 用法Join是用来实现拼接字符串的，用法如下：12345678// 结果1： ''const Expected1 = join('-')();// 结果2： 'a'const Expected2 = join('-')('a');// 结果3： 'abc'const Expected3 = join('')('a', 'b', 'c');// 结果4： 'a-b-c'const Expected4 = join('-')('a', 'b', 'c'); 实现方式1234567891011type Tail&lt;T extends string[]&gt; = T extends [any, ...infer Rest] ? Rest : []type StringJoin&lt; D extends string, P extends string[] = []&gt; = P extends [] ? '' : P extends [infer Only] ? Only : `$&#123;P[0]&#125;$&#123;D&#125;$&#123;StringJoin&lt;D, Tail&lt;P&gt;&gt;&#125;`declare function join&lt;D extends string&gt;(delimiter: D): &lt;P extends string[] = []&gt;(...parts: P) =&gt; StringJoin&lt;D, P&gt;; DeepPick(深层次Pick) 用法DeepPick是用来深层次获取属性值的，用法如下：123456789101112131415161718192021type Obj = &#123; a: number, b: string, c: boolean, obj: &#123; d: number, e: string, f: boolean, obj2: &#123; g: number, h: string, i: boolean, &#125; &#125;&#125;// 结果1：Objtype result1 = DeepPick&lt;Obj, ''&gt;// 结果2：&#123; a: number; &#125;type result2 = DeepPick&lt;Obj, 'a'&gt;// 结果3：&#123; a: number; &#125; &amp; &#123; obj: &#123; d: number; &#125; &#125;type result3 = DeepPick&lt;Obj, 'a', 'obj.d'&gt; 实现方式在之前，我们实现过根据属性路径取值Get，根据其思路我们很容易实现DeepPick，如下：1234567891011121314151617181920212223type UnionToIntersection&lt;U&gt; = (U extends any ? (x: U) =&gt; any : never ) extends (x: infer V) =&gt; any ? V : nevertype GetType&lt;T, S&gt; = S extends `$&#123;infer S1&#125;.$&#123;infer S2&#125;` ? S1 extends keyof T ? &#123; [K in S1]: GetType&lt;T[S1], S2&gt; &#125; : never : S extends keyof T ? &#123; [K in S]: T[K] &#125; : nevertype DeepPick&lt; T, U extends string&gt; = UnionToIntersection&lt; U extends infer keys ? GetType&lt;T, keys&gt; : never&gt; Camelize(对象属性键转小驼峰) 用法Camelize是用来将对象中的key全部转换为小驼峰的，用法如下：123456789101112131415161718192021type Person = &#123; some_PROP: string; prop: &#123; another_prop: string; &#125;; array: [ &#123; snake_case: string; &#125; ]&#125;type Expected = &#123; someProp: string; prop: &#123; anotherProp: string; &#125;; array: [ &#123; snakeCase: string; &#125; ]&#125;// 结果：Expectedtype result = Camelize&lt;Person&gt; 实现方式12345678910111213type CamelCase&lt;S&gt; = S extends `$&#123;infer S1&#125;_$&#123;infer S2&#125;` ? `$&#123;Lowercase&lt;S1&gt;&#125;$&#123;CamelCase&lt;Capitalize&lt;Lowercase&lt;S2&gt;&gt;&gt;&#125;` : Stype Camelize&lt;T&gt; = &#123; [K in keyof T as CamelCase&lt;K&gt;]: T[K] extends [infer R] ? [Camelize&lt;R&gt;] : T[K] extends Object ? Camelize&lt;T[K]&gt; : T[K]&#125; 代码详解：CamelCase的实现可以分为两个部分，第一部分来自于处理属性key转小驼峰的情况，第二部分来自于嵌套对象的情况。 处理属性key：根据之前介绍过的as用法，我们可以在in迭代过程中使用as来进一步加工或者处理属性key，也就是CamelCase的部分。 处理嵌套对象：对于T[P]而言，我们考虑嵌套对象为数组和普通对象的情况，首先判断是否为数组类型，如果是则迭代数组递归调用Camelize；如果是普通对象，则直接调用Camelize；如果都不是，则直接返回T[P]即可。 DropString(移除全部字符) 用法DropString是用来移除全部字符的，用法如下：12// 结果：'ooar!'type result = DropString&lt;'foobar!', 'fb'&gt; 实现方式1234567891011121314type StrngToUnion&lt;S extends string&gt; = S extends `$&#123;infer S1&#125;$&#123;infer S2&#125;` ? S1 | StrngToUnion&lt;S2&gt; : Stype DropString&lt; S extends string, R extends string, U = StrngToUnion&lt;R&gt;&gt; = S extends `$&#123;infer S1&#125;$&#123;infer S2&#125;` ? S1 extends U ? DropString&lt;S2, R&gt; : `$&#123;S1&#125;$&#123;DropString&lt;S2, R&gt;&#125;` : S 代码详解：实现DropString的核心是将指定的字符串转换为联合类型，转换之后只需要迭代字符串，判断当前迭代的字符是不是在联合类型中，如果是则直接丢弃，不是则原样保留。 Split(字符串Split方法) 用法Split是用来实现字符串split方法的，其用法如下：12// 结果：[\"Hi!\", \"How\", \"are\", \"you?\"]type result = Split&lt;'Hi! How are you?', ' '&gt; 实现方式12345678910111213type Split&lt; S extends string, SEP extends string, R extends any[] = []&gt; = S extends `$&#123;infer _&#125;` ? S extends `$&#123;infer S1&#125;$&#123;SEP&#125;$&#123;infer S2&#125;` ? Split&lt;S2, SEP, [...R, S1]&gt; : S extends '' ? SEP extends '' ? R : [...R, S] : [...R, S] : string[] ClassPublicKeys(类的公共键) 用法实现方式IsRequiredKeys(是否为必填key) 用法IsRequiredKeys是用来判断是否为必填key的，其用法如下：12345678type Obj = &#123; a: number, b?: string&#125;// 结果1：truetype result1 = IsRequiredKeys&lt;Obj, 'a'&gt;// 结果2：falsetype result2 = IsRequiredKeys&lt;Obj, 'b'&gt; 实现方式1type IsRequiredKey&lt;T, K extends keyof T&gt; = T extends Record&lt;K, T[K]&gt; ? true : false 根据IsRequiredKey的实现思路，我们可以很容易实现IsOptionalKey，如下：123456type IsOptionalKey&lt;T, K extends keyof T&gt; = &#123;&#125; extends &#123; [P in K]: T[P] &#125; ? true : false// 结果1：falsetype result1 = IsOptionalKey&lt;Obj, 'a'&gt;// 结果2：truetype result2 = IsOptionalKey&lt;Obj, 'b'&gt; ObjectEntries(对象Object.entries方法) 用法实现方式IsPalindrome(是否为回文) 用法实现方式MutableKeys(所有可写键) 用法实现方式Intersection(交集) 用法实现方式BinaryToDecimal(二进制转十进制) 用法实现方式ObjectKeyPaths(对象属性键路径) 用法实现方式TwoSum(LeetCode两数之和) 用法实现方式ValidDate(校验是否为合法日期) 用法实现方式Assign(对象Object.assign方法) 用法实现方式Maximum(数字中的最大值) 用法实现方式DeepCapitalize(深度首字母大写) 用法实现方式UnionReplace(联合类型替换) 用法实现方式FizzBuzz(Fizz和Buzz输出问题) 用法实现方式RLE(运行长度编码) 用法实现方式ObjectPathArray(对象键路径数组) 用法实现方式SnakeCase(字符串下划线连接) 用法实现方式IsNegativeNumber(是否为负数) 用法实现方式OptionalUndefined(按需转换为可选属性) 用法实现方式地狱撰写中…","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"/tags/typescript/"}]},{"title":"TypeScript教程(一)","slug":"TypeScript教程-一","date":"2024-08-01T06:37:09.000Z","updated":"2024-08-12T01:14:32.310Z","comments":true,"path":"2024/08/01/TypeScript教程-一/","link":"","permalink":"/2024/08/01/TypeScript教程-一/","excerpt":"TypeScript基础教程","text":"TypeScript基础教程 TypeScriptTypeScript是JavaScript的一个超集，主要提供了类型系统和对ES6的支持，它于2012年10月正式发布第一个版本。 优势： 能在开发过程中更快的发现潜在问题。 对编辑器更友好的代码提示功能。 代码语义更清晰易懂。 安装Node.js你首先需要在Node.js官网按照你电脑的操作系统下载对应的Node版本进行安装。 TypeScript你需要使用如下命令全局安装TypeScript:12345# 安装命令$ npm install -g typescript# 安装完毕后，查看版本号$ tsc -v warning如果你对具体版本有严格的要求，你同样可以按照指定版本号进行安装。 如下：12345# 按指定版本号进行安装$ npm install -g typescript@3.6.4# 安装完毕后，查看版本号$ tsc -v 起步目录在正式开始学习TypeScript之前，我们需要创建一个叫做TypeScript的文件夹：12# 创建文件夹$ mkdir TypeScript 随后在TypeScript文件夹中创建demo.ts文件，其代码如下：1console.log('Hello,world') 编译.ts中的代码一般而言是不能直接运行在浏览器的，需要我们把typescript代码进行编译成普通的javascript代码以后才能运行在浏览器，我们可以使用如下命令来进行编译：12# 编译命令$ tsc demo.ts 当编译完毕后，我们可以在文件夹中看到多出来了一个叫做demo.js文件：123|-- TypeScript| |-- demo.js| |-- demo.ts 随后我们需要使用如下命令来执行我们编译后的javascript代码：12# 执行$ node demo.js 当执行完毕以上命令后，你可以在终端上看到输出一下内容：1Hello,world 简化过程：我们发现，如果要运行一个.ts文件，我们首先需要使用tsc命令去编译它，随后再使用node命令去执行它，那么有没有一种工具能够一个步骤就帮我们做完以上的事情呢？我们需要全局安装一个叫做ts-node的工具：12345# 安装ts-node$ npm install ts-node -g# 安装完毕，查看版本号$ ts-node -v 在ts-node安装完毕后，我们先删除demo.js文件，随后使用ts-node命令来编译并执行我们的代码： warningts-node包有升级更新，如果运行ts-node命令报错，请按照ts-node最新文档进行处理。 12345# 删除demo.js文件$ rm demo.js# 编译并执行$ ts-node demo.ts 以上命令执行完毕后，你将会看到与上面实例相同的输出结果。 基础原始数据类型我们知道JavaScript分为原始数据类型和对象类型，原始数据类型包括：number、string、boolean、null、undefined和symbol。在TypeScript中，我们可以如下定义：12345let tsNum: number = 123let tsStr: string = 'AAA'let tsFlag: boolean = truelet tsNull: null = nulllet tsUndefined: undefined = undefined void空值我们知道在JavaScript中，是没有空值(void)的概念的，但在TypeScript中，可以使用void来表示一个没有返回值的函数：123function sayHello (): void &#123; console.log('Hello, world')&#125; 我们也可以定义一个void类型的变量，不过这样的变量并没有什么意义，因为我们只能给这种变量赋值为null或undefined。12let voidValue1: void = nulllet voidValue2: void = undefined void、null和undefinedvoid和null与undefined是有一定区别的，在TypeScript中，null和undefined是所有类型的子类型，也就是说可以把undefined或null赋值给number等类型的变量:12let tsNumber1: number = undefinedlet tsNumber2: number = null 而对于void而言，它只能被赋值为null或者undefined：123// 这两行代码会编译报错let voidValue1: void = 123let voidValue2: void = '123' 任意值任意值Any用来表示可以接受任何类型的值。 在有以上内容的基础上，我们知道以下代码会报错：123// 变量被定义为number，那么它只能接受number类型的值，不能改变其类型，会编译报错let tsNumber: number = 123tsNumber = '123' 但是如果一个变量被定义为any，那么代表它可以接受任何类型的值：123// 以下代码是正确的，编译成功let tsAny: any = 123tsAny = '123' 现在我们来思考一个问题，如果我们定义了一个变量，没有指定其类型，也没有初始化，那么它默认为any类型：1234// 以下代码是正确的，编译成功let tsValuetsValue = 123tsValue = '123' 类型注解和类型推断在以上的所有实例中，我们都为每一个变量提供了一个确定的类型，这种做法就叫做类型注解。而有些时候，当我们没有为其提供一个确定的类型，但提供了一个确定的值，那么TypeScript会根据我们给定的值的类型自动推断出这个变量的类型，这就叫类型推断。1234567// typescript会自动为num1变量推断为numberlet num1 = 123// typescript会自动为num4变量推断为numberlet num2 = 456let num3 = 789let num4 = num2 + num3 根据以上的案例，当我们给一个变量一个明确值的情况下，我们可以省略为其定义类型。但如果在函数参数中，则我们必须为其指定一个类型，如果不指定则默认为any:1234567function add (num1: number, num2: number): number &#123; return num1 + num2&#125;// 或者省略函数的返回值类型，因为typescript会基于num1和num1全部为number类型，从而推断出函数返回值为number类型function add (num1: number, num2: number) &#123; return num1 + num2&#125; 建议：始终为函数返回值提供一个确定的类型是有一个比较推荐的好习惯。 联合类型联合类型：表示取值可以为多种类型中的一种，多种类型使用|分隔开。123let value: string | numbervalue = 123value = '123' warning当我们使用联合类型的时候，因为TypeScript不确定到底是哪一个类型，所以我们只能访问此联合类型的所有类型公用的属性和方法。 123456789// 会编译报错function getLength (value: string | number): number &#123; return value.length&#125;// 以下代码不会编译报错function valueToStr (value: string | number): string &#123; return value.toString()&#125; warning另外一个值得注意的地方就是，当联合类型被赋值后，TypeScript会根据类型推断来确定变量的类型，一旦确定后，则此变量只能使用这种类型的属性和方法。 12345let tsValue: string | numbertsValue = '123'console.log(tsValue.length) // 编译正确tsValue = 123console.log(tsValue.length) // 编译报错 接口在TypeScript中，接口interface是一个比较重要的概念，它是对行为的抽象，而具体的行为需要由类去实现，接口interface中的任何代码都不会被最后编译到JavaScript中。 12345678interface Person &#123; name: string, age: number&#125;let person: Person = &#123; name: 'why', age: 23&#125; 在以上代码中，person变量它是Person类型的，那么此变量只能接受接口规定的属性，且属性值的类型也必须和接口中规定的一致，多一个属性或者少一个属性在TypeScript中都不是被允许的。1234567891011121314interface Person &#123; name: string, age: number&#125;// 编译报错let person1: Person = &#123; name: 'why'&#125;// 编译报错let person2: Person = &#123; name: 'why', age: 23, sex: 'man'&#125; 接口中的任意属性以上一个例子为基础，假设我们接口只对name和age做规定，其它任何属性都是可以的，那么我们可以如下方式进行定义：1234567891011interface Person &#123; name: string, age: number, // 任意属性 [propName: string]: any&#125;let person: Person = &#123; name: 'why', age: 23, sex: 'man'&#125; 接口中的可选属性现在假设，我们有一个接口，它只对name做规定，但是对于是否包含age不做要求，那么可以如下方式进行处理：12345678910111213interface Person &#123; name: string, // age属性是可选的 age?: number&#125;// 编译成功let person1: Person = &#123; name: 'why'&#125;let person2: Person = &#123; name: 'why', age: 23&#125; 接口中的只读属性最后我们要介绍的知识点是只读属性，一旦在接口中标记了属性为只读的， 那么其不能被赋值。12345678910interface Person &#123; name: string, readonly age: number&#125;let person: Person = &#123; name: 'why', age: 23&#125;// 编译报错person.age = 32 函数的类型在JavaScript中，定义函数有三种表现形式： 函数声明。 函数表达式。 箭头函数 123456789101112// 函数声明function func1 () &#123; console.log('Hello, world')&#125;// 函数表达式const func2 = function () &#123; console.log('Hello, world')&#125;// 箭头函数const func3 = () =&gt; &#123; console.log('Hello, world')&#125; 如果函数有参数，则必须在TypeScript中为其定义具体的类型：12345function add (x: number, y: number): number &#123; return x + y&#125;console.log(add(1, 2)) // 输出3console.log(add(1, '2')) // 报错 接口定义函数函数也可以使用接口来定义其类型：1234567interface AddInterface &#123; (x: number, y: number): number&#125;const add: AddInterface = function (x: number, y: number): number &#123; return x + y&#125;console.log(add(1, 2)) // 输出3 可选参数前面我们已经提到过，必须为具体的参数提供具体的类型，但如果一个函数接受一个参数，这个参数又是可选的，那么我们可以如下方式进行定义：12345function getArea (a: number, b?: number): number &#123; return b ? a * b : a * a&#125;console.log(getArea(4)) // 16console.log(getArea(4, 5)) // 20 warning可选参数必须放在最后一个位置，否则会报错。 1234// 编译报错function getArea (b?: number, a: number): number &#123; return b ? a * b : a * a&#125; 参数默认值在JavaScript中，函数允许我们给参数设置默认值，因此另外一种处理可选参数的方式是，为参数提供一个默认值，此时TypeScript将会把该参数识别为可选参数：12345function getArea (a: number, b: number = 1): number &#123; return a * b&#125;console.log(getArea(4)) // 4console.log(getArea(4, 5)) // 20 tip给一个参数设置了默认值后，就不再受TypeScript可选参数必须在最后一个位置的限制了。 123456function getArea (b: number = 1, a: number): number &#123; return a * b&#125;// 此时必须显示的传递一个undefined进行占位console.log(getArea(undefined,4)) // 4console.log(getArea(4, 5)) // 20 剩余参数在ES6中，我们可以使用...符号进行收缩剩余参数，在TypeScript中，我们依然可以这么做：1234567// rest是一个数组，我们可以使用数组的类型来定义它function getTotal (a: number, ...rest: number[]) &#123; console.log(a) // 1 console.log(rest) // [2, 3, 4]&#125;getTotal(1, 2, 3, 4,) 函数重载因为在JavaScript中，并没有限制函数参数的个数或者类型，因此JavaScript没有函数重载的概念，在TypeScript中对于函数重载的理解是：只要函数参数的类型或者函数参数的数量不同时，就可以认为这是两个函数(重载)。123456789101112// 前两个为函数声明，最后一个才是函数实现function add (a: number, b: number): number;function add (a: string, b: string): string;function add (a: number | string, b: number | string): number | string &#123; if (typeof a === 'number' &amp;&amp; typeof b === 'number') &#123; return a + b &#125; else &#123; return a + '' + b &#125;&#125;console.log(add(1, 2)) // 3console.log(add('1', '2')) // 12 tip在有函数重载时，会优先从第一个进行逐一匹配，因此如果重载函数有包含关系，应该将最精准的函数定义写在最前面。 类型断言在上面联合类型中，我们知道可以变量可以是多个类型的，这可能会在代码编写的过程中带给我们一些困惑：1234567891011121314151617181920212223242526class Student &#123; name: string = 'student' sayHi () &#123; console.log(this.name) &#125;&#125;class Teacher &#123; name: string = 'teacher' sayHello () &#123; console.log(this.name) &#125;&#125;function print(person: Student | Teacher) &#123; if (person instanceof Student) &#123; // 强制断言为Student类型 (person as Student).sayHi() &#125; else &#123; // 强制断言为Teacher类型 (person as Teacher).sayHello() &#125;&#125;let stu = new Student()let teacher = new Teacher()print(stu) // studentprint(teacher) // teacher 代码分析：在print函数中，我们接受的参数可以是Student或者Teacher，在此函数内部我们希望能够根据不同的类型来调用不同的方法。我们首先使用instanceof来判断参数是否为Student类的实例，是我们将person参数强制断言成Student类型，此时就可以安全的调用sayHi方法了，Teacher同理。 类型别名类型别名用type关键字来给一个类型起一个新的名字，类型别名常用于联合类型。12345678910type combineType = number | stringtype typeObj = &#123; age: number; name: string;&#125;const value1: combineType = 123const obj: typeObj = &#123; age: 123, name: 'why'&#125; 字符串字面量类型字符串字面量类型用来表示一个变量只能取某几个字符串值中的一个。1234567type eventName = 'click' | 'scroll' | 'mousemove'function handleEvent (event: eventName) &#123; console.log(event)&#125;handleEvent('click') // clickhandleEvent('scroll') // scrollhandleEvent('dbclick') // 编译报错 进阶数组和元组数组和普通的变量一样，数组中的类型定义也有一定的规则：类型+方括号表示1234// 只允许存储number类型let numArray: number[] = [1, 2, 3]// 只允许存储string类型let strArray: string[] = ['1', '2', '3'] 值得一提的是，以上案例还有一种泛型方式的写法：1234// 只允许存储number类型let numArray: Array&lt;number&gt; = [1, 2, 3]// 只允许存储string类型let strArray: Array&lt;string&gt; = ['1', '2', '3'] 在数组中也可以使用联合类型：12// 只允许存储number和string类型的值let tsArray: (number | string) [] = [1, '2', '3'] 我们知道，在数组中不仅可以存储基础数据类型，还可以存储对象类型，如果需要存储对象类型，可以用如下方式进行定义：1234// 只允许存储对象仅有name和age，且name为string类型，age为number类型的对象let objArray: (&#123; name: string, age: number &#125;)[] = [ &#123; name: 'AAA', age: 23 &#125;] 为了更加方便的撰写代码，我们可以使用类型别名的方式来管理以上类型：12345678// 类型别名type person = &#123; name: string; age: number;&#125;let objArray: person[] = [ &#123; name: 'AAA', age: 23 &#125;] 元组对元组的理解是：一个数组如果知道它确定的长度，且每个位置的值的类型也是确定的，那么就可以把这样的数组称为元组。12// tuple数组只有2个元素，并且第一个元素类型为string，第二个元素类型为numberlet tuple: [string, number] = ['AAA', 123] warning当访问元组中已知位置的索引时，将得到其对应正确的值；当访问元组中未知位置的索引时，会报错。 123let tuple: [string, number] = ['AAA', 123]console.log(tuple[1]) // 123console.log(tuple[2]) // 报错 枚举枚举Enum类型用来表示取值限定在指定的范围，例如一周只能有七天，颜色只能有红、绿、蓝等。 12345678enum colors &#123; red, green, blue&#125;console.log(colors.red) // 0console.log(colors.green) // 1console.log(colors.blue) // 2 代码分析：我们定义一个colors的枚举类型，其取值只能是red、green、blue。我们可以在打印的内容发现，其输出值从0开始，依次累加1。这是枚举类型的默认行为，我们可以手动设置一个起始值：12345678enum colors &#123; red = 10, green, blue&#125;console.log(colors.red) // 10console.log(colors.green) // 11console.log(colors.blue) // 12 在枚举类型中，我们不仅可以正向的获取值，还可以通过值反向获取枚举：12345678enum colors &#123; red = 10, green, blue&#125;console.log(colors[10]) // redconsole.log(colors[11]) // greenconsole.log(colors[12]) // blue 类类的继承在JavaScript中，通过extends关键字来实现子类继承父类，子类也可以通过super关键字来访问父类的属性或者方法。12345678910111213141516171819202122class Person &#123; name: string constructor (name: string) &#123; this.name = name &#125; sayHello () &#123; console.log(`hello, $&#123;this.name&#125;`) &#125;&#125;class Teacher extends Person &#123; constructor (name: string) &#123; // 调用父类的构造函数 super(name) &#125; sayTeacherHello () &#123; // 调用父类的方法 return super.sayHello() &#125;&#125;let teacher = new Teacher('why')teacher.sayHello() // hello, whyteacher.sayTeacherHello() // hello, why tip有一种关于类属性的简写方式，就是在类的构造函数中指明访问修饰符。 1234567891011// 简写形式class Person &#123; constructor (public name: string) &#123;&#125;&#125;// 等价于class Person &#123; name: string constructor (name: string) &#123; this.name = name &#125;&#125; 存取器在class中，可以通过getter和setter来改变属性的读取和赋值行为。1234567891011121314151617class Person &#123; // 私有属性，只能在类中进行访问 private _name: string constructor (_name: string) &#123; this._name = _name &#125; get name () &#123; return this._name &#125; set name(name) &#123; this._name = name &#125;&#125;let person = new Person('why')console.log(person.name) // whyperson.name = 'AAA'console.log(person.name) // AAA 静态属性和静态方法所谓静态属性和静态方法，就是只能通过类来进行访问，不能通过类的实例来进行访问。在众多设计模式中，有一种设计模式叫做单例设计模式，可以使用static静态方法来辅助我们完成单例设计模式。12345678910111213class Person &#123; private static _instance: Person private constructor () &#123;&#125; public static getInstance () &#123; if (!this._instance) &#123; this._instance = new Person() &#125; return this._instance; &#125;&#125;const person1 = Person.getInstance()const person2 = Person.getInstance()console.log(person1 === person2) // true TypeScript类的访问修饰符在以上的实例中，我们使用到了TypeScript中关于类的几种访问修饰符，它有三种： public：公有的，在任何地方都可以访问到。 protected：受保护的，只能在类的内部及其类的子类内部使用。 private：私有的，只能在类的内部进行使用。 123456789101112131415161718192021class Person &#123; private age: number protected address: string public name: string constructor (age: number, address: string, name: string) &#123; this.age = age this.address = address this.name = name &#125;&#125;class Teacher extends Person &#123; sayHello () &#123; console.log(`my addresss is $&#123;this.address&#125;`) // my address is 广东广州 console.log(`my name is $&#123;this.name&#125;`) // my name is why console.log(`my age is $&#123;this.age&#125;`) // 编译报错 &#125;&#125;const person = new Person(21, '广东广州', 'why')console.log(person.name) // whyconsole.log(person.age) // 编译报错console.log(person.address) // 编译报错 只读属性可以使用readonly关键字来表示属性是只读的。123456class Person &#123; constructor (public readonly name: string) &#123;&#125;&#125;let person = new Person('AAA')console.log(person.name) // AAAperson.name = 'BBB' // 编译报错 抽象类在TypeScript中，可以使用abstract关键字来定义抽象类以及抽象类中的抽象方法，在使用抽象类的过程中，有几点需要注意： 抽象类不能被实例化，只能被继承。 抽象类中的抽象方法必须被子类实现。 抽象类不能被实例化：12345678910abstract class Animal &#123; name: string constructor (name: string) &#123; this.name = name &#125;&#125;class Person extends Animal&#123;&#125;const person = new Person('why')console.log(person.name) // whyconst animal = new Animal() // 编译报错 抽象类中的抽象方法必须被子类实现：12345678910111213141516abstract class Animal &#123; name: string constructor (name: string) &#123; this.name = name &#125; abstract eat (): void&#125;class Person extends Animal&#123; // 子类必须实现抽象类中的抽象方法 eat () &#123; console.log('person is eating') &#125;&#125;const person = new Person('why')console.log(person.name) // whyperson.eat() // person is eating 类和接口类实现接口 tip一个类可以实现一个或者多个接口，用逗号分隔。 如果我们定义了一个接口，然后类去实现它，那么这个接口中的属性和方法，在类中必须全部都要存在，否则会编译报错。1234567891011interface Animal &#123; age: number sayHello (): void&#125;class Person implements Animal &#123; age: number sayHello () &#123; console.log(this.age) &#125;&#125; 接口继承接口在上面的案例中，我们使用到了类实现接口，其实一个接口还可以继承自另外一个接口。123456789101112131415interface Animal &#123; age: number sayHello (): void&#125;interface Person extends Animal &#123; // Person接口继承了Animal，就拥有了Animal种所有的属性和方法 name: string&#125;class Person implements Person &#123; age: number sayHello () &#123; console.log(this.age) &#125;&#125; 接口继承类在有些语言中，接口一般而言是不能继承类的，但在TypeScript中是可以继承的，接口继承类以后，就拥有类中所有的属性和方法。1234567891011121314151617class Point &#123; x: number y: number constructor (x: number, y: number) &#123; this.x = x this.y = y &#125;&#125;interface Point3d extends Point &#123; z: number&#125;let point3d: Point3d = &#123; x: 10, y: 10, z: 10&#125;console.log(point3d) // &#123; x: 10, y: 10, z: 10 &#125; 泛型泛型generics是指在定义函数、接口和类的时候，不预先指定其具体类型，而在使用的时候再去指定的一种特性。 函数中的泛型假设我们有如下一个函数，其中参数a和b接受的类型必须为相同的类型。123function join (a, b) &#123; return `$&#123;a&#125;$&#123;b&#125;`&#125; 我们在没有了解到泛型之前，我们可以用联合类型来定义：123function join (a: number | string, b: number | string) &#123; return `$&#123;a&#125;$&#123;b&#125;`&#125; 代码分析：在以上的例子中，我们仅仅只是规定了a和b参数必须是number类型或者string类型，但并没有办法来限制a和b必须是同一个类型。这个时候我们可以使用泛型来表示：123456function join&lt;T&gt; (a: T, b: T): string &#123; return `$&#123;a&#125;$&#123;b&#125;`&#125;console.log(join(1, 2)) // 12 console.log(join('1', '2')) // 12console.log(join(1, '2')) // 编译报错 注意：我们在调用join()函数并进行传参的时候，TypeScript会自动帮我们推断参数的类型，以上三行代码也可以像如下方式进行撰写：123console.log(join&lt;number&gt;(1, 2)) // 12 console.log(join&lt;string&gt;('1', '2')) // 12console.log(join&lt;number&gt;(1, '2')) // 编译报错 tip泛型可以是多个的。 123456function join&lt;T, P&gt; (a: T, b: P): string &#123; return `$&#123;a&#125;$&#123;b&#125;`&#125;console.log(join(1, 2)) // 12 console.log(join('1', '2')) // 12console.log(join(1, '2')) // 12 代码分析：在以上的案例中，join方法接受2个泛型类型，其中参数a:T，参数b:p，因此console.log(join(1, &#39;2&#39;))会正确被编译并输出12。 类中的泛型泛型同样可以使用在类中。1234567891011121314class CreateClass&lt;T&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let createNumber = new CreateClass&lt;number&gt;()createNumber.add = function (x, y) &#123; return x + y&#125;let createString = new CreateClass&lt;string&gt;()createString.add = function (x, y) &#123; return `$&#123;x&#125;$&#123;y&#125;`&#125;console.log(createNumber.add(1, 2)) // 3console.log(createString.add('1', '2')) // 12 tip在`TypeScript@2.3+`以后的版本，我们可以为泛型提供一个默认值。 1234567891011121314class CreateClass&lt;T = number&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let createNumber = new CreateClass()createNumber.add = function (x, y) &#123; return x + y&#125;let createString = new CreateClass&lt;string&gt;()createString.add = function (x, y) &#123; return `$&#123;x&#125;$&#123;y&#125;`&#125;console.log(createNumber.add(1, 2)) // 3console.log(createString.add('1', '2')) // 12 代码分析：在CreateClass类的定义部分，我们为泛型提供了一个默认值number，因此我们在实例createNumber初始化的时候就可以不用传递number了。 接口中的泛型像在类中一样，泛型可以存在于接口中。123456789101112interface CreateArray &#123; &lt;T&gt;(length: number, value: T): T[]&#125;let createArrayFunc: CreateArray = function (length, value) &#123; let result = [] for (let index = 0; index &lt; length; index++) &#123; result[index] = value &#125; return result&#125;console.log(createArrayFunc(3, 'AAA')) // ['AAA', 'AAA', 'AAA']console.log(createArrayFunc(2, true)) // [true, true] 声明合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。声明合并，我们在上面已经有实例的案例了，那就是函数的重载。1234567891011function add (a: number, b: number): number;function add (a: string, b: string): string;function add (a: number | string, b: number | string): number | string &#123; if (typeof a === 'number' &amp;&amp; typeof b === 'number') &#123; return a + b &#125; else &#123; return a + '' + b &#125;&#125;console.log(add(1, 2)) // 3console.log(add('1', '2')) // 12 当重复定义同一个接口时，会进行接口合并：1234567891011121314interface Person &#123; name: string, address: string&#125;interface Person &#123; name: string, age: 23&#125;// 相当于interface Person &#123; name: string, address: string, age: 23&#125; warning当合并的属性类型不一致时，会报错。 123456789interface Person &#123; name: string, address: string&#125;interface Person &#123; // 报错，name类型冲突 name: number, age: 23&#125; 命名空间在我们以上所有案例中，我们编写的代码大多数是运行在Node环境下的，接下来我们来编写一些代码，让其在浏览器环境中运行。 首先我们需要创建如下的项目以及目录结构：123456|-- TypeScript| |-- dist| | |-- index.html| |-- src| | |-- page.ts| |-- tsconfig.json 其中，tsconfig.json的配置如下：12345678910&#123; \"compilerOptions\": &#123; \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"./dist\", \"rootDir\": \"./src\", \"strict\": true, \"esModuleInterop\": true &#125;&#125; 在配置完tsconfig.json以后，我们来撰写page.ts中的代码：12345678910111213141516171819202122232425262728class Header &#123; constructor () &#123; let dom = document.createElement('div') dom.innerHTML = 'Header' document.body.append(dom) &#125;&#125;class Content &#123; constructor () &#123; let dom = document.createElement('div') dom.innerHTML = 'Content' document.body.append(dom) &#125;&#125;class Footer &#123; constructor () &#123; let dom = document.createElement('div') dom.innerHTML = 'Footer' document.body.append(dom) &#125;&#125;class Page &#123; constructor () &#123; new Header() new Content() new Footer() &#125;&#125; 编写完以上代码后，我们运行如下命令：12# 编译src下的*.ts文件到dist目录下$ tsc 随后我们在dist/index.html中引用我们刚刚编译的代码：1234&lt;script src=\"./page.js\"&gt;&lt;/script&gt;&lt;script&gt; new Page()&lt;/script&gt; 当我们在浏览器中运行index.html文件后，我们可以在浏览器下正确的看到我们想要的输出内容。 当我们在打开page.js文件时，我们可以发现： 在全局作用域环境下，我们一次性引入了四个全局变量：Header、Content、Footer和Page。要解决这个问题，我们可以使用namespace命令空间：12345678910111213141516171819202122232425262728293031// 使用命名空间包裹我们的代码并把Page类导出出去namespace Home &#123; class Header &#123; constructor () &#123; let dom = document.createElement('div') dom.innerHTML = 'Header' document.body.append(dom) &#125; &#125; class Content &#123; constructor () &#123; let dom = document.createElement('div') dom.innerHTML = 'Content' document.body.append(dom) &#125; &#125; class Footer &#123; constructor () &#123; let dom = document.createElement('div') dom.innerHTML = 'Footer' document.body.append(dom) &#125; &#125; export class Page &#123; constructor () &#123; new Header() new Content() new Footer() &#125; &#125;&#125; 随后，再次使用tsc命令重新编译代码，编译后的page.js如下： 再次修改index.html中的代码，我们依然能够得到跟前面示例代码一样的输出结果：1234&lt;script src=\"./page.js\"&gt;&lt;/script&gt;&lt;script&gt; new Home.Page()&lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"/tags/typescript/"}]},{"title":"electron基础入门","slug":"electron基础入门","date":"2024-07-17T01:22:37.000Z","updated":"2025-03-04T01:18:48.933Z","comments":true,"path":"2024/07/17/electron基础入门/","link":"","permalink":"/2024/07/17/electron基础入门/","excerpt":"electron+vue3+pinia构建一个桌面应用","text":"electron+vue3+pinia构建一个桌面应用Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux。 本教程使用vite+vue3+pinia配合electron开发一个桌面应用。 app应用功能，点击添加按钮，弹出dialog，填写内容后提交，将内容保存在public/files文件夹下，并且当前列表会展示出目前的文件列表。点击相应的文件会跳转到详情页展示。 基础功能vue3安装vue31npm create vite@latest 按照命令行提示输入项目名base-tutorial,之后选择vue项目，语言javascript。123cd base-tutorialnpm installnpm run dev 通过上边的命令可以启动vue3项目了。 electron安装electron1npm i electron -D electron比较大，根据网络情况可能会安装失败，多尝试几次。 安装nodemon开发方便1npm i nodemon -D 之后在package.json中添加123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;nodemon --exec electron . --watch ./ --ext .js,.html,.css,.vue&quot;,&#125;, 监控.js,.html,.css,.vue这些文件变化，自动重启electron应用。 安装electron-win-state1npm i electron-win-state --save electron-win-state可以记录应用上次关闭前窗口大小和位置。 编写electron应用在package.json中添加electron应用的主入口文件1&quot;main&quot;: &quot;main.js&quot; 在项目根目录下新建main.js文件123456789101112131415161718192021222324252627282930313233343536373839import &#123; app, BrowserWindow &#125; from &apos;electron&apos;;import WinState from &apos;electron-win-state&apos;; // 保存窗口位置和大小的调整const createWindow = ()=&gt; &#123; const winState = new WinState.default(&#123; defaultWidth: 1000, defaultHeight: 800, electronStoreOptions: &#123; name: &apos;window-state-main&apos; // 开启多个窗口的时候分别记录 &#125; &#125;); const win = new BrowserWindow(&#123; ...winState.winOptions, show: false, &#125;); win.loadURL(&apos;http://localhost:5173&apos;); win.webContents.openDevTools(); winState.manage(win); win.on(&apos;ready-to-show&apos;, ()=&gt; &#123; win.show(); &#125;);&#125;app.whenReady().then(()=&gt; &#123; createWindow(); app.on(&apos;activate&apos;, () =&gt; &#123; if (BrowserWindow.getAllWindows().length === 0) &#123; createWindow() &#125; &#125;);&#125;);app.on(&apos;window-all-closed&apos;, () =&gt; &#123; if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125;&#125;); 运行npm start,app顺利启动但是在调试工具打印台会看到Electron Security Warning (Insecure Content-Security-Policy)警告，解决办法是在index.html中加入1&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;self&apos;; img-src &apos;self&apos; data:; style-src &apos;self&apos; &apos;unsafe-inline&apos;&quot;&gt; 添加新功能添加路由，状态管理，ui库，css预编译，css初始化，lodash等 安装对应的库123456npm i vue-router --savenpm i stylus --savenpm i pinia --savenpm i normalize.css --savenpm i lodash --savenpm i element-plus --save 改造vue内容修改App.vue12345678910&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;electron基础入门&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt; 添加路由插槽&lt;router-view&gt;&lt;/router-view&gt; 新建views在src目录下，新建views文件夹在views下新建Home.vue，Detail.vue文件 新建router在src目录下，新建router文件夹在router下新建index.js文件1234567891011121314151617181920212223import &#123; createRouter, createWebHashHistory &#125; from &apos;vue-router&apos;;import Home from &apos;@/views/Home.vue&apos;;const routes = [ &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125;, &#123; path: &apos;/home&apos;, name: &apos;home&apos;, component: Home &#125;, &#123; path: &apos;/detail&apos;, name: &apos;detail&apos;, component: ()=&gt; import(&apos;@/views/Detail.vue&apos;) &#125;];const router = createRouter(&#123; history: createWebHashHistory(), routes&#125;);export default router; 修改Home.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;script setup&gt;import &#123; ref, reactive, onMounted, nextTick &#125; from &apos;vue&apos;;import useLoadingStore from &apos;../store/loading&apos;;import List from &apos;./List.vue&apos;;const loadingSotate = useLoadingStore();const dialogVisible = ref(false);const list = ref([]);const refForm = ref(null);const form = reactive(&#123; title: &apos;&apos;, city: &apos;&apos;, desc: &apos;&apos;,&#125;);const rules = &#123; title: [ &#123; required: true, message: &apos;请输入题目&apos;, trigger: &apos;blur&apos; &#125; ], city: [ &#123; required: true, message: &apos;请选择城市&apos;, trigger: &apos;change&apos; &#125; ], desc: [ &#123; required: true, message: &apos;请输入描述&apos;, trigger: &apos;blur&apos; &#125; ]&#125;const onAdd = ()=&gt; &#123; dialogVisible.value = true; nextTick(()=&gt; &#123; refForm.value.resetFields(); &#125;);&#125;const sunmitHandle = ()=&gt; &#123; refForm.value.validate(async valid=&gt; &#123; if(valid) &#123; dialogVisible.value = false; loadingSotate.set(true); // 调用渲染进程提供的方法 await rendererApi.saveText(JSON.stringify(form)); loadingSotate.set(false); getList(); &#125; &#125;);&#125;const getList = async ()=&gt; &#123; list.value = await rendererApi.getText();&#125;// 主进程调用vue侧的函数rendererApi.showAddDialog(()=&gt; &#123; onAdd();&#125;);onMounted(async ()=&gt; &#123; getList();&#125;);&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onAdd&quot;&gt;+&lt;/el-button&gt; &lt;/div&gt; &lt;List :listData=&quot;list&quot;&gt;&lt;/List&gt; &lt;el-dialog v-model=&quot;dialogVisible&quot; title=&quot;添加内容&quot; width=&quot;80%&quot; &gt; &lt;el-form :model=&quot;form&quot; ref=&quot;refForm&quot; :rules=&quot;rules&quot; label-width=&quot;auto&quot; style=&quot;max-width: 600px&quot;&gt; &lt;el-form-item label=&quot;题目&quot; prop=&quot;title&quot;&gt; &lt;el-input v-model=&quot;form.title&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;城市&quot; prop=&quot;city&quot;&gt; &lt;el-select v-model=&quot;form.city&quot; placeholder=&quot;请选择城市&quot;&gt; &lt;el-option label=&quot;沈阳&quot; value=&quot;沈阳&quot; /&gt; &lt;el-option label=&quot;大连&quot; value=&quot;大连&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;描述&quot; prop=&quot;desc&quot;&gt; &lt;el-input v-model=&quot;form.desc&quot; type=&quot;textarea&quot; :row=&quot;5&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;template #footer&gt; &lt;div class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;sunmitHandle&quot;&gt; 确定 &lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt; 修改Detail.vue123456789101112131415161718192021222324&lt;script setup&gt;import &#123; useRoute, useRouter &#125; from &apos;vue-router&apos;;const route = useRoute();const router = useRouter();const query = route.query;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div class=&quot;go-back&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;router.go(-1)&quot;&gt;返回&lt;/el-button&gt; &lt;/div&gt; &lt;h1&gt;&#123;&#123; query.title &#125;&#125;&lt;/h1&gt; &lt;div&gt;来自-&#123;&#123; query.city &#125;&#125;&lt;/div&gt; &lt;pre&gt;&#123;&#123; query.desc &#125;&#125;&lt;/pre&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;.go-back &#123; text-align: right;&#125;&lt;/style&gt; 添加pinia在src下新建store文件夹，新建loading.js文件。此文件内容控制Loading组件显示隐藏12345678910111213141516171819import &#123; defineStore &#125; from &apos;pinia&apos;;const useLoadingStore = defineStore(&apos;websiteStore&apos;, &#123; state() &#123; return &#123; bShow: false &#125; &#125;, actions: &#123; set(val) &#123; this.bShow = val; &#125; &#125;, getters: &#123; getBShow() &#123; return this.bShow; &#125; &#125;&#125;);export default useLoadingStore; 添加loading在App.vue文件夹下添加Loading组件。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script setup&gt;import useLoadingStore from &apos;../store/loading&apos;;const loadingSotate = useLoadingStore();&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;loading-wrap&quot; v-if=&quot;loadingSotate.getBShow&quot;&gt; &lt;svg class=&quot;circular&quot; viewBox=&quot;0 0 50 50&quot;&gt;&lt;circle class=&quot;path&quot; cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;20&quot; fill=&quot;none&quot;&gt;&lt;/circle&gt;&lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;.loading-wrap &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, .8); display: flex; justify-content: center; align-items: center; .circular &#123; stroke: #000000; width: 50px; height: 50px; animation: loading-rotate .5s linear infinite alternate; &#125;&#125;@keyframes loading-rotate &#123; 0% &#123; transform: scale(1); opacity: 0 &#125; 100% &#123; transform: scale(1.2); opacity: 1 &#125;&#125;&lt;/style&gt; 比如在Home页面控制Loading组件显示隐藏1234loadingSotate.set(true);setTimeout(() =&gt; &#123; loadingSotate.set(false);&#125;, 3000); 显示后3秒隐藏 改造electron内容vue侧提交内容后，需要将内容保存到文件里。需要修改electron的主进程和渲染进程 electron主进程在main.js里新增123webPreferences: &#123; preload: path.resolve(__dirname, &apos;./preload/index.js&apos;)&#125;, 引入渲染进程文件。 controller在根目录下新建controller文件夹，再新建saveText.js文件，用于保存vue侧保存的内容。12345678910import &#123; ipcMain &#125; from &apos;electron&apos;;import path from &apos;path&apos;;import fs from &apos;fs&apos;;import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;ipcMain.handle(&apos;on-save-text-event&apos;, (e, str)=&gt; &#123; const data = JSON.parse(str); const filePath = path.resolve(__dirnameFn(import.meta.url), &apos;../public/files/&apos;, data.title + &apos;-&apos; + data.city + &apos;.txt&apos;); fs.writeFileSync(filePath, data.desc);&#125;); ipcMain.handle用来注册事件，渲染进程可以触发这个事件的回调函数。 electron渲染进程在根目录下新建preload文件夹，再新建index.js文件，这里都是渲染进程的功能。123456789const &#123; contextBridge, ipcRenderer &#125; = require(&apos;electron&apos;)const saveText = async data=&gt; &#123; let result = await ipcRenderer.invoke(&apos;on-save-text-event&apos;, data); return result;&#125;contextBridge.exposeInMainWorld(&apos;myApi&apos;, &#123; saveText,&#125;); 渲染进程将saveText这个方法暴露给vue侧，可以window.saveText来调用，调用时，渲染进程会触发主进程注册的对应事件的回调函数完成保存文件的功能。 通过vue侧-&gt;渲染进程-&gt;主进程,也就是vue侧向主进程发起的通讯，后边还会实现electron主进程向vue侧发起的通讯。 后续修改略之后还会对vue侧，渲染进程，主进程代码修改，这里就不一一列举。思路还是主进程注册事件，渲染进程暴漏给vue侧全局方法调用来触发主进程的事件回调函数。 自定义Menu可以自定义Menu，这里为了使用主进程-&gt;渲染进程-&gt;vue侧的通讯，也就是在菜单中点击按钮，调用vue侧的一个方法。这个流程与上面vue侧-&gt;渲染进程-&gt;主进程的调用正好相反。 渲染进程新增事件注册在preload的index.js中，新增1234// 主进程触发渲染进程const showAddDialog = cb=&gt; ipcRenderer.on(&apos;on-show-add-dialog-event&apos;, (e, value)=&gt; &#123; cb(value);&#125;); vue侧调用1234// 主进程调用vue侧的函数rendererApi.showAddDialog(()=&gt; &#123; onAdd();&#125;); 新建buildMenu.js在controller下新建buildMenu.js。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import &#123; app, Menu, ipcMain &#125; from &apos;electron&apos;;import &#123; inject &#125; from &apos;vue&apos;;const isMac = process.platform === &apos;darwin&apos;;let mainWindow = null;const template = [ // &#123; role: &apos;appMenu&apos; &#125; ...(isMac ? [&#123; label: app.name, submenu: [ &#123; role: &apos;about&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;services&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;hide&apos; &#125;, &#123; role: &apos;hideOthers&apos; &#125;, &#123; role: &apos;unhide&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;quit&apos; &#125; ] &#125;] : []), // &#123; role: &apos;fileMenu&apos; &#125; &#123; label: &apos;File&apos;, submenu: [ isMac ? &#123; role: &apos;close&apos; &#125; : &#123; role: &apos;quit&apos; &#125; ] &#125;, // &#123; role: &apos;editMenu&apos; &#125; &#123; label: &apos;Edit&apos;, submenu: [ &#123; role: &apos;undo&apos; &#125;, &#123; role: &apos;redo&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;cut&apos; &#125;, &#123; role: &apos;copy&apos; &#125;, &#123; role: &apos;paste&apos; &#125;, ...(isMac ? [ &#123; role: &apos;pasteAndMatchStyle&apos; &#125;, &#123; role: &apos;delete&apos; &#125;, &#123; role: &apos;selectAll&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;Speech&apos;, submenu: [ &#123; role: &apos;startSpeaking&apos; &#125;, &#123; role: &apos;stopSpeaking&apos; &#125; ] &#125; ] : [ &#123; role: &apos;delete&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;selectAll&apos; &#125; ]) ] &#125;, // &#123; role: &apos;viewMenu&apos; &#125; &#123; label: &apos;View&apos;, submenu: [ &#123; role: &apos;reload&apos; &#125;, &#123; role: &apos;forceReload&apos; &#125;, &#123; role: &apos;toggleDevTools&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;resetZoom&apos; &#125;, &#123; role: &apos;zoomIn&apos; &#125;, &#123; role: &apos;zoomOut&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;togglefullscreen&apos; &#125; ] &#125;, // &#123; role: &apos;windowMenu&apos; &#125; &#123; label: &apos;Window&apos;, submenu: [ &#123; role: &apos;minimize&apos; &#125;, &#123; role: &apos;zoom&apos; &#125;, ...(isMac ? [ &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;front&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; role: &apos;window&apos; &#125; ] : [ &#123; role: &apos;close&apos; &#125; ]) ] &#125;, &#123; role: &apos;help&apos;, submenu: [ &#123; label: &apos;Learn More&apos;, click: async () =&gt; &#123; const &#123; shell &#125; = require(&apos;electron&apos;) await shell.openExternal(&apos;https://electronjs.org&apos;) &#125; &#125; ] &#125;, &#123; label: &apos;actions&apos;, submenu: [ &#123; label: &apos;添加&apos;, click: async ()=&gt; &#123; // 触发renderer进程的on-show-add-dialog-event事件 mainWindow.webContents.send(&apos;on-show-add-dialog-event&apos;); &#125;, accelerator: &apos;CommandOrControl+Alt+O&apos; &#125; ] &#125;]const menu = Menu.buildFromTemplate(template)Menu.setApplicationMenu(menu)export const injectMainWindow = win=&gt; &#123; mainWindow = win;&#125; 在vue侧调用渲染进程暴露的函数，把需要执行的vue侧回调函数传进去。 渲染进程函数执行后注册了on-show-add-dialog-event这个渲染进程事件。 Menu菜单点击后，主进程触发渲染进程事件，这个事件的回调函数中会执行vue侧提供的回调函数。 通过上述步骤即可完成主进程-&gt;渲染进程-&gt;vue侧的通信 托盘&amp;app图标mac端在controller下新建tray.js12345678910111213141516// 兼容mac电脑import &#123; Tray &#125; from &apos;electron&apos;;import path from &apos;path&apos;;import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;const createTray = (app, win)=&gt; &#123; const tray = new Tray(path.resolve(__dirnameFn(import.meta.url), &apos;../icon.png&apos;)); tray.setToolTip(&apos;electron-tutorial&apos;); tray.on(&apos;click&apos;, e=&gt; &#123; if(e.shiftKey) &#123; app.quit(); &#125; &#125;);&#125;export default createTray; 在main.js增加1234// tray 兼容mac托盘import createTray from &apos;./controller/tray.js&apos;;createTray(app, win); window端在main.js增加1icon: nativeImage.createFromPath(path.resolve(__dirnameFn(import.meta.url), &apos;./icon.png&apos;)), 全屏全屏功能可以应用在一些终端设备中，比如商场或者机场的自助终端。在main.js中增加1234// 取消浏览器头部菜单栏frame: false// 设置全屏win.maximize(); 打包方法一electron打包需要打包工具，安装12npm i @electron-forge/cli -Dnpm i @electron-forge/maker-squirrel -D window端在根目录下新增forge.config.js文件12345678910111213export default &#123; // ... makers: [ &#123; name: &apos;@electron-forge/maker-squirrel&apos;, config: &#123; certificateFile: &apos;./cert.pfx&apos;, certificatePassword: process.env.CERTIFICATE_PASSWORD &#125; &#125; ] // ...&#125; package.json增加1&quot;make&quot;: &quot;electron-forge make&quot; 执行npm run make,（网络不好有时会失败，重试几次），在根目录输出一个out文件夹。在里边找到项目名称的exe文件就是可执行app。 方法二electron打包需要打包工具，安装1npm i electron-packager -D window端配置可以直接写在scripts脚本中,package.json增加1&quot;make2&quot;: &quot;electron-packager . godex-printer --platform=win32 --arch=x64 --icon=build/icon.ico --out=out --overwrite&quot; 这个打包方式比第一个要快很多，--icon=build/icon.ico这个参数是生成的exe图标设置 方法三 此方法可以打包生成安装文件 electron打包需要打包工具，安装1npm i electron-builder -D 在项目根目录下创建electron-builder.yml文件，内容如下123456789nsis: oneClick: false # 创建一键安装程序还是辅助安装程序（默认是一键安装） allowElevation: true # 是否允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序 （仅作用于辅助安装程序） allowToChangeInstallationDirectory: true # 是否允许修改安装目录 （仅作用于辅助安装程序） createStartMenuShortcut: true # 是否创建开始菜单快捷方式 artifactName: $&#123;productName&#125;-$&#123;version&#125;-$&#123;platform&#125;-$&#123;arch&#125;.$&#123;ext&#125; shortcutName: $&#123;productName&#125; uninstallDisplayName: $&#123;productName&#125; createDesktopShortcut: always 在package.json增加123&quot;scripts&quot;: &#123; &quot;makebuilder&quot;: &quot;electron-builder --win --config&quot;&#125;, 第一次执行打包时需要下载打包工具，根据网络实际情况可能会失败，多尝试几次。打包后在dist目录下的.exe文件就是安装执行文件，双击下一步即可安装。 打包问题开发调试时，main.js中，引入vue侧是win.loadURL(&#39;http://localhost:5173&#39;);这样引入的，这样打包的话，执行app应用时还需要启动vue项目才可以使用。如果想直接把vue侧直接打到app应用包中，修改main.js12// win.loadURL(&apos;http://localhost:5173&apos;);win.loadFile(path.resolve(__dirnameFn(import.meta.url), &apos;./dist/index.html&apos;)); 还需要修改dist/index.html中引入的js和css的路径1234&lt;!-- &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;/assets/index-CrynHw1J.css&quot;&gt; --&gt;&lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;./assets/index-CrynHw1J.css&quot;&gt; 将绝对路径改成相对路径。 打包后resources文件加密在打包之后，输出的可执行exe文件夹下有一个resources文件夹，里边是源代码，因为执行时需要这些源代码文件，不能删除。但是，代码暴露了，为了安全，可以使用asar对源代码封装加密。 安装asar12// 全局安装npm i -g asar 执行asar封装源码1asar pack src src.asar 将src文件夹封装成了src.asar 如何使用比如，之前main.js文件需要调用src文件夹里的内容1import &apos;./src/index.js&apos;; 封装之后1import &apos;./src.asar/index.js&apos;; 就这么简单，重新打包之后在resources下可以看到src.asar文件了，asar文件轻易破解不了的，起到了一定的安全性，这时可以把文件夹下src源代码删除，提供给客户使用。 应用更新使用electron-updater实现应用更新详情暂略 总结以上完成了一个简单的electron+vue的项目。 代码1本教程代码source 代码2保存网站的app代码source","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"electron","slug":"electron","permalink":"/tags/electron/"}]},{"title":"pnpm创建monorepo项目","slug":"pnpm创建monorepo项目","date":"2024-07-04T08:15:46.000Z","updated":"2024-07-05T05:29:50.693Z","comments":true,"path":"2024/07/04/pnpm创建monorepo项目/","link":"","permalink":"/2024/07/04/pnpm创建monorepo项目/","excerpt":"使用pnpm工具创建monorepo项目","text":"使用pnpm工具创建monorepo项目monorepo项目是当下非常流行的，例如React、Vue、Vite等项目都在使用。创建monorepo项目的方法很多，本文使用pnpm来创建。 全局安装pnpm1npm install -g pnpm 创建文件夹创建一个叫monorepo的文件夹1mkdir monorepo 创建相关文件初始化package.json1pnpm init pnpm-workspace.yaml新建pnpm-workspace.yaml文件，内容如下12packages: - &apos;packages/*&apos; 表示packages下是子项目 .npmignore1node_modules/ 这个文件设置发布的时候过滤掉node_modules文件夹的内容 创建packages文件夹在packages下创建子项目1mkdir core utils api 创建好三个子项目文件夹后，分别初始化package.json，之后需要修改package.json的name，加上npmjs上所对应的Organizations名字(名字前加@)。再加上&quot;publishConfig&quot;: {&quot;access&quot;: &quot;public&quot;}，用来告诉npmjs这个是公开的（私有是收费的，发布的时候会报错）。core package.json123456789101112131415161718&#123; &quot;name&quot;: &quot;@nux-monorepo/core&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node ./index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;publishConfig&quot;: &#123; &quot;access&quot;: &quot;public&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@nux-monorepo/api&quot;: &quot;workspace:^&quot; &#125;&#125; api package.json123456789101112131415161718&#123; &quot;name&quot;: &quot;@nux-monorepo/api&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;publishConfig&quot;: &#123; &quot;access&quot;: &quot;public&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@nux-monorepo/utils&quot;: &quot;workspace:^&quot; &#125;&#125; utils package.json123456789101112131415&#123; &quot;name&quot;: &quot;@nux-monorepo/utils&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;publishConfig&quot;: &#123; &quot;access&quot;: &quot;public&quot; &#125;&#125; 添加依赖公共依赖在monorepo目录下1pnpm add loadsh -w -w表示在主项目目录下添加依赖 局部依赖1pnpm add @nux-monorepo/utils -F @nux-monorepo/api 表示给@nux-monorepo/api子项目添加了一个@nux-monorepo/utils的依赖。再加一个依赖1pnpm add @nux-monorepo/api -F @nux-monorepo/core 可以看上边的package.json文件,添加依赖后的效果。上边公共依赖和局部依赖执行命令都是在项目的根目录下执行即可。 测试可以在子项目中运行npm run dev去执行,也可以在主项目下直接执行,在主项目的package.json下添加1&quot;dev:core&quot;: &quot;pnpm -F @nux-monorepo/core dev&quot; 运行结果跟在子项目中是一样的。 发布普通发布 在npmjs官网有一个账号 在npmjs新建一个Organizations,这个名字就是子项目package.json中name的前缀,@nux-monorepo/core中的nux-monorepo 进入到子项目,执行pnpm publish,注意,这里需要把npm的源设置成官网的https://registry.npmjs.org/(因为npmjs的官方源下载速度慢，平时都会切换国内的镜像地址，这里需要注意下) 每次发布时需要修改version版本号，一样的话发布会失败。 脚本发布上面的发布需要进入到每个子项目进行发布，非常麻烦，可以编写一个脚本，进行批量发布。这里还有一点，可以在脚本中修改版本号，可以根据不同的规则修改，本文简单起见，把子项目中的version版本号都设置成主项目里的version，但是发布前主项目的version需要手动修改一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const &#123; exec &#125; = require(&apos;child_process&apos;);const packagesRoot = &apos;./packages&apos;;const packageName = &apos;package.json&apos;;let version;// 获取主项目package.json中的versionlet packageData = fs.readFileSync(path.resolve(&apos;./&apos;, packageName), &apos;utf8&apos;);version = JSON.parse(packageData).version;// 发布的命令行执行函数function publishPackage(packageDir) &#123; exec(`cd $&#123;packageDir&#125; &amp;&amp; pnpm publish`, (error, stdout, stderr) =&gt; &#123; if (error) &#123; console.error(`Error publishing $&#123;packageDir&#125;:`, error); &#125; else &#123; console.log(`Published: $&#123;packageDir&#125;`); &#125; &#125;);&#125;// 扫描子项目函数function scanAndPublish(directory) &#123; fs.readdir(directory, &#123; withFileTypes: true &#125;, (err, files) =&gt; &#123; if (err) &#123; console.error(&apos;Error reading directory:&apos;, err); return; &#125; files.forEach((file) =&gt; &#123; if (file.isDirectory()) &#123; // 修改package.json中的version let packagePath = path.resolve(&apos;./&apos;, packagesRoot, file.name, packageName); let packageData = JSON.parse(fs.readFileSync(packagePath, &apos;utf8&apos;)); packageData.version = version; let writeData = JSON.stringify(packageData, null, 2); fs.writeFileSync(packagePath, writeData, &apos;utf8&apos;); // 发布 publishPackage(path.dirname(packagePath)); &#125; &#125;); &#125;);&#125;// 主入口scanAndPublish(packagesRoot); 使用1npm i @nux-monorepo/core 相关代码source","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"npm","slug":"npm","permalink":"/tags/npm/"}]},{"title":"从零打造一个Web地图引擎","slug":"从零打造一个Web地图引擎","date":"2024-07-03T01:19:47.000Z","updated":"2024-07-03T02:27:57.898Z","comments":true,"path":"2024/07/03/从零打造一个Web地图引擎/","link":"","permalink":"/2024/07/03/从零打造一个Web地图引擎/","excerpt":"从零开始，实现一个web地图，类似百度地图的效果","text":"从零开始，实现一个web地图，类似百度地图的效果本文clone来至wanglin2 说到地图，大家一定很熟悉，平时应该都使用过百度地图、高德地图、腾讯地图等，如果涉及到地图相关的开发需求，也有很多选择，比如前面的几个地图都会提供一套js API，此外也有一些开源地图框架可以使用，比如OpenLayers、Leaflet等。 那么大家有没有想过这些地图是怎么渲染出来的呢，为什么根据一个经纬度就能显示对应的地图呢，不知道没关系，本文会带各位从零实现一个简单的地图引擎，来帮助大家了解GIS基础知识及Web地图的实现原理。 选个经纬度首先我们去高德地图上选个经纬度，作为我们后期的地图中心点，打开高德坐标拾取工具，随便选择一个点： 笔者选择了杭州的雷峰塔，经纬度为：[120.148732,30.231006]。 瓦片url分析地图瓦片我们使用高德的在线瓦片，地址如下： 1https://webrd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8 目前各大地图厂商的瓦片服务遵循的规则是有不同的： 谷歌XYZ规范：谷歌地图、OpenStreetMap、高德地图、geoq、天地图，坐标原点在左上角 TMS规范：腾讯地图，坐标原点在左下角 WMTS规范：原点在左上角，瓦片不是正方形，而是矩形，这个应该是官方标准 百度地图比较特立独行，投影、分辨率、坐标系都跟其他厂商不一样，原点在经纬度都为0的位置，也就是中间，向右为X正方向，向上为Y正方向 谷歌和TMS的瓦片区别可以通过该地址可视化的查看：地图瓦片。 虽然规范不同，但原理基本是一致的，都是把地球投影成一个巨大的正方形世界平面图，然后按照四叉树进行分层切割，比如第一层，只有一张瓦片，显示整个世界的信息，所以基本只能看到洲和海的名称和边界线，第二层，切割成四张瓦片，显示信息稍微多了一点，以此类推，就像一个金字塔一样，底层分辨率最高，显示的细节最多，瓦片数也最多，顶层分辨率最低，显示的信息很少，瓦片数量相对也最少： 每一层的瓦片数量计算公式： 1Math.pow(Math.pow(2, n), 2)// 行*列：2^n * 2^n 十八层就需要68719476736张瓦片，所以一套地图瓦片整体数量是非常庞大的。 瓦片切好以后，通过行列号和缩放层级来保存，所以可以看到瓦片地址中有三个变量：x、y、z 123x：行号y：列号z：分辨率，一般为0-18 通过这三个变量就可以定位到一张瓦片，比如下面这个地址，行号为109280，列号为53979，缩放层级为17： 1https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8 对应的瓦片为： 关于瓦片的更多信息可以阅读瓦片地图原理。 坐标系简介高德地图使用的是GCJ-02坐标系，也称火星坐标系，由中国国家测绘局在02年发布，是在GPS坐标（WGS-84坐标系）基础上经加密后而来，也就是增加了非线性的偏移，让你摸不准真实位置，为了国家安全，国内地图服务商都需要使用GCJ-02坐标系。 WGS-84坐标系是国际通用的标准，EPSG编号为EPSG:4326，通常GPS设备获取到的原始经纬度和国外的地图厂商使用的都是WGS-84坐标系。 这两种坐标系都是地理坐标系，球面坐标，单位为度，这种坐标方便在地球上定位，但是不方便展示和进行面积距离计算，我们印象中的地图都是平面的，所以就有了另外一种平面坐标系，平面坐标系是通过投影的方式从地理坐标系中转换过来，所以也称为投影坐标系，通常单位为米，投影坐标系根据投影方式的不同存在多种，在Web开发的场景里通常使用的是Web墨卡托投影，编号为EPSG:3857，它基于墨卡托投影，把WGS-84坐标系投影成正方形： 这是通过舍弃了南北85.051129纬度以上的地区实现的，因为它是正方形，所以一个大的正方形可以很方便的被分割为更小的正方形。 坐标系更详细的信息可参考GIS之坐标系统，EPSG:3857的详细信息可参考EPSG:3857。 经纬度定位行列号上一节里我们简单介绍了一下坐标系，按照Web地图的标准，我们的地图引擎也选择支持EPSG:3857投影，但是我们通过高德工具获取到的是火星坐标系的经纬度坐标，所以第一步要把经纬度坐标转换为Web墨卡托投影坐标，这里为了简单，先直接把火星坐标当做WGS-84坐标，后面再来看这个问题。 转换方法网上一搜就有： 12345678910111213141516171819202122232425262728293031// 角度转弧度const angleToRad = (angle) =&gt; &#123; return angle * (Math.PI / 180)&#125;// 弧度转角度const radToAngle = (rad) =&gt; &#123; return rad * (180 / Math.PI)&#125;// 地球半径const EARTH_RAD = 6378137// 4326转3857const lngLat2Mercator = (lng, lat) =&gt; &#123; // 经度先转弧度，然后因为 弧度 = 弧长 / 半径 ，得到弧长为 弧长 = 弧度 * 半径 let x = angleToRad(lng) * EARTH_RAD; // 纬度先转弧度 let rad = angleToRad(lat) // 下面我就看不懂了，各位随意。。。 let sin = Math.sin(rad) let y = EARTH_RAD / 2 * Math.log((1 + sin) / (1 - sin)) return [x, y]&#125;// 3857转4326const mercatorTolnglat = (x, y) =&gt; &#123; let lng = radToAngle(x) / EARTH_RAD let lat = radToAngle((2 * Math.atan(Math.exp(y / EARTH_RAD)) - (Math.PI / 2))) return [lng, lat]&#125; 3857坐标有了，它的单位是米，那么怎么转换成瓦片的行列号呢，这就涉及到分辨率的概念了，即地图上一像素代表实际多少米，分辨率如果能从地图厂商的文档里获取是最好的，如果找不到，也可以简单计算一下（如果使用计算出来的也不行，那就只能求助搜索引擎了），我们知道地球半径是6378137米，3857坐标系把地球当做正圆球体来处理，所以可以算出地球周长，投影是贴着地球赤道的： 所以投影成正方形的世界平面图后的边长代表的就是地球的周长，前面我们也知道了每一层级的瓦片数量的计算方式，而一张瓦片的大小一般是256*256像素，所以用地球周长除以展开后的世界平面图的边长就知道了地图上每像素代表实际多少米： 1234567891011// 地球周长const EARTH_PERIMETER = 2 * Math.PI * EARTH_RAD// 瓦片像素const TILE_SIZE = 256// 获取某一层级下的分辨率const getResolution = (n) =&gt; &#123; const tileNums = Math.pow(2, n) const tileTotalPx = tileNums * TILE_SIZE return EARTH_PERIMETER / tileTotalPx&#125; 地球周长算出来是40075016.68557849，可以看到OpenLayers就是这么计算的： 3857坐标的单位是米，那么把坐标除以分辨率就可以得到对应的像素坐标，再除以256，就可以得到瓦片的行列号： 函数如下： 1234567// 根据3857坐标及缩放层级计算瓦片行列号const getTileRowAndCol = (x, y, z) =&gt; &#123; let resolution = getResolution(z) let row = Math.floor(x / resolution / TILE_SIZE) let col = Math.floor(y / resolution / TILE_SIZE) return [row, col]&#125; 接下来我们把层级固定为17，那么分辨率resolution就是1.194328566955879，雷峰塔的经纬度转成3857的坐标为：[13374895.665697495, 3533278.205310311]，使用上面的函数计算出来行列号为：[43744, 11556]，我们把这几个数据代入瓦片的地址里进行访问： 1https://webrd01.is.autonavi.com/appmaptile?x=43744&amp;y=11556&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8 一片空白，这是为啥呢，其实是因为原点不一样，4326和3857坐标系的原点在赤道和本初子午线相交点，非洲边上的海里，而瓦片的原点在左上角： 再来看下图会更容易理解： 3857坐标系的原点相当于在世界平面图的中间，向右为x轴正方向，向上为y轴正方向，而瓦片地图的原点在左上角，所以我们需要根据图上【绿色虚线】的距离计算出【橙色实线】的距离，这也很简单，水平坐标就是水平绿色虚线的长度加上世界平面图的一半，垂直坐标就是世界平面图的一半减去垂直绿色虚线的长度，世界平面图的一半也就是地球周长的一半，修改getTileRowAndCol函数： 12345678const getTileRowAndCol = (x, y, z) =&gt; &#123; x += EARTH_PERIMETER / 2 // ++ y = EARTH_PERIMETER / 2 - y // ++ let resolution = getResolution(z) let row = Math.floor(x / resolution / TILE_SIZE) let col = Math.floor(y / resolution / TILE_SIZE) return [row, col]&#125; 这次计算出来的瓦片行列号为[109280, 53979]，代入瓦片地址： 1https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8 结果如下： 可以看到雷峰塔出来了。 瓦片显示位置计算我们现在能根据一个经纬度找到对应的瓦片，但是这还不够，我们的目标是要能在浏览器上显示出来，这就需要解决两个问题，一个是加载多少块瓦片，二是计算每一块瓦片的显示位置。 渲染瓦片我们使用canvas画布，模板如下： 12345&lt;template&gt; &lt;div class=\"map\" ref=\"map\"&gt; &lt;canvas ref=\"canvas\"&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt; 地图画布容器map的大小我们很容易获取： 12345678910// 容器大小let &#123; width, height &#125; = this.$refs.map.getBoundingClientRect()this.width = widththis.height = height// 设置画布大小let canvas = this.$refs.canvascanvas.width = widthcanvas.height = height// 获取绘图上下文this.ctx = canvas.getContext('2d') 地图中心点我们设在画布中间，另外中心点的经纬度center和缩放层级zoom因为都是我们自己设定的，所以也是已知的，那么我们可以计算出中心坐标对应的瓦片： 12345// 中心点对应的瓦片let centerTile = getTileRowAndCol( ...lngLat2Mercator(...this.center),// 4326转3857 this.zoom// 缩放层级) 缩放层级还是设为17，中心点还是使用雷峰塔的经纬度，那么对应的瓦片行列号前面我们已经计算过了，为[109280, 53979]。 中心坐标对应的瓦片行列号知道了，那么该瓦片左上角在世界平面图中的像素位置我们也就知道了： 12// 中心瓦片左上角对应的像素坐标let centerTilePos = [centerTile[0] * TILE_SIZE, centerTile[1] * TILE_SIZE] 计算出来为[27975680, 13818624]。这个坐标怎么转换到屏幕上呢，请看下图： 中心经纬度的瓦片我们计算出来了，瓦片左上角的像素坐标也知道了，然后我们再计算出中心经纬度本身对应的像素坐标，那么和瓦片左上角的差值就可以计算出来，最后我们把画布的原点移动到画布中间（画布默认原点为左上角，x轴正方向向右，y轴正方向向下），也就是把中心经纬度作为坐标原点，那么中心瓦片的显示位置就是这个差值。 补充一下将经纬度转换成像素的方法： 123456789101112// 计算4326经纬度对应的像素坐标const getPxFromLngLat = (lng, lat, z) =&gt; &#123; let [_x, _y] = lngLat2Mercator(lng, lat)// 4326转3857 // 转成世界平面图的坐标 _x += EARTH_PERIMETER / 2 _y = EARTH_PERIMETER / 2 - _y let resolution = resolutions[z]// 该层级的分辨率 // 米/分辨率得到像素 let x = Math.floor(_x / resolution) let y = Math.floor(_y / resolution) return [x, y]&#125; 计算中心经纬度对应的像素坐标： 12// 中心点对应的像素坐标let centerPos = getPxFromLngLat(...this.center, this.zoom) 计算差值： 12345// 中心像素坐标距中心瓦片左上角的差值let offset = [ centerPos[0] - centerTilePos[0], centerPos[1] - centerTilePos[1]] 最后通过canvas来把中心瓦片渲染出来： 12345678910// 移动画布原点到画布中间this.ctx.translate(this.width / 2, this.height / 2)// 加载瓦片图片let img = new Image()// 拼接瓦片地址img.src = getTileUrl(...centerTile, this.zoom)img.onload = () =&gt; &#123; // 渲染到canvas this.ctx.drawImage(img, -offset[0], -offset[1])&#125; 这里先来看看getTileUrl方法的实现： 1234567// 拼接瓦片地址const getTileUrl = (x, y, z) =&gt; &#123; let domainIndexList = [1, 2, 3, 4] let domainIndex = domainIndexList[Math.floor(Math.random() * domainIndexList.length)] return `https://webrd0$&#123;domainIndex&#125;.is.autonavi.com/appmaptile?x=$&#123;x&#125;&amp;y=$&#123;y&#125;&amp;z=$&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8`&#125; 这里随机了四个子域：webrd01、webrd02、webrd03、webrd04，这是因为浏览器对于同一域名同时请求的资源是有数量限制的，而当地图层级变大后需要加载的瓦片数量会比较多，那么均匀分散到各个子域下去请求可以更快的渲染出所有瓦片，减少排队等待时间，基本所有地图厂商的瓦片服务地址都支持多个子域。 为了方便看到中心点的位置，我们再额外渲染两条中心辅助线，效果如下： 可以看到中心点确实是雷峰塔，当然这只是渲染了中心瓦片，我们要的是瓦片铺满整个画布，对于其他瓦片我们都可以根据中心瓦片计算出来，比如中心瓦片左边的一块，它的计算如下： 1234567// 瓦片行列号，行号减1，列号不变let leftTile = [centerTile[0] - 1, centerTile[1]]// 瓦片显示坐标，x轴减去一个瓦片的大小，y轴不变let leftTilePos = [ offset[0] - TILE_SIZE * 1, offset[1]] 所以我们只要计算出中心瓦片四个方向各需要几块瓦片，然后用一个双重循环即可计算出画布需要的所有瓦片，计算需要的瓦片数量很简单，请看下图： 画布宽高的一半减去中心瓦片占据的空间即可得到该方向剩余的空间，然后除以瓦片的尺寸就知道需要几块瓦片了： 12345// 计算瓦片数量let rowMinNum = Math.ceil((this.width / 2 - offset[0]) / TILE_SIZE)// 左let colMinNum = Math.ceil((this.height / 2 - offset[1]) / TILE_SIZE)// 上let rowMaxNum = Math.ceil((this.width / 2 - (TILE_SIZE - offset[0])) / TILE_SIZE)// 右let colMaxNum = Math.ceil((this.height / 2 - (TILE_SIZE - offset[1])) / TILE_SIZE)// 下 我们把中心瓦片作为原点，坐标为[0, 0]，来个双重循环扫描一遍即可渲染出所有瓦片： 1234567891011121314151617181920// 从上到下，从左到右，加载瓦片for (let i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123; for (let j = -colMinNum; j &lt;= colMaxNum; j++) &#123; // 加载瓦片图片 let img = new Image() img.src = getTileUrl( centerTile[0] + i,// 行号 centerTile[1] + j,// 列号 this.zoom ) img.onload = () =&gt; &#123; // 渲染到canvas this.ctx.drawImage( img, i * TILE_SIZE - offset[0], j * TILE_SIZE - offset[1] ) &#125; &#125;&#125; 效果如下： 很完美。 拖动拖动可以这么考虑，前面已经实现了渲染指定经纬度的瓦片，当我们按住进行拖动时，可以知道鼠标滑动的距离，然后把该距离，也就是像素转换成经纬度的数值，最后我们再更新当前中心点的经纬度，并清空画布，调用之前的方法重新渲染，不停重绘造成是在移动的视觉假象。 监听鼠标相关事件： 1&lt;canvas ref=\"canvas\" @mousedown=\"onMousedown\"&gt;&lt;/canvas&gt; 1234567891011121314151617181920212223242526272829303132export default &#123; data()&#123; return &#123; isMousedown: false &#125; &#125;, mounted() &#123; window.addEventListener(\"mousemove\", this.onMousemove); window.addEventListener(\"mouseup\", this.onMouseup); &#125;, methods: &#123; // 鼠标按下 onMousedown(e) &#123; if (e.which === 1) &#123; this.isMousedown = true; &#125; &#125;, // 鼠标移动 onMousemove(e) &#123; if (!this.isMousedown) &#123; return; &#125; // ... &#125;, // 鼠标松开 onMouseup() &#123; this.isMousedown = false; &#125; &#125;&#125; 在onMousemove方法里计算拖动后的中心经纬度及重新渲染画布： 1234567// 计算本次拖动的距离对应的经纬度数据let mx = e.movementX * resolutions[this.zoom];let my = e.movementY * resolutions[this.zoom];// 把当前中心点经纬度转成3857坐标let [x, y] = lngLat2Mercator(...this.center);// 更新拖动后的中心点经纬度center = mercatorToLngLat(x - mx, my + y); movementX和movementY属性能获取本次和上一次鼠标事件中的移动值，兼容性不是很好，不过自己计算该值也很简单，详细请移步MDN。乘以当前分辨率把像素换算成米，然后把当前中心点经纬度也转成3857的米坐标，偏移本次移动的距离，最后再转回4326的经纬度坐标作为更新后的中心点即可。 为什么x是减，y是加呢，很简单，我们鼠标向右和向下移动时距离是正的，相应的地图会向右或向下移动，4326坐标系向右和向上为正方向，那么地图向右移动时，中心点显然是相对来说是向左移了，因为向右为正方向，所以中心点经度方向就是减少了，所以是减去移动的距离，而地图向下移动，中心点相对来说是向上移了，因为向上为正方向，所以中心点纬度方向就是增加了，所以加上移动的距离。 更新完中心经纬度，然后清空画布重新绘制： 1234// 清空画布this.clear();// 重新绘制，renderTiles方法就是上一节的代码逻辑封装this.renderTiles(); 效果如下： 可以看到已经凌乱了，这是为啥呢，其实是因为图片加载是一个异步的过程，我们鼠标移动过程中，会不断的计算出要加载的瓦片进行加载，但是可能上一批瓦片还没加载完成，鼠标已经移动到新的位置了，又计算出一批新的瓦片进行加载，此时上一批瓦片可能加载完成并渲染出来了，但是这些瓦片有些可能已经被移除画布，不需要显示，有些可能还在画布内，但是使用的还是之前的位置，渲染出来也是不对的，同时新的一批瓦片可能也加载完成并渲染出来，自然导致了最终显示的错乱。 知道原因就简单了，首先我们加个缓存对象，因为在拖动过程中，很多瓦片只是位置变了，不需要重新加载，同一个瓦片加载一次，后续只更新它的位置即可；另外再设置一个对象来记录当前画布上应该显示的瓦片，防止不应该出现的瓦片渲染出来： 123456&#123; // 缓存瓦片 tileCache: &#123;&#125;, // 记录当前画布上需要的瓦片 currentTileCache: &#123;&#125;&#125; 因为需要记录瓦片的位置、加载状态等信息，我们创建一个瓦片类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 瓦片类class Tile &#123; constructor(opt = &#123;&#125;) &#123; // 画布上下文 this.ctx = ctx // 瓦片行列号 this.row = row this.col = col // 瓦片层级 this.zoom = zoom // 显示位置 this.x = x this.y = y // 一个函数，判断某块瓦片是否应该渲染 this.shouldRender = shouldRender // 瓦片url this.url = '' // 缓存key this.cacheKey = this.row + '_' + this.col + '_' + this.zoom // 图片 this.img = null // 图片是否加载完成 this.loaded = false this.createUrl() this.load() &#125; // 生成url createUrl() &#123; this.url = getTileUrl(this.row, this.col, this.zoom) &#125; // 加载图片 load() &#123; this.img = new Image() this.img.src = this.url this.img.onload = () =&gt; &#123; this.loaded = true this.render() &#125; &#125; // 将图片渲染到canvas上 render() &#123; if (!this.loaded || !this.shouldRender(this.cacheKey)) &#123; return &#125; this.ctx.drawImage(this.img, this.x, this.y) &#125; // 更新位置 updatePos(x, y) &#123; this.x = x this.y = y return this &#125;&#125; 然后修改之前的双重循环渲染瓦片的逻辑： 12345678910111213141516171819202122232425262728293031323334this.currentTileCache = &#123;&#125;// 清空缓存对象for (let i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123; for (let j = -colMinNum; j &lt;= colMaxNum; j++) &#123; // 当前瓦片的行列号 let row = centerTile[0] + i let col = centerTile[1] + j // 当前瓦片的显示位置 let x = i * TILE_SIZE - offset[0] let y = j * TILE_SIZE - offset[1] // 缓存key let cacheKey = row + '_' + col + '_' + this.zoom // 记录画布当前需要的瓦片 this.currentTileCache[cacheKey] = true // 该瓦片已加载过 if (this.tileCache[cacheKey]) &#123; // 更新到当前位置 this.tileCache[cacheKey].updatePos(x, y).render() &#125; else &#123; // 未加载过 this.tileCache[cacheKey] = new Tile(&#123; ctx: this.ctx, row, col, zoom: this.zoom, x, y, // 判断瓦片是否在当前画布缓存对象上，是的话则代表需要渲染 shouldRender: (key) =&gt; &#123; return this.currentTileCache[key] &#125;, &#125;) &#125; &#125;&#125; 效果如下： 可以看到，拖动已经正常了，当然，上述实现还是很粗糙的，需要优化的地方很多，比如： 1.一般会先排个序，优先加载中心瓦片 2.缓存的瓦片越来越多肯定也会影响性能，所以还需要一些清除策略 这些问题有兴趣的可以自行思考。 缩放拖动是实时更新中心点经纬度，那么缩放自然更新缩放层级就行了： 12345678910111213141516171819202122232425262728293031export default &#123; data() &#123; return &#123; // 缩放层级范围 minZoom: 3, maxZoom: 18, // 防抖定时器 zoomTimer: null &#125; &#125;, mounted() &#123; window.addEventListener('wheel', this.onMousewheel) &#125;, methods: &#123; // 鼠标滚动 onMousewheel(e) &#123; if (e.deltaY &gt; 0) &#123; // 层级变小 if (this.zoom &gt; this.minZoom) this.zoom-- &#125; else &#123; // 层级变大 if (this.zoom &lt; this.maxZoom) this.zoom++ &#125; // 加个防抖，防止快速滚动加载中间过程的瓦片 this.zoomTimer = setTimeout(() =&gt; &#123; this.clear() this.renderTiles() &#125;, 300) &#125; &#125;&#125; 效果如下： 功能是有了，不过效果很一般，因为我们平常使用的地图缩放都是有一个放大或缩小的过渡动画，而这个是直接空白然后重新渲染，不仔细看都不知道是放大还是缩小。 所以我们不妨加个过渡效果，当我们鼠标滚动后，先将画布放大或缩小，动画结束后再根据最终的缩放值来渲染需要的瓦片。 画布默认缩放值为1，放大则在此基础上乘以2倍，缩小则除以2，然后动画到目标值，动画期间设置画布的缩放值及清空画布，重新绘制画布上的已有瓦片，达到放大或缩小的视觉效果，动画结束后再调用renderTiles重新渲染最终缩放值需要的瓦片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 动画使用popmotion库，https://popmotion.io/import &#123; animate &#125; from 'popmotion'export default &#123; data() &#123; return &#123; lastZoom: 0, scale: 1, scaleTmp: 1, playback: null, &#125; &#125;, methods: &#123; // 鼠标滚动 onMousewheel(e) &#123; if (e.deltaY &gt; 0) &#123; // 层级变小 if (this.zoom &gt; this.minZoom) this.zoom-- &#125; else &#123; // 层级变大 if (this.zoom &lt; this.maxZoom) this.zoom++ &#125; // 层级未发生改变 if (this.lastZoom === this.zoom) &#123; return &#125; this.lastZoom = this.zoom // 更新缩放比例，也就是目标缩放值 this.scale *= e.deltaY &gt; 0 ? 0.5 : 2 // 停止上一次动画 if (this.playback) &#123; this.playback.stop() &#125; // 开启动画 this.playback = animate(&#123; from: this.scaleTmp,// 当前缩放值 to: this.scale,// 目标缩放值 onUpdate: (latest) =&gt; &#123; // 实时更新当前缩放值 this.scaleTmp = latest // 保存画布之前状态，原因有二： // 1.scale方法是会在之前的状态上叠加的，比如初始是1，第一次执行scale(2,2)，第二次执行scale(3,3)，最终缩放值不是3，而是6，所以每次缩放完就恢复状态，那么就相当于每次都是从初始值1开始缩放，效果就对了 // 2.保证缩放效果只对重新渲染已有瓦片生效，不会对最后的renderTiles()造成影响 this.ctx.save() this.clear() this.ctx.scale(latest, latest) // 刷新当前画布上的瓦片 Object.keys(this.currentTileCache).forEach((tile) =&gt; &#123; this.tileCache[tile].render() &#125;) // 恢复到画布之前状态 this.ctx.restore() &#125;, onComplete: () =&gt; &#123; // 动画完成后将缩放值重置为1 this.scale = 1 this.scaleTmp = 1 // 根据最终缩放值重新计算需要的瓦片并渲染 this.renderTiles() &#125;, &#125;) &#125; &#125;&#125; 效果如下： 虽然效果还是一般，不过至少能看出来是在放大还是缩小。 坐标系转换前面还遗留了一个小问题，即我们把高德工具上选出的经纬度直接当做4326经纬度，前面也讲过，它们之间是存在偏移的，比如手机GPS获取到的经纬度一般都是84坐标，直接在高德地图显示，会发现和你实际位置不一样，所以就需要进行一个转换，有一些工具可以帮你做些事情，比如Gcoord、coordtransform等。 总结上述效果看着比较一般，其实只要在上面的基础上稍微加一点瓦片的淡出动画，效果就会好很多，目前一般都是使用canvas来渲染2D地图，如果自己实现动画不太方便，也有一些强大的canvas库可以选择，笔者最后使用Konva.js库重做了一版，加入了瓦片淡出动画，最终效果如下： 另外只要搞清楚各个地图的瓦片规则，就能稍加修改支持更多的地图瓦片： 具体实现限于篇幅不再展开，有兴趣的可以阅读本文源码。 本文详细的介绍了一个简单的web地图开发过程，上述实现原理仅是笔者的个人思路，不代表openlayers等框架的原理，因为笔者也是GIS的初学者，所以难免会有问题，或更好的实现，欢迎指出。 完整源码：source","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"},{"name":"canvas","slug":"canvas","permalink":"/tags/canvas/"}]},{"title":"《Vue.js 设计与实现》速读","slug":"《Vue-js-设计与实现》速读","date":"2024-06-21T02:21:16.000Z","updated":"2024-06-21T05:46:30.706Z","comments":true,"path":"2024/06/21/《Vue-js-设计与实现》速读/","link":"","permalink":"/2024/06/21/《Vue-js-设计与实现》速读/","excerpt":"《Vue.js 设计与实现》概要总结","text":"《Vue.js 设计与实现》概要总结 序这是一本没有带你阅读一行源码，却可以让你在阅读完成之后，对 vue 3 所有的核心逻辑 了如指掌 的书籍。 无论是 响应性、调度系统、惰性执行 ，还是 渲染器、diff 算法、编辑器三大步 ，甚至是 有限自动状态机 等所有你能想到知识，本书都可以给你答案。 它就是 尤雨溪亲自做序 ，Vue 官方团队成员：霍春阳 编写的 Vue.js 设计与实现。 前言在当前这个时间段下，关于 vue 3 源码的书籍，主要有两本。 第一本就是，咱们本次要讲的 《Vue.js 设计与实现》。 第二本是，《vue.js 技术内幕》，作者是黄轶。 正巧，两本书我都买来了。 这两本书，虽然都是讲解 vue 3 源码的，但是在讲解的方式上，有非常大的区别。 首先是 《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序），以 提出问题 - 分析思路 - 解决问题 的方式，来讲解 vue 3 的核心设计。其内部，没有读一行 vue3 的源码，但却可以让我们对整个 vue 3 的核心，拥有一个非常清楚的认知。 其次是 《vue.js 技术内幕》：它是一个标准的 “源码分析” 书籍，内部对 vue 3 的很多源码，进行了逐一的解读。 如果大家想要学习 vue 3 的设计思路，掌握框架设计的思维方式。那么我强烈推荐你看一看《Vue.js 设计与实现》。 如果你想要对 vue 源码进行逐一解读，那么可以看一下《vue.js 技术内幕》。 那么明确好了现在市面上学习 vue 3 源码的方式之后，下面就让我们进入到 《Vue.js 设计与实现》的学习中去吧！ 大纲《Vue.js 设计与实现》的内容一共分为 6 篇， 18 个章节： 首先第一篇：对 vue 的整个框架设计，进行了概述 第二篇：主要讲解了 vue 中的响应式系统，除了大家所熟悉的 proxy 之外，额外还包含了：调度系统 scheduler、惰性执行 lazy、ref 的实现原理 第三篇：主要针对 vue 的渲染器（renderer）进行了讲解，额外还包含了 diff 算法的详细讲解 第四篇：是组件化。包含了 组件的渲染机制，以及对 vue 官方组件 KeepAlive、Teleport、Transition 的实现原理，进行了剖析 第五篇：是编译器（compiler）。在这一篇中，把编译器的三大步：parse、transform、generate 进行了分步的讲解。 最后：是服务端渲染。主要是 CSR、SSR 以及 同构渲染。 第一篇：框架设计概览整个第一篇分为三个章节： 权衡的艺术：这里主要涉及到了 vue 框架设计的一些基本概念，也是咱们讲解的重点 框架设计的核心要素：相对比较杂，都是一些零碎的知识点 Vue.js 3 的设计思路：这一章包含了 vue 框架设计的逻辑主线，也非常重要，但是内容并不多 那么首先咱们先来看第一章。 第一章：权衡的艺术在这一章中，开头的一句话，描述了框架设计的精髓，这句话也是尤雨溪在多个开发者大会中经常提到的，那就是：框架的设计，本身就是一种权衡的艺术。 在这一章中，书中分别从三个方面来去分析了所谓权衡的艺术，到底是什么意思。 命令式和声明式首先第一个方面就是：命令式和声明式 的概念。 所谓 命令式 指的就是：关注过程 的范式。 而 声明式 指的就是： 关注结果 的范式。 什么意思呢？我们来举一个小例子： 张三的妈妈，让张三去买酱油。 那么对于张三而言，他就需要：拿钱、出门、下楼、进超市、拿酱油、付钱、回家。 而对于张三的妈妈来说，她完全不需要关心张三做了什么，只需要对张三说一声就可以了。 那么在这个例子中，张三就是一个典型的命令式，他需要完成整件事情的所有过程。 而张三的妈妈，就是典型的声明式，她不关心过程只关心结果。 那么这里大家来想一下，vue 是声明式的？还是命令式的？ 对于 vue 而言，它的内部实现一定是 命令式 的，而我们在使用 vue 的时候，则是通过 声明式 来使用的。 也就是说： vue 封装了命令式的过程，对外暴露出了声明式的结果 性能与可维护性的权衡在明确好了命令式和声明式的概念之后。接下来咱们来看下从 性能 层面，vue 所体现出来的一种权衡的方式。 针对于性能的分析，主要从两个方面去说。 首先第一个方面：大家觉得 是命令式的性能更强，还是声明式的性能更强呢？ 答案是：命令式的性能 &gt; 声明式的性能。 其实原因非常简单，对于 命令式 的代码而言，它直接通过 原生的 JavaScript 进行实现，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 1。 而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 1 + N 的。 那么既然如此，vue 为什么还要对外暴露出声明式的接口呢？ 这其实是因为：声明式的可维护性，要远远大于命令式的可维护性。 大家从这两段代码（命令式和声明式代码）中就可以发现，声明式代码比命令式代码要简单的多。 越简单的代码，可维护性就越强 当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 vue 的性能优化之下，它并不会比纯命令式的性能差太多） 而这样的一种权衡，在 template 模板中，更是体现的淋漓尽致。 在前端领域，想要使用 JavaScript 修改 html 的方式，主要有三种：原生 JavaScript、innerHTML、虚拟 DOM 很多小伙伴都会认为 虚拟 DOM 的性能是最高的，其实不是。 我们来看这个对比。 从这个对比我们可以发现，虚拟 DOM 的性能，并不是最高的。 但是它的 心智负担（书写难度）最小， 从而带来了 可维护性最高。所以哪怕它的性能并不是最高的。vue 依然选择了 虚拟 DOM 来进行了渲染层的构建。 这个也是一种性能与可维护性的权衡。 运行时和编译时第一章的最后一部分，主要讲解的就是 运行时和编译时。 这两个名词，各位小伙伴在日常开发中，应该是经常听到的。 它们两个都是框架设计的一种方式，可单独出现，也可组合使用。 那么下面咱们就分别来介绍一下它们。 首先是 运行时：runtime。 它指的是：利用 render 函数，直接把 虚拟 DOM 转化为 真实 DOM 元素 的一种方式。 在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。 其次是 编译时：compiler： 它指的是：直接把 template 模板中的内容，转化为 真实 DOM 元素。 因为存在编译的过程，所以可以分析用户提供的内容。 同时，没有运行时理论上性能会更好。 目前该方式，有具体的实现库，那就是现在也非常火的 Svelte 但是这里要注意： 它的真实性能，没有办法达到理论数据。 最后是 运行时 + 编译时： 它的过程被分为两步： 先把 template 模板转化为 render 函数。也就是 编译时 再利用 render 函数，把 虚拟 DOM 转化为 真实 DOM。也就是 运行时 两者的结合，可以： 在 编译时，分析用户提供的内容在 运行时，提供足够的灵活性 这也是 vue 的主要实现方式。 第二章：框架设计的核心要素这一章主要讲解了，框架设计时一些凌乱的注意点。 比如： 通过 环境变量 和 TreeShanking 控制打包之后的体积 构建不同的打包产物，以应用不同的场景 提供了 callWithErrorHandling 接口函数，来对错误进行统一处理 源码通过 TypeScript 开发，以保证可维护性。 内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。 这些东西都是基于一个个的小点单独去说的，整体之间并没有一个完成的线性逻辑。 所以大家可以根据具体感兴趣或者不了解的点，单独去看就可以。 第三章：Vue.js 3 的设计思路在这一章中，作者站在一个高层的角度，以 UI 形式、渲染器、组件、编辑器 为逻辑主线进行的讲解。 下面咱们就来捋一捋这条线。 在 Vue 中 UI 形式主要分为两种： 声明式的模板描述 命令式的 render 函数 而针对于 声明式的模板描述 而言，本质上就是咱们常用的 tempalte 模板。它会被 编辑器 编译，得到 渲染函数 render 。 渲染器与渲染函数，并 不是 一个东西。 渲染器是 函数 createRenderer 的返回值，是一个对象。被叫做 renderer。 renderer 对象中有一个方法 render，这个 render ，就是我们常说的渲染函数。 渲染函数接收两个参数 VNode 和 container。 其中 VNode 表示 虚拟 DOM，本质上是一个 JS 对象。container 是一个容器，表示被挂载的位置。而 render 函数的作用，就是： 把 vnode 挂载到 container 上。 同时，因为 Vue 以组件代表最小颗粒度，所以 vue 内部的渲染，本质上是：大量的组件渲染。 而组件本质上是一组 DOM 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 DOM。也就是说，Vue 本质上是： 以组件作为介质，来完成针对于一组、一组的 DOM 渲染。 第一篇总结在整个第一篇中，作者主要就是通过这三章的内容， 自顶向下 的为我们介绍了 vue 的框架设计逻辑。其目的主要就是为了让我们了解， Vue 框架的运行逻辑和一些关键概念。 第二篇：响应式系统第二篇主要是针对 响应式系统 的讲解。 同样也是被分为三章： 首先第一章，也是最重要的一章，就是 响应系统的作用与实现 第二章，主要针对 对象的响应性实现原理 进行了讲解 第三章，主要针对 非对象的响应性实现原理 进行了讲解 第四章：响应系统的作用与实现在这一章中，作者从 响应式数据的概念开始，讲解了响应式系统的实现。 然后针对于 计算属性与 watch 的实现原理，进行了分析。 在分析的过程中，也对其所设计到的 调度系统（scheduler） 和 惰性执行（lazy） 的原理进行了明确。 最后讲解了在 竞态问题下，关于过期的副作用的处理逻辑。 响应式数据那么首先咱们先来看基本概念 副作用函数 与 响应式数据。 所谓 副作用函数 指的是 会产生副作用的函数，这样的函数非常的多。比如 在这段代码中， effect 的触发会导致全局变化 val 发生变化，那么 effect 就可以被叫做副作用函数。而如果 val 这个数据的变化，导致了视图的变化，那么 val 就被叫做 响应式数据。 那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为： 第一个是 getter 行为，也就是 数据读取 第二个是 setter 行为，也就是 数据修改 在 vue 2 中，这样的两个行为通过 Object.defineProperty 进行的实现。 在 vue 3 中，这样的两个行为通过 Proxy 进行的实现。 那么具体的实现逻辑是什么呢？咱们来看下面的图示： 首先是 getter 形式： 在该函数中，存在一个 effect 方法，方法内部触发了 getter 行为。一旦 getter 行为被触发，则把对应的 effect 方法保存到一个 “桶（数据对象）” 中 当触发 setter 行为时： 则会从 “桶” 中取出 effect 方法，并执行。 那么此时因为 obj.text 的值发生了变化，所以 effect 被执行时 document.body.innerText 会被赋上新的值。从而导致视图发生变化。 这是一套构建响应式系统的基础逻辑。这一套逻辑足够应对大家在日常的 面试 或者 工作 中的基本需求。 而这套逻辑说起来简单，做起来还是有一些难度的。 调度系统（scheduler）那么说完了基本的响应性之后，接下来咱们来看 调度系统（scheduler） 所谓调度系统，指的就是 响应性的可调度性。 而所谓的可调度，指的就是 当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式 比如，在这段打印中，决定打印的顺序 而想要实现一个调度系统，则需要依赖 异步：Promise 和 队列：jobQueue 来进行实现。咱们需要 基于 Set 构建出一个基本的队列数组 jobQueue，利用 Promise 的异步特性，来控制执行的顺序 计算属性（computed）当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 计算属性（computed） 的实现了。 计算属性本质上是： 一个属性值，当依赖的响应式数据发生变化时，重新计算 那么它的实现就需要彻底依赖于 调度系统（scheduler） 来进行实现。 惰性执行（lazy）说完计算属性，那么下面我们来看下 watch 监听器。 watch 监听器本质上是 观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数 这也就意味着，watch 很多时候并不需要立刻执行。 那么此时，就需要使用到 惰性执行（lazy） 来进行控制。 惰性执行的实现要比调度系统简单。它本质上 是一个 boolean 型的值，可以被添加到 effect 函数中，用来控制副作用的执行。 123if (!lazy) &#123; // 执行副作用函数&#125; watch 的实现原理基于 调度系统 与 惰性执行，那么就可以实现 watch 监听器了。 过期的副作用watch 监听器的实现非常广泛，有时候我们甚至可以在 watch 中完成一些异步操作。 但是大量的异步操作，极有可能会导致 竞态问题。 所谓的竞态问题，指的是 在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机。比如咱们来看这段代码 这段代码完成的是一个异步操作。 如果 obj 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 data 被赋值为 请求B 的结果。 但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 data 的值就会变为 请求 A 的返回值。 这个咱们的期望是不一样的。 那么这样的问题，就是 竞态问题 而如果想要解决这问题，那么就需要使用到 watch 回调函数的第三个参数 onInvalidate，它本身也是一个回调函数。并且 该回调函数（onInvalidate）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求 而 onInvalidate 的实现原理也非常简单，只需要 在副作用函数（effct）重新执行前，先触发 onInvalidate 即可。 第四章总结那么到这里，咱们就把 响应性系统的大致核心逻辑 明确完成了。从这个逻辑中，我们知道想要实现响应性数据，那么核心就是通过 Proxy 实现。 那么这个 proxy 具体怎么做呢？ 接下来，咱们来看第五章。 第五章：非原始值（对象）的响应性方案书中的第五章整体而言非常简单，主要就介绍了两个接口，Proxy 和 Reflect。 这两个接口通常会一起进行使用，其中： Proxy 可以 代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象） Reflect 可以 在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用 第六章：原始值（非对象）的响应性方案如果大家熟悉 proxy 的话，那么可以知道，针对于 proxy 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。 但是，在 vue 中，我们可以通过 ref 构建简单数据类型的响应。 那么 ref 是如何进行实现的呢？ 这里大家要注意：针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献 在最新的 vue 3.2 代码中，vue 通过 get 、set 函数标记符，让函数以属性调用的形式被触发。这两个修饰符，可以让我们 像调用属性一样，调用方法。 所以当我们平时 访问 ref.value 属性时，本质上是 value() 函数的执行。 第二篇总结那么到这里咱们整个响应式系统的大概流程，就已经描述完成了。其核心逻辑主要就是在第四章中。 至于第五章和第六章，更多的偏向于具体的细节和代码逻辑。 第三篇：渲染器那么下面咱们来看 第三篇：渲染器 。 第三篇一共被分为 5 个章节。但是只讲解了三部分内容。 首先第七章，主要讲解了渲染器的设计。 第八章，主要讲解了 DOM 的挂载和更新的逻辑。 而 第九、十、十一 这三章，主要讲解了 Diff 算法 第七章：渲染器的设计在之前咱们说过 渲染器与渲染函数不是一个东西 渲染器 是 createRenderer 的返回值，是一个对象。 渲染函数 是渲染器对象中的 render 方法 在 vue 3.2.37 的源码内部，createRenderer 函数的具体实现是通过 baseCreateRenderer 进行的。它的代码量非常庞大，涉及到了 2000 多行的代码。 代码量虽多，但是核心思路并不是特别复杂。总体可以被分为两部分： 在浏览器端渲染时，利用 DOM API 完成 DOM 操作：比如，如果渲染 DOM 那么就使用 createElement，如果要删除 DOM 那么就使用 removeChild。 渲染器不能与宿主环境（浏览器）产生强耦合：因为 vue 不光有浏览器渲染，还包括了 服务端 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。 在渲染的过程中，还有一个非常重要的概念 vnode。书中并没有专门的章节来介绍 vnode。所以为了避免各位小伙伴对 vnode 不了解，咱们单独把 vnode 说一下。 所谓 vnode 本身是 一个普通的 JavaScript 对象，代表了渲染的内容。对象中通过 type 表示渲染的 DOM。比如 type === div：则表示 div 标签、type === Framgnet 则表示渲染片段（vue 3 新增）、type === Text 则表示渲染文本节点。 第八章：挂载与更新对于渲染器而言，它做的最核心的事情就是 对节点进行挂载、更新的操作。作者在第八章中，详细的介绍了对应的逻辑。 整个第八章分为两部分来讲解了这个事情： DOM 节点操作 属性节点操作 DOM 节点操作首先先来看 DOM 节点操作。DOM 节点的操作可以分为三部分： 挂载：所谓挂载表示节点的初次渲染。比如，可以直接通过 createElement 方法新建一个 DOM 节点，再利用 parentEl.insertBefore 方法插入节点。 更新：当响应性数据发生变化时，可能会涉及到 DOM 的更新。此时的更新本质上是属于 属性的更新。咱们等到属性节点操作那里再去说。 卸载：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 parentEl.removeChild 进行。 以上三种类型，是 vue 在进行 DOM 操作时的常见逻辑。基本上覆盖了 DOM 操作 90% 以上 的常见场景 属性节点操作看完了 DOM 操作之后，接下来咱们来看属性节点操作。 针对于属性而言，大体可以分为两类： 属性：比如 class、id、value、src… 事件：比如 click、input…. 那么咱们就先来看 非事件的属性部分。 想要了解 vue 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 浏览器中的属性分类。 在浏览器中 DOM 属性其实被分为了两类： 第一类叫做 HTML Attributes：直接定义在 HTML 标签 上的属性，都属于这一类。 第二类叫做 DOM Properties：它是拿到 DOM 对象后定义的属性。咱们接下来主要要说的就是它。 HTML Attributes 的定义相对而言比较简单和直观，但是问题在于 它只能在 html 中进行操作。 而如果想要在 JS 中操作 DOM 属性，就必须要通过 DOM Properties 来进行实现。但是因为 JS 本身特性的问题，会导致某些 DOM Properties 的设置存在特殊性。比如 class、type、value 这三个。 所以为了保证 DOM Properties 的成功设置，那么我们就必须要知道 不同属性的 DOM Properties 定义方式 。 下面咱们来看一下。 DOM Properties 的设置一共被分为两种： el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;) . 属性赋值 ： el.属性名 = 属性值 或者 el[属性名] = 属性值 都属于 .属性赋值 我们来看这段代码： 在这段代码中，我们为 textarea 利用 DOM Properties 的方式设置了三个不同的属性： 首先是 class： class 在属性操作中是一个非常特殊的存在。它有两个名字 class 和 className。如果我们直接通过 el.setAttribute 的话，那么必须要用 class 才可以成功，而如果是通过 . 属性 的形式，那么必须要使用 className 才可以成功。 第二个是 type： type 仅支持 el.setAttribute 的方式，不支持 .属性的方式 第三个是 value：value 不支持直接使用 el.setAttribute 设置，但是支持 .属性 的设置方式 除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。 事件接下来，咱们来看 vue 对事件的处理操作。 事件的处理和属性、DOM 一样，也是分为 添加、删除、更新 三类。 添加：添加比较简单，主要利用 el.addEventListener 进行实现即可。 删除：主要利用 el.removeEventListener 进行处理。 更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。 通常情况下，我们所认知的事件更新应该是 删除旧事件、添加新事件 的过程。但是如果利用 el.addEventListener 和 el.removeEventListener 来完成这件事情，是一件非常消耗性能的事。 那么怎么能够节省性能，同时完成事件的更新呢？ 这时，vue 对事件的更新提出了一个叫做 vei 的概念，这个概念的意思是： 为 addEventListener 回调函数，设置了一个 value 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。 这个代码比较多，大家如果想要查看具体代码的话，可以 在 github 搜索 vue-next-mini，进入到 packages/runtime-dom/src/modules/events.ts 路径下查看。 第九、十、十一章：Diff 算法整个渲染器最后的三个章节全部都用来讲解了 diff 算法。 针对于 diff 而言，它的本质其实就是一个对比的方法，其描述的核心就是： “旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。 目前针对于 vue 3.2.37 的版本来说，整个的 diff 算法被分为 5 步（这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助）： sync from start：自前向后的对比 sync from end：自后向前的对比 common sequence + mount：新节点多于旧节点，需要挂载 common sequence + unmount：旧节点多于新节点，需要卸载 unknown sequence：乱序 而，针对于书中的这三章来说，本质上是按照 简单 diff 算法、双端 diff 算法、快速 diff 算法 的顺序把整个 diff 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。 所以说咱们在当前的这个分享中，肯定是没有办法为大家讲解具体算法逻辑的。 针对于这一块，我同样也是准备了另外的博客。 第三篇总结针对于第三篇渲染器来说，咱们所描述的重点主要是围绕 渲染器的设计 和 DOM 的挂载和更新的逻辑 来去说的。 针对于这两部分而言，大家要明确 渲染器与渲染函数的区别，同时要知道 HTML Attributes 和 DOM Properties 在行为上的差异性。另外关于事件更新的 vei 概念，应该也可以给大家带来一些新的思路。 而针对于 diff，咱们没有放在当前分享中去说，主要还是因为时长不够的原因。但是我为大家准备了额外的博客和视频，大家可以根据自己需要去进行查看。 第四篇：组件化第四篇组件化，它应该算是比较简单的一个篇章，也是分为三部分来去讲解： 组件的实现原理：这是咱们讲解的重心，但是不用担心，它并不复杂。 异步组件与函数式组件：这个比较冷僻，在实际开发中的使用场景有限 内建组件和模块：里面主要讲解了 KeepAlive、Teleport、Transition 这三个内置组件的实现逻辑 第十二章：组件的实现原理想要了解 vue 中组件的实现，那么首先我们需要知道什么是组件。 组件本质上就是一个 JavaScript 对象，比如，以下对象就是一个基本的组件 而对于组件而言，同样需要使用 vnode 来进行表示，当 vnode 的 type 属性是一个 自定义对象 时，那么这个 vnode 就表示组件的 vnode 而组件的渲染，本质上是 组件包含的 DOM 的渲染。 对于组件而言，必然会包含一个 render 渲染函数。如果没有 render 函数，那么 vue 会把 template 模板编译为 render 函数。而组件渲染的内容，其实就是 render 函数返回的 vnode。具体的渲染逻辑，全部都通过渲染器执行。 vue 3 之后提出了 composition API，composition API 包含一个入口函数，也就是 setup 函数。 setup 函数包含两种类型的返回值： 返回一个函数：当 setup 返回一个函数时，那么该函数会被作为 render 函数直接渲染。 返回一个对象：当 setup 返回一个对象时，那么 vue 会直接把该对象的属性，作为 render 渲染时的依赖数据 同时，对于组件来说还有一个 插槽 的概念。插槽的实现并不神奇。插槽本质上 是一段 innerHTML 的内容，在 vnode 中以 children 属性进行呈现。当插槽被渲染时，只需要渲染 children 即可。 对于组件来说，除了咱们常用的 对象组件 之外，vue 还提供了额外的两种组件，也就是 异步组件与函数式组件。 第十三章：异步组件与函数式组件所谓异步组件，指的是： 异步加载的组件 。 比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。 异步组件在 优化页面性能、拆包、服务端下发组件 时，会比较有用。 而对于 函数式组件 来说，相对就比较冷僻了。函数式组件指的是 没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 props 属性 。在实际开发中，并不常见。 第十四章：内建组件和模块这一章中，主要描述了 vue 的三个内置组件。 keepAlive首先第一个是 KeepAlive。 这是我们在日常开发中，非常常用的内置组件。它可以 缓存一个组件，避免该组件不断地销毁和创建。 看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 组件卸载 和 组件挂载 两个方面： 组件卸载：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中 组件挂载：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。 TeleportTeleport 是 vue 3 新增的组件，作用是 将 Teleport 插槽的内容渲染到其他的位置。比如我们可以把 dialog 渲染到 body 根标签之下。 它的实现原理，主要也是分为两部分： 把 Teleport 组件的渲染逻辑，从渲染器中抽离 在指定的位置进行独立渲染 TransitionTransition 是咱们常用的动画组件，作用是 实现动画逻辑。 其核心原理同样被总结为两点： DOM 元素被挂载时，将动效附加到该 DOM 元素上 DOM 元素被卸载时，等在 DOM 元素动效执行完成后，执行卸载 DOM 操作 第四篇总结整个第四篇，主要围绕着组件来去讲。所以内容并不复杂。 对于咱们的日常的开发与面试而言，其实只需要搞清楚 组件的原理 与 内建组件原理 即可。 第五篇：编译器编译器是一个非常复杂的环节。作者主要通过 编辑器核心逻辑、解析器、编译优化 这三个方向进行了说明。 其中对于我们日常开发与面试来说，最核心的就是 第十五章：编译器核心技术概述 。这也是咱们在这一篇中的主要章节。 第十五章：编译器核心技术概述在编译器核心技术概述，主要包含两个核心内容： 模板 DSL 的编译器 Vue 编译流程三大步 模板 DSL 的编译器在任何一个编程语言中，都存在编译器的概念。 vue 的编译器是在 一种领域下，特定语言的编译器 ，那么这种编译器被叫做 DSL 编译器。 而编译器的本质是 通过一段程序，可以把 A 语言翻译成 B 语言。在 vue 中的体现就是 把 tempalte 模板，编译成 render 渲染函数 一个完整的编译器，一个分为 两个阶段、六个流程： 编译前端： 词法分析 语法分析 语义分析 编译后端： 中间代码生成 优化 目标代码生成 而对于 vue 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步 parse：通过 parse 函数，把模板编译成 AST 对象 transform：通过 transform 函数，把 AST 转化为 JavaScript AST generate：通过 generate 函数，把 JavaScript AST 转化为 渲染函数（render） 这三大步中，每一步都包含非常复杂的逻辑实现。 和之前一样，因为篇幅的问题，我们没有办法这里去详细讲解三大步的流程。 我依然为大家提供了 博客版 第十六章：解析器（parse）这一章，主要详细讲解了 parse 解析逻辑。是在三大步中的 parse 逻辑的基础上，进行了一个加强。 所以这里咱们也按下不表 第十七章：编译优化最后就是编译优化。 编译优化也是一个非常大的概念，其核心就是 通过编译的手段提取关键信息，并以此知道生成最优代码的过程。 它的核心优化逻辑，主要是 把节点分为两类： 第一类是 动态节点：也就是会 受数据变化影响 的节点 第二类是 静态节点：也就是 不受数据变化影响 的节点 优化主要的点，就是 动态节点。 优化的方式主要是通过 Block 树 进行优化。 Block 树 本质上就是一个 虚拟节点数对象，内部包含一个 dynamicChildren 属性，用来 收集所有的动态子节点，以达到提取关键点进行优化的目的。 除此之外，还有一些小的优化手段，比如： 静态提升 预字符串化 缓存内联事件处理函数 v-once 指令 … 第五篇总结其实第五篇编译器应该是整本书中，逻辑最复杂的一篇了。内部包含了特别多的代码实现。 但是因为篇幅问题，所以我们没有办法给大家进行详细介绍。只能是把大致的核心流程为大家进行明确。希望大家见谅。 第六篇：服务端渲染最后一篇只有一个章节，就是 同构渲染。 想要了解同构渲染，那么需要先搞明白 CSR、SSR 的概念。 CSR：所谓 CSR 指的是 客户端渲染。 浏览器向服务器发起请求 服务器查询数据库，返回数据 浏览器得到数据，进行页面构建 SSR：表示 服务端渲染 览器向服务器发起请求 服务器查询数据库，根据数据，生成 HTML ，并进行返回 浏览器直接渲染 HTML 两种方式各有利弊，所以同构渲染，指的就是 把 CSR 和 SSR 进行合并。既可以单独 CSR ，也可以单独 SSR，同时还可以 结合两者，在首次渲染时，通过 SSR，在非首次渲染时，通过 CSR。 以下是三者的对比图 而针对 vue 的服务端渲染来说，它是 将虚拟 DOM 渲染为 HTML 字符串，本质上是 解析的 vnode 对象，然后进行的 html 的字符串拼接 最后又讲解了客户端激活的原理，大致分为两步： 为页面中的 DOM 元素与虚拟节点对象之间建立联系 为页面中的 DOM 元素添加事件绑定 这两步主要是通过 renderer.hydrate() 方法进行实现了。 总结 那么到这里，整个 《Vue.js 设计与实现》就已经全部说完了。 整本书中，涉及到的内容是非常全面的，就像咱们开头所说的一样，它是一个 从高层的设计角度，来探讨框架需要关注的问题。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"日语-N2文法","slug":"日语-N2文法","date":"2024-06-11T03:11:15.000Z","updated":"2024-06-11T05:22:08.066Z","comments":true,"path":"2024/06/11/日语-N2文法/","link":"","permalink":"/2024/06/11/日语-N2文法/","excerpt":"日语学习之N2文法","text":"日语学习之N2文法 単元第１７課文法～ぬきで／～ぬきにして 本意是去除的意思，引申义是不是，不必，不需要，不的意思 堅苦しいあいさつはぬきにして思い切り飲みましょう。 これはお世辞抜きで面白いですよ。 ～（よう）とする／としている 打算做/正要做，马上快要 犯人は警察に捕まりそうになって，銃で自殺しょうとした。 复习：すると 一……就……，紧接着前项事情发生后项事情 据说的几种表达方式 ～といわれています（第3课）通常认为 ～そうです （第4课） ～とのことです （第5课） ～ということです （第5课） ～とまで（さえ）いわれている （第17课）夸张的据说，极端情况下使用 蘇州は美しい街だ，東洋のベニスとさえいわれている。 第１8課文法在……的时候，期间 時 表示时间 小さい時 間 表示时间和空间 皆が寝ている間に，～ 東京と大阪の間に，～ ところ 表示状态 忙しいところですが，～ うち 在……当中，在……期间，趁着（年轻等） ～うちに 等同于～間に，表示在这个期间一定发生了动作 母が外出しているうちに（間に），掃除をして部屋をピカピカにしよう。 ～うちは 表示在这个期间没有变化 体が健康なうちは，妻と二人でのんびり暮らしたい。 折，節，際 和時一样，属于美化语 假定形＋幸いです／恐縮です 对方这么做我会很高兴/我这么做的化给对方添麻烦 後日こちらからお電話いたしますので，その折にご都合をお聞かせいただければ幸いです。 お忙しい中恐縮ですが，ご連絡いただければ幸いです。 AをBにした／とした 以A作为B的一部分/全部 弊社では，「金星」をベースにした新感覚のカクテルもごよういしています。 この服は「エコロジー」をコンセプトとした素材でできています。 なお／また／さらに 另外，还有第１９課文法ます形＋次第＋～ 一……就…… わかり次第ご連絡を差し上げます。 準備ができ次第，ご案内いたします。 复习：～たら，すぐに，～と ます形＋つつある 表示动作正在逐渐变化或朝着一个方向发展 中国国内の物価が上がりつつある。 复习：一方，ばかりだ，の一途をたどる，いく ～と評判だ 得到很高的评价 都内の浄水場で処理した水をボトルに詰めて販売していて，味も美味しいと評判だ。 ～に伴って～ 随着~，表示伴随着某个重大事件连带发生了另外的事件 冷戦の終結に伴って，経済関係の重要性が強調されるようになってきた。 都市の緑化に伴って，駅周辺に花や木が増えってきた。 复习：～とともに ～のもと（で） 表示在……之下，之中。本意是表示位置靠下的部位 国連の旗のもと，各国が協力して紛争の平和的な解決を目指している。 マイナス３０度吹雪という悪天候のものでも，観測作業は継続された。 一方 一边，一边，表示并列同时经行 彼は大学で哲学を教える一方，大工として働いている。 复习：一方也有朝着趋势一直发展的意思 第２０課文法～だらけ 满是，沾满了，很多 ここのところ，失敗だらけなんです。 間違いだらけの答案を採点する。 ~と思ったら，～ 刚一……就……，动作刚一发生，就发生了意外的事情 電車は発車したと思ったら大きな音を出して急停車した。 その学生は，就職したと思ったらさっさと辞めてしまった。 ～というより/～というよりむしろ 比起这样说……还不如……/与其说是……不如说…… 正直に言えば，喜んで引き受けたというより思わず頷いたという形だった。 この料理は，中華料理というよりむしろ日本料理というほうが適切だ。 ばかり ～たばかりです 主观上觉得事情刚刚完成 彼は3月に大学を卒業したばかりです。 ～ばかり～ 全是，尽是，光是 最近，変な夢ばかり見る。 ～てはばかりいる 消极的事情反复发生 彼はよく遅れてばかりいる。 ～ばかりではなく 不仅……而且…… その地方は寒いばかりではなく，乾燥しているため，農業には向いていない。 ～ばかりだ 朝着一个不好的方向不断发展 病気はどんどん悪くなるばかりだ。 ～ほど 表示程度很高 李さんは日本人と間違わるほど，日本語が上手だ。 その日は，部屋のコップの水さえ凍るほどの寒さだった。 Aを境にB 以A作为分水岭有了B这样的变化 1970年代を境に，日本は高齢化社会になったといわれる。 単元第２１課文法～分 与之相对应的，与另一部分做对比 急いだ分，仕上がりはよくない。 食べたら食べた分，運動をしないと，太ってしまいます。 ～ずつ 在进行反复进行的动作时，每次动作实现需要的数量或分量 3人ずつ部屋に入ってください。 機械が壊れないように，電流を少しずつ流します。 わけ ～わけだ 自然而然的 田中さんは大学を卒業して3年だから，今年25歳になるというわけだ。 ～わけがない 没有道理 食べる後にお金を上げないわけがない。 ～わけではない 并不是，不应该，不能 皆がルールを守らないから，自分も守らなくていいというわけではない。 ～わけにはいかない 不能（没有道理的） ここであきらめいるわけにはいきません。 必ずしも～ない 未必，表示部分否定，不强烈的否定 学校で学んだことが必ずしも生活に役に立つわけではない。 王さんの言うことが必ずしも正しいとは限らない。 ～を始め 以……代表（为首） 中国，日本，韓国を始めとするアジアの国々にとって経済的な協力関係は重要だ。 ～に至るまで 意思和まで一样，多用于列举极端的事物 この店には，日常使うもの，歯ブラシやせっけんはもちろん，整髪料に至るまでそろっている。 ～といっても過言ではない 即使这么说也不过分 私は本が好きだ。本を読まない日はないといっても過言ではない。 現在，中国の経済が世界経済の動向を決めるといっても言い過ぎではない。 第２２課文法ます形＋ながら／つつ 同时进行的动作，强调后面的动作 彼は食べながらテレビを見る。 私は，今，お茶を飲みつつ手紙を書いています。 虽然……但是……，表示转折 彼は大学生でありながら，喫茶店を経営している。 何かしなければならないと思いつつ，時間が過ぎてしまった。 まま 照旧，一如原样 ～たまま／～のまま 理应改变却没有改变 ～ままに 表示顺从该动作或意志和～どおり有一样的意思 お客様のご希望のままに，シェフが調理します。 あなたが望むままに生きていきなさい。 ～なしで／～抜きで 在不具备本来该有的某种东西的状态下做某事 準備なしで発表をしたら，失敗した。 相談抜きで面白い。 ～に加え（て） 不仅……而且…… 前回の勝利に加えて，今回も大差で勝った。 ～たびに 每当……就会…… 海絵来るたびに，子供のころ溺れたことを思い出す。 卒業式のたびに校長先生は泣きながらあいさつをします。 拓展：～といつも／～時はいつも／～ごとに 意思和～たびに一样 次第 一……就…… ～次第で 随着……，取决于…… この裁判では，あなたの証言次第で，被告は有罪になります。 今回の旅行でどこへ行くかは，予算次第です。 第２３課文法～だからこそ 正因为，こそ在这里起到了强调的作用 偶然ではなく，~努力したからこそ教員試験に合格したんだ。 从……到…… ～から～まで 具有连续性的准确范围 3時から3時15分まで休憩します。 ～から～にかけて 断断续续，大致范围 城を持たない水上都市として，明から清にかけて大きく発展した。 ～にわたって 时间长，跨度大，范围大 10年にわたって研究開発によって，ようやく新しい農薬が完成した。 时间＋を通して 表示整个时间范围 今週一週間を通して湿度が高く，蒸し暑い日が続くでしょう。 ～ことがない 不会出现这样的情况 その美しさはみ飽きることがない。 ～ことはない 没必要，用不着 ここまで来て，今さえ，やめることはない。 第２４課文法ます形＋がち 往往会，容易会，表示消极的事项 一般の視聴者にとって，CMは迷惑なものと考えられがちだ。 それは，小さい子にありがちな自己中心的な考え方です。 ～以上（は）～／～からには～ 既然……就……（建议，义务，表决心） 応援する以上は最後まで応援したほうがいい。 視聴者が，企業の広告ではなく番組のためにテレビを見る以上，広告主の企業や放送局と視聴者の利害は常に対立することになる。 ます形／一类形容词去い＋がる 想做，觉得，用于第三人称 恥ずかしがってばかりいないで，自分から発言してはどうですか。 その子供はジュースを食べたがっている。 単元第２５課文法～ついに 终于，表示花费时间或经过艰苦努力终于完成某事 あの二人は7年交際して，ついに婚約した。 やっと 侧重于期待的事情终于实现了 あの二人は7年交際して，やっよ婚約した。 よく 经常 陳さんは東京によく遊びに行きます。 程度 李さん，その洋服よく似合いますね。 意外或感叹 それにしても，よく会場を押さえられましたよね 以よくも的形式表示惊讶或憎恶 裏切っておきながら，彼はよくも私たちの前に姿を見せられたものだ。 ます形＋きる 表示动作或事情彻底完成，用于动作或事情实现起来有困难时 3人分の料理を1人で食べきった。 中国をはじめとしたアジアの国々，ヨーロッパやアメリカ，中東，ロシアなどにも，数えきれないほどの日本食レストランがある。 类似的表达还有ます形＋通す 不放弃，不会改变想法，把某一动作坚持做到最后 演奏家は途中で間違えたが，最後までその曲を弾き通した。 ～に応じた（接名词）／～に応じて（接动词） 根据/适应~，书面语 賃金は働きに応じて支払われる。 外国で売られている寿司は，文化の違いに応じた「創作料理」になっていることが多い。 ～から見ると／～から見ても／～から見れば 从……来看，从某种立场上审视，考虑问题。 日本人から見ると，寿司だとは思えないものもたくさんある。 私から見て，佐藤さんは素晴らしい上司だ。 ～に即した／～に即して 按照……/根据…… 食べ物はその国の状況に即して変化するものなのだ。 現状に即して考えると，政府の予測は楽観的過ぎる。 ぬ，ず 都是古日语用于表示未然形 江戸前ならぬ，アメリカ前，ニュージーランド前の寿司をその土地のスタイルで楽しむのもよいのではないだろうか。 第２６課文法～だけあって 真不愧是……，一般和さすが连用 さすが上海一の高級ホテルだけあって，素晴らしい会場ですね。 ～だけに 正是由于…… 今回のテストは簡単だっただけに，クラスの平均点は高かった。 古日语表示未然形 复习：ず（三类动词せず），ぬ ざる ない形＋ざるをえない／～しかない 不得不……，只好…… 約束だから，明日までにやらざるをえません。 期限が迫っているので，決めざるを得ません。 パソコンがフリーズしたので，プログラムを終了するしかありません。 ～にもかかわらず 尽管……/虽然…… 何度も注意したにもかかわらず，娘はまた友達の悪口を言っている。 李さんは頭が痛いにもかかわらず，寝ないで仕事を続けた。 ～どころか 从根本上否定，用于消极事项，类似はもちろん 忙しくて，昼ご飯どころか，朝ご飯も食べていない。 このところ支出が多くて，貯金するどころか，借金が増えてしまった。 ます形＋かねる／かねない 难以实现/不好的事情很容易很可能实现 このままだと，プロジェクトは中止になりかねない。 第２７課文法Aなしには／では／て＋B 没有A是不可能完成B的 今回の成功は，彼らの協力なしにはありえなかったと思います。 お金もなしに，会社を成立することは不可能だ。 ます形＋える／うる 也表示为动词的可能态 この状態は，予想しえない事態だ。 字典形＋まい ～ないだろう 表示否定推测，难道不是…… この勝負の勝敗はすでに決まっていたのではあるまいか。 ～しないつもりだ 表示否定的意志 こんな所にはもう二度と来るまい。 ～ずにはいられない 忍不住要……做 部屋が汚れていると，片づけずにはいられない。 その映画を見たら，泣かずにはいられない。 ～のみならず 不仅…… 中国のみならず，日本でも張一心は人気がある。 复习：和～ばかりでなく，～だけではなく意思一样 ちなみに～ 顺便一提，附带，补充说明 玉袁譚公園では，日本から寄贈された桜を見ることができる。ちなみに，北京の桜は東京よりも3週間ほど開花が遅いそうだ。 第２８課文法～もんです 表示理由的ものです ここ数日忙しかったもんで，なかなかお電話できず申し訳ありませんでした。 ついでに 做某事同时又在做着其他事情 散歩に出たついでに，コンビニで買い物をして帰った。 だったらいいんです／ならいいんです 那就好 コンテストは大成功のうちに終わりました。 だったらいいんです。 ～だけには～ 唯独对…… 健康だけには自信があったのに。 Aに反してB 与A相反的B 予想に反して，来場者は1万人を超えた。 そてらとは別に 另一方面，与～一方有相同的意思 彼は英会話学校で動いています。しかし，それらとは別に芸術家として活動しています。 単元第２９課文法～までもない 没必要 今さら言うまでもありません，すべて皆さんのおかげです。 ～ぶり／～っぷり ……的样子 彼の歩きぶりから見せと，どうも足にけがをしているようだ。 佐藤さんはいつも食べっぷりがいい。 复习：时间＋ぶり表示时间间隔 たった 仅仅经常和だけ连用 たった1年で，これだけ業績を上げたんですから。 ～に決まっている 一定是……，绝对是……，肯定是…… 今から会社に帰っても，もう誰もいないにきまっている。 AうえでB／AたうえでB 为了A，在此之前先做B/先做A，然后做B 外国に住むうえで，一番気を付けなければならないことは何ですか。 多額の資金を集めたうえで，会長に立候補した。 そう～ではない 并不是…… 日本語はそう難しくないと思います。 ～とはいうものの 虽然这么说，尽管 とはいうものの，宇宙に持っていける食べ物には，いくつかの条件がある。 このはかりはデザインが斬新なものの，実用的ではない。 ～にすら 尽然，连 そのことは，田中さんすら知らなかった。 疲れ切って，食事すらできない。 ～にあたって 在……之际 海外に赴任するにあたって，いろいろな準備をしなければなりませんでした。 第３０課文法Aに先立ってB 在A之前先做B动作 トレーニングの開始に先立ち，細かいスケジュールを立てた。 Aを通してB 表示方法手段，通过A做B动作 妻とは，私と妻の共通の友人を通して知り合いました。 复习：时间段+を通して 表示整个时间段 ～できなくはない 不是不能 その映画は原作を読まなくても理解できなくはないですが，よく分からないと思うころがたくさんあると思います。 ～にしたがって／～につれて 随着……，按照…… 年を取るにしたがって，一日が短く感じられるのはなぜだろう。 太陽が沈むにしたがって，辺りは暗くなった。 ～にすぎない 不过如此，没什么大不了的 私はあくまで彼の代理で会議に出席したにすぎない。 ～に位置している 位于，处于……位置 フランスはドイツの西に位置しています。 ～にほかならない 正因为是…… 落第の原因は，勉強不足にほかならない。 ～としても，～ 即使……也…… 両親が反対したとしても，私は留学します。 明日は忙しいので，そちらに伺えるとしても遅くなってしまうと思います。 第３１課文法～くせに 明明……却…… 俺より2年後輩のくせに，すごいじゃないか。 私の息子は，学校で答えが分からないくせに，いつも手を挙げているそうだ。 （动词原形/形容词去い＋くある/名词和形动＋である）＋べき 表示第三人称的应该…… とにかく，先に栄転を受けるべきだよ。 すべての人は平等であるべきだ。 地球の自然はいつまでも美しくあるべきだ。 ～もんか／～ものか 不…… こうなったら，もう心配なんてするもんか。 助けてやると言ったのに断るなんて，もう絶対に助けてやるものか。 ～てやる 说话人给予对方利益，恩惠。 今日は俺がおごってやるよ。 娘に四捨五入の方法を教えてやる。 ～とすると／～とすれば／～となると／～としたら 如果…… 公衆の面前でスピーチするとなると，緊張してしまいます。 ～がなされる／～をする 古日语的用法，书面语 今回の研究会では活溌な議論がなされる。 第３２課文法～どころではない 顾不上……，不是做……的时候 父は正月だというのに出かけるどころではなく，家で遅くまで仕事をしている。 ～なりに 站在……立场上 大阪で，僕なりに考えました。 あの子もあの子なりに意見があるのでしょうから，怒らないでまず話を聞いてあげてください。 ～でしかない 不过是…… 貯金しているといっても，まだ１０万円でしかない。 言葉というのはコミュニケーションをするための道具でしかない。 ～恐れがある／～かねない（有依据时可以使用） 恐怕会……，很有可能……发生不好的事情 台風が本州に上達する恐れがある。 あんな運転の仕方では，衝突事故でも起こしかねない。 ～のみ 和だけ一样的意思，书面语 この商品は，予約している方のみ購入することができます。 ～に至る 到……为止，书面语 現在では1000羽以上が確認されるに至っている。 結婚に至るまで，二人の間にはいろんなことがありました。 AかたわらB 表示A和B同时进行，A是主要动作，B是次要动作 山本さんはコーチのかたわら，審判としても活躍している。 ～に終わる（失敗，不調） 以不顺利的情况结束 今回の世界大会で，日本チームは実力が出せずに不調に終わった。 ～をもって 以……分水岭，从……起，到……为止 私は，3月31日をもって，会社を退職することにいたしました。 ～に際して 在……之际，……的时候，书面语 本ホームページのご利用に際しては，以かの点にご注意ください。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"日语","slug":"日语","permalink":"/tags/日语/"}]},{"title":"日语-N3文法","slug":"日语-N3文法","date":"2024-06-11T03:10:55.000Z","updated":"2024-06-11T05:20:24.688Z","comments":true,"path":"2024/06/11/日语-N3文法/","link":"","permalink":"/2024/06/11/日语-N3文法/","excerpt":"日语学习之N3文法","text":"日语学习之N3文法 単元第１課文法～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词 接续：动词简体，形容词，形容动词+ な ……左右，大约……，可以和ほど替换 12345例：家から学校まで一時間ぐらいかかる。译：从家到学校大概要花1个小时左右。例：どのぐらい日本語を勉強していますか。译：大概学了多久日语呢？ 表示动作或状态的程度，可以和ほど替换 12345例：飛ぶほど嬉しい。译：高兴地飞起。例：今日は忙しくて、食事する時間もないくらいだ。译：今天太忙了以至于我连吃饭的时间都没有。 表示最低程度，至少 12345例：いくら忙しくても、電話ぐらいはできるでしょう。译：例：自分の事ぐらいは自分でやります。译： 没有比……更……，可以和ほど替换 12345例：朱さんぐらい可愛い人はいない。译：例：戦争ぐらい残酷なものはない。译： とは/というのは 所谓的~ 用于下定义和解释说明 12例：JRとは、Japan Railwaysの略です。译：JR是Japan Railways的简写。 ……是因为…… 前者是因为后者导致的，这时只能用～というのは～のだ 12例：彼は怒ったというのは、きっと酷い事を言われたのでしょう。译：他生气的原因一定是被说了很过分的话吧？ ～というものは/ということは 用于说明该事物的本质特征 ～というものは 用于名词 12例：人間というものは一人で生きていくことはできません。译：人类是一个人无法生存下去的吧。 ～ということは 用于动词，也可以用于对事情原因的推测 12345例：一人で生活するということは、大変なことですね。译：一个人生活真是不容易呀。例：彼は怒ったということは、きっと酷い事を言われたのでしょう。译：他生气的原因一定是被说了很过分的话吧？ ～ということは/つまり、～ということだ 也就是说…… 12例：明日から会社へ来なくてもいい、つまり君はクビだということだ。译：明天就不用来公司上班了，也就是说你被解雇了。 ～はもちろん/はもとより 自不必说12345例：最近は仕事が忙しくて、土曜日はもちろん、日曜日も休めない。译：最近工作太忙了，星期六就不用说了，星期天也没法休息了。例：主要都市を結ぶ路線はもちろん、世界で初めて実用化されたリニアモーターカーも国営です。译：连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。 课文日本には，JR，鉄道，公営の３種類の鉄道会社があります。JRとは，Japan Railwaysの略です。以前は国営の鉄道でしたが，１９８７年に民営化されました。世界的に有名な新幹線もJRの路線の１つで，日本の主要な都市と都市を結んでいます。最高時速は３００キロを超えます。最初に完成したのは東海道新幹線ですが，山陽新幹線，東北新幹線，九州新幹線など，路線がどんどん延びています。 中国の鉄道は，ほとんど国営です。主要都市を結ぶ路線はもちろん，世界で初めて実用化されたリニアモーターも国営です。 在日本有JR、铁路、公营三种类型的铁路公司。JR是Japan Railways的简称。以前是属于国有铁路，1987年民营化了。世界有名的新干线就是JR的其中一条线路，把日本主要城市与城市之间连接起来。最高时速超过300公里。最初完成的是东海道新干线、山阳新干线以及九州新干线等等，渐渐的线路不断延伸。 中国的铁路基本都是国营的。连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。 第２課文法～ものです。 表示对事物的性质或变化的感慨或吃惊，经常与よく一起使用 12例：一人でよく返って来られたものですね。译：竟然能一个人回来呀。 AはBものです，A本质上具有B的性质、B是理所应当的事情 12345例：人の心は分からないものです。（本质）译：人心是最难懂的。例：約束の時間に遅れる時は，相手に連絡するものです。（理所应当）译：在约定的时间迟到了的话，应该和对方联系。 口语中经常使用～て来接续，书面语中使用ます形来接续12例：深いお辞儀をし，相手の名刺をお辞儀をしながら受け取ります。译：深深地鞠躬，一边鞠躬一边接受对方的名片。 简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！12例：名刺を出す時も受け取る時も，両手を使うほうが丁寧です。译：名片递出和接收的时候，用双手是更加礼貌的。 いくら～ても～ 无论……也……12例：この店ではいくら食べても，１０００円です。译：这家店不管吃多少，只要1000日元。 课文仕事で初対面の人にあった時は，名刺を出します。名刺の出し方と受け取り方にも決まりがあります。相手が目上の時は，まず自分から名刺をだして深いお辞儀をし，次に相手の名刺をお辞儀をしながら受け取ります。出す時も受け取る時も，両手を使うほうが丁寧です。 また，話内容にも気をつけなけれならなりません。初対面の時は，個人的なことを聞かないのが普通です。特に仕事の場で出合った相手には，個人的な質問を避けたほうがいいでしょう。結婚しているかどうか，給料はいくらか，年齢はいくつかなどもは，普通は聞きません。 工作场合下和对方第一次见面时，要递出名片。名片的递出和接收方法都是有规定的。对方是上级的时候，首先自己首先递出名片并深鞠躬，接着边鞠躬边接收对方的名片。名片递出和接收的时候，用双手是更加礼貌的。 另外聊天的内容也要注意。第一次见面时，个人相关的事情一般不要询问。特别是工作场合遇到对方，最好避免个人问题。结婚了没，工资多少，年龄多大了等问题一般不要询问。 第３課文法～を含めて＋数量词 包括~在内的+「数量词」12例：今回の『金星』プロジェクトは，私を含めて４名のスタッフが担当いたします。译：这次金星项目包括我一共四人负责。 拓展：～ほか＋数量词 除开……还有+「数量词」…… 12例：今回のプロジェクトの担当者は，主任の李秀麗ほか３名のスタッフです。译：这次的项目负责人除了李秀丽以外还有3人。 ～にとって 对……来说，表示从某人立场上来说，用于表明立场12例：私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。译：对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。 拓展： ～として，有和当事人有同一向想法的时候使用 12例：困っている人を助けるのは，人間として当然のことです。译：帮助有困难的人，作为人来说是应当的。 ～としては，站在客观立场上，强调自己的立场 12例：私としては，その案に反対です。译：我个人是反对这个方案的。 ～にしたら・～してみれば・～にすれば 有希望对方理解的感觉 12例：大人には簡単でも，子供にしたら難しいでしょう。译：对大人来说简单，可对小孩子就困难的很。 ～が，～けど 表示转折或者铺垫下文的说法12345例：すみませんが，今話してもいいでしょう。译：打扰一下，现在方便说话吗？例：李さんも日本語も上手ですけど，王さんも上手ですね。译：李桑日语说的很好，王桑也说的很好呀。 ～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱12345例：名字をつけないわけにはにいきません。译：不取名字是不行的。例：質問がたくさんあっても，無視するわけにもいかないので，きちんと答えています。译：即使问题有很多，也不能无视它，要好好地回答。 ～といわれています 据说，通常认为，表示非说话人主观判断，而是一种普遍的常识12例：日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。译：日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。 会话 佐藤：よろしくお願いします。李さんも日本語が上手ですけど，王さんも上手です。 王：ありがとうございます。出身は浙江省の紹興ですが，大学時代，日本に留学していたんです。ですから，今回のプロジェクトに大変興味があります。 佐藤：紹興ですか，１０年前に，一度だけ行ったことがあります。 王：そうでうか。 佐藤：ええ。私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。 12345佐藤：请多关照。李桑日语说的很好，王桑也说的很好呀。王：谢谢夸奖。出生于浙江绍兴，大学地时候，去日本留学过。所以对这次地项目非常地有兴趣。佐藤：绍兴吗，10年前，去过一次呀。王：是吗？佐藤：是的呢。对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。 课文しかし，名字をつけないわけにはいきません。そこで，多くの人が，地名や地形から名字をつけましら。日本の名字に，『木』，『林』，『山』，『川』など自然に関係する名字が多いのは，そのためです。家が谷の中にあるから『中谷』，近くに大きな杉の木があるから『大杉』とつけられた名字もたくさんあります。日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。 但是不取名字是不行的。所以大多数人的名字是来源于地名或地形。因此日本的名字中，『木』，『林』，『山』，『川』等等和自然有关的名字很多。家住在山谷中就叫『中谷』，附近有巨大的杉树就叫『大杉』这样的名字也有很多。日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。 第４課文法信息的转述 简体＋そうです 转述他人信息 12例：李さんは明日会社を休むそうです。译：李桑明天休假。 听说传闻 12例：彼女はもうすぐ結婚するそうです。译：她好像马上要结婚了。 样态，似乎、好像、看起来 12例：この葡萄が美味しそうです。译：这个葡萄看起来很好吃的样子。 ～とのことです、～ということです 听说，据说 12345例：このダムには３メートルくらいの魚がいるということです。译：听说这个水坝有3米长的鱼。例：山田さんがよろしくとのことです。译：听说山田人很好。 ～といってもいました 记得说过，或者用于确认对方说的话 12例：青木主任がちょっとお話しをしたいと言っていました。译：青木主任想和你说几句话。 简体＋って 与家人、朋友等亲密的人表示传闻，可以替换～と，～とは，～という人は 12例：明日は雨だって。译：明天有雨。 思ったより 超出预想水平或范围12例：思ったより大変な仕事になりそうなんです。译：工作变得超乎想象的辛苦呢。 拓展：予想以上に/想像以上に 比より更加正式程度也更强一些 12345例：今月の給料は予想以上に少なくて，がっかりしました。译：这个月的工资比预想的少多了，很失望。例：上海の変化は想像以上に速いですね。译：上海的变化比预想的还要快呀。 ～といえば 说道~ 用于把名词作为话题提出，对话题进行说明12例：かつて，日本のサラリーマンといえば，朝早く家を出て家に帰るのは深夜になり，残業や休日出勤をするのは当たり前でした。译：以前说到日本的上班族，很早出门深夜回家，加班和周末上班是理所应当的。 このように 综上所述12例：このように，日本のサラリーマンの働き方は，かつてに比べると大きく変化しています。译：综上所述，日本的上班族的工作方式对比之前有了很大变化。 会话 青木：お忙しいところすみません。実は，上海支社で進めている『金星』プロジェクトが，思ったより大変な仕事になりそうなんです。 山田：そうですか。 青木：それで，東京本社でも『金星』プロジェクトの担当者を決めることになりました。突然ですが，山田さん，この仕事をしてもらえませんか。 山田：私が『金星』プロジェクトの担当者に？ 青木：はい。上海支社の李さんからの要望なんです。 山田：李さんが，私を推薦してくれたんですか。 青木：ええ。山田さんは上海支社に行ったこともあるし，中国の事情に詳しいからということでした。 山田：分かりました。中国と関係のある仕事なら，ぜひやってみたいと思います。 12345678青木：这忙还打扰你。实际上上海分公司正在推进的金星项目，变得比预想还要麻烦呢。山田：是这样吗？青木：所以，东京总公司决定了金星项目的负责人。虽然有些突然，山田桑，这份工作你愿意接受吗？山田：我担任金星项目的负责人吗？青木：是的。上海分公司的李桑推荐的。山田：李桑推荐的我吗？青木：是的呢。山田桑去过上海分公司，对中国的事情也很了解。山田：我知道了。和中国有关系的工作，请一定要让我试试。 课文さらに，フレックスタイム制度を導入する会社も増えています。これは，自分の出勤と退勤の時間を自由に決められる制度です。労働者が自分の生活と仕事のバランスを取りながら，働くことができるように設けられました。 另外，引入弹性时间制度的公司也增加了不少。这是项可以自己自由决定上班和下班时间的制度。这个是为劳动者既能平衡自己的生活和工作，也能工作所设计的。 単元第５課文法转换话题1234567ところで 话说回来話しが変わりますが 说点别的さて 那么それで 然后けれども/でも 不过/但是それでは/では 那么（转换下一个话题）それはそうと 先不说这个 ～を～にして 以……为…… ～をきっかけにして 以……为契机 12例：コンテストで最高賞を受賞したのをきっかけにして，売れるようになりました。译：再一次竞赛后得到最高奖为契机，变得开始畅销。 ～を手がかりにして 以……为线索 12例：犯人が残したナイフを手がかりにして，事件を解決した。译：以犯人留下的小刀为线索，将事件解决了。 ～を頼りにして 根据…… 12例：李さんが書いてくれた地図を頼りにして，美術館を探した。译：我根据李桑画的地图找到了美术馆。 ～ということからきた～/～に由来した～ 由此而来的，源于12345例：相撲でぐらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。译：相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。例：『天ぷら』はボルトガル語の”tempera”に由来した言葉です。译：『天妇罗』的由来时葡萄牙语的“tempera”一词。 ～のは間違いない 一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用12例：中国の体操選手がオリンピックで優勝するのは間違いない。译：中国的体操选手一定会在奥林匹克上获胜。 拓展：～に違いない/～に相違ない（书面） 能和 きっと 多分 这样的词语一起使用 12345例：このガイドブックは内容が豊富で面白い。きっと売れるに違いない。译：这本指南的内容丰富有趣。一定买的很好。例：彼は十分な休みを取っていなかったに相違ない。译：他一定没有得到充分的休息。 ～という点から/で 从……方面来 という点から分類する 从……方面来分类 12例：日本語の単語を，元の言葉は何かという点から分類すると，……译：日语的单词是以它原来的语言是什么这一点来分类的。 という点から判断する 从……方面来判断 12例：いろいろな証拠という点から判断するんですが，彼は犯人です。译：各种各样的证据判断出，他是犯人。 という点で 依据……性质来判断 12例：遅くまで開いているという点で，あの店は便利です。译：营业到很晚这一点来看，那家店很便利。 ～を中心とした～ 以……为中心12例：外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉だ。译：外来语主要是19世纪以后，以西洋为中心的外国引进的语言。 AをBという/呼ぶ（书面） 把A叫做B12例：さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。译：另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。 名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……12345例：東京のような大都市では，家賃が高くて大変だ。译：像东京这样的大城市，房租太高了太不容易了。例：鳥が飛ぶように空を飛んでみたい。译：想像鸟一样在空中飞行。 拓展： ～という/いったよう＋な/に 列举多个例子时使用，いった有没有列举完的语气，といったような可以省略为といった 12345例：エビ，イカ，卵といったようなコレステロの高い食品は避けた穂がいい。译：避免高胆固醇食物，如虾、鱿鱼和鸡蛋。例：テレビ，冷蔵庫，布団というように，一人暮らしで必要な物を買った。译：我买了一个人生活必需的东西，比如电视、冰箱和被褥。 ～というふうな/に 用于列举多个具体事例，陈述处理办法或顺序，略显口语 12例：北京，上海，広州というふうに，中国の大きな都市を順番に訪問した。译：我们依次参观了中国的大城市，如北京、上海和广州。 ～に受ける 受欢迎12例：『金星』という名前は，中国人にうけるでしょう。译：金星这个名字，中国人会喜欢吧？ ～に基づいた～ 以……为根据12例：音読みとは，昔の中国語の発音に基づいた読み方だ。译：音读是指以以前中文的发音为根据的读法。 ~うち 在……当中12345例：若いうち译：趁着年轻例：参加者のうち，賞品がもらえるのは３位までだ。译：参加人中，能得到奖品的只有三位。 会话 佐藤：ええ，『金星』は星の名前ですが，『金星』というのは，『すばらしい働きをすること』を表します。相撲でくらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。 1佐藤：『金星』是指星星的名字，这里的金星是指，有着出色工作表现的意思。相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。 课文日本の単語を，元の言葉は何かという点から分類すると，和語，漢語，外来語，混種語の４つに分かることができる。和語はもともと日本語にあった言葉で，漢語は中国から取り入れられた言葉だ。漢語は『音読み』する。音読みとは，昔の中国の発音に基いた読み方だ。外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉で，普通片仮名でかく。さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。『消しゴム』や『マラソン大会』『正月休み』などの言葉だ。 日语的单词是以它原来的语言是什么这一点来分类的。可以分为和语、汉语、外来语、混合语四种。和语是最早日语就有的语言，汉语是从中国引入的语言。汉语是音读。所谓的音读是指以以前中文的发音为根据的读法。外来语主要是19世纪以后，以西洋为中心的外国引进的语言，用普通片假名书写。另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。诸如“橡皮擦”、“马拉松比赛”和“新年假期”之类的词。 第６課文法～ちゃって/～じゃって 是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。12345食べてしまう ー＞ 食べちゃう ー＞ 食べちゃって飲んでしまう ー＞ 飲んでじゃう ー＞ 飲んでじゃって例：打ち合わせが長引いちゃって。译：会议拖了很长时间。 気になる 一直想着…… 对某人有意思12例：そんなことを聞くということは，佐藤さん，李さんのことが気になるのかしら。译：听到这样的话，佐藤桑，你是不是对李桑有意思呀。 ～による/よって 根据……12例：『はし』といっても，その形や材料は国や地域によって違う。译：虽说都是筷子，它的形态和材料会因为国家和地区而不同。 簡体＋といっても 虽说……12例：英語できないといっても，日常会話は十分にできる。译：虽说英语不行，但是日常对话应该够了。 簡体／名詞の＋ほか，～も 除了……之外，也……12例：材料は木や竹，プラスチックのほか，玉や金属の物もある。译：材料是木头或竹子，除了塑料以外，也有玉和金属的。 ～をしている 状态的表示方法12例：韓国の箸は中国より少し短く，やや平らな形をしている。译：韩国的筷子比中国的短了一些，也要扁平一些。 ～とされる 和 と考えられている 意思一样：被认为是……12例：日本では２月１４日のバレンタインデーは，女性が男性にチョコレートを贈る日だとされる。译：在日本2月14日情人节被认为是女性向男性赠送巧克力的日子。 面倒を見る 照顾12例：部下の面倒をよくみるし。译：很照顾自己的下属。 会话 中井さん：うん。明るくて，仕事熱心な人だっていったよ。部下の面倒をよく見るし，優しいし，まさに理想的な上司です。 1中井桑：是的。人很开朗，对工作也很热心的人呢。对下属也很照顾，人也温柔，简直是理想的上司呢。 课文『はし』といっても，その形や材料は国や地域によって違う。中国の箸は長くて，先端が丸太さがあまり変わらない。材料は木や竹，プラスチックのほか，玉や金属の物もある。韓国の箸は中国より少し短く，やや平らな形をしている。ステンレスなど，金属の物が一般的だ。日本の箸は韓国の物に比べてさらに短く，先のほうは細くなっていて，尖っている。材質は木や竹が多く，漆が塗られていることがある。 虽说都是筷子，它的形态和材料会因为国家和地区而不同。中国的筷子比较长，筷子前端的圆度没怎么变化。材料是木头或竹子，除了塑料以外，也有玉和金属的。韩国的筷子比中国的短了一些，也要扁平一些。一般是不锈钢之类的金属。日本的筷子相比韩国要短一些，前者很细很尖。材质大多数是木头或竹子，也有在表面涂漆的。 第７課文法簡体＋参考にする/参考になる 把……作为参考/有参考价值12345例：『燕醸造のCMを参考にする』と書いてあるけど，これはどいう意味？译：上面写着『燕牌啤酒的广告有参考价值』，这是什么意思呢？例：このCMは，きっと参考になるだろうと思います。译：这个广告一定有参考价值。 名詞の＋うえで 这……方面12例：ただし，仕事のうえでのメールや目上の人に送る場合は，いくつか気をつけなければならないことがある。译：然而工作上的邮件和发送给上级的场合下，有一些必须注意事项。 名词+さえ～ば，～ 只要……就……12例：お金と時間さえあれば，毎日演劇を見に行きたい。译：只要有钱和时间，每天都想去剧院。 ～などという 这……之类的12例：『こんにちは』『はじめまして』などという，メールの内容の分からない表現は避ける。译：邮件内容要避免『你好』『初次见面』之类的无法理解内容的表达方式。 ～ごとに 表示每隔……（间隔）12例：１年ごとに，売り上げの目標作って，営業活動を頑張った。译：每年都会指定销售目标，努力开展营业活动。 课文件名を描く時は，用件を明確にする 宛て先と自分の名前を忘れずに入れる 用件は簡潔にする 最後に署名を入れる 描述主题时，用词要明确不要忘记写收件人和自己的名字用词要简洁最后要署上你的名字 第８課文法だけ 仅仅 だけで 少量的事情或者事物就能引发后项结果 12例：ちょっと見ただけで，本物だとわかります。译：仅仅只是看了一眼，就知道是真的。 だけだ／だけではない 仅此/不仅 12345例：そのだけです。译：仅此而已。例：中井さんは事件あった場所を知っているだけだ。译：田中桑仅仅只是知道发生时间的场所。 だけではすまない／だけですむ 仅仅这样是不行的 12例：課長に報告したら，注意されるだけではさまない。译：向课长报告的话，仅仅是注意是不行的。 ～代わりに／～かわって／～に代わる ……被代替……1234567891011例：相手は丼を使う代わりに紙コップを使い，その中に砕いたインスタントラーメンを入れる，お湯を注いで，食べ始めた。译：对方使用纸杯代替碗，在纸杯中放入碎的方便面，再放入开水，就可以开始吃了。例：手紙の代わりに電子メールをうちます。译：发送电子邮件代替信件。例：父に代わって長男がご挨拶に伺います。译：长子代替父亲前来问候。例：丼に代わる新しい容器が必要だ。译：使用新容器代替是有必要的。 ～（ら）れるようにしなければいけない 努力做到12例：免許証はいつでも見せられるようにしなければいけない。译：驾照无论何时都需要能看到。 ～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果12345例：何度も失敗した末に，ようやく開発に成功した。译：经历无数次失败，最终成功开发出来。例：苦労したあげく，結局失敗した。译：辛苦的工作到最后还是失败了。 会話 王：はい。商品のPRだけじゃなくて，日本の文化を紹介するコーナーを作ってはどうかと考えています。日本の食べ物とか若者の意識とかを紹介するのも面白いとおもいます。 1王：是的。这不仅是商品的提案，我想做一个介绍日本文化的栏目。介绍日本的饮食什么的，年轻人的想法什么的都很有趣。 课文しかし，開発は簡単ではなかった。容器の材料は，ガラス，紙，プラスチック，金属，当時考えられるだけの物が集められた。様々な工夫のすえ，『発泡スチロール』が採用された。容器の形についても試作が繰り返された。片手を持てて，手から滑り落ちない形を理想として，現在の形が生まれた。 然而，开发不是这么简单的。容器的材料有不锈钢、纸、塑料、金属，这些都是当时能想到的汇聚起来的东西。通过各种各样的方式方法，最终采用了泡沫塑料。关于容器的形状也多次尝试制作。以单手就能拿起，不容易从手中滑落为理想，诞生了现在的形状。 単元第９課文法自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态12345例：「王風」という名札が付けてあります。译：上面挂有【王风】名字的牌子。例：玄関の電気がつけてあります。译：玄关的灯开着。 他动词 + ている 自然状态持续着12345例：窓が開けています。译：窗户开着。例：窓が開けてあります。译：窗户打开着。 自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。12345例：ファイルは机の上に置いておきます。译：我把文件反正桌子上。例：朝起きられるように、時計を6時にセットしておく。译：为了能早起，我定了6点的闹钟。 名词 + どおり 与～一样；按照～那样；预想；预计12345例：予定通り17時30分に到着いたしましたが…译：和预计的一样17点30分到达了……例：田中さんは、希望通り大学院に進学しました。译：田中如愿升入研究生院。 後ほど；後（のち）で；あとで 前者更有礼貌12345例：後ほど，お泊まりのホテルに届けいたします。译：稍后送到您住宿的酒店。例：詳細については後ほどご報告いたします。译：详细情况稍后汇报给您。 另外还有 先ほど 会话 王さん：ちょっと，いたい，いつまでも待ってばいいんですか。もう６時半ですよ。 手荷物係：申し訳ございません。ただ今お調べしております。もう少しお待ちいただけませんか。 王さん：そんな，困りますよ。ロビーで同僚が待っているんです。早くしてもらえませんか。 手荷物係：本当に申し訳ございません。後ほど，お泊まりのホテルに届けいたします。よろしいでしょうか。 王さん：仕方ないですね。できるだけ早く届けてくださいよ。 1234567王桑：喂，究竟要让我等到多久才好呀？已经6点半了呀！行李员：真的十分抱歉！但是现在还在调查中，请在稍等一下可以吗？王桑：怎么会这样，太麻烦了。前厅还有同事在等着我。能尽快找到还给我吗？行李员：真的非常抱歉，稍后送到您住宿的酒店，这样您觉得可以吗？王桑：只好这样了。快点送过来呀！ 课文4月1日17時20分，憧れのローマに到着。荷物を受け取って，入国。旅行社の人が迎えに来ているはずだが，見つからない。もし来なかったらと思い，不安になった時，背の高い男性が，にこにこしながら近付いてきて何か言う。誰かと思ったら，我々を迎えに来たガイドさんだった。 4月1日17点20分，憧憬的罗马到了。取到了托运的行李，入国。因该有旅行社的人来接我们，但是没有看见。正在想着如果没有来的话怎么办，感到不安的时候，有个背高高的男性笑眯眯的走过来说着什么。我正在想着这是谁，原来是来迎接我们的导游。 第１０課文法よう（更为正式）／ように 目的，为了……12345例：できるだけたくさんの取材ができるよう予定を立てました。译：为了尽可能多的采访，我们定了这样的行程。例：早く病気がなおるよう、安静にしていた。译：为了病能早点好，静养了一段时间。 ～による／よって被动中提示动作的主体.12例：このレストランは，有名なデザイナーによって設計された。译：这个饭店是有名的设计师设计的。 根据，依据12例：林さんが行くかどうかによって，私もどうするかきめます。译：小林去不去决定了我怎么完成。 方式，方法12例：この薬の効果は，多くの実験によって確認されている。译：这个药的效果是经过了多次实验才确认的。 ～になります 代替です／だ，语气更加的含蓄，委婉。12例：お１人様１６０００円になりますが，よろしいですか。译：一个人16000日元，您觉得可以吗？ 课文温泉地では，お客を集めるための工夫をしている。例えば，宿泊する人以外がホテルや旅館の入浴施設を有料で使用できる「日帰り温泉」がある。「入浴＋昼ご飯」や，「入浴＋部屋で休憩」など，宿泊する時間のない人のためにさまざまなプランもある。最近では「日帰り入浴」専用の施設も増えてきている。 また銭湯といって，安い値段で入浴できる施設もある。銭湯とは，多くの家にお風呂がなかったころに作られた入浴施設のことだ。現在ではその数も少なくなってきているが，最近では，「スーパー銭湯」が出てきて人気を集めている。普通の銭湯より値段は高いが，いろいろな種類のお風呂やマッサージ，エステなどがあり，1日中たのしめる。「スーパー銭湯」は忙しい人たちのちょっとした癒しの場になっているのだ。 泡温泉的地方为了能揽客下了很大的功夫。比如，有住宿以外的人可以通过付费使用旅馆的入浴设施【日归温泉】。还有【温泉+晚饭】和【温泉+房间休息】等等，没有住宿时间的人也有各种各样的方案。最近【日归温泉】专用设置也增加了许多。 另外还有钱汤，价格实惠的洗浴设施也有。所谓钱汤是指，以前许多家里没有可以泡温泉的地方，而建立的公用洗浴设施。现在这样的设施在慢慢减少，最近出现了很有人气的超级钱汤。比普通的钱汤价格稍微贵一点，但是有各种各样的种类，洗浴，按摩以及美容，可以享受一整天。超级钱汤正在成为给那些忙碌人难得消除身心疲惫的场所。 第１１課文法避免断定的说法 难道不是吗？ 12345678910111213书面语：ではないかではないだろうかではないでしょうか。口语：ではありませんかではないですかじゃありませんかじゃないですかじゃないか ～きがする 好像，对过去的某事尽管记忆模糊，但是认为是那样 12例：その時は，賛成した気がします。译：那个时候我好像是赞成的。 ～と思う／～と思える／～と思われる 认为，～と思える／～と思われる 有自然而然地这样认为，而非专断的意见 12345例：彼女の言っていることは事実だと思う。译：我觉得她说的话是事实。例：私はこの方針が正しいと思えません。译：我不觉得这个方针是正确的。 ～はずです 应该是……，基于推论或记忆认为理所应当成立的事情12例：彼は今年定年のはずです。译：他今年应该退休了。 ～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。12345例：あの雲の様子から見て，明日は雨のようだ。译：从那个云的样子来看，明天可能要下雨。例：天気予報によると，今年の冬は暖かいらしい。译：天气预报说今年冬天可能会比较暖和。 ～のところ ……的时刻，有包含这个的后续可能会发生某种变化的语气12例：興行成績は現在のところ第２位ですが，来週はトップになる見込みです。译：票房成绩目前还是第二名，但下周有可能登顶。 ～見込みです 很可能，有希望的意思12例：来年の業績はかなり良い見込みです。译：明年的业已有希望相当好。 形容词去掉い＋まる（自动词：变得）／める（他动词：使……） 古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语12345例：そうそう，日本映画の人気も高まっていますよ。译：是的呢，日本电影的人气也变得很高。例：社員一人一人の節約の意識を，もう少し高めないといけない。译：必须提高每个社员的节约意识。 ～に夢中になる 被什么东西吸引而聚精会神投入其中的状态12例：昔の子供は学校が終われると，外で遊ぶに夢中になったものです。译：以前的小孩放学后，会沉迷在外面玩。 知识拓展 夢中になって 专心致志 12例：日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。译：来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。 夢中で/夢中だ 拼命的做 12345例：田中さんは今日仕事に夢中だから，しばらく結婚はしないでしょう。译：看田中桑今天拼命的工作，最近一段时间应该不会结婚吧？例：大きな犬に追いかけられて，夢中で逃げだ。译：被大型犬着，拼命地逃跑。 ～うえに，～ 不仅……而且……12例：今日は気温が低いうえに，風が強いので，とても寒く感じる。译：今天不仅气温低风也很大，感觉非常冷啊。 ～とともに，～ 随着前向的变化，后向也因此伴随着变化，也有同时进行的意思12345例：その後，デジタル技術の開発が進むとともに，高画質のいきいきとした映像が生み出されるようになった。译：之后，随着数字技术的开发，产生了高画质的生动影像。例：原因を調査するとともに，再発を防ぐための努力もしていかなければならない。译：随着原因的调查，为了防止再次发生而不得不努力。 会話 担当者：ええ，若者は日本のものと外国のものを区別していないような気がします。彼らは，映画にしても音楽にしても，いいものならすぐに受け入れます。 王：そうですね。中国の若者も同じだという気がします。じゃあ，彼らの心をつかむには，どうすればいいんでしょうか。 担当者：うーん…，難しい質問ですね。やはり本当にいいものを作ることではないでしょうか。 王：本当にいいもの，ですか？ 担当者：ええ。今の若者は，テレビCMより，同時代の人の口コミを信じます。映像でも音楽でも，本当にいいものを提供すれば，口コミで広がっていくはずです。 王：なるほど。ありがとうございます。とても参考になりました。 12345678担当者：是的，我觉得年轻人好像没有区分日本的东西和外国的东西。他们不管是电影还是音乐，只要是觉得好的马上就会接受。王：是这样呢，中国的年轻人好像也是这样。那么怎么做才能抓住他们的心呢？担当者：嗯，很难得问题呀。果然还是要真正做出好的东西对吧？王：真的好的东西，是吗？担当者：是的。现今的年轻人比起电视频道更相信同龄人的口碑。不管是电影还是音乐，提供真正好的东西的话，口碑应该也会越来越好。王：原来如此，谢谢。非常有参考价值。 课文日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。日本の漫画は，子供向けから成人向けまで，対象の年代ごとにさまざまな種類がある。 会社員の生活や，経済に関するものなど，大人にしか楽しめない内容の漫画が多くある。一方，子供向けの漫画でも，大人が楽しめるものも多い。近年，中国では「クレヨンしんちゃん」「ドラえもん」「ちびまる子ちゃん」などの漫画が子供だけでなく大人からも人気を集めている。 来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。日本的漫画从孩子到成人，会因为看漫画对象的年代不同有着各种各样的分类。 公司职员的生活或者经济相关的漫画等等，有很多精彩的内容只有大人才能看的漫画有很多。另一方面，也有很多小孩子和大人都能看得的漫画。近几年，在中国像【蜡笔小新】、【哆啦A梦】【樱桃小丸子】等等这样的漫画不仅小孩子喜欢，也很受大人们的欢迎。 第１２課文法耳にする／目にする 表示没主动去看听，而是被动传入 最も大阪の方言が聞けると思っていたんですが，あまり耳にしませんでした。 携帯電話の普及で，最近公衆電話を目にしなくなりました。 ～せい／せいで／せいか 事情的原因，原因不明确时用せいか 風邪を引いているせいか，今日は仕事に集中できない。 計画が失敗したのは，私のせいだ。 ～おかけで／～おかけか 多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか 林さんのおかけで，助かりました。 薬を飲んだおかけか，1日で熱が下がりました。 ～です／だけれど，～ 虽然……，但是……，意思和が，だけ一样的但是更有礼貌 せっかくですけれど，今日は遠慮しておきます。 ～においても 对于，在……方面，就……而言 日本語においても，発音，文法，語彙など，地域による言葉の違いがある。 ～ことになる 也就是说，变得……会这样 参加者は男性３名，女性２名，５名ということになる。 课文中国は多民族国家で，民族によって使用する言語が異なっている。また中国語も一つではなく，かなりの数の方言が存在する。それぞれの方言は発音も文法も語彙も大きく違っている。 日本語においても，発音，文法，語彙など，地域による言葉の違いがある。 まず，発音やアクセントの違いがある。例えば，「はし」という言葉だ。「箸」の「はし」，「橋」の「はし」。ほかにも異なった意味があるが，この二つの意味で考えてみよう。 方言の違いによってこんな誤解が起きることもある。例えば，東北地方に「なげる」という方言がある。これは「捨てる」という意味だが，方言を知らない人が「これをなげす」と言われて，「投げる」だと解釈して，ごみを投げ返して怒られたという話がある。また，関西地方には「ほかす」という方言がある。やはり「捨てる」という意味が，これを「保管して」と聞き間違えて，要らないものを大切に保管してしまったという話もある。 単元第１３課文法折り入って～ 诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫 折り入ってお話したいのですが，今よろしいでしょうか。 もしかして／もしかすると・もしかしたら 该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句 もしかして，上海の李さんも来るの？ ～ことになりました 决定要…… 有受到多种因素的影响后才做出的决定，自然的变成这样的 王さんが結婚式に出席してくれことになりました。 来年の春に結婚することになりました。 朝着一个方向不断发展，有～ていく的感觉 ～一方だ 世界の人口は増加する一方が，日本の人口は減り始めている。 前后主语一样时表示同时做某事，可用于接续 彼は事故の原因を調べる一方，被害の拡大を防いだ。 前后主语不一样时表示对比，也可以用于接续 出生率が下がる一方，平均寿命どんどん長くなっています。 ～ばかりだ 全是，尽是，光是 最近，変な夢ばかり見る。 彼は週末になると博物館ばかり行っている 朝着一个不好的方向不断发展 病気はどんどん悪くなるばかりだ。 の一途をたどる 书面语 出生率は減少の一途をたどっている。 AのBにはCがある AのB的原因之一有C 事故の原因には整備不良がある。 「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。 Aに対する 对于A的……（态度，感情，动作），也有对比的意思 政府に対する国民の批判が高まっている。 地球温暖化に対して取り組みは国によってさまざまだ。 兄はおとなしく内向的なのに対して，弟はとても活発で外向的だ。 课文「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。例えば，結婚年齢が遅くなる「晩婚化」の傾向は，年々強まっている。結婚時の女性の平均年齢は，1977年には25.0歳であったが，1992年には26.0歳，2004年には27.8歳になった。 高年齢になると出産を控える傾向が強まり，一人の女性が出産する子供の数を示す「出生率」が下がる。それが少子化の原因に繋がっている。 第１４課文法～を問わず 不论……，书面语 男女を問わず，黒か濃い紺色，灰色の地味なスーツを指す。 ～て初めて～ 只有……才能…… これらの試験をとっばして初めて内定をもらうことになる 。 #### 少しでも～ 尽可能早的…… 少しでもいい席を取れるように，会場の前に朝早くから多くの人が並んでいる。 课文面接は話す場であり，文を読む場ではない。志望動機や自己PRなど，履歴書に書いたものをそのまま話すのはよくない。 会社の建物に入り，出るまでが採用試験である。受付での話し方や待合室での態度なども評価の対象になる。 面接でははじめの印象が大切である。清潔のあるきちんとした服装をすること。 第１５課文法ちっとも／少しも／全然／真く＋～ない 一点也不 学生の頃と，ちっとも変わってないわね。 課長は少しも部下の意見を聞いてくれない。 昨日の夜のことは全然覚えてない。 山田さんと町子さんが結婚することを真く知らなかった。 それはそうと 先不说那个，转换话题 今回は仕事で日本に来たんでしょう。 決して～ない 绝对不是这样，绝对不这样做 彼は決して嘘はつきません 誰にも決してを分からない場所にお金を隠した。 课文日本の料理には，面白い名前のものがある。例えば，「親子丼」というのは，鶏肉と卵を調理してご飯にのせた料理である。鶏肉と卵は親と子であることからついた名前だ。ほなに，「他人丼」という料理もある。豚肉や牛肉と卵を調理してご飯に載せた料理である。豚肉と卵は「親子」ではなく「他人」だからである。 では，「キツネうどん」というのはどんな料理だろうか。決して狐の肉が入ったうどんではない。うどんの上に，「油揚げ」という，豆腐を油揚げた物を載せた料理だ。油揚げの色がキツネのような色だからとか，油揚げがキツネの好物だから，という理由でこんな名前が付けられたという。 第１６課文法～ともに 一起做……和一緒に一样的意思 今までともに助け合って，頑張ってきた。 ～とも 全部，都 私たち姉妹は５人とも元気です。 ～からといって～とは限らない／ない 虽然说……但也不一定/不 日本人だからといって，日本の文化に詳しいとは限らない。 森さんは，お酒を飲まないからといってお酒が嫌いではない。 会話中国には「白头偕老」という言葉があります。これは「ともに白髪になるまで一緒にいる」いう意味の言葉です。お二人とも，きっとこの言葉通りの幸せな夫婦になられるでしょう。 课文キリスト教式で結婚式を上げるからといって，キリスト教の信者であるとは限らない。ウエディングドレスが着たいからとか，教会で挙式したいからなど，自分の好みで挙式のスタイルを決める人が多く，宗教で決める人は少数である。ほてるや結婚式場には，挙式の場所が設けられているので，実際に神社や教会へ行く人の数は少ない。さらに，海外で挙式をする人も多くなっている。 下のグラフは，ある出版社が首都圏の夫婦４００組に対して行ったアンケートの結果を求めたものである。これを見ると，挙式の形式が時代とともに変わってきていることが分かる。１９９４年には「キリスト教式結婚式」が56.6%，「人前結婚式」が5.4%であったのに対して，２００５年では，それぞれ74.4%，12.6%に増えた。一方，伝統的な挙式形式である「神前結婚式」は，２００５年には１９９４年の３分の１まで減少した。このように，結婚式に対する人々の意識は，時代にとともに変化してきている。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"日语","slug":"日语","permalink":"/tags/日语/"}]},{"title":"日语-(简敬)语","slug":"日语-简敬-语","date":"2024-06-11T03:10:38.000Z","updated":"2024-06-11T05:18:08.534Z","comments":true,"path":"2024/06/11/日语-简敬-语/","link":"","permalink":"/2024/06/11/日语-简敬-语/","excerpt":"日语学习之(简敬)语","text":"日语学习之(简敬)语 简体变形规则名词和形容动词1234567一般陈述句：だ，である一般否定：ではない、じゃない过去时：だった过去否定：ではなかった、じゃなかった 形容词1234567一般陈述句：寒い一般否定：寒くない过去时：寒かった过去否定：寒くなかった 动词1234567一般陈述句：字典形一般否定：ない形过去时：た形过去否定：なかった 活用形终止形 终止形即终止句子的形式当名词和形容动词后面有か时可以省略だ 1234567动词简体形容词简体形容动词＋だ名词＋だ 连体形 用于修饰名词, 所以连体形没有名词的变形 12345动词简体形容词简体形容动词＋な 连用形123I形: ます形II形: て形, た形 文法简体可以修饰名词12例：私は四川語を話すことができます。译：我会说四川话。 简体＋といいます 引用别人说的话 直接引用 12例：寝る前に、『おやしみ』といいます。译：睡觉之前一般会说“晚安”。 间接引用 12例：ミーラさんは『来週東京へ出張する』といいます。译：米勒说下周要去东京出差。 动词和形容词简体/形容动词な/名词の＋とき 在……时候，动词简体过去式表示动作之后的情况12345678例：暇なとき、遊びに来ましょうか。译：闲暇的时候，来玩吧！例：国へ帰るとき译：回国途中时……例：国へ帰ったとき译：回国后…… 字典形＋と…… 一怎么样12例：右へ曲がると郵便局があります。译：一右转就到邮局了。 简体/名词な＋んですか 寻求更详细的说明 12例：どうして遅れたんですか。译：为什么迟到了呢？ 提起话题 12例：NHKを見学したいんですが、どうしたらいいですか。译：我想去NHK参观学习，怎做么才好呢？ 终止形＋し＋终止形＋し＋终止形＋「から」 并列 12例：ワット先生は熱心だし真面目だし、経験もあります。译：瓦特老师既热心又认真，而且非常有经验。 列举理由，表示轻微的因果关系，暗示还有其他理由 12例：駅から近いし、車でも来られるし、この店はとても便利です。译：离车站又近，坐车也能来，这家店真是便利呀。 动词字典形/动词ない形＋つもりです 下决心打算做某事12345例：国へ帰っても柔道を続けるつもりです。译：即使回国也打算继续柔道。例：明日からは煙草を吸わないつもりです。译：打算从明天开始不再吸烟了。 动词字典形/名词の＋予定です 预计，预定的计划12345例：７月の終わりにドイツへ出張する予定です。译：预计7月完去德国出差。例：旅行は１週間ぐらいの予定です。译：预计旅行一周左右。 动词た形/ない形ない＋ほうがいいです。 最好做… 用于给别人提供建议和忠告12例：毎日運動したほうがいいです。译：最好每天运动。 终止形＋でしょう 表示说话人的推测12345例：明日は雨が降るでしょう。译：明天要下雨吧？例：楊さんは合格するでしょうか。译：杨同学及格了吧？ 终止形＋かもしれません 可能，或许，可以简写为かも12例：約束の時間に合わないかもしれません。译：可能会错过了约定的时间。 字典形/た形＋とおりに、～ 按照……做……12345例：私はやるとおりに、やってください。译：请跟着我做。例：みたとおりに、話してください。译：请按照所看到的那样说。 拓展：～らしい 推测，传闻，……的样子 12345例：あそこにいる人は男らしい。译：那人像是个男的。例：彼はとても男らしい。译：她非常像一名男性。 ます形/名词の＋とおりに、～ 正如，按照12例：説明書のとおりに、組み立てました。译：我按照说明书组装好了。 た形/名词の＋あとで ……之后…… （する前に、した後で）12例：仕事のあとで、飲みに行きませんか。译：下班后要去喝一杯吗？ 可能态字典形/ない形ない＋ように、～ 为了……而…… 前方必须是非意志类词语，前后主语可以不一致12345678例：早く泳げるように、毎日練習しています。译：为了早点学会游泳，每天都在练习。例：忘れないように、メモしてください。译：为了不忘记，记了笔记。例：老人にも読めるように、新聞の字を大きくする。译：为了让老人也能阅读，放大了报纸上的字。 字典形/名词の＋ために、～ 为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿12例：自分の店を持つために、貯金しています。译： 可能态字典形/ない形なく＋ように、なります 变得……12345例：毎日練習すれば、泳げように、なります。译：例：太りましたから、好きな服が着られなくように、なりました。译： 字典形/ない形ない＋ように、します 努力（尽可能）做或不做……12345例：毎日運動して、何でも食べるように、しています。译：例：もっと野菜を食べるように、してください。（更有礼貌）译： 疑问词＋终止形＋か、～12345例：結婚のお祝いは何がいいか、話しています。译：例：私たちが初めて会ったのはいつか、覚えていますか。译： 终止形（名词不加だ）＋かどうか、～12345例：その話は本堂かどうか、わかりません。译：例：まちがいがないかどうか、調べてください。译： 名词/形容词去い/形容动词＋がる 有……的感觉, 感觉……12345例：嬉しがる译：例：好きがる译： 名词に/形容词去い加く/形容动词に＋します 使……变成…… 名词に还有选择和决定的意思1234567891011例：音を大きくします。译：例：部屋を綺麗にします。译：例：会議は明日にします。译：例：部屋はシングルにしますか、ツインにしますか。译： 连体形/名词の＋場合は、～ 如果……就……(后面一般接对策或导致的结果)12345例：会議に間に合わない場合は、連絡してください。译：例：時間に遅れた場合は、会場に入れません。译： 连体形/名词な＋のに、～ 明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。12345例：約束をしたのに、彼女はきませんでした。译：例：約束をしたのに、どうして来なかったですか。译： 动词字典形/～ている/~た＋ところです 即将/正在/刚刚做了（5-10分钟的事情）12345678例：会議は今から始まるところです。译：例：今私は勉強しているところです。译：例：たった今バスがでたところです译： 动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです 应该会，确信的推断。12例：くるはずですよ译： 简体＋そうです 据说，传闻。12345例：天気予報によると、明日はさむくなるそうです。译：例：クララさんは子どもの時、フランスに住んでいたそうです译： 动词字典形/形容词/形容动词な/名词の＋ようです 好像，感官感受到的好像12例：渡辺さんはこのごろはやくかえりますから、どうも恋人ができたようですね。译： ～がします。 有……的感受1234567891011例：おと（こえ）がします译：例：あじがします译：例：においがします译：例：～顔がします 有~样的表情译： 敬语礼貌体です普通形态：～です。过去形态：～でした。否定形态：～では（じゃ）ありません。过去否定形态：～では（じゃ）ありませんでした。 ます普通形态：～ます。过去形态：～ました。否定形态：～ません。过去否定形态：～ませんでした。 尊他语被动形表达尊敬 課長はもう帰られました。 お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～ ～ください 请…… お待ちください。 ～になる 社長はもうお帰りになりました。 特殊动词的敬语变形 いらっしゃる ー＞ いらっしゃいます ー＞ いる、来る、行く 召し上がります ー＞ 食べる、飲む おっしゃる ー＞ おっしゃいます ー＞ 言う というと ー＞ とおっしゃいますと なさる ー＞ なさいます ー＞ する ご覧になります ー＞ 見る ご覧ください ―＞ 見てください ご存じです ー＞ 知っています くださる ー＞ くださいます ー＞ くれる ます形＋まして 用于敬语中使前后敬语一致，使礼貌程度一致 ハンスが昨夜ねつをだしまして、今朝もまだ下がらないんです。 お＋形容词 お忙しい 今日はお忙しいようですから，また明後日伺います。 お詳しい 御社が中国国内の酒類販売ルートにお詳しいことを，MTS社の聞くより伺いました。 自谦语お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～ ～＋する／いたします／できる 今月のスケジュールはお送りします。 はい，ご用意できます。 ～＋申し上げる・申し上げます 同する一样的意思，但是敬意程度更高 よろしくご検討くださいますようお願い申し上げます。 お＋动词て型＋しております ～ています 的自谦语 只今お調べしております。 お呼び出ししております。 特殊动词的敬语变形 差し上げります ー＞ 上げる いただきます ー＞ もらう，食べる，飲む 参ります ー＞ 行く、来る おります ー＞ いる 申します ー＞ 言う いたします ー＞ する 拝見します ー＞ 見る 伺います ー＞ 聞く、いる 存じます ー＞ 思う，知る ことと存じます ー＞ と思います お目にかかります ー＞ 会う お目にかけります ー＞ 見せる 私 ー＞ わたくし 私たち ー＞ わたくしども お～しております ー＞ ～ています、お～します 使役态表达自谦 常用组合形式为～＋させていただきます 検討させていただきます 礼貌语 お手洗い ー＞ 洗手间 ございます ー＞ ある でございます ー＞ です よろしい ー＞ いい より ―＞ から にて ―＞ で ～におかれましては／～には ―＞ ～は 书函中表达敬意的写法","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"日语","slug":"日语","permalink":"/tags/日语/"}]},{"title":"日语-(形助副)词","slug":"日语-形助副-词","date":"2024-06-11T03:10:19.000Z","updated":"2024-06-11T03:28:17.307Z","comments":true,"path":"2024/06/11/日语-形助副-词/","link":"","permalink":"/2024/06/11/日语-形助副-词/","excerpt":"日语学习之(形助副)词","text":"日语学习之(形助副)词 形容词1. 修饰名词~い + 名词 12例：優しい人译：温柔的人 2. 名词化形容词（去い） + さ 12例：部長は頭の痛さを我慢して出張した。译：部长忍着头痛出差去了。 3. 修饰动词形容词（去い） + く 12例：浅く笑う译：浅笑 4. 句中接续12例：彼女は美しくて優しいです。译：她美丽温柔。 形容动词1. 修饰名词形容动词 + な + 名词 12例：綺麗な景色译：美丽的风景 2. 名词化形容动词 + さ 12例：あの店は家に近いので、便利さは一番です。译：那个商店离家很近，非常方便呀。 3. 修饰动词形容动词 + に 12例：簡単にしました译：轻易地完成了 4. 句中接续12例：この町は綺麗で静かです。译：这坐小镇真是美丽安静呀。 助词助词是日语中的一大特色，它是日语语言中的黏着剂，串连起一个个完整的句子和含义。 常用助词1. を 提示宾语 全員が無事であることをお祈りします。 祈祷大家都没事。 表示经过的场所 猫は塀の上を走っていった。 小猫从在墙上跑走了。 动作的出发点，起点 彼は文房具を売る6階でエレベーターを降りた。 他在买文具的6楼下了电梯。 2. に 动作作用的对象 親に黙って、会社を辞めてしまった。 瞒着父母辞掉了工作。 动作变化的结果 温度がマイナスになると、水が氷になります。 温度到达零度以下水就会结冰。 事物存在的场所 その言葉にうそは少しもなかった。 那些话里一点谎言也没有。 动作的着落点 道に倒れている人を助けました。 救助了倒在道路上的人。 表示目的 スーパーへ買い物に行きます。 去超市买东西。 3. が 固定搭配，前接表示感觉的词表示感觉 さっき隣の部屋で人の話し声がしました。 我刚才听到隔壁有人说话的声音。 接在自动词前面 新しくて白い建物が見えるでしょう。あれが王さんの家です。 能看到那座又新又白的建筑吧，那就是小王的家。 表示转折或铺垫 ちょっとお願いがあるんですが… 予定どおり１７時３０分に到着いたしましたが… 4. で 表示交通工具手段 バスで学校へ行きます。 坐公交去学校。 表示动作发生的场所 運動場で走ります。 在运动场上跑步。 表示原因 地震でビルが倒れた。 地震把大楼震倒了。 表示范围 クラスの中で李さんが一番かっこいいです。 班里小李最帅。 表示限定 明日いっぱいで仕事を終わらせてください。 请在明天内完成工作。 5. と 表示共同动作的对象 李さんと一緒に映画を見に行きます。 和小李一起去看电影。 表示引用的内容 ほら、見てごらん。あそこに｢危険｣と書いてありますよ。 你瞧，那里写着“危险”两个字哦。 6. へ 表示动作移动的方向 買い物へいく途中王先生に会いました。 去买东西的路上遇到了王老师。 7. から 表示起点 学校から家まで1時間かかります。 从家到学校要花1个小时。 表示原因 昨日試験がありましたから行かなかった。 因为昨天有考试所以没去。 表示成分/材料 この箱は紙からできた。 这个箱子是纸做的。 8. まで 表示终点 試験は明日までです。 考试到明天结束。 9. の 表示所属,属性 高校時代最後の運動会は一生忘れられない。 高中时代最后一次运动会终生难忘。 名词化 あのう、赤いのがありますか。 请问有红色的吗？ 表解释说明 昨日試験がありましたから、来なかったのです。 因为昨天有考试所以没来。 9. ～けど 表示转折或铺垫 あうの，荷物がでてこないんですけど… 那个，我的行李还有没有出来，能不能…… 知っていたけど，言わなかっただけだ。 我是知道的，只不过没有说罢了。 副词副词用作连用修饰语，表示用言的状态、程度，或者表明句子的陈述语气等的词叫作副词。 常用副词ああまり后接动词，肯定：太，过于；否定：不那么，不怎么 12345例：あまり食べると毒だよ。译：吃太多会伤身。例：あまり良くない。译：不怎么好。 あるいは或者；或许 12例：すぐ行けば或いは間に合うかもしれない。译：马上出发的话或许能赶上也说不定。 あいにく不凑巧 12例：あいにく彼は留守でした。译：不凑巧他不在家。 いいかが如何；怎样 12例：ご病人の具合はいかがでしょうか。译：病人的情况如何？ 一番（いちばん）最 12例：彼が一番よく知っている。译：他知道的最清楚。 一生懸命（いっしょうけんめい）拼命 12例：一生懸命努力する。译：拼命努力着。 一緒に（いっしょに）一起 12例：一緒にビルを飲みましょう。译：一起去喝啤酒吧。 一層（いっそう）更加 12例：病気は一層悪くなった。译：病情更加恶化了。 一般に（いっぱんに）一般地、普遍地 12例：一般にイギリス発祥とされるゴルフ。译：一般认为高尔夫的发祥地是英国。 いつまでも永远；无论到何时 12例：いつまでも友達でいましょう。译：永远是朋友。 いつも总是；经常 12例：いつもニコニコしていたら，嫌なことが寄り付きません。译：经常面带微笑的话，不好的事情就不会靠近哦。 お凡そ（およそ） 大约 凡是 完全（用于否定） 12345678例：君の話は凡そ分かった。译：你的话我大概明白了。例：凡そ人間として生まれた以上…译：本来既然生而为人……例：政治とは凡そ縁がない。译：与政治全然无缘。 かがっかり 失望 筋疲力竭 12345例：そんなにがっかりするな。译：别那么丧气呀。例：疲れてがっかりした。译：累得精疲力竭了。 必ず（かならず）一定 12例：必ず失敗する。译：必定要失败。 かなり相当（出乎意料的那种） 12345例：かなりの距離。译：相当远的距离。例：あの人は日本語がかなりできる。译：那个人日语相当不错。 ききちんと 整整齐齐地，干干净净地 规规矩矩地，准确地 正好，正巧，正合适 12345678例：料金はきちんと払ってある。译：钱已经如数付清。例：3時にきちんと集まる。译：3点准时集合。例：きちんとした字。译：工整的字。 きっと一定（经常和だろう/でしょう一起使用） 12例：きっと合格できる。译：一定能合格。 極めて（きわめて）极其 12例：極めて簡単な問題である。译：是个极其简单的问题。 け結局（けっきょく）到底，终究 12例：結局だれがやるのか。译：到底谁来做呢？ 結構（けっこう ）相当 12例：私の日本語も結構通（つう）じたようだ。译：我的日语还算讲的通了。 決して（けっして）决不~ 后要接否定使用 12例：決して屈（く）しない。译：绝不屈服。 ささっき刚刚 12例：さっき帰ったばかりだ。译：刚刚才回来。 早速（さっそく ）立刻，马上 12例：早速返事をくれた。译：很快给我了反馈。 さっぱり清爽；干净；直爽；清单；不油腻；完全；精光 1234567891011121314例：さっぱりした身なりをしている。译：打扮得干净利落。例：この料理はさっぱりしている。译：这个菜很清淡。例：約束のことはきれいさっぱりと忘れてしまった。译：早把约定忘得干干净净例：この映画はさっぱりおもしろくない。译：这个电影一点也不好看。例：どうもさっぱりだ。译：真糟糕。 ししっかり牢牢地；紧紧地 12例：しっかりつかまる。译：牢牢抓住。 じっと一动不动地；一声不响地，忍耐着，不出声；目不转睛地 12345例：じっと見つめる。译：盯着看。例：じっとしていられない。译：坐立不安。 実は（じつは）说真的，老实说，事实是，说实在的，其实，原来 12例：実は私にもよく分からない。译：说真的，我也不太明白。 しばらく暂时，不久 12例：しばらく待ってくれ。 译：（你）给我等一会儿。 一时的，暂且 12例：しばらく辛抱する。译：姑且忍耐一时。 许久，好久 12例：しばらくでしたね。译：好久不见呀。 充分（じゅうぶん）充分的 12例：自分の力を充分発揮する。译：充分发挥自己的才能。 すずいぶん相当厉害；非常，很；颇，相当；特别； 12例：病人は熱のためにずいぶん苦しんでいる。译：病人因发烧很难受。 好久 12例：ずいぶん捜した。译：找了好久。 すぐ立刻；马上 12例：すぐ出かけましょう。译：马上出门吧。 すこし一点点；稍微 12例：少し疲れました。译：有点累了。 すっかり完全 12例：すっかり忘れていた。译：全忘了。 ずっと一直 12例：今朝からずっと待っていた。译：从今天早晨一直等到现在。 远比…..更 12例：彼の方がずっといい。译：他的方法好得多。 径直（走） 12例：ずっと前へ進み出た。译：径直走到前面。 すべて全部 12例：問題はすべて解決した。译：问题全部解决了。 せせっかく难得，好不容易 12例：せっかく晩ご飯を作ったのに、みんなは外食にするなんて。译：我特意做了晚饭，大家却在外面吃饭。 ぜったい绝对 12例：ぜったい間違いない。译：绝对没有错。 ぜひ一定；务必 12例：ぜひ遊びに来てね。译：一定要来玩哦。 全然（ぜんぜん）一点也不…..（后接否定，表全否） 12例：全然興味がない。译：完全没了兴趣。 全部（ぜんぶ）全部 12例：問題は全部解決ずみだ。译：问题已经全部解决。 そ相当（そうとう）相当 12例：今日は相当（に）寒いです。译：今天相当的冷呀。 そろそろ就要，快要；不久；时间差不多了 12例：もうそろそろ晚飯だ。译：就要吃晚饭了。 渐渐；逐渐 12例：そろそろ（と）寒くなってきた。译：渐渐地冷起来了。 慢慢地；徐徐地 12例：そろそろと歩く。译：慢慢地走。 それぞれ各自；分别；各个；每个 12例：それぞれ別の道を行く。译：各走各的路。 それほど那么，那样 12例：日本語はそれほど難しくありません。译：语并不是那么难。 ただんだん渐渐 12例：だんだん秋めいてきた。译：渐有秋意了。 たまに偶尔 12例：たまにはご両親に電話を掛けなさい。译：偶尔请给你父母打个电话。 多分（たぶん）大概（经常和でしょう/だろう一起使用，表示推测，大概….） 12例：彼が言うことは多分本当だろう。译：他说的大概是真的吧！ 大体（だいたい）大体上；大概 12例：大体以下のように規定する。译：大致规定如下。 基本上 12例：大体できた。 译：基本上完成了。 たいてい大致上，大都，差不多 12例：問題はたいてい出来た。译：问题大都产生了。 大概，恐怕。 12例：たいてい大丈夫だろう。译：大概没问题吧。 たくさん许多（后接名词时要加の例：たくさんの人 动词可直接接） 12例：たくさんの人。译：很多人。 確か（たしか）似乎，大概，表示根据记忆有相当把握的推断。 12例：確か2000円でした。译：要是没错，那是二千日元。 たとえ即使 12例：たとえ負けても後悔しない。译：即使输了也不后悔。 例えば（たとえば）例如 12例：スポーツ，例えばバレーボールや卓球などをなさいますか。译：体育活动，例如排球、乒乓球，你参加吗？ ちちゃんと好好地；踏踏实实地 12例：ちゃんと仕事をする。译：踏踏实实地工作。 整整齐齐 12例：物をちゃんとかたづける。译：把东西收拾好。 确实；的确 12例：わたしがちゃんと見た。译：我确实看见了。 ちょうど刚好 12例：ちょうど居合わせる。译：正好在场。 宛如，好像，恰似 12例：ちょうど絵のようだ。译：好像一幅画。 正，整。完全一致。 12例：ちょうど８時。译：八点整。 ちょっと一会儿，一下；表示数量不多，程度不深，时间很短等。 12例：ちょっと待ってください。译：请稍等一下。 相当，颇。 12例：ちょっと名の通った人译：颇有名望的人 不太容易，表示没那么简单。 12例：ちょっとわからない。译：不太明白。 试试，看看，以轻松的心情事做。 12例：ちょっと行ってくる。译：去去就来。 つついでに顺便 12例：散歩のついでに、お菓子を買ってきた。译：去散步，顺便买来了点心。 ついに终于 12例：ついに出来上がった。译：终于完成了。 直到最后（也不）；始终（不） 12例：ついに会わずじまいだ。译：直到最后也未能见面。 次々（つぎつぎ）连续不断、络绎不绝。 12例：次々に仕掛け花火が打ち上げられる。译：一个接一个地放起烟火。 常に（つねに）经常 12例：常にあることだ。译：常有的事。 つまり总之，归根究底 12例：つまり君は何を言いたいのか。译：究竟你想说什么呢？ てできるだけ尽量地；尽可能地 12例：できるだけのことをする。译：尽力而为。 とどう如何；怎么样 12345例：それはどういうわけだ。译：那是为什么呢？例：もう一杯どう。 译：再来一杯怎么样？ どうか请；务必 12例：あのことはどうかなるだろう。译：那件事总会有办法的吧。 礼貌用语 12例：どうかよろしくお願いします。译：请多关照。 不正常；异常 12例：彼は今日にどうかしている。译：他今天与往常不一样。 怎么回事 12例：それはどうか分からない。译：不明白那是怎么回事。 どうして为什么 12例：今日はどうして学校を休みましたか。译：今天怎么没来上学呀。 怎么样，怎么办，如何。 12例：この機械をどうして動かすか教えてほしい。译：希望教给我怎样开动这个机器。 岂止，岂料，意外，相反 12例：やさしそうに見えるが，どうして，なかなか気が強い。 译：看上去像很温柔，其实刚强得很。 唉呀唉呀。出乎意料时表示吃惊或感叹的词。 12例：どうして，たいした人気だ。译：唉呀唉呀，真红得不得了。 当然（とうぜん）当然 12例：謝るのが当然だ。译：道歉是应当的。 ときどき偶尔 12例：ときどき外食する。译：偶尔再外面吃饭。 とても非常 12例：今日はとても寒いです。译：今天非常的冷呀。 とにかく总之 12例：とにかく仕事を続けたくない。译：总之我不想继续工作了。 ともに一起 12例：学友とともに恩師を訪ねる。 译：和学友一同访问恩师。 同时 12例：残念であるとともに、くやしくも思う。译：感到遗憾的同时，也很悔恨。 どうぞ请 12例：はい，どうぞ。译：请。 礼貌用语 12例：どうぞよろしく。译：请多关照。 特に（とくに）特别是 12例：特に注意すべき点。译：应特别注意的地方。 ななお更加，愈发 12例：薬を飲んで、なお悪くなった。译：吃了药更加不好了。 犹，尚，还，仍然，依然 12例：今もなお夢中している。译：现在也仍然非常热衷。 此外（接续） 12例：なお、詳しいことは後で話します。译：此外，具体事宜稍后再谈。 なかなか后接形容词时表肯定：相当后接动词ない型时：轻易(不)，怎么也….，表示动作很难完成 12345例：去年の冬はなかなか寒かったですね。译：去年冬天相当的冷呀。例：なかなか怒らない。译：轻易不生气。 なるべく尽量 12例：なるべくなら明日来ていただけませんか。译：可能的话，请明天来怎么样？ なるほど诚然，的确；果然；怪不得 12例：なるほど美しい人だ。译：的确是个美人。 なんとなく不知为何，总觉得 12例：先輩の前では、なんとなく気兼ねする。译：在老前辈面前总觉得拘束。 无意中，不自主地 12例：なんとなく、口を滑らせてしまった。译：无意中说漏了嘴。 ははっきり清楚；明白 12例：はっきりと見える。译：清晰可见。 ばらばら零散；散乱（形容动词） 12例：ばらばらの髪の毛。译：披散的头发。 忽地跳出来 12例：悪漢共がばらばらと現れた。译：坏蛋们忽地跳了出来。 哗啦啦的雨声 12例：大粒の雨がばらばらと降り出した。译：大雨点哗啦哗啦地下了起来。 ひ非常に（ひじょうに）非常地 12例：血糖値が非常に高い。译：血糖值非常高。 びっくり吓一跳；吃惊 12例：びっくり仰天する。译：大吃一惊。 ほほとんど几乎 12例：ほとんど眠れなかった。译：几乎没有睡。 大部分；大概；大致；大体上 12例：古い建物はほとんど取り払われた。译：旧房子差不多都拆掉了。 ままあまあ一般般，尚可 12例：まあまあいいだろう。译：还算可以吧。 また又；再 12例：またにしましょう。译：改天再说〔去,来,做〕吧；下次再说吧！ まだ还 12例：まだ完成していない。译：尚未完成。 还，仍旧 12例：まだ会議中だ。译：会议还在进行中。 才，仅，刚刚 12例：まだ作ったばかりだ。译：刚刚做完。 还，更加 12例：理由はまだある。译：理由还有。 还，还好，还算 12例：このほうがまだましだ。译：这样还算好。 まっすぐ笔直；径直 12例：まっすぐに見る。译：直向前看。 一直；照直；不绕弯；直接 12例：まっすぐに家に帰る。译：直接回家。 正直；坦率；耿直 12例：まっすぐに白状する。译：老实供认；坦白交代。 まったく完全地 12例：まったく健康になった。译：完全康复。 全然；完全（否定） 12例：お酒はまったく飲まない。译：全然不喝酒。 真，实在 12例：まったく困ったものだ。译：真难办。 ますます越来越…… 12例：ますます元気になった。译：越来越有精神了。 間も無く（まもなく）马上就要…… 12例：間も無く春休みがやって来る。译：春假不久就会来到。 まるで简直 12例：まるで違う。译：完全不一样。 好像 12例：まるで夢のようだ。译：好像做梦一样。 めめったに（后接否定）几乎（不）……很（少），（不）常 12例：めったに怒らない。译：很少发火。 めっきり显著，急剧 12例：病人はめっきりよくなってきた。译：病人明显好转了。 ももう已经 12例：当地に来てもう半月になった。译：来到此地已经半个月了。 もし如果 12例：もし彼が来たら，またせておいてください。译：要是他来了，请让他等一下。 もっと更加 12例：リンゴをもっとください。译：再给些苹果吧。 最も（もっとも）最 12例：最もよい。译：最好。 ややがて不久 12例：やがて夜になった。译：天不久就黑了。 大约，大致，差不多 12例：やがて小１時間になる。译：差不多过了一个小时。 約（やく）大约 12例：約4時間。译：约四小时。 やっと好不容易；终于；总算 12例：終電にやっと間に合った。译：好不容易赶上了末班电车。 勉勉强强；刚刚 12例：やっとでき上がった。译：好不容易才完成了。 やはり果然 12例：注意したが、やはりミスがある。译：虽然注意了，但还是有错。 虽然…仍旧…。归根到底仍然是最初预测的结论。 12例：やはり女がいた。 译：果然在外边有了女人。 依然，仍旧。情况和以前一样 12例：今でも、やはり昔のままになっている。 译：即使到了现在，（它）仍旧保留着原来的风貌。 ゆゆっくり慢慢地 12例：ご飯をゆっくり食べる。译：慢慢地吃饭。 有余地，宽敞舒适，充裕，舒畅，安静，舒适 12例：いまからでもゆっくり間に合う。译：即使从现在起也还来得及。 よようやく终于 12例：ようやく試験が終わった。译：考试终于结束了。 勉强，好不容易，总算 12例：ようやく間に合った。译：总算赶上了。 渐渐，逐渐 12例：ようやく春らしくなってきた。译：渐渐有点春意了。 よほど很，颇，相当 12例：よほど自信があるのだろう。译：很有自信吧！ 差一点就….. 12例：よほど帰ろうかと思った。译：差点想回去。 わ割合（わりあい）比较 12例：この子は割合と勉強する。译：这个孩子比较用功。 わざと故意 12例：わざと聞こえないふりにする。译：故意装作听不见。 わざわざ特意地 12例：そのために、わざわざ来たのだ。 译：为此特意过来的。 故意地 12例：わざわざいたずら書きをする。译：故意乱涂乱画。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"日语","slug":"日语","permalink":"/tags/日语/"}]},{"title":"日语-动词变形","slug":"日语-动词变形","date":"2024-06-11T03:09:46.000Z","updated":"2024-06-11T03:25:52.011Z","comments":true,"path":"2024/06/11/日语-动词变形/","link":"","permalink":"/2024/06/11/日语-动词变形/","excerpt":"日语学习之动词变形","text":"日语学习之动词变形 ます形变形规则：1234567一类动词：う段假名 ー＞ い段＋ます二类动词：去掉 る＋ます三类动词： か变动词：くる ー＞ きます サ变动词：する ー＞ します 文法：1. ます形本身就是动词的敬语形态2. ますー＞ましょう/ましょうか 劝诱/积极主动为对方做某事12345例：一緒にビールを飲みましょ！译：一起去喝啤酒吧！例：傘を貸しましょうか？译：可以把伞借给我吗？ 3. ますー＞ませんか 更有礼貌的询问对方12例：あのシャツはありませんか？译：那件衬衫还有吗？ 4. ます形可直接修饰名词 做……的方法 ます形+方（かた） 12例：漢字の読み方译：汉字的读法 5. ます形＋ながら＋句子2 一边做……一般做……强调后面的动作12例：音楽を聴きながら食事します。译：一边听音乐一边吃饭。 6. ます形/形容词去い/形容动词＋すぎる 过度做……, 超过许可范围, 不好的事情12345例：働きすぎる。译：过度工作例：最近の車は操作が簡単すぎて、運転がおもしくないです。译：最近的车操作起来太简单了，都没有驾驶乐趣了。 7. ます形/形容词去い/形容动词＋そうです(样态助动词) 看起来好像……特殊变形词语: いいー＞よさ ないー＞なさ 12345678例：今にも雨が降りそうです。译：今天看起好像要下雨了。例：その料理は辛そうです。译：这个料理看起来很辣的样子。例：この机は丈夫そうです。译：这张桌子看起来很结实。 8. ます形＋やすいです 客观觉得容易……12例：このパソコンは使いやすいです。译：这台电脑很容易使用。 9. ます形＋にくいです 客观觉得难……12例：このカープは割れにくくて、安全ですよ。译：这个杯子很难裂开，很安全哟。 10. ます形＋がたいです 主观觉得难…… (认知类, 说话类的词语, 书面语)12例：この宿題はやりがたいです。译：这道题做起来很难。 11. ます形＋かねる 难以…… (郑重书面语, 与敬语连用)12例：ちょっと断りかねる译：难以拒绝 た形变形规则123456789101112131415161718一类动词： く、ぐ ー＞ いた、いだ 特例：いく ー＞ 行った う、つ、る ー＞ った ぬ、ぶ、む ー＞ んだ す ー＞ した二类动词：去掉 る＋た三类动词： か变动词：来る ー＞ きた サ变动次：する ー＞ した形容词：去掉 い+かった ~かったり、～かったりです 既……又……形容动词：词语+だった ~だったり、～だったりです 既……又…… 文法1. 动词/形容词/形容动词的た形表示动词的简体过去式2. ～たことがあります 有过……的经历12例：私は日本へ行ったことがあります。译：我去过日本。 3. ～たり、～たり 交替，反复的动作12例：私は歌ったり、ダンスしたりこができます。译：我可以边唱歌边跳舞。 4. 疑问词＋～たらいいですか 做……才好呢？12例：どうしたらいいですか？译：怎么做才好呢？ 5. ～たら、～ 如果……就……12例：雨が降ったら、行きません。译：如果下雨了，就不去了。 6. ～た＋ばかりです 刚刚做了，比ところです更长的时间但是是主观觉得时间短12例：彼は3月に大学を卒業したばかりです。译：他3月份才刚刚从大学毕业。 て形变形规则12345678910111213141516一类动词： く、ぐ ー＞ いて、いで 特例：いく ー＞ 行って う、つ、る ー＞ って ぬ、ぶ、む ー＞ んで す ー＞ して二类动词：去掉 る＋て三类动词： か变动词：来る ー＞ きて サ变动次：する ー＞ して形容词：去掉 い＋くて形容动词和名词：～＋で 文法1. ～てください 请……（轻微的命令）12例：やめてください。译：请不要这么做！ 2. ～てもいいです 可以做……12例：食べていいです。译：可以吃掉。 3. ～てはいけません 不可以做……12例：いま伝染病時から、旅行してはいけません。译：因为现在是疫情时期，不可以去旅行。 4. ～ています4.1 正在做某事12例：ゲームしています。译：正在打游戏。 4.2 表示状态（结婚，认识某人，住在，有等）12例：今大阪に住んでいます。译：目前我住在大版。 4.3 反复进行的动作或习惯（学习，工作等）12例：勉強しています译：学习中…… 5. ～てあげます 为别人做……（我或我方为第三方做事情）12例：译： 5.1 比自己地位低的人，动物，植物可以用 やります12例：译： 5.2 比自己地位高的人，可以用 あしあげます12例：译： 6. ～てもらいます 主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）12例：译： 6.1 比自己地位高的人，可以用 ～ていただきます12例：译： 7. ～てくれます 别人主动为我做……（别人为我或我方做事情，别人主动为我做）12例：译： 7.1 比自己地位高的人，可以用 ～てくださいます12例：译： 7.2 ～てくださいませんか 超级有礼貌的表达方式12例：译： 7.3 ～ていただけませんか 能帮我做……吗？12例：译： 8. ～ても～ 即使……也……12例：やっても、無理です。译：即使做了，也不行了。 9. ～てしまいます 表示下决心、将来完成12例：昼ご飯までにレポートを書いてしまいます。译：我要在午饭前把报告写完。 10. ～てしまいました10.1. 强调某个行为已经全部完成了12例：漢字の宿題はもうやってしまいました。译：汉字的作业已经全部做完了。 10.2. 为难状态下的困惑，后悔（发生了不好的事情）12例：パスポートをなくしてしまいました。译：护照弄丢了。 11. ～てあります11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）12例：机の上にメモが置いてあります。译：桌子上放着笔记本。 11.2. 表示状态时和ています的区别1234567自动词，强调窗户的状态例：窓が閉まっています。译：窗户关闭着。他动词，强调不知道被谁关了窗户这件事的结果例：窓が閉めてあります译：窗户关闭着 11.3. 表示为将来提前做准备12例：誕生日のプレゼントはもう買ってあります。译：生日礼物已经买好了。 12. ～ておきます12.1. 做某件事之前必要做的事情12例：旅行の前に切符を買っておきます。译：旅行之前要把票买好。 12.2. 为下次使用而完成必要的动作12例：はさみを使ったら、元の所に戻して置いてください。译：用完剪刀后，请放回原来的地方。 12.3. 让状态持续下去12例：明日会議がありますから、いすはこのままにして置いてください。译：明天还有会议，椅子就这样保持下去吧。 12.4. 临时的措施12例：資料は後で見ておきます、そこに置いといてください。译：资料之后要看，请放在哪里。 12.5. ～ておきます ー＞ ～ときます（口语）12例：そこにおいといてください。译：请放到那里。 13. まだ～ていません 事情或者动作还没有发生12例：銀行はまだ開いていません。译：银行还没有开门。 14. ～てみる 试着做……12345例：も一度考えてみます。译：在试着思考一次。例：このズボンをはいてみてもいいですか。译：可以试穿一下这条裤子吗？ 15. （て形/ない形+ないで）＋动词2 在动词1的情况下做动词2 有「没有做……而是做……」的意思12345678例：醤油を付けて食べます。译：沾着酱油吃。例：醤油を付けないで食べます。译：不要沾着酱油吃。例：日曜日はどこも行かないで、うちでゆっくり休みます。译：周日哪里也不去，在家里好好休息。 16. ～て来ます16.1. 做某个动作之后再回来, 有去去就回的感觉12例：ちょっと煙草を買ってきます。译：我去买包香烟。 16.2. 有逐渐变化的意思12例：消えて来ます。译：慢慢消失了。 ない形变形规则1234567891011121314一类动词：う段 ー＞ あ段＋ない 以う结尾的动词，要去掉う变成わない。買うー＞買わない ある的ない形就是ない二类动词：去掉 る＋ない三类动词： か变动词：来る ー＞ 来（こ）ない サ变动次：する ー＞ しない形容词：去掉 い＋くない形容动词和名词：～＋では（じゃ）ない 文法1. 一般用于否定2. ～ないでください 请不要做……12例：译： 3. 必须做…… ～なければ、なりません 12例：译： ～ないと、いけません 12例：译： ～ないと 12例：译： 4. ～なくてもいいです 不做……也可以12例：译： 可能态变形规则1234567一类动词：う段假名 ー＞ え段＋る二类动词：去掉 る＋られる三类动词： か变动词：くる ー＞ こられる サ变动词：する ー＞ できる 变化后的词性 变化之后都是二类动词 变化之后都是自动词 含义1.事物的性质12例：この野菜は生で食べらない。译：这个蔬菜不能生吃。 2.表示可能性12345678例：この事は両親に言えません。译：这件事不能对父母说。例：今は社長に会えません。译：现在无法会见社长。例：事務所の人は誰もそのコンーピュータを使えます。译：事务所的人谁都不会使用那台电脑。 3.能力12例：日本語を話せます。译：会说日语。 假定形变形规则1234567891011一类动词：う段 ー＞ え段＋ば二类动词：去掉 る＋れば三类动词： か变动词：来る ー＞ くれば サ变动次：する ー＞ すれば形容词：去掉 い＋ければ形容动词和名词：〜＋なら「ば」 文法1. 一般条件：一……就……12例：いい天気なら、向こうに島が見えます。译：天气好的话，你可以看到对面的小岛。 2. 假定条件：如果……就…… PS: 前句是意志类词语，后句是对听话人提要求的话，只能用たら，たら范围最大。 12345678例：時間がなかったら、テレビを見ません。译：没时间我就不看电视了。例：時間がなければ、テレビを見ません。译：没时间我就不看电视了。例：よがったら、助けてもらいますか。译：可以的话，能帮下忙吗？ 3. 名词+なら 可用于对方提出的话题，再提供一些信息12345例：温泉に行きたいんですが、どこか良い所がありませんか。译：非常想去泡温泉呀，有什么好地方吗？例：温泉なら、白馬がいいですよ。译：如果是温泉的话，白马县挺不错的哦。 4. 疑问词＋假定形＋いいですか 等同于 〜たらいいですか 怎么做才好呢？12例：本を借りたいですが、どうすればいいですか。译：想借本书，怎么做才好呢？ 5. 假定形＋连体形＋ほど〜 越……越……12例：パソコンは操作が簡単なら簡単なほどいいです。译：电脑的操作越简单越好呀。 被动形变形规则1234567一类动词：う段 ー＞ あ段＋れる二类动词：去る＋られる三类动词： か变动词：来る ー＞ 来られる サ变动次：する ー＞ される 文法AはBに＋被动形 A被B…… 中性，好坏都可表达当A是作品或者发明时，被动形前面要加上よって 12345678例：私は先生に褒められました。译：我被老师表扬了。例：私は犬に噛まれました。译：我被狗咬了。例：電話はベルによって発明されました。译：电话是被贝尔发明的。 AはBに＋なにを被动形 A的なに被B…… 中性，不好的事情A和~是从属关系（A的~），但是不能直接使用『Aの~』作为主语 12例：私は犬に手を噛まれました。译：我的手被狗咬了。 使役态变形规则12345678一类动词：う段假名 ー＞ あ段＋せる う结尾 ー＞ わせる二类动词：去る＋させる三类动词： か变动词：くる ー＞ こさせる サ变动词：する ー＞ させる 文法～を自动词使役态 让名词（某人）做~12例：息子をイギリスヘ留学させます。 译：让我的儿子去英国留学。 ～に～を他动词使役态 让名词（某人）做~12例：娘にピアノを習わせます。译：让女儿学习钢琴 意志形变形规则1234567一类动词：う段假名 ー＞ お段＋う二类动词：去掉 る＋よう三类动词： か变动词：くる ー＞ こよう サ变动词：する ー＞ しよう 文法自己的意志12345例：ちょっと休まない。译：要不休息一下？例：うん、休もう。译：嗯，去休息吧！ 劝诱12例：て伝おうか。译：能帮我一下吗？ 提议(大家一起做)12例：みんなですごし休もうか。译：大家一起休息一下吧？ 意志形＋とおもっています 很久以前就打算做……12例：週末は海に行こうとおもっています。译：很久以前就打算周末去海边呢。 意志形＋とおもいます 刚刚有这样的打算……12例：今から銀行へ行こうとおもいます。译：我今天才打算去银行。 敬体～ましょう12例：休みましょう。译：休息一下吧！ 命令形变形规则1234567一类动词：う段假名 ー＞ え段二类动词：去掉 る＋ろ三类动词： か变动词：くる ー＞ こい サ变动词：する ー＞ しろ 示例命令形和禁止形变形规则1字典形＋な 示例","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"日语","slug":"日语","permalink":"/tags/日语/"}]},{"title":"日语-五十音图","slug":"日语-五十音图","date":"2024-06-11T03:09:09.000Z","updated":"2024-06-11T03:25:57.204Z","comments":true,"path":"2024/06/11/日语-五十音图/","link":"","permalink":"/2024/06/11/日语-五十音图/","excerpt":"日语学习之五十音图发音","text":"日语学习之五十音图发音 五十音图平假名 あ段 い段 う段 え段 お段 あ（a） い（i） う（u） え（e） お（o） か（ka） き（ki） く（ku） け（ke） こ（ko） さ（sa） し（si） す（su） せ（se） そ（so） た（ta） ち（chi） つ（tsu） て（te） と（to） な（na） に（ni） ぬ（nu） ね（ne） の（no） は（ha） ひ（hi） ふ（fu） へ（he） ほ（ho） ま（ma） み（mi） む（mu） め（me） も（mo） や（ya） い（i） ゆ（yu） え（e） よ（yo） ら（ra） り（ri） る（ru） れ（re） ろ（ro） わ（wa） い（i） う（u） え（e） を（wo） ん（n） 片假名 ア段 イ段 ウ段 エ段 オ段 ア（a） イ（i） ウ（u） エ（e） オ（o） カ（ka） キ（ki） ク（ku） ケ（ke） コ（ko） サ（sa） シ（si） ス（su） セ（se） ソ（so） タ（ta） チ（chi） ツ（tsu） テ（te） ト（to） ナ（na） ニ（ni） ヌ（nu） ネ（ne） ノ（no） ハ（ha） ヒ（hi） フ（fu） ヘ（he） ホ（ho） マ（ma） ミ（mi） ム（mu） メ（me） モ（mo） ヤ（ya） イ（i） ユ（yu） エ（e） ヨ（yo） ラ（ra） リ（ri） ル（ru） レ（re） ロ（ro） ワ（wa） イ（i） ウ（u） エ（e） ヲ（wo） ン（n） 浊音/半浊音 あ段 い段 う段 え段 お段 が（ga） ぎ（gi） ぐ（gu） げ（ge） ご（go） ざ（za） じ（ji） ず（zu） ぜ（ze） ぞ（zo） だ（da） ぢ（ji） づ（zu） で（ze） ど（do） ば（ba） び（bi） ぶ（bu） べ（be） ぼ（bo） ぱ（pa） ぴ（pi） ぷ（pu） ぺ（pe） ぽ（po） 拗音 や段 ゆ段 よ段 きゃ（kya） きゅ（kyu） きょ（kyo） ぎゃ（gya） ぎゅ（gyu） ぎょ（gyo） しゃ（sha） しゅ（shu） しょ（sho） じゃ（ja） じゅ（ju） じょ（jo） ちゃ（cha） ちゅ（chu） ちょ（cho） にゃ（nya） にゅ（nyu） にょ（nyo） ひゃ（hya） ひゅ（hyu） ひょ（hyo） びゃ（bya） びゅ（byu） びょ（byo） ぴゃ（pya） ぴゅ（pyu） ぴょ（pyu） みゃ（mya） みゅ（myu） みょ（myo） りゃ（rya） りゅ（ryu） りょ（ryo） 拨音ん不出现在词头，ん在其后面发音为n的音 1例：反対（はんたい）、新聞（しんぶん）、天気（てんき） 促音つ音的主要在两个发音之前停顿一拍，促音与否会影响单词的含义 123物価（ぶっか）部下（ぶか）喝采（かっさい）火災（かさい）夫（おっと）音（おと） 长音长音是两倍母音的发音，长音与否同样也会影响单词的含义 123おばあさん（奶奶）、おばさん（阿姨）お爺（じい）さん（爷爷）、おじさん（叔叔）雪（ゆき）、勇気（ゆうき） 音调升调12庭（に👆わ）鼻（は👆な） 降调12本（ほ👇ん）天気（て👇んき） 词中降调12卵（た👆ま👇ご）飛行機（ひ👆こ👇うき） 接续降调12靴（くつ👇）花（はな👇） 升调和接续降调的区别花和鼻发音都一样，但是后面接助词时助词的发音却不一样。 12例：花👇が咲く例：鼻👉が高い 音调不同词语的意思也有可能不一样 12例：橋（はし👇）例：箸（は👇し） 语调平调陈述句一般都是平调 12例：明日友達とお花見をします。👉译：明天和朋友一起去赏花。 升调疑问句是升调 12例：ミラさんも一緒に行きませんか。👆译：米勒先生你也一块去吗？ 降调表示同意和失望的语气时也有用降调 12例：ああ、いいですね。👇译：啊，好的呢！","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"日语","slug":"日语","permalink":"/tags/日语/"}]},{"title":"Three.js基础入门","slug":"Three-js基础入门","date":"2024-06-06T05:59:37.000Z","updated":"2024-06-06T06:12:46.721Z","comments":true,"path":"2024/06/06/Three-js基础入门/","link":"","permalink":"/2024/06/06/Three-js基础入门/","excerpt":"Three.js基础入门学习","text":"Three.js基础入门学习 Three.js是一款开源的主流3D绘图JS引擎（名字Three就是3D的含义），原作者为Mr.Doob。项目地址为Three.js经常会和WebGL混淆， 但也并不总是，three.js其实是使用WebGL来绘制三维效果的。 WebGL是一个只能画点、线和三角形的非常底层的系统. 想要用WebGL来做一些实用的东西通常需要大量的代码， 这就是Three.js的用武之地。它封装了诸如场景、灯光、阴影、材质、贴图、空间运算等一系列功能，让你不必要再从底层WebGL开始写起。 场景Scene三维场景Scene (opens new window)对象理解为虚拟的3D场景，用来表示模拟生活中的真实三维场景,或者说三维世界。12// 创建3D场景对象Sceneconst scene = new THREE.Scene(); 物体物体 = 几何体 + 材质 几何体Geometry12// 创建一个长方体几何对象Geometryconst geometry = new THREE.BoxGeometry(100, 100, 100); 材质Material1234// 创建一个材质对象Materialconst material = new THREE.MeshBasicMaterial(&#123; color: 0xff0000, // 0xff0000设置材质颜色为红色&#125;); 网格模型Mesh(物体)123456// 两个参数分别为几何体geometry、材质materialconst mesh = new THREE.Mesh(geometry, material); // 网格模型对象Mesh// 设置网格模型在三维空间中的位置坐标，默认是坐标原点mesh.position.set(0,10,0);// 在threejs中你创建了一个表示物体的虚拟对象Mesh，需要通过.add()方法，把网格模型mesh添加到三维场景scene中。scene.add(mesh); 摄像机CameraThreejs如果想把三维场景Scene渲染到web网页上，还需要定义一个虚拟相机Camera，就像你生活中想获得一张照片，需要一台用来拍照的相机。Threejs提供了正投影相机OrthographicCamera和透视投影相机PerspectiveCamera，本次使用比较常用的透视投影相机PerspectiveCamera。 透视投影相机PerspectiveCamera12345// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)const width = 800; //宽度const height = 500; //高度// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000); PerspectiveCamera( fov, aspect, near, far ) 参数 含义 默认值 fov 相机视锥体竖直方向视野角度 50 aspect 相机视锥体水平方向和竖直方向长度比，一般设置为Canvas画布宽高比width / height 1 near 相机视锥体近裁截面相对相机距离 0.1 far 相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向 2000 相机位置.position生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs中虚拟相机同样如此。比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。相机对象Camera具有位置属性.position，通过位置属性.position可以设置相机的位置。123// 相机在Three.js三维坐标系中的位置// 根据需要设置相机位置具体值camera.position.set(200, 200, 200); 相机观察目标.lookAt()你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于threejs相机而言，就是设置.lookAt()方法的参数，指定一个3D坐标。1234// 相机观察目标指向Threejs 3D空间中某个位置camera.lookAt(0, 0, 0); // 坐标原点camera.lookAt(0, 10, 0); // y轴上位置10camera.lookAt(mesh.position); // 指向mesh对应的位置 渲染器WebGLRenderer创建渲染器通过WebGL渲染器WebGLRenderer可以实例化一个WebGL渲染器对象。12// 创建渲染器对象const renderer = new THREE.WebGLRenderer(); 设置Canvas画布尺寸.setSize()1234// 定义threejs输出画布的尺寸(单位:像素px)const width = 800; //宽度const height = 500; //高度renderer.setSize(width, height); // 设置three.js渲染区域的尺寸(像素px) 渲染器渲染方法.render()渲染器WebGLRenderer执行渲染方法.render()就可以生成一个Canvas画布(照片)，并把三维场景Scene呈现在canvas画布上面,你可以把.render()理解为相机的拍照动作“咔”。1renderer.render(scene, camera); // 执行渲染操作 渲染器Canvas画布属性.domElement渲染器WebGLRenderer通过属性.domElement可以获得渲染方法.render()生成的Canvas画布，.domElement本质上就是一个HTML元素：Canvas画布。1document.body.appendChild(renderer.domElement); 光Light实际生活中物体表面的明暗效果是会受到光照的影响，比如晚上不开灯，你就看不到物体，灯光比较暗，物体也比较暗。在threejs中，咱们用网格模型Mesh模拟生活中物体，所以threejs中模拟光照Light对物体表面的影响，就是模拟光照Light对网格模型Mesh表面的影响。 受光照影响材质threejs提供的网格材质，有的受光照影响，有的不受光照影响。 光源简介Three.js提供了多种模拟生活中光源。下面用点光源举例子 点光源点光源PointLight可以类比为一个发光点，就像生活中一个灯泡以灯泡为中心向四周发射光线。1234// 点光源：两个参数分别表示光源颜色和光照强度// 参数1：0xffffff是纯白光,表示光源颜色// 参数2：1.0,表示光照强度，可以根据需要调整const pointLight = new THREE.PointLight(0xffffff, 1.0); 除了通过THREE.PointLight的参数2设置光照强度，你可以可以直接访问光照强度属性.intensity设置。1pointLight.intensity = 1.0;//光照强度 光源衰减实际生活中点光源，比如一个灯泡，随着距离的改变，光线会衰减，越来越弱，光源衰减属性.decay默认值是2.0，如果你不希望衰减可以设置为0.0。1pointLight.decay = 0.0; // 设置光源不随距离衰减 光源位置你把点光源想象为一个电灯泡，你在3D空间中，放的位置不同，模型的渲染效果就不一样。12//点光源位置pointLight.position.set(400, 0, 0); // 点光源放在x轴上 光源添加到场景光源和网格模型Mesh对应一样是三维场景的一部分，自然需要添加到三维场景中才能起作用。1scene.add(pointLight); // 点光源添加到场景中 动画threejs可以借助HTML5的API请求动画帧window.requestAnimationFrame实现动画渲染。 threejs旋转动画1234567// 渲染函数function render() &#123; renderer.render(scene, camera); // 执行渲染操作 mesh.rotateY(0.01); // 每次绕y轴旋转0.01弧度 requestAnimationFrame(render); // 请求再次执行渲染函数render，渲染下一帧&#125;render(); 计算两帧渲染时间间隔和帧率1234567891011// 渲染循环const clock = new THREE.Clock();function render() &#123; const spt = clock.getDelta()*1000;//毫秒 console.log(&apos;两帧渲染时间间隔(毫秒)&apos;,spt); console.log(&apos;帧率FPS&apos;,1000/spt); renderer.render(scene, camera); //执行渲染操作 mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度 requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧&#125;render(); 渲染循环和相机控件OrbitControls设置了渲染循环,相机控件OrbitControls就不用再通过事件change执行renderer.render(scene, camera);，毕竟渲染循环一直在执行renderer.render(scene, camera)。 以上内容就是Three.js的基础内容，下面介绍一些辅助开发的插件。 三维坐标系辅助观察坐标系THREE.AxesHelper()的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。123// AxesHelper：辅助观察的坐标系const axesHelper = new THREE.AxesHelper(150);scene.add(axesHelper); AxesHelper的xyz轴three.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。 相机控件OrbitControls平时开发调试代码，或者展示模型的时候，可以通过相机控件OrbitControls实现旋转缩放预览效果。 OrbitControls使用 旋转：拖动鼠标左键 缩放：滚动鼠标中键 平移：拖动鼠标右键 引入扩展库OrbitControls.js12// 引入轨道控制器扩展库OrbitControls.jsimport &#123; OrbitControls &#125; from &apos;three/addons/controls/OrbitControls.js&apos;; 使用OrbitControls123456// 设置相机控件轨道控制器OrbitControlsconst controls = new OrbitControls(camera, renderer.domElement);// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景controls.addEventListener(&apos;change&apos;, function () &#123; renderer.render(scene, camera); //执行渲染操作&#125;);//监听鼠标、键盘事件 stats查看threejs渲染帧率three.js每执行WebGL渲染器.render()方法一次，就在canvas画布上得到一帧图像，不停地周期性执行.render()方法就可以更新canvas画布内容，一般场景越复杂往往渲染性能越低，也就是每秒钟执行.render()的次数越低。通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(FPS),所谓渲染帧率(FPS)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。 引入Stats12//引入性能监视器stats.jsimport Stats from &apos;three/addons/libs/stats.module.js&apos;; Stats使用123456789101112//创建stats对象const stats = new Stats();// stats.domElement:web页面上输出计算结果,一个div元素，document.body.appendChild(stats.domElement);// 渲染函数function render() &#123; // requestAnimationFrame循环调用的函数中调用方法update(),来刷新时间 stats.update(); renderer.render(scene, camera); // 执行渲染操作 requestAnimationFrame(render); // 请求再次执行渲染函数render，渲染下一帧&#125;render(); demo source123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import * as THREE from &apos;three&apos;;// 引入轨道控制器扩展库OrbitControls.jsimport &#123; OrbitControls &#125; from &apos;three/addons/controls/OrbitControls.js&apos;;//引入性能监视器stats.jsimport Stats from &apos;three/addons/libs/stats.module.js&apos;;// 获取屏幕宽高const width = screen.width;const height = screen.height;// 变量声明let scene, camera, mesh, renderer, directionalLight, stats;// 初始化场景函数function initScene() &#123; // 创建3D场景对象Scene scene = new THREE.Scene();&#125;// 创建物体function initObject() &#123; //创建一个长方体几何对象Geometry const geometry = new THREE.BoxGeometry(20, 20, 20); //创建一个材质对象Material const material = new THREE.MeshLambertMaterial(&#123; color: 0xff0000,//0xff0000设置材质颜色为红色 transparent:true,//开启透明 opacity:0.8,//设置透明度 &#125;); // 两个参数分别为几何体geometry、材质material mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh //设置网格模型在三维空间中的位置坐标，默认是坐标原点 mesh.position.set(0,0,0); scene.add(mesh); &#125;// 初始化相机function initCamera() &#123; // 实例化一个透视投影相机对象 camera = new THREE.PerspectiveCamera(30, width/height, 1, 1000); // 相机在Three.js三维坐标系中的位置 // 根据需要设置相机位置具体值 camera.position.set(200, 200, 200); //相机观察目标指向Threejs 3D空间中某个位置 camera.lookAt(0, 0, 0); // 坐标原点&#125;// 初始化灯光function initLight() &#123; // 环境光:没有特定方向，整体改变场景的光照明暗 const ambient = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambient); // 平行光 directionalLight = new THREE.DirectionalLight(0xffffff, 1); // 设置光源的方向：通过光源position属性和目标指向对象的position属性计算 directionalLight.position.set(80, 50, 50); // 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0 directionalLight.target = mesh; scene.add(directionalLight);&#125;// 初始化渲染器function initRender() &#123; // 创建渲染器对象 renderer = new THREE.WebGLRenderer(); renderer.setSize(width, height); renderer.render(scene, camera); // 执行渲染操作 document.querySelector(&apos;#app&apos;).appendChild(renderer.domElement);&#125;// 初始化辅助开发工具function initHelper() &#123; //创建stats对象 stats = new Stats(); //stats.domElement:web页面上输出计算结果,一个div元素， document.body.appendChild(stats.domElement); // DirectionalLightHelper：可视化平行光 const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5,0xff0000); scene.add(dirLightHelper); // AxesHelper：辅助观察的坐标系 const axesHelper = new THREE.AxesHelper(150); scene.add(axesHelper); // 设置相机控件轨道控制器OrbitControls const controls = new OrbitControls(camera, renderer.domElement); // 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景 // controls.addEventListener(&apos;change&apos;, function () &#123; // renderer.render(scene, camera); //执行渲染操作 // &#125;);//监听鼠标、键盘事件&#125;// 动画function animate() &#123; mesh.rotateX(0.01); mesh.rotateY(0.01); stats.update(); renderer.render(scene, camera); //执行渲染操作 requestAnimationFrame(animate);&#125;// 开始Threejsfunction start() &#123; initScene(); initObject(); initCamera(); initLight(); initRender(); initHelper(); animate();&#125;start();","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"/tags/Threejs/"}]},{"title":"Three.js学习资源导航","slug":"Three-js学习资源导航","date":"2024-06-03T01:56:22.000Z","updated":"2024-10-09T00:39:54.385Z","comments":true,"path":"2024/06/03/Three-js学习资源导航/","link":"","permalink":"/2024/06/03/Three-js学习资源导航/","excerpt":"Three.js相关学习资源导航链接","text":"Three.js相关学习资源导航链接 教程 官网文档 官方API文档 中文文档 官方入门教程 初中高级教程 基础教程 从零构建3D智能仓库 案例 官网案例 暮志未晚博客案例100篇 3D案例 物联网粮仓3D可视化 3D版赛车游戏 Three.js开发的3D头像生成器 three-cesium-examples 开源项目 官方源码仓库 官方示例仓库 Physijs-一款物理引擎，可以协助基于原生WebGL或使用three.js创建模拟物理现象，比如重力下落、物体碰撞等物理现象 stats.js-提供了一个简单的信息框，可帮助您监视代码性能 dat.gui-轻量级的icon形用户界面框架，可以用来控制Javascript的变量，比如WebGL中一个物体的尺寸、颜色 tween.js-一款可生成平滑动画效果的js动画库。可以非常方便的控制机械、游戏角色运动 ThreeBSP-可以将现有的模型组合出更多个性的模型来使用。如两个几何体的差集、并集、交集的展示 免费3D模型","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"资源导航","slug":"资源导航","permalink":"/tags/资源导航/"},{"name":"Threejs","slug":"Threejs","permalink":"/tags/Threejs/"}]},{"title":"windows系统安装Redis","slug":"windows系统安装redis","date":"2024-05-30T08:06:09.000Z","updated":"2024-05-30T08:27:27.803Z","comments":true,"path":"2024/05/30/windows系统安装redis/","link":"","permalink":"/2024/05/30/windows系统安装redis/","excerpt":"windows系统下如何安装Redis","text":"windows系统下如何安装Redis Redis简介Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，它提供了一个高效的键值存储解决方案，并支持多种数据结构，如字符串（Strings）、哈希（Hashes）、列表（Lists）、集合（Sets）和有序集合（Sorted Sets）等。它被广泛应用于缓存、消息队列、实时统计等场景。 安装（windows）Redis安装文件下载将这个库clone到本地，之后以管理员身份执行install_redis.cmd这个文件后，就安装好了。 使用客户端redis-cli.exe是客户端，可以连接redis服务进行操作如：12SET mykey &quot;Hello, World!&quot;GET mykey 卸载服务1redis-server --service-uninstall 停止服务1redis-server --service-stop 开始服务1redis-server --service-start 补充还有一个安装地址，Redis安装文件下载但是这个库维护的Redis版本较低。","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"后端","slug":"后端","permalink":"/tags/后端/"}]},{"title":"web视频播放浅析","slug":"web视频播放浅析","date":"2024-04-19T02:32:53.000Z","updated":"2024-04-22T01:16:01.429Z","comments":true,"path":"2024/04/19/web视频播放浅析/","link":"","permalink":"/2024/04/19/web视频播放浅析/","excerpt":"简单的介绍html中video标签的几种使用场景,注意，视频播放是点播形式。","text":"简单的介绍html中video标签的几种使用场景,注意，视频播放是点播形式。 视频知识web端以前用flash播放视频，但是由于安全原因，现在已经抛弃，使用html5的video标签。 视频容器（也称为视频封装格式）是用来存储音频、视频和其他元数据（如字幕、章节信息等）的一种文件格式结构。它将音视频编码数据组织在一起，以便于播放器解析和呈现。容器的作用就像一个“包装盒”，将不同的轨道（视频流、音频流、字幕流等）按照一定的标准组织起来，使得各部分数据可以同步播放。 常见的视频文件格式 常见的视频编码格式 浏览器中的视频格式WebM Ogg/Theora MPEG-4/H.264 常见视频播放方法基础方式使用video标签，src直接链接到一个完整的视频地址1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;video-basic&lt;/title&gt; &lt;style&gt; #video &#123; width: 800px; margin: 20px auto; display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;video id=&quot;video&quot; controls autoplay&gt; &lt;source src=&quot;http://127.0.0.1:3000/video1.mp4&quot; type=&quot;&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这个例子是最基础最简单的。源码 video-stream方式前端代码1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;icon&quot; href=&quot;data:,&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;Streaming&lt;/title&gt; &lt;style&gt; body &#123; background-color: #000000; &#125; video &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; max-height: 100%; max-width: 100%; margin: auto; object-fit: contain; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;video src=&quot;http://localhost:3000/api/video/video.mp4&quot; playsInline muted autoplay controls controlsList=&quot;nodownload&quot; &gt; &lt;/video&gt; &lt;/body&gt;&lt;/html&gt; 后端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import Koa from &apos;koa&apos;import KoaRouter from &apos;koa-router&apos;import sendFile from &apos;koa-sendfile&apos;import url from &apos;url&apos;import path from &apos;path&apos;import fs from &apos;fs&apos;import util from &apos;util&apos;const __filename = url.fileURLToPath(import.meta.url)const __dirname = path.dirname(__filename)const PORT = parseInt(process.env.PORT, 10) || 3000const app = new Koa()const router = new KoaRouter()//// Serve HTML page containing the video player//router.get(&apos;/&apos;, async (ctx) =&gt; &#123; await sendFile(ctx, path.resolve(__dirname, &apos;public&apos;, &apos;index.html&apos;)) if (!ctx.status) &#123; ctx.throw(404) &#125;&#125;)//// Serve video streaming//router.get(&apos;/api/video/:name&apos;, async (ctx, next) =&gt; &#123; const &#123; name &#125; = ctx.params if ( !/^[a-z0-9-_ ]+\\.mp4$/i.test(name) ) &#123; return next() &#125; const &#123; request, response &#125; = ctx const &#123; range &#125; = request.headers if (!range) &#123; ctx.throw(400, &apos;Range not provided&apos;) &#125; const videoPath = path.resolve(__dirname, &apos;videos&apos;, name) try &#123; await util.promisify(fs.access)(videoPath) &#125; catch (err) &#123; if (err.code === &apos;ENOENT&apos;) &#123; ctx.throw(404) &#125; else &#123; ctx.throw(err.toString()) &#125; &#125; // // Calculate start Content-Range // const parts = range.replace(&apos;bytes=&apos;, &apos;&apos;).split(&apos;-&apos;) const rangeStart = parts[0] &amp;&amp; parts[0].trim() const start = rangeStart ? parseInt(rangeStart, 10) : 0 // // Calculate video size and chunk size // const videoStat = await util.promisify(fs.stat)(videoPath) const videoSize = videoStat.size const chunkSize = 10 ** 6 // 1mb // // Calculate end Content-Range // // Safari/iOS first sends a request with bytes=0-1 range HTTP header // probably to find out if the server supports byte ranges // const rangeEnd = parts[1] &amp;&amp; parts[1].trim() const __rangeEnd = rangeEnd ? parseInt(rangeEnd, 10) : undefined const end = __rangeEnd === 1 ? __rangeEnd : (Math.min(start + chunkSize, videoSize) - 1) // We remove 1 byte because start and end start from 0 const contentLength = end - start + 1 // We add 1 byte because start and end start from 0 response.set(&apos;Content-Range&apos;, `bytes $&#123;start&#125;-$&#123;end&#125;/$&#123;videoSize&#125;`) response.set(&apos;Accept-Ranges&apos;, &apos;bytes&apos;) response.set(&apos;Content-Length&apos;, contentLength) const stream = fs.createReadStream(videoPath, &#123; start, end &#125;) stream.on(&apos;error&apos;, (err) =&gt; &#123; console.log(err.toString()) &#125;) response.status = 206 response.type = path.extname(name) response.body = stream&#125;)//// We ignore ECONNRESET, ECANCELED and ECONNABORTED errors// because when the browser closes the connection, the server// tries to read the stream. So, the server says that it cannot// read a closed stream.//app.on(&apos;error&apos;, (err) =&gt; &#123; if (![&apos;ECONNRESET&apos;, &apos;ECANCELED&apos;, &apos;ECONNABORTED&apos;].includes(err.code)) &#123; console.log(err.toString()) &#125;&#125;)//// Add Koa Router middleware//app.use(router.routes())app.use(router.allowedMethods())//// Start the server on the specified PORT//app.listen(PORT)console.log(&apos;Video Streaming Server is running on Port&apos;, PORT) 可以看出，前端部分的代码跟第一个例子一样，直接给video标签的src一个视频链接地址，但是这个地址指向后台一个api接口。video标签默认会在请求头加上Content-Range属性，后端接口会根据这个属性去返回对应的数据。对于前端开发来说是无感的，因为浏览器已经自动完成了，只需要对后端接口做处理即可。源码 mediaSource方式这个方式用到了MediaSource这个API，允许JavaScript创建和处理媒体数据源，使得浏览器能够播放来自各种来源的自定义媒体数据，而不是只限于原始的文件或 URL。前端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id=&quot;video&quot; width=&quot;800&quot; height=&quot;400&quot; webkit-playsinline=&quot;true&quot; controls playsinline=&quot;true&quot; type=&quot;video/mp4&quot; muted x5-video-player-type=&quot;h5&quot; &gt; &lt;script&gt; var PostbirdMp4ToBlob = &#123; mediaSource:new MediaSource(), // 检查是否支持 MediaSource 或者 mimeCodec checkSupported: function (cb) &#123; if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(this.mimeCodec)) &#123; &#125; else &#123; this.video.src = assetUrl; // 如果不支持，则直接将 src 修改成原始的url，保证兼容性 console.error(&apos;Unsupported MediaSource or unsupported MIME type or codec: &apos;, this.mimeCodec); &#125; &#125;, // 初始化 selector / assetUrl / mimeCodec / autoPlay // selector：video的选择器 exp: &apos;#video&apos; // assetUrl: video的请求地址 exp : &apos;./v.mp4&apos; // mimeCodec: 编码模式 exp: &apos;video/mp4; codecs=&quot;avc1.640028, mp4a.40.2&quot;&apos; init: function (selector, assetUrl, mimeCodec) &#123; this.video = document.querySelector(selector); // 获取vide dom this.assetUrl = assetUrl; this.mimeCodec = mimeCodec; this.checkSupported(); this.start();// 开启 &#125;, start: function () &#123; console.log(this.mediaSource.readyState); // closed this.video.src = URL.createObjectURL(this.mediaSource); this.mediaSource.addEventListener(&apos;sourceopen&apos;, this.sourceOpen.bind(this));// bind(this) 保证回调 &#125;, // MediaSource sourceopen 事件处理 sourceOpen: function (_) &#123; var _this = this; console.log(this.mediaSource.readyState); // open var sourceBuffer = this.mediaSource.addSourceBuffer(this.mimeCodec); this.fetchAB(this.assetUrl, function (buf) &#123; sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123; _this.mediaSource.endOfStream();// 结束 _this.video.play(); // 播放视频 console.log(_this.mediaSource.readyState); // ended &#125;); sourceBuffer.appendBuffer(buf); &#125;); &#125;, // 基于 XHR 的简单封装 // arguments - url // arguments - cb (回调函数) fetchAB: function (url, cb) &#123; var xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, url); xhr.responseType = &apos;arraybuffer&apos;; xhr.onload = function () &#123; cb(xhr.response); &#125;; xhr.send(); &#125; &#125;; &lt;/script&gt; &lt;script&gt; var codec = &apos;video/mp4; codecs=&quot;avc1.42e01e, mp4a.40.2&quot;&apos;; PostbirdMp4ToBlob.init(&apos;#video&apos;, &apos;/video/video1.mp4&apos;, codec); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码1234567891011121314151617const Koa = require(&apos;koa&apos;);const Router = require(&apos;koa-router&apos;);const static = require(&apos;koa-static&apos;);const path = require(&apos;path&apos;);const fs = require(&apos;fs&apos;).promises;const app = new Koa();const router = new Router();app.use(static(&apos;./static&apos;));app.use(router.routes());app.listen(8080, () =&gt; &#123; console.log(&apos;server is run at 8080......&apos;);&#125;) 后端是一个静态资源服务器 这里需要注意下，用MediaSource接口来播放视频，对视频文件是有要求的，目前例子中的mp4文件可以播放，但是笔者试了很多方式来转换其它的视频文件都没有成功，目前也在尝试中。 源码 m3u8 Hls方式.m3u8文件本质上是一个索引文件，其中包含了指向一系列多媒体片段（通常是经过加密或未加密的TS格式文件）的URL列表。前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// index.html&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;video-m3u8&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;video-list&quot;&gt; &lt;div&gt;播放列表&lt;/div&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;video id=&quot;video&quot; controls autoplay&gt;&lt;/video&gt; &lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;// main.jsimport &apos;./style.css&apos;;import Hls from &apos;hls.js&apos;;var video = document.getElementById(&apos;video&apos;);var videoList = [&apos;video1&apos;, &apos;video2&apos;, &apos;video3&apos;, &apos;video4&apos;, &apos;video5&apos;];// 创建buttons并插入domvar nUl = document.querySelector(&apos;.video-list ul&apos;);videoList.forEach(item=&gt; &#123; var nLi= document.createElement(&apos;li&apos;); var nBtn= document.createElement(&apos;button&apos;); nBtn.textContent = item; nLi.appendChild(nBtn); nUl.appendChild(nLi);&#125;);playVideo(videoList[0]);// 按钮添加事件var buttons = document.querySelectorAll(&apos;.video-list button&apos;);for(let btn of buttons) &#123; btn.onclick = (evt)=&gt; &#123; let videoName = evt.target.textContent; playVideo(videoName); &#125;&#125;// 播放videofunction playVideo(videoName) &#123; if (Hls.isSupported()) &#123; var hls = new Hls(); hls.loadSource(&apos;http://127.0.0.1:3000/&apos;+videoName+&apos;.m3u8&apos;); hls.attachMedia(video); hls.on(Hls.Events.MANIFEST_PARSED, function () &#123; // video.play(); &#125;); &#125; else if (video.canPlayType(&apos;application/vnd.apple.mpegurl&apos;)) &#123; video.src = &apos;http://127.0.0.1:3000/&apos;+videoName+&apos;.m3u8&apos;; video.addEventListener(&apos;loadedmetadata&apos;, function () &#123; // video.play(); &#125;); &#125;&#125; js文件中需要hls.js库。 hls.js 是一个开源的JavaScript库，专为解决在现代Web浏览器上播放基于HTTP Live Streaming (HLS)协议的视频内容而设计。HLS协议由苹果公司开发，被广泛用于在网络上分发实时和点播视频内容，尤其适用于移动端和桌面设备。HLS协议的工作原理是将长视频文件切割成一系列小的媒体片段（通常为MPEG-2 Transport Stream格式，扩展名为.ts），并通过一个M3U8索引文件来组织这些片段。M3U8文件包含了指向各个视频片段的URL以及元数据，如分辨率、编码类型等信息。 video.src = &#39;http://127.0.0.1:3000/&#39;+videoName+&#39;.m3u8&#39;这段代码是指向一个.m3u8的文件，这个文件怎么生成的呢？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// creatM3u8.jsconst fs = require(&apos;fs&apos;);const fluentFFmpeg = require(&apos;fluent-ffmpeg&apos;);const path = require(&apos;path&apos;);// 输入文件夹const inputFolder = path.resolve(__dirname, &apos;./sourceVideos&apos;);// 输入文件夹下的所有视频文件listconst files = fs.readdirSync(inputFolder);// 输出目录，用于保存生成的 TS 文件和 M3U8 索引文件const outputDir = path.resolve(__dirname, &apos;./public&apos;);// FfmpegCommand实例变量let command;// 删除文件夹内容deleteFolderRecursiveSync(outputDir);// 循环files文件列表，逐个转换(async ()=&gt; &#123; for(let file of files) &#123; // 创建一个 FfmpegCommand 实例 command = fluentFFmpeg(); await creatVideos(file); console.log(&apos;-----完成转换&apos;+file+&apos;-----&apos;); &#125;&#125;)();function creatVideos(file) &#123; return new Promise((resolve, reject )=&gt; &#123; console.log(&apos;-----开始转换&apos;+file+&apos;-----&apos;); const basenameWithExt = path.basename(file); const extname = path.extname(basenameWithExt); const fileNameWithoutExt = basenameWithExt.slice(0, -extname.length); // 设置输出目录和 HLS 参数 command.input(`$&#123;inputFolder&#125;/$&#123;file&#125;`) .output(`$&#123;outputDir&#125;/$&#123;fileNameWithoutExt&#125;.m3u8`) .outputOptions([ &apos;-hls_time 10&apos;, // 每个切片时长为 10 秒 &apos;-hls_list_size 0&apos;, // 不限制播放列表的大小（无限循环） `-hls_segment_filename $&#123;outputDir&#125;/$&#123;file&#125;_%03d.ts`, // 指定切片文件命名规则 ]); // 执行转换过程 command .on(&apos;progress&apos;, function(progress) &#123; let per = parseInt(progress.percent || 0); console.log(&apos;转换进度: &apos; + per + &apos;%&apos;); &#125;) .on(&apos;end&apos;, () =&gt; &#123; // console.log(&apos;HLS 转换完成！&apos;); resolve(file); &#125;) .on(&apos;error&apos;, (err) =&gt; &#123; console.error(&apos;An error occurred: &apos; + err.message); &#125;) .run(); &#125;);&#125;// 删除文件夹内容function deleteFolderRecursiveSync(folderPath) &#123; if (!fs.existsSync(folderPath)) return; const files = fs.readdirSync(folderPath); for (let i = 0; i &lt; files.length; i++) &#123; const filePath = path.join(folderPath, files[i]); if (fs.lstatSync(filePath).isDirectory()) &#123; // 如果是子目录，则递归删除 deleteFolderRecursiveSync(filePath); &#125; else &#123; // 如果是文件，则直接删除 fs.unlinkSync(filePath); &#125; &#125;&#125; 这个文件读取目录sourceVideos文件夹下的mp4文件，并且分成n个视频片段和.m3u8文件，保存到了public目录下。public目录是一个静态资源服务器文件夹，前端hls.js库会拿到m3u8文件，解析文件内容，加载视频片段并播放。源码 总结以上简单介绍并列举了几种video标签在web视频播放中的例子。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"npm安装不同版本的一个包","slug":"npm安装不同版本的一个包","date":"2024-03-18T02:30:03.000Z","updated":"2024-03-18T02:44:39.992Z","comments":true,"path":"2024/03/18/npm安装不同版本的一个包/","link":"","permalink":"/2024/03/18/npm安装不同版本的一个包/","excerpt":"在同一个项目中，安装不同版本的一个包","text":"在同一个项目中，安装不同版本的一个包最近在开发中遇到项目需要同时依赖echarts的4.8.0版本和5.0.0版本，有两种方法解决。 方法一 把下载的4.8.0版本中，dist文件夹下的echarts.js文件copy出来，放到需要引入的文件夹下，比如lib。 在使用的地方直接引入就可以，如：import echarts from &quot;@/lib/echarts.js&quot; 方法二使用npm安装2个版本的包1npm i --save echarts@npm:echarts@4.8.0 安装后package.json中：12345&quot;dependencies&quot;: &#123; &quot;echarts&quot;: &quot;^5.0.0&quot;, &quot;echarts-gl&quot;: &quot;^2.0.9&quot;, &quot;echarts4&quot;: &quot;npm:echarts@^4.8.0&quot;, &#125;, 可以看到，echarts是正常安装的5.0.0版本，echarts4就是安装的4.8.0版本。使用的时候import * as echarts from &#39;echarts4&#39;就可以。再有就是，笔者在项目中用到了z-render，可以这样引入import * as zrender from &#39;echarts4/node_modules/zrender&#39;;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"手写动画库","slug":"手写动画库","date":"2024-02-20T07:03:29.000Z","updated":"2024-02-20T07:28:47.419Z","comments":true,"path":"2024/02/20/手写动画库/","link":"","permalink":"/2024/02/20/手写动画库/","excerpt":"简单实现一个动画库","text":"简单实现一个动画库 本动画库学习参考winter老师教程实现 思维导图通过上面的思维导图，动画库有Timeline，Animate，Easing三个类构成，对应三个文件。 使用案例案例代码在vite环境下构建 index.html文件1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vite App&lt;/title&gt; &lt;style&gt; #el1 &#123; width: 100px; height: 100px; background-color: aqua; &#125; #el2 &#123; position: relative; width: 100px; height: 100px; background-color: rgb(13, 50, 146); &#125; .btns &#123; margin-top: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;el1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;el2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;button id=&quot;startBtn&quot;&gt;start&lt;/button&gt; &lt;button id=&quot;pauseBtn&quot;&gt;pause&lt;/button&gt; &lt;button id=&quot;resumeBtn&quot;&gt;resume&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import animate, &#123; Linear, QuadraticIn, QuinticIn &#125; from &quot;./animate&quot;;// 使用方法// 获取时间线的实例let tl = animate();// 向时间线中加入动画实例tl.add(&#123; el: &apos;#el1&apos;, // 动画元素，可以是string或dom元素 property: &apos;transform&apos;, // 动画的属性 startValue: 0, // 动画初始值 endValue: 500, // 动画的结束值 duration: 2, // 动画持续时间 秒单位 delay: 0, // 动画的延迟 秒单位 timingFunction: QuadraticIn, // 动画的移动效果，可以查看Easing.js文件 template: v=&gt; `translate($&#123;v&#125;px)`, // 动画执行的每一帧，返给属性加工后得知，比如返回“500px”等 startTime: new Date(&apos;2024-2-20 9:36:00&apos;), // 可以指定具体的时间让动画执行 loop: &apos;reverse&apos;, // 动画是否循环 loop值真时正常动画 reverse反向动画&#125;);// 下面是对同一个元素el2的两个属性添加动画效果tl.add(&#123; el: &apos;#el2&apos;, property: &apos;top&apos;, startValue: 0, endValue: 500, duration: 2, delay: 0, timingFunction: Linear, template: v=&gt; `$&#123;v&#125;px`, loop: true&#125;);tl.add(&#123; el: &apos;#el2&apos;, property: &apos;left&apos;, startValue: 0, endValue: 500, duration: 2, delay: 0, timingFunction: Linear, template: v=&gt; `$&#123;v&#125;px`, loop: true&#125;);// 按钮事件document.querySelector(&apos;#startBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123; tl.start();&#125;, false);// document.querySelector(&apos;#resetBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;// tl.reset();// &#125;, false);document.querySelector(&apos;#pauseBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123; tl.pause();&#125;, false);document.querySelector(&apos;#resumeBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123; tl.resume();&#125;, false); 源码sourceCode","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"npm link","slug":"npm-link","date":"2024-02-18T03:15:29.000Z","updated":"2024-02-18T06:05:45.427Z","comments":true,"path":"2024/02/18/npm-link/","link":"","permalink":"/2024/02/18/npm-link/","excerpt":"npm link用法","text":"npm link用法 本地调试用假设要开发一个工具库，可以供多个项目使用。一种方法是发布到npm仓库中去，使用的时候，直接npm i moduleName,但是，这种方式不利于开发时候使用，每次改动都需要发布，其它依赖的项目还要更新依赖包，非常麻烦。另一种方法是使用npm link,在命令行下npm link --help1234npm link (in package dir)npm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]alias: ln 具体的使用示例:1.在&lt;工具库&gt;目录下，使用npm link命令，会根据目录下的package.json文件，将项目名称和入口文件，软连接到nodejs的全局环境下。可以使用npm ls --global --depth 0命令查看当前全局都有哪些包。12345678D:\\Program Files\\nodejs -&gt; .\\+-- corepack@0.10.0+-- hexo-cli@4.3.1+-- http-server@14.1.1+-- nodemon@3.0.2+-- npm@8.1.2+-- pnpm@8.15.1`-- simple-mind-map@0.9.7 -&gt; .\\..\\..\\..\\jinux\\test\\思维导图\\mind-map-main\\simple-mind-map 上面是笔者nodejs全局下的包，只有simple-mind-map@0.9.7这个包是通过npm link软连接生成的，其他的都是npm全局安装的。2.利用npm link生成软链接后，在需要引用&lt;工具库&gt;的项目目录下执行npm link &lt;工具库名称&gt;,这时在node_modules下就安装了这个工具库，而且是指向前面生成的软连接。3.按照步骤2的方式，可以在多个项目中这样使用。当更改&lt;工具库&gt;代码后，其它引用这个依赖的项目也会自动更改。 卸载 如果不需要依赖&lt;工具库&gt;时，可以在项目目录下执行npm unlink &lt;工具库名称&gt;。 全局删除软连接，npm rm --global &lt;工具库名称&gt;，有时候软链接可能删除了，但是还能使用,可以进入到nodejs全局安装的目录手动把这个包删除。 实际工作中的小技巧比如，&lt;工具库&gt;这个包已经发布到npm上了，本地又有很多项目依赖，如果想每次发布这个包后，所有项目都跟着更新，步骤如下： 全局安装&lt;工具库&gt;这个包,npm i &lt;工具库名称&gt; -g. 在依赖&lt;工具库&gt;这个包的项目下，执行npm link &lt;工具库名称&gt;. 全局更新包npm update &lt;工具库名称&gt; -g,所有link这个包的项目都会更新. 刚开始笔者也有疑问,全局安装的包不是在哪里都可以使用吗?为什么还要link呢?其实,npm i -g moduleName是将模块安装到全局目录下,但是只能在命令行下使用,项目代码中想require引用的话,还需要npm link后才能使用.","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"调试","slug":"调试","permalink":"/tags/调试/"}]},{"title":"浅析npm参数init,create,exec","slug":"浅析npm参数init-create-exec","date":"2024-01-17T05:11:33.000Z","updated":"2024-01-17T06:07:51.209Z","comments":true,"path":"2024/01/17/浅析npm参数init-create-exec/","link":"","permalink":"/2024/01/17/浅析npm参数init-create-exec/","excerpt":"npm [init,create,exec,innit],npx的使用","text":"npm [init,create,exec,innit],npx的使用 npm exec12345// pkg是包名npm exec &lt;pkg&gt;// 还有一种简写形式// npm官方文档中指出x,其实就是exec的别名,npm exec、npm x,两个命令是完全等价的。npm x &lt;pkg&gt; npm exec &lt;pkg&gt;的执行流程 在本地查找是否有&lt;pkg&gt;对应的npm包,若找到,则运行这个包的package.json中bin字段对应的可执行文件,若未找到,在远程npm仓库查找是否有&lt;pkg&gt;对应的npm包,若找到,则下载到本地,下载完成后运行这个包package.json中bin字段对应的可执行文件。 在执行bin字段有几点注意的,如果bin只有一个入口,那么可以执行,如果bin有多个入口,则寻找和包名一样的那个入口,如果没找到,则npm exec &lt;pkg&gt;报错。123456789create-vite这个npm包的package.json&#123; &quot;name&quot;: &quot;create-vite&quot; &quot;bin&quot;: &#123; &quot;create-vite&quot;: &quot;index.js&quot;, &quot;cva&quot;: &quot;index.js&quot; &#125; ...&#125; npm exec &lt;pkg&gt;的执行案例以create-vite这个包为例子执行npm exec crate-vite这条命令后,首先本地查找是否有create-vite这个npm包,找到,则运行create-vite这个npm包中的package.json中bin字段对应的可执行文件,即index.js这个文件。若未找到,在远程npm仓库查找是否有create-vite这个包,如果有,则下载到本地,并执行package.json中bin字段对应的可执行文件。 npxnpm文档中提到：npx的二进制文件在npm v7.0.0中被重写,而独立的npx包在当时已弃用。npx使用npm exec命令,而不是单独的参数解析器和安装过程。并提供了一些支持,以保持与它在以前版本中接受的参数的向后兼容性。因此:12npx = npm execnpx = npm x 所以上面的npm exec create-vite也可以使用npx create-vite去执行 npm init12npm initnpm init &lt;initializer&gt; 无initializer后面没有&lt;initializer&gt;是用来创建package.json文件 有initializer这里的npm init &lt;initializer&gt;实际会调用npm exec create-&lt;initializer&gt;, 也相当于npx create-&lt;initializer&gt;。比如在使用vite时,npm init vite,实际是执行npm exec create-vite npm create,npm innitnpm官方文档中指出create,innit其实就是init的别名,也就是说npm init,npm create,npm innit三个命令是完全等价的。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"}]},{"title":"软件工程中的版本管理","slug":"软件工程中的版本管理","date":"2024-01-02T02:15:42.000Z","updated":"2024-01-11T07:00:59.285Z","comments":true,"path":"2024/01/02/软件工程中的版本管理/","link":"","permalink":"/2024/01/02/软件工程中的版本管理/","excerpt":"简单的介绍软件工程中的版本管理","text":"简单的介绍软件工程中的版本管理 版本号的类型在软件开发中，版本（version）是指软件发布的不同版本或版本号。版本号通常由数字和字母组成，用于标识软件发布的时间、功能、修复的漏洞等信息。其中，一些常见的版本号命名包括： Alpha 版本：Alpha 版本通常是软件开发的早期版本，包含有限的功能，可能存在许多漏洞和问题，仅供开发人员进行内部测试和调试使用。 Beta 版本：Beta 版本是相对于 Alpha 版本而言的，通常包含更多的功能和修复了一些漏洞和问题，但仍然可能存在一些问题和缺陷。Beta 版本通常会发布给一些有限的测试用户或公众进行测试和反馈。 Release Candidate (RC) 版本：RC 版本是指预发布的版本，通常是最终版本发布之前的最后一个版本。RC 版本通常包含所有预计的功能和修复的漏洞，但仍然需要进行测试和反馈，以确保最终版本的质量和稳定性。 Stable 版本：Stable 版本是指最终发布的稳定版本，通常包含所有功能和修复的漏洞，经过了充分的测试和反馈，具有较高的质量和稳定性。 版本日期与时间命名的方式 Major.Minor.Patch：这种版本号命名方式通常由三个部分组成，例如 1.2.3，分别表示主版本号、次版本号和修订号。主版本号通常表示大的功能更新和重大变更，次版本号通常表示小的功能更新和优化，修订号通常表示修复的漏洞和问题。 Year.Month：这种版本号命名方式通常由两个部分组成，例如 2022.01，表示软件发布的年份和月份。这种命名方式通常用于一些周期性更新的软件。 Codename：这种版本号命名方式通常使用一个有意义的名称来代替版本号，例如 Ubuntu 发布的版本号通常使用一个动物名字来代替，例如 Ubuntu 22.04 LTS 的版本号为 “Jammy Jellyfish”。 例子 一个版本号的例子可以是 3.1.2-beta。其中，3 表示主版本号，1 表示次版本号，2 表示修订号，beta 表示预发布版本。这个版本号可以理解为软件发布的第三个主要版本，第一次次要更新，第二次修订更新，现在处于 beta 预发布阶段 一个包含版本号和时间戳的完整版本号可能如下所示：3.1.2-beta.202307151200，其中，202307151200 表示的是版本发布的时间，格式为年月日小时分钟。这个版本号可以表示一个预发布版本，在 2023 年 7 月 15 日 12:00 发布的第三个主要版本，第一次次要更新，第二次修订更新。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"svg转canvas","slug":"svg转canvas","date":"2023-10-12T02:34:12.000Z","updated":"2024-01-11T07:00:59.230Z","comments":true,"path":"2023/10/12/svg转canvas/","link":"","permalink":"/2023/10/12/svg转canvas/","excerpt":"svg转canvas小例子","text":"svg转canvas小例子 demo123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;svg2canvas&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;svg-wrap&quot;&gt; &lt;svg width=&quot;200&quot; height=&quot;200&quot; xmlns=&apos;http://www.w3.org/2000/svg&apos;&gt; &lt;rect width=&quot;200&quot; height=&quot;200&quot; style=&quot;fill:#b44a4a&quot;&gt;&lt;/rect&gt; &lt;text x=&quot;15&quot; y=&quot;50&quot; fill=&quot;#ffffff&quot;&gt;中文显示&lt;/text&gt; &lt;/svg&gt; &lt;/div&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; window.onload = function()&#123; //获取svg内容 var svg = document.getElementById(&apos;svg-wrap&apos;).innerHTML; var canvas = document.getElementById(&apos;canvas&apos;); var c = canvas.getContext(&apos;2d&apos;); //新建Image对象 var img = new Image(); // 转换重点在这里 //svg编码成base64 img.src = &apos;data:image/svg+xml;base64,&apos; + window.btoa(unescape(encodeURIComponent(svg)));//svg内容中可以有中文字符 // img.src = &apos;data:image/svg+xml;base64,&apos; + window.btoa(svg);//svg内容中不能有中文字符 //图片初始化完成后调用 img.onload = function() &#123; //将canvas的宽高设置为图像的宽高 canvas.width = img.width; canvas.height = img.height; //canvas画图片 c.drawImage(img, 0, 0); //将图片添加到body中 document.body.appendChild(img); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结利用了img可以加载base64数据，将svg转成base64数据。用到了unescape，encodeURIComponent函数，详情可参考","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"}]},{"title":"vue中this.$message的实现","slug":"vue中this.$message的实现","date":"2023-10-10T06:31:29.000Z","updated":"2024-04-15T02:11:10.618Z","comments":true,"path":"2023/10/10/vue中this.$message的实现/","link":"","permalink":"/2023/10/10/vue中this.$message的实现/","excerpt":"vue中全局message组件的实现","text":"vue中全局message组件的实现 vue3中的$messageelement plus中message组件可以this.$message来调用，参考它实现一个简版的message组件 message.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;transition @before-leave=&quot;onClose&quot; @after-leave=&quot;$emit(&apos;destroy&apos;)&quot; &gt; &lt;div v-show=&quot;visible&quot; :id=&quot;id&quot; :style=&quot;customStyle&quot; class=&quot;message-wrap&quot; @mouseenter=&quot;clearTimer&quot; @mouseleave=&quot;startTimer&quot; &gt; &lt;slot&gt; &#123;&#123; message &#125;&#125; &lt;/slot&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, defineProps, computed, ref, onMounted, onBeforeUnmount, watch, getCurrentInstance &#125; from &apos;vue&apos;export default defineComponent(&#123; name: &apos;message&apos;, props: [&apos;message&apos;, &apos;id&apos;, &apos;offset&apos;, &apos;onClose&apos;, &apos;duration&apos;], emits: &#123; destroy: ()=&gt; true &#125;, setup(props) &#123; const visible = ref(true); let timer = null; onMounted(()=&gt; &#123; startTimer(); &#125;); onBeforeUnmount(()=&gt; &#123; document.removeEventListener(&apos;keydown&apos;, keydown, false); &#125;); // 开始定时器 const startTimer = ()=&gt; &#123; // 设置定时关闭 timer = setTimeout(()=&gt; &#123; visible.value = false; &#125;, props.duration || 5000); &#125; // 清除定时器 const clearTimer = ()=&gt; &#123; clearTimeout(timer); &#125; // 样式计算属性 const customStyle = computed(()=&gt; &#123; return &#123; top: props.offset+&apos;px&apos; &#125; &#125;); // 案件按下回调函数 const keydown = (&#123; code &#125;)=&gt; &#123; if(code === &apos;Escape&apos;) &#123; if(visible.value) &#123; visible.value = false; &#125; &#125; &#125; // 添加事件 document.addEventListener(&apos;keydown&apos;, keydown, false); return &#123; visible, customStyle, startTimer, clearTimer &#125; &#125;,&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.message-wrap &#123; position: fixed; width: 200px; margin: 0 auto; padding: 10px 10px; color: rgb(233, 110, 110); border: 1px solid rgb(243, 122, 122); background-color: rgba(243, 122, 122, .1); border-radius: 5px; top: 10px; left: 0; right: 0; font-size: 13px; user-select: none; cursor: auto;&#125;&lt;/style&gt; 这里用到了vue自带的transition组件，这里使用了before-leave和after-leave两个钩子 message.js123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; createVNode, render &#125; from &apos;vue&apos;;import MessageConstructor from &apos;./message.vue&apos;;const instances = [];let seed = 1;const message = (options=&#123;&#125;)=&gt; &#123; let verticalOffset = 10; if(typeof options === &apos;string&apos;) options = &#123; message: options &#125; // 用于销毁vm，也就是从dom中删除 options.onDestroy = ()=&gt; &#123; // console.log(&apos;destroy已经调用&apos;); render(null, container); &#125; options.onClose = ()=&gt; &#123; delInstance(options.id); &#125; options.id = seed++; // 设置id // 计算高度 instances.forEach(vm=&gt; &#123; verticalOffset += (vm.el.offsetHeight + 10); &#125;); options.offset = verticalOffset; const vm = createVNode(MessageConstructor, options, options.message); instances.push(vm); const container = document.createElement(&apos;div&apos;); render(vm, container); document.body.appendChild(container.firstChild);&#125;// 销毁的实例从instances中删除,并重新计算offset// 这里需要注意，一定在transition的before-leave回调中执行const delInstance = (id)=&gt; &#123; let idx = instances.findIndex(vm=&gt; &#123; return id === vm.component.props.id; &#125;); const curVm = instances[idx]; const removedHeight = curVm.el.offsetHeight; // debugger; const len = instances.length; for(let i=idx; i&lt;len; i++) &#123; const pos = parseInt(instances[i].el.style.top, 10) - removedHeight - 10; instances[i].component.props.offset = pos; &#125; instances.splice(idx, 1);&#125;export default message; 这里是全局调用$message时的逻辑，全局创建和销毁组件。 index.js12345import message from &apos;./message&apos;;message.install = (app) =&gt; &#123; app.config.globalProperties[&apos;$message&apos;] = message;&#125;export default message; 对外导出，在main.js中引入1234import Message from &apos;./components/message/index&apos;;let app = createApp(App);app = app.use(Message);app = app.mount(&apos;#app&apos;); 使用$messagevue3的setup函数中使用123import &#123; getCurrentInstance &#125; from &apos;vue&apos;;const &#123; proxy &#125; = getCurrentInstance();proxy.$message(&apos;message组件&apos;); 总结以上是vue3中全局调用组件的实现，vue2的实现也差不多，只是在创建组件，挂载，销毁时的api写法不一样，其它基本一致。vue3-messagevue2-message vue3中使用provide,inject上面使用的是app.config.globalProperties[&#39;$message&#39;] = message;这种方法，但是，vue3最新的api中已经淘汰了这种方法，建议使用provide,inject下面是一个新的例子，vue-router也是这么实现 定义插件1234567891011121314151617181920212223242526272829import &#123; inject &#125; from &apos;vue&apos;const watermark = &#123; set: () =&gt; &#123; console.log(&apos;set watermark&apos;) &#125;, show: () =&gt; &#123; console.log(&apos;show watermark&apos;) &#125;, hide: () =&gt; &#123; console.log(&apos;hide watermark&apos;) &#125;, clear: () =&gt; &#123; console.log(&apos;clear watermark&apos;) &#125;, install (app, options) &#123; const watermark = this app.config.globalProperties.$watermark = watermark app.provide(&apos;watermark&apos;, watermark) &#125;&#125;​const useWaterMark = function () &#123; return inject(&apos;watermark&apos;)&#125;​export &#123; watermark, useWaterMark&#125; 调用插件12345678910111213&lt;template&gt; &lt;div&gt; demo &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import HelloWorld from &apos;./components/HelloWorld.vue&apos;import &#123; getCurrentInstance &#125; from &apos;vue&apos;import &#123; useWaterMark &#125; from &apos;./plugin/watermark.js&apos;​const watermark = useWaterMark()watermark.hide()&lt;/script&gt; vue2中的$loadingloading.vue1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id=&quot;loading-wrap&quot; v-if=&quot;loading&quot;&gt; &lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot;&gt; &lt;span&gt;&#123;&#123; loadText &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; loading: true &#125; &#125;, props: [&apos;loadText&apos;], &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;#loading-wrap &#123; background-color: rgba(0,0,0,.7); position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 999; display: flex; align-items: center; justify-content: center; img &#123; flex-grow: 0; width: 100px; &#125; &#125;&lt;/style&gt; index.js1234567891011121314151617import loadVue from &apos;./loading.vue&apos;;export default &#123; install(Vue) &#123; let vEl; Vue.prototype._showloading = function(options = &#123;&#125;) &#123; vEl = new Vue(Object.assign(&#123;&#125;, loadVue, &#123; propsData: &#123; loadText: &apos;加载中...&apos; &#125; &#125;)) document.body.appendChild(vEl.$mount().$el); &#125; Vue.prototype._hideloading = function() &#123; document.body.removeChild(vEl.$mount().$el); &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"面试知识点之计算机操作系统","slug":"面试知识点之计算机操作系统","date":"2023-09-20T08:01:05.000Z","updated":"2024-01-11T07:00:59.293Z","comments":true,"path":"2023/09/20/面试知识点之计算机操作系统/","link":"","permalink":"/2023/09/20/面试知识点之计算机操作系统/","excerpt":"计算机操作系统","text":"计算机操作系统 计算机操作系统本部分主要是笔者在学习现代操作系统和一些相关面试题所做的笔记，如果出现错误，希望大家指出！ 现代操作系统阅读笔记第一章 引论1. 操作系统定义操作系统是运行在内核态的软件，它执行两个基本上独立的任务。 隐藏计算机底层硬件的实现，为用户及应用程序提供一个资源集的清晰抽象。 管理计算机硬件资源。 任何操作系统的核心是它可处理的系统调用集。这些系统调用集真实地说明了操作系统做的工作。 2. 计算机运行模式多数计算机有两种运行模式：内核态和用户态。 软件中最基础的部分是操作系统，它运行在内核态。这内核态模式下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下，在用户态下，只能使用机器指令中的一个子集。 3. shell 与 GUI用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（GUI）。 它们并不是操作系统的一部分，它们是运行在用户态最低层次的用户接口程序 4. 对于抽象的理解现代计算机系统中，大量使用了抽象这一概念。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其中第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。 以抽象的角度看操作系统，它的任务就是创建好的抽象，并实现和管理它所创建的抽象。 5. 多路复用资源方式在时间上复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。 在空间上复用：每个客户得到资源的一部分。 6. I/O 设备的结构I/O 设备一般包括两个部分：设备控制器和设备本身。控制器插在电路板上的一块芯片或一组芯片，这块电路板物理地控制芯片，它从操作系统接收命令。 控制器的任务是为操作系统提供一个简单的接口。每类设备控制器是不同的，所以需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。为了使用设备驱动程序，必须要把设备驱动程序装入到操作系统中，这样它可在核心态中运行。 每个设备控制器都有少量的用于通信的寄存器，所有的寄存器的集合构成了I/O 空间。 7. IDE 概念IDE 表示集成驱动电子设备，是许多计算机的磁盘标准。 8. 实现输入输出的三种方式第一种方式，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。当 I/O 结束后，设备驱动程序把数据送到指定的地方（若有此需要），并返回。然后操作系统将控制返回给调用者。这种方式称为忙等待（busy waiting），其缺点是要占据CPU ，CPU 一直轮询设备直到对应的 I/O 操作完成。 第二种方式，设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成。 第三种方式，为I/O使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预。 9. CMOS 存储器CMOS 存储器是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。 CMOS 存储器和递增时间的时钟电路有一块小电池驱动，所以，即使计算机没有上电，时间也可以正确地更新。 10. USB 概念USB 是通用串行总线，是用来将所有的慢速 I/O 设备，诸如键盘和鼠标，与计算机相连。USB 是一种集中式总线，其根设备每 1ms 轮询一次 I/O 设备，看是否有消息收发。所有的 USB 设备共享一个 USB 设备驱动器，于是就不需要为新的 USB 设备安装新的设备驱动器了。 11. 即插即用概念在一般的计算机工作环境下，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求导致了 Intel 和微软设计了一种名为即插即用的 I/O 系统。 在即插即用之前，每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。即插即用所做的工作是，系统自动地收集有关 I/O 设备的信息，集中赋予 I/O 地址，然后通知每块卡所用的数值。 12. 计算机的启动Pentium 的简要启动过程如下。在每个 Pentium 上有一块母板。在母板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序存放在一块闪速 RAM 中，它是非可易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。 简要过程如下： BIOS 开始运行。它首先检查计算机设备的状态信息是否正常。 扫描并记录总线所连设备。 依次搜索启动设备，导入操作系统。 操作系统询问 BIOS ，获得配置信息，获取所有设备的驱动程序并调入内核。 初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。 13. 操作系统分类大型机操作系统、服务器操作系统、多处理器操作系统、个人计算机操作系统、掌上计算机操作系统、嵌入式操作系统、传感器节点操作系统、实时操作系统、智能卡操作系统 14. 实时操作系统的基本概念实时操作系统的特征是将时间作为关键参数。通常分为硬实时操作系统和软实时操作系统。 在硬实时操作系统中，某个规定的动作必须绝对地在规定的时刻（或规定的时间范围）发生。 在软实时操作系统中，偶尔违反最终时限是不希望的，但可以接受，并且不会引起任何实时性的损害。 15. UID系统管理器授权每个进程使用一个给定的 UID 标识。每个被启动的进程都有一个启动该进程的用户 UID 。子进程与父进程拥有一样 UID。用户可以是某个组的成员，每个组也有一个 GID 标识。 16. 文件路径在 UNIX 中，绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用正斜线 / 隔开。最开始的正斜线标识这是从根目录开始的绝对路径。 在 MS-DOS 和 Windows 中，用反斜线 \\ 作为分隔符。 17. 文件系统安装UNIX 一个重要概念是安装文件系统。几乎所有的个人计算机都有一个或多个光盘驱动器，可以插入 CD-ROM 和 DV D。它们几乎都有 USB 接口，可以插入 USB 存储棒（实际是固态磁盘驱动器）。为了提供一个出色的方式处理可移动介质，UNIX 允许把在 CD-ROM 或 DVD 上的文件系统接入到主文件树上。 mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。 18. 特殊文件提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可通过同样的系统调用进行读写。 有两类特殊文件：块特殊文件和字符特殊文件。 块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第4块，程序可以直接访问设备的第4块而不必考虑存放该文件的文件系统结构。 字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在 /dev 目录中。例如，/dev/lp是打印机。 19. 文件保护UNIX 操作系统通过对每个文件赋予一个9位的二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个3位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的 rwx 位。 20. 系统调用概念如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。 21. POSIXUNIX 有很多不兼容的版本，从而导致了混乱。为了能使编写的程序能够在任何版本的 UNIX 系统运行，IEEE提出了一个 UNIX 标准，称为 POSIX，目前大多数 UNIX 版本都支持他。 POSIX 标准定义了凡是 UNIX 必须支持的小型系统调用接口。 22. Windows Win32 APIWindows 和 UNIX 的主要差别在于编程方式。一个 UNIX 程序包括做各种处理的代码以及从事完成特定服务的系统调用。相反，一个 Windows 程序通常是一个事件驱动程序。其中主程序等待某些事件发生，然后调用一个过程处理该事件。 在 UNIX 中，系统调用（如read）和系统调用所使用的库过程（如read）之间几乎是一一对应的关系。换句话说，对于每个系统调用，差不多就涉及一个被调用的库过程。 在 Windows 中，情况就大不相同了。首先，库调用和实际的系统调用是几乎不对应的。微软定义了一套过程，称为应用编程接口（Application Program Interface，Win32 API），程序员用这套过程获得操作系统的服务。 Win32 并不是非常统一的或有一致的接口。其主要原因是由于 Win32 需要与早期的在 Windows 3.x 中使用的16位接口向后兼容。 Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。 23. 操作系统结构单体结构、层次式结构、微内核、客户机-服务器模式、虚拟机、外核、 24. 微内核的概念在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。 25. 机制与策略分离原则策略指的是做什么，机制指的是怎么做。例如一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程以优先级）可以由用户态中的进程完成。在这个方式中，机制和策略是分离的，从而使系统内核变得更小。 26. make 程序在 UNIX 系统中，有个名为 make 的程序（其大量的变体如 gmake、pmake 等），它读入 Makefile ，该 Makefile 说明哪个文件与哪个文件相关。make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后，是否有任何它依赖（代码和头文件）的文件已经被修改了。如果有，目标文件需要重新编译。在大型项目中，创建 Makefile 是一件容易出错的工作，所以出现了一些工具使该工作能够自动完成。 第二章 进程与线程一、进程1. 进程模型在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。 由于CPU在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常也不可再现。所以，在对进程编程时决不能对时序做任何确定的假设。 2. 进程的创建有4种主要事件导致进程的创建： 系统初始化 启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反，却具有某些专门的功能。停留在后台处理诸如电子邮件、Web 页面、新闻、打印之类活动的进程称为守护进程 执行了正在运行的进程所调用的进程创建系统调用 一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以容易地划分成若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。 用户请求创建一个新进程 在交互式系统中，键入一个命令或者点（双）击一个图标就可以启动一个程序。这两个动作中的任何一个都会开始一个新的进程，并在其中运行所选择的程序。 一个批处理作业的初始化 最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中（可能是远程地）提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。 在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。 在 Windows 中，一个Win32函数调用 CreateProcess 既处理进程的创建，也负责把正确的程序装入新的进程。 在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。 3. 进程的终止进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起： 正常退出（自愿的） 多数进程是由于完成了它们的工作而终止。在 UNIX 中该调用是exit，而在 Windows 中，相关的调用是 ExitProcess 。 出错退出（自愿的） 进程终止的第二个原因是进程发现了严重错误。 严重错误（非自愿） 进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致。 被其他进程杀死（非自愿） 第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程。在 UNIX 中，这个系统调用是 kill 。在 Win32中对应的函数是 TerminateProcess 。 4. 进程的层次结构某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。 在 UNIX 中，进程和它的所有子女以及后裔共同组成一个进程组。 在 Windows 中没有进程层次的概念，所有的进程都是地位相同的。惟一类似于进程层次的暗示是在创建进程的时侯，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。 5. UNIX 启动时的初始化一个称为 init 的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。 6. 进程的状态进程存在三种状态： 运行态（该时刻进程实际占用CPU）。 就绪态（可运行，但因为其他进程正在运行而暂时停止）。 阻塞态（除非某种外部事件发生，否则进程不能运行）。 状态间的转化关系为 7. 进程的实现为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项。（也可称为进程控制块。）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。 8. 多道程序设计模型采用多道程序设计可以提高 CPU 的利用率。从概率的角度来看 CPU 的利用率。假设一个进程等待 I/O 操作的时间与其停留在内存中时间的比为p。当内存中同时有 n 个进程时，则所有 n 个进程都在等待 I/O（此时 CPU 空转）的概率是 pⁿ 。CPU 的利用率由下面的公式给出： CPU 利用率 = 1-pⁿ 二、线程1. 线程的使用原因人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。 第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。在许多系统中，创建一个线程较创建一个进程要快10～100倍。 需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。 2. 线程模型进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。 3. 在用户空间中实现线程把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。我们已经见过其中的四个过程：pthread_create ，pthread_exit ，pthread_join 和 pthread_yield 。不过，一般还会有更多的过程。 在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和内核中的进程表类似。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。 优点 用户级线程包可以在不支持线程的操作系统上实现。 线程的切换可以在几条指令内完成。进行类似于这样的线程切换至少比陷入内核要快一个数量级（或许更多）。 保存线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。 它允许每个进程有自己定制的调度算法。 缺点 第一个问题是如何实现阻塞系统调用。假设在还没有任何击键之前，一个线程读取键盘。让该线程实际进行该系统调用是不可接受的，因为这会停止所有的线程。 页面故障问题。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU 。 通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是CPU密集型而且极少有阻塞的应用程序而言，没有很大的意义。 4. 在内核中实现线程在内核中实现线程时，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。内核的线程表保存了每个线程的寄存器、状态和其他信息。 所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的 CPU （或者没有可运行的线程存在了）为止。 5. 混合实现人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。 采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。 6. 调度程序激活机制调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。 使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这个机制称为上行调用。一旦如此激活，运行时系统就重新调度其线程。 调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。 7. 弹出式线程一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。 弹出式线程的关键好处是，由于这种线程相当新，没有历史这样，就有可能快速创建这类线程。对该新线程指定所要处理的消息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。 三、 进程间通信进程间通信需要关注的三个问题： 一个进程如何把信息传递给另一个。 如何确保两个或更多的进程在关键活动中不会出现交叉。 正确的顺序。 1. 竞争条件两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。 2. 临界区在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。 对于保证使用共享数据的并发进程能够正确和高效地进行协作，一个好的解决方案，需要满足以下4个条件： 任何两个进程不能同时处于其临界区。 不应对CPU的速度和数量做任何假设。 临界区外运行的进程不得阻塞其他进程。 不得使进程无限期等待进入临界区。 3. 忙等待的互斥（1） 屏蔽中断在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。 缺点： 若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。 如果系统是多处理器（有两个或可能更多的处理器），则屏蔽中断仅仅对执行disable 指令的那个 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。 但是对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。 所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。 （2） 锁变量设想有一个共享（锁）变量，其初始值为0。当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该进程将等待直到其值变为0。于是，0就表示临界区内没有进程，1表示已经有某个进程进入临界区。 缺点：锁变量的读写不是原子操作，可能被其他进程中断 假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行，将该锁变量设置为1。当第一个进程再次能运行时，它同样也将该锁设置为1，则此时同时有两个进程进入临界区中。 （3）严格轮换法定义一个整型变量 turn ，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程0检查 turn ，发现其值为0，于是进入临界区。进程1也发现其值为0，所以在一个等待循环中不停地测试 turn ，看其值何时变为1。连续测试一个变量直到某个值出现为止，称为忙等待。 只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁（spin lock）。 缺点： 采用忙等待的方式，会浪费 CPU 时间。 该方案要求两个进程严格地轮流进入它们的临界区，会造成一个临界区外运行的进程阻塞其他进程的情况。 （4）Peterson 解法在使用共享变量（即进入其临界区）之前，各个进程使用其进程号0或1作为参数来调用 enter_region 。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 leave_region ，表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。 （5）TSL 指令TSL 指令是硬件支持的一种方案，称为测试并加锁，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。 读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。因此不会出现前面第二种方法锁变量的问题。 为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为0时，任何进程都可以使用 TSL 指令将其设置为1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为0。 一个可替代 TSL 的指令是 XCHG ，它原子性地交换了两个位置的内容，它本质上与 TSL 的解决办法一样。所有的Intel x86 CPU 在低层同步中使用 XCHG 指令。 缺点： 采用忙等待的方式，会浪费 CPU 时间。 4. 睡眠与唤醒Peterson 解法和 TSL 或 XCHG 解法都是正确的，但它们都有忙等待的缺点。这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。 我们可以使用睡眠与唤醒的机制，使它们在无法进入临界区时将阻塞，而不是忙等待。 最简单的是 sleep 和 wakeup 。 sleep 是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup 调用有一个参数，即要被唤醒的进程。 缺点： 参考生产者-消费者问题，发给一个（尚）未睡眠进程的 wakeup 信号会出现丢失，从而出现生产者和消费者同时睡眠的情况。 一种快速的弥补方法是修改规则，加上一个唤醒等待位。当一个 wakeup 信号发送给一个清醒的进程信号时，将该位置1。随后，当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒。但原则上讲，这并没有从根本上解决问题。 5. 信号量信号量是一个整型变量用来累计唤醒次数，供以后使用。一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。 对信号量一共有两种操作：down 和 up （分别为一般化后的 sleep 和 wakeup ）。 对一信号量执行 down 操作，则是检查其值是否大于0。若该值大于0，则将其值减1（即用掉一个保存的唤醒信号）并继续；若该值为0，则进程将睡眠，而且此时down操作并未结束。 对一信号量执行 up 操作，会对信号量的值增1。如果一个或多个进程在该信号量上睡眠，信号量的值仍旧是0，但在其上睡眠的进程会被唤醒一个。 检查数值、修改变量值以及可能发生的睡眠和唤醒操作均作为一个单一的、不可分割的原子操作完成。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。 6. 互斥量如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。 互斥量是一个可以处于两态之一的变量：解锁和加锁。当一个线程（或进程）需要访问临界区时，它调用 mutex_lock 。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用 mutex_unlock 。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。 enter_region 和 mutex_lock 的代码很相似，但有一个关键的区别。 当 enter_region 进入临界区失败时，它始终重复测试锁（忙等待）。实际上，由于时钟超时的作用，会调度其他进程运行。这样迟早拥有锁的进程会进入运行并释放锁。 在（用户）线程中，情形有所不同，因为没有时钟停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁。因此当 mutex_lock 取锁失败时，它调用 thread_yield 将 CPU 放弃给另一个线程。这样，就没有忙等待。在该线程下次运行时，它再一次对锁进行测试。 7. 条件变量条件变量允许线程由于一些未达到的条件而阻塞。 与条件变量相关的最重要的两个操作是 pthread_cond_wait 和 pthread_cond_signal 。前者阻塞调用线程直到另一其他线程向它发信号（使用后一个调用）。 条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。 8. 管程管程是一种高级同步原语，管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。 当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果 管程提供了一种实现互斥的简便途径，通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。 9. 消息传递这种进程间通信的方法使用两条原语 send 和 receive ，它们像信号量而不像管程，是系统调用而不是语言成分。 前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源（或者是任意源，如果接收者不介意的话）接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者，带着一个错误码立即返回。 10. 屏障在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。 四、调度当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序使用的算法称为调度算法。 1. 何时调度 在创建一个新进程之后，需要决定是运行父进程还是运行子进程。 在一个进程退出时必须做出调度决策。 当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。 第四，在一个 I/O 中断发生时，必须做出调度决策。 2. 调度算法分类 批处理。 交互式。 实时。 3. 调度算法的目标为了设计调度算法，有必要考虑什么是一个好的调度算法。某些目标取决于环境（批处理、交互式或实时），但是还有一些目标是适用于所有情形的。 4. 批处理系统中的调度（1）先来先服务在所有调度算法中，最简单的是非抢占式的先来先服务算法。使用该算法，进程按照它们请求 CPU 的顺序使用 CPU 。 优点： 这个算法的主要优点是易于理解并且便于在程序中运用。 缺点： 平均等待时间过长。 （2）最短作业优先当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先算法。 只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的。 （3）最短剩余时间优先最短作业优先的抢占式版本是最短剩余时间优先算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。 5. 交互式系统中的调度（1）轮转调度一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺 CPU 并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。 需要注意的是，时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20ms～50 ms通常是一个比较合理的折中。 （2）优先级调度每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这个动作导致该进程的优先级低于次高优先级的进程，则进行进程切换。 （3）多级队列将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用其他调度方式。 （4）最短进程优先对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互进程，那将是非常好的。 （5）保证调度向用户作出明确的性能保证，然后去实现它。 一种很实际并很容易实现的保证是：若用户工作时有 n 个用户登录，则用户将获得 CPU 处理能力的 1/n 。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。看上去足够公平了。 （6）彩票调度向进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。在应用到 CPU 调度时，系统可以掌握每秒钟50次的一种彩票，作为奖励每个获奖者可以得到20 ms 的 CPU 时间。 （7）公平分享调度到现在为止，我们假设被调度的都是各个进程自身，并不关注其所有者是谁。 为了避免这种情形，某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得50% CPU 时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。 6. 策略和机制我们讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。 解决问题的方法是将调度机制与调度策略分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。 在这里，调度机制位于内核，而调度策略则由用户进程决定。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"面试题系列","slug":"面试题系列","permalink":"/tags/面试题系列/"}]},{"title":"面试知识点之算法","slug":"面试知识点之算法","date":"2023-09-20T05:53:59.000Z","updated":"2024-01-11T07:00:59.292Z","comments":true,"path":"2023/09/20/面试知识点之算法/","link":"","permalink":"/2023/09/20/面试知识点之算法/","excerpt":"算法知识总结","text":"算法知识总结 算法知识总结本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！ 目录 常用算法和数据结构总结 排序 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 基数排序 快速排序相对于其他排序效率更高的原因 系统自带排序实现 稳定性 排序面试题目总结 树 二叉树相关性质 满二叉树 完全二叉树 平衡二叉查找树（AVL） B-树 B 树 数据库索引 红黑树 Huffman 树 二叉查找树 求解二叉树中两个节点的最近公共祖先节点 链表 反转单向链表 动态规划 爬楼梯问题 递归方法分析 备忘录方法 迭代法 经典笔试题 1. js 实现一个函数，完成超过范围的两个大整数相加功能 2. js 如何实现数组扁平化？ 3. js 如何实现数组去重？ 4. 如何求数组的最大值和最小值？ 5. 如何求两个数的最大公约数？ 6. 如何求两个数的最小公倍数？ 7. 实现 IndexOf 方法？ 8. 判断一个字符串是否为回文字符串？ 9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf() 10. 使用 reduce 方法实现 forEach、map、filter 11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3” 12. 如何查找一篇英文文章中出现频率最高的单词？ 常见面试智力题总结 1. 时针与分针夹角度数问题？ 2. 用3升，5升杯子怎么量出4升水？ 3. 浑浊药罐问题 4. 卡片证明问题 5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？ 6. 五队夫妇参加聚会握手问题 7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？ 8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？ 9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？ 10. 火车相对而行，小鸟飞行距离问题 11. 弹球拾取几率问题 12. 8个球使用天平称重问题 13. 三盏灯区分开关问题 14. 盲人黑白袜子问题 15. 水果标签问题 16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？ 17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？ 剑指 offer 思路总结 题目 1. 二维数组中的查找 2. 替换空格 3. 从尾到头打印链表 4. 重建二叉树 5. 用两个栈实现队列 6. 旋转数组的最小数字 7. 斐波那契数列 8. 跳台阶 9. 变态跳台阶 10. 矩形覆盖 11. 二进制中1的个数 12. 数值的整数次方 13. 调整数组顺序使奇数位于偶数前面 14. 链表中倒数第 k 个节点 15. 反转链表 16. 合并两个排序的链表 17. 树的子结构 18. 二叉树的镜像 19. 顺时针打印矩阵 20. 定义一个栈，实现 min 函数 21. 栈的压入弹出 22. 从上往下打印二叉树 23. 二叉搜索树的后序遍历 24. 二叉树中和为某一值路径 25. 复杂链表的复制 26. 二叉搜索树与双向链表 27. 字符串的排列 28. 数组中出现次数超过一半的数字 29. 最小的 K 个数 30. 连续子数组的最大和 31. 整数中1出现的次数（待深入理解） 32. 把数组排成最小的数 33. 丑数（待深入理解） 34. 第一个只出现一次的字符 35. 数组中的逆序对 36. 两个链表的第一个公共结点 37. 数字在排序数组中出现的次数 38. 二叉树的深度 39. 平衡二叉树 40. 数组中只出现一次的数字 41. 和为 S 的连续正数序列 42. 和为 S 的两个数字 43. 左旋转字符串 44. 翻转单词顺序列 45. 扑克牌的顺子 46. 圆圈中最后剩下的数字（约瑟夫环问题） 47. 1 2 3 … n 48. 不用加减乘除做加法 49. 把字符串转换成整数。 50. 数组中重复的数字 51. 构建乘积数组 52. 正则表达式的匹配 53. 表示数值的字符串 54. 字符流中第一个不重复的字符 55. 链表中环的入口结点 56. 删除链表中重复的结点 57. 二叉树的下一个结点 58. 对称二叉树 59. 按之字形顺序打印二叉树（待深入理解） 60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 61. 序列化二叉树（待深入理解） 62. 二叉搜索树的第 K 个节点 63. 数据流中的中位数（待深入理解） 64. 滑动窗口中的最大值（待深入理解） 65. 矩阵中的路径（待深入理解） 66. 机器人的运动范围（待深入理解） 相关算法题 1. 明星问题 2. 正负数组求和 常用算法和数据结构总结排序冒泡排序冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。 代码实现： 12345678910111213141516function bubbleSort(arr) &#123; if (!Array.isArray(arr) || arr.length &lt;= 1) return; let lastIndex = arr.length - 1; while (lastIndex &gt; 0) &#123; // 当最后一个交换的元素为第一个时，说明后面全部排序完毕 let flag = true, k = lastIndex; for (let j = 0; j &lt; k; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = false; lastIndex = j; // 设置最后一次交换元素的位置 [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; if (flag) break; &#125;&#125; 冒泡排序有两种优化方式。 一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。因此我们不需要再执行之后的外层循环，此时可以直接结束。 一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下一轮循环中无需再去比较。 优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。 冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。 详细资料可以参考：《图解排序算法(一)》《常见排序算法 - 鸡尾酒排序 》《前端笔试&amp;面试爬坑系列—算法》《前端面试之道》 选择排序选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。 在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。 代码实现： 123456789101112131415161718192021222324252627282930313233function selectSort(array) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 if (!Array.isArray(array) || length &lt;= 1) return; for (let i = 0; i &lt; length - 1; i++) &#123; let minIndex = i; // 设置当前循环最小元素索引 for (let j = i + 1; j &lt; length; j++) &#123; // 如果当前元素比最小元素索引，则更新最小元素索引 if (array[minIndex] &gt; array[j]) &#123; minIndex = j; &#125; &#125; // 交换最小元素到当前位置 // [array[i], array[minIndex]] = [array[minIndex], array[i]]; swap(array, i, minIndex); &#125; return array;&#125;// 交换数组中两个元素的位置function swap(array, left, right) &#123; var temp = array[left]; array[left] = array[right]; array[right] = temp;&#125; 选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。 选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。 详细资料可以参考：《图解排序算法(一)》 插入排序直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。 插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间….依次 代码实现： 123456789101112131415161718192021222324function insertSort(array) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 if (!Array.isArray(array) || length &lt;= 1) return; // 循环从 1 开始，0 位置为默认的已排序的序列 for (let i = 1; i &lt; length; i++) &#123; let temp = array[i]; // 保存当前需要排序的元素 let j = i; // 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置 while (j -1 &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; // 将找到的位置插入元素 array[j] = temp; &#125; return array;&#125; 当排序序列为已排序序列时，为最好的时间复杂度 O(n)。 插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。 详细资料可以参考：《图解排序算法(一)》 希尔排序希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。 代码实现： 1234567891011121314151617181920212223242526function hillSort(array) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 if (!Array.isArray(array) || length &lt;= 1) return; // 第一层确定增量的大小，每次增量的大小减半 for (let gap = parseInt(length &gt;&gt; 1); gap &gt;= 1; gap = parseInt(gap &gt;&gt; 1)) &#123; // 对每个分组使用插入排序，相当于将插入排序的1换成了 n for (let i = gap; i &lt; length; i++) &#123; let temp = array[i]; let j = i; while (j - gap &gt;= 0 &amp;&amp; array[j - gap] &gt; temp) &#123; array[j] = array[j - gap]; j -= gap; &#125; array[j] = temp; &#125; &#125; return array;&#125; 希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。 简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。 希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。 插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，所以希尔排序是一个不稳定的排序。 希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。 详细资料可以参考：《图解排序算法(二)之希尔排序》《数据结构基础 希尔排序 之 算法复杂度浅析》 归并排序归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后将数组排序合并，最终合并为排序好的数组。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function mergeSort(array) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于0，直接返回，不需要排序 if (!Array.isArray(array) || length === 0) return; if (length === 1) &#123; return array; &#125; let mid = parseInt(length &gt;&gt; 1), // 找到中间索引值 left = array.slice(0, mid), // 截取左半部分 right = array.slice(mid, length); // 截取右半部分 return merge(mergeSort(left), mergeSort(right)); // 递归分解后，进行排序合并&#125;function merge(leftArray, rightArray) &#123; let result = [], leftLength = leftArray.length, rightLength = rightArray.length, il = 0, ir = 0; // 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止 while (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123; if (leftArray[il] &lt; rightArray[ir]) &#123; result.push(leftArray[il++]); &#125; else &#123; result.push(rightArray[ir++]); &#125; &#125; // 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。 while (il &lt; leftLength) &#123; result.push(leftArray[il++]); &#125; // 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。 while (ir &lt; rightLength) &#123; result.push(rightArray[ir++]); &#125; return result;&#125; 归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。 归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归并排序的空间复杂度为 O(n)。 归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。 详细资料可以参考：《图解排序算法(四)之归并排序》《归并排序的空间复杂度？》 快速排序快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function quickSort(array, start, end) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 if (!Array.isArray(array) || length &lt;= 1 || start &gt;= end) return; let index = partition(array, start, end); // 将数组划分为两部分，并返回右部分的第一个元素的索引值 quickSort(array, start, index - 1); // 递归排序左半部分 quickSort(array, index + 1, end); // 递归排序右半部分&#125;function partition(array, start, end) &#123; let pivot = array[start]; // 取第一个值为枢纽值，获取枢纽值的大小 // 当 start 等于 end 指针时结束循环 while (start &lt; end) &#123; // 当 end 指针指向的值大等于枢纽值时，end 指针向前移动 while (array[end] &gt;= pivot &amp;&amp; start &lt; end) &#123; end--; &#125; // 将比枢纽值小的值交换到 start 位置 array[start] = array[end]; // 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动 while (array[start] &lt; pivot &amp;&amp; start &lt; end) &#123; start++; &#125; // 将比枢纽值大的值交换到 end 位置，进入下一次循环 array[end] = array[start]; &#125; // 将枢纽值交换到中间点 array[start] = pivot; // 返回中间索引值 return start;&#125; 这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递归左右两边的的序列。 当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。 当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。 快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。 快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。 详细资料可以参考：《图解排序算法(五)之快速排序——三数取中法》《关于快速排序的四种写法》《快速排序的时间和空间复杂度》《快速排序最好，最坏，平均复杂度分析》《快速排序算法的递归深度》 堆排序堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function heapSort(array) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 if (!Array.isArray(array) || length &lt;= 1) return; buildMaxHeap(array); // 将传入的数组建立为大顶堆 // 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆 for (let i = length - 1; i &gt; 0; i--) &#123; swap(array, 0, i); adjustMaxHeap(array, 0, i); // 将剩下的元素重新构建为大顶堆 &#125; return array;&#125;function adjustMaxHeap(array, index, heapSize) &#123; let iMax, iLeft, iRight; while (true) &#123; iMax = index; // 保存最大值的索引 iLeft = 2 * index + 1; // 获取左子元素的索引 iRight = 2 * index + 2; // 获取右子元素的索引 // 如果左子元素存在，且左子元素大于最大值，则更新最大值索引 if (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; // 如果右子元素存在，且右子元素大于最大值，则更新最大值索引 if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; // 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树 if (iMax !== index) &#123; swap(array, index, iMax); index = iMax; &#125; else &#123; // 如果未被更新，说明该子树满足大顶堆的要求，退出循环 break; &#125; &#125;&#125;// 构建大顶堆function buildMaxHeap(array) &#123; let length = array.length, iParent = parseInt(length &gt;&gt; 1) - 1; // 获取最后一个非叶子点的元素 for (let i = iParent; i &gt;= 0; i--) &#123; adjustMaxHeap(array, i, length); // 循环调整每一个子树，使其满足大顶堆的要求 &#125;&#125;// 交换数组中两个元素的位置function swap(array, i, j) &#123; let temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在不管什么情况下都是 O(nlogn)。 堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。 详细资料可以参考：《图解排序算法(三)之堆排序》《常见排序算法 - 堆排序 (Heap Sort)》《堆排序中建堆过程时间复杂度O(n)怎么来的？》《排序算法之 堆排序 及其时间复杂度和空间复杂度》《最小堆 构建、插入、删除的过程图解》 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function radixSort(array) &#123; let length = array.length; // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 if (!Array.isArray(array) || length &lt;= 1) return; let bucket = [], max = array[0], loop; // 确定排序数组中的最大值 for (let i = 1; i &lt; length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // 确定最大值的位数 loop = (max + '').length; // 初始化桶 for (let i = 0; i &lt; 10; i++) &#123; bucket[i] = []; &#125; for (let i = 0; i &lt; loop; i++) &#123; for (let j = 0; j &lt; length; j++) &#123; let str = array[j] + ''; if (str.length &gt;= i + 1) &#123; let k = parseInt(str[str.length - 1 - i]); // 获取当前位的值，作为插入的索引 bucket[k].push(array[j]); &#125; else &#123; // 处理位数不够的情况，高位默认为 0 bucket[0].push(array[j]); &#125; &#125; array.splice(0, length); // 清空旧的数组 // 使用桶重新初始化数组 for (let i = 0; i &lt; 10; i++) &#123; let t = bucket[i].length; for (let j = 0; j &lt; t; j++) &#123; array.push(bucket[i][j]); &#125; bucket[i] = []; &#125; &#125; return array;&#125; 基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定排序。 详细资料可以参考：《常见排序算法 - 基数排序》《排序算法之 基数排序 及其时间复杂度和空间复杂度》 算法总结可以参考：《算法的时间复杂度和空间复杂度-总结》《十大经典排序算法（动图演示）》《各类排序算法的对比及实现》 快速排序相对于其他排序效率更高的原因上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同数据量的情况下，它的运算效率最高，并且它额外所需空间最小。 我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？ 首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因此归并排序首先就被排除掉了。 接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。 第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。 第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其他的因素。 相关资料可以参考：《为什么在平均情况下快速排序比堆排序要优秀？》《为什么说快速排序是性能最好的排序算法？》 系统自带排序实现每个语言的排序内部实现都是不同的。 对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。 稳定性稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。 稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个&lt;ul&gt;列表进行渲染，当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。 排序面试题目总结 快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。 初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。 合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。 外部排序常用的算法是归并排序。 数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。 如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。 插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。 对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。 下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。 拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。 任何一个基于”比较”的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!，时间下界为 O(nlogn) m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3 对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。 在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e) 树二叉树相关性质 节点的度：一个节点含有的子树的个数称为该节点的度； 叶节点或终端节点：度为零的节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 树的高度或深度：树中节点的最大层次。 在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i&gt;=1。 深度为 h 的二叉树最多有 2^h-1个结点(h&gt;=1)，最少有 h 个结点。 对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1； 给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。 二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。 二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。 一个带权的无向连通图的最小生成树的权值之和是唯一的。 只有一个结点的二叉树的度为 0 。 二叉树的度是以节点的最大的度数定义的。 树的后序遍历序列等同于该树对应的二叉树的中序序列。 树的先序遍历序列等同于该树对应的二叉树的先序序列。 线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列：debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。 递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，也就是深度d！=logn，有可能d&gt;&gt;logn。所以栈大小应该是O（d） 一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。 引入二叉线索树的目的是加快查找结点的前驱或后继的速度。 二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。 不管是几叉树，节点数等于=分叉数+1 任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。 详细资料可以参考：《n 个节点的二叉树有多少种形态》《数据结构二叉树知识点总结》《还原二叉树–已知先序中序或者后序中序》《树、森林与二叉树的转换》 满二叉树对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满二叉树。 完全二叉树对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。 性质： 具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数) 有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则如果 I&gt;1，则其父结点的编号为 I/2； 完全二叉树，如果 2 I &lt;= N，则其左儿子（即左子树的根结点）的编号为2 I；若2 I &gt; N，则无左儿子；如果 2 I + 1 &lt;= N，则其右儿子的结点编号为 2 I + 1；若 2 I + 1 &gt; N，则无右儿子。 平衡二叉查找树（AVL）平衡二叉查找树具有如下几个性质： 可以是空树。 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。 平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有一点帮帮助，反而增加了维护的成本。 平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。 详细资料可以参考：《平衡二叉树，AVL树之图解篇》 B-树B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少索引树的高度是提高索引效率的关键。 B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。 详细资料可以参考：《漫画：什么是 B- 树？》 B+树B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。 详细资料可以参考：《漫画：什么是 B+ 树？》 数据库索引数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。 相关资料可以参考：《深入浅出数据库索引原理》《数据库的最简单实现》 红黑树红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子节点的最长路径不会超过最短路径的两倍。 红黑树的有具体的规则： 1.节点是红色或黑色。 2.根节点是黑色。 3.每个叶子节点都是黑色的空节点（NIL节点）。 4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。 详细资料可以参考：《漫画：什么是红黑树？》《漫画算法等精选文章目录》 Huffman 树给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为 Huffman 树。 利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码不是另一个字符编码的前缀。 性质： 对应一组权重构造出来的 Huffman 树一般不是唯一的 Huffman 树具有最小的带权路径长度 Huffman 树中没有度为1的结点 哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近 Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和 详细资料可以参考： 《数据结构和算法—— Huffman 树和 Huffman 编码》《详细图解哈夫曼 Huffman 编码树》 二叉查找树二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。 实现树节点类： 123456789101112// 节点类，树的节点class Node &#123; constructor(value) &#123; this.value = value; this.left = null; this.right = null; &#125; show() &#123; console.log(this.value); &#125;&#125; 实现二叉查找树类： 1234567class BinarySearchTree &#123; constructor() &#123; this.root = null &#125;&#125; 实现树的节点插入方法 节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。循环这个过程直到找到合适的插入位置。 12345678910111213141516171819202122232425262728293031insert(value) &#123; let newNode = new Node(value); // 判断根节点是否为空，如果不为空则递归插入到树中 if (this.root === null) &#123; this.root = newNode; &#125; else &#123; this.insertNode(this.root, newNode); &#125;&#125;insertNode(node, newNode) &#123; // 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。 if (newNode.value &lt; node.value) &#123; if (node.left === null) &#123; node.left = newNode; &#125; else &#123; this.insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; this.insertNode(node.right, newNode); &#125; &#125;&#125; 通过递归实现树的先序、中序、后序遍历 1234567891011121314151617181920212223242526272829303132333435363738394041// 先序遍历通过递归实现// 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。 preOrderTraverse() &#123; this.preOrderTraverseNode(this.root); &#125; preOrderTraverseNode(node) &#123; if (node !== null) &#123; node.show(); this.preOrderTraverseNode(node.left); this.preOrderTraverseNode(node.right); &#125; &#125; // 中序遍历通过递归实现 // 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。 inOrderTraverse() &#123; this.inOrderTraverseNode(this.root); &#125; inOrderTraverseNode(node) &#123; if (node !== null) &#123; this.inOrderTraverseNode(node.left); node.show(); this.inOrderTraverseNode(node.right); &#125; &#125; // 后序遍历通过递归实现 // 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。 postOrderTraverse() &#123; this.postOrderTraverseNode(this.root); &#125; postOrderTraverseNode(node) &#123; if (node !== null) &#123; this.postOrderTraverseNode(node.left); this.postOrderTraverseNode(node.right); node.show(); &#125; &#125; 通过循环实现树的先序、中序、后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 先序遍历通过循环实现// 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将// 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。preOrderTraverseByStack() &#123; let stack = []; // 现将根节点入栈，开始遍历 stack.push(this.root); while (stack.length &gt; 0) &#123; // 从栈中获取当前节点 let node = stack.pop(); // 执行节点操作 node.show(); // 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根 // 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的 if (node.right) &#123; stack.push(node.right); &#125; if (node.left) &#123; stack.push(node.left); &#125; &#125;&#125;// 中序遍历通过循环实现// 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有// 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。inOrderTraverseByStack() &#123; let stack = [], node = this.root; // 中序遍历是先左再根最后右 // 所以首先应该先把最左边节点遍历到底依次 push 进栈 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点 while (stack.length &gt; 0 || node) &#123; if (node) &#123; stack.push(node); node = node.left; &#125; else &#123; node = stack.pop(); node.show(); node = node.right; &#125; &#125;&#125;// 后序遍历通过循环来实现// 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次// 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。postOrderTraverseByStack() &#123; let stack1 = [], stack2 = [], node = null; // 后序遍历是先左再右最后根 // 所以对于一个栈来说，应该先 push 根节点 // 然后 push 右节点，最后 push 左节点 stack1.push(this.root); while (stack1.length &gt; 0) &#123; node = stack1.pop(); stack2.push(node); if (node.left) &#123; stack1.push(node.left); &#125; if (node.right) &#123; stack1.push(node.right); &#125; &#125; while (stack2.length &gt; 0) &#123; node = stack2.pop(); node.show(); &#125;&#125; 实现寻找最大最小节点值 12345678910111213141516171819202122// 寻找最小值，在最左边的叶子节点上 findMinNode(root) &#123; let node = root; while (node &amp;&amp; node.left) &#123; node = node.left; &#125; return node; &#125; // 寻找最大值，在最右边的叶子节点上 findMaxNode(root) &#123; let node = root; while (node &amp;&amp; node.right) &#123; node = node.right; &#125; return node; &#125; 实现寻找特定大小节点值 123456789101112131415161718// 寻找特定值find(value) &#123; return this.findNode(this.root, value);&#125;findNode(node, value) &#123; if (node === null) &#123; return node; &#125; if (value &lt; node.value) &#123; return this.findNode(node.left, value); &#125; else if (value &gt; node.value) &#123; return this.findNode(node.right, value); &#125; else &#123; return node; &#125;&#125; 实现移除节点值 移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。 123456789101112131415161718192021222324252627282930313233343536373839404142// 移除指定值节点remove(value) &#123; this.removeNode(this.root, value);&#125;removeNode(node, value) &#123; if (node === null) &#123; return node; &#125; // 寻找指定节点 if (value &lt; node.value) &#123; node.left = this.removeNode(node.left, value); return node; &#125; else if (value &gt; node.value) &#123; node.right = this.removeNode(node.right, value); return node; &#125; else &#123; // 找到节点 // 第一种情况——没有叶节点 if (node.left === null &amp;&amp; node.right === null) &#123; node = null; return node; &#125; // 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点 if (node.left === null) &#123; node = node.right; return node; &#125; else if (node.right === null) &#123; node = node.left; &#125; // 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点 // 的值，保持树的特性，然后将替换的节点去掉 let aux = this.findMinNode(node.right); node.value = aux.value; node.right = this.removeNode(node.right, aux); return node; &#125;&#125; 求解二叉树中两个节点的最近公共祖先节点1234567891011121314151617求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑（1）该二叉树为搜索二叉树 解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于 根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个 节点的值小时，该节点则为两个节点的最近公共祖先节点。（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。 通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点 的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。 这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同 的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。 详细资料可以参考：《二叉树中两个节点的最近公共祖先节点》 链表反转单向链表需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题。 思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。 12345678910111213141516171819var reverseList = function(head) &#123; // 判断下变量边界问题 if (!head || !head.next) return head; // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null let pre = null; let current = head; let next; // 判断当前节点是否为空 // 不为空就先获取当前节点的下一节点 // 然后把当前节点的 next 设为上一个节点 // 然后把 current 设为下一个节点，pre 设为当前节点 while(current) &#123; next = current.next; current.next = pre; pre = current; current = next; &#125; return pre;&#125;; 动态规划爬楼梯问题有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？ 递归方法分析由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到2级阶梯的走法数量。 代码实现12345678910111213141516function getClimbingWays(n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; if (n === 2) &#123; return 2; &#125; return getClimbingWays(n - 1) + getClimbingWays(n - 2);&#125; 使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度为递归的深度 O(logn)。 备忘录方法分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。 代码实现123456789101112131415161718192021222324let map = new Map();function getClimbingWays(n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; if (n === 2) &#123; return 2; &#125; if (map.has(n)) &#123; return map.get(n); &#125; else &#123; let value = getClimbingWays(n - 1) + getClimbingWays(n - 2); map.set(n, value); return value; &#125;&#125; 通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n) 迭代法通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。 代码实现1234567891011121314151617181920212223242526function getClimbingWays(n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; if (n === 2) &#123; return 2; &#125; let a = 1, b = 2, temp = 0; for (let i = 3; i &lt;= n; i++) &#123; temp = a + b; a = b; b = temp; &#125; return temp;&#125; 通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。 详细资料可以参考：《漫画：什么是动态规划？（整合版）》 经典笔试题1. js 实现一个函数，完成超过范围的两个大整数相加功能 123456789101112131415161718192021222324252627主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。function bigNumberAdd(number1, number2) &#123; let result = \"\", // 保存最后结果 carry = false; // 保留进位结果 // 将字符串转换为数组 number1 = number1.split(\"\"); number2 = number2.split(\"\"); // 当数组的长度都变为0，并且最终不再进位时，结束循环 while (number1.length || number2.length || carry) &#123; // 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0 carry += ~~number1.pop() + ~~number2.pop(); // 取加法结果的个位加入最终结果 result = carry % 10 + result; // 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0 carry = carry &gt; 9; &#125; // 返回最终结果 return result;&#125; 详细资料可以参考： 《JavaScript实现超范围的数相加》 《js 实现大整数加法》 2. js 如何实现数组扁平化？ 1234567891011121314151617181920212223242526272829303132333435363738 // 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好 function flattenArray(array) &#123; if (!Array.isArray(array)) return; let result = []; result = array.reduce(function (pre, item) &#123; // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中 return pre.concat(Array.isArray(item) ? flattenArray(item) : item); &#125;, []); return result; &#125; //使用递归的形式进行数组打平 function flatArray(arr)&#123; let result = []; function flat(arr)&#123; arr.forEach(element =&gt; &#123; if(Array.isArray(element))&#123; flat(element); &#125;else&#123; result.push(element); &#125; &#125;); &#125; flat(arr); return result;&#125; // 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况 function flattenArray(array) &#123; return array.toString().split(\",\").map(function (item) &#123; return JSON.parse(item); &#125;) &#125; 详细资料可以参考： 《JavaScript专题之数组扁平化》 3. js 如何实现数组去重？ 1234567891011121314151617181920function unique(array) &#123; if (!Array.isArray(array) || array.length &lt;= 1) return; var result = []; array.forEach(function (item) &#123; if (result.indexOf(item) === -1) &#123; result.push(item); &#125; &#125;) return result;&#125;function unique(array) &#123; if (!Array.isArray(array) || array.length &lt;= 1) return; return [...new Set(array)];&#125; 详细资料可以参考： 《JavaScript专题之数组去重》 4. 如何求数组的最大值和最小值？ 12var arr = [6, 4, 1, 8, 2, 11, 23];console.log(Math.max.apply(null, arr)) 详细资料可以参考： 《JavaScript专题之如何求数组的最大值和最小值》 5. 如何求两个数的最大公约数？ 12345678基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，直到余数为0时，最后的被除数就是两个数的最大公约数。function getMaxCommonDivisor(a, b) &#123; if (b === 0) return a; return getMaxCommonDivisor(b, a % b);&#125; 6. 如何求两个数的最小公倍数？ 12345基本思想是采用将两个数相乘，然后除以它们的最大公约数function getMinCommonMultiple(a, b)&#123; return a * b / getMaxCommonDivisor(a, b);&#125; 详细资料可以参考： 《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》 7. 实现 IndexOf 方法？ 12345678910111213function indexFun(array, val) &#123; if (!Array.isArray(array)) return; let length = array.length; for (let i = 0; i &lt; length; i++) &#123; if (array[i] === val) &#123; return i; &#125; &#125; return -1;&#125; 8. 判断一个字符串是否为回文字符串？ 1234567function isPalindrome(str) &#123; let reg = /[\\W_]/g, // 匹配所有非单词的字符以及下划线 newStr = str.replace(reg, \"\").toLowerCase(), // 替换为空字符并将大写字母转换为小写 reverseStr = newStr.split(\"\").reverse().join(\"\"); // 将字符串反转 return reverseStr === newStr;&#125; 9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf() 1234567891011121314151617181920212223function sum(...args) &#123;let result = 0;result = args.reduce(function (pre, item) &#123; return pre + item;&#125;, 0);let add = function (...args) &#123; result = args.reduce(function (pre, item) &#123; return pre + item; &#125;, result); return add;&#125;;add.valueOf = function () &#123; console.log(result);&#125;return add;&#125; 10. 使用 reduce 方法实现 forEach、map、filter 1234567891011121314151617181920212223242526272829303132// forEachfunction forEachUseReduce(array, handler) &#123; array.reduce(function (pre, item, index) &#123; handler(item, index); &#125;, null);&#125;// mapfunction mapUseReduce(array, handler) &#123; let result = []; array.reduce(function (pre, item, index) &#123; let mapItem = handler(item, index); result.push(mapItem); &#125;, null); return result;&#125;// filterfunction filterUseReduce(array, handler) &#123; let result = []; array.reduce(function (pre, item, index) &#123; if (handler(item, index)) &#123; result.push(item); &#125; &#125;, null); return result;&#125; 11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3” 123456789101112131415161718192021class Queue &#123; constructor() &#123; this.queue = []; this.time = 0; &#125; addTask(task, t) &#123; this.time += t; this.queue.push([task, this.time]); return this; &#125; start() &#123; this.queue.forEach(item =&gt; &#123; setTimeout(() =&gt; &#123; item[0](); &#125;, item[1]); &#125;) &#125;&#125; 12. 如何查找一篇英文文章中出现频率最高的单词？ 12345678910111213141516171819202122232425262728293031function findMostWord(article) &#123;// 合法性判断if (!article) return;// 参数处理article = article.trim().toLowerCase();let wordList = article.match(/[a-z]+/g), visited = [], maxNum = 0, maxWord = \"\";article = \" \" + wordList.join(\" \") + \" \";// 遍历判断单词出现次数wordList.forEach(function (item) &#123; if (visited.indexOf(item) &lt; 0) &#123; let word = new RegExp(\" \" + item + \" \", \"g\"), num = article.match(word).length; if (num &gt; maxNum) &#123; maxNum = num; maxWord = item; &#125; &#125;&#125;);return maxWord + \" \" + maxNum;&#125; 常见面试智力题总结1. 时针与分针夹角度数问题？ 分析： 123456789当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。时针每走一格为 30 度。因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; 答案： 1因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; 详细资料参考： 《面试智力题 — 时针与分针夹角度数问题》 2. 用3升，5升杯子怎么量出4升水？ 12345（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。 3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？ 12345678由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4 片药片。（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。 4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？ 1我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。 5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？ 1234567891011我认为一共至少需要 7 次才能选出最快的三匹马。（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直 接淘汰掉，那么我们现在还剩下了 15 匹马。（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余 马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了， 它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马， 它们都有竞争最快第二第三的机会。（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。 6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？ 1234567891011121314151617（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因 此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有 他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手 ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数 为 1 的人是配偶。（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。 7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？ 1234（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路 程。 8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？ 123456789一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。 （1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。 9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？ 12345（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。 10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？ 12由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。 11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？ 1第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法 12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？ 123456最少两次可以称出。首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。 13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？ 123（1）首先打开一盏灯 10 分钟，然后打开第二盏。（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开 的。 14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？ 1将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。 15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。 12345从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。对应水果标签的筐的标签改为另一种水果。另一种水果标签的框改为混合。 16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？ 123456（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多 90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。因此三种球都喜欢的人占比为 10%-60% 17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？ 1五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。 更多的智力题可以参考： 《经典面试智力题200+题和解答》 剑指 offer 思路总结本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！ 题目1. 二维数组中的查找 1234567891011题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动 ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。 2. 替换空格 1234567891011题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy思路：使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”str.replace(/\\s/g,&quot;%20&quot;) 3. 从尾到头打印链表 123456789题目：输入一个链表，从尾到头打印链表每个节点的值。思路：利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的实现可以利用 Array 的 push 和 pop 方法来模拟。 4. 重建二叉树 1234567891011题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。思路：利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的时间复杂度为 O(n)，空间复杂度为 O(logn)。 5. 用两个栈实现队列 1234567891011121314题目：用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。思路：队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。扩展：当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。 6. 旋转数组的最小数字 12345678910111213题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。思路：（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相 邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。（2）二分法 相关资料可以参考： 《旋转数组的最小数字》 7. 斐波那契数列 123456789题目：大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39思路：斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。 8. 跳台阶 12345678910题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。思路：跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。 9. 变态跳台阶 12345678910111213141516171819题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。思路：变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。f(1) = 1f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。f(3) = f(3-1) + f(3-2) + f(3-3) ...f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 再次总结可得 | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2*f(n-1),(n&gt;=2) 10. 矩形覆盖 123456789题目：我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？思路：依旧是斐波那契数列的应用 11. 二进制中1的个数 123456789101112题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。思路：一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判断这个数可以经历多少次这样的过程。如：1100&amp;1011=1000 12. 数值的整数次方 12345678题目：给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。思路：首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 13. 调整数组顺序使奇数位于偶数前面 1234567891011题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。思路：由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间复杂度为 O(n)。 14. 链表中倒数第 k 个节点 123456789题目：输入一个链表，输出该链表中倒数第 k 个结点。思路：使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。 15. 反转链表 12345678910题目：输入一个链表，反转链表后，输出链表的所有元素。思路：通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 next 节点，实现下一次循环。 16. 合并两个排序的链表 1234567题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。思路：通过递归的方式，依次将两个链表的元素递归进行对比。 17. 树的子结构 12345678910题目：输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）思路：通过递归的思想来解决第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。 18. 二叉树的镜像 1234567题目：操作给定的二叉树，将其变换为源二叉树的镜像。 思路：从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。 19. 顺时针打印矩阵 12345678910111213141516题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10思路：（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一 次需要打印的数据范围。（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。 20. 定义一个栈，实现 min 函数 123456789题目：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。思路：使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小的值。 21. 栈的压入弹出 123456789101112题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）思路：我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。 22. 从上往下打印二叉树 123456789题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。思路：本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。 23. 二叉搜索树的后序遍历 1234567891011题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两个数字都互不相同。思路：对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我们可以利用这些特点来递归判断。 24. 二叉树中和为某一值路径 123456789题目：输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。思路：通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。 25. 复杂链表的复制 123456789101112131415161718题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）思路：（1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。（2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复 制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此 不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。（3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行 random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点 。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。 26. 二叉搜索树与双向链表 12345678910111213题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。思路：需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序序列。基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。 27. 字符串的排列 12345678910题目：输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。思路：我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。 详细资料可以参考： 《字符串的排列》 28. 数组中出现次数超过一半的数字 1234567891011121314151617181920题目：数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。思路：（1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为 O(nlogn)。（2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中 位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随 机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字 便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之 在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。（3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数 字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果 次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大， 则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。 详细资料可以参考： 《出现次数超过一半的数字》 29. 最小的 K 个数 123456789101112131415161718192021题目：输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。思路：（1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂 度，最好的情况下为 O(nlogn)。（2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢 纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢 纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划 分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平 均时间复杂度为 O(n)。（3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这 就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最 大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一 种方法的平均时间复杂度为 O(nlogk)。 详细资料可以参考： 《寻找最小的 k 个数》 30. 连续子数组的最大和 1234567891011121314151617题目：HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？例如：&#123;6,-3,-2,7,-15,1,2,2&#125;，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠住？（子向量的长度至少是1）思路：（1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首 往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。（2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。 因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负 数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。 使用这一种方法的时间复杂度为 O(n)。 详细资料可以参考： 《连续子数组的最大和》 31. 整数中1出现的次数（待深入理解） 1234567891011题目：求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整数区间中1出现的次数。思路：（1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。（2）第二种思路是求出1出现在每位上的次数，然后进行叠加。 详细资料可以参考： 《从1到n整数中1出现的次数：O(logn)算法》 32. 把数组排成最小的数 123456789101112题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。思路：（1）求出数组的全排列，然后对每个排列结果进行比较。（2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的 结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。 详细资料可以参考： 《把数组排成最小的数》 33. 丑数（待深入理解） 123456789101112题目：把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。思路：（1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以 5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。（2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。 34. 第一个只出现一次的字符 123456789101112题目：在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。思路：（1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这 一种方法的时间复杂度为 O(n^2)。（2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时 ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。 35. 数组中的逆序对 1234567891011121314题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 P。思路：（1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果 后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比 较，因此这个算法的时间复杂度是 O(n^2)。（2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂 度为 O(nlogn)。 详细资料可以参考： 《数组中的逆序对》 36. 两个链表的第一个公共结点 1234567891011121314151617题目：输入两个链表，找出它们的第一个公共结点。思路：（1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二 个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一 个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。（2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈 ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这 一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。（3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个 指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动， 判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。 详细资料可以参考： 《两个链表的第一个公共结点》 37. 数字在排序数组中出现的次数 1234567891011121314151617题目：统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出现了 4 次，因此输出 4 。思路：（1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。（2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要 去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束 位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如 果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值 是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们 下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结 束位置。这一种方法的平均时间复杂度为 O(logn)。 38. 二叉树的深度 123456789题目：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。思路：根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。 39. 平衡二叉树 123456789101112题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。思路：（1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它 就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。（2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深 度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。 40. 数组中只出现一次的数字 1234567891011121314题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。思路：（1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。（2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中 的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下 的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和 B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会 被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。 41. 和为 S 的连续正数序列 1234567891011121314题目：小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。思路：维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连续序列，直到数组遍历完成终止。 详细资料可以参考： 《和为 s 的连续正数序列》 42. 和为 S 的两个数字 123456789101112题目：输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。思路：首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。 详细资料可以参考： 《和为 S 的字符串》 43. 左旋转字符串 12345678910题目：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “XYZdefabc”。是不是很简单？OK，搞定它！思路：字符串裁剪后拼接 44. 翻转单词顺序列 12345678910题目：牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？思路：通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。 45. 扑克牌的顺子 123456789101112131415161718题目：LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\\小王可以看成任何数字，并且 A 看作1，J 为11，Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。思路：首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空缺，这个数组实际上还是连续的。于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。 详细资料可以参考： 《扑克牌的顺子》 46. 圆圈中最后剩下的数字（约瑟夫环问题） 1234567891011题目：0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数字。思路：（1）使用环形链表进行模拟。（2）根据规律得出（待深入理解） 详细资料可以参考： 《圆圈中最后剩下的数字》 47. 1+2+3+…+n 123456789题目：求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。思路：由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特性来实现。 48. 不用加减乘除做加法 12345678题目：写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。思路：通过位运算，递归来实现。 49. 把字符串转换成整数。 123456789题目：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。思路：首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。 50. 数组中重复的数字 12345678910111213141516题目：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。思路：（1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。（2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O (n)，空间复杂度为 O(n)。（3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值 交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要 额外的内存空间。 51. 构建乘积数组 1234567891011121314151617题目：给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。思路：（1） C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1] D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1] B[i]=C[i]×D[i] 将乘积分为前后两个部分，分别循环求出后，再进行相乘。（2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解） 详细资料可以参考： 《构建乘积数组》 52. 正则表达式的匹配 12345678910题目：请实现一个函数用来匹配包括&apos;.&apos;和&apos;*&apos;的正则表达式。模式中的字符&apos;.&apos;表示任意一个字符，而&apos;*&apos;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。思路：（1）状态机思路（待深入理解） 详细资料可以参考： 《正则表达式匹配》 53. 表示数值的字符串 123456789题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。、思路：利用正则表达式实现 54. 字符流中第一个不重复的字符 12345678910题目：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次的字符是 &quot;g&quot; 。当从该字符流中读出前六个字符 &quot;google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。 输出描述：如果当前字符流没有存在出现一次的字符，返回#字符。思路：同第 34 题 55. 链表中环的入口结点 12345678910111213题目：一个链表中包含环，如何找出环的入口结点？思路：首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇点就是环的入口节点。 详细资料可以参考： 《链表中环的入口结点》 《《剑指offer》——链表中环的入口结点》 56. 删除链表中重复的结点 1234567891011121314题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5思路：解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头结点也可能被删除，所以在链表头额外添加一个结点。接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev要始终与下一个没有重复的结点连接在一起。 57. 二叉树的下一个结点 123456789101112131415161718题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父节点的指针。思路：这个问题我们可以分为三种情况来讨论。第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点出发，一直沿着左子节点的指针，就能找到下一个节点。第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节点。第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。 58. 对称二叉树 12345678910题目：请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。思路：我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉树。 59. 按之字形顺序打印二叉树（待深入理解） 1234567891011题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。思路：按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每一个栈遍历完成后进入下一层循环。 详细资料可以参考： 《按之字形顺序打印二叉树》 60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 123456789题目：从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。思路：用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还没有打印的结点数，另一个变量表示下一次结点的数目。 61. 序列化二叉树（待深入理解） 12345678题目：请实现两个函数，分别用来序列化和反序列化二叉树。思路：数组模拟 62. 二叉搜索树的第 K 个节点 12345678题目：给定一颗二叉搜索树，请找出其中的第 k 小的结点。思路：对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。 63. 数据流中的中位数（待深入理解） 1234题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 64. 滑动窗口中的最大值（待深入理解） 1234567891011题目：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下6个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。思路：使用队列的方式模拟 65. 矩阵中的路径（待深入理解） 123456题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 66. 机器人的运动范围（待深入理解） 12345题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 剑指 offer 相关资料可以参考：《剑指 offer 题目练习及思路分析》《JS 版剑指 offer》《剑指 Offer 学习心得》 相关算法题1. 明星问题 123456789101112131415题目：有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。思路：（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。 这一种方法的时间复杂度为 O(n^2)。（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明 A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移 除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩 一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。 详细资料可以参考： 《一个明星和 n-1 个群众》 2. 正负数组求和 1234567891011题目：有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和最接近零。思路：（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分 别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动 一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题系列","slug":"面试题系列","permalink":"/tags/面试题系列/"}]},{"title":"面试知识点之网络","slug":"面试知识点之网络","date":"2023-09-20T05:53:31.000Z","updated":"2024-01-11T07:00:59.293Z","comments":true,"path":"2023/09/20/面试知识点之网络/","link":"","permalink":"/2023/09/20/面试知识点之网络/","excerpt":"计算机网络知识总结","text":"计算机网络知识总结 计算机网络知识总结本部分主要是笔者在复习计算机网络相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！ 目录 应用层 HTTP 协议 概况 HTTP 请求报文 HTTP 响应报文 首部行 HTTP/1.1 协议缺点 HTTP/2 协议 二进制协议 多路复用 数据流 头信息压缩 服务器推送 HTTP/2 协议缺点 HTTP/3 协议 HTTPS 协议 HTTP 存在的问题 HTTPS 简介 TLS 握手过程 实现原理 DNS 协议 概况 域名的层级结构 查询过程 DNS 记录和报文 递归查询和迭代查询 DNS 缓存 DNS 实现负载平衡 传输层 多路复用与多路分解 UDP 协议 UDP 报文段结构 TCP 协议 TCP 报文段结构 TCP 三次握手的过程 TCP 四次挥手的过程 状态转化图 ARQ 协议 TCP 的可靠运输机制 TCP 的流量控制机制 TCP 的拥塞控制机制 网络层 数据链路层 物理层 常考面试题 1. Post 和 Get 的区别？ 2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？ 3. SSL 连接断开后如何恢复？ 4. RSA 算法的安全性保障？ 5. DNS 为什么使用 UDP 协议作为传输层协议？ 6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？ 7. 谈谈 CDN 服务？ 8. 什么是正向代理和反向代理？ 9. 负载平衡的两种实现方式？ 10. http 请求方法 options 方法有什么用？ 11. http1.1 和 http1.0 之间有哪些区别？ 12. 网站域名加 www 与不加 www 的区别？ 13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？ 14. 怎么实现多个网站之间共享登录状态 应用层应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、有哪些字段等等。 HTTP 协议概况HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。 HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。 HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。 HTTP 请求报文HTTP 报文有两种，一种是请求报文，一种是响应报文。 HTTP 请求报文的格式如下： 1234GET / HTTP/1.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。 请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。 方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参看文档。 HTTP 响应报文HTTP 报文有两种，一种是请求报文，一种是响应报文。 HTTP 响应报文的格式如下： 12345678910HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。 状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。 实体部分是报文的主要部分，它包含了所请求的对象。 常见的状态有 200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理301-永久移动、302-临时移动、304-所请求的资源未修改、400-客户端请求的语法错误、404-请求的资源不存在500-服务器内部错误。 一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。 更多关于状态码的可以查看： 《HTTP 状态码》 首部行首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。 常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。 常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。 常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。 常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。 更多关于首部的资料可以查看： 《HTTP 首部字段详细介绍》 《图解 HTTP》 HTTP/1.1 协议缺点HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。 为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的原因。 HTTP/2 协议2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。 HTTP/2 主要有以下新的特性： 二进制协议HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。 多路复用HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。 数据流HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。 头信息压缩HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用SSE 等方式向客户端发送即时数据的推送是不同的。 详细的资料可以参考：《HTTP 协议入门》《HTTP/2 服务器推送（Server Push）教程》 HTTP/2 协议缺点因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。 HTTP/3 协议由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能 详细资料可以参考：《如何看待 HTTP/3 ？》 HTTPS 协议HTTP 存在的问题 HTTP 报文使用明文方式发送，可能被第三方窃听。 HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。 HTTP 还存在认证的问题，第三方可以冒充他人参与通信。 HTTPS 简介HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。 TLS 握手过程 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。 实现原理TLS 的握手过程主要用到了三个方法来保证传输的安全。 首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。这就要用到非对称加密的方法。 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。 因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。 但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。 为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。 详细资料可以参考：《一个故事讲完 https》《SSL/TLS 协议运行机制的概述》《图解 SSL/TLS 协议》《RSA 算法原理（一）》《RSA 算法原理（二）》《分分钟让你理解 HTTPS》 DNS 协议概况DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号端口。 域名的层级结构域名的层级结构可以如下 12345主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root 根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。 查询过程DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。 从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地址）。 从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。 从”次级域名服务器”查出”主机名”的 IP 地址。 比如我们如果想要查询 www.baidu.com 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。 DNS 记录和报文DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为 （Name，Value，Type，TTL） 其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。 常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。 如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标准的主机名到 IP 地址的映射。 如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式查询时，返回下一级需要查询的 DNS 服务器的信息。 如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名。 如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一样的，都是为了解决规范主机名不利于记忆的缺点。 递归查询和迭代查询递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。 一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。 DNS 缓存DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。 DNS 实现负载平衡DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。 详细资料可以参考：《DNS 原理入门》《根域名的知识》 传输层传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。 多路复用与多路分解将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。 在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。 无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端口号，那么不同的报文段将会转交到同一个 UDP 套接字中。 面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个值来将报文段定向到相应的套接字。 UDP 协议UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。 特点： 使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。 UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。 UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。 因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信。 UDP 首部小，只有 8 个字节。 UDP 报文段结构UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。 TCP 协议TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。 特点： TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。 TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。 TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。 TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。 TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。 TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送速率，避免因为缓存填满而造成的数据包的丢失。 TCP 报文段结构TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。 源端口和目的端口号用于报文段的多路复用和分解。 32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。 16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。 4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。 6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。 校验和提供了对数据的差错检测。 TCP 三次握手的过程第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的随机数。它代表的是客户端数据的初始序号。 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加一。 第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。 在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。 详细资料可以参考：《TCP 为什么是三次握手，而不是两次或四次？》《TCP 的三次握手与四次挥手》 TCP 四次挥手的过程因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。 第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。 第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。 第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAST_ACK 状态。 第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被释放了。 TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。 最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。 详细资料可以参考： 《前端面试之道》 状态转化图 ARQ 协议ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的机制。 它分为停止等待 ARQ 协议和连续 ARQ 协议。 一、停止等待 ARQ 协议 停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。 对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余分组的确认。当收到分组损坏的情况的时候，直接丢弃。 使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。 二、连续 ARQ 协议 连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。 滑动窗口协议 使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分组。 接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，所以发送窗口可以移动到已确认分组的后面。 滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。 选择重传协议 因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。 选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。 在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。 详细资料可以参考：《TCP 连续 ARQ 协议和滑动窗口协议》 TCP 的可靠运输机制TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。 TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发送但确认的报文段。 接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。 发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文段的发送速率。 但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。 TCP 的流量控制机制TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。 TCP 的拥塞控制机制TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。 TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。 慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。 拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。这样将窗口的增长速率由指数增长，变为加法线性增长。 快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。 快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。 TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四种机制来达到拥塞控制的目的。 详细资料可以参考：《TCP 的拥塞控制机制》《网络基本功：TCP 拥塞控制机制》 网络层网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选择协议。 IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用32 位来分配地址，还有 IPv6 使用 128 位来分配地址。 路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。 数据链路层数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，这是由网络适配器决定的，在全世界都是独一无二的。 物理层物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质是什么。 详细资料可以参考：《搞定计算机网络面试，看这篇就够了（补充版）》《互联网协议入门（一）》《互联网协议入门（二）》 常考面试题1. Post 和 Get 的区别？123456789101112Post 和 Get 是 HTTP 请求的两种方法。（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。 2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？123客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。 3. SSL 连接断开后如何恢复？12345678910一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。 4. RSA 算法的安全性保障？12对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在1024位的 RSA 密钥基本安全，2048位的密钥极其安全。 5. DNS 为什么使用 UDP 协议作为传输层协议？123456789101112DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，所以现在有了 DNS over HTTPS 来解决这个问题。 详细资料可以参考：《为什么 DNS 使用 UDP 而不是 TCP？》 6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？123456789101112131415161718192021222324252627282930313233343536373839404142（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。（9）最后一步是 TCP 断开连接的四次挥手过程。 详细资料可以参考：《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》 7. 谈谈 CDN 服务？123CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。 详细资料可以参考：《CDN 是什么？使用 CDN 有什么优势？》 8. 什么是正向代理和反向代理？123456我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。 详细资料可以参考：《正向代理与反向代理有什么区别》《webpack 配置 proxy 反向代理的原理是什么？》 9. 负载平衡的两种实现方式？12345678一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。 详细资料可以参考：《负载均衡的原理》 10. http 请求方法 options 方法有什么用？123OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用&apos;*&apos;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 相关资料可以参考：《HTTP 请求方法》 11. http1.1 和 http1.0 之间有哪些区别？123456789http1.1 相对于 http1.0 有这样几个区别：（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。 详细资料可以参考：《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》《HTTP 协议入门》《网络—一篇文章详解请求头 Host 的概念》 12. 网站域名加 www 与不加 www 的区别？详细资料可以参考：《为什么域名前要加 www 前缀 www 是什么意思？》《为什么越来越多的网站域名不加「www」前缀？》《域名有 www 与没有 www 有什么区别？》 13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？12345678910111213141516171819202122短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。 详细资料可以参考：《轮询、长轮询、长连接、websocket》《Server-Sent Events 教程》《WebSocket 教程》 14. 怎么实现多个网站之间共享登录状态1234567在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。 详细资料可以参考：《HTTP 是个无状态协议，怎么保持登录状态？》","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"面试题系列","slug":"面试题系列","permalink":"/tags/面试题系列/"}]},{"title":"面试知识点之css","slug":"面试知识点之css","date":"2023-09-20T05:51:54.000Z","updated":"2024-01-11T07:00:59.289Z","comments":true,"path":"2023/09/20/面试知识点之css/","link":"","permalink":"/2023/09/20/面试知识点之css/","excerpt":"CSS 面试知识点总结","text":"CSS 面试知识点总结 CSS 面试知识点总结本部分主要是笔者在复习 CSS 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！ 目录 1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？ 2.CSS 选择符有哪些？ 3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。 4.伪类与伪元素的区别 5.CSS 中哪些属性可以继承？ 6.CSS 优先级算法如何计算？ 7.关于伪类 LVHA 的解释? 8.CSS3 新增伪类有那些？ 9.如何居中 div？ 10.display 有哪些值？说明他们的作用。 11.position 的值 relative 和 absolute 定位原点是？ 12.CSS3 有哪些新特性？（根据项目回答） 13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？ 14.用纯 CSS 创建一个三角形的原理是什么？ 15.一个满屏品字布局如何设计? 16.CSS 多列等高如何实现？ 17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？ 18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 19.为什么要初始化 CSS 样式？ 20.什么是包含块，对于包含块的理解? 21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？ 22.width:auto 和 width:100\\x 的区别 23.绝对定位元素与非绝对定位元素的百分比计算的区别 24.简单介绍使用图片 base64 编码的优点和缺点。 25.’display’、’position’和’float’的相互关系？ 26.margin 重叠问题的理解。 27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？ 28.IFC 是什么？ 29.请解释一下为什么需要清除浮动？清除浮动的方式 30.使用 clear 属性清除浮动的原理？ 31.zoom:1 的清除浮动原理? 32.移动端的布局用过媒体查询吗？ 33.使用 CSS 预处理器吗？喜欢哪个？ 34.CSS 优化、提高性能的方法有哪些？ 35.浏览器是怎样解析 CSS 选择器的？ 36.在网页中应该使用奇数还是偶数的字体？为什么呢？ 37.margin 和 padding 分别适合什么场景使用？ 38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 39.简单说一下 css3 的 all 属性。 40.为什么不建议使用统配符初始化 css 样式。 41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？ 42.对于 hasLayout 的理解？ 43.元素竖向的百分比设定是相对于容器的高度吗？ 44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践） 45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解） 46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） 47.如何修改 chrome 记住密码后自动填充表单的黄色背景？ 48.怎么让 Chrome 支持小于 12px 的文字？ 49.让页面里的字体变清晰，变细用 CSS 怎么做？ 50.font-style 属性中 italic 和 oblique 的区别？ 51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？ 52.layout viewport、visual viewport 和 ideal viewport 的区别？ 53.position:fixed;在 android 下无效怎么处理？ 54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 55.如何让去除 inline-block 元素间间距？ 56.overflow:scroll 时不能平滑滚动的问题怎么处理？ 57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。 58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？ 59.浏览器如何判断是否支持 webp 格式图片 60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做） 61.style 标签写在 body 后与 body 前有什么区别？ 62.什么是 CSS 预处理器/后处理器？ 63.阐述一下 CSSSprites 64.使用 rem 布局的优缺点？ 65.几种常见的 CSS 布局 66.画一条 0.5px 的线 67.transition 和 animation 的区别 68.什么是首选最小宽度？ 69.为什么 height:100\\x 会无效？ 70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？ 71.内联盒模型基本概念 72.什么是幽灵空白节点？ 73.什么是替换元素？ 74.替换元素的计算规则？ 75.content 与替换元素的关系？ 76.margin:auto 的填充规则？ 77.margin 无效的情形 78.border 的特殊性？ 79.什么是基线和 x-height？ 80.line-height 的特殊性？ 81.vertical-align 的特殊性？ 82.overflow 的特殊性？ 83.无依赖绝对定位是什么？ 84.absolute 与 overflow 的关系？ 85.clip 裁剪是什么？ 86.relative 的特殊性？ 87.什么是层叠上下文？ 88.什么是层叠水平？ 89.元素的层叠顺序？ 90.层叠准则？ 91.font-weight 的特殊性？ 92.text-indent 的特殊性？ 93.letter-spacing 与字符间距？ 94.word-spacing 与单词间距？ 95.white-space 与换行和空格的控制？ 96.隐藏元素的 background-image 到底加不加载？ 97.如何实现单行／多行文本溢出的省略（…）？ 98.常见的元素隐藏方式？ 99.css 实现上下固定中间自适应布局？ 100.css 两栏布局的实现？ 101.css 三栏布局的实现？ 102.实现一个宽高自适应的正方形 103.实现一个三角形 104.一个自适应矩形，水平垂直居中，且宽高比为 2:1 105.你知道 CSS 中不同属性设置为百分比\\x 时对应的计算基准？ 1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？相关知识点： 123456789101112（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分IE盒模型和W3C标准盒模型的区别：（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。 回答： 123456盒模型都是由四个部分组成的，分别是margin、border、padding和content。标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。 详细的资料可以参考：《CSS 盒模型详解》 2.CSS 选择符有哪些？1234567891011（1）id选择器（#myid）（2）类选择器（.myclassname）（3）标签选择器（div,h1,p）（4）后代选择器（h1 p）（5）相邻后代选择器（子）选择器（ul&gt;li）（6）兄弟选择器（li~a）（7）相邻兄弟选择器（li+a）（8）属性选择器（a[rel=&quot;external&quot;]）（9）伪类选择器（a:hover,li:nth-child）（10）伪元素选择器（::before、::after）（11）通配符选择器（*） 3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。相关知识点： 12345678单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。 回答： 1234在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。 4.伪类与伪元素的区别123456789101112css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。 详细资料可以参考：《总结伪类与伪元素》 5.CSS 中哪些属性可以继承？相关资料： 1234567891011121314151617181920212223242526272829303132333435每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。有继承性的属性：（1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-side border-collapse empty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。 回答： 1234567每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。 详细的资料可以参考：《继承属性》《CSS 有哪些属性可以继承？》 6.CSS 优先级算法如何计算？相关知识点： 123456789101112131415161718192021222324252627282930313233343536CSS的优先级是根据样式声明的特殊性值来判断的。选择器的特殊性值分为四个等级，如下：（1）标签内选择符x,0,0,0（2）ID选择符0,x,0,0（3）class选择符/属性选择符/伪类选择符 0,0,x,0（4）元素和伪元素选择符0,0,0,x计算方法：（1）每个等级的初始值为0（2）每个等级的叠加为选择器出现的次数相加（3）不可进位，比如0,99,99,99（4）依次表示为：0,0,0,0（5）每个等级计数之间没关联（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值（7）如果两个优先级相同，则最后出现的优先级高，!important也适用（8）通配符选择器的特殊性值为：0,0,0,0（9）继承样式优先级最低，通配符样式优先级高于继承样式（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。计算实例：（1）#demo a&#123;color: orange;&#125;/*特殊性值：0,1,0,1*/（2）div#demo a&#123;color: red;&#125;/*特殊性值：0,1,0,2*/注意：（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。（2）特殊性值越大的声明优先级越高。（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的） (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑 回答： 123456789判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。 对于组合声明的特殊性值计算可以参考：《CSS 优先级计算及应用》《CSS 优先级计算规则》《有趣：256 个 class 选择器可以干掉 1 个 id 选择器》 7.关于伪类 LVHA 的解释?12345678910111213a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；当链接未访问过时：（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。当链接访问过时，情况基本同上，只不过需要将:link换成:visited。这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。 8.CSS3 新增伪类有那些？12345678910111213141516171819202122232425262728（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。（3）elem:last-child选中最后一个子元素。（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。（6）elem:first-of-type选中父元素下第一个elem类型元素。（7）elem:last-of-type选中父元素下最后一个elem类型元素。（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。（9）elem:empty选中不包含子元素和内容的elem类型元素。（10）elem:target选择当前活动的elem元素。（11）:not(elem)选择非elem元素的每个元素。（12）:enabled 控制表单控件的禁用状态。（13）:disabled 控制表单控件的禁用状态。(14):checked单选框或复选框被选中。 详细的资料可以参考：《CSS3 新特性总结(伪类)》《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》 9.如何居中 div？-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性 1234div &#123; width: 200px; margin: 0 auto;&#125; -水平居中，利用 text-align:center 实现 123456789101112.container &#123; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0;&#125;.box &#123; display: inline-block; width: 500px; height: 400px; background-color: pink;&#125; -让绝对定位的 div 居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /*方便看效果*/&#125; -水平垂直居中一 123456789/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/position: absolute;/*绝对定位*/width: 500px;height: 300px;top: 50%;left: 50%;margin: -150px 0 0 -250px;/*外边距为自身宽高的一半*/background-color: pink;/*方便看效果*/&#125; -水平垂直居中二 12345678910/*未知容器的宽高，利用`transform`属性*/div &#123; position: absolute; /*相对定位或绝对定位均可*/ width: 500px; height: 300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /*方便看效果*/&#125; -水平垂直居中三 1234567891011/*利用flex布局实际使用时应考虑兼容性*/.container &#123; display: flex; align-items: center; /*垂直居中*/ justify-content: center; /*水平居中*/&#125;.containerdiv &#123; width: 100px; height: 100px; background-color: pink; /*方便看效果*/&#125; -水平垂直居中四 1234567891011121314151617181920212223242526272829/*利用text-align:center和vertical-align:middle属性*/.container &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0; white-space: nowrap; overflow: auto;&#125;.container::after &#123; content: ''; display: inline-block; height: 100%; vertical-align: middle;&#125;.box &#123; display: inline-block; width: 500px; height: 400px; background-color: pink; white-space: normal; vertical-align: middle;&#125; 回答： 12345678910111213141516171819一般常见的几种居中的方法有：对于宽高固定的元素（1）我们可以利用margin:0 auto来实现元素的水平居中。（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。 10.display 有哪些值？说明他们的作用。1234567block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 元素不显示，并从文档流中移除。inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。list-item 像块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承display属性的值。 详细资料可以参考：《CSS display 属性》 11.position 的值 relative 和 absolute 定位原点是？相关知识点： 123456789101112131415absolute生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。inherit规定从父元素继承position属性的值。 回答： 12345relative定位的元素，是相对于元素本身的正常位置来进行定位的。absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。 12.CSS3 有哪些新特性？（根据项目回答）12345678910新增各种CSS选择器 （:not(.input)：所有class不是“input”的节点）圆角 （border-radius:8px）多列布局 （multi-column layout）阴影和反射 （Shadow\\Reflect）文字特效 （text-shadow）文字渲染 （Text-decoration）线性渐变 （gradient）旋转 （transform）缩放，定位，倾斜，动画，多背景例如：transform:\\scale(0.85,0.90)\\translate(0px,-30px)\\skew(-9deg,0deg)\\Animation: 13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？相关知识点： 1234567891011121314151617181920212223242526272829303132333435363738394041Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。以下6个属性设置在容器上。flex-direction属性决定主轴的方向（即项目的排列方向）。flex-wrap属性定义，如果一条轴线排不下，如何换行。flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。justify-content属性定义了项目在主轴上的对齐方式。align-items属性定义项目在交叉轴上如何对齐。align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。以下6个属性设置在项目上。order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 回答： 123456789flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。 详细资料可以参考：《Flex 布局教程：语法篇》《Flex 布局教程：实例篇》 14.用纯 CSS 创建一个三角形的原理是什么？123456789101112采用的是相邻边框连接处的均分原理。 将元素的宽高设为0，只设置 border ，把任意三条边隐藏掉（颜色设为 transparent），剩下的就是一个三角形。 #demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 15.一个满屏品字布局如何设计?1234简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 16.CSS 多列等高如何实现？12345678（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。 详细资料可以参考：《前端应该掌握的 CSS 实现多列等高布局》《CSS：多列等高布局》 17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？12345678910111213141516171819202122232425262728293031323334353637383940414243444546（1）png24位的图片在iE6浏览器上出现背景解决方案：做成PNG8，也可以引用一段脚本处理。（2）浏览器默认的margin和padding不同解决方案：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。#box&#123;float:left;width:10px;margin:0 0 0 10px;&#125;这种情况之下IE会产生20px的距离解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)（4）渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用&quot;\\9&quot;这一标记，将IE游览器从所有情况中分离出来。接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。.bb&#123;background-color:#f1ee18;/*所有识别*/.background-color:#00deff\\9;/*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/&#125;（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性解决方法：统一通过getAttribute()获取自定义属性。（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示解决方法：1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了解决方法：改变CSS属性的排列顺序L-V-H-A（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。 18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？1234567891011121314浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。解决办法：（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符间隔设为默认letter-spacing:normal。 详细资料可以参考：《li 与 li 之间有看不见的空白间隔是什么原因引起的？》 19.为什么要初始化 CSS 样式？1234567891011121314151617181920212223-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法：*&#123;padding:0;margin:0;&#125;（强烈不建议）淘宝的样式初始化代码：body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;body,button,input,select,textarea&#123;font:12px/1.5tahoma,arial,\\5b8b\\4f53;&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;address,cite,dfn,em,var&#123;font-style:normal;&#125;code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;small&#123;font-size:12px;&#125;ul,ol&#123;list-style:none;&#125;a&#123;text-decoration:none;&#125;a:hover&#123;text-decoration:underline;&#125;sup&#123;vertical-align:text-top;&#125;sub&#123;vertical-align:text-bottom;&#125;legend&#123;color:#000;&#125;fieldset,img&#123;border:0;&#125;button,input,select,textarea&#123;font-size:100%;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125; 20.什么是包含块，对于包含块的理解?123456789101112131415161718包含块（containing block）就是元素用来计算和定位的一个框。（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。（3）如果元素position:fixed，则“包含块”是“初始包含块”。（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：如果该祖先元素是纯inline元素，则规则略复杂：•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。 21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？1234567891011（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。在不同浏览器下的区别：在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。 详细资料可以参考：《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》 22.width:auto 和 width:100%的区别12345一般而言width:100%会使元素box的宽度等于父元素的content box的宽度。width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。 23.绝对定位元素与非绝对定位元素的百分比计算的区别123绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。 24.简单介绍使用图片 base64 编码的优点和缺点。123456789101112131415161718base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。使用base64的优点是：（1）减少一个图片的HTTP请求使用base64的缺点是：（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。（3）兼容性的问题，ie8以前的浏览器不支持。一般一些网站的小图标可以使用base64图片来引入。 详细资料可以参考：《玩转图片 base64 编码》《前端开发中，使用 base64 图片的弊端是什么？》《小 tip:base64:URL 背景图片与 web 页面性能优化》 25.’display’、’position’和’float’的相互关系？123456789101112131415（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在的时候，浮动不起作用，&apos;display&apos;的值也需要调整；其次，元素的&apos;float&apos;特性的值不是&quot;none&quot;的时候或者它是根元素的时候，调整&apos;display&apos;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&apos;display&apos;特性值同设置值。 详细资料可以参考：《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》 26.margin 重叠问题的理解。相关知识点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。产生折叠的必备条件：margin必须是邻接的!而根据w3c规范，两个margin是邻接的必须满足以下条件：•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。•没有线盒，没有空隙，没有padding和border将他们分隔开•都属于垂直方向上相邻的外边距，可以是下面任意一种情况•元素的margin-top与其第一个常规文档流的子元素的margin-top•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottommargin合并的3种场景：（1）相邻兄弟元素margin合并。解决办法：•设置块状格式化上下文元素（BFC）（2）父级和第一个/最后一个子元素的margin合并。解决办法：对于margin-top合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-top值；•父元素设置padding-top值；•父元素和第一个子元素之间添加内联元素进行分隔。对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-bottom值；•父元素设置padding-bottom值；•父元素和最后一个子元素之间添加内联元素进行分隔；•父元素设置height、min-height或max-height。（3）空块级元素的margin合并。解决办法：•设置垂直方向的border；•设置垂直方向的padding；•里面添加内联元素（直接Space键空格是没用的）；•设置height或者min-height。 回答： 1234567891011121314151617margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。一般来说可以分为四种情形：第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。 27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？相关知识点： 123456789101112131415块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。通俗来讲•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。创建BFC（1）根元素或包含根元素的元素（2）浮动元素float＝left|right或inherit（≠none）（3）绝对定位元素position＝absolute或fixed（4）display＝inline-block|flex|inline-flex|table-cell或table-caption（5）overflow＝hidden|auto或scroll(≠visible) 回答： 12345BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。 详细资料可以参考：《深入理解 BFC 和 MarginCollapse》《前端面试题-BFC（块格式化上下文）》 28.IFC 是什么？12345IFC指的是行级格式化上下文，它有这样的一些布局规则：（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。（2）当一行不够的时候会自动切换到下一行。（3）行级上下文的高度由内部最高的内联盒子的高度决定。 详细资料可以参考：《[译]:BFC 与 IFC》《BFC 和 IFC 的理解（布局）》 29.请解释一下为什么需要清除浮动？清除浮动的方式1234567891011121314浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。清除浮动的方式（1）使用clear属性清除浮动。参考28。（2）使用BFC块级格式化上下文来清除浮动。参考26。因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。 30.使用 clear 属性清除浮动的原理？1234567891011121314151617181920212223242526使用clear属性清除浮动，其语法如下：clear:none|left|right|both如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。一般使用伪元素的方式清除浮动.clear::after&#123;content:&apos;&apos;;display:table;//也可以是&apos;block&apos;，或者是&apos;list-item&apos;clear:both;&#125;clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。 31.zoom:1 的清除浮动原理?123456789101112清除浮动，触发hasLayout；zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在CSS3.0规范草案中。目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。 32.移动端的布局用过媒体查询吗？12345678假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 详细资料可以参考：《CSS3@media 查询》 33.使用 CSS 预处理器吗？喜欢哪个？1SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS） 34.CSS 优化、提高性能的方法有哪些？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354加载性能：（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。选择器性能：（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。（4）尽量少的去对标签进行选择，而是用class。（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。渲染性能：（1）慎重使用高性能属性：浮动、定位。（2）尽量减少页面重排、重绘。（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。（4）属性值为0时，不加单位。（5）属性值为浮动小数0.**，可以省略小数点之前的0。（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。（7）不使用@import前缀，它会影响css的加载速度。（8）选择器优化嵌套，尽量避免层级过深。（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。可维护性、健壮性：（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。 详细资料可以参考：《CSS 优化、提高性能的方法有哪些？》《CSS 优化，提高性能的方法》 35.浏览器是怎样解析 CSS 选择器的？12345样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。 详细资料可以参考：《探究 CSS 解析原理》 36.在网页中应该使用奇数还是偶数的字体？为什么呢？1234（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。 详细资料可以参考：《谈谈网页中使用奇数字体和偶数字体》《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》 37.margin 和 padding 分别适合什么场景使用？12345678910111213margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干。padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。何时应当使用margin：•需要在border外侧添加空白时。•空白处不需要背景（色）时。•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。何时应当时用padding：•需要在border内测添加空白时。•空白处需要背景（色）时。•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。 38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]12我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。 详细资料可以参考：《CSS 规范-分类方法》 39.简单说一下 css3 的 all 属性。12345678910all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。 详细资料可以参考：《简单了解 CSS3 的 all 属性》 40.为什么不建议使用统配符初始化 css 样式。123456采用*&#123;padding:0;margin:0;&#125;这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。 41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？12345（1）内联元素也可以作为“包含块”所在的元素；（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；（3）边界是padding box而不是content box。 42.对于 hasLayout 的理解？1234hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。 详细资料可以参考：《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》《CSS 魔法堂：hasLayout 原来是这样的！》 43.元素竖向的百分比设定是相对于容器的高度吗？123如果是height的话，是相对于包含块的高度。如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。 44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）12345原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。overflow：hidden；transition：all 1000 ms ease； 详细资料可以参考：《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》《用 ES6 写全屏滚动插件》 45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）12响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。 详细资料可以参考：《响应式布局原理》《响应式布局的实现方法和原理》 46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）1视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 详细资料可以参考：《如何实现视差滚动效果的网页？》 47.如何修改 chrome 记住密码后自动填充表单的黄色背景？123456789101112131415161718chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：&#123;background-color:rgb(250,255,189)!important;background-image:none!important;color:rgb(0,0,0)!important;&#125;对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;-webkit-box-shadow:000px 1000px white inset;border:1px solid #CCC !important;&#125; 详细资料可以参考：《去掉 chrome 记住密码后的默认填充样式》《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》 48.怎么让 Chrome 支持小于 12px 的文字？12345678910111213在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。解决办法：（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 详细资料可以参考：《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》 49.让页面里的字体变清晰，变细用 CSS 怎么做？1234webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。 详细资料可以参考：《让字体变的更清晰 CSS 中-webkit-font-smoothing》 50.font-style 属性中 italic 和 oblique 的区别？1234italic和oblique这两个关键字都表示“斜体”的意思。它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。 51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？123456789设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。 详细资料可以参考：《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》《前端工程师需要明白的「像素」》《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》《前端开发中像素的概念》 52.layout viewport、visual viewport 和 ideal viewport 的区别？相关知识点： 1234567891011如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做layout viewport。layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把这个viewport叫做visual viewport。ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 回答： 1234567891011121314移动端一共需要理解三个viewport的概念的理解。第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visual viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。 详细资料可以参考：《移动前端开发之 viewport 的深入理解》《说说移动前端中 viewport（视口）》《移动端适配知识你到底知多少》 53.position:fixed;在 android 下无效怎么处理？12345678因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; 54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）1多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms 55.如何让去除 inline-block 元素间间距？1移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 详细资料可以参考：《去除 inline-block 元素间间距的 N 种方法》 56.overflow:scroll 时不能平滑滚动的问题怎么处理？12以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流畅。 详细资料可以参考：《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》 57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。1234（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;left:0;right:0;（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。 详细资料可以参考：《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》 58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？相关知识点： 12345678910111213141516171819202122232425262728293031（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。 回答： 1234567891011121314151617181920212223我了解到的一共有七种常见的图片的格式。（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。 详细资料可以参考：《图片格式那么多，哪种更适合你？》 59.浏览器如何判断是否支持 webp 格式图片123456（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。 详细资料可以参考：《判断浏览器是否支持 WebP 图片》《toDataURL()》 60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）12345678910网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。 详细资料可以参考：《CDN 是什么？使用 CDN 有什么优势？》 61.style 标签写在 body 后与 body 前有什么区别？123页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） 62.什么是 CSS 预处理器/后处理器？12345678910111213CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 详细资料可以参考：《CSS 预处理器和后处理器》 63.阐述一下 CSSSprites1234567891011121314将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。优点：减少HTTP请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点：图片合并麻烦维护麻烦，修改一个图片可能需要重新布局整个图片，样式 64.使用 rem 布局的优缺点？123456789优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。 详细资料可以参考：《css3 的字体大小单位 rem 到底好在哪？》《VW:是时候放弃 REM 布局了》《为什么设计稿是 750px》《使用 Flexible 实现手淘 H5 页面的终端适配》 65.几种常见的 CSS 布局详细的资料可以参考：《几种常见的 CSS 布局》 66.画一条 0.5px 的线12345采用meta viewport的方式采用border-image的方式采用transform:scale()的方式 详细资料可以参考：《怎么画一条 0.5px 的边（更新）》 67.transition 和 animation 的区别123transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。 详细资料可以参考：《CSSanimation 与 CSStransition 有何区别？》《CSS3Transition 和 Animation 区别及比较》《CSS 动画简介》《CSS 动画：animation、transition、transform、translate》 68.什么是首选最小宽度？12345678“首选最小宽度”，指的是元素最适合的最小宽度。东亚文字（如中文）最小宽度为每个汉字的宽度。西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。 69.为什么 height:100%会无效？123456对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。 70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？123（1）max-width会覆盖width，即使width是行类样式或者设置了!important。（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。 71.内联盒模型基本概念12345678910（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。（4）包含块（containing box），由一行一行的“行框盒子”组成。 72.什么是幽灵空白节点？123“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。 73.什么是替换元素？123456789101112131415161718通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。替换元素除了内容可替换这一特性以外，还有以下一些特性。（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口，（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。 74.替换元素的计算规则？1234567891011121314151617181920212223替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的size属性、&lt;textarea&gt;的cols和rows属性等。（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。这3层结构的计算规则具体如下（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。 75.content 与替换元素的关系？123456789content属性生成的对象称为“匿名替换元素”。（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。（2）content生成的内容不能左右:empty伪类。（3）content动态生成值无法获取。 76.margin:auto 的填充规则？12345margin的&apos;auto&apos;可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。（1）如果一侧定值，一侧auto，则auto为剩余空间大小。（2）如果两侧均是auto，则平分剩余空间。 77.margin 无效的情形12345678（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。（3）绝对定位元素非定位方位的margin值“无效”。（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。 78.border 的特殊性？12345678910（1）border-width却不支持百分比。（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。（4）border-color默认颜色就是color色值。（5）默认background背景图片是相对于padding box定位的。 79.什么是基线和 x-height？1234567字母x的下边缘（线）就是我们的基线。x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。 80.line-height 的特殊性？123456789101112131415161718192021222324252627（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。（3）行距=line-height-font-size。（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。 81.vertical-align 的特殊性？1234567891011121314151617181920（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成&lt;td&gt;元素，则和&lt;tr&gt;元素上边缘对齐。（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。 82.overflow 的特殊性？12345678（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素&lt;html&gt;，另一个是文本域&lt;textarea&gt;。（3）滚动条会占用容器的可用宽度或高度。（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！ 83.无依赖绝对定位是什么？123没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。 84.absolute 与 overflow 的关系？1234567（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。 85.clip 裁剪是什么？123所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。 86.relative 的特殊性？12345（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。 87.什么是层叠上下文？12345678910111213141516171819层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。层叠上下文元素有如下特性：（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。（2）层叠上下文可以阻断元素的混合模式。（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。层叠上下文的创建：（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。（3）其他一些CSS3属性，比如元素的opacity值不是1。 88.什么是层叠水平？1234层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。 89.元素的层叠顺序？层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。 90.层叠准则？123（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 91.font-weight 的特殊性？1如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。 92.text-indent 的特殊性？12345678910（1）text-indent仅对第一行内联盒子内容有效。（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。（3）&lt;input&gt;标签按钮text-indent值无效。（4）&lt;button&gt;标签按钮text-indent值有效。（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。 93.letter-spacing 与字符间距？12345678910letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。letter-spacing具有以下一些特性。（1）继承性。（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。（5）支持小数值，即使0.1px也是支持的。（6）暂不支持百分比值。 94.word-spacing 与单词间距？12letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。 95.white-space 与换行和空格的控制？12345678910white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。其属性值包括下面这些。•normal：合并空白字符和换行符。•pre：空白字符不合并，并且内容只在有换行符的地方换行。•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。 96.隐藏元素的 background-image 到底加不加载？相关知识点： 123456789根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使用的。如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。 回答： -（1）元素的背景图片 -元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求-:hover 样式下，触发时请求 -（2）img 标签图片任何情况下都会请求图片 详细资料可以参考：《CSS 控制前端图片 HTTP 请求的各种情况示例》 97.如何实现单行／多行文本溢出的省略（…）？1234567891011121314151617181920212223/*单行文本溢出*/p &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;/*多行文本溢出*/p &#123; position: relative; line-height: 1.5em; /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/ height: 3em; overflow: hidden;&#125;p:after &#123; content: '...'; position: absolute; bottom: 0; right: 0; background-color: #fff;&#125; 详细资料可以参考：《【CSS/JS】如何实现单行／多行文本溢出的省略》《CSS 多行文本溢出省略显示》 98.常见的元素隐藏方式？-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。 -（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。 -（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。 -（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。 -（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。 -（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。 -（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。 详细资料可以参考：《CSS 隐藏元素的八种方法》 99.css 实现上下固定中间自适应布局？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455利用绝对定位实现body &#123; padding: 0; margin: 0;&#125;.header &#123; position: absolute; top: 0; width: 100%; height: 100px; background: red;&#125;.container &#123; position: absolute; top: 100px; bottom: 100px; width: 100%; background: green;&#125;.footer &#123; position: absolute; bottom: 0; height: 100px; width: 100%; background: red;&#125;利用flex布局实现html,body &#123; height: 100%;&#125;body &#123; display: flex; padding: 0; margin: 0; flex-direction: column;&#125;.header &#123; height: 100px; background: red;&#125;.container &#123; flex-grow: 1; background: green;&#125;.footer &#123; height: 100px; background: red;&#125; 详细资料可以参考：《css 实现上下固定中间自适应布局》 100.css 两栏布局的实现？相关资料： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*//*以左边宽度固定为200px为例*//*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/.outer &#123; height: 100px;&#125;.left &#123; float: left; height: 100px; width: 200px; background: tomato;&#125;.right &#123; margin-left: 200px; width: auto; height: 100px; background: gold;&#125;/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/.outer &#123; display: flex; height: 100px;&#125;.left &#123; flex-shrink: 0; flex-grow: 0; flex-basis: 200px; background: tomato;&#125;.right &#123; flex: auto; /*11auto*/ background: gold;&#125;/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。*/.outer &#123; position: relative; height: 100px;&#125;.left &#123; position: absolute; width: 200px; height: 100px; background: tomato;&#125;.right &#123; margin-left: 200px; height: 100px; background: gold;&#125;/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/.outer &#123; position: relative; height: 100px;&#125;.left &#123; width: 200px; height: 100px; background: tomato;&#125;.right &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 200px; background: gold;&#125; 《两栏布局 demo 展示》 回答： 两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。 以左边宽度固定为 200px 为例 -（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。 -（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。 -（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。 -（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。 101.css 三栏布局的实现？相关资料： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。*//*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/.outer &#123; position: relative; height: 100px;&#125;.left &#123; position: absolute; width: 100px; height: 100px; background: tomato;&#125;.right &#123; position: absolute; top: 0; right: 0; width: 200px; height: 100px; background: gold;&#125;.center &#123; margin-left: 100px; margin-right: 200px; height: 100px; background: lightgreen;&#125;/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/.outer &#123; display: flex; height: 100px;&#125;.left &#123; flex: 00100px; background: tomato;&#125;.right &#123; flex: 00200px; background: gold;&#125;.center &#123; flex: auto; background: lightgreen;&#125;/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/.outer &#123; height: 100px;&#125;.left &#123; float: left; width: 100px; height: 100px; background: tomato;&#125;.right &#123; float: right; width: 200px; height: 100px; background: gold;&#125;.center &#123; height: 100px; margin-left: 100px; margin-right: 200px; background: lightgreen;&#125;/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/.outer &#123; height: 100px; padding-left: 100px; padding-right: 200px;&#125;.left &#123; position: relative; left: -100px; float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato;&#125;.right &#123; position: relative; left: 200px; float: right; margin-left: -200px; width: 200px; height: 100px; background: gold;&#125;.center &#123; float: left; width: 100%; height: 100px; background: lightgreen;&#125;/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/.outer &#123; height: 100px;&#125;.left &#123; float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato;&#125;.right &#123; float: left; margin-left: -200px; width: 200px; height: 100px; background: gold;&#125;.wrapper &#123; float: left; width: 100%; height: 100px; background: lightgreen;&#125;.center &#123; margin-left: 100px; margin-right: 200px; height: 100px;&#125; 《三栏布局 demo 展示》 回答： 12345678910111213三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。 102.实现一个宽高自适应的正方形123456789101112131415161718192021222324252627/*1.第一种方式是利用vw来实现*/.square &#123; width: 10%; height: 10vw; background: tomato;&#125;/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/.square &#123; width: 20%; height: 0; padding-top: 20%; background: orange;&#125;/*3.第三种方式是利用子元素的margin-top的值来实现的*/.square &#123; width: 30%; overflow: hidden; background: yellow;&#125;.square::after &#123; content: ''; display: block; margin-top: 100%;&#125; 《自适应正方形 demo 展示》 103.实现一个三角形12345678/*三角形的实现原理是利用了元素边框连接处的等分原理。*/.triangle &#123; width: 0; height: 0; border-width: 100px; border-style: solid; border-color: tomatotransparenttransparenttransparent;&#125; 《三角形 demo 展示》 104.一个自适应矩形，水平垂直居中，且宽高比为 2:11234567891011121314/*实现原理参考自适应正方形和水平居中方式*/.box &#123; position: absolute; top: 0; right: 0; left: 0; bottom: 0; margin: auto; width: 10%; height: 0; padding-top: 20%; background: tomato;&#125; 105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？1234567891011121314公式：当前元素某CSS属性值 = 基准 * 对应的百分比元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）元素的 border-width，不支持百分比元素的 text-indent，基准为包含块的 width元素的 border-radius，基准为分别为自身的height、width元素的 background-size，基准为分别为自身的height、width元素的 translateX、translateY，基准为分别为自身的height、width元素的 line-height，基准为自身的 font-size元素的 font-size，基准为父元素字体","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"面试题系列","slug":"面试题系列","permalink":"/tags/面试题系列/"}]},{"title":"面试知识点之javascript","slug":"面试知识点之javascript","date":"2023-09-20T05:51:41.000Z","updated":"2024-01-11T07:00:59.291Z","comments":true,"path":"2023/09/20/面试知识点之javascript/","link":"","permalink":"/2023/09/20/面试知识点之javascript/","excerpt":"JavaScript 面试知识点总结","text":"JavaScript 面试知识点总结 JavaScript 面试知识点总结本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！ 目录 1. 介绍 js 的基本数据类型。 2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？ 3. 什么是堆？什么是栈？它们之间有什么区别和联系？ [4. 内部属性 [Class]] 是什么？ 5. 介绍 js 有哪些内置对象？ 6. undefined 与 undeclared 的区别？ 7. null 和 undefined 的区别？ 8. 如何获取安全的 undefined 值？ 9. 说几条写 JavaScript 的基本规范？ 10. JavaScript 原型，原型链？ 有什么特点？ 11. js 获取原型的方法？ 12. 在 js 中不同进制数字的表示方式 13. js 中整数的安全范围是多少？ 14. typeof NaN 的结果是什么？ 15. isNaN 和 Number.isNaN 函数的区别？ 16. Array 构造函数只有一个参数值时的表现？ 17. 其他值到字符串的转换规则？ 18. 其他值到数字值的转换规则？ 19. 其他值到布尔类型的值的转换规则？ 20. {} 和 [] 的 valueOf 和 toString 的结果是什么？ 21. 什么是假值对象？ 22. ~ 操作符的作用？ 23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？ 24. 操作符什么时候用于字符串的拼接？ 25. 什么情况下会发生布尔值的隐式强制类型转换？ 26. || 和 &amp;&amp; 操作符的返回值？ 27. Symbol 值的强制类型转换？ 28. == 操作符的强制类型转换规则？ 29. 如何将字符串转化为数字，例如 ‘12.3b’? 30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』? 31. 常用正则表达式 32. 生成随机数的各种方法？ 33. 如何实现数组的随机排序？ 34. javascript 创建对象的几种方式？ 35. JavaScript 继承的几种实现方式？ 36. 寄生式组合继承的实现？ 37. Javascript 的作用域链？ 38. 谈谈 This 对象的理解。 39. eval 是做什么的？ 40. 什么是 DOM 和 BOM？ 41. 写一个通用的事件侦听器函数。 42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？ 43. 三种事件模型是什么？ 44. 事件委托是什么？ 45. [“1”, “2”, “3”].map(parseInt) 答案是多少？ 46. 什么是闭包，为什么要用它？ 47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？ 48. 如何判断一个对象是否属于某个类？ 49. instanceof 的作用？ 50. new 操作符具体干了什么呢？如何实现？ 51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ 52. 对于 JSON 的了解？ 53. [].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？ 54. js 延迟加载的方式有哪些？ 55. Ajax 是什么? 如何创建一个 Ajax？ 56. 谈一谈浏览器的缓存机制？ 57. Ajax 解决浏览器缓存问题？ 58. 同步和异步的区别？ 59. 什么是浏览器的同源政策？ 60. 如何解决跨域问题？ 61. 服务器代理转发时，该如何处理 cookie？ 62. 简单谈一下 cookie ？ 63. 模块化开发怎么做？ 64. js 的几种模块规范？ 65. AMD 和 CMD 规范的区别？ 66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。 67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？） 68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？ 69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西? 70. documen.write 和 innerHTML 的区别？ 71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？ 72. innerHTML 与 outerHTML 的区别？ 73. .call() 和 .apply() 的区别？ 74. JavaScript 类数组对象的定义？ 75. 数组和对象有哪些原生方法，列举一下？ 76. 数组的 fill 方法？ 77. [,,,] 的长度？ 78. JavaScript 中的作用域与变量声明提升？ 79. 如何编写高性能的 Javascript ？ 80. 简单介绍一下 V8 引擎的垃圾回收机制 81. 哪些操作会造成内存泄漏？ 82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里） 84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？ 85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？ 86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？ 87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？ 88. 检测浏览器版本版本有哪些方式？ 89. 什么是 Polyfill ？ 90. 使用 JS 实现获取文件扩展名？ 91. 介绍一下 js 的节流与防抖？ 92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？ 93. escape,encodeURI,encodeURIComponent 有什么区别？ 94. Unicode 和 UTF-8 之间的关系？ 95. js 的事件循环是什么？ 96. js 中的深浅拷贝实现？ 97. 手写 call、apply 及 bind 函数 98. 函数柯里化的实现 99. 为什么 0.1 0.2 != 0.3？如何解决这个问题？ 100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？ 102. 什么是 XSS 攻击？如何防范 XSS 攻击？ 103. 什么是 CSP？ 104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？ 105. 什么是 Samesite Cookie 属性？ 106. 什么是点击劫持？如何防范点击劫持？ 107. SQL 注入攻击？ 108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？ 109. vue 双向数据绑定原理？ 110. Object.defineProperty 介绍？ 111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？ 112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？ 113. 如何比较两个 DOM 树的差异？ 114. 什么是 requestAnimationFrame ？ 115. 谈谈你对 webpack 的看法 116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？ 117. 谈一谈你理解的函数式编程？ 118. 异步编程的实现方式？ 119. Js 动画与 CSS 动画区别及相应实现 120. get 请求传参长度的误区 121. URL 和 URI 的区别？ 122. get 和 post 请求在缓存方面的区别 123. 图片的懒加载和预加载 124. mouseover 和 mouseenter 的区别？ 125. js 拖拽功能的实现 126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？ 127. let 和 const 的注意点？ 128. 什么是 rest 参数？ 129. 什么是尾调用，使用尾调用有什么好处？ 130. Symbol 类型的注意点？ 131. Set 和 WeakSet 结构？ 132. Map 和 WeakMap 结构？ 133. 什么是 Proxy ？ 134. Reflect 对象创建目的？ 135. require 模块引入的查找方式？ 136. 什么是 Promise 对象，什么是 Promises/A 规范？ 137. 手写一个 Promise 138. 如何检测浏览器所支持的最小字体大小？ 139. 怎么做 JS 代码 Error 统计？ 140. 单例模式模式是什么？ 141. 策略模式是什么？ 142. 代理模式是什么？ 143. 中介者模式是什么？ 144. 适配器模式是什么？ 145. 观察者模式和发布订阅模式有什么不同？ 146. Vue 的生命周期是什么？ 147. Vue 的各个生命阶段是什么？ 148. Vue 组件间的参数传递方式？ 149. computed 和 watch 的差异？ 150. vue-router 中的导航钩子函数 151. $route 和 $router 的区别？ 152. vue 常用的修饰符？ 153. vue 中 key 值的作用？ 154. computed 和 watch 区别？ 155. keep-alive 组件有什么作用？ 156. vue 中 mixin 和 mixins 区别？ 157. 开发中常用的几种 Content-Type ？ 158. 如何封装一个 javascript 的类型判断函数？ 159. 如何判断一个对象是否为空对象？ 160. 使用闭包实现每隔一秒打印 1,2,3,4 161. 手写一个 jsonp 162. 手写一个观察者模式？ 163. EventEmitter 实现 164. 一道常被人轻视的前端 JS 面试题 165. 如何确定页面的可用性时间，什么是 Performance API？ 166. js 中的命名规则 167. js 语句末尾分号是否可以省略？ 168. Object.assign() 169. Math.ceil 和 Math.floor 170. js for 循环注意点 171. 一个列表，假设有 100000 个数据，这个该怎么办？ 172. js 中倒计时的纠偏实现？ 173. 进程间通信的方式？ 174. 如何查找一篇英文文章中出现频率最高的单词？ 175. ele.getElementsByClassName和ele.querySelectorAll的区别？ 1. 介绍 js 的基本数据类型。123js 一共有五种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。 2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？涉及知识点： 栈：原始数据类型（Undefined、Null、Boolean、Number、String） 堆：引用数据类型（对象、数组和函数） 123456两种类型的区别是：存储位置不同。原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 回答： 12345678js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。基本数据类型....（参考1）复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。 详细资料可以参考：《JavaScript 有几种类型的值？》《JavaScript 有几种类型的值？能否画一下它们的内存图；》 3. 什么是堆？什么是栈？它们之间有什么区别和联系？12345678910堆和栈的概念存在于数据结构中和操作系统内存中。在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。 详细资料可以参考：《什么是堆？什么是栈？他们之间有什么区别和联系？》 4. 内部属性 [[Class]] 是什么？1234567891011121314151617181920所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：Object.prototype.toString.call( [1,2,3] );// &quot;[object Array]&quot;Object.prototype.toString.call( /regex-literal/i );// &quot;[object RegExp]&quot;// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签// 默认情况类的[[Class]]返回[object Object]class Class1 &#123;&#125;Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;// 需要定制[[Class]]class Class2 &#123; get [Symbol.toStringTag]() &#123; return &quot;Class2&quot;; &#125;&#125;Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot; 5. 介绍 js 有哪些内置对象？涉及知识点： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。标准内置对象的分类（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等（10）控制抽象对象例如 Promise、Generator 等（11）反射例如 Reflect、Proxy（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等（13）WebAssembly（14）其他例如 arguments 回答： 123js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。 详细资料可以参考：《标准内置对象的分类》《JS 所有内置对象属性和方法汇总》 6. undefined 与 undeclared 的区别？1234已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。 7. null 和 undefined 的区别？12345678910首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。 详细资料可以参考：《JavaScript 深入理解之 undefined 与 null》 8. 如何获取安全的 undefined 值？12345因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。按惯例我们用 void 0 来获得 undefined。 9. 说几条写 JavaScript 的基本规范？12345678910111213141516在平常项目开发中，我们遵守一些这样的基本规范，比如说：（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时 如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。（2）代码中出现地址、时间等字符串时需要使用常量代替。（3）在进行比较的时候吧，尽量使用&apos;===&apos;, &apos;!==&apos;代替&apos;==&apos;, &apos;!=&apos;。（4）不要在内置对象的原型上添加方法，如 Array, Date。（5）switch 语句必须带有 default 分支。（6）for 循环必须使用大括号。（7）if 语句必须使用大括号。 10. JavaScript 原型，原型链？ 有什么特点？123456789101112131415在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。特点：JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 详细资料可以参考：《JavaScript 深入理解之原型与原型链》 11. js 获取原型的方法？ p.__proto__ p.constructor.prototype Object.getPrototypeOf(p) 12. 在 js 中不同进制数字的表示方式 以 0X、0x 开头的表示为十六进制。 以 0、0O、0o 开头的表示为八进制。 以 0B、0b 开头的表示为二进制格式。 13. js 中整数的安全范围是多少？1234567安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。 14. typeof NaN 的结果是什么？1234567NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。typeof NaN; // &quot;number&quot;NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。 15. isNaN 和 Number.isNaN 函数的区别？12345函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。 16. Array 构造函数只有一个参数值时的表现？1234Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 17. 其他值到字符串的转换规则？12345678910111213规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。（1）Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，（2）Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()） 来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会 调用该方法并使用其返回值。 18. 其他值到数字值的转换规则？1234567891011121314151617有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。（1）Undefined 类型的值转换为 NaN。（2）Null 类型的值转换为 0。（3）Boolean 类型的值，true 转换为 1，false 转换为 0。（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。（5）Symbol 类型的值不能转换为数字，会报错。（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。 19. 其他值到布尔类型的值的转换规则？12345678910ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。以下这些是假值：• undefined• null• false• +0、-0 和 NaN• &quot;&quot;假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。 20. {} 和 [] 的 valueOf 和 toString 的结果是什么？123&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot; 21. 什么是假值对象？123浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。 22. ~ 操作符的作用？123~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。~x 大致等同于 -(x+1)。 23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？12解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。 24. + 操作符什么时候用于字符串的拼接？12345678根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。 25. 什么情况下会发生布尔值的隐式强制类型转换？12345（1） if (..) 语句中的条件判断表达式。（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。（3） while (..) 和 do..while(..) 循环中的条件判断表达式。（4） ? : 中的条件判断表达式。（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。 26. || 和 &amp;&amp; 操作符的返回值？12345678|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果 27. Symbol 值的强制类型转换？1234ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。 28. == 操作符的强制类型转换规则？1234567891011（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。 详细资料可以参考：《JavaScript 字符串间的比较》 29. 如何将字符串转化为数字，例如 ‘12.3b’?1234567（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。 详细资料可以参考：《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》 30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?123456789101112// 方法一function format(number) &#123; return number &amp;&amp; number.replace(/(?!^)(?=(\\d&#123;3&#125;)+\\.)/g, \",\");&#125;// 方法二function format1(number) &#123; return Intl.NumberFormat().format(number)&#125;// 方法三function format2(number) &#123; return number.toLocaleString('en')&#125; 31. 常用正则表达式1234567891011121314// （1）匹配 16 进制颜色值var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;// （2）匹配日期，如 yyyy-mm-dd 格式var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;// （3）匹配 qq 号var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;// （4）手机号码正则var regex = /^1[34578]\\d&#123;9&#125;$/g;// （5）用户名正则var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]&#123;4,16&#125;$/; 详细资料可以参考：《前端表单验证常用的 15 个 JS 正则表达式》《JS 常用正则汇总》 32. 生成随机数的各种方法？《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》 33. 如何实现数组的随机排序？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。function randomSort(a, b) &#123; return Math.random() &gt; 0.5 ? -1 : 1;&#125;// 缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。// （2）随机从原数组抽取一个元素，加入到新数组function randomSort(arr) &#123; var result = []; while (arr.length &gt; 0) &#123; var randomIndex = Math.floor(Math.random() * arr.length); result.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return result;&#125;// （3）随机交换数组内的元素（洗牌算法类似）function randomSort(arr) &#123; var index, randomIndex, temp, len = arr.length; for (index = 0; index &lt; len; index++) &#123; randomIndex = Math.floor(Math.random() * (len - index)) + index; temp = arr[index]; arr[index] = arr[randomIndex]; arr[randomIndex] = temp; &#125; return arr;&#125;// es6function randomSort(array) &#123; let length = array.length; if (!Array.isArray(array) || length &lt;= 1) return; for (let index = 0; index &lt; length - 1; index++) &#123; let randomIndex = Math.floor(Math.random() * (length - index)) + index; [array[index], array[randomIndex]] = [array[randomIndex], array[index]]; &#125; return array;&#125; 详细资料可以参考：《Fisher and Yates 的原始版》《javascript 实现数组随机排序?》《JavaScript 学习笔记：数组随机排序》 34. javascript 创建对象的几种方式？1234567891011121314151617我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。嗯我目前了解到的就是这么几种方式。 详细资料可以参考：《JavaScript 深入理解之对象创建》 35. JavaScript 继承的几种实现方式？12345678910111213我了解的 js 中实现继承的几种方式有：（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。 详细资料可以参考：《JavaScript 深入理解之继承》 36. 寄生式组合继承的实现？12345678910111213141516171819function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; console.log(\"My name is \" + this.name + \".\");&#125;;function Student(name, grade) &#123; Person.call(this, name); this.grade = grade;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.sayMyGrade = function() &#123; console.log(\"My grade is \" + this.grade + \".\");&#125;; 37. Javascript 的作用域链？123456789作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。作用域链的创建过程跟执行上下文的建立有关.... 详细资料可以参考：《JavaScript 深入理解之作用域链》 38. 谈谈 This 对象的理解。12this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。 1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。 2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。 3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。 4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。 12这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。 《JavaScript 深入理解之 this 详解》 39. eval 是做什么的？123它的功能是把对应的字符串解析成 JS 代码并运行。应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。 详细资料可以参考：《eval()》 40. 什么是 DOM 和 BOM？1234567DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。 详细资料可以参考：《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》《Window 对象》《DOM 与 BOM 分别是什么，有何关联？》《JavaScript 学习总结（三）BOM 和 DOM 详解》 41. 写一个通用的事件侦听器函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const EventUtils = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 添加事件 addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, // 移除事件 removeEvent: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, // 获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event getEvent: function(event) &#123; return event || window.event; &#125;, // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获） stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;&#125;; 详细资料可以参考：《JS 事件模型》 42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？ 1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。 2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。 3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true; 详细资料可以参考：《Javascript 事件模型系列（一）事件及事件的三种模型》《Javascript 事件模型：事件捕获和事件冒泡》 43. 三种事件模型是什么？12345678事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。 详细资料可以参考：《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》 44. 事件委托是什么？1234事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。 详细资料可以参考：《JavaScript 事件委托详解》 45. [“1”, “2”, “3”].map(parseInt) 答案是多少？123456parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 &quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。 详细资料可以参考：《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》 46. 什么是闭包，为什么要用它？123456789101112闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。闭包有两个常用的用途。闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。 详细资料可以参考：《JavaScript 深入理解之闭包》 47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？相关知识点： 123use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立&quot;严格模式&quot;的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 区别： 1.禁止使用 with 语句。 2.禁止 this 关键字指向全局对象。 3.对象不能有重名的属性。 回答： 1234use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。 详细资料可以参考：《Javascript 严格模式详解》 48. 如何判断一个对象是否属于某个类？123456第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。 详细资料可以参考：《js 判断一个对象是否属于某一类》 49. instanceof 的作用？123456789101112131415// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。// 实现：function myInstanceof(left, right) &#123; let proto = Object.getPrototypeOf(left), // 获取对象的原型 prototype = right.prototype; // 获取构造函数的 prototype 对象 // 判断构造函数的 prototype 对象是否在对象的原型链上 while (true) &#123; if (!proto) return false; if (proto === prototype) return true; proto = Object.getPrototypeOf(proto); &#125;&#125; 详细资料可以参考：《instanceof》 50. new 操作符具体干了什么呢？如何实现？12345678910111213141516171819202122232425262728293031323334// （1）首先创建了一个新的空对象// （2）设置原型，将对象的原型设置为函数的 prototype 对象。// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。// 实现:function objectFactory() &#123; let newObject = null, constructor = Array.prototype.shift.call(arguments), result = null; // 参数判断 if (typeof constructor !== \"function\") &#123; console.error(\"type error\"); return; &#125; // 新建一个空对象，对象的原型为构造函数的 prototype 对象 newObject = Object.create(constructor.prototype); // 将 this 指向新建对象，并执行函数 result = constructor.apply(newObject, arguments); // 判断返回对象 let flag = result &amp;&amp; (typeof result === \"object\" || typeof result === \"function\"); // 判断返回结果 return flag ? result : newObject;&#125;// 使用方法// objectFactory(构造函数, 初始化参数); 详细资料可以参考：《new 操作符具体干了什么？》《JavaScript 深入之 new 的模拟实现》 51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？1234hasOwnProperty所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。 详细资料可以参考：《Object.prototype.hasOwnProperty()》 52. 对于 JSON 的了解？相关知识点： 123456JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。 回答： 123456789JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。 详细资料可以参考：《深入了解 JavaScript 中的 JSON 》 53. [].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？1234567（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。（2）循环遍历 DOM 元素（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。 详细资料可以参考：《通过一行代码学 JavaScript》 54. js 延迟加载的方式有哪些？相关知识点： 1js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。 一般有以下几种方式： defer 属性 async 属性 动态创建 DOM 方式 使用 setTimeout 延迟方法 让 JS 最后加载 回答： 1234567891011js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。我了解到的几种方式是：第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。 详细资料可以参考：《JS 延迟加载的几种方式》《HTML 5 &lt;script&gt; async 属性》 55. Ajax 是什么? 如何创建一个 Ajax？相关知识点： 2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 具体来说，AJAX 包括以下几个步骤。 1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息 3.设置响应 HTTP 请求状态变化的函数 4.发送 HTTP 请求 5.获取异步调用返回的数据 6.使用 JavaScript 和 DOM 实现局部刷新 一般实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const SERVER_URL = \"/server\";let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(\"GET\", SERVER_URL, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功时 if (this.status === 200) &#123; handle(this.response); &#125; else &#123; console.error(this.statusText); &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123; console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = \"json\";xhr.setRequestHeader(\"Accept\", \"application/json\");// 发送 Http 请求xhr.send(null);// promise 封装实现：function getJSON(url) &#123; // 创建一个 promise 对象 let promise = new Promise(function(resolve, reject) &#123; let xhr = new XMLHttpRequest(); // 新建一个 http 请求 xhr.open(\"GET\", url, true); // 设置状态的监听函数 xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; // 设置错误监听函数 xhr.onerror = function() &#123; reject(new Error(this.statusText)); &#125;; // 设置响应的数据类型 xhr.responseType = \"json\"; // 设置请求头信息 xhr.setRequestHeader(\"Accept\", \"application/json\"); // 发送 http 请求 xhr.send(null); &#125;); return promise;&#125; 回答： 1234567891011我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。创建一个 ajax 有这样几个步骤首先是创建一个 XMLHttpRequest 对象。然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。 详细资料可以参考：《XMLHttpRequest 对象》《从 ajax 到 fetch、axios》《Fetch 入门》《传统 Ajax 已死，Fetch 永生》 56. 谈一谈浏览器的缓存机制？123456789101112131415161718192021222324252627浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。 详细资料可以参考：《浅谈浏览器缓存》《前端优化：浏览器缓存技术介绍》《请求头中的 Cache-Control》《Cache-Control 字段值详解》 57. Ajax 解决浏览器缓存问题？ 1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。 4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。 5.如果是使用 jQuery，直接这样就可以了\\$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。 详细资料可以参考：《Ajax 中浏览器的缓存问题解决方法》《浅谈浏览器缓存》 58. 同步和异步的区别？相关知识点： 123同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 回答： 12345同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。 详细资料可以参考：《同步和异步的区别》 59. 什么是浏览器的同源政策？12345678910111213我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。同源政策主要限制了三个方面第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。第三个是当前域下 ajax 无法发送跨域请求。同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。 60. 如何解决跨域问题？相关知识点： 通过 jsonp 跨域 document.domain + iframe 跨域 location.hash + iframe window.name + iframe 跨域 postMessage 跨域 跨域资源共享（CORS) nginx 代理跨域 nodejs 中间件代理跨域 WebSocket 协议跨域 回答： 12345678910111213141516171819202122232425解决跨域的方法我们可以根据我们想要实现的目的来划分。首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。（7）使用 websocket 协议，这个协议没有同源限制。（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。 详细资料可以参考：《前端常见跨域解决方案（全）》《浏览器同源政策及其规避方法》《跨域，你需要知道的全在这里》《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》 61. 服务器代理转发时，该如何处理 cookie？详细资料可以参考：《深入浅出 Nginx》 62. 简单谈一下 cookie ？12345我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了9个属性值 name、value、expires、domain、path、secure、HttpOnly、SameSite、Priority。其中 name 和 value 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。 详细资料可以参考：《HTTP cookies》 《聊一聊 cookie》 63. 模块化开发怎么做？12345678910我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。 详细资料可以参考：《浅谈模块化开发》《Javascript 模块化编程（一）：模块的写法》《前端模块化：CommonJS，AMD，CMD，ES6》《Module 的语法》 64. js 的几种模块规范？12345678910111213js 中现在比较成熟的有四种模块加载方案。第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。 65. AMD 和 CMD 规范的区别？它们之间的主要区别有两个方面。 （1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。 （2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。 123456789101112131415161718// CMDdefine(function(require, exports, module) &#123; var a = require(\"./a\"); a.doSomething(); // 此处略去 100 行 var b = require(\"./b\"); // 依赖可以就近书写 b.doSomething(); // ...&#125;);// AMD 默认推荐define([\"./a\", \"./b\"], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething(); // 此处略去 100 行 b.doSomething(); // ...&#125;); 详细资料可以参考：《前端模块化，AMD 与 CMD 的区别》 66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。 1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）1require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。 详细资料可以参考：《requireJS 的用法和原理分析》《requireJS 的核心原理是什么？》《从 RequireJs 源码剖析脚本加载原理》《requireJS 原理分析》 68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？详细资料可以参考：《JS 模块加载器加载原理是怎么样的？》 69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?123在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。在 class 中添加的方法，其实是添加在类的原型上的。 详细资料可以参考：《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》《Class 的基本语法》 70. documen.write 和 innerHTML 的区别？123document.write 的内容会代替整个文档内容，会重写整个页面。innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。 详细资料可以参考：《简述 document.write 和 innerHTML 的区别。》 71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？（1）创建新节点 123createDocumentFragment(node);createElement(node);createTextNode(text); （2）添加、移除、替换、插入 1234appendChild(node)removeChild(node)replaceChild(new,old)insertBefore(new,old) （3）查找 123456getElementById();getElementsByName();getElementsByTagName();getElementsByClassName();querySelector();querySelectorAll(); （4）属性操作 1234getAttribute(key);setAttribute(key, value);hasAttribute(key);removeAttribute(key); 详细资料可以参考：《DOM 概述》《原生 JavaScript 的 DOM 操作汇总》《原生 JS 中 DOM 节点相关 API 合集》 72. innerHTML 与 outerHTML 的区别？123456对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。innerHTML：内部 HTML，content&lt;br/&gt;；outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；innerText：内部文本，content ；outerText：内部文本，content ； 73. .call() 和 .apply() 的区别？12345它们的作用一模一样，区别仅在于传入参数的形式的不同。apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。 详细资料可以参考：《apply、call 的区别和用途》 74. JavaScript 类数组对象的定义？1234一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。 常见的类数组转换为数组的方法有这样几种： （1）通过 call 调用数组的 slice 方法来实现转换 1Array.prototype.slice.call(arrayLike); （2）通过 call 调用数组的 splice 方法来实现转换 1Array.prototype.splice.call(arrayLike, 0); （3）通过 apply 调用数组的 concat 方法来实现转换 1Array.prototype.concat.apply([], arrayLike); （4）通过 Array.from 方法来实现转换 1Array.from(arrayLike); 详细的资料可以参考：《JavaScript 深入之类数组对象与 arguments》《javascript 类数组》《深入理解 JavaScript 类数组》 75. 数组和对象有哪些原生方法，列举一下？12345678910111213数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法数组归并方法 reduce() 和 reduceRight() 方法 详细资料可以参考：《JavaScript 深入理解之 Array 类型详解》 76. 数组的 fill 方法？12fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。 详细资料可以参考：《Array.prototype.fill()》 77. [,,,] 的长度？1234567尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。 详细资料可以参考：《尾后逗号》 78. JavaScript 中的作用域与变量声明提升？123变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。 详细资料可以参考：《JavaScript 深入理解之变量对象》 79. 如何编写高性能的 Javascript ？ 1.使用位运算代替一些简单的四则运算。 2.避免使用过深的嵌套循环。 3.不要使用未定义的变量。 4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。 详细资料可以参考：《如何编写高性能的 Javascript？》 80. 简单介绍一下 V8 引擎的垃圾回收机制123456789101112131415161718192021v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。（2）如果对象不存活，则释放对象的空间。（3）最后将 From 空间和 To 空间角色进行交换。新生代对象晋升到老生代有两个条件：（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。 详细资料可以参考：《深入理解 V8 的垃圾回收原理》《JavaScript 中的垃圾回收》 81. 哪些操作会造成内存泄漏？相关知识点： 1.意外的全局变量 2.被遗忘的计时器或回调函数 3.脱离 DOM 的引用 4.闭包 回答： 123456789第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。 详细资料可以参考：《JavaScript 内存泄漏教程》《4 类 JavaScript 内存泄漏及如何避免》《杜绝 js 中四种内存泄漏类型的发生》《javascript 典型内存泄漏及 chrome 的排查方法》 82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？123456通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。 详细资料可以参考：《pushState + ajax 实现浏览器无刷新前进后退》《Manipulating the browser history》 83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）123typeof window === &apos;undefined&apos; ? &apos;node&apos; : &apos;browser&apos;;通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。 84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？详细资料可以参考：《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》《从 Chrome 源码看浏览器如何加载资源》 85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？1移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。 有三种办法来解决这个问题： 1.通过 meta 标签禁用网页的缩放。 2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。 3.调用一些 js 库，比如 FastClick 1click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。 详细资料可以参考：《移动端 300ms 点击延迟和点击穿透》 86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？123456789101112131415（1）什么是前端路由？前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。（2）什么时候使用前端路由？在单页面应用，大部分页面结构不变，只改变部分内容的使用（3）前端路由有什么优点和缺点？优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。 详细资料可以参考：《什么是“前端路由”》《浅谈前端路由》 《前端路由是什么东西？》 87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？详细资料可以参考：《浅谈前端单元测试》 88. 检测浏览器版本版本有哪些方式？12345检测浏览器版本一共有两种方式：一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。 详细资料可以参考：《JavaScript 判断浏览器类型》 89. 什么是 Polyfill ？12345Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。 详细资料可以参考：《Web 开发中的“黑话”》《Polyfill 为何物》 90. 使用 JS 实现获取文件扩展名？12345678// String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。// 对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为\"\"。function getFileExtension(filename) &#123; return filename.slice(((filename.lastIndexOf(\".\") - 1) &gt;&gt;&gt; 0) + 2);&#125; 详细资料可以参考：《如何更有效的获取文件扩展名》 91. 介绍一下 js 的节流与防抖？相关知识点： 1234567891011121314151617181920212223242526272829303132333435363738394041// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。// 函数防抖的实现function debounce(fn, wait) &#123; var timer = null; return function() &#123; var context = this, args = arguments; // 如果此时存在定时器的话，则取消之前的定时器重新记时 if (timer) &#123; clearTimeout(timer); timer = null; &#125; // 设置定时器，使事件间隔指定事件后执行 timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, wait); &#125;;&#125;// 函数节流的实现;function throttle(fn, delay) &#123; var preTime = Date.now(); return function() &#123; var context = this, args = arguments, nowTime = Date.now(); // 如果两次时间间隔超过了指定时间，则执行函数。 if (nowTime - preTime &gt;= delay) &#123; preTime = Date.now(); return fn.apply(context, args); &#125; &#125;;&#125; 回答： 123函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。 详细资料可以参考：《轻松理解 JS 函数节流和函数防抖》《JavaScript 事件节流和事件防抖》《JS 的防抖与节流》 92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？相关知识点： 123456两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 回答： 12345使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。 93. escape,encodeURI,encodeURIComponent 有什么区别？相关知识点： 12escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。 回答： 12345encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。 详细资料可以参考：《escape,encodeURI,encodeURIComponent 有什么区别?》 94. Unicode 和 UTF-8 之间的关系？123Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。 详细资料可以参考：《字符编码详解》《字符编码笔记：ASCII，Unicode 和 UTF-8》 95. js 的事件循环是什么？相关知识点： 1事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。 回答： 123456因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。 详细资料可以参考：《浏览器事件循环机制（event loop）》《详解 JavaScript 中的 Event Loop（事件循环）机制》《什么是 Event Loop？》《这一次，彻底弄懂 JavaScript 执行机制》 96. js 中的深浅拷贝实现？相关资料： 12345678910111213141516171819202122232425262728293031323334// 浅拷贝的实现;function shallowCopy(object) &#123; // 只拷贝对象 if (!object || typeof object !== \"object\") return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : &#123;&#125;; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = object[key]; &#125; &#125; return newObject;&#125;// 深拷贝的实现;function deepCopy(object) &#123; if (!object || typeof object !== \"object\") return object; let newObject = Array.isArray(object) ? [] : &#123;&#125;; for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = deepCopy(object[key]); &#125; &#125; return newObject;&#125; 回答： 123浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。 详细资料可以参考：《JavaScript 专题之深浅拷贝》《前端面试之道》 97. 手写 call、apply 及 bind 函数相关资料： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// call函数实现Function.prototype.myCall = function(context) &#123; // 判断调用对象 if (typeof this !== \"function\") &#123; console.error(\"type error\"); &#125; // 获取参数 let args = [...arguments].slice(1), result = null; // 判断 context 是否传入，如果未传入则设置为 window context = context || window; // 将调用函数设为对象的方法 context.fn = this; // 调用函数 result = context.fn(...args); // 将属性删除 delete context.fn; return result;&#125;;// apply 函数实现Function.prototype.myApply = function(context) &#123; // 判断调用对象是否为函数 if (typeof this !== \"function\") &#123; throw new TypeError(\"Error\"); &#125; let result = null; // 判断 context 是否存在，如果未传入则为 window context = context || window; // 将函数设为对象的方法 context.fn = this; // 调用方法 if (arguments[1]) &#123; result = context.fn(...arguments[1]); &#125; else &#123; result = context.fn(); &#125; // 将属性删除 delete context.fn; return result;&#125;;// bind 函数实现Function.prototype.myBind = function(context) &#123; // 判断调用对象是否为函数 if (typeof this !== \"function\") &#123; throw new TypeError(\"Error\"); &#125; // 获取参数 var args = [...arguments].slice(1), fn = this; return function Fn() &#123; // 根据调用方式，传入不同绑定值 return fn.apply( this instanceof Fn ? this : context, args.concat(...arguments) ); &#125;;&#125;; 回答： call 函数的实现步骤： 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。 3.处理传入的参数，截取第一个参数后的所有参数。 4.将函数作为上下文对象的一个属性。 5.使用上下文对象来调用这个方法，并保存返回结果。 6.删除刚才新增的属性。 7.返回结果。 apply 函数的实现步骤： 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。 3.将函数作为上下文对象的一个属性。 4.判断参数值是否传入 4.使用上下文对象来调用这个方法，并保存返回结果。 5.删除刚才新增的属性 6.返回结果 bind 函数的实现步骤： 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。 2.保存当前函数的引用，获取其余传入参数值。 3.创建一个函数返回 4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。 详细资料可以参考：《手写 call、apply 及 bind 函数》《JavaScript 深入之 call 和 apply 的模拟实现》 98. 函数柯里化的实现12345678910111213141516171819202122232425262728293031// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) &#123; // 获取函数需要的参数长度 let length = fn.length; args = args || []; return function() &#123; let subArgs = args.slice(0); // 拼接得到现有的所有参数 for (let i = 0; i &lt; arguments.length; i++) &#123; subArgs.push(arguments[i]); &#125; // 判断参数的长度是否已经满足函数所需参数的长度 if (subArgs.length &gt;= length) &#123; // 如果满足，执行函数 return fn.apply(this, subArgs); &#125; else &#123; // 如果不满足，递归返回科里化的函数，等待参数的传入 return curry.call(this, fn, subArgs); &#125; &#125;;&#125;// es6 实现function curry(fn, ...args) &#123; return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);&#125; 详细资料可以参考：《JavaScript 专题之函数柯里化》 99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？123456当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON 详细资料可以参考：《十进制的 0.1 为什么不能用二进制很好的表示？》《十进制浮点数转成二进制》《浮点数的二进制表示》《js 浮点数存储精度丢失原理》《浮点数精度之谜》《JavaScript 浮点数陷阱及解法》《0.1+0.2 !== 0.3？》《JavaScript 中奇特的~运算符》 100. 原码、反码和补码的介绍1234567891011原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。正数的补码和其原码一样；负数的补码为其反码加1。例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。 详细资料可以参考：《关于 2 的补码》 101. toPrecision 和 toFixed 和 Math.round 的区别？123toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。toFixed 是对小数点后指定位数取整，从小数点开始数起。Math.round 是将一个数字四舍五入到一个整数。 102. 什么是 XSS 攻击？如何防范 XSS 攻击？123456789101112131415161718192021XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。 详细资料可以参考：《前端安全系列（一）：如何防止 XSS 攻击？》 103. 什么是 CSP？1234CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;metahttp-equiv=&quot;Content-Security-Policy&quot;&gt; 详细资料可以参考：《内容安全策略（CSP）》《前端面试之道》 104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？1234567891011121314151617181920212223CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。一般的 CSRF 攻击类型有三种：第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。CSRF 可以用下面几种方法来防护：第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。 详细资料可以参考：《前端安全系列之二：如何防止 CSRF 攻击？》《[ HTTP 趣谈] origin, referer 和 host 区别》 105. 什么是 Samesite Cookie 属性？1234567Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。 106. 什么是点击劫持？如何防范点击劫持？1234点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。 详细资料可以参考：《web 安全之–点击劫持攻击与防御技术简介》 107. SQL 注入攻击？12SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。 详细资料可以参考：《Web 安全漏洞之 SQL 注入》《如何防范常见的 Web 攻击》 108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？123456789101112MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。 详细资料可以参考：《浅析前端开发中的 MVC/MVP/MVVM 模式》《MVC，MVP 和 MVVM 的图示》《MVVM》《一篇文章了解架构模式：MVC/MVP/MVVM》 109. vue 双向数据绑定原理？12345678910vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。 详细资料可以参考：《Vue.js 双向绑定的实现原理》 110. Object.defineProperty 介绍？123Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。 详细资料可以参考：《Object.defineProperty()》 111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？1有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。 112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？123456789我对 Virtual DOM 的理解是，首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。 详细资料可以参考：《Virtual DOM》《理解 Virtual DOM》《深度剖析：如何实现一个 Virtual DOM 算法》《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》 113. 如何比较两个 DOM 树的差异？12345两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。 114. 什么是 requestAnimationFrame ？详细资料可以参考：《你需要知道的 requestAnimationFrame》《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》 115. 谈谈你对 webpack 的看法12345678910111213141516我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。 详细资料可以参考：《不聊 webpack 配置，来说说它的原理》《前端工程化——构建工具选型：grunt、gulp、webpack》《浅入浅出 webpack》《前端构建工具发展及其比较》 116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？1234567891011clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。 详细资料可以参考：《最全的获取元素宽高及位置的方法》《用 Javascript 获取页面元素的位置》 117. 谈一谈你理解的函数式编程？123简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;。 详细资料可以参考：《函数式编程初探》 118. 异步编程的实现方式？相关资料： 12345678910111213141516171819202122回调函数优点：简单、容易理解缺点：不利于维护，代码耦合高事件监听（采用时间驱动模式，取决于某个事件是否发生）：优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰发布/订阅（观察者模式）类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者Promise 对象优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对比较难Generator 函数优点：函数体内外的数据交换、错误处理机制缺点：流程管理不方便async 函数优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。缺点：错误处理机制 回答： 123456789js 中的异步机制可以分为以下几种：第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。 119. Js 动画与 CSS 动画区别及相应实现1234567891011CSS3 的动画的优点在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单缺点在动画控制上不够灵活兼容性不好JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧 120. get 请求传参长度的误区123误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点: 1.HTTP 协议未规定 GET 和 POST 的长度限制 2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度 3.不同的浏览器和 WEB 服务器，限制的最大长度不一样 4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte 121. URL 和 URI 的区别？1234567URI: Uniform Resource Identifier 指的是统一资源标识符URL: Uniform Resource Location 指的是统一资源定位符URN: Universal Resource Name 指的是统一资源名称URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。 详细资料可以参考：《HTTP 协议中 URI 和 URL 有什么区别？》《你知道 URL、URI 和 URN 三者之间的区别吗？》《URI、URL 和 URN 的区别》 122. get 和 post 请求在缓存方面的区别相关知识点： 123get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。 回答： 1缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。 详细资料可以参考：《HTML 关于 post 和 get 的区别以及缓存问题的理解》 123. 图片的懒加载和预加载相关知识点： 12345预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 回答： 12345懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 详细资料可以参考：《懒加载和预加载》《网页图片加载优化方案》《基于用户行为的图片等资源预加载》 124. mouseover 和 mouseenter 的区别？123当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。 详细资料可以参考：《mouseenter 与 mouseover 为何这般纠缠不清？》 125. js 拖拽功能的实现相关知识点： 1234567首先是三个事件，分别是 mousedown，mousemove，mouseup当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：鼠标移动时候的坐标-鼠标按下去时候的坐标。也就是说定位信息为：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft. 回答： 12345678一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。最后 mouseup 事件触发后，清除状态，结束拖拽事件。 详细资料可以参考：《原生 js 实现拖拽功能基本思路》 126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？相关知识点： 12345678910111213141516171819202122// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果function mySetInterval(fn, timeout) &#123; // 控制器，控制定时器是否继续执行 var timer = &#123; flag: true &#125;; // 设置递归函数，模拟定时器执行。 function interval() &#123; if (timer.flag) &#123; fn(); setTimeout(interval, timeout); &#125; &#125; // 启动定时器 setTimeout(interval, timeout); // 返回控制器 return timer;&#125; 回答： 123setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。 详细资料可以参考：《用 setTimeout 实现 setInterval》《setInterval 有什么缺点？》 127. let 和 const 的注意点？ 1.声明的变量只在声明时的代码块内有效 2.不存在声明提升 3.存在暂时性死区，如果在变量声明前使用，会报错 4.不允许重复声明，重复声明会报错 128. 什么是 rest 参数？1rest 参数（形式为...变量名），用于获取函数的多余参数。 129. 什么是尾调用，使用尾调用有什么好处？1尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 130. Symbol 类型的注意点？ 1.Symbol 函数前不能使用 new 命令，否则会报错。 2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。 4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。 131. Set 和 WeakSet 结构？ 1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用， 132. Map 和 WeakMap 结构？ 1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。 133. 什么是 Proxy ？123Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 134. Reflect 对象创建目的？ 1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。 2.修改某些 Object 方法的返回结果，让其变得更合理。 3.让 Object 操作都变成函数行为。 4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 135. require 模块引入的查找方式？12345678910111213141516171819202122232425当 Node 遇到 require(X) 时，按下面的顺序处理。（1）如果 X 是内置模块（比如 require(&apos;http&apos;)） a. 返回该模块。 b. 不再继续执行。（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头 a. 根据 X 所在的父模块，确定 X 的绝对路径。 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X X.js X.json X.node c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X/package.json（main字段） X/index.js X/index.json X/index.node（3）如果 X 不带路径 a. 根据 X 所在的父模块，确定 X 可能的安装目录。 b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4）抛出 &quot;not found&quot; 详细资料可以参考：《require() 源码解读》 136. 什么是 Promise 对象，什么是 Promises/A+ 规范？1234Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。 详细资料可以参考：《Promises/A+ 规范》《Promise》 137. 手写一个 Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const PENDING = \"pending\";const RESOLVED = \"resolved\";const REJECTED = \"rejected\";function MyPromise(fn) &#123; // 保存初始化状态 var self = this; // 初始化状态 this.state = PENDING; // 用于保存 resolve 或者 rejected 传入的值 this.value = null; // 用于保存 resolve 的回调函数 this.resolvedCallbacks = []; // 用于保存 reject 的回调函数 this.rejectedCallbacks = []; // 状态转变为 resolved 方法 function resolve(value) &#123; // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变 if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; // 保证代码的执行顺序为本轮事件循环的末尾 setTimeout(() =&gt; &#123; // 只有状态为 pending 时才能转变， if (self.state === PENDING) &#123; // 修改状态 self.state = RESOLVED; // 设置传入的值 self.value = value; // 执行回调函数 self.resolvedCallbacks.forEach(callback =&gt; &#123; callback(value); &#125;); &#125; &#125;, 0); &#125; // 状态转变为 rejected 方法 function reject(value) &#123; // 保证代码的执行顺序为本轮事件循环的末尾 setTimeout(() =&gt; &#123; // 只有状态为 pending 时才能转变 if (self.state === PENDING) &#123; // 修改状态 self.state = REJECTED; // 设置传入的值 self.value = value; // 执行回调函数 self.rejectedCallbacks.forEach(callback =&gt; &#123; callback(value); &#125;); &#125; &#125;, 0); &#125; // 将两个方法传入函数执行 try &#123; fn(resolve, reject); &#125; catch (e) &#123; // 遇到错误时，捕获错误，执行 reject 函数 reject(e); &#125;&#125;MyPromise.prototype.then = function(onResolved, onRejected) &#123; // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数 onResolved = typeof onResolved === \"function\" ? onResolved : function(value) &#123; return value; &#125;; onRejected = typeof onRejected === \"function\" ? onRejected : function(error) &#123; throw error; &#125;; // 如果是等待状态，则将函数加入对应列表中 if (this.state === PENDING) &#123; this.resolvedCallbacks.push(onResolved); this.rejectedCallbacks.push(onRejected); &#125; // 如果状态已经凝固，则直接执行对应状态的函数 if (this.state === RESOLVED) &#123; onResolved(this.value); &#125; if (this.state === REJECTED) &#123; onRejected(this.value); &#125;&#125;; 138. 如何检测浏览器所支持的最小字体大小？1用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。 139. 怎么做 JS 代码 Error 统计？1error 统计使用浏览器的 window.error 事件。 140. 单例模式模式是什么？1单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。 141. 策略模式是什么？12策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。 142. 代理模式是什么？1代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。 143. 中介者模式是什么？1中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。 144. 适配器模式是什么？123适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。 更多关于设计模式的资料可以参考：《前端面试之道》《JavaScript 设计模式》《JavaScript 中常见设计模式整理》 145. 观察者模式和发布订阅模式有什么不同？12345发布订阅模式其实属于广义上的观察者模式在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。 详细资料可以参考：《观察者模式和发布订阅模式有什么不同？》 146. Vue 的生命周期是什么？1Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。 147. Vue 的各个生命阶段是什么？12345678910111213141516171819Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 详细资料可以参考：《vue 生命周期深入》《Vue 实例》 148. Vue 组件间的参数传递方式？1234567891011121314151617181920212223242526（1）父子组件间通信第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。（2）兄弟组件间通信第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。（3）任意组件之间使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。 详细资料可以参考：《VUE 组件之间数据传递全集》 149. computed 和 watch 的差异？12345（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。 详细资料可以参考：《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》《深入理解 Vue 的 watch 实现原理及其实现方式》 150. vue-router 中的导航钩子函数12345678（1）全局的钩子函数 beforeEach 和 afterEachbeforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。 详细资料可以参考：《导航守卫》 151. $route 和 $router 的区别？1$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。 152. vue 常用的修饰符？1.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发； 153. vue 中 key 值的作用？12345vue 中 key 值的作用可以分为两种情况来考虑。第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。 详细资料可以参考：《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》《Vue2.0 v-for 中 :key 到底有什么用？》《vue 中 key 的作用》 154. computed 和 watch 区别？123computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 155. keep-alive 组件有什么作用？1如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 156. vue 中 mixin 和 mixins 区别？123mixin 用于全局混入，会影响到每个组件实例。mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并 详细资料可以参考：《前端面试之道》《混入》 157. 开发中常用的几种 Content-Type ？12345678910111213141516（1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。（2）multipart/form-data该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。（3）application/json告诉服务器消息主体是序列化后的 JSON 字符串。（4）text/xml该种方式主要用来提交 XML 格式的数据。 详细资料可以参考：《常用的几种 Content-Type》 158. 如何封装一个 javascript 的类型判断函数？12345678910111213141516171819function getType(value) &#123; // 判断数据是 null 的情况 if (value === null) &#123; return value + \"\"; &#125; // 判断数据是引用类型的情况 if (typeof value === \"object\") &#123; let valueClass = Object.prototype.toString.call(value), type = valueClass.split(\" \")[1].split(\"\"); type.pop(); return type.join(\"\").toLowerCase(); &#125; else &#123; // 判断数据是基本数据类型的情况和函数的情况 return typeof value; &#125;&#125; 详细资料可以参考：《JavaScript 专题之类型判断(上)》 159. 如何判断一个对象是否为空对象？123function checkNullObj(obj) &#123; return Object.keys(obj).length === 0 &amp;&amp; Object.getOwnPropertySymbols(obj).length === 0;&#125; 详细资料可以参考：《js 判断一个 object 对象是否为空》 160. 使用闭包实现每隔一秒打印 1,2,3,412345678910111213141516// 使用闭包实现for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;// 使用 let 块级作用域for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000);&#125; 161. 手写一个 jsonp1234567891011121314151617181920212223242526272829303132333435function jsonp(url, params, callback) &#123; // 判断是否含有参数 let queryString = url.indexOf(\"?\") === -1 ? \"?\" : \"&amp;\"; // 添加参数 for (var k in params) &#123; if (params.hasOwnProperty(k)) &#123; queryString += k + \"=\" + params[k] + \"&amp;\"; &#125; &#125; // 处理回调函数名 let random = Math.random() .toString() .replace(\".\", \"\"), callbackName = \"myJsonp\" + random; // 添加回调函数 queryString += \"callback=\" + callbackName; // 构建请求 let scriptNode = document.createElement(\"script\"); scriptNode.src = url + queryString; window[callbackName] = function() &#123; // 调用回调函数 callback(...arguments); // 删除这个引入的脚本 document.getElementsByTagName(\"head\")[0].removeChild(scriptNode); &#125;; // 发起请求 document.getElementsByTagName(\"head\")[0].appendChild(scriptNode);&#125; 详细资料可以参考：《原生 jsonp 具体实现》《jsonp 的原理与实现》 162. 手写一个观察者模式？123456789101112131415161718192021222324252627282930313233343536373839404142434445var events = (function() &#123; var topics = &#123;&#125;; return &#123; // 注册监听函数 subscribe: function(topic, handler) &#123; if (!topics.hasOwnProperty(topic)) &#123; topics[topic] = []; &#125; topics[topic].push(handler); &#125;, // 发布事件，触发观察者回调事件 publish: function(topic, info) &#123; if (topics.hasOwnProperty(topic)) &#123; topics[topic].forEach(function(handler) &#123; handler(info); &#125;); &#125; &#125;, // 移除主题的一个观察者的回调事件 remove: function(topic, handler) &#123; if (!topics.hasOwnProperty(topic)) return; var handlerIndex = -1; topics[topic].forEach(function(item, index) &#123; if (item === handler) &#123; handlerIndex = index; &#125; &#125;); if (handlerIndex &gt;= 0) &#123; topics[topic].splice(handlerIndex, 1); &#125; &#125;, // 移除主题的所有观察者的回调事件 removeAll: function(topic) &#123; if (topics.hasOwnProperty(topic)) &#123; topics[topic] = []; &#125; &#125; &#125;;&#125;)(); 详细资料可以参考：《JS 事件模型》 163. EventEmitter 实现12345678910111213141516171819202122232425262728293031323334353637383940class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125;; &#125; on(event, callback) &#123; let callbacks = this.events[event] || []; callbacks.push(callback); this.events[event] = callbacks; return this; &#125; off(event, callback) &#123; let callbacks = this.events[event]; this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback); return this; &#125; emit(event, ...args) &#123; let callbacks = this.events[event]; callbacks.forEach(fn =&gt; &#123; fn(...args); &#125;); return this; &#125; once(event, callback) &#123; let wrapFun = (...args) =&gt; &#123; callback(...args); this.off(event, wrapFun); &#125;; this.on(event, wrapFun); return this; &#125;&#125; 164. 一道常被人轻视的前端 JS 面试题123456789101112131415161718192021222324252627function Foo() &#123; getName = function() &#123; alert(1); &#125;; return this;&#125;Foo.getName = function() &#123; alert(2);&#125;;Foo.prototype.getName = function() &#123; alert(3);&#125;;var getName = function() &#123; alert(4);&#125;;function getName() &#123; alert(5);&#125;//请写出以下输出结果：Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 3 详细资料可以参考：《前端程序员经常忽视的一个 JavaScript 面试题》《一道考察运算符优先级的 JavaScript 面试题》《一道常被人轻视的前端 JS 面试题》 165. 如何确定页面的可用性时间，什么是 Performance API？12345678910Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。 根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下： 12var t = performance.timing;var pageLoadTime = t.loadEventEnd - t.navigationStart; 详细资料可以参考：《Performance API》 166. js 中的命名规则1234（1）第一个字符必须是字母、下划线（_）或美元符号（$）（2）余下的字符可以是下划线、美元符号或任何字母或数字字符一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。 详细资料可以参考：《ECMAScript 变量》 167. js 语句末尾分号是否可以省略？12在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。 168. Object.assign()1Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 169. Math.ceil 和 Math.floor123Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。 170. js for 循环注意点123456for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) &#123; console.log(i, j);&#125;// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。// 当判断语句为空时，循环会一直进行。 171. 一个列表，假设有 100000 个数据，这个该怎么办？123456789我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？解决办法：（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。 172. js 中倒计时的纠偏实现？1234567在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。一般解决倒计时中的误差的有这样两种办法：（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。 详细资料可以参考：《JavaScript 前端倒计时纠偏实现》 173. 进程间通信的方式？ 1.管道通信 2.消息队列通信 3.信号量通信 4.信号通信 5.共享内存通信 6.套接字通信 详细资料可以参考：《进程间 8 种通信方式详解》《进程与线程的一个简单解释》 174. 如何查找一篇英文文章中出现频率最高的单词？123456789101112131415161718192021222324252627282930313233function findMostWord(article) &#123; // 合法性判断 if (!article) return; // 参数处理 article = article.trim().toLowerCase(); let wordList = article.match(/[a-z]+/g), visited = [], maxNum = 0, maxWord = \"\"; article = \" \" + wordList.join(\" \") + \" \"; // 遍历判断单词出现次数 wordList.forEach(function(item) &#123; if (visited.indexOf(item) &lt; 0) &#123; // 加入 visited visited.push(item); let word = new RegExp(\" \" + item + \" \", \"g\"), num = article.match(word).length; if (num &gt; maxNum) &#123; maxNum = num; maxWord = item; &#125; &#125; &#125;); return maxWord + \" \" + maxNum;&#125; 175. ele.getElementsByClassName和ele.querySelectorAll的区别？123456789101112131415161718192021222324element.getElementsByClassName 返回一个即时更新（动态的）HTMLCollectionelement.querySelectorAll 返回一个非即时更新（静态的） NodeList// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）&lt;div id=&quot;parent&quot;&gt; &lt;p class=&quot;p&quot;&gt;1&lt;/p&gt; &lt;p class=&quot;p&quot;&gt;2&lt;/p&gt; &lt;p class=&quot;p&quot;&gt;3&lt;/p&gt;&lt;/div&gt;&lt;script&gt;let list1 = parent.getElementsByClassName(&apos;p&apos;);let list2 = parent.querySelectorAll(&apos;.p&apos;);console.log(list1.length1); // 3console.log(list2.length1); // 3let newP = docuemnt.createElement(&quot;p&quot;)newP.classList.add(&apos;p&apos;);parent.appendChild(newP);console.log(list1.length1); // 4 (即时更新)console.log(list2.length1); // 3（非即时更新）&lt;/script&gt;// 在说下返回值// HTMLCollection 和 NodeList 都是类数组形式如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollectionEventTarget - Node - Element - HTMLElement - HTMLDivElement&lt;br&gt;EventTarget - Node - Element - SVGElement - SVGPathElement&lt;br&gt; MDN 上元素 div 继承关系","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题系列","slug":"面试题系列","permalink":"/tags/面试题系列/"}]},{"title":"面试知识点之html","slug":"面试知识点之html","date":"2023-09-20T05:51:25.000Z","updated":"2024-01-11T07:00:59.290Z","comments":true,"path":"2023/09/20/面试知识点之html/","link":"","permalink":"/2023/09/20/面试知识点之html/","excerpt":"HTML 面试知识点总结","text":"HTML 面试知识点总结 HTML 面试知识点总结本部分主要是笔者在复习 HTML 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！ 目录 1. DOCTYPE 的作用是什么？ 2. 标准模式与兼容模式各有什么区别？ 3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？ 4. SGML 、 HTML 、XML 和 XHTML 的区别？ 5. DTD 介绍 6. 行内元素定义 7. 块级元素定义 8. 行内元素与块级元素的区别？ 9. HTML5 元素的分类 10. 空元素定义 11. link 标签定义 12. 页面导入样式时，使用 link 和 @import 有什么区别？ 13. 你对浏览器的理解？ 14. 介绍一下你对浏览器内核的理解？ 15. 常见的浏览器内核比较 16. 常见浏览器所用内核 17. 浏览器的渲染原理？ 18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程） 19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程） 20. 什么是文档的预解析？（浏览器解析过程） 21. CSS 如何阻塞文档解析？（浏览器解析过程） 22. 渲染页面时常见哪些不良现象？（浏览器渲染过程） 23. 如何优化关键渲染路径？（浏览器渲染过程） 24. 什么是重绘和回流？（浏览器绘制过程） 25. 如何减少回流？（浏览器绘制过程） 26. 为什么操作 DOM 慢？（浏览器绘制过程） 27. DOMContentLoaded 事件和 Load 事件的区别？ 28. HTML5 有哪些新特性、移除了那些元素？ 29. 如何处理 HTML5 新标签的浏览器兼容问题？ 30. 简述一下你对 HTML 语义化的理解？ 31. b 与 strong 的区别和 i 与 em 的区别？ 32. 前端需要注意哪些 SEO ？ 33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？ 34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？ 35. 常见的浏览器端的存储技术有哪些？ 36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 37. iframe 有那些缺点？ 38. Label 的作用是什么？是怎么用的？ 39. HTML5 的 form 的自动完成功能是什么？ 40. 如何实现浏览器内多个标签页之间的通信? 41. webSocket 如何兼容低版本浏览器？ 42. 页面可见性（Page Visibility API） 可以有哪些用途？ 43. 如何在页面上实现一个圆形的可点击区域？ 44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 45. title 与 h1 的区别？ 46. &lt;img&gt; 的 title 和 alt 有什么区别？ 47. Canvas 和 SVG 有什么区别？ 48. 网页验证码是干嘛的，是为了解决什么安全问题？ 49. 渐进增强和优雅降级的定义 50. attribute 和 property 的区别是什么？ 51. 对 web 标准、可用性、可访问性的理解 52. IE 各版本和 Chrome 可以并行下载多少个资源？ 53. Flash、Ajax 各自的优缺点，在使用中如何取舍？ 54. 怎么重构页面？ 55. 浏览器架构 56. 常用的 meta 标签 57. css reset 和 normalize.css 有什么区别？ 58. 用于预格式化文本的标签是？ 59. DHTML 是什么？ 60. head 标签中必不少的是？ 61. HTML5 新增的表单元素有？ 62. 在 HTML5 中，哪个方法用于获得用户的当前位置？ 63. 文档的不同注释方式？ 64. disabled 和 readonly 的区别？ 65. 主流浏览器内核私有属性 css 前缀？ 66. 前端性能优化？ 67. Chrome 中的 Waterfall ？ 68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？ 69. Html 规范中为什么要求引用资源不加协议头http或者https？ 1. DOCTYPE 的作用是什么？ 相关知识点： 12345IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。&lt;!DOCTYPE&gt;声明位于 HTML 文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。 回答（参考1-5）： 123456&lt;!DOCTYPE&gt; 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。 2. 标准模式与兼容模式各有什么区别？ 12标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。 3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？ 1234HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。 4. SGML 、 HTML 、XML 和 XHTML 的区别？ 123456789SGML（Standard Generalized Markup language）是标准通用置标语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。HTML（HyperText Markup Language）是超文本标记语言，主要是用于规定怎么显示网页。XML（Extensible Markup Language）是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。XHTML（Extensible Hypertext Markup Language）也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。 5. DTD 介绍 1234DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。 6. 行内元素定义 1234HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间。常见的行内元素有 a b span img strong sub sup button input label select textarea 7. 块级元素定义 123块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。常见的块级元素有 div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p 8. 行内元素与块级元素的区别？ 123456HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei ght），设置 margin 和 padding 的上下不会对其他元素产生影响。 9. HTML5 元素的分类 123456HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive 10. 空元素定义 123标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。常见的空元素有：br hr img input link meta 11. link 标签定义 12345link 标签定义文档与外部资源的关系。link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。 12. 页面导入样式时，使用 link 和 @import 有什么区别？ 12345678910（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加 载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容 性问题。（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i mport 的方式插入样式。 13. 你对浏览器的理解？ 1234567891011121314浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些 浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。 14. 介绍一下你对浏览器内核的理解？ 12345678主要分成两部分：渲染引擎和 JS 引擎。渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。JS 引擎：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 15. 常见的浏览器内核比较 12345678910111213141516171819Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。 详细的资料可以参考： 《浏览器内核的解析和对比》 《五大主流浏览器内核的源起以及国内各大浏览器内核总结》 16. 常见浏览器所用内核 1234567891011121314151617181920（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；（4） Safari 浏览器内核：Webkit 内核；（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；（8） 百度浏览器、世界之窗内核：IE 内核；（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说 是基于火狐内核。 17. 浏览器的渲染原理？ 123456789101112131415161718（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。（2）然后对 CSS 进行解析，生成 CSSOM 规则树。（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩 形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也 可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动 重排”。（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组 件。 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其 余内容。 详细资料可以参考： 《浏览器渲染原理》 《浏览器的渲染原理简介》 《前端必读：浏览器内部工作原理》 《深入浅出浏览器渲染原理》 18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程） 123456JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程） 12345678（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执 行。（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。 当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执 行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。 详细资料可以参考： 《defer 和 async 的区别》 20. 什么是文档的预解析？（浏览器解析过程） 123Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。 21. CSS 如何阻塞文档解析？（浏览器解析过程） 123456理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。 22. 渲染页面时常见哪些不良现象？（浏览器渲染过程） 1234567FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示 出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 CSS 加载时间过长，或者 CSS 被放在了文档底 部。白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 JS 文件放在头部，脚本的加载会阻塞后面 文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。 详细资料可以参考： 《前端魔法堂：解秘 FOUC》 《白屏问题和 FOUC》 23. 如何优化关键渲染路径？（浏览器渲染过程） 1234567891011121314151617181920为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：（1）关键资源的数量。（2）关键路径长度。（3）关键字节的数量。关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。优化关键渲染路径的常规步骤如下：（1）对关键路径进行分析和特性描述：资源数、字节数、长度。（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。（3）优化关键字节数以缩短下载时间（往返次数）。（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。 详细资料可以参考： 《优化关键渲染路径》 24. 什么是重绘和回流？（浏览器绘制过程） 1234567891011121314151617181920重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background -color，我们将这样的操作称为重绘。回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样 的操作我们称为回流。常见引起回流属性和方法：任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。（1）添加或者删除可见的 DOM 元素；（2）元素尺寸改变——边距、填充、边框、宽度和高度（3）内容变化，比如用户在 input 框中输入文字（4）浏览器窗口尺寸改变——resize事件发生时（5）计算 offsetWidth 和 offsetHeight 属性（6）设置 style 属性的值（7）当你修改网页的默认字体时。回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 常见引起重绘属性和方法： 常见引起回流属性和方法： 详细资料可以参考： 《浏览器的回流与重绘》 25. 如何减少回流？（浏览器绘制过程） 123456789（1）使用 transform 替代 top（2）不要把节点的属性值放在一个循环里当成循环里的变量（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局（4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM（5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 26. 为什么操作 DOM 慢？（浏览器绘制过程） 1一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。 27. DOMContentLoaded 事件和 Load 事件的区别？ 1234当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。Load 事件是当所有资源加载完成后触发的。 详细资料可以参考： 《DOMContentLoaded 事件 和 Load 事件的区别？》 28. HTML5 有哪些新特性、移除了那些元素？ 1234567891011121314151617HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。新增的有： 绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除;语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search;新的技术 webworker, websocket;新的文档属性 document.visibilityState移除的元素有：纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes； 29. 如何处理 HTML5 新标签的浏览器兼容问题？ 123456789（1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器 支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。（2） 当然也可以直接使用成熟的框架，比如 html5shiv ; `&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=\"https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js\"&lt;/script&gt; &lt;![endif]--&gt;` [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。 30. 简述一下你对 HTML 语义化的理解？ 相关知识点： 12345（1） 用正确的标签做正确的事情。（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 回答： 12345678我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签。 详细资料可以参考： 《语义化的 HTML 结构到底有什么好处？》 《如何理解 Web 语义化？》 《我的 HTML 会说话——从实用出发，谈谈 HTML 的语义化》 31. b 与 strong 的区别和 i 与 em 的区别？ 12345678从页面显示效果来看，被 &lt;b&gt; 和 &lt;strong&gt; 包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt; 包围的文字将以斜体的形式呈现。但是 &lt;b&gt; &lt;i&gt; 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 &#123; font-weight: bolder&#125;，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。而 &lt;em&gt; 和 &lt;strong&gt; 是语义样式标签。 &lt;em&gt; 表示一般的强调文本，而 &lt;strong&gt; 表示比 &lt;em&gt; 语义更强的强调文本。使用阅读设备阅读网页时：&lt;strong&gt; 会重读，而 &lt;b&gt; 是展示强调内容。 详细资料可以参考： 《HTML5 中的 b/strong，i/em 有什么区别？》 32. 前端需要注意哪些 SEO ？ 12345678910111213141516（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超 过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不 同页面 description 有所不同；keywords 列举出重要关键词即可。（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被 抓取。 （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容（6）非装饰性图片必须加 alt（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标 33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资 源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面 展示。如何使用：（1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。 &lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;（2）在如下 cache.manifest 文件的编写离线存储的资源。 CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出 来。 NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些 资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C ACHE 的优先级更高。 FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下 任何一个资源失败了，那么就去访问 offline.html 。（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。如何更新缓存：（1）更新 manifest 文件（2）通过 javascript 操作（3）清除浏览器缓存注意事项：（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。（4）FALLBACK 中的资源必须和 manifest 文件同源。（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。 详细的使用可以参考： 《HTML5 离线缓存-manifest 简介》 《有趣的 HTML5：离线存储》 34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？ 123456在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 35. 常见的浏览器端的存储技术有哪些？ 12345浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。 详细的资料可以参考： 《很全很全的前端本地存储讲解》 36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 相关资料： 1234567891011121314151617181920SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。存储大小： cookie 数据大小不能超过4 k 。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。 sessionStorage 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会 保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 作用域： sessionStorage 只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。 localStorage 在所有同源窗口中都是共享的。 cookie 在所有同源窗口中都是共享的。 回答： 1234567891011121314浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。 详细的资料可以参考： 《请描述一下 cookies，sessionStorage 和 localStorage 的区别？》 《浏览器数据库 IndexedDB 入门教程》 37. iframe 有那些缺点？ 12345678910iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。主要缺点有：（1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才 会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。（4） 浏览器的后退按钮失效。（5） 小型的移动设备无法完全显示框架。 详细的资料可以参考： 《使用 iframe 的优缺点》 《iframe 简单探索以及 iframe 跨域处理》 38. Label 的作用是什么？是怎么用的？ 1234label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt; 39. HTML5 的 form 的自动完成功能是什么？ 123456autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。 40. 如何实现浏览器内多个标签页之间的通信? 相关资料： 123456789（1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。（2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标 签页之间的双向通行。（3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触 发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；（4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。 回答： 1234567891011121314实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。 详细的资料可以参考： 《WebSocket 教程》 《WebSocket 协议：5分钟从入门到精通》 《WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室》 《使用 Web Storage API》 《JavaScript 的多线程，Worker 和 SharedWorker》 《实现多个标签页之间通信的几种方法》 41. webSocket 如何兼容低版本浏览器？ 1234Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR 42. 页面可见性（Page Visibility API） 可以有哪些用途？ 123456这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。（1）对服务器的轮询（2）网页动画（3）正在播放的音频或视频 详细资料可以参考： 《Page Visibility API 教程》 43. 如何在页面上实现一个圆形的可点击区域？ 123456789（1）纯 html 实现，使用 &lt;area&gt; 来给 &lt;img&gt; 图像标记热点区域的方式，&lt;map&gt; 标签用来定义一个客户端图像映射，&lt;area&gt; 标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击 的圆形区域。（2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的 点击区域。（3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我 们规定的圆形区域内。 详细资料可以参考： 《如何在页面上实现一个圆形的可点击区域？》 《HTML 标签及在实际开发中的应用》 44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 1&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt; 45. title 与 h1 的区别？ 1title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。 46. &lt;img&gt; 的 title 和 alt 有什么区别？ 1234title 通常当鼠标滑动到元素上的时候显示alt 是 &lt;img&gt; 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 47. Canvas 和 SVG 有什么区别？ 12345Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。 详细资料可以参考： 《SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？》 48. 网页验证码是干嘛的，是为了解决什么安全问题？ 12（1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水（2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 49. 渐进增强和优雅降级的定义 1234渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的 用户体验。优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。 50. attribute 和 property 的区别是什么？ 1234attribute 是 dom 元素在文档中作为 html 标签拥有的属性；property 就是 dom 元素在 js 中作为对象拥有的属性。对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。 51. 对 web 标准、可用性、可访问性的理解 1234567可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 52. IE 各版本和 Chrome 可以并行下载多少个资源？ 123（1） IE6 2 个并发（2） iE7 升级之后的 6 个并发，之后版本也是 6 个（3） Firefox，chrome 也是6个 53. Flash、Ajax 各自的优缺点，在使用中如何取舍？ 123456789101112Flash：（1） Flash 适合处理多媒体、矢量图形、访问机器（2） 对 CSS、处理文本上不足，不容易被搜索Ajax：（1） Ajax 对 CSS、文本支持很好，支持搜索（2） 多媒体、矢量图形、机器访问不足共同点：（1） 与服务器的无刷新传递消息（2） 可以检测用户离线和在线状态（3） 操作 DOM 54. 怎么重构页面？ 123（1） 编写 CSS（2） 让页面结构更合理化，提升用户体验（3） 实现良好的页面效果和提升性能 55. 浏览器架构 123456789101112* 用户界面 * 主进程 * 内核 * 渲染引擎 * JS 引擎 * 执行栈 * 事件触发线程 * 消息队列 * 微任务 * 宏任务 * 网络异步线程 * 定时器线程 56. 常用的 meta 标签 1234567891011121314151617181920212223242526272829303132333435&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。&lt;!DOCTYPE html&gt; H5标准声明，使用 HTML5 doctype，不区分大小写&lt;head lang=&quot;en&quot;&gt; 标准的 lang 属性写法&lt;meta charset=&quot;utf-8&quot;&gt; 声明文档使用的字符编码&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; 优先使用 IE 最新版本和 Chrome&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt; 页面描述&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt; 页面关键词者&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt; 网页作&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; 搜索引擎抓取&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; 为移动设备添加 viewport&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; iOS 设备 begin&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; 添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; 设置苹果工具栏颜色&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 避免IE使用兼容模式&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; 不让百度转码&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; 微软的老式浏览器&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; uc强制竖屏&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; QQ强制竖屏&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; UC强制全屏&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; QQ强制全屏&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; UC应用模式&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; QQ应用模式&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; windows phone 点击无高光设置页面不缓存&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 详细资料可以参考： 《Meta 标签用法大全》 57. css reset 和 normalize.css 有什么区别？ 相关知识点： 123456789101112131415161718192021222324252627282930313233343536373839为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题。reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。1.Normalize.css 保护了有价值的默认值Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normalize.css 会力求让这些样式保持一致并尽可能与现代标准相符合。2.Normalize.css 修复了浏览器的 bug它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中的与表单相关的 bug。3.Normalize.css 没有复杂的继承链使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。4.Normalize.css 是模块化的这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。5.Normalize.css 拥有详细的文档Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。 回答： 1234567css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成画蛇添足的效果。后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。 详细资料可以参考： 《关于CSS Reset 那些事（一）之 历史演变与 Normalize.css》 《Normalize.css 和 Reset CSS 有什么本质区别没？》 58. 用于预格式化文本的标签是？ 123预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。&lt;pre&gt; 定义预格式文本，保持文本原有的格式 59. DHTML 是什么？ 12345678910111213DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。包括：（1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。（2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、 文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样 式”即可以“动态”地改变排版样式。 60. head 标签中必不少的是？ 123456789&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 61. HTML5 新增的表单元素有？ 12345datalist 规定输入域的选项列表，通过 option 创建！ keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！output 元素用于不同类型的输出！ 62. 在 HTML5 中，哪个方法用于获得用户的当前位置？ 1getCurrentPosition() 63. 文档的不同注释方式？ 12345HTML 的注释方法 &lt;!--注释内容--&gt; CSS 的注释方法 /*注释内容*/ JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式 64. disabled 和 readonly 的区别？ 12345disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。 readonly 规定输入字段为只读。input 内容会随着表单提交。无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value 65. 主流浏览器内核私有属性 css 前缀？ 1234mozilla 内核 （firefox,flock 等） -mozwebkit 内核 （safari,chrome 等） -webkitopera 内核 （opera 浏览器） -otrident 内核 （ie 浏览器） -ms 66. 前端性能优化？ 12345678910111213141516171819202122232425262728293031前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。第一个方面是页面的内容方面（1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。（2）通过 DNS 缓存等机制来减少 DNS 的查询次数。（3）通过设置缓存策略，对常用不变的资源进行缓存。（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。第二个方面是服务器方面（1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。（2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。（3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie第三个方面是 CSS 和 JavaScript 方面（1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。（2）避免使用 @import 标签。（3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。（4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。 详细的资料可以参考： 《前端性能优化之雅虎35条军规》 《你真的了解 gzip 吗？》 《前端性能优化之 gzip》 67. Chrome 中的 Waterfall ？ 详细资料可以参考： 《前端性能之 Chrome 的 Waterfall》 《教你读懂网络请求的瀑布图》 《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》 68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？ 12345678910111213核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。我的理解二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成有效的安全防护。 详细资料可以参考： 《微信扫描二维码登录网页》 69. Html 规范中为什么要求引用资源不加协议头http或者https？ 12345678如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式不同。为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为 protocol-relative URL，暂且可译作协议相对 URL。如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省5字节的数据量。 详细资料可以参考： 《协议相对 URL》 《Why you need protocol-relative URLs now》","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题系列","slug":"面试题系列","permalink":"/tags/面试题系列/"}]},{"title":"video src blob","slug":"video-src-blob","date":"2023-07-11T06:06:46.000Z","updated":"2024-01-11T07:00:59.232Z","comments":true,"path":"2023/07/11/video-src-blob/","link":"","permalink":"/2023/07/11/video-src-blob/","excerpt":"html中的video标签，src属性是blob类型","text":"html中的video标签，src属性是blob类型 例子在哔哩哔哩看视频时，审查页面中的播放器，可以看到如下代码:1&lt;video crossorigin=&quot;anonymous&quot; preload=&quot;auto&quot; src=&quot;blob:https://www.bilibili.com/fccf2603-28b1-43a1-a85e-49ed045f300d&quot;&gt;&lt;/video&gt; 直接复制src属性的值，在浏览器中打开是404。其实，blob:开头的地址，是利用URL.createObjectURL将blob类型数据处理成在内存中的地址形式。 分析上边的例子，用几行代码可以实现。12345function playVideo(videoStream)&#123; // as blob var video = document.querySelector(&apos;video&apos;); var videoUrl=window.URL.createObjectURL(videoStream); video.src = videoUrl;&#125; 但是，视频网站中使用MediaSource对象配合video实现视频播放，代码如下:12345678910111213141516171819202122232425262728293031323334353637383940const video = document.querySelector(&apos;video&apos;);const assetURL = &apos;frag_bunny.mp4&apos;;// Need to be specific for Blink regarding codecs// ./mp4info frag_bunny.mp4 | grep Codecconst mimeCodec = &apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;;if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123; const mediaSource = new MediaSource(); //console.log(mediaSource.readyState); // closed video.src = URL.createObjectURL(mediaSource); mediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);&#125; else &#123; console.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);&#125;function sourceOpen (_) &#123; //console.log(this.readyState); // open const mediaSource = this; const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec); fetchAB(assetURL, function (buf) &#123; sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123; mediaSource.endOfStream(); video.play(); //console.log(mediaSource.readyState); // ended &#125;); sourceBuffer.appendBuffer(buf); &#125;);&#125;;function fetchAB (url, cb) &#123; console.log(url); const xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, url); xhr.responseType = &apos;arraybuffer&apos;; xhr.onload = function () &#123; cb(xhr.response); &#125;; xhr.send();&#125;; 上述代码也是一次性请求到数据并播放，可以稍作修改，实现续传方式的播放。 总结这里只是简单的介绍video的src属性值是blob类型的处理方法，在实际应用中可以使用视频播放库来实现。常用库: VideoJS Shaka Player Clappr dash.js hls.js JWPlayer Bitmovin THEOplayer NexPlayer castLabs Flowplayer Radiant Media Player VisualON","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"手写Koa2","slug":"手写Koa2","date":"2023-05-25T05:12:18.000Z","updated":"2024-01-11T07:00:59.270Z","comments":true,"path":"2023/05/25/手写Koa2/","link":"","permalink":"/2023/05/25/手写Koa2/","excerpt":"Koa2源码实现","text":"Koa2源码实现 Koa2使用1234567891011121314151617181920212223242526272829const Koa = require(&apos;koa&apos;);// const Koa = require(&apos;./my-koa&apos;);const app = new Koa();const mid1 = async (ctx, next)=&gt; &#123; console.log(&apos;mid1&apos;); ctx.body = &apos;mid1Before-&apos;; await next(); ctx.body += &apos;mid1After&apos;;&#125;const mid2 = async (ctx, next)=&gt; &#123; console.log(&apos;mid2&apos;); ctx.body += &apos;mid2Before-&apos;; await next(); ctx.body += &apos;mid2After-&apos;;&#125;const mid3 = async (ctx, next)=&gt; &#123; console.log(&apos;mid3&apos;); ctx.body += &apos;mid3Before-&apos;; await next(); ctx.body += &apos;mid3After-&apos;;&#125;app.use(mid1).use(mid2).use(mid3);app.listen(3005, ()=&gt; &#123; console.log(&apos;web server is on at port 3005&apos;);&#125;); 实现自己的Koa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const http = require(&apos;http&apos;);const context = &#123; _body: null, get body() &#123; return this._body; &#125;, set body(val) &#123; this._body = val; &#125;&#125;class MyKoa &#123; constructor() &#123; this.middlewares = []; &#125; use(middleware) &#123; middleware&amp;&amp;this.middlewares.push(middleware); return this; &#125; listen(...args) &#123; const server = http.createServer(async (req, res)=&gt; &#123; const ctx = this.createContext(req, res); const fn = this.compose(this.middlewares); await fn(ctx); res.end(ctx.body); &#125;); server.listen(...args); &#125; createContext(req, res) &#123; const ctx = Object.create(context); ctx.req = req; ctx.res = res; return ctx; &#125; compose(middlewares) &#123; return async (ctx)=&gt; &#123; return dispatch(0); function dispatch(index) &#123; const fn = middlewares[index]; if(!fn) &#123; return Promise.resolve(); &#125; return Promise.resolve(fn(ctx, ()=&gt; &#123; return dispatch(index + 1); &#125;)); &#125; &#125; &#125;&#125;module.exports = MyKoa; 总结Koa2的核心代码不多，但是功能无比强大，主要是它的中间件特别多，利用中间件来完成很多工作。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"Koa2学习笔记","slug":"Koa2学习笔记","date":"2023-05-16T08:14:23.000Z","updated":"2024-01-11T07:00:59.131Z","comments":true,"path":"2023/05/16/Koa2学习笔记/","link":"","permalink":"/2023/05/16/Koa2学习笔记/","excerpt":"mysql学习笔记整理-账号管理","text":"mysql学习笔记整理-账号管理 koa2开始koa2 快速开始环境准备 因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上 node.js环境 版本v7.6以上 直接安装node.js 7.6：node.js官网地址https://nodejs.org nvm管理多版本node.js：可以用nvm 进行node版本进行管理 Mac系统安装nvm https://github.com/creationix/nvm#manual-install windows系统安装nvm https://github.com/coreybutler/nvm-windows Ubuntu系统安装nvm https://github.com/creationix/nvm npm 版本3.x以上 快速开始安装koa212345## 初始化package.jsonnpm init## 安装koa2 npm install koa hello world 代码123456789const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; ctx.body = 'hello koa2'&#125;)app.listen(3000)console.log('[demo] start-quick is starting at port 3000') 启动demo由于koa2是基于async/await操作中间件，目前node.js 7.x的harmony模式下才能使用，所以启动的时的脚本如下： 1node index.js 访问http:localhost:3000，效果如下 async/await使用快速上手理解 先复制以下这段代码，在粘贴在chrome的控制台console中，按回车键执行 123456789101112131415161718192021222324252627function getSyncTime() &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let startTime = new Date().getTime() setTimeout(() =&gt; &#123; let endTime = new Date().getTime() let data = endTime - startTime resolve( data ) &#125;, 500) &#125; catch ( err ) &#123; reject( err ) &#125; &#125;)&#125;async function getSyncData() &#123; let time = await getSyncTime() let data = `endTime - startTime = $&#123;time&#125;` return data&#125;async function getData() &#123; let data = await getSyncData() console.log( data )&#125;getData() 在chrome的console中执行结果如下 从上述例子可以看出 async/await 的特点： 可以让异步逻辑用同步写法实现 最底层的await返回需要是Promise对象 可以通过多层 async function 的同步写法代替传统的callback嵌套koa2简析结构 源码文件123456├── lib│ ├── application.js│ ├── context.js│ ├── request.js│ └── response.js└── package.json 这个就是 GitHub https://github.com/koajs/koa上开源的koa2源码的源文件结构，核心代码就是lib目录下的四个文件 application.js 是整个koa2 的入口文件，封装了context，request，response，以及最核心的中间件处理流程。 context.js 处理应用上下文，里面直接封装部分request.js和response.js的方法 request.js 处理http请求 response.js 处理http响应 koa2特性 只提供封装好http上下文、请求、响应，以及基于async/await的中间件容器。 利用ES7的async/await的来处理传统回调嵌套问题和代替koa@1的generator，但是需要在node.js 7.x的harmony模式下才能支持async/await。 中间件只支持 async/await 封装的，如果要使用koa@1基于generator中间件，需要通过中间件koa-convert封装一下才能使用。koa中间件开发和使用 注：原文地址在我的博客issue里https://github.com/ChenShenhai/blog/issues/15 koa v1和v2中使用到的中间件的开发和使用 generator 中间件开发在koa v1和v2中使用 async await 中间件开发和只能在koa v2中使用 generator中间件开发generator中间件开发 generator中间件返回的应该是function * () 函数 12345678910111213141516/* ./middleware/logger-generator.js */function log( ctx ) &#123; console.log( ctx.method, ctx.header.host + ctx.url )&#125;module.exports = function () &#123; return function * ( next ) &#123; // 执行中间件的操作 log( this ) if ( next ) &#123; yield next &#125; &#125;&#125; generator中间件在koa@1中的使用 generator 中间件在koa v1中可以直接use使用 123456789101112const koa = require('koa') // koa v1const loggerGenerator = require('./middleware/logger-generator')const app = koa()app.use(loggerGenerator())app.use(function *( ) &#123; this.body = 'hello world!'&#125;)app.listen(3000)console.log('the server is starting at port 3000') generator中间件在koa@2中的使用 generator 中间件在koa v2中需要用koa-convert封装一下才能使用 12345678910111213const Koa = require('koa') // koa v2const convert = require('koa-convert')const loggerGenerator = require('./middleware/logger-generator')const app = new Koa()app.use(convert(loggerGenerator()))app.use(( ctx ) =&gt; &#123; ctx.body = 'hello world!'&#125;)app.listen(3000)console.log('the server is starting at port 3000') async中间件开发async 中间件开发123456789101112/* ./middleware/logger-async.js */function log( ctx ) &#123; console.log( ctx.method, ctx.header.host + ctx.url )&#125;module.exports = function () &#123; return async function ( ctx, next ) &#123; log(ctx); await next() &#125;&#125; async 中间件在koa@2中使用 async 中间件只能在 koa v2中使用 123456789101112const Koa = require('koa') // koa v2const loggerAsync = require('./middleware/logger-async')const app = new Koa()app.use(loggerAsync())app.use(( ctx ) =&gt; &#123; ctx.body = 'hello world!'&#125;)app.listen(3000)console.log('the server is starting at port 3000') 路由koa2 原生路由实现简单例子12345678const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; let url = ctx.request.url ctx.body = url&#125;)app.listen(3000) 访问 http://localhost:3000/hello/world 页面会输出 /hello/world，也就是说上下文的请求request对象中url之就是当前访问的路径名称，可以根据ctx.request.url 通过一定的判断或者正则匹配就可以定制出所需要的路由。 定制化的路由demo源码 https://github.com/ChenShenhai/koa2-note/tree/master/demo/route-simple 源码文件目录1234567.├── index.js├── package.json└── view ├── 404.html ├── index.html └── todo.html demo源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Koa = require('koa')const fs = require('fs')const app = new Koa()/** * 用Promise封装异步读取文件方法 * @param &#123;string&#125; page html文件名称 * @return &#123;promise&#125; */function render( page ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; let viewUrl = `./view/$&#123;page&#125;` fs.readFile(viewUrl, \"binary\", ( err, data ) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( data ) &#125; &#125;) &#125;)&#125;/** * 根据URL获取HTML内容 * @param &#123;string&#125; url koa2上下文的url，ctx.url * @return &#123;string&#125; 获取HTML文件内容 */async function route( url ) &#123; let view = '404.html' switch ( url ) &#123; case '/': view = 'index.html' break case '/index': view = 'index.html' break case '/todo': view = 'todo.html' break case '/404': view = '404.html' break default: break &#125; let html = await render( view ) return html&#125;app.use( async ( ctx ) =&gt; &#123; let url = ctx.request.url let html = await route( url ) ctx.body = html&#125;)app.listen(3000)console.log('[demo] route-simple is starting at port 3000') 运行demo执行运行脚本1node -harmony index.js 运行效果如下访问http://localhost:3000/index## koa-router中间件 如果依靠ctx.request.url去手动处理路由，将会写很多处理代码，这时候就需要对应的路由的中间件对路由进行控制，这里介绍一个比较好用的路由中间件koa-router 安装koa-router中间件12## koa2 对应的版本是 7.xnpm install --save koa-router@7 快速使用koa-routerdemo源码 https://github.com/ChenShenhai/koa2-note/tree/master/demo/route-use-middleware 1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa')const fs = require('fs')const app = new Koa()const Router = require('koa-router')let home = new Router()// 子路由1home.get('/', async ( ctx )=&gt;&#123; let html = ` &lt;ul&gt; &lt;li&gt;&lt;a href=\"/page/helloworld\"&gt;/page/helloworld&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/page/404\"&gt;/page/404&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; ` ctx.body = html&#125;)// 子路由2let page = new Router()page.get('/404', async ( ctx )=&gt;&#123; ctx.body = '404 page!'&#125;).get('/helloworld', async ( ctx )=&gt;&#123; ctx.body = 'helloworld page!'&#125;)// 装载所有子路由let router = new Router()router.use('/', home.routes(), home.allowedMethods())router.use('/page', page.routes(), page.allowedMethods())// 加载路由中间件app.use(router.routes()).use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('[demo] route-use-middleware is starting at port 3000')&#125;) 请求数据获取GET请求数据获取使用方法在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法，query返回是格式化好的参数对象，querystring返回的是请求字符串，由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。 1.是从上下文中直接获取 请求对象ctx.query，返回如 { a:1, b:2 } 请求字符串 ctx.querystring，返回如 a=1&amp;b=2 2.是从上下文的request对象中获取 请求对象ctx.request.query，返回如 { a:1, b:2 } 请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2 举个例子demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/request/get.js 例子代码1234567891011121314151617181920212223242526const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; let url = ctx.url // 从上下文的request对象中获取 let request = ctx.request let req_query = request.query let req_querystring = request.querystring // 从上下文中直接获取 let ctx_query = ctx.query let ctx_querystring = ctx.querystring ctx.body = &#123; url, req_query, req_querystring, ctx_query, ctx_querystring &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] request get is starting at port 3000')&#125;) 执行程序1node get.js 执行后程序后，用chrome访问 http://localhost:3000/page/user?a=1&amp;b=2 会出现以下情况 注意：我是用了chrome的json格式化插件才会显示json的格式化 POST请求参数获取原理对于POST请求的处理，koa2没有封装获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req，将POST表单数据解析成query string（例如：a=1&amp;b=2&amp;c=3），再将query string 解析成JSON格式（例如：{&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:&quot;2&quot;, &quot;c&quot;:&quot;3&quot;}） 注意：ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象，同理ctx.response是context经过封装的响应对象，ctx.res是context提供的node.js原生HTTP响应对象。 具体koa2 API文档可见 https://github.com/koajs/koa/blob/master/docs/api/context.md#ctxreq 解析出POST请求上下文中的表单数据demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/request/post.js 1234567891011121314151617181920212223242526272829// 解析上下文里node原生请求的POST参数function parsePostData( ctx ) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let postdata = \"\"; ctx.req.addListener('data', (data) =&gt; &#123; postdata += data &#125;) ctx.req.addListener(\"end\",function()&#123; let parseData = parseQueryStr( postdata ) resolve( parseData ) &#125;) &#125; catch ( err ) &#123; reject(err) &#125; &#125;)&#125;// 将POST请求参数字符串解析成JSONfunction parseQueryStr( queryStr ) &#123; let queryData = &#123;&#125; let queryStrList = queryStr.split('&amp;') console.log( queryStrList ) for ( let [ index, queryStr ] of queryStrList.entries() ) &#123; let itemList = queryStr.split('=') queryData[ itemList[0] ] = decodeURIComponent(itemList[1]) &#125; return queryData&#125; 举个例子源码在 /demos/request/post.js中 例子代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method=\"POST\" action=\"/\"&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=\"userName\" /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name=\"nickName\" /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name=\"email\" /&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if ( ctx.url === '/' &amp;&amp; ctx.method === 'POST' ) &#123; // 当POST请求的时候，解析POST表单里的数据，并显示出来 let postData = await parsePostData( ctx ) ctx.body = postData &#125; else &#123; // 其他请求显示404 ctx.body = '&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;' &#125;&#125;)// 解析上下文里node原生请求的POST参数function parsePostData( ctx ) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let postdata = \"\"; ctx.req.addListener('data', (data) =&gt; &#123; postdata += data &#125;) ctx.req.addListener(\"end\",function()&#123; let parseData = parseQueryStr( postdata ) resolve( parseData ) &#125;) &#125; catch ( err ) &#123; reject(err) &#125; &#125;)&#125;// 将POST请求参数字符串解析成JSONfunction parseQueryStr( queryStr ) &#123; let queryData = &#123;&#125; let queryStrList = queryStr.split('&amp;') console.log( queryStrList ) for ( let [ index, queryStr ] of queryStrList.entries() ) &#123; let itemList = queryStr.split('=') queryData[ itemList[0] ] = decodeURIComponent(itemList[1]) &#125; return queryData&#125;app.listen(3000, () =&gt; &#123; console.log('[demo] request post is starting at port 3000')&#125;) 启动例子1node post.js 访问页面 提交表单发起POST请求结果显示 koa-bodyparser中间件原理对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中 安装koa2版本的koa-bodyparser@3中间件1npm install --save koa-bodyparser@3 举个例子例子代码demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/request/post-middleware.js 12345678910111213141516171819202122232425262728293031323334353637const Koa = require('koa')const app = new Koa()const bodyParser = require('koa-bodyparser')// 使用ctx.body解析中间件app.use(bodyParser())app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method=\"POST\" action=\"/\"&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=\"userName\" /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name=\"nickName\" /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name=\"email\" /&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if ( ctx.url === '/' &amp;&amp; ctx.method === 'POST' ) &#123; // 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来 let postData = ctx.request.body ctx.body = postData &#125; else &#123; // 其他请求显示404 ctx.body = '&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;' &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] request post is starting at port 3000')&#125;) 启动例子1node post-middleware.js 访问页面 提交表单发起POST请求结果显示 静态资源加载原生koa2实现静态资源服务器前言一个http请求访问web服务静态资源，一般响应结果有三种情况 访问文本，例如js，css，png，jpg，gif 访问静态目录 找不到资源，抛出404错误 原生koa2 静态资源服务器例子demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/static-server/ 代码目录123456789101112├── static ## 静态资源目录│ ├── css/│ ├── image/│ ├── js/│ └── index.html├── util ## 工具代码│ ├── content.js ## 读取请求内容│ ├── dir.js ## 读取目录内容│ ├── file.js ## 读取文件内容│ ├── mimes.js ## 文件类型列表│ └── walk.js ## 遍历目录内容└── index.js ## 启动入口文件 代码解析index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Koa = require('koa')const path = require('path')const content = require('./util/content')const mimes = require('./util/mimes')const app = new Koa()// 静态资源目录对于相对入口文件index.js的路径const staticPath = './static'// 解析资源类型function parseMime( url ) &#123; let extName = path.extname( url ) extName = extName ? extName.slice(1) : 'unknown' return mimes[ extName ]&#125;app.use( async ( ctx ) =&gt; &#123; // 静态资源目录在本地的绝对路径 let fullStaticPath = path.join(__dirname, staticPath) // 获取静态资源内容，有可能是文件内容，目录，或404 let _content = await content( ctx, fullStaticPath ) // 解析请求内容的类型 let _mime = parseMime( ctx.url ) // 如果有对应的文件类型，就配置上下文的类型 if ( _mime ) &#123; ctx.type = _mime &#125; // 输出静态资源内容 if ( _mime &amp;&amp; _mime.indexOf('image/') &gt;= 0 ) &#123; // 如果是图片，则用node原生res，输出二进制数据 ctx.res.writeHead(200) ctx.res.write(_content, 'binary') ctx.res.end() &#125; else &#123; // 其他则输出文本 ctx.body = _content &#125;&#125;)app.listen(3000)console.log('[demo] static-server is starting at port 3000') util/content.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const path = require('path')const fs = require('fs')// 封装读取目录内容方法const dir = require('./dir')// 封装读取文件内容方法const file = require('./file')/** * 获取静态资源内容 * @param &#123;object&#125; ctx koa上下文 * @param &#123;string&#125; 静态资源目录在本地的绝对路径 * @return &#123;string&#125; 请求获取到的本地内容 */async function content( ctx, fullStaticPath ) &#123; // 封装请求资源的完绝对径 let reqPath = path.join(fullStaticPath, ctx.url) // 判断请求路径是否为存在目录或者文件 let exist = fs.existsSync( reqPath ) // 返回请求内容， 默认为空 let content = '' if( !exist ) &#123; //如果请求路径不存在，返回404 content = '404 Not Found! o(╯□╰)o！' &#125; else &#123; //判断访问地址是文件夹还是文件 let stat = fs.statSync( reqPath ) if( stat.isDirectory() ) &#123; //如果为目录，则渲读取目录内容 content = dir( ctx.url, reqPath ) &#125; else &#123; // 如果请求为文件，则读取文件内容 content = await file( reqPath ) &#125; &#125; return content&#125;module.exports = content util/dir.js12345678910111213141516171819202122232425262728const url = require('url')const fs = require('fs')const path = require('path')// 遍历读取目录内容方法const walk = require('./walk')/** * 封装目录内容 * @param &#123;string&#125; url 当前请求的上下文中的url，即ctx.url * @param &#123;string&#125; reqPath 请求静态资源的完整本地路径 * @return &#123;string&#125; 返回目录内容，封装成HTML */function dir ( url, reqPath ) &#123; // 遍历读取当前目录下的文件、子目录 let contentList = walk( reqPath ) let html = `&lt;ul&gt;` for ( let [ index, item ] of contentList.entries() ) &#123; html = `$&#123;html&#125;&lt;li&gt;&lt;a href=\"$&#123;url === '/' ? '' : url&#125;/$&#123;item&#125;\"&gt;$&#123;item&#125;&lt;/a&gt;` &#125; html = `$&#123;html&#125;&lt;/ul&gt;` return html&#125;module.exports = dir util/file.js1234567891011121314const fs = require('fs')/** * 读取文件方法 * @param &#123;string&#125; 文件本地的绝对路径 * @return &#123;string|binary&#125; */function file ( filePath ) &#123; let content = fs.readFileSync(filePath, 'binary' ) return content&#125;module.exports = file util/walk.js1234567891011121314151617181920212223242526272829303132const fs = require('fs')const mimes = require('./mimes')/** * 遍历读取目录内容（子目录，文件名） * @param &#123;string&#125; reqPath 请求资源的绝对路径 * @return &#123;array&#125; 目录内容列表 */function walk( reqPath )&#123; let files = fs.readdirSync( reqPath ); let dirList = [], fileList = []; for( let i=0, len=files.length; i&lt;len; i++ ) &#123; let item = files[i]; let itemArr = item.split(\"\\.\"); let itemMime = ( itemArr.length &gt; 1 ) ? itemArr[ itemArr.length - 1 ] : \"undefined\"; if( typeof mimes[ itemMime ] === \"undefined\" ) &#123; dirList.push( files[i] ); &#125; else &#123; fileList.push( files[i] ); &#125; &#125; let result = dirList.concat( fileList ); return result;&#125;;module.exports = walk; util/mime.js1234567891011121314151617181920212223let mimes = &#123; 'css': 'text/css', 'less': 'text/css', 'gif': 'image/gif', 'html': 'text/html', 'ico': 'image/x-icon', 'jpeg': 'image/jpeg', 'jpg': 'image/jpeg', 'js': 'text/javascript', 'json': 'application/json', 'pdf': 'application/pdf', 'png': 'image/png', 'svg': 'image/svg+xml', 'swf': 'application/x-shockwave-flash', 'tiff': 'image/tiff', 'txt': 'text/plain', 'wav': 'audio/x-wav', 'wma': 'audio/x-ms-wma', 'wmv': 'video/x-ms-wmv', 'xml': 'text/xml'&#125;module.exports = mimes 运行效果启动服务1node index.js 效果访问http://localhost:3000 访问http://localhost:3000/index.html 访问http://localhost:3000/js/index.js koa-static中间件使用使用例子demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/static-use-middleware/ 123456789101112131415161718192021const Koa = require('koa')const path = require('path')const static = require('koa-static')const app = new Koa()// 静态资源目录对于相对入口文件index.js的路径const staticPath = './static'app.use(static( path.join( __dirname, staticPath)))app.use( async ( ctx ) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] static-use-middleware is starting at port 3000')&#125;) 效果访问http://localhost:3000 访问http://localhost:3000/index.html 访问http://localhost:3000/js/index.js cookie/sessionkoa2使用cookie使用方法koa提供了从上下文直接读取、写入cookie的方法 ctx.cookies.get(name, [options]) 读取上下文请求中的cookie ctx.cookies.set(name, value, [options]) 在上下文中写入cookie koa2 中操作的cookies是使用了npm的cookies模块，源码在https://github.com/pillarjs/cookies，所以在读写cookie的使用参数与该模块的使用一致。 例子代码12345678910111213141516171819202122232425262728const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === '/index' ) &#123; ctx.cookies.set( 'cid', 'hello world', &#123; domain: 'localhost', // 写cookie所在的域名 path: '/index', // 写cookie所在的路径 maxAge: 10 * 60 * 1000, // cookie有效时长 expires: new Date('2017-02-15'), // cookie失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 &#125; ) ctx.body = 'cookie is ok' &#125; else &#123; ctx.body = 'hello world' &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] cookie is starting at port 3000')&#125;) 运行例子执行脚本1node index.js 运行结果访问http://localhost:3000/index 可以在控制台的cookie列表中中看到写在页面上的cookie 在控制台的console中使用document.cookie可以打印出在页面的所有cookie（需要是httpOnly设置false才能显示） koa2实现session前言koa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。在koa2中实现session的方案有一下几种 如果session数据量很小，可以直接存在内存中 如果session数据量很大，则需要存储介质存放session数据 数据库存储方案 将session存放在MySQL数据库中 需要用到中间件 koa-session-minimal 适用于koa2 的session中间件，提供存储介质的读写接口 。 koa-mysql-session 为koa-session-minimal中间件提供MySQL数据库的session数据读写操作。 将sessionId和对应的数据存到数据库 将数据库的存储的sessionId存到页面的cookie中 根据cookie的sessionId去获取对于的session信息 快速使用demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/session/index.js 例子代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const Koa = require('koa')const session = require('koa-session-minimal')const MysqlSession = require('koa-mysql-session')const app = new Koa()// 配置存储session信息的mysqllet store = new MysqlSession(&#123; user: 'root', password: 'abc123', database: 'koa_demo', host: '127.0.0.1',&#125;)// 存放sessionId的cookie配置let cookie = &#123; maxAge: '', // cookie有效时长 expires: '', // cookie失效时间 path: '', // 写cookie所在的路径 domain: '', // 写cookie所在的域名 httpOnly: '', // 是否只用于http请求中获取 overwrite: '', // 是否允许重写 secure: '', sameSite: '', signed: '', &#125;// 使用session中间件app.use(session(&#123; key: 'SESSION_ID', store: store, cookie: cookie&#125;))app.use( async ( ctx ) =&gt; &#123; // 设置session if ( ctx.url === '/set' ) &#123; ctx.session = &#123; user_id: Math.random().toString(36).substr(2), count: 0 &#125; ctx.body = ctx.session &#125; else if ( ctx.url === '/' ) &#123; // 读取session信息 ctx.session.count = ctx.session.count + 1 ctx.body = ctx.session &#125; &#125;)app.listen(3000)console.log('[demo] session is starting at port 3000') 运行例子执行命令1node index.js 访问连接设置sessionhttp://localhost:3000/set 查看数据库session是否存储 查看cookie中是否种下了sessionIdhttp://localhost:3000 模板引擎koa2加载模板引擎快速开始安装模块12345## 安装koa模板使用中间件npm install --save koa-views## 安装ejs模板引擎npm install --save ejs 使用模板引擎demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/ejs/ 文件目录1234├── package.json├── index.js└── view └── index.ejs ./index.js文件123456789101112131415161718const Koa = require('koa')const views = require('koa-views')const path = require('path')const app = new Koa()// 加载模板引擎app.use(views(path.join(__dirname, './view'), &#123; extension: 'ejs'&#125;))app.use( async ( ctx ) =&gt; &#123; let title = 'hello koa2' await ctx.render('index', &#123; title, &#125;)&#125;)app.listen(3000) ./view/index.ejs 模板12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ejs模板引擎具体查看ejs官方文档https://github.com/mde/ejs 文件上传busboy模块快速开始安装1npm install --save busboy 模块简介busboy 模块是用来解析POST请求，node原生req中的文件流。 开始使用1234567891011121314151617181920212223242526272829303132333435363738394041const inspect = require('util').inspect const path = require('path')const fs = require('fs')const Busboy = require('busboy')// req 为node原生请求const busboy = new Busboy(&#123; headers: req.headers &#125;)// ...// 监听文件解析事件busboy.on('file', function(fieldname, file, filename, encoding, mimetype) &#123; console.log(`File [$&#123;fieldname&#125;]: filename: $&#123;filename&#125;`) // 文件保存到特定路径 file.pipe(fs.createWriteStream('./upload')) // 开始解析文件流 file.on('data', function(data) &#123; console.log(`File [$&#123;fieldname&#125;] got $&#123;data.length&#125; bytes`) &#125;) // 解析文件结束 file.on('end', function() &#123; console.log(`File [$&#123;fieldname&#125;] Finished`) &#125;)&#125;)// 监听请求中的字段busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated) &#123; console.log(`Field [$&#123;fieldname&#125;]: value: $&#123;inspect(val)&#125;`)&#125;)// 监听结束事件busboy.on('finish', function() &#123; console.log('Done parsing form!') res.writeHead(303, &#123; Connection: 'close', Location: '/' &#125;) res.end()&#125;)req.pipe(busboy) 更多模块信息更多详细API可以访问npm官方文档 https://www.npmjs.com/package/busboy 上传文件简单实现依赖模块安装依赖1npm install --save busboy busboy 是用来解析出请求中文件流 例子源码demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/upload/ 封装上传文件到写入服务的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const inspect = require('util').inspectconst path = require('path')const os = require('os')const fs = require('fs')const Busboy = require('busboy')/** * 同步创建文件目录 * @param &#123;string&#125; dirname 目录绝对地址 * @return &#123;boolean&#125; 创建目录结果 */function mkdirsSync( dirname ) &#123; if (fs.existsSync( dirname )) &#123; return true &#125; else &#123; if (mkdirsSync( path.dirname(dirname)) ) &#123; fs.mkdirSync( dirname ) return true &#125; &#125;&#125;/** * 获取上传文件的后缀名 * @param &#123;string&#125; fileName 获取上传文件的后缀名 * @return &#123;string&#125; 文件后缀名 */function getSuffixName( fileName ) &#123; let nameList = fileName.split('.') return nameList[nameList.length - 1]&#125;/** * 上传文件 * @param &#123;object&#125; ctx koa上下文 * @param &#123;object&#125; options 文件上传参数 fileType文件类型， path文件存放路径 * @return &#123;promise&#125; */function uploadFile( ctx, options) &#123; let req = ctx.req let res = ctx.res let busboy = new Busboy(&#123;headers: req.headers&#125;) // 获取类型 let fileType = options.fileType || 'common' let filePath = path.join( options.path, fileType) let mkdirResult = mkdirsSync( filePath ) return new Promise((resolve, reject) =&gt; &#123; console.log('文件上传中...') let result = &#123; success: false, formData: &#123;&#125;, &#125; // 解析请求文件事件 busboy.on('file', function(fieldname, file, filename, encoding, mimetype) &#123; let fileName = Math.random().toString(16).substr(2) + '.' + getSuffixName(filename) let _uploadFilePath = path.join( filePath, fileName ) let saveTo = path.join(_uploadFilePath) // 文件保存到制定路径 file.pipe(fs.createWriteStream(saveTo)) // 文件写入事件结束 file.on('end', function() &#123; result.success = true result.message = '文件上传成功' console.log('文件上传成功！') resolve(result) &#125;) &#125;) // 解析表单中其他字段信息 busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) &#123; console.log('表单字段数据 [' + fieldname + ']: value: ' + inspect(val)); result.formData[fieldname] = inspect(val); &#125;); // 解析结束事件 busboy.on('finish', function( ) &#123; console.log('文件上结束') resolve(result) &#125;) // 解析错误事件 busboy.on('error', function(err) &#123; console.log('文件上出错') reject(result) &#125;) req.pipe(busboy) &#125;) &#125; module.exports = &#123; uploadFile&#125; 入口文件123456789101112131415161718192021222324252627282930313233343536373839404142434445const Koa = require('koa')const path = require('path')const app = new Koa()// const bodyParser = require('koa-bodyparser')const &#123; uploadFile &#125; = require('./util/upload')// app.use(bodyParser())app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 upload demo&lt;/h1&gt; &lt;form method=\"POST\" action=\"/upload.json\" enctype=\"multipart/form-data\"&gt; &lt;p&gt;file upload&lt;/p&gt; &lt;span&gt;picName:&lt;/span&gt;&lt;input name=\"picName\" type=\"text\" /&gt;&lt;br/&gt; &lt;input name=\"file\" type=\"file\" /&gt;&lt;br/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if ( ctx.url === '/upload.json' &amp;&amp; ctx.method === 'POST' ) &#123; // 上传文件请求处理 let result = &#123; success: false &#125; let serverFilePath = path.join( __dirname, 'upload-files' ) // 上传文件事件 result = await uploadFile( ctx, &#123; fileType: 'album', // common or album path: serverFilePath &#125;) ctx.body = result &#125; else &#123; // 其他请求显示404 ctx.body = '&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;' &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] upload-simple is starting at port 3000')&#125;) 运行结果 异步上传图片实现快速上手demo 地址 https://github.com/ChenShenhai/koa2-note/tree/master/demo/upload-async 源码理解demo源码目录123456789101112.├── index.js ## 后端启动文件├── node_modules├── package.json├── static ## 静态资源目录│ ├── image ## 异步上传图片存储目录│ └── js│ └── index.js ## 上传图片前端js操作├── util│ └── upload.js ## 后端处理图片流操作└── view └── index.ejs ## ejs后端渲染模板 后端代码入口文件 demo/upload-async/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const Koa = require('koa')const views = require('koa-views')const path = require('path')const convert = require('koa-convert')const static = require('koa-static')const &#123; uploadFile &#125; = require('./util/upload')const app = new Koa()/** * 使用第三方中间件 start */app.use(views(path.join(__dirname, './view'), &#123; extension: 'ejs'&#125;))// 静态资源目录对于相对入口文件index.js的路径const staticPath = './static'// 由于koa-static目前不支持koa2// 所以只能用koa-convert封装一下app.use(convert(static( path.join( __dirname, staticPath))))/** * 使用第三方中间件 end */app.use( async ( ctx ) =&gt; &#123; if ( ctx.method === 'GET' ) &#123; let title = 'upload pic async' await ctx.render('index', &#123; title, &#125;) &#125; else if ( ctx.url === '/api/picture/upload.json' &amp;&amp; ctx.method === 'POST' ) &#123; // 上传文件请求处理 let result = &#123; success: false &#125; let serverFilePath = path.join( __dirname, 'static/image' ) // 上传文件事件 result = await uploadFile( ctx, &#123; fileType: 'album', path: serverFilePath &#125;) ctx.body = result &#125; else &#123; // 其他请求显示404 ctx.body = '&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;' &#125; &#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] upload-pic-async is starting at port 3000')&#125;) 后端上传图片流写操作入口文件 demo/upload-async/util/upload.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const inspect = require('util').inspectconst path = require('path')const os = require('os')const fs = require('fs')const Busboy = require('busboy')/** * 同步创建文件目录 * @param &#123;string&#125; dirname 目录绝对地址 * @return &#123;boolean&#125; 创建目录结果 */function mkdirsSync( dirname ) &#123; if (fs.existsSync( dirname )) &#123; return true &#125; else &#123; if (mkdirsSync( path.dirname(dirname)) ) &#123; fs.mkdirSync( dirname ) return true &#125; &#125;&#125;/** * 获取上传文件的后缀名 * @param &#123;string&#125; fileName 获取上传文件的后缀名 * @return &#123;string&#125; 文件后缀名 */function getSuffixName( fileName ) &#123; let nameList = fileName.split('.') return nameList[nameList.length - 1]&#125;/** * 上传文件 * @param &#123;object&#125; ctx koa上下文 * @param &#123;object&#125; options 文件上传参数 fileType文件类型， path文件存放路径 * @return &#123;promise&#125; */function uploadFile( ctx, options) &#123; let req = ctx.req let res = ctx.res let busboy = new Busboy(&#123;headers: req.headers&#125;) // 获取类型 let fileType = options.fileType || 'common' let filePath = path.join( options.path, fileType) let mkdirResult = mkdirsSync( filePath ) return new Promise((resolve, reject) =&gt; &#123; console.log('文件上传中...') let result = &#123; success: false, message: '', data: null &#125; // 解析请求文件事件 busboy.on('file', function(fieldname, file, filename, encoding, mimetype) &#123; let fileName = Math.random().toString(16).substr(2) + '.' + getSuffixName(filename) let _uploadFilePath = path.join( filePath, fileName ) let saveTo = path.join(_uploadFilePath) // 文件保存到制定路径 file.pipe(fs.createWriteStream(saveTo)) // 文件写入事件结束 file.on('end', function() &#123; result.success = true result.message = '文件上传成功' result.data = &#123; pictureUrl: `//$&#123;ctx.host&#125;/image/$&#123;fileType&#125;/$&#123;fileName&#125;` &#125; console.log('文件上传成功！') resolve(result) &#125;) &#125;) // 解析结束事件 busboy.on('finish', function( ) &#123; console.log('文件上结束') resolve(result) &#125;) // 解析错误事件 busboy.on('error', function(err) &#123; console.log('文件上出错') reject(result) &#125;) req.pipe(busboy) &#125;) &#125; module.exports = &#123; uploadFile&#125; 前端代码1234567&lt;button class=\"btn\" id=\"J_UploadPictureBtn\"&gt;上传图片&lt;/button&gt;&lt;hr/&gt;&lt;p&gt;上传进度&lt;span id=\"J_UploadProgress\"&gt;0&lt;/span&gt;%&lt;/p&gt;&lt;p&gt;上传结果图片&lt;/p&gt;&lt;div id=\"J_PicturePreview\" class=\"preview-picture\"&gt;&lt;/div&gt;&lt;script src=\"/js/index.js\"&gt;&lt;/script&gt; 上传操作代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113(function()&#123;let btn = document.getElementById('J_UploadPictureBtn')let progressElem = document.getElementById('J_UploadProgress')let previewElem = document.getElementById('J_PicturePreview')btn.addEventListener('click', function()&#123; uploadAction(&#123; success: function( result ) &#123; console.log( result ) if ( result &amp;&amp; result.success &amp;&amp; result.data &amp;&amp; result.data.pictureUrl ) &#123; previewElem.innerHTML = '&lt;img src=\"'+ result.data.pictureUrl +'\" style=\"max-width: 100%\"&gt;' &#125; &#125;, progress: function( data ) &#123; if ( data &amp;&amp; data * 1 &gt; 0 ) &#123; progressElem.innerText = data &#125; &#125; &#125;)&#125;)/** * 类型判断 * @type &#123;Object&#125; */let UtilType = &#123; isPrototype: function( data ) &#123; return Object.prototype.toString.call(data).toLowerCase(); &#125;, isJSON: function( data ) &#123; return this.isPrototype( data ) === '[object object]'; &#125;, isFunction: function( data ) &#123; return this.isPrototype( data ) === '[object function]'; &#125;&#125;/** * form表单上传请求事件 * @param &#123;object&#125; options 请求参数 */function requestEvent( options ) &#123; try &#123; let formData = options.formData let xhr = new XMLHttpRequest() xhr.onreadystatechange = function() &#123; if ( xhr.readyState === 4 &amp;&amp; xhr.status === 200 ) &#123; options.success(JSON.parse(xhr.responseText)) &#125; &#125; xhr.upload.onprogress = function(evt) &#123; let loaded = evt.loaded let tot = evt.total let per = Math.floor(100 * loaded / tot) options.progress(per) &#125; xhr.open('post', '/api/picture/upload.json') xhr.send(formData) &#125; catch ( err ) &#123; options.fail(err) &#125;&#125;/** * 上传事件 * @param &#123;object&#125; options 上传参数 */function uploadEvent ( options )&#123; let file let formData = new FormData() let input = document.createElement('input') input.setAttribute('type', 'file') input.setAttribute('name', 'files') input.click() input.onchange = function () &#123; file = input.files[0] formData.append('files', file) requestEvent(&#123; formData, success: options.success, fail: options.fail, progress: options.progress &#125;) &#125;&#125;/** * 上传操作 * @param &#123;object&#125; options 上传参数 */function uploadAction( options ) &#123; if ( !UtilType.isJSON( options ) ) &#123; console.log( 'upload options is null' ) return &#125; let _options = &#123;&#125; _options.success = UtilType.isFunction(options.success) ? options.success : function() &#123;&#125; _options.fail = UtilType.isFunction(options.fail) ? options.fail : function() &#123;&#125; _options.progress = UtilType.isFunction(options.progress) ? options.progress : function() &#123;&#125; uploadEvent(_options)&#125;&#125;)() 运行效果 数据库mysqlmysql模块快速开始安装MySQL数据库https://www.mysql.com/downloads/ 安装 node.js的mysql模块1npm install --save mysql 模块介绍mysql模块是node操作MySQL的引擎，可以在node.js环境下对MySQL数据库进行建表，增、删、改、查等操作。 开始使用创建数据库会话12345678910111213141516const mysql = require('mysql')const connection = mysql.createConnection(&#123; host : '127.0.0.1', // 数据库地址 user : 'root', // 数据库用户 password : '123456' // 数据库密码 database : 'my_database' // 选中数据库&#125;) // 执行sql脚本对数据库进行读写 connection.query('SELECT * FROM my_table', (error, results, fields) =&gt; &#123; if (error) throw error // connected! // 结束会话 connection.release() &#125;); 注意：一个事件就有一个从开始到结束的过程，数据库会话操作执行完后，就需要关闭掉，以免占用连接资源。 创建数据连接池一般情况下操作数据库是很复杂的读写过程，不只是一个会话，如果直接用会话操作，就需要每次会话都要配置连接参数。所以这时候就需要连接池管理会话。 12345678910111213141516171819202122const mysql = require('mysql')// 创建数据池const pool = mysql.createPool(&#123; host : '127.0.0.1', // 数据库地址 user : 'root', // 数据库用户 password : '123456' // 数据库密码 database : 'my_database' // 选中数据库&#125;) // 在数据池中进行会话操作pool.getConnection(function(err, connection) &#123; connection.query('SELECT * FROM my_table', (error, results, fields) =&gt; &#123; // 结束会话 connection.release(); // 如果有错误就抛出 if (error) throw error; &#125;)&#125;) 更多模块信息更多详细API可以访问npm官方文档 https://www.npmjs.com/package/mysql async/await封装使用mysql前言由于mysql模块的操作都是异步操作，每次操作的结果都是在回调函数中执行，现在有了async/await，就可以用同步的写法去操作数据库 Promise封装mysql模块Promise封装 ./async-db1234567891011121314151617181920212223242526272829const mysql = require('mysql')const pool = mysql.createPool(&#123; host : '127.0.0.1', user : 'root', password : '123456', database : 'my_database'&#125;)let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; reject( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;module.exports = &#123; query &#125; async/await使用12345678910111213const &#123; query &#125; = require('./async-db')async function selectAllData( ) &#123; let sql = 'SELECT * FROM my_table' let dataList = await query( sql ) return dataList&#125;async function getData() &#123; let dataList = await selectAllData() console.log( dataList )&#125;getData() 建表初始化前言通常初始化数据库要建立很多表，特别在项目开发的时候表的格式可能会有些变动，这时候就需要封装对数据库建表初始化的方法，保留项目的sql脚本文件，然后每次需要重新建表，则执行建表初始化程序就行 快速开始demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/mysql/ 源码目录1234567891011├── index.js ## 程序入口文件├── node_modules/├── package.json├── sql ## sql脚本文件目录│ ├── data.sql│ └── user.sql└── util ## 工具代码 ├── db.js ## 封装的mysql模块方法 ├── get-sql-content-map.js ## 获取sql脚本文件内容 ├── get-sql-map.js ## 获取所有sql脚本文件 └── walk-file.js ## 遍历sql脚本文件 具体流程1234567891011121314151617 +---------------------------------------------------+ | | | +-----------+ +-----------+ +-----------+ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |+----------+ 遍历sql +---+ 解析所有sql +---+ 执行sql +------------&gt; | | 目录下的 | | 文件脚本 | | 脚本 | |+----------+ sql文件 +---+ 内容 +---+ +------------&gt; | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | +-----------+ +-----------+ +-----------+ | | | +---------------------------------------------------+ 源码详解数据库操作文件 ./util/db.js12345678910111213141516171819202122232425262728293031323334const mysql = require('mysql')const pool = mysql.createPool(&#123; host : '127.0.0.1', user : 'root', password : 'abc123', database : 'koa_demo'&#125;)let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; reject( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;module.exports = &#123; query&#125; 获取所有sql脚本内容 ./util/get-sql-content-map.js123456789101112131415161718192021222324252627282930const fs = require('fs')const getSqlMap = require('./get-sql-map')let sqlContentMap = &#123;&#125;/** * 读取sql文件内容 * @param &#123;string&#125; fileName 文件名称 * @param &#123;string&#125; path 文件所在的路径 * @return &#123;string&#125; 脚本文件内容 */function getSqlContent( fileName, path ) &#123; let content = fs.readFileSync( path, 'binary' ) sqlContentMap[ fileName ] = content&#125;/** * 封装所有sql文件脚本内容 * @return &#123;object&#125; */function getSqlContentMap () &#123; let sqlMap = getSqlMap() for( let key in sqlMap ) &#123; getSqlContent( key, sqlMap[key] ) &#125; return sqlContentMap&#125;module.exports = getSqlContentMap 获取sql目录详情 ./util/get-sql-map.js1234567891011121314151617181920const fs = require('fs')const walkFile = require('./walk-file')/** * 获取sql目录下的文件目录数据 * @return &#123;object&#125; */function getSqlMap () &#123; let basePath = __dirname basePath = basePath.replace(/\\\\/g, '\\/') let pathArr = basePath.split('\\/') pathArr = pathArr.splice( 0, pathArr.length - 1 ) basePath = pathArr.join('/') + '/sql/' let fileList = walkFile( basePath, 'sql' ) return fileList&#125;module.exports = getSqlMap 遍历目录操作 ./util/walk-file.js12345678910111213141516171819202122232425262728const fs = require('fs')/** * 遍历目录下的文件目录 * @param &#123;string&#125; pathResolve 需进行遍历的目录路径 * @param &#123;string&#125; mime 遍历文件的后缀名 * @return &#123;object&#125; 返回遍历后的目录结果 */const walkFile = function( pathResolve , mime )&#123; let files = fs.readdirSync( pathResolve ) let fileList = &#123;&#125; for( let [ i, item] of files.entries() ) &#123; let itemArr = item.split('\\.') let itemMime = ( itemArr.length &gt; 1 ) ? itemArr[ itemArr.length - 1 ] : 'undefined' let keyName = item + '' if( mime === itemMime ) &#123; fileList[ item ] = pathResolve + item &#125; &#125; return fileList&#125;module.exports = walkFile 入口文件 ./index.js1234567891011121314151617181920212223242526272829303132333435363738394041const fs = require('fs');const getSqlContentMap = require('./util/get-sql-content-map');const &#123; query &#125; = require('./util/db');// 打印脚本执行日志const eventLog = function( err , sqlFile, index ) &#123; if( err ) &#123; console.log(`[ERROR] sql脚本文件: $&#123;sqlFile&#125; 第$&#123;index + 1&#125;条脚本 执行失败 o(╯□╰)o ！`) &#125; else &#123; console.log(`[SUCCESS] sql脚本文件: $&#123;sqlFile&#125; 第$&#123;index + 1&#125;条脚本 执行成功 O(∩_∩)O !`) &#125;&#125;// 获取所有sql脚本内容let sqlContentMap = getSqlContentMap()// 执行建表sql脚本const createAllTables = async () =&gt; &#123; for( let key in sqlContentMap ) &#123; let sqlShell = sqlContentMap[key] let sqlShellList = sqlShell.split(';') for ( let [ i, shell ] of sqlShellList.entries() ) &#123; if ( shell.trim() ) &#123; let result = await query( shell ) if ( result.serverStatus * 1 === 2 ) &#123; eventLog( null, key, i) &#125; else &#123; eventLog( true, key, i) &#125; &#125; &#125; &#125; console.log('sql脚本执行结束！') console.log('请按 ctrl + c 键退出！')&#125;createAllTables() sql脚本文件 ./sql/data.sql12345678CREATE TABLE IF NOT EXISTS `data` ( `id` int(11) NOT NULL AUTO_INCREMENT, `data_info` json DEFAULT NULL, `create_time` varchar(20) DEFAULT NULL, `modified_time` varchar(20) DEFAULT NULL, `level` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 sql脚本文件 ./sql/user.sql12345678910111213141516CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(255) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `nick` varchar(255) DEFAULT NULL, `detail_info` json DEFAULT NULL, `create_time` varchar(20) DEFAULT NULL, `modified_time` varchar(20) DEFAULT NULL, `level` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `user` set email='1@example.com', password='123456';INSERT INTO `user` set email='2@example.com', password='123456';INSERT INTO `user` set email='3@example.com', password='123456'; 效果执行脚本1node index.js 执行结果 查看数据库写入数据 JSONP实现原生koa2实现jsonp前言在项目复杂的业务场景，有时候需要在前端跨域获取数据，这时候提供数据的服务就需要提供跨域请求的接口，通常是使用JSONP的方式提供跨域接口。 实现JSONPdemo地址 https://github.com/ChenShenhai/koa2-note/blob/master/demo/jsonp/ 具体原理12345678910111213141516171819202122// 判断是否为JSONP的请求 if ( ctx.method === 'GET' &amp;&amp; ctx.url.split('?')[0] === '/getData.jsonp') &#123; // 获取jsonp的callback let callbackName = ctx.query.callback || 'callback' let returnData = &#123; success: true, data: &#123; text: 'this is a jsonp api', time: new Date().getTime(), &#125; &#125; // jsonp的script字符串 let jsonpStr = `;$&#123;callbackName&#125;($&#123;JSON.stringify(returnData)&#125;)` // 用text/javascript，让请求支持跨域获取 ctx.type = 'text/javascript' // 输出jsonp字符串 ctx.body = jsonpStr&#125; 解析原理 JSONP跨域输出的数据是可执行的JavaScript代码 ctx输出的类型应该是’text/javascript’ ctx输出的内容为可执行的返回数据JavaScript代码字符串 需要有回调函数名callbackName，前端获取后会通过动态执行JavaScript代码字符，获取里面的数据 效果截图同域访问JSON请求 跨域访问JSON请求 完整demo代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; // 如果jsonp 的请求为GET if ( ctx.method === 'GET' &amp;&amp; ctx.url.split('?')[0] === '/getData.jsonp') &#123; // 获取jsonp的callback let callbackName = ctx.query.callback || 'callback' let returnData = &#123; success: true, data: &#123; text: 'this is a jsonp api', time: new Date().getTime(), &#125; &#125; // jsonp的script字符串 let jsonpStr = `;$&#123;callbackName&#125;($&#123;JSON.stringify(returnData)&#125;)` // 用text/javascript，让请求支持跨域获取 ctx.type = 'text/javascript' // 输出jsonp字符串 ctx.body = jsonpStr &#125; else &#123; ctx.body = 'hello jsonp' &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] jsonp is starting at port 3000')&#125;)```## koa-jsonp中间件koa.js 官方wiki中也介绍了不少jsonp的中间件![jsonp-wiki](./../images/jsonp-wiki.png)其中koa-jsonp是支持koa2的，使用方式也非常简单，koa-jsonp的官方demo也很容易理解### 快速使用demo地址[https://github.com/ChenShenhai/koa2-note/blob/master/demo/jsonp-use-middleware/](https://github.com/ChenShenhai/koa2-note/blob/master/demo/jsonp-use-middleware/)#### 安装```shnpm install --save koa-jsonp 简单例子123456789101112131415161718192021222324const Koa = require('koa')const jsonp = require('koa-jsonp')const app = new Koa()// 使用中间件app.use(jsonp())app.use( async ( ctx ) =&gt; &#123; let returnData = &#123; success: true, data: &#123; text: 'this is a jsonp api', time: new Date().getTime(), &#125; &#125; // 直接输出JSON ctx.body = returnData&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] jsonp is starting at port 3000')&#125;) 测试单元测试前言测试是一个项目周期里必不可少的环节，开发者在开发过程中也是无时无刻进行“人工测试”，如果每次修改一点代码，都要牵一发动全身都要手动测试关联接口，这样子是禁锢了生产力。为了解放大部分测试生产力，相关的测试框架应运而生，比较出名的有mocha，karma，jasmine等。虽然框架繁多，但是使用起来都是大同小异。 准备工作安装测试相关框架1npm install --save-dev mocha chai supertest mocha 模块是测试框架 chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2 supertest 模块是http请求测试库，用来请求API接口 测试例子demo地址 https://github.com/ChenShenhai/koa2-note/blob/master/demo/test-unit/ 例子目录12345.├── index.js ## api文件├── package.json└── test ## 测试目录 └── index.test.js ## 测试用例 所需测试demo12345678910111213141516171819202122232425262728293031323334353637383940const Koa = require('koa')const app = new Koa()const server = async ( ctx, next ) =&gt; &#123; let result = &#123; success: true, data: null &#125; if ( ctx.method === 'GET' ) &#123; if ( ctx.url === '/getString.json' ) &#123; result.data = 'this is string data' &#125; else if ( ctx.url === '/getNumber.json' ) &#123; result.data = 123456 &#125; else &#123; result.success = false &#125; ctx.body = result next &amp;&amp; next() &#125; else if ( ctx.method === 'POST' ) &#123; if ( ctx.url === '/postData.json' ) &#123; result.data = 'ok' &#125; else &#123; result.success = false &#125; ctx.body = result next &amp;&amp; next() &#125; else &#123; ctx.body = 'hello world' next &amp;&amp; next() &#125;&#125;app.use(server)module.exports = appapp.listen(3000, () =&gt; &#123; console.log('[demo] test-unit is starting at port 3000')&#125;) 启动服务后访问接口会看到以下数据 http://localhost:3000/getString.json 开始写测试用例demo/test-unit/test/index.test.js 123456789101112131415161718192021222324const supertest = require('supertest')const chai = require('chai')const app = require('./../index')const expect = chai.expectconst request = supertest( app.listen() )// 测试套件/组describe( '开始测试demo的GET请求', ( ) =&gt; &#123; // 测试用例 it('测试/getString.json请求', ( done ) =&gt; &#123; request .get('/getString.json') .expect(200) .end(( err, res ) =&gt; &#123; // 断言判断结果是否为object类型 expect(res.body).to.be.an('object') expect(res.body.success).to.be.an('boolean') expect(res.body.data).to.be.an('string') done() &#125;) &#125;)&#125;) 执行测试用例12345## node.js &lt;= 7.5.x./node_modules/.bin/mocha --harmony## node.js = 7.6.0./node_modules/.bin/mocha 注意： 如果是全局安装了mocha，可以直接在当前项目目录下执行 mocha –harmony 命令 如果当前node.js版本低于7.6，由于7.5.x以下还直接不支持async/awiar就需要加上–harmony 会自动读取执行命令 ./test 目录下的测用例文件 inde.test.js，并执行。测试结果如下 用例详解服务入口加载如果要对一个服务的API接口，进行单元测试，要用supertest加载服务的入口文件12const supertest = require('supertest')const request = supertest( app.listen() ) 测试套件、用例 describe()描述的是一个测试套件 嵌套在describe()的it()是对接口进行自动化测试的测试用例 一个describe()可以包含多个it() 12345describe( '开始测试demo的GET请求', ( ) =&gt; &#123; it('测试/getString.json请求', () =&gt; &#123; // TODO ... &#125;)&#125;) supertest封装服务request，是用来请求接口 chai.expect使用来判断测试结果是否与预期一样 chai 断言有很多种方法，这里只是用了数据类型断言 debug开发debug快速开始环境 node环境 8.x + chrome 60+ 启动脚本调试demohttps://github.com/ChenShenhai/koa2-note/blob/master/demo/start-quick/ 1node --inspect index.js 指令框显示 指令框就会出现以下字样 12Debugger listening on ws://127.0.0.1:9229/4c23c723-5197-4d23-9b90-d473f1164abeFor help see https://nodejs.org/en/docs/inspector 访问chrome浏览器调试server 打开浏览器调试窗口会看到一个node.js 的小logo 打开chrome浏览器的node调试窗口 注意打开了node的调试窗口后，原来绿色的node\b按钮会\b变灰色，同时调试框会显示debug状态 可以自定义打断点调试了 项目框架搭建项目demo快速启动demo地址https://github.com/ChenShenhai/koa2-note/blob/master/demo/project/ 环境准备初始化数据库 安装MySQL5.6以上版本 创建数据库koa_demo 1create database koa_demo; 配置项目config.js https://github.com/ChenShenhai/koa2-note/blob/master/demo/project/ 123456789101112131415const config = &#123; // 启动端口 port: 3001, // 数据库配置 database: &#123; DATABASE: 'koa_demo', USERNAME: 'root', PASSWORD: 'abc123', PORT: '3306', HOST: 'localhost' &#125;&#125;module.exports = config 启动脚本1234567891011121314## 安装淘宝镜像cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org## 安装依赖cnpm install## 数据建库初始化npm run init_sql## 编译react.js源码npm run start_static## 启动服务npm run start_server 访问项目demohttp://localhost:3001/admin 框架设计实现概要 koa2 搭建服务 MySQL作为数据库 mysql 5.7 版本 储存普通数据 存储session登录态数据 渲染 服务端渲染：ejs作为服务端渲染的模板引擎 前端渲染：用webpack4环境编译react.js动态渲染页面，使用ant-design框架 文件目录设计demo源码 https://github.com/ChenShenhai/koa2-note/blob/master/demo/project/ 12345678910111213141516171819├── init ## 数据库初始化目录│ ├── index.js ## 初始化入口文件│ ├── sql/ ## sql脚本文件目录│ └── util/ ## 工具操作目录├── package.json ├── config.js ## 配置文件├── server ## 后端代码目录│ ├── app.js ## 后端服务入口文件│ ├── codes/ ## 提示语代码目录│ ├── controllers/ ## 操作层目录│ ├── models/ ## 数据模型model层目录│ ├── routers/ ## 路由目录│ ├── services/ ## 业务层目录│ ├── utils/ ## 工具类目录│ └── views/ ## 模板目录└── static ## 前端静态代码目录 ├── build/ ## webpack编译配置目录 ├── output/ ## 编译后前端代码目录&amp;静态资源前端访问目录 └── src/ ## 前端源代码目录 入口文件预览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const path = require('path')const Koa = require('koa')const convert = require('koa-convert')const views = require('koa-views')const koaStatic = require('koa-static')const bodyParser = require('koa-bodyparser')const koaLogger = require('koa-logger')const session = require('koa-session-minimal')const MysqlStore = require('koa-mysql-session')const config = require('./../config')const routers = require('./routers/index')const app = new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: 'USER_SID', store: new MysqlStore(sessionMysqlConfig)&#125;))// 配置控制台日志中间件app.use(convert(koaLogger()))// 配置ctx.body解析中间件app.use(bodyParser())// 配置静态资源加载中间件app.use(convert(koaStatic( path.join(__dirname , './../static'))))// 配置服务端模板渲染引擎中间件app.use(views(path.join(__dirname, './views'), &#123; extension: 'ejs'&#125;))// 初始化路由中间件app.use(routers.routes()).use(routers.allowedMethods())// 监听启动端口app.listen( config.port )console.log(`the server is start at port $&#123;config.port&#125;`)```## 分层设计### 后端代码目录```sh└── server ├── controllers ## 操作层 执行服务端模板渲染，json接口返回数据，页面跳转 │ ├── admin.js │ ├── index.js │ ├── user-info.js │ └── work.js ├── models ## 数据模型层 执行数据操作 │ └── user-Info.js ├── routers ## 路由层 控制路由 │ ├── admin.js │ ├── api.js │ ├── error.js │ ├── home.js │ ├── index.js │ └── work.js ├── services ## 业务层 实现数据层model到操作层controller的耦合封装 │ └── user-info.js └── views ## 服务端模板代码 ├── admin.ejs ├── error.ejs ├── index.ejs └── work.ejs 数据库设计初始化数据库脚本脚本目录./demos/project/init/sql/ 123456789101112131415CREATE TABLE IF NOT EXISTS `user_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, ## 用户ID `email` varchar(255) DEFAULT NULL, ## 邮箱地址 `password` varchar(255) DEFAULT NULL, ## 密码 `name` varchar(255) DEFAULT NULL, ## 用户名 `nick` varchar(255) DEFAULT NULL, ## 用户昵称 `detail_info` longtext DEFAULT NULL, ## 详细信息 `create_time` varchar(20) DEFAULT NULL, ## 创建时间 `modified_time` varchar(20) DEFAULT NULL, ## 修改时间 `level` int(11) DEFAULT NULL, ## 权限级别 PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;## 插入默认信息INSERT INTO `user_info` set name='admin001', email='admin001@example.com', password='123456'; 路由设计使用koa-router中间件路由目录12345678910## ...└── server ## 后端代码目录 └── routers ├── admin.js ## /admin/* 子路由 ├── api.js ## resetful /api/* 子路由 ├── error.js ## /error/* 子路由 ├── home.js ## 主页子路由 ├── index.js ## 子路由汇总文件 └── work.js ## /work/* 子路由 ## ... 子路由配置resetful API 子路由例如api子路由/user/getUserInfo.json，整合到主路由，加载到中间件后，请求的路径会是 http://www.example.com/api/user/getUserInfo.json ./demos/project/server/routers/api.js12345678910111213/** * restful api 子路由 */const router = require('koa-router')()const userInfoController = require('./../controllers/user-info')const routers = router .get('/user/getUserInfo.json', userInfoController.getLoginUserInfo) .post('/user/signIn.json', userInfoController.signIn) .post('/user/signUp.json', userInfoController.signUp)module.exports = routers 子路由汇总./demos/project/server/routers/index.js123456789101112131415161718/** * 整合所有子路由 */const router = require('koa-router')()const home = require('./home')const api = require('./api')const admin = require('./admin')const work = require('./work')const error = require('./error')router.use('/', home.routes(), home.allowedMethods())router.use('/api', api.routes(), api.allowedMethods())router.use('/admin', admin.routes(), admin.allowedMethods())router.use('/work', work.routes(), work.allowedMethods())router.use('/error', error.routes(), error.allowedMethods())module.exports = router app.js加载路由中间件./demos/project/server/app.js1234const routers = require('./routers/index')// 初始化路由中间件app.use(routers.routes()).use(routers.allowedMethods()) webpack4 环境搭建前言由于demos/project 前端渲染是通过react.js渲染的，这就需要webpack4 对react.js及其相关JSX，ES6/7代码进行编译和混淆压缩。 webpack4安装和文档可访问网https://webpack.js.org/ 配置webpack4编译react.js + less + sass + antd 环境文件目录12345678910111213141516└── static ## 项目静态文件目录 ├── build │ ├── webpack.base.config.js ## 基础编译脚本 │ ├── webpack.dev.config.js ## 开发环境编译脚本 │ └── webpack.prod.config.js ## 生产环境编译脚本 ├── output ## 编译后输出目录 │ ├── asset │ ├── dist │ └── upload └── src ## 待编译的ES6/7、JSX源代码 ├── api ├── apps ├── components ├── pages ├── texts └── utils webpack4 编译基础配置babel@7 配置123456789101112131415161718192021222324252627282930313233const babelConfig = &#123; presets: [ '@babel/env', // [ // '@babel/env', // &#123; // targets: &#123; // edge: '17', // firefox: '60', // chrome: '67', // safari: '11.1' // &#125;, // useBuiltIns: 'usage' // &#125; // ], '@babel/preset-react' ], 'plugins': [ [ 'import', &#123; 'libraryName': 'antd', 'libraryDirectory': 'lib' &#125;, 'ant' ], [ 'import', &#123; 'libraryName': 'antd-mobile', 'libraryDirectory': 'lib' &#125;, 'antd-mobile' ], '@babel/plugin-proposal-class-properties' ]&#125;;module.exports = babelConfig; webpack.base.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const path = require('path');const webpack = require('webpack');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const babelConfig = require('./babel.config');// const prodMode = process.env.NODE_ENV === 'production';const srcResolve = function (file) &#123; return path.join(__dirname, '..', 'src', file);&#125;;const distResolve = function (file) &#123; return path.join(__dirname, '..', 'output', 'dist', file);&#125;;module.exports = &#123; entry: &#123; 'index': srcResolve('js/index'), 'admin' : srcResolve('pages/admin.js'), 'work' : srcResolve('pages/work.js'), 'index' : srcResolve('pages/index.js'), 'error' : srcResolve('pages/error.js'), &#125;, output: &#123; path: distResolve(''), filename: 'vendorjs/[name].js' &#125;, module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, use: &#123; loader: 'babel-loader', options: babelConfig &#125; &#125;, &#123; test: /\\.(css|less)$/, use: [ // devMode ? 'style-loader' : MiniCssExtractPlugin.loader, // 'style-loader', MiniCssExtractPlugin.loader, 'css-loader', // 'postcss-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; &#123; return []; &#125; &#125; &#125;, 'less-loader' ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css' &#125;) ], optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: 'vendor', chunks: 'all' &#125; &#125; &#125; &#125;&#125;; 配置开发&amp;生产环境webpack4 编译设置为了方便编译基本配置代码统一管理，开发环境（wepack.dev.config.js）和生产环境（webpack.prod.config.js）的编译配置都是继承了基本配置（wepack.base.config.js）的代码 开发环境配置 wepack.dev.config.js12345678910111213141516var merge = require('webpack-merge')var webpack = require('webpack')var baseWebpackConfig = require('./webpack.base.config');module.exports = merge(baseWebpackConfig, &#123; devtool: 'source-map', plugins: [ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('development') &#125; &#125;), ]&#125;) 编译环境配置 wepack.prod.config.js12345678910111213141516171819202122process.env.NODE_ENV = 'production';const merge = require('webpack-merge');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');const config = require('./webpack.base.config');module.exports = merge(config, &#123; mode: 'production', // plugins: [ // new UglifyJsPlugin() // ] optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;&#125;); 使用react.jsreact.js简介react.js 是作为前端渲染的js库（注意：不是框架）。react.js用JSX开发来描述DOM结构，通过编译成virtual dom的在浏览器中进行view渲染和动态交互处理。更多了解可查阅GitHubhttps://facebook.github.io/react/ 编译使用由于react.js开发过程用JSX编程，无法直接在浏览器中运行，需要编译成浏览器可识别运行的virtual dom。从JSX开发到运行，需要有一个编译的过程。目前最常用的方案是用webpack + babel进行编译打包。 前端待编译源文件目录demos/project/static/123456789101112131415161718192021222324252627.├── build ## 编译的webpack脚本│ ├── webpack.base.config.js│ ├── webpack.dev.config.js│ └── webpack.prod.config.js├── output ## 输出文件│ ├── asset│ ├── dist ## react.js编译后的文件目录│ └── ...└── src ├── apps ## 页面react.js应用 │ ├── admin.jsx │ ├── error.jsx │ ├── index.jsx │ └── work.jsx ├── components ## jsx 模块、组件 │ ├── footer-common.jsx │ ├── form-group.jsx │ ├── header-nav.jsx │ ├── sign-in-form.jsx │ └── sign-up-form.jsx └── pages ## react.js 执行render文件目录 ├── admin.js ├── error.js ├── index.js └── work.js ... react.js页面应用文件static/src/apps/index.jsx 文件12345678910111213141516171819202122232425262728import React from 'react'import ReactDOM from 'react-dom'import &#123; Layout, Menu, Breadcrumb &#125; from 'antd'import HeadeNav from './../components/header-nav.jsx'import FooterCommon from './../components/footer-common.jsx'import 'antd/lib/layout/style/css'const &#123; Header, Content, Footer &#125; = Layoutclass App extends React.Component &#123; render() &#123; return ( &lt;Layout className=\"layout\"&gt; &lt;HeadeNav/&gt; &lt;Content style=&#123;&#123; padding: '0 50px' &#125;&#125;&gt; &lt;Breadcrumb style=&#123;&#123; margin: '12px 0' &#125;&#125;&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt; &lt;div style=&#123;&#123; background: '#fff', padding: 24, minHeight: 280 &#125;&#125;&gt; &lt;p&gt;index&lt;/p&gt; &lt;/div&gt; &lt;/Content&gt; &lt;FooterCommon /&gt; &lt;/Layout&gt; ) &#125;&#125;export default App react.js执行render渲染static/src/pages/index.js 文件123456import React from 'react'import ReactDOM from 'react-dom'import App from './../apps/index.jsx'ReactDOM.render( &lt;App /&gt;, document.getElementById(\"app\")) 静态页面引用react.js编译后文件123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/output/dist/css/index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"/output/dist/js/vendor.js\"&gt;&lt;/script&gt; &lt;script src=\"/output/dist/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面渲染效果 登录注册功能实现用户模型dao操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 数据库创建用户 * @param &#123;object&#125; model 用户数据模型 * @return &#123;object&#125; mysql执行结果 */ async create ( model ) &#123; let result = await dbUtils.insertData( 'user_info', model ) return result &#125;, /** * 查找一个存在用户的数据 * @param &#123;obejct&#125; options 查找条件参数 * @return &#123;object|null&#125; 查找结果 */ async getExistOne(options ) &#123; let _sql = ` SELECT * from user_info where email=\"$&#123;options.email&#125;\" or name=\"$&#123;options.name&#125;\" limit 1` let result = await dbUtils.query( _sql ) if ( Array.isArray(result) &amp;&amp; result.length &gt; 0 ) &#123; result = result[0] &#125; else &#123; result = null &#125; return result &#125;, /** * 根据用户名和密码查找用户 * @param &#123;object&#125; options 用户名密码对象 * @return &#123;object|null&#125; 查找结果 */ async getOneByUserNameAndPassword( options ) &#123; let _sql = ` SELECT * from user_info where password=\"$&#123;options.password&#125;\" and name=\"$&#123;options.name&#125;\" limit 1` let result = await dbUtils.query( _sql ) if ( Array.isArray(result) &amp;&amp; result.length &gt; 0 ) &#123; result = result[0] &#125; else &#123; result = null &#125; return result &#125;, /** * 根据用户名查找用户信息 * @param &#123;string&#125; userName 用户账号名称 * @return &#123;object|null&#125; 查找结果 */ async getUserInfoByUserName( userName ) &#123; let result = await dbUtils.select( 'user_info', ['id', 'email', 'name', 'detail_info', 'create_time', 'modified_time', 'modified_time' ]) if ( Array.isArray(result) &amp;&amp; result.length &gt; 0 ) &#123; result = result[0] &#125; else &#123; result = null &#125; return result &#125;, 业务层操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 创建用户 * @param &#123;object&#125; user 用户信息 * @return &#123;object&#125; 创建结果 */ async create( user ) &#123; let result = await userModel.create(user) return result &#125;, /** * 查找存在用户信息 * @param &#123;object&#125; formData 查找的表单数据 * @return &#123;object|null&#125; 查找结果 */ async getExistOne( formData ) &#123; let resultData = await userModel.getExistOne(&#123; 'email': formData.email, 'name': formData.userName &#125;) return resultData &#125;, /** * 登录业务操作 * @param &#123;object&#125; formData 登录表单信息 * @return &#123;object&#125; 登录业务操作结果 */ async signIn( formData ) &#123; let resultData = await userModel.getOneByUserNameAndPassword(&#123; 'password': formData.password, 'name': formData.userName&#125;) return resultData &#125;, /** * 根据用户名查找用户业务操作 * @param &#123;string&#125; userName 用户名 * @return &#123;object|null&#125; 查找结果 */ async getUserInfoByUserName( userName ) &#123; let resultData = await userModel.getUserInfoByUserName( userName ) || &#123;&#125; let userInfo = &#123; // id: resultData.id, email: resultData.email, userName: resultData.name, detailInfo: resultData.detail_info, createTime: resultData.create_time &#125; return userInfo &#125;, /** * 检验用户注册数据 * @param &#123;object&#125; userInfo 用户注册数据 * @return &#123;object&#125; 校验结果 */ validatorSignUp( userInfo ) &#123; let result = &#123; success: false, message: '', &#125; if ( /[a-z0-9\\_\\-]&#123;6,16&#125;/.test(userInfo.userName) === false ) &#123; result.message = userCode.ERROR_USER_NAME return result &#125; if ( !validator.isEmail( userInfo.email ) ) &#123; result.message = userCode.ERROR_EMAIL return result &#125; if ( !/[\\w+]&#123;6,16&#125;/.test( userInfo.password ) ) &#123; result.message = userCode.ERROR_PASSWORD return result &#125; if ( userInfo.password !== userInfo.confirmPassword ) &#123; result.message = userCode.ERROR_PASSWORD_CONFORM return result &#125; result.success = true return result &#125; controller 操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 登录操作 * @param &#123;obejct&#125; ctx 上下文对象 */ async signIn( ctx ) &#123; let formData = ctx.request.body let result = &#123; success: false, message: '', data: null, code: '' &#125; let userResult = await userInfoService.signIn( formData ) if ( userResult ) &#123; if ( formData.userName === userResult.name ) &#123; result.success = true &#125; else &#123; result.message = userCode.FAIL_USER_NAME_OR_PASSWORD_ERROR result.code = 'FAIL_USER_NAME_OR_PASSWORD_ERROR' &#125; &#125; else &#123; result.code = 'FAIL_USER_NO_EXIST', result.message = userCode.FAIL_USER_NO_EXIST &#125; if ( formData.source === 'form' &amp;&amp; result.success === true ) &#123; let session = ctx.session session.isLogin = true session.userName = userResult.name session.userId = userResult.id ctx.redirect('/work') &#125; else &#123; ctx.body = result &#125; &#125;, /** * 注册操作 * @param &#123;obejct&#125; ctx 上下文对象 */ async signUp( ctx ) &#123; let formData = ctx.request.body let result = &#123; success: false, message: '', data: null &#125; let validateResult = userInfoService.validatorSignUp( formData ) if ( validateResult.success === false ) &#123; result = validateResult ctx.body = result return &#125; let existOne = await userInfoService.getExistOne(formData) console.log( existOne ) if ( existOne ) &#123; if ( existOne .name === formData.userName ) &#123; result.message = userCode.FAIL_USER_NAME_IS_EXIST ctx.body = result return &#125; if ( existOne .email === formData.email ) &#123; result.message = userCode.FAIL_EMAIL_IS_EXIST ctx.body = result return &#125; &#125; let userResult = await userInfoService.create(&#123; email: formData.email, password: formData.password, name: formData.userName, create_time: new Date().getTime(), level: 1, &#125;) console.log( userResult ) if ( userResult &amp;&amp; userResult.insertId * 1 &gt; 0) &#123; result.success = true &#125; else &#123; result.message = userCode.ERROR_SYS &#125; ctx.body = result &#125;, api路由操作1234567const router = require('koa-router')()const userInfoController = require('./../controllers/user-info')const routers = router .get('/user/getUserInfo.json', userInfoController.getLoginUserInfo) .post('/user/signIn.json', userInfoController.signIn) .post('/user/signUp.json', userInfoController.signUp) 前端用react.js实现效果登录模式注册模式 session登录态判断处理使用session中间件123456789101112131415161718192021222324// code ...const session = require('koa-session-minimal')const MysqlStore = require('koa-mysql-session')const config = require('./../config')// code ...const app = new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: 'USER_SID', store: new MysqlStore(sessionMysqlConfig)&#125;))// code ... 登录成功后设置session到MySQL和设置sessionId到cookie1234let session = ctx.sessionsession.isLogin = truesession.userName = userResult.namesession.userId = userResult.id 需要判断登录态页面进行session判断123456789101112async indexPage ( ctx ) &#123; // 判断是否有session if ( ctx.session &amp;&amp; ctx.session.isLogin &amp;&amp; ctx.session.userName ) &#123; const title = 'work页面' await ctx.render('work', &#123; title, &#125;) &#125; else &#123; // 没有登录态则跳转到错误页面 ctx.redirect('/error') &#125; &#125;, 其他进阶前言 Node 9最激动人心的是提供了在flag模式下使用ECMAScript Modules，虽然现在还是Stability: 1 - Experimental阶段，但是可以让Noder抛掉babel等工具的束缚，直接在Node环境下愉快地去玩耍import/export 如果觉得文字太多，看不下去，可以直接去玩玩demo，地址是https://github.com/chenshenhai/node-modules-demo Node 9下import/export使用简单须知 Node 环境必须在 9.0以上 不加loader时候，使用import/export的文件后缀名必须为*.mjs（下面会讲利用Loader Hooks兼容*.js后缀文件） 启动必须加上flag --experimental-modules 文件的import和export必须严格按照ECMAScript Modules语法 ECMAScript Modules和require()的cache机制不一样 使用简述Node 9.x官方文档 https://nodejs.org/dist/latest-v9.x/docs/api/esm.html 与require()区别 能力 描述 require() import NODE_PATH 从NODE_PATH加载依赖模块 Y N cache 缓存机制 可以通过require的API操作缓存 自己独立的缓存机制，目前不可访问 path 引用路径 文件路径 URL格式文件路径，例如import A from &#39;./a?v=2017&#39; extensions 扩展名机制 require.extensions Loader Hooks natives 原生模块引用 直接支持 直接支持 npm npm模块引用 直接支持 需要Loader Hooks file 文件(引用) *.js,*.json等直接支持 默认只能是*.mjs，通过Loader Hooks可以自定义配置规则支持*.js,*.json等Node原有支持文件 Loader Hooks模式使用 由于历史原因，在ES6的Modules还没确定之前，JavaScript的模块化处理方案都是八仙过海，各显神通，例如前端的AMD、CMD模块方案，Node的CommonJS方案也在这个“乱世”诞生。当到了ES6规范确定后，Node的CommonJS方案已经是JavaScript中比较成熟的模块化方案，但ES6怎么说都是正统的规范，“法理”上是需要兼容的，所以*.mjs这个针对ECMAScript Modules规范的Node文件方案在一片讨论声中应运而生。 当然如果import/export只能对*.mjs文件起作用，意味着Node原生模块和npm所有第三方模块都不能。所以这时候Node 9就提供了 Loader Hooks，开发者可自定义配置Resolve Hook规则去利用import/export加载使用Node原生模块，*.js文件，npm模块，C/C++的Node编译模块等Node生态圈的模块。 Loader Hooks 使用步骤 自定义loader规则 启动的flag要加载loader规则文件 例如：node --experimental-modules --loader ./custom-loader.mjs ./index.js Koa2 直接使用import/export看看demo4，https://github.com/chenshenhai/node-modules-demo/tree/master/demo4 文件目录 12345678910111213├── esm│ ├── README.md│ ├── custom-loader.mjs│ ├── index.js│ ├── lib│ │ ├── data.json│ │ ├── path.js│ │ └── render.js│ ├── package.json│ └── view│ ├── index.html│ ├── index.html│ └── todo.html 代码片段太多，不一一贴出来，只显示主文件 1234567891011121314151617181920import Koa from 'koa';import &#123; render &#125; from './lib/render.js';import data from './lib/data.json';let app = new Koa();app.use((ctx, next) =&gt; &#123; let view = ctx.url.substr(1); let content; if ( view === '' ) &#123; content = render('index'); &#125; else if ( view === 'data' ) &#123; content = data; &#125; else &#123; content = render(view); &#125; ctx.body = content;&#125;)app.listen(3000, ()=&gt;&#123; console.log('the modules test server is starting');&#125;) 执行代码 1node --experimental-modules --loader ./custom-loader.mjs ./index.js 访问 访问 http://127.0.0.1:3000/index 访问 http://127.0.0.1:3000/data 访问 http://127.0.0.1:3000/todo 自定义loader规则优化从上面官方提供的自定义loader例子看出，只是对*.js文件做import/export做loader兼容，然而我们在实际开发中需要对npm模块，*.json文件也使用import/export loader规则优化解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import url from 'url';import path from 'path';import process from 'process';import fs from 'fs';// 从package.json中// 的dependencies、devDependencies获取项目所需npm模块信息const ROOT_PATH = process.cwd();const PKG_JSON_PATH = path.join( ROOT_PATH, 'package.json' );const PKG_JSON_STR = fs.readFileSync(PKG_JSON_PATH, 'binary');const PKG_JSON = JSON.parse(PKG_JSON_STR);// 项目所需npm模块信息const allDependencies = &#123; ...PKG_JSON.dependencies || &#123;&#125;, ...PKG_JSON.devDependencies || &#123;&#125;&#125;//Node原生模信息const builtins = new Set( Object.keys(process.binding('natives')).filter((str) =&gt; /^(?!(?:internal|node|v8)\\/)/.test(str)));// 文件引用兼容后缀名const JS_EXTENSIONS = new Set(['.js', '.mjs']);const JSON_EXTENSIONS = new Set(['.json']);export function resolve(specifier, parentModuleURL, defaultResolve) &#123; // 判断是否为Node原生模块 if (builtins.has(specifier)) &#123; return &#123; url: specifier, format: 'builtin' &#125;; &#125; // 判断是否为npm模块 if ( allDependencies &amp;&amp; typeof allDependencies[specifier] === 'string' ) &#123; return defaultResolve(specifier, parentModuleURL); &#125; // 如果是文件引用，判断是否路径格式正确 if (/^\\.&#123;0,2&#125;[/]/.test(specifier) !== true &amp;&amp; !specifier.startsWith('file:')) &#123; throw new Error( `imports must begin with '/', './', or '../'; '$&#123;specifier&#125;' does not`); &#125; // 判断是否为*.js、*.mjs、*.json文件 const resolved = new url.URL(specifier, parentModuleURL); const ext = path.extname(resolved.pathname); if (!JS_EXTENSIONS.has(ext) &amp;&amp; !JSON_EXTENSIONS.has(ext)) &#123; throw new Error( `Cannot load file with non-JavaScript file extension $&#123;ext&#125;.`); &#125; // 如果是*.js、*.mjs文件 if (JS_EXTENSIONS.has(ext)) &#123; return &#123; url: resolved.href, format: 'esm' &#125;; &#125; // 如果是*.json文件 if (JSON_EXTENSIONS.has(ext)) &#123; return &#123; url: resolved.href, format: 'json' &#125;; &#125;&#125; 规则总结在自定义loader中，export的resolve规则最核心的代码是1234return &#123; url: '', format: ''&#125; url 是模块名称或者文件URL格式路径 format 是模块格式有esm, cjs, json, builtin, addon这四种模块/文件格式. 注意：目前Node对import/export的支持现在还是Stability: 1 - Experimental阶段，后续的发展还有很多不确定因素，自己练手玩玩还可以，但是在还没去flag使用之前，尽量不要在生产环境中使用。Node 9.x 更详细import/export的使用，可参考 https://github.com/ChenShenhai/blog/issues/24","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"/tags/后端/"}]},{"title":"MYSQL(十二)","slug":"MYSQL-十二","date":"2023-04-06T08:14:23.000Z","updated":"2024-01-11T07:00:59.142Z","comments":true,"path":"2023/04/06/MYSQL-十二/","link":"","permalink":"/2023/04/06/MYSQL-十二/","excerpt":"mysql学习笔记整理-账号管理","text":"mysql学习笔记整理-账号管理 账号管理MYSQL 新版本需要将创建用户与权限配置分配操作 添加帐号添加用户 houdunren 并设置密码为 admin8881CREATE USER houdunren IDENTIFIED BY &apos;admin888&apos;; 刷新帐表使设置立刻生效1FLUSH PRIVILEGES; 修改密码下面是设置 root 帐号的密码为 admin8881ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;admin888&apos;; 设置权限下面来学习设置权限，修改权限后需要用户重新登录生效。查看当前用户权限1SHOW grants; 查看指定用户权限1SHOW GRANTS FOR &apos;houdunren&apos;@&apos;%&apos;; 移除用户权限1REVOKE ALL ON *.* FROM houdunren@&apos;%&apos;; 用户可以为 code 库中的所有表执行 SELECT 与 INSERT 操作1GRANT SELECT ,INSERT ON code.* TO houdunren@&apos;%&apos;; 可以从任何电脑登录服务器并管理所有库和表1GRANT ALL ON *.* TO houdunren@&apos;%&apos;; 用户可以管理 code 库中的所有表，来源以 192.168.0 开始的 IP 地址1GRANT ALL ON code.* TO houdunren@&apos;192.168.0.%&apos;; 用户 houdunren 可以对 code 库中的所有表执行 ALTER ,CREATE ,DROP 指令，并且来源不受限制1GRANT ALTER ,CREATE ,DROP ON code.* TO houdunren@&apos;%&apos;;","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(十一)","slug":"MYSQL-十一","date":"2023-04-06T08:14:15.000Z","updated":"2024-01-11T07:00:59.135Z","comments":true,"path":"2023/04/06/MYSQL-十一/","link":"","permalink":"/2023/04/06/MYSQL-十一/","excerpt":"mysql学习笔记整理-索引优化","text":"mysql学习笔记整理-索引优化 索引优化基础知识合理设置索引会对数据库性能带来很大提升。 测试数据为了演示索引需要添加些测试数据，下面是添加学生数据的储存过程代码。如果你已经有测试数据可以省掉这一步。123456789101112131415161718DELIMITER $$CREATE PROCEDURE add_stus(IN num int)BEGINDECLARE i int DEFAULT 0;DECLARE _birthday datetime;WHILE num&gt;i DO SET _birthday = date_sub(now(),INTERVAL floor(RAND()*1000) day); INSERT INTO stu SET sname = concat(left(md5(RAND()),5),&apos;后盾人向军&apos;), class_id =1+FLOOR( RAND()*100000), birthday = _birthday , sex = 1+FLOOR(RAND()*2 ); SET i= i+1;END WHILE;END$$DELIMITER ; 调用储存过程添加五十万条记录1call add_stus(500000) 基础思路选择合理范围内最小的 我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘 I/0 读写开销，减少内存占用，减少 CPU 的占用率。 选择相对简单的数据类型 数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如说在保存时间时，因为 PHP 可以良好的处理 LINUX 时间戳所以我们可以将日期存为 int(10)要方便、合适、快速的多。 字符串字符串数据类型是一个万能数据类型，可以储存数值、字符串等。 保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的 9 是大于 22 的。如果进行运算时 mysql 会将字符串转换为数值类型，这种转换是不会走索引的。 如果明确数据在一个完整的集合中如男，女，那么可以使用 set 或 enum 数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。 数值类型整数 整数类型很多比如 tinyint、int、smallint、bigint 等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时 tinyint(10)与 tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定 zerofill 属性查看显示时区别。 浮点数与精度数值 浮点数 float 与 double 在储存空间及运行效率上要优于精度数值类型 decimal，但 float 与 double 会有舍入错误而 decimal 则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。 总结数值数据类型要比字符串执行更快，范围区间小的数据类型占用空间更少，处理速度更快，如 tinyint 可比 bigint 要快的多。选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型。 EXPLAINEXPLAIN 指令可以帮助开发人员分析 SQL 问题，explain 显示了 mysql 如何使用索引来处理 select 语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。字段说明 字段 说明 备注 id 索引执行顺序 select_type 查询类型 simple:基本查询 union result:union 的结果 table 操作表 type 使用类型 const: 前面表匹配唯一行检索速度快，如果使用主键值比较ref: 前面表中的非唯一数据eq_ref:前面表中非唯一数据，使用了唯一索引字段，如表关联时使用主键range:索引区间获得，如使用 IN(1,2,3)筛选all:全表遍历index:与 all 类似只是扫描所有表，而非数据表 possible_keys 可能用到的索引，不一定被真正使用 key 最终使用的索引 key_len 索引字节数 ref 列与索引的比较 const 为常量比较 rows 预计读出的记录条数 Extra 查询说明 &nbsp; 使用没有添加索引的 birthday 字段会进行全表扫描1explain select * from stu where birthday = &apos;19900231&apos;; 使用索引表排序所以 type 为 index1explain select * from stu order by id ; 使用主键查询会使用 const 类型1explain select * from stu where id = 3; 使用 IN 查询后使用了区间 range 索引1explain select * from stu where class_id in(1,2,3); 下面是多表关联使用索引的情况1explain select * from stu s inner join class c on s.class_id = c.id where sname = &apos;后盾人&apos; 索引基础索引就像一本书的目录一样，我们可以通过一本书的目录，快速的找到需要的页面，但是我们也不能过多的创建目录页（索引），原因是如果某一篇文章删除或修改将发变所有页码的顺序，就需要重新创建目录。select sname from stu where sname=&quot;后盾人&quot; 如果 sname 使用了索引，上面这个例子就会使用到 sname 索引索引弊端 创建索引会使查询操作变得更加快速，但是会降低增加、删除、更新操作的速度，因为执行这些操作的同时会对索引文件进行重新排序或更新 创建过多列的索引会大大增加磁盘空间开销 不要盲目的创建索引，只为查询操作频繁的列创建索引 索引类型 索引 说明 UNIQUE 唯一索引 不可以出现相同的值，可以有 NULL 值 INDEX 普通索引 允许出现相同的索引内容 PRIMARY KEY 主键索引 不允许出现相同的值，且不能为 NULL 值 索引维护为 stu 学生表的 sname 字段设置索引1ALTER TABLE stu ADD INDEX sname_index(sname) 删除索引1ALTER TABLE stu DROP INDEX sname_index 删除主键索引，首先需要移除 auto_increment 然后删除主键索引12ALTER TABLE stu MODIFY id int;ALTER TABLE stu DROP PRIMARY KEY 查看表索引1show index from stu; 性能分析索引是加快查询操作的重要手段，如果当发生查询过慢时添加上索引后会发现速度大大改观 普通字段当没有地表 class_id 字段添加索引时，查找 cid 为 3 的记录会执行全表扫描，性能是最差的1EXPLAIN SELECT * FROM stu WHERE class_id =5 LIMIT 1; 通过结果的 type=ALL 可以看到执行了全表扫描，遍历了一百万条记录123456789101112id | 1select_type | SIMPLEtable | stupartitions | &lt;null&gt;type | ALLpossible_keys | &lt;null&gt;key | &lt;null&gt;key_len | &lt;null&gt;ref | &lt;null&gt;rows | 1000000filtered | 10.0Extra | Using where 索引字段下面来为 class_id 添加索引1ALTER TABLE stu ADD INDEX class_id(class_id); 再次执行查询来看添加索引后的效果1EXPLAIN SELECT * FROM stu WHERE class_id =5 LIMIT 1; 通过查看 type 字段看到已经走了索引，本次查询遍历了 16 条记录123456789101112id | 1select_type | SIMPLEtable | stupartitions | &lt;null&gt;type | refpossible_keys | class_idkey | class_idkey_len | 5ref | constrows | 16filtered | 100.0Extra | &lt;null&gt; 多表操作在使用连接操作多个表时，如果没有添加索引性能会非常差。1explain select * from a join b on a.id=b.id join c on b.id=c.id 结果中会看到每张表都遍历了所有记录下面来添加索引123ALTER TABLE a ADD INDEX id(id);ALTER TABLE b ADD INDEX id(id);ALTER TABLE c ADD INDEX id(id); 执行的结果会看到使用了索引，并且并没有进行全表遍历 字段选择维度思考 数据列中不重复值出现的个数，维度的最大值是数据行的数量 如数据表中存在 8 行数据 a ,b ,c,d,a,b,c,d 这个表的维度为 4 要为维度高的列创建索引 性别这样的列不适合创建索引，因为维度过低 索引规则 对 where，on 或 group by 及 order by 中出现的列使用索引 对较小的数据列使用索引，这样会使索引文件更小，同时内存中也可以装载更多的索引键 为较长的字符串使用前缀索引 不要过多创建索引，除了增加额外的磁盘空间外，对于 DML 操作的速度影响很大 前缀与组合前缀索引大使用 text/长 varchar 字段时创建索引，会造成索引列长度过长，从而生成过大的索引文件影响检索性能。使用前缀索引方式进行索引，可以有效解决这个问题。前缀索引应该控制在一个合适的点，控制在 0.31 黄金值即可。 下面是取前缀索引的计算公式，有时也根据字段保存内容确定，比如标题 100 可以取 30 个字符为索引1select count(distinct(left(title,10)))/count(*) from news 下面为文章表 article 的 title 字段添加 30 个长度的前缀索引1ALTER TABLE article ADD INDEX title(title(30)); 组合索引组合索引为是多个字段统一设计索引 可以较为每个字段设置索引文件体积更小 使用速度优于多个索引操作 前面字段没出现，只出现后面字段时不走索引 下面为学生表中的班级字段 class_id 与学生状态 status 设置组合索引1Alter table stu add index class_id_status(class_id,status); 使用 class_id 时会走索引，因为 class_id 在组合索引最前面1explain select * from stu where class_id =3; 只使用 status 字段不会走索引1explain select * from stu where status =1 当 class_id 与 status 字段一起使用时会走索引1explain select * from stu where status =1 and class_id=5; 查询优化解析器Mysql 的解析器非常智能，会对发出的每条 SQL 进行分析，决定是否使用索引或是否进行全表扫描。 下面发送的 SQL 解析器分析后已经清楚不会有任何语句符合操作，所以不会操作任何表或索引1select * from houdunwang where false 表达式影响下面 SQL 语句不会使用索引，因为所有索引列参与了计算1explain select * from stu where status+1=1; 下面 SQL 不会使用索引，因为使用了函数运算，原理与上面相同1explain select * from stu where left(sname,1)=&apos;后盾人&apos; 下面 SQL 不会使用索引，因为索引列是模糊匹配的1explain select * from stu where sname like &apos;%向军大叔%&apos; 下面 SQL 会使用索引，因为不是模糊匹配1explain select * from stu where sname like &apos;后盾人%&apos; 正则表达式也不会使用索引1explain select * from stu where sname regexp &apos;^后盾人&apos; 类型比较相同类型比较时走索引1explain select * from stu where sname=&quot;1&quot;; 字符串类型使用数值时不走索引1explain select * from stu where sname=1; 排序排序中尽量使用添加索引的列进行下例使用数据表进行排序1explain select id from stu order by birthday 排序字段为索引列后使用索引表排序1explain select id from stu order by id ; 慢查询当 Mysql 性能下降时，通过开启慢查询来获得哪条 SQL 语句造成的响应过慢进行分析处理。当然开启慢查询会带来 CPU 损耗与日志记录的 IO 开销，所以我们要间断性的打开慢查询日志来查看 Mysql 运行状态。 慢查询能记录下所有执行超过 long_query_time 时间的 SQL 语句, 用于找到执行慢的 SQL, 方便我们对这些 SQL 进行优化。 状态查看查看开启慢查询状态12345678show variables like &apos;slow_query%&apos;;+---------------------+-----------------------------------+| Variable_name | Value |+---------------------+-----------------------------------+| slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/homestead-slow.log |+---------------------+-----------------------------------+ 查看慢查询设置的时间1234567show variables like &quot;long_query_time&quot;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+ 运行配置会话配置 通过以下指令开启全局慢查询（如果重起 Mysql 后需要重新执行）1set global slow_query_log=&apos;ON&apos;; 设置慢查询时间为 1 秒，即超过 1 秒将会被记录到慢查询日志1set session long_query_time=1; 全局配置通过修改配置 mysql 配置文件 my.cnf 来开启全局慢查询配置，在配置文件中修改以下内容123slow_query_log = ONslow_query_log_file = /usr/local/mysql/data/slow.loglong_query_time = 1 重起 MYSQL 服务1service mysqld restart","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(十)","slug":"MYSQL-十","date":"2023-04-06T08:14:07.000Z","updated":"2024-01-11T07:00:59.135Z","comments":true,"path":"2023/04/06/MYSQL-十/","link":"","permalink":"/2023/04/06/MYSQL-十/","excerpt":"mysql学习笔记整理-外键约束","text":"mysql学习笔记整理-外键约束 外键约束外键表示一个表中的字段被另一个表中的一个字段引用。外键对相关表中的数据造成了限制，使 MySQL 能够保持数据完整性。比如学生和班级表，学生表完全依赖班级表，我们可以通过外键约束让学生表与班级表产生关联，当班级表数据变化时影响学生表。 父表和子表储存引擎要一致 使用 InnoDB 引擎支持外键约束 外键要与主表列类型一致 外键列使用索引（有些版本的 mysql 会自动帮助为外键设置索引) 创建外键下面我们先创建表关联后，再详细解释里面的参数选项。 新建表下面创建班级表与学生表，并定义学生表与班级表建立外键约束。1234567891011121314-- 班级表CREATE TABLE class (id int PRIMARY KEY AUTO_INCREMENT,name varchar(50));-- 学生表CREATE TABLE stu ( `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `sname` varchar(30) DEFAULT NULL, `class_id` int(11) DEFAULT NULL, CONSTRAINT `stu_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8 修改表下面是对学生表添加班级表的外键约束。123456ALTER TABLE stu ADDCONSTRAINT stu_classFOREIGN KEY (class_id)REFERENCES class(id)ON DELETE SET NULLON UPDATE CASCADE; 删除1ALTER TABLE stu DROP FOREIGN KEY stu_class; 选项说明下面列出外键关联用到的关键词。 选项 说明 CONSTRAINT 为外键约束定义名称 FOREIGN KEY 子表与父表关联的列 REFERENCES 子表关联的父表字段 ON DELETE 父表删除时的处理方式 ON UPDATE 父表更新时的处理方式 处理动作ON DELETEON DELETE 指在删除时的处理方式，常用的处理方式包括以下几种。 选项 说明 ON DELETE CASCADE 删除父表记录时，子表记录同时删除 ON DELETE SET NULL 删除父表记录时，子表记录设置为 NULL（子表字段要允许 NULL） ON DELETE NO ACTION ON DELETE RESTRICT 删除父表记录时，子表不做任何处理，必须把子表处理完才可以删除主表 ON UPDATEON UPDATE 指在更新时的处理方式，常用的处理方式包括以下几种。 选项 说明 ON UPDATE CASCADE 更新父表记录时，比如更改主表的主键时，子表记录同时更新 ON UPDATE SET NULL 更新父表记录时，比如更改主表的主键时，子表记录设置为 NULL ON UPDATE NO ACTION ON UPDATE RESTRICT 更新父表记录时，子表不做任何处理，必须把子表处理完才可以更新主表","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(九)","slug":"MYSQL-九","date":"2023-04-06T08:13:57.000Z","updated":"2024-01-11T07:00:59.132Z","comments":true,"path":"2023/04/06/MYSQL-九/","link":"","permalink":"/2023/04/06/MYSQL-九/","excerpt":"mysql学习笔记整理-锁机制","text":"mysql学习笔记整理-锁机制 锁机制因为 Mysql 支持多线程方式，所以可以同时处理多个客户端请求。有时为了防止客户端同时修改数据，我们使用锁操作完成。 比如一个用户在修改数据，另一个用户也要修改该条数据，我们可以让第一个用户独占这个表记录，等他操作完再让第二个用户操作。 下面是典型的商城应用，多用户购买商品时可以使用锁机制保障库存的准确性。 储存引擎InnoDB 是主流储存引擎并支持行级锁的，有更高的并发处理性能，下面来演示行锁的运行过程。MyIsam引擎在最新版本的 MYSQL 中已经废弃所以不过多讨论了。 行锁开销大，锁表慢 行锁高并发下可并行处理，性能更高 行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁 在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT 或者 ROLLBACK 的时候释放 事务处理1.A 事务执行以下代码但不提交12BEGIN;UPDATE stu SET sname = &apos;hdcms&apos; WHERE id=1; 2.B 事务执行以下代码，可以正常执行123BEGIN;update stu set sname = &apos;后盾人&apos; where id=3COMMIT; 3.但 B 事务更新与 A 事务相同的记录则无法操作，执行过程发生阻塞123BEGIN;UPDATE stu SET sname = &apos;hdcms&apos; WHERE id=1;... 4.当 A 执行执行COMMIT 提交后，解锁记录行这时 B 事务继续执行123...COMMIT;... 非索引阻塞使用非索引字段筛选时，将造成全表锁定即表级锁，应该避免这种情况发生，提升数据库的并发性能。1.事务 A 执行以下代码，因为sname字段没有添加索引，造成锁定整个表12BEGIN;UPDATE stu SET sname = &apos;hdcms&apos; WHERE sname =&apos;后盾人&apos;; 2.现在事务 B 更新任何一条记录都会造成阻塞，因为现在是表锁状态123BEGIN;update stu set sname = &apos;小明&apos; where id=1-- 阻塞中... 3.将 sname字段添加索引后，行锁功能就又有效了 范围锁查询没有指定明确范围时也会造成大量记录的锁定1.事务 A 筛选时使用了范围区间，将会造成表锁12BEGIN;UPDATE goods SET num=200 WHERE id&gt;1 AND id&lt;3; 2.事务 B 将不能修改表中的 ID 大于 2 的记录123BEGIN;update goods set num =1 where id=2;-- 阻塞中... 但可以更改 ID 为 1 的记录1update goods set num =1 where id=1; 3.执行添加时因为不在 id 为 1~3 的范围内所以可以添加，但如果添加时指定 ID 为 2 将会阻塞。1insert into goods (name,num) values(&apos;西瓜&apos;,200); 悲观锁非观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。 下面演示商城下单情况，要用户购买商品后我们要减少库存，如果在高并发情况下多个用户同时修改库存表，会造成库存数据异常，使用悲观锁可以解决这个问题。1.事务 A 执行悲观锁操作后，其他事务执行同一代码时将阻塞1234BEGIN;SELECT * FROM goods WHERE id=1 FOR UPDATE;UPDATE goods SET num=num-2 WHERE id=1;... 2.事务 B 执行以下代码将不能查询库存，必须等事务 A 提交或回滚事务1234BEGIN;## B事务中查询中也要使用 FOR UPDATE 悲观锁SELECT * FROM goods WHERE id=1 FOR UPDATE;-- 阻塞中... 3.事务 A 提交后，事务 B 会得到事务 A 操作后的结果123...COMMIT;... 乐观锁在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。 下面使用版本字段来实现乐观锁操作，并实现更改商品库存的案例。1.事务 A 查询商品库存，获取了商品记录，记录中有 VERSION 字段用于记录版本号（目前为 0）12BEGIN;SELECT * FROM goods WHERE id = 1; 2.事务 B 同时查询，也获取了版本号为 0 的记录12BEGIN;SELECT * FROM goods WHERE id = 1; 3.事务 A 更改库存，并增加版本号1UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0; 4.事务 B 更改数据，但使用的是事务 B 查询到的 0 号版本，因为事务 A 已经提交版本号为 1，造成事务 B 修改失败，保证了数据的完整性。1UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0; 表锁机制针对一些不支持事务的处理引擎可以使用锁表的方式控制业务。 读锁为表设置读锁后，当前会话和其他会话都不可以修改数据，但可以读取表数据。1.会话 A 对表 goods 设置了读锁，将不能修改该表，也不能操作其他表123LOCK TABLE goods READ;UPDATE goods SET num=300 WHERE id=1;SELECT * FROM stu; 2.因为会话 A 对表goods设置了读锁，所以会话 B 也不能修改12update goods set num=200 where id=1;-- 阻塞 3.会话 A 解锁表后，其他会话又可以继续操作表了1UNLOCK TABLES; 写锁为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。1.会话 A 对表 goods 和 stu 设置写锁，本会话可以正常操作表， 并不能操作其他表12LOCK TABLE goods WRITE，stu WRITE;INSERT INTO goods (name,num )VALUES(&apos;后盾人教程&apos;,300); 2.会话 B 读取/写入表数据都将阻塞1select * from goods 3.会话 A 解锁表数据后，其他会话都可以正常操作了1UNLOCK TABLES;","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(八)","slug":"MYSQL-八","date":"2023-04-06T08:13:44.000Z","updated":"2024-01-11T07:00:59.133Z","comments":true,"path":"2023/04/06/MYSQL-八/","link":"","permalink":"/2023/04/06/MYSQL-八/","excerpt":"mysql学习笔记整理-事务处理","text":"mysql学习笔记整理-事务处理 事务处理事务是保证多个 SQL 操作的一致性，如果一条失败全部 SQL 也将失效。 学习事务时建议开启两个客户端（或 GUI 软件如 Dbeaver、SequelPro）来体验 业务分析 事务是保证多个 SQL 操作的一致性，如果一条失败全部 SQL 也将失效。 实际业务中大多数是对多个表操作，比如当发表文章时需要将文章的基本信息发到文章基础表和文章内容添加到文章内容表，这种情况不使用事务也没有关系，如果出现数据异常重新添加就可以了 但牵涉到货币的情况就必须使用事务了，必须保证货币处理是准确的 当然有些公司要求所有查询都使用事务，这就遵照公司要求完成就可以了 储存引擎查看引擎1SHOW ENGINES; 最新版本的 Mysql 中已经不建议使用 MyISAM引擎了，所以我们也不用讨论它了。InnoDB支持事务的引擎建议使用 InnoDB。如果旧表是其他引擎，使用下面语句更改为InnoDB引擎。1ALTER TABLE stu ENGINE=InnoDB; 提交模式自动提交Mysql 的提交默认是自动提交，即发送一条执行一条。在 DBeaver 执行以下 SQL 后，在另一个 Sequel Pro 会立刻看到结果。1INSERT INTO stu (class_id,sname,sex)VALUES(2,&apos;张帝&apos;,&apos;女&apos;); 在 Sequel Pro 里即可看到结果，这为自动提交。 事务提交事务单独开启执行 START TRANSACTION 或 BEGIN 语句后，表示要开启一项事务处理。 COMMIT 提交事务 ROLLBACK 回滚事务 123START TRANSACTION;INSERT INTO stu (class_id,sname,sex)VALUES(2,&apos;张帝&apos;,&apos;女&apos;);COMMIT; 全局开启事务如果所有 SQL 都使用事务操作，我们可以通过 SET AUTOCOMMIT=0 关闭自动提交来开启事务机制，这样所有语句都是事务类型。12345678-- 关闭自动提交SET AUTOCOMMIT = 0;INSERT INTO stu (class_id,sname,sex)VALUES(2,&apos;李清&apos;,&apos;女&apos;);COMMIT;-- 开启自动提交SET AUTOCOMMIT = 1; 事务隔离并发问题当高并发访问会遇到多个事务的隔离问题，可能会出现以下： 脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。 幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 隔离级别 事务隔离级别 脏读 不可重复读 幻读 说明 读未提交（read-uncommitted） 是 是 是 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 不可重复读（read-committed） 否 是 是 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 可重复读（repeatable-read） 否 否 是 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 串行化（serializable） 否 否 否 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。 查询级别mysql8 版本查询隔离级别1select @@global.transaction_isolation,@@transaction_isolation; mysql8 以下版本查询隔离级别1select @@tx_isolation; 设置级别设置会话隔离级别，影响当前连接1set session transaction isolation level read uncommitted; 设置全局隔离级别，影响全局连接1set global transaction isolation level read uncommitted; 脏读为了演示效果将隔离级别设置为最低级 read uncommitted。脏读是一个事务没有提交时可被其他事务读取到。1.事务 A 执行更新操作123set session transaction isolation level read UNCOMMITTED;BEGIN;UPDATE stu SET sname = &apos;后盾人&apos; WHERE id=1; 2.因为使用了最低级别read uncommitted，事务 B 在事务 A 没有提交时就可以看到更新的数据，如果事务 A 执行ROLLBACK 事务 B 的读到的数据就为脏数据。123SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;BEGIN;SELECT * FROM `stu`; 3.将隔离级别设置为除 read uncommitted 以外的，再重复上面的例子，都可以有效避免脏读的问题。 不可重复读不可重复读指在事务中多次读取的数据出现不一致的情况，我们希望读取的数据在本事务中是一致的。 事务 A 在执行过程中更新数据，事务 B 同时读取的数据没有脏数据。 但当事务 A 提交了事务后，事务 B 再读取时得到了最新的数据，这种情况为不可重复读。 所以要保证事务过程中的数据重复操作是一致的，不受其他事务影响，即避免不可重复读的产生。 为了演示效果将隔离级别设置为低级别 read committed。1.事务 A 执行以下代码，但没有提交123set session transaction isolation level READ COMMITTED;BEGIN;UPDATE stu SET sname = &apos;后盾人9&apos; WHERE id=1; 2.因为使用了 read committed级别，所以事务 B 不会读到脏数据123SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;BEGIN;SELECT * FROM stu; 3.事务 A 提交事务123...commit... 4.此时事务 B 可以读取到事务 A 提交的数据，这就是不能重复读取到同一个数据，即事务 B 读取结果受事务 A 影响。5.将隔离机制设置为 REPEATABLE READ 就可以解决这类不可重复读的问题。 幻读幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。1.事务 A 执行查询，假如查询结果是 6 条123set session transaction isolation level REPEATABLE READ;BEGIN;SELECT * FROM stu; 2.事务 B 执行添加123set session transaction isolation level REPEATABLE READ;insert into stu (class_id,sname,sex) values(2,&apos;后盾人&apos;,1);commit; 3.事务 A 执行更新，发现更新了 7 条（刚才查询时 6 条，但更新了七条，感觉像出现了幻觉）123...UPDATE stu SET balance = 200;... 4.切换隔离级别为 SERIALIZABLE 后，在事务 A 没有提交时，事务 B 是不能插入数据的（表现形式为等待）。123set session transaction isolation level SERIALIZABLE;select @@global.transaction_isolation,@@transaction_isolation; 程序控制程序语言基本上都支持事务的处理。123456789101112131415161718192021222324252627282930313233343536&lt;?phpheader(&quot;Content-type:text/html;charset=utf8&quot;);try &#123; $config = [ &apos;host&apos; =&gt; &apos;127.0.0.1&apos;, &apos;user&apos; =&gt; &apos;root&apos;, &apos;password&apos; =&gt; &apos;root&apos;, &apos;database&apos; =&gt; &apos;test&apos;, &apos;charset&apos; =&gt; &apos;utf8&apos; ]; $dsn = sprintf( &quot;mysql:host=%s;dbname=%s;charset=%s&quot;, $config[&apos;host&apos;], $config[&apos;database&apos;], $config[&apos;charset&apos;] ); $pdo = new PDO($dsn, $config[&apos;user&apos;], $config[&apos;password&apos;]); $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&#125; catch (PDOException $e) &#123; die($e-&gt;getMessage());&#125;try &#123; # 开启事务 $pdo-&gt;beginTransaction(); $d = $pdo-&gt;exec(&quot;INSERT INTO stu (class_id,sname,sex) VALUES(2,&apos;后盾人&apos;,&apos;男&apos;)&quot;); $pdo-&gt;exec(&quot;UPDATE class SET stu_count = (SELECT count(*) FROM stu WHERE class_id=2) WHERE id=2&quot;); # 提交事务 $pdo-&gt;commit();&#125; catch (PDOException $e) &#123; # 事务回滚 $pdo-&gt;rollBack(); die(&quot;Exception:&quot; . $e-&gt;getMessage());&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(七)","slug":"MYSQL-七","date":"2023-04-06T08:13:35.000Z","updated":"2024-01-11T07:00:59.132Z","comments":true,"path":"2023/04/06/MYSQL-七/","link":"","permalink":"/2023/04/06/MYSQL-七/","excerpt":"mysql学习笔记整理-多表攻略","text":"mysql学习笔记整理-多表攻略 多表攻略前面我们学习了 sql 语句的操作，但是我们大部分都是操作的单张表，大部分问题只有一张表是不能解决的。我们需要从多张表中获得数据，或者通过其他表的数据删除某个表的记录等操作，这个时候就需要多表操作。 表关联一对一比如说会员表与个人资料（QQ，邮箱）表即为一对一关系。一对多比如学生与班级表间即为一对多关系，一个班级有多个学生，一个学生属于一个班级。多对多粉丝表与用户表关系，一个粉丝可以关注多个用户，一个用户也可以有多个粉丝，像这种关系我们会使用一张中间表来记录关系。 笛卡尔积多个表的连接将会得到所有可能出现的行，即没有明确这两个表间的关联条件时，所有记录都将符合。1SELECT * FROM stu ,class; 下面是添加条件后的结果1SELECT * FROM stu ,class WHERE stu.class_id = class.id; JOIN所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。 INNER JOIN获取用户的资料信息12SELECT * FROM stu AS s INNER JOIN user_info as iON s.id = i.stu_id; 使用INNER JOIN 使用多表关联的语义更清晰12SELECT * FROM stu INNER JOIN classON stu.class_id = class.id; 查询一班的所有同学123SELECT * FROM stu INNER JOIN classON stu.class_id = class.idWHERE class.id = 1; 为了性能和多表字段重名覆盖的问题，有必要在查询时明确获取的列123SELECT sname,class_id,stu.id as stu_id,sex,cname FROM stu INNER JOIN classON stu.class_id = class.idWHERE class.id = 1; 每个班级发表的文章数量，来操作多张表的关联操作12345SELECT c.id ,count(*) FROM stu as sINNER JOIN class as cINNER JOIN article as aON s.class_id = c.id AND s.id = a.stu_idGROUP BY c.id; 一班的所有女生发表的文章12345SELECT c.id,a.title FROM stu as sINNER JOIN class as cINNER JOIN article as aON s.class_id = c.id AND s.id = a.stu_idWHERE c.id=1 AND s.sex = &apos;女&apos;; 每个班级发表的文章总数12345SELECT count(a.id) as article_sum,c.id FROM stu as sINNER JOIN class as cINNER JOIN article as aON s.class_id = c.id AND s.id = a.stu_idGROUP BY c.id; 哪个班级发表的文章超过两篇123456SELECT c.id,count(*) as total FROM stu as sINNER JOIN class as cINNER join article as aON s.class_id = c.id AND s.id = a.stu_idGROUP BY c.idHAVING total &gt;=2; 每个班级文章的总点击数与平均点击数123456SELECT sum(a.click) as class_sum,avg(a.click),c.id FROM stu as sINNER JOIN class as cINNER JOIN article as aON s.class_id = c.id AND s.id = a.stu_idGROUP BY c.idORDER BY class_sum DESC; 每个班级有多少同学123SELECT count(*),c.cname FROM stu as s INNER JOIN class as cON s.class_id = c.idGROUP BY c.id; 学生人数大于两个的班级名称1234SELECT count(*) as total,c.cname FROM stu as s INNER JOIN class as cON s.class_id = c.idGROUP BY c.cnameHAVING total&gt;=2; OUTER JOIN外链接包括LEFT JOIN 与 RIGHT JOIN ，可以简单理解为 LEFT JOIN会包含左侧所有表记录，RIGHT JOIN 会包含右侧表全部记录。 获取没有设置 QQ 的用户123SELECT s.sname FROM stu AS s LEFT JOIN user_info as iON s.id = i.stu_idWHERE i.qq is null; 查找所有没有发表文章的同学123SELECT s.id,s.sname FROM stu as s LEFT JOIN article as aON s.id = a.stu_idWHERE a.id IS NULL; 哪个班级没有学生123SELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as cON s.class_id = c.idWHERE s.id IS NULL; 每个班级的平均年龄1234SELECT c.cname,avg(timestampdiff(year,s.birthday,now())) as tFROM stu as s INNER JOIN class as cON s.class_id = c.idGROUP BY c.cname; 查找学生所在班级，没有班级的学生显示无12SELECT sname,ifnull(s.class_id,&apos;无&apos;) FROM stu AS s LEFT JOIN class AS cON s.class_id = c.id; SELF JOINSELF JOIN为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。查找后盾人的同班同学使用子查询操作123SELECT * FROM stu WHERE class_id =(SELECT class_id FROM stu WHERE sname = &apos;后盾人&apos;)AND stu.sname !=&apos;后盾人&apos;; 使用自连接查询1234SELECT s1.sname,s2.sname FROM stu as s1INNER JOIN stu as s2ON s1.class_id = s2.class_idWHERE s1.sname = &apos;后盾人&apos; AND s2.sname !=&apos;后盾人&apos;; 查找与后盾人同年出生的同学123SELECT s2.* FROM stu as s1 INNER JOIN stu AS s2ON year(s1.birthday) = year(s2.birthday)WHERE s1.sname =&apos;后盾人&apos; AND s2.sname !=&apos;后盾人&apos;; 查找比后盾人大的同学1234SELECT s2.sname,s2.birthday FROM stu AS s1INNER JOIN stu AS s2ON year(s1.birthday)&gt;year(s2.birthday)WHERE s1.sname = &apos;后盾人&apos;; 多对多比如学生可以学习多个课程，一个课程也可以被多个学生学习，这种情况就是多对多的关系。需要创建一张中间表来把这种关系联系起来。查找后盾人学习的课程123456SELECT sname,l.name FROM stu AS sINNER JOIN user_lesson AS ulON s.id = ul.stu_idINNER JOIN lesson AS lON ul.lesson_id = l.idWHERE s.sname = &apos;后盾人&apos;; 哪个班级的同学最爱学习 PHP12345678910SELECT c.cname,count(*) AS total FROM stu AS sINNER JOIN user_lesson AS ulINNER JOIN lesson AS lON s.id = ul.stu_id AND ul.lesson_id = l.idINNER JOIN class AS cON c.id = s.class_idWHERE l.name=&apos;php&apos;GROUP BY c.cnameORDER by totalLIMIT 1; UNIONUNION 用于连接多个查询结果，要保证每个查询返回的列的数量与顺序要一样。 UNION 会过滤重复的结果 UNION ALL 不过滤重复结果 列表字段由是第一个查询的字段 查询年龄最大与最小的同学1234(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)UNION(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)ORDER BY birthday DESC; 最新发表的文章和学习的课程组成动态数据12345678910(SELECT CONCAT(s.sname,&apos;发表了文章：&apos;,a.title) from article as aINNER JOIN stu as sON s.id = a.stu_idLIMIT 2)UNION(SELECT CONCAT(s.sname,&apos;正在学习：&apos;,l.name) FROM stu AS sINNER JOIN user_lesson as ulINNER JOIN lesson as lON s.id = ul.stu_id AND ul.lesson_id = l.idLIMIT 2); 多表删除删除所有没有学习任何课程的同学1234DELETE s FROM stu as sLEFT JOIN user_lesson as ulON s.id = ul.stu_idWHERE ul.lesson_id IS NULL; 使用子查询操作12345678DELETE FROM stu WHERE id IN( SELECT id FROM (SELECT s.id FROM stu as s LEFT JOIN user_lesson as ul ON s.id = ul.stu_id WHERE ul.lesson_id IS NULL) AS s); ExistsExists与NOT EXISTS都是通过子查询来决定是否返回结果，下面是是语法介绍1SELECT * FROM h1 WHERE [conditions] AND EXISTS(SELECT * FROM h2) 说明如下： EXISTS最终返回 true或false 外层查询会将每条结果传递给子查询，用于进行exists判断 如果子查询有结果，则外层查询的这条记录返回 NOT EXISTS是EXISTS的反函数 哪些学习已经在学习课程1select * from stu s where exists(select * from stu_lesson sl where s.id=sl.stu_id); 哪些学生没有课程1select * from stu s where not exists(select * from stu_lesson sl where s.id=sl.stu_id); 学习的课程数量&gt;=2个的学生1select * from stu s where exists(select id from stu_lesson sl where s.id=sl.stu_id group by id HAVING count(*)&gt;=2); 性别是男生并且设置了QQ号的同学12select * from stu s where s.sex=&apos;男&apos; and exists(select * from stu_info si where s.id=si.stu_id and si.qq is not null );","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(六)","slug":"MYSQL-六","date":"2023-04-06T08:13:23.000Z","updated":"2024-01-11T07:00:59.135Z","comments":true,"path":"2023/04/06/MYSQL-六/","link":"","permalink":"/2023/04/06/MYSQL-六/","excerpt":"mysql学习笔记整理-排序聚合分组","text":"mysql学习笔记整理-排序聚合分组 排序聚合分组ORDER排序介绍mysql 对查询结果使用order by 进行排序 对任何字段进行排序 desc 降序 asc 升序 对别名字段可排序 对函数结果可排序 支持多列表排序 排序受校对规则影响（请查看其他章节课程了解校对规则） 排序实例从男到女排序1SELECT * FROM stu ORDER BY sex ASC; 从男到女排序年龄从小到大排序1SELECT * FROM stu ORDER BY sex ASC,birthday DESC; 随机获取学生1SELECT * FROM stu ORDER BY RAND() LIMIT 1; 按出生月份从小到大排序1234SELECT birthday,MONTH(birthday) as m FROM stu ORDER BY m ASC;# 或使用字符串函数操作SELECT birthday,mid(birthday,6,2) as m FROM stu ORDER BY m ASC; 自定义排序field 函数用于比较值在集合中的索引，利用这一特性可以自定义排序12SELECT FIELD(&apos;a&apos;,&apos;c&apos;,&apos;a&apos;,&apos;b&apos;);# 第一个a 为比较字符，后面的 c/a/b为集合，所以结果为2，如果在集合中不存在为0 使用 field 进行自定义排序1SELECT * FROM stu ORDER BY FIELD(left(sname,1),&apos;何&apos;,&apos;赵&apos;); COUNT统计所有学生人数1SELECT COUNT(*) FROM stu; 所有女生人数1SELECT COUNT(*) FROM stu WHERE sex=2; 统计所有分配班级的学生（count(字段)不会统计 null 值，使用 count(*)时会计算 null），所以下面使用具体的字段1SELECT COUNT(class_id) FROM stu; MIN/MAX获取最小的学生出生年份1SELECT year(max(birthday)) from stu; 最大的班级编号1SELECT max(class_id) FROM stu; 获取点击数最少的文章1SELECT * FROM article WHERE click = (SELECT MIN(click) FROM article); SUM/AVG获取所有文章总点击数1SELECT SUM(click) FROM article; 获取平均点击数1SELECT AVG(click) FROM article; 获取低于平均点击数据的文章1SELECT * FROM article WHERE click &lt; (SELECT AVG(click) FROM article); 获取学生的平均年龄1SELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now()))) FROM stu ; DISTINCTdistinct 用于去除结果集中的重复记录 获取所有班级编号1SELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL; 获取学生数，同班同名的算一个1SELECT COUNT(DISTINCT class_id,sname) FROM stu WHERE class_id IS NOT NULL; 获取班级平均人数，去掉重复的数值1SELECT DISTINCT (count(id)) AS c FROM users GROUP BY class_id GROUP统计受 ONLY_FULL_GROUP_BY 模式影响，有关 ONLY_FULL_GROUP_BY 的详细讨论请查看 「运行模式」章节。 统计每个班级的人数1SELECT COUNT(*),class_id FROM stu WHERE class_id IS NOT NULL GROUP BY class_id ; 每个班年龄最大的同学 结果中要求出现班级编号和学生姓名，如果 GROUP BY 中只有班级编号字段，默认运行模式下 SELECT 中不能出现学生姓名。 MYSQL 默认使用 ONLY_FULL_GROUP_BY 模式要求 select 中的列要在 group 中使用。有多种方式可以处理这个问题 可以通过更改查询模式，允许 select 的列不在 group 中出现 使用聚合函数 使用 any_value 函数处理 GROUP BY 中使用 PRIMAY KEY 或 UNIQUE NOT NULL 字段 有关 ONLY_FULL_GROUP_BY 模式已经在「运行模式」章节讨论过 直接查询将产生错误，因为 sname 不是 GROUP BY 使用的字段1SELECT min(birthday),sname FROM stu GROUP BY class_id; 使用聚合函数解决这个问题1SELECT min(birthday),min(sname) FROM stu GROUP BY class_id; 使用 any_value 函数解决1SELECT min(birthday),any_value(sname) FROM stu GROUP BY class_id; 也可以使用子查询12SELECT * FROM stu where birthday IN(SELECT min(birthday) FROM stu GROUP BY class_id); 或使用聚合函数1SELECT min(birthday),min(sname) FROM stu GROUP BY class_id; 也可以更改查询模式，去掉 ONLY_FULL_GROUP_BY 模式的方式解决。 很多后台程序框架提供配置项用于禁止 ONLY_FULL_GROUP_BY 模式 123SET sql_mode=&apos;&apos;SELECT min(birthday),sname FROM stu GROUP BY class_id; 统计每班的男、女人数1234SELECT concat(class_id,&apos;班&apos;),if(sex=1,&apos;男&apos;,&apos;女&apos;) as sex,count(*) FROM stuWHERE class_id IS NOT NULLGROUP BY class_id,sex ORDER BY class_id; 查找超过两个同学的班级1SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2; 查找本周迟到超过两次的同学12345SELECT stu_id FROM attendanceWHERE date(created_at)&gt;date(DATE_ADD(NOW(),INTERVAL 0-WEEKDAY(NOW()) day))AND time(created_at)&gt;&apos;08:30:00&apos;GROUP BY stu_idHAVING COUNT(*)&gt;2; 本周哪个同学准时到校次数最多123456SELECT count(*) as c,stu_id FROM attendanceWHERE date(created_at)&gt;=date(date_add(now(),interval 0-WEEKDAY(now()) day))AND time(created_at)&lt;=&apos;08:30:00&apos;GROUP BY stu_idORDER by c desclimit 1; 本周哪一天迟到的人数最少123456SELECT date(created_at) FROM attendanceWHERE date(created_at)&gt;date(DATE_ADD(NOW(),INTERVAL 0-WEEKDAY(NOW()) day))AND time(created_at)&lt;=&apos;08:30:00&apos;GROUP BY created_atORDER BY COUNT(*) DESCLIMIT 1; 查找哪个姓的同学最多1234SELECT left(sname,1) as s,count(*) AS c FROM stuGROUP BY sORDER BY c DESCLIMIT 1; 查找超过两个同学的姓氏123SELECT left(sname,1) as s,count(*) AS c FROM stuGROUP BY sHAVING c&gt;=2;","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(五)","slug":"MYSQL-五","date":"2023-04-06T08:13:06.000Z","updated":"2024-01-11T07:00:59.133Z","comments":true,"path":"2023/04/06/MYSQL-五/","link":"","permalink":"/2023/04/06/MYSQL-五/","excerpt":"mysql学习笔记整理-运行模式","text":"mysql学习笔记整理-运行模式 运行模式 MYSQL 运行时可以使用不同的模式，这是很多语言中都有的特性比如 JS/PHP 等。在 MYSQL5.7 前 SQL 运行在宽松模式，会以开放不严谨的方式运行。在 5.7 后默认运行模式较为严格，这会造成在升级数据库时，数据库的操作出现问题。所以有必要理解 MYSQL 的运行模式机制。 模式说明查看当前运行模式1SELECT @@sql_mode 模式选项不同运行模式即对不同模式选项的配置，下面是常用的模式选项 选项 说明 ONLY_FULL_GROUP_BY 结果中的字段需要在 GROUP BY 中出现 STRICT_TRANS_TABLES 如果一个值不能插入到一个事务表中，则中断当前的操作 NO_ZERO_IN_DATE 不能插入为 0 的日期和月份 NO_ZERO_DATE 不能添加 0000-00-00 格式的日期 ERROR_FOR_DIVISION_BY_ZERO 除数不能为零，禁止该模式后插入的结果为 NULL 常用模式常用模式是系统将不同的模式选项过行的组合 模式 说明 ANSI 宽松模式：对长度超过字段定义等错误进行截取等操作。报 WARNING 警告错误 TRADITIONAL 严格模式：对数据进行严格校验。事务处理中会进行事务回滚操作。非事务时，发生错误时就立即报错终止，会造成有部分数据插入。 设置当前会话为宽松模式123set session sql_mode=ANSI;# 或SET sql_mode = ANSI 设置全局模式限制1SET GLOBAL sql_mode=&apos;&apos;; 设置为严格模式1set session sql_mode=TRADITIONAL; 对比分析我们来看下在不同模式下的表现，首先宽松模式可以插入’0000-00-00’的日期格式123SET sql_mode = ANSIINSERT INTO stu SET birthday = &apos;0000-00-00&apos; 当使用严格模式时将不可以插入123set sql_mode=TRADITIONAL;INSERT INTO stu SET birthday = &apos;0000-00-00&apos; 内容超过字段长度时宽松模式会过行截断并可以正常插入，下面的字段 rank 使用的是 smallint123SET sql_mode = ANSIINSERT INTO article SET rank =1000000; 当改为严格模式时不能插入数据会报错123set sql_mode=TRADITIONAL;INSERT INTO article SET rank =1000000; ONLY_FULL_GROUP_BYONLY_FULL_GROUP_BY 要求 SELECT 中的字段是在与 GROUP BY 中使用的字段 如果 GROUP BY 是主键或 UNIQUE NOT NULL 时可以在 SELECT 中列出其他字段 使用 max/min/avg/count 等聚合函数时不受 ONLY_FULL_GROUP_BY 模式影响 问题分析下面获取男生和女生的人 下面的班级编号 class_id 是男/女两个组中的，这个值是不确定的也是无意义的 使用 ONLY_FULL_GROUP_BY 模式后将报错 1SELECT class_id,count(*) AS c FROM stu u GROUP BY sex 去除 ONLY_FULL_GROUP_BY 模式后可以读到 class_id ，但针对这个 SQL 来讲 class_id 结果是不确定的也是无意义的123SELECT @@sql_modeSELECT class_id,count(*) AS c FROM stu u GROUP BY sex any_value有些情况下确实要取到非 GROUP BY 中的字段，使用 any_value 函数可以从组中读取第一个值，解决使用 ONLY_FULL_GROUP_BY 报错的问题any_value 会读取使用 group by 分组后的每组中第一个数据123SET sql_mode = &apos;ONLY_FULL_GROUP_BY,TRADITIONAL&apos;SELECT any_value(class_id),count(*) AS c FROM stu u GROUP BY sex; 聚合函数在 SELECT 中使用 max/min/avg/count 等聚合函数时不受 ONLY_FULL_GROUP_BY 模式影响123SET sql_mode = &apos;ONLY_FULL_GROUP_BY,TRADITIONAL&apos;SELECT max(class_id),count(*) AS c FROM stu u GROUP BY sex primary/uniqueGROUP BY 使用主键或 unique not null 字段时，不受 ONLY_FULL_GROUP_BY 的约束。下面是获取每班的人数的示例1234SELECT c.id,c.cname,count(*) FROM stu uINNER JOIN class cON c.id = u.class_idGROUP BY c.id;","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(四)","slug":"MYSQL-四","date":"2023-04-06T08:12:59.000Z","updated":"2024-01-11T07:00:59.143Z","comments":true,"path":"2023/04/06/MYSQL-四/","link":"","permalink":"/2023/04/06/MYSQL-四/","excerpt":"mysql学习笔记整理-日期时间","text":"mysql学习笔记整理-日期时间 日期时间DBeaver如果使用 DBeaver 软件学习，需要在编辑连接设置正确时区。使用命令设置时区设置会话时区，每次连接会话需要重新设置1set time_zone = &apos;+8:00&apos; 全局时区设置12set global time_zone = &apos;+8:00&apos;;flush privileges; 数据类型 日期时间类型 占用空间 日期格式 最小值 最大值 零值表示 DATETIME 8 bytes YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 TIMESTAMP 4 bytes YYYY-MM-DD HH:MM:SS 1970-01-01 08:00:01 2038-01-19 03:14:07 00000000000000 DATE 4 bytes YYYY-MM-DD 1000-01-01 9999-12-31 0000-00-00 TIME 3 bytes HH:MM:SS -838:59:59 838:59:59 00:00:00 YEAR 1 bytes YYYY 1901 2155 0000 Mysql 保存日期格式使用 YYYY-MM-DD HH:MM:SS 的 ISO 8601 标准 向数据表储存日期与时间必须使用 ISO 格式 创建字段1ALTER TABLE stu ADD birthday datetime default null; 格式化参数介绍 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 实例操作使用Date_format格式化日期与时间显示1select sname,DATE_FORMAT(birthday,&apos;%Y年%m月%d %H时%i分%s秒&apos;) as birthday from stu; 使用time_format格式化输出时间1select sname,TIME_FORMAT(birthday,&apos;%r&apos;) as birthday from stu; 时间戳以时间戳格式来记录日期与时间。设置 TIMESTAMP 字段1234ALTER TABLE stu ADD updated_atTIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;INSERT INTO stu SET sname = &apos;后盾人&apos;,updated_at = &apos;2020-2-12 10:33:12&apos;; 添加数据时自动更新时间123ALTER TABLE stu ADD updated_atTIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMPON UPDATE CURRENT_TIMESTAMP; 当执行添加与更新时字段将自动为当前时间12insert into stu set sname = &apos;小张&apos;;update stu set sname = &apos;ih&apos; where id= 7; 执行更新或添加都会改变 timestamp 字段 常用函数下面是获取当前日期、时间的示例1select CURRENT_DATE,CURRENT_TIME,NOW(); 获取时间部分值1select YEAR(updated_at),MONTH(updated_at),DAY(updated_at) from stu; 其他可以使用的函数如下 函数 说明 HOUR 时（范围从 0 到 23） MINUTE 分（范围从 0 到 59） SECOND 秒（范围从 0 到 59） YEAR 年（范围从 1000 到 9999） MONTH 月（范围从 1 到 12） DAY 日（范围从 1 开始） TIME 获取时间 WEEK 一年中的第几周，从 1 开始计数 QUARTER 一年中的季度，从 1 开始计数 CURRENT_DATE 当前日期 CURRENT_TIME 当前时间 NOW 当前时间 DAYOFYEAR 一年中的第几天（从 1 开始） DAYOFMONTH 月份中天数（从 1 开始） DAYOFWEEK 星期天（1）到星期六（7） WEEKDAY 星期一（0）到星期天（6） TO_DAYS 从元年到现在的天数（忽略时间部分） FROM_DAYS 根据天数得到日期（忽略时间部分） TIME_TO_SEC 时间转为秒数（忽略日期部分） SEC_TO_TIME 根据秒数转为时间（忽略日期部分） UNIX_TIMESTAMP 根据日期返回秒数（包括日期与时间） FROM_UNIXTIME 根据秒数返回日期与时间（包括日期与时间） DATEDIFF 两个日期相差的天数（忽略时间部分，前面日期减后面日期） TIMEDIFF 计算两个时间的间隔（忽略日期部分） TIMESTAMPDIFF 根据指定单位计算两个日期时间的间隔（包括日期与时间） LAST_DAY 该月的最后一天 拆分日期时间123select sname,YEAR(birthday),MONTH(birthday),DAY(birthday),HOUR(birthday),MINUTE(birthday),SECOND(birthday) from stu; 当前日期时间1SELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW(); 时间计算1SELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now()); 秒转换不包含日期的秒转换12SET @time = time(now());SELECT now(),TIME_TO_SEC(@time),SEC_TO_TIME(TIME_TO_SEC(@time)); 日期时间与秒转换1SELECT now(),UNIX_TIMESTAMP(birthday),FROM_UNIXTIME(UNIX_TIMESTAMP(birthday)) FROM stu; 天转换1SELECT now(),TO_DAYS(birthday),FROM_DAYS(TO_DAYS(birthday)) FROM stu; 差值计算计算天数差值，忽略时间部分1SELECT now(),DATEDIFF(now(),birthday) from stu; 计算时间差值，忽略天数1SELECT now(),TIMEDIFF(time(birthday),time(now())) from stu; 指定单位差值支持的单位有 YEAR/MONTH/WEEK/DAY/HOUR/MINUTE/SECOND 等。下面是获取学生来到人生经历的天数。1select sname,TIMESTAMPDIFF(day,birthday,NOW()) from stu; 基本查询MYSQL 内部将日期按数值进行处理，下面是查找’1990-02-22 09:00:00’ 日期可以写成数值形式1SELECT * FROM users WHERE birthday = 19900222090000 查找在 1990~1999 年出生的同学1SELECT * FROM stu WHERE birthday BETWEEN &apos;1990-01-01&apos; AND &apos;1999-12-31&apos;; 获取年龄最大的同学1234SELECT * FROM stu ORDER BY birthday ASC LIMIT 1;# 更准确的查询SELECT * FROM stuWHERE birthday =(SELECT birthday FROM stu ORDER BY birthday ASC LIMIT 1); 查询在 1 班或 2 班 1990 年出生的同学1SELECT * FROM stu WHERE class_id IN(1,2) AND year(birthday)=1999; 90 后最喜欢上的班级12345SELECT count(id) as total,class_id from stuWHERE LEFT(birthday,4) &gt;= 1990 AND YEAR(birthday)&lt;=2000GROUP BY class_idORDER BY total DESCLIMIT 1; 大于 20 岁的女生最多的班级12345SELECT count(id),class_id FROM stuWHERE TIMESTAMPDIFF(YEAR,birthday,now())&gt;20 AND sex=2GROUP BY class_idORDER BY count(id) DESCLIMIT 1; 时间计算 函数 说明 ADDTIME 添加时间（负数为减少），只对时间有效 TIMESTAMP 添加时间（负数为减少），只对时间有效 DATE_ADD 根据单位添加时间，支持单位有 YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE/DAY_HOUR/DAY_MINUTE/DAY_SECOND/HOUR_MINUTE/HOUR_SECOND（负数时等于 DATE_SUB) DATE_SUB DATE_ADD 的反函数 LAST_DAY 指定月最后一天日期 七小时前的时间1select ADDTIME(now(),&apos;-7:00:00&apos;) 七天后的日期1SELECT DATE_ADD(now(),INTERVAL 7 DAY); 20 小时 10 分钟后的日期1SELECT DATE_ADD(NOW(),INTERVAL &apos;20:10&apos; HOUR_MINUTE); 2 天 8 小时后的日期1SELECT DATE_ADD(NOW(),INTERVAL &apos;2 8&apos; DAY_HOUR); 获取本月最后一天日期1SELECT LAST_DAY(now()); 获取本月的第一天日期1SELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY); 获取本月发表的文章123SELECT * FROM articleWHERE created_at &gt;=DATE_SUB(now(),INTERVAL DAYOFMONTH(now()) DAY)AND created_at &lt;=LAST_DAY(now()); 因为使用大量函数会造成性能下降，所以推荐在后台程序中算出时间后再进行比对 获取三个月内发表的文章123456SELECT * FROM articleWHERE publish_time &gt;=DATE_SUB(now(),INTERVAL -3 MONTH) ;# 如果从前上个月的一号开始获取SELECT * from articleWHERE publish_time &gt;= DATE_FORMAT(DATE_SUB(now(),INTERVAL 3 MONTH),&apos;%Y-%m-01&apos;); 获取上个月的最后一天123SELECT LAST_DAY(DATE_SUB(NOW(),INTERVAL 1 MONTH));# 或直接通过明确日期SELECT * FROM article WHERE publish_time&gt;=&apos;2019-01-01&apos; AND publish_time&lt;CURDATE(); 下个月的第一天1SELECT DATE_ADD(LAST_DAY(NOW()),INTERVAL 1 DAY); 查看出生超过 20 年的同学1SELECT * FROM stu WHERE birthday &lt; DATE_SUB(NOW(),INTERVAL 20 YEAR); 本周二的日期，使用 DAYOFWEEK 时周二为 31SELECT now(),DATE_ADD(NOW(),INTERVAL 3-DAYOFWEEK(NOW()) DAY); 本周星期日123SELECT date_add(now(),INTERVAL 6-WEEKDAY(now()) DAY)SELECT date_add(now(),INTERVAL 1-DAYOFWEEK(now())+7 day) 上周的星期日1SELECT date_add(now(),INTERVAL 1-DAYOFWEEK(now()) day) 查看三周前的周二12345SELECT now(),DATE_SUB(DATE_ADD(NOW(),INTERVAL 3-DAYOFWEEK(NOW()) DAY),INTERVAL 21 DAY);# 或SELECT date_add(now(),INTERVAL 3-DAYOFWEEK(now())-21 DAY ) 上周一的日期12345SET @week = DATE_SUB(NOW(),interval 1 week);SELECT DATE_ADD(@week,INTERVAL 0-WEEKDAY(@week) day);#或SELECT date_add(now(),INTERVAL 2-DAYOFWEEK(now())-7 DAY ) 获取本月迟到的同学123select * from attendanceWHERE created_at &gt;= date_sub(NOW(),INTERVAL DAYOFMONTH(now())-1 DAY)AND time(created_at)&gt;&apos;08:30:00&apos;; 本月迟到超过 2 次的同学12345select stu_id from attendanceWHERE created_at &gt;= date_sub(NOW(),INTERVAL DAYOFMONTH(now())-1 DAY)AND time(created_at)&gt;&apos;08:30:00&apos;GROUP BY stu_idHAVING count(id)&gt;=2; 本周周一的日期1SELECT DATE_ADD(now(),INTERVAL 0-WEEKDAY(now()) day); 获取本周迟到的学生编号12345set @begin =DATE_FORMAT(date_add(now(),INTERVAL 0-WEEKDAY(now()) day),&apos;%Y-%m-%d&apos;);select stu_id from attendanceWHERE created_at &gt;= @beginAND time(created_at)&gt;&apos;08:00:00&apos;GROUP BY stu_id; 获取上周打卡记录1234set @week = DATE_SUB(now(),INTERVAL 1 WEEK);SELECT stu_id FROM attendanceWHERE created_at&gt;=DATE_ADD(@week,interval 0-WEEKDAY(@week) day)AND created_at&lt;=DATE_ADD(@week,interval 4-WEEKDAY(@week) day); 获取本周发表的文章1SELECT * FROM article WHERE created_at &gt;=DATE_ADD(now(),INTERVAL 0-WEEKDAY(now()) day); 周日来校学习的同学12SELECT * from attendanceWHERE date(created_at) = date(date_add(now(),INTERVAL 6 - WEEKDAY(now()) day));","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(三)","slug":"MYSQL-三","date":"2023-04-06T08:12:52.000Z","updated":"2024-01-11T07:00:59.132Z","comments":true,"path":"2023/04/06/MYSQL-三/","link":"","permalink":"/2023/04/06/MYSQL-三/","excerpt":"mysql学习笔记整理-数据类型","text":"mysql学习笔记整理-数据类型 数据类型字符串数据类型下面是 mysql 支持的字符串类型 类型 大小 用途 CHAR 0-255 字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255 字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 字节 短文本字符串 BLOB 0-65 535 字节 二进制形式的长文本数据 TEXT 0-65 535 字节 长文本数据 MEDIUMBLOB 0-16 777 215 字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 字节 中等长度文本数据 LONGBLOB 0-4 294 967 295 字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 字节 极大文本数据 char 类型是定长类型，比如定义了 20 长度的char类型，只存一个字符也占用 20 个长度，char 好处是处理速度快，缺点是空间占用大，把手机号、邮箱、密码等长度相对固定的设置为 char 类型是不错的选择。varchar 类型与 char 相反，点用空间受内容影响，可以把文章标题、介绍等设置为 varchar 类型更合适。 字符串字符串分二进制与非二进制类型，二进制用于储存图片、声音等文件，非二进制用于储存文本数据。非二进制文本受字符集和校对规则影响。 字符集字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同。常用的字符集有 GBK、BIG5、UTF8。UTF8 字符包含文字内容更广，如韩文、日文、德文兼容度更高，也是推荐使用的字符集。下面是查看服务器支持的字符集1SHOW CHARACTER SET; 表不设置字符集继承数据库，字段不设置字符集继承表的 校对规则是在字符集内用于字符比较和排序的一套规则，以_ci 结束的为大小写不敏感、_bin 结束的为区分大小写。下面是查看系统支持的校对规则1show COLLATION; 当使用不区分大小写的校对规则时 A 与 a 是相同的，否则则不相同，这会影响到排序与比对。如果使用utf8_bin 校对规则时，下面的查询将匹配不到大写的PHP1select * from class WHERE cname = &apos;php&apos;; 修改表校对规则，对表的原字段将不影响，只对新增字段影响。 常用函数大小写转换1SELECT UPPER(cname) as cname,LOWER(description) as `desc` from class; Left&amp;rightleft 与 right 函数用于取左或右指定数量的字符，下面是取班级介绍前 8 个字符并用… 连接。1SELECT CONCAT(LEFT(description,8),&apos;...&apos;) FROM class; mid从中间取字符串，参数二为起始，参数三为取的字符数量。下面是获取从第二个字符取两个字符值为hp的。1select * from class where mid(cname,2,2) = &apos;hp&apos;; substring从指定位置开始向右取所有字符串，下面是获取从第二个位置开始的字符值为hp的记录。1select * from class where SUBSTRING(cname,2) = &apos;hp&apos;; char_length获取字符串数量 concat连接字符串使用1SELECT concat(&apos;编号:&apos;,id) as id,concat(&apos;班级:&apos;,cname) as name FROM class; 将所有班级前加上后盾人1UPDATE class SET cname = CONCAT(&apos;后盾人:&apos;,cname); 截取班级介绍，超过 8 个字符的后面连接…123SELECTif(CHAR_LENGTH(description)&gt;8,CONCAT(LEFT(description,8),&apos;...&apos;),LEFT(description,8)) as nameFROM class; 正则表达式Mysql 支持正则表达式操作，可用于处理复杂的匹配操作。查找第二个字符为h的字符串1SELECT * FROM class WHERE cname REGEXP &apos;^.h&apos;; 查找班级名称中包含php 或 mysql的记录1SELECT * FROM class WHERE cname REGEXP &apos;php|mysql&apos;; 所有介绍中包含 php 与 mysql 的课程名前加上后盾人12update class set cname = REPLACE(cname,cname,concat(&apos;后盾人：&apos;,cname))where description REGEXP &apos;php|mysql&apos;; LIKE在 LIKE 表达式中 % 用于匹配任意多个字符，_ 用于匹配一个字符。查找第二个字符为 h 的班级。1SELECT * FROM class WHERE cname LIKE &apos;_h%&apos;; 数值类型整型 MySQL 数据类型 范围（有符号） 范围（无符号） tinyint(m) 1 个字节 范围(-128~127) (0，255) smallint(m) 2 个字节 范围(-32768~32767) (0，65 535) mediumint(m) 3 个字节 范围(-8388608~8388607) (0，16 777 215) int(m) 4 个字节 范围(-2147483648~2147483647) (0，4 294 967 295) bigint(m) 8 个字节 范围(+-9.22*10 的 18 次方) (0，18 446 744 073 709 551 615) 取值范围如果加了 unsigned，则最大值翻倍，如 tinyint unsigned 的取值范围为(0~256)。 m 的含义不是允许字段的长度，而是显示长度，在为字段设置 zerofill 时有效。 添加有前导零的字段1ALTER TABLE class ADD stu_count smallint(6) ZEROFILL default null; 在命令行查看（有些 GUI 软件不显示前导零)，结果如下：123456+----+-------+--------------------------------------------+-----------+| id | cname | description | stu_count |+----+-------+--------------------------------------------+-----------+| 4 | Mysql | 数据库 | 000001 || 5 | PHP | 后盾人教你使用PHP快速开发网站 | NULL |+----+-------+--------------------------------------------+-----------+ 浮点型 类型 大小 范围（有符号） 范围（无符号） FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) DECIMAL DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30 依赖于 M 和 D 的值 依赖于 M 和 D 的值 下面是检测浮点数精度的示例12alter table class add e FLOAT(10,2);update class set e = 12345678.66 where id=11; 查看结果时会发布浮点数结果不精确。 float：2^23 = 8388608，一共七位，这意味着最多能有 7 位有效数字，但绝对能保证的为 6 位，即 float 的精度为 6~7 位有效数字 double：2^52 = 4503599627370496，一共 16 位，double 的精度为 15~16 位 浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值 decimal(m,d) 参数 m&lt;65 是总个数，d&lt;30 且 d&lt;m 是小数位 对货币等对精度敏感的数据，应该用定点数 decimal 存储 ENUM/SETENUMENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。换个枚举最大可以有 65535 个成员值1ALTER TABLE stu ADD sex ENUM(&apos;男&apos;,&apos;女&apos;) DEFAULT NULL; 可以使用索引或值添加 enum 数据12INSERT INTO stu (sname,class_id,sex) VALUES(&apos;李岗&apos;,1,&apos;男&apos;);INSERT INTO stu (sname,class_id,sex) VALUES(&apos;李玉&apos;,1,2); 可以使用值与索引检索 ENUM12SELECT * from stu WHERE sex=&apos;女&apos;;SELECT * from stu WHERE sex=2; SETSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。一个 SET 类型最多可以包含 64 项元素。使用 SET 类型添加文章属性字段1ALTER TABLE article ADD flag SET(&apos;推荐&apos;,&apos;置顶&apos;,&apos;图文&apos;,&apos;热门&apos;); 添加数据1INSERT INTO article (title,status,flag)VALUES(&apos;后盾人&apos;,1,&apos;图文,推荐,置顶&apos;); 使用 find_in_set 查找数据1SELECT * FROM article WHERE find_in_set(&apos;图文&apos;,flag); 使用like 查找数据1SELECT * FROM article WHERE flag like &apos;%置顶%&apos; 二进制比较可以使用二进制方式对 SET 类型进行模糊筛选。 SET 成员 十进制值 二进制值 推荐 1 0001 置顶 2 0010 图文 4 0100 热门 8 1000 获取包含图文与推荐的文章1SELECT * FROM article WHERE flag &amp; 5;","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(二)","slug":"MYSQL-二","date":"2023-04-06T08:09:47.000Z","updated":"2024-01-11T07:00:59.133Z","comments":true,"path":"2023/04/06/MYSQL-二/","link":"","permalink":"/2023/04/06/MYSQL-二/","excerpt":"mysql学习笔记整理-表维护","text":"mysql学习笔记整理-表维护 表维护修改表修改表名1ALTER TABLE stu RENAME stus; 别一种操作方式1RENAME TABLE stus to stu; 修改表字符集1ALTER TABLE class charset gbk; 删除表所有数据1TRUNCATE stu; 删除数据表1DROP TABLE IF EXISTS stu; 字段管理修改字段类型1ALTER TABLE stu MODIFY sname char(30) not null; 修改字段时同时更改字段名1ALTER TABLE stu CHANGE sname name varchar(30) not null; 添加字段1ALTER TABLE stu ADD sex SMALLINT default null; 在学生名称后添加邮箱字段1ALTER TABLE stu ADD email varchar(50) AFTER sname; 将字段添加到最前面1ALTER TABLE stu ADD qq varchar(30) first; 删除学生邮箱字段1ALTER TABLE stu DROP email; 主键操作一般主键为自增字段，需要删除自增属性后才可以删除主键1ALTER TABLE stu MODIFY id int not null; 删除主键1ALTER TABLE stu DROP PRIMARY key; 添加表主键1ALTER table stu2 add PRIMARY KEY(id); 添加自增列1ALTER TABLE stu2 MODIFY id int not null AUTO_INCREMENT; 主键与自增列一起添加1ALTER table stu3 modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"MYSQL(一)","slug":"MYSQL-一","date":"2023-04-04T06:57:09.000Z","updated":"2024-01-11T07:00:59.132Z","comments":true,"path":"2023/04/04/MYSQL-一/","link":"","permalink":"/2023/04/04/MYSQL-一/","excerpt":"mysql学习笔记整理-基础操作","text":"mysql学习笔记整理-基础操作 基础操作连接服务器参数说明在命令行连接 mysql 的参数如下： 选项 说明 默认 -u 帐号 当前系统同名帐号 -p 密码 -P 连接端口 3306 -h 主机地址 127.0.0.1 -e 执行 sql 指令 连接操作连接服务器1mysql -uroot -p -P3306 -h 127.0.0.1 连接本地数据库时可以使用默认值1mysql -uroot -p 使用-e 执行 SQL 语句1mysql -uroot -proot -e&quot;show databases;&quot; 退出连接命令行下执行 exit 可通出当前连接1exit 执行与取消每条 SQL 指令以;结束，按回车键后执行该条语句。1show databases; 放弃语句在 SQL 后使用 \\c表示取消本条 SQL，后面不需要写 ;。1show databases \\c 数据库管理常用指令数据库列表使用以下命令可以得到当前服务器中的所有数据库。1show databases; 创建新库下面是创建数据库 houdunren 并设置字符集为 utf8。1CREATE DATABASE houdunren CHARSET utf8; 查看数据库1show create database houdunren; 删除数据库1drop database houdunren; 为了防止删除不存在的数据库报错1drop database if exists houdunren; 选择数据库数据库主要是对表操作，选择数据库后可以省掉每次指定数据库的麻烦。1use houdunren 导入语句有时需要把外部的 SQL 文件导入到服务器中，图像化的数据库管理软件都支持导入，下面我们介绍命令行的使用方法。创建文件下面我们创建 test.sql文件内容如下12create database hdcms charset utf8;SHOW DATABASES; 外部导入1mysql -uroot -p &lt; test.sql 连接后导入12mysql -uroot -p&gt; source test.sql 数据表管理可以把数据库理解为文件夹，数据表理解为文件，数据表是真正储存数据的地方。 基本操作创建数据表12345create table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL)charset utf8; 以上语句创建表 class 字段说明如下： 字段 id 为主键自增 字段 cname 为字符串类型 varchar 并不允许为 null 字段 description 为可为 null 字符串 字符集为 utf8 ，如果不设置将继承数据库字符集 添加测试数据12INSERT INTO class (cname,description) VALUES(&apos;PHP&apos;,&apos;后盾人教你使用PHP快速开发网站&apos;);INSERT INTO class (cname) VALUES(&apos;Mysql&apos;); 因为 description 设置为 null 所以第二个记录没有设置值时使用默认的 null 值。 复制数据根据已经存在的表结构创建新表1create table hdcms like class; 复制其他表的数据1insert into hdcms select * from class; 只复制批定字段1insert into hdcms (cname) select cname from class; 复制表时同时复制数据1create table hdjs select * from class; 下面是只复制指定字段，并为不同名字段起别名1create table hd (id int primary key AUTO_INCREMENT,name varchar(30)) select id,cname as name from class; 删除数据表1DROP TEMPORARY TABLE IF EXISTS hd; 临时表临时表是用于储存临时数据表表，会在数据库连接中断时自动删除。 可以与普通表同名，优先级高于普通表 连接终端时自动删除12create TEMPORARY TABLE class_names SELECT * from class;select * from class_names; 删除临时表1DROP TEMPORARY TABLE IF EXISTS class_names; 当然开发中我们更喜欢将临时数据放在缓存或会话中，以上只是介绍这个 mysql 特性。 查询数据测试表为了进行查询实例操作我们创建以下表123CREATE TABLE stu (id int PRIMARY KEY AUTO_INCREMENT,sname char(30),class_id int default null,age smallint default null)INSERT INTO stu(sname,class_id,age) VALUES(&apos;小明&apos;,1,20),(&apos;张三&apos;,2,32),(&apos;李四&apos;,3,null),(&apos;小刘&apos;,null,46); 字段处理查询所有字估数据1select * from class; 查询指定字段数据并排序字段1select description,cname from class; 条件筛选根据条件查询1select * from class where cname = &apos;php&apos; 查询包含关键词的数据1select * from class where description like &apos;%p%&apos;; 合并列返回查询结果1select CONCAT(id,cname) as &apos;class_info&apos; FROM class; 指定多条件查询1SELECT * FROM class where id&gt;1 and cname = &apos;php&apos; 查找一班或姓张的同学1select * from stu where class_id =1 or sname like &apos;%张%&apos; 介绍中不包含 php 的班级1SELECT * from class WHERE description NOT LIKE &apos;%php%&apos;; 查询学生所在班级编号，并去除重复值1SELECT DISTINCT class_id from stu ; 查询年龄在 20~35 岁的同学1select * from stu where age BETWEEN 20 and 35; 查找不在 30~35 岁间的同学1select * from stu where age NOT BETWEEN 30 and 35; 查找 2、3 班的所有同学1SELECT * FROM stu where class_id IN(2,3); 查找除了 1、3 班的同学1select * from stu where class_id NOT IN (1,3); NULL查询没有分配班级的学生姓名1select sname from stu where class_id is null; 查询已经分配班级的学生信息1SELECT * from stu where class_id is not null; 查询结果中对没分配班级的学生显示未分配123select sname,if(class_id is null,&apos;未分配&apos;,class_id) from stu;# 也可以使用IFNULl 函数简化操作select sname,ifnull (class_id ,&apos;未分配&apos;) from stu; 排序结果按学生年龄从大到小排序1SELECT * FROM stu order by age desc; 班级从大到小排序，相同班级的同学年龄从小到大排序1select * from stu order by class_id DESC,age ASC; 随机获取一名同学1SELECT * from stu order by RAND() limit 1; 最后报名的同名1select * from stu order by id desc limit 1 第二和第三报名的同学12# Limit 是从零开始的SELECT * FROM stu order by id ASC limit 1,2; 查找 2 班年龄最小的同学1SELECT * from stu where class_id =2 and age is not null order by age asc limit 1; 以上代码结果不准确，因为可能有同年龄的同学，所以可以使用子查询操作。1select * from stu where age = (SELECT age from stu where class_id =2 and age is not null order by age asc limit 1) 其他操作更新数据将班级为 2 的学生改为班级 31UPDATE stu SET class_id = 3 WHERE class_id = 2; 2 班年龄小于 20 岁的同学年龄设置为 NULL1UPDATE stu SET age = null WHERE class_id=2 AND age&lt;20; 将年龄小于 20 岁的同学年龄加 10 岁1UPDATE stu SET age= age+20 WHERE age&lt;20; 删除记录删除所有年龄小于 20 的同学1DELETE FROM stu WHERE age&lt;20; 删除所有年龄小在 30 并没有班级的同学1DELETE FROM stu WHERE class_id IS NULL; 添加数据添加一条记录1INSERT INTO stu SET sname = &apos;小明&apos;,age=22,class_id=1; 添加多条记录1INSERT INTO stu (sname,class_id,age) VALUES(&apos;小明&apos;,2,32),(&apos;小张&apos;,3,45);","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"MYSQL笔记","slug":"MYSQL笔记","permalink":"/tags/MYSQL笔记/"}]},{"title":"提高效率的AI工具","slug":"提高效率的AI工具","date":"2023-04-04T06:24:59.000Z","updated":"2024-01-11T07:00:59.272Z","comments":true,"path":"2023/04/04/提高效率的AI工具/","link":"","permalink":"/2023/04/04/提高效率的AI工具/","excerpt":"工作中提高效率的AI工具","text":"工作中提高效率的AI工具 5款腾讯免费AI工具Effidit 智能创作助手 「Effidit」是一款免费的人工智能写作助手，提供多种实用功能，包括文本纠错、文本润色、文本改写、文本扩写、词语推荐、句子推荐与生成等。使用 Effidit 可以轻松完成中英文写作，提高写作效率。 腾讯交互翻译 「腾讯交互翻译」是一款免费跨平台人工智能翻译神器，目前支持 20 种语言互译，翻译精准。它最大的特色在于融合了腾讯自研的 AI 技术。 帮小忙 「帮小忙」是一款所有功能完全免费的万能工具箱，涵盖了“图片”、“数据换算”、“生活娱乐”、“教育”、“文本工具”、“文档转换”、“开发工具”、“视频”和“PDF 转换工具”等 9 大类在线工具，目前共有 122 款，功能超级全面，最重要的还是免费的。 ARC 实验室 「ARC 实验室」是腾讯专门探索前沿科技的团队，被称为腾讯 PCG 的“侦察兵”、“特种兵”，目前 ARC 实验室公布了三款主要工具：“人像修复”、“人像抠图”和“动漫增强”，完全免费。 腾讯智影 「腾讯智影」是一款云端智能视频创作工具，无需下载即可通过 PC 浏览器访问，支持视频云剪辑、素材库、文本配音、数字人播报、自动字幕识别等功能，帮助用户更好地进行视频化的表达。 国外流行AI工具(有些需要科学上网)ChatGPT ChatGPT 是最近特别火爆的一款 AI 工具，它能够通过理解和学习人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文等任务。 Midjourney Midjourney 是一个由 Midjourney 研究实验室开发的人工智能程序，它可以根据你输入的文本智能生成图片，当然你也可以使用使用图片去生成与该图片类似的图片（图生图）。 Writesonic Writesonic 是一个人工智能作家，它可以以 10 倍的速度为您的博客、广告、电子邮件和网站创建 SEO 优化且无抄袭的内容。 remove.bg 使用 remove.bg 智能 AI 工具，您只需轻点一下，就可以在 5 秒钟内完全自动地去除背景。这将为您节省大量编辑时间，同时增加更多的乐趣。remove.bg 支持通过上传图片、拖拽图片和粘贴图片地址的方式选择图片进行处理。 beauiful.ai beautiful.ai 提供了大量智能 PPT 模版，您可以自由选择模版，轻松生成您的 PPT，让您可以在几分钟内创建专业 PPT，而不是几个小时。 Galileo AI Galileo AI 是一个生成式人工智能，它只需要您输入一个文本提示，即可生成令人惊叹、完全可编辑的 UI 设计，使您能够以超乎想象的速度进行设计。此外，它还提供许多由人工智能生成的插图和图像，供您添加到您的产品中。 Excel Formula Bot Excel Formula Bot 借助 AI 能力，让您几秒钟内快速将文本指令转化为 Excel 公式，帮助您解决所有电子表格问题。 Auto Draw AutoDraw 是一种来自谷歌创意实验室的完全免费的 AI 智能自动绘图工具。它将机器学习与天才艺术家的画作配对，帮助每个人快速创建任何视觉效果。并且它可以在任何地方使用：手机、平板电脑、笔记本电脑、台式机等。 TLDR-this TLDR 可帮助您将任何一段文本总结为简洁、易于理解的内容。将自己从信息过载中解放出来。 Fliki Fliki 可以将文本转换为带有 AI 语音短视频，您可以在 1 分钟内用人工智能的声音创建音频和视频内容。有了 Fliki，您就可以将您的博客文章或任何基于文本的内容转换成视频、播客或有声读物的配音。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"AI","slug":"AI","permalink":"/tags/AI/"}]},{"title":"前端枚举","slug":"前端枚举","date":"2023-03-31T05:16:16.000Z","updated":"2024-01-11T07:00:59.262Z","comments":true,"path":"2023/03/31/前端枚举/","link":"","permalink":"/2023/03/31/前端枚举/","excerpt":"前端枚举的简单入门","text":"前端枚举的简单入门 枚举在类似java等语言中很基础，但是js中却没有，即使现在的es6也没有把枚举加进来。但是，typescript中是有枚举供使用的。 typescript中枚举示例demo112345678910111213141516171819202122232425262728// tsenum demo1 &#123; Up = 1, Down, Left, Right&#125;// jsvar demo1;(function (demo1) &#123; demo1[demo1[&quot;Up&quot;] = 1] = &quot;Up&quot;; demo1[demo1[&quot;Down&quot;] = 2] = &quot;Down&quot;; demo1[demo1[&quot;Left&quot;] = 3] = &quot;Left&quot;; demo1[demo1[&quot;Right&quot;] = 4] = &quot;Right&quot;;&#125;)(demo1 || (demo1 = &#123;&#125;));// console&#123; &quot;1&quot;: &quot;Up&quot;, &quot;2&quot;: &quot;Down&quot;, &quot;3&quot;: &quot;Left&quot;, &quot;4&quot;: &quot;Right&quot;, &quot;Up&quot;: 1, &quot;Down&quot;: 2, &quot;Left&quot;: 3, &quot;Right&quot;: 4&#125; demo2123456789101112131415161718192021222324// tsenum demo2 &#123; Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;,&#125;// jsvar demo2;(function (demo2) &#123; demo2[&quot;Up&quot;] = &quot;UP&quot;; demo2[&quot;Down&quot;] = &quot;DOWN&quot;; demo2[&quot;Left&quot;] = &quot;LEFT&quot;; demo2[&quot;Right&quot;] = &quot;RIGHT&quot;;&#125;)(demo2 || (demo2 = &#123;&#125;));// console&#123; &quot;Up&quot;: &quot;UP&quot;, &quot;Down&quot;: &quot;DOWN&quot;, &quot;Left&quot;: &quot;LEFT&quot;, &quot;Right&quot;: &quot;RIGHT&quot;&#125; demo312345678910111213141516171819// tsenum demo3 &#123; No = 0, Yes = &quot;YES&quot;,&#125;// jsvar demo3;(function (demo3) &#123; demo3[demo3[&quot;No&quot;] = 0] = &quot;No&quot;; demo3[&quot;Yes&quot;] = &quot;YES&quot;;&#125;)(demo3 || (demo3 = &#123;&#125;));// console&#123; &quot;0&quot;: &quot;No&quot;, &quot;No&quot;: 0, &quot;Yes&quot;: &quot;YES&quot;&#125; 上面3个例子，ts部分是在typescript中的写法，js部分是typescript编译后的写法。可以发现，枚举中的数字类型和字符串类型编译后的结果稍有区别，在使用时也可以灵活使用。 前端中枚举的作用不难看出，枚举被编译后的结果就是一个js对象，那直接使用对象不是更好？其实，枚举主要作用是减少代码的错误，比如这样一段代码：1234567891011enum demo &#123; Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;,&#125;// 使用1demo.Up// 使用2demo.Upp 上述代码的使用2，在编译阶段就会报错，如果不使用ts的话，只能在运行时才能发现错误，可以提高代码正确率。 实际应用vue3的源码中：12345678910111213export const enum ShapeFlags &#123; ELEMENT = 1, FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1, STATEFUL_COMPONENT = 1 &lt;&lt; 2, TEXT_CHILDREN = 1 &lt;&lt; 3, ARRAY_CHILDREN = 1 &lt;&lt; 4, SLOTS_CHILDREN = 1 &lt;&lt; 5, TELEPORT = 1 &lt;&lt; 6, SUSPENSE = 1 &lt;&lt; 7, COMPONENT_SHOULD_KEEP_ALIVE = 1 &lt;&lt; 8, COMPONENT_KEPT_ALIVE = 1 &lt;&lt; 9, COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT&#125; 这样一段代码，简单些理解：12345678910111213141516171819202122232425262728const study = &#123; html: 1, css: 1 &lt;&lt; 1, js: 1 &lt;&lt; 2, svg: 1 &lt;&lt; 3, canvas: 1 &lt;&lt; 4&#125;function isStudy(studentNum, ...enumStudyArr) &#123; // 1 00000001 代表html // 2 00000010 代表css // 4 00000100 代表js // 8 00001000 代表svg // 16 00010000 代表canvas return enumStudyArr.every(item=&gt; &#123; return studentNum &amp; item; &#125;); &#125;/*** 使用：* 假设mike会html和svg，那么他的num就是1+8=9;* isStudy(9, study.html, study.svg);* 如果都会的话，1+2+4+8+16=31;* isStudy(31, study.html, study.css, study.js, study.svg, study.canvas);**/let mikeNum = 9;console.log(&apos;1-&gt;:&apos;, isStudy(mikeNum, study.html, study.svg));console.log(&apos;2-&gt;:&apos;, isStudy(mikeNum, study.html, study.css, study.js, study.svg, study.canvas));","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"typescript","slug":"typescript","permalink":"/tags/typescript/"}]},{"title":"javascript中的执行上下文和调用栈","slug":"javascript中的执行上下文和调用栈","date":"2023-03-15T06:59:07.000Z","updated":"2024-01-11T07:00:59.194Z","comments":true,"path":"2023/03/15/javascript中的执行上下文和调用栈/","link":"","permalink":"/2023/03/15/javascript中的执行上下文和调用栈/","excerpt":"Javascript中你必须理解的执行上下文和调用栈","text":"Javascript中你必须理解的执行上下文和调用栈 执行上下文在 JavaScript 是非常重要的基础知识，想要理解 JavaScript 的执行过程，执行上下文 是你必须要掌握的知识。否则只能是知其然不知其所以然。理解执行上下文有什么好处呢？它可以帮助你更好的理解代码的执行过程，作用域，闭包等关键知识点。特别是闭包它是 JavaScript 中的一个难点，当你理解了执行上下文在回头看闭包时，应该会有豁然开朗的感觉。这篇文章我们将深入了解 执行上下文，读完文章之后你应该可以清楚的了解到 JavaScript 解释器到底做了什么，为什么可以在一些函数和变量之前使用它，以及它们的值是如何确定的。 什么是执行上下文在 JavaScript 中运行代码时，代码的执行环境非常重要，通常是下列三种情况： Global code：代码第一次执行时的默认环境。 Function code：函数体中的代码 Eval code：eval 函数内执行的文本（实际开发中很少使用，所以见到的情况不多） 在网上你可以读到很多关于作用域的文章，为了便于理解本文的内容，我们将 执行上下文 当作代码的 执行环境/作用域。现在就让我们看一个例子：它包括 全局和函数/本地执行上下文。上面的例子我们看到，紫色的框代表全局上下文，绿色、蓝色、橙色代表三个不同的函数上下文。全局上下文执行有一个，它可以被其他上下文访问到。你可以有任意数量的函数上下文，每个函数在调用时都会创建一个新的上下文，它是一个私有范围，函数内部声明的所有东西都不能在函数作用域外访问到。上面的例子中，函数内部可以访问当前上下文之外声明的变量，但是外部却不能访问函数内部的变量/函数。这到底是为什么？其中的代码是如何执行的？ 执行上下文栈浏览器中的 JavaScript 解释器是单线程实现的。这意味着在浏览器中一次只能做一件事情。而其他的行为或事件都会在执行栈中排队等待。如图：我们知道，当浏览器第一次加载脚本时，默认情况下，它会进入全局上下文。如果在全局代码中调用了一个函数，则代码的执行会进入函数中，此时会创建一个新的执行上下文，它会被推到执行上下文栈中。如果在这个过程中函数内部调用了另一个函数，会发生同样的事情，代码的执行会进入函数中，然后创建一个新的执行上下文，它会被推到上下文栈 的顶部。浏览器始终执行栈顶部的执行上下文。一旦函数完成执行，当前的执行上下文将从栈的顶部弹出，然后继续执行下面的，下面程序演示了一个递归函数的执行上下文情况。12345678(function foo(i) &#123; if (i === 3) &#123; return; &#125; else &#123; foo(++i); &#125;&#125;(0)); 自己调用自己三次，每次将 i 递增 1，每次函数 foo 被调用的时候，就会创建一个新的执行上下文。一旦当前上下文执行完毕之后，它就会从栈中弹出并转移到下面的上下文中，直到全局上下。 执行上下文栈的 5 个关键点： 单线程 同步执行 只有一个全局上下文 任意数量的函数上下文 每个函数调用都会创建一个新的执行上下文，包括自己调用自己 详解执行上下文到此，我们知道每次调用一个函数时，都会创建一个新的执行上下文。但是在 JavaScript 解释器中，每次调用执行上下文会有两个阶段：1.创建阶段 创建作用域链 创建变量，函数，arguments列表。 确定 this 的指向 2.执行阶段 赋值，寻找函数引用，解释/执行代码 执行上下文可以抽象为一个对象它具备三个属性：12345executionContextObj = &#123; &apos;scopeChain&apos;: &#123; /* variableObject + all parent execution context&apos;s variableObject */ &#125;, &apos;variableObject&apos;: &#123; /* function arguments / parameters, inner variable and function declarations */&#125;, &apos;this&apos;: &#123;&#125;&#125; 活动/变量对象[AO/VO]executionContextObj 对象在函数调用时创建，但它是在函数真正执行之前就创建的，这就是我们所说的第一个阶段 创建阶段，此时解释器通过扫描函数的传入参数，arguments，本地函数声明，局部变量声明来创建executionContextObj 对象。将结果变成 variableObject 放入 executionContextObj 中。 解释器执行代码时的大致描述：1.调用函数2.在执行代码时，创建执行上下文3.进入创建阶段 初始化作用域链 创建变量对象（variableObject） 创建参数对象（arguments object），检查参数的上下文，初始化名称和值，并创建引用副本 扫描上下文中的函数声明 每发现一个函数，就会在 variableObject 中创建一个名称，保存函数的引用 如果名称已经存在，则覆盖引用 扫描上下文中的变量声明 每发现一个变量，就在 variableObject 中创建一个名称，并初始化值为 undefined 如果变量名已经存在，什么都不做，继续扫描 确定上下文中的 this 指向 4.执行代码阶段 在上下文中执行/解释代码，在代码逐行执行时进行变量复赋值 让我们看一个例子：123456function foo(i) &#123; var a = &apos;hello&apos;; var b = function privateB() &#123;&#125;; function c() &#123;&#125;&#125;foo(22); foo(22) 函数执行的时候，创建阶段如下1234567891011121314fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125; 如上所述，除了形参 i 和 arguments外，在创建阶段我们只把变量进行声明而不进行赋值。在创建阶段完成后，程序会进入函数中执行代码，如下所示：1234567891011121314fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: &apos;hello&apos;, b: pointer to function privateB() &#125;, this: &#123; ... &#125;&#125; 声明提前网上很多关于声明提前的内容，它是用来解释变量和函数在声明时会被提前到作用域的顶部。但是并没有人详细解释为什么会发生这种情况，有了刚才关于解释器如何创建活动对象（AO）的认知，我们将很容易看出原因。例如：1234567891011(function() &#123; console.log(typeof foo); // function pointer console.log(typeof bar); // undefined var foo = &apos;hello&apos;, bar = function() &#123; return &apos;world&apos;; &#125;; function foo() &#123; return &apos;hello&apos;; &#125;&#125;()) 我们现在可以回答如下问题：为什么我们可以在声明之前访问foo？在执行阶段之前，我们已经完成了创建阶段，此时变量/函数已经被创建，所以当函数执行的时候 foo 可以被访问到。foo 被声明了两次，为什么 foo 显示的是 function 而不是 undefined 或者 string？虽然 foo 被声明了两次，但是我们在创建阶段中说到，函数是在变量之前创建在变量对象中，当变量对象中名称已经存在时，变量声明什么也不做。因此 foo 会被先创建为函数 function foo() 的引用，当执行到 var foo时发现变量对象中已将存在了，所以此时什么也不做，而是继续扫描。为什么 bar 是 undefined？bar 实际上是一个变量只不过它的值是函数，而变量在创建阶段的值为 undefined。 总结我们再来梳理下重要的知识点： 首先在程序执行时会创建一个全局的执行上下文，有且只有一个。 函数在每次调用时就会创建一个函数上下文，可以有很多。 函数上下文可以访问全局上下文的内容，反之则不行。 创建的上下文会被推入到上下文栈中，然后从顶部开始依次执行。 执行上下文会分为两个阶段：创建阶段和执行阶段。 创建阶段会先进行函数声明和变量声明提前。 创建阶段会先进行函数声明，然后进行变量声明，同时会被放入变量对象中，如果变量对象中已经存在：函数则进行引用的覆盖，变量则什么都不做。 执行阶段才会进行赋值和运行。 希望你已经理解了 JavaScript 解释器是如何执行你的代码的。理解执行上下文和 执行上下文栈能够让你清楚的知道你的代码为什么和预期的值不一样。你认为了解，解释器的内部原理是多余还是必须的知识？它是否能够帮助你更好的编写 JavaScript 代码？欢迎留言讨论。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"for循环中var与let深入理解","slug":"for循环中var与let深入理解","date":"2023-03-15T06:32:29.000Z","updated":"2024-01-11T07:00:59.180Z","comments":true,"path":"2023/03/15/for循环中var与let深入理解/","link":"","permalink":"/2023/03/15/for循环中var与let深入理解/","excerpt":"for循环中var与let作用域不同的原理","text":"for循环中var与let作用域不同的原理 for中的var和let的使用var使用12345678910//使用var声明，得到3个3var a = [];for (var i = 0; i &lt; 3; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[0](); //3a[1](); //3a[2](); //3 let使用12345678910//使用let声明，得到0,1,2var a = [];for (let i = 0; i &lt; 3; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[0](); //0a[1](); //1a[2](); //2 for循环的展开for循序的执行顺序是这样的：设置循环变量(var i = 0) ==&gt; 循环判断(i&lt;3) ==&gt; 满足执行循环体 ==&gt; 循环变量自增(i++) var展开1234567891011121314151617181920212223242526272829var a = [];&#123; //我是父作用域 var i = 0; if (0 &lt; 3) &#123; a[0] = function () &#123; //我是子作用域 console.log(i); &#125;; &#125;; i++; //为1 if (1 &lt; 3) &#123; a[1] = function () &#123; console.log(i); &#125;; &#125;; i++; //为2 if (2 &lt; 3) &#123; a[2] = function () &#123; console.log(i); &#125;; &#125;; i++; //为3 // 跳出循环&#125;//调用N次指向都是最终的3a[0](); //3a[1](); //3a[2](); //3 let展开1234567891011121314151617181920212223242526272829var a = [];&#123; //我是父作用域 let i = 0; if (0 &lt; 3) &#123; a[0] = function () &#123; //我是子作用域 console.log(i); &#125;; &#125;; i++; //为1 if (1 &lt; 3) &#123; a[1] = function () &#123; console.log(i); &#125;; &#125;; i++; //为2 if (2 &lt; 3) &#123; a[2] = function () &#123; console.log(i); &#125;; &#125;; i++; //为3 // 跳出循环&#125;//调用N次指向都是最终的3a[0](); //3a[1](); //3a[2](); //3 但是，let这样写的结果跟var是一样的。其实浏览器底层的实现跟上边的实现是不一样，详细情况不解释，只写最后实现代码 1234567891011121314151617181920212223242526272829303132var a = []; &#123; //我是父作用域 let i = 0; if (i &lt; 3) &#123; //这一步模拟底层实现 let k = i; a[k] = function () &#123; //我是子作用域 console.log(k); &#125;; &#125;; i++; //为1 if (i &lt; 3) &#123; let k = i; a[k] = function () &#123; console.log(k); &#125;; &#125;; i++; //为2 if (i &lt; 3) &#123; let k = i; a[k] = function () &#123; console.log(k); &#125;; &#125;; i++; //为3 // 跳出循环&#125;a[0](); //0a[1](); //1a[2](); //2 总结参考-听风是风","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"递归深入理解","slug":"递归深入理解","date":"2023-01-09T02:46:19.000Z","updated":"2024-01-11T07:00:59.285Z","comments":true,"path":"2023/01/09/递归深入理解/","link":"","permalink":"/2023/01/09/递归深入理解/","excerpt":"深入的理解递归算法","text":"深入的理解递归算法【递归浅析】这篇文章简单的介绍了递归算法，本编会对递归进行深入的理解。 递归原理什么是递归，它是如何工作的？ 递归(recursion)是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。简单说程序调用自身的编程技巧叫递归。递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。 使用递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含2个属性： 基本情况（bottom cases），基本情况用于保证程序调用及时返回，不在继续递归，保证了程序可终止。 递推关系（recurrentce relation），可将所有其他情况拆分到基本案例。 简单的示例：以相反的顺序打印字符串。可以使用迭代的办法轻而易举地解决这个问题，即从字符串的最后一个字符开始遍历字符串。但是如何递归地解决它呢？1234567891011function printReverse(str) &#123; helper(0, str);&#125;function helper(index, str) &#123; if(!str || index&gt;str.length) &#123; return ; &#125; helper(index+1, str); console.log(str[index]);&#125;printReverse('abcdefg'); 递归的程序特征优雅性 相比其他解法（比如迭代法），使用递归法，会发现只需少量程序就可描述出解题过程，大大减少了程序的代码量，而且很好理解。递归的能力在于用有限的语句来定义对象的无限集合。 反向性 由于递归调用程序需要维护调用栈，而栈具有后进先出的特征，因此递归程序适合满足取反类需求。 递推关系 递归程序可以较明显的发现递推关系，反过来也可以这么说，具有递推关系的问题基本都可以通过递归求解（当然也许有性能更佳的解法，但递归绝对是一种选择）。递推关系常见问题有杨辉三角、阶乘计算等。 什么时候考虑递归具有以下特征的问题可考虑递归求解： 当问题和子问题具有递推关系，比如杨辉三角、计算阶乘。 具有递归性质的数据结构，比如链表、树、图。 反向性问题，比如取反。 总结下来，最根本的还是要抓住问题本身是否可以通过层层拆解到最小粒度来得解。 递归的递推性质上一节说了，在实现递归函数之前，需要弄明白2件事： ​递推关系​： 一个问题的结果与其子问题的结果之间的关系。 ​基本情况​: 不需要进一步的递归调用就可以直接计算答案的情况。 它们往往是问题被减少到最小规模的情况，也就是如果将问题划分为子问题是一种自上而下的方式的最下层。 一旦计算出以上两个元素，再想要实现一个递归函数，就只需要根据​递推关系​调用函数本身，直到其抵达​基本情况​。为了解释以上几点，来看一个经典问题：杨辉三角（也叫帕斯卡三角）。 帕斯卡三角 帕斯卡三角形是排列成三角形的一系列数字。 在帕斯卡三角形中，每一行的最左边和最右边的数字总是 1。 对于其余的每个数字都是前一行中直接位于它上面的两个数字之和。 下面的插图给出了一个 5 行的帕斯卡三角： 递推关系从帕斯卡三角形内的递推关系开始。首先，定义一个函数 f(i,j)，它将会返回帕斯卡三角形​第 i 行​、​第 j 列​的数字。可以用下面的公式来表示这一递推关系：f(i,j)=f(i−1,j−1)+f(i−1,j) 基本情况可以看到，每行的最左边和最右边的数字是​基本情况​，在这个问题中，它总是等于 1。因此，可以将基本情况定义如下:f(i,j)=1wherej=1orj=i 演示一旦定义了 ​递推关系​ 和 ​基本情况​，递归函数的实现变得更加直观，特别是在用数学公式表示出这两个元素之后。下面给出一个例子，展示如何用这个公式递归地计算 f(5,3), 也就是 帕斯卡三角形​第 5 行​中的​第 3 个​数。可以将 f(5,3) 分解为 f(5,3)=f(4,2)+f(4,3)，然后递归地调用 f(4,2) 和 f(4,3)：对于调用的 f(4,2)，可以进一步展开它，直到到达基本情况，正如下面所描述的：f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3对于调用的 f(4,3)，类似地，可以将其分解为：f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3最后，结合上述子问题的结果：f(5,3)=f(4,2)+f(4,3)=3+3=6可能已经注意到递归解决方案可能会导致一些重复的计算，​例如​，重复计算相同的中间数以获得最后一行中的数字。 举例说明，为了得到 f(5,3) 的结果，在 f(4,2) 和 f(4,3) 的调用中计算了 f(3,2) 两次，这样重复计算效率肯定不高，下一节会给出优化方案来避免重复计算（即记忆术）。 递归复杂性分析递归时间复杂度计算给出一个递归算法，其时间复杂度 O(T) 通常是递归调用的数量（记作 R）和计算的时间复杂度的乘积（表示为 O(s)）的乘积：O(T)=R∗O(s) 示例在反转字符串问题中，需要以相反的顺序打印字符串，解决问题的递归关系可以表示如下：​printReverse(str) = printReverse(str[1...n]) + print(str[0])​其中 ​str[1...n]​ 是输入字符串 ​str​ 的子串，仅不含前导字符 ​str[0]​。该函数将被递归调用 n 次，其中 n 是输入字符串的大小。在每次递归结束时，只是打印前导字符，因此该特定操作的时间复杂度是恒定的，即 O(1)。总而言之，递归函数 ​printReverse(str)​ 的总体时间复杂度为 O(printReverse)=n∗O(1)=O(n)。 执行树分析递归调用数量在分析递归的时间复杂度时，递归调用的数量不一定和N成线性关系，比如斐波那契数的计算（见第五部分），其递推关系被定义为​f(n) = f(n-1) + f(n-2)​。乍一看，在执行斐波那契函数期间计算递归调用的数量似乎并不简单。执行树定义 执行树是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。 递归函数的执行树将形成 ​n 叉树​，其中 ​n​ 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 ​f(4)​ 的执行树。在 n 层的完全二叉树中，节点的总数为 2n−1。因此 ​f(n)​ 中递归数目的上限（尽管不严格）也是 2n−1。那么我们可以估计 ​f(n)​ 的时间复杂度为 O(2n)。 递归空间复杂性分析在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：递归相关空间（​recursion related space）和非递归相关空间​（​non-recursion related space​）。 递归相关空间递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。为了完成典型的函数调用，系统应该在栈中分配一些空间来保存三个重要信息： 函数调用的返回地址。一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点。 传递给函数调用的参数。 函数调用中的局部变量。 栈中的这个空间是函数调用期间产生的最小成本。然而，一旦完成函数调用，就会释放该空间。对于递归算法，函数调用将连续链接直到它们到达基本情况（也称为 底层情况）。这意味着用于每个函数调用的空间也会累积。对于递归算法，如果没有产生其他内存消耗，则此递归引起的空间将是算法的空间上限。例如，在本文一开始提到了反转字符串示例中，没有使用额外的内存，因为仅仅是打印一个字符。对于每个递归调用，假设它可能需要一个最大为某一常量值的空间。并且递归调用最多可以链接 ​n​ 次，其中 ​n​ 是输入字符串的大小。因此，该递归算法的空间复杂度就是 O(n)。为了更好地说明这一点，接下来将会展示递归调用​ f(x1) -&gt; f(x2) -&gt; f(x3)​ 的执行顺序以及栈空间的分配情况。栈中的空间将会分配给 ​f(x1)​ 来调用 ​f(x2)​。类似的情况也同样发生在 ​f(x2)​ 中，系统会为 ​f(x3) 的调用分配另一个空间，最后在​ ​f(x3)​ 中，我们到达基本情况，因此在 ​f(x3)​ 中没有进行进一步的递归调用。正是由于这些与递归相关的空间消耗，有时可能会遇到称为堆栈溢出的情况，其中为程序分配的堆栈达到其最大空间限制并导致程序最终失败。在设计递归算法时，应该仔细评估在输入规模扩大时是否存在堆栈溢出的可能性，栈溢出是非常容易出错的点，在下一节将讨论优化策略。 非递归相关空间正如名称所示，非递归相关空间指的是与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间（通常在堆中）。不管是否递归，都可能需要在任何函数调用之前将问题的输入存储为全局变量。可能还需要保存递归调用的中间结果（也就是即将讨论的记忆化技术）。例如，在使用带有记忆化技术的递归算法解决斐波那契数问题时,使用映射（map）来跟踪在递归调用期间产生的所有中间斐波那契数。因此，在分析空间复杂度时，应该考虑到因采用记忆化技术所导致的空间成本。 递归的优化策略时间优化策略：记忆化递归是一种直观而有效的实现算法的方法。 但是，如果不明智地使用它，可能会给性能带来一些不希望的损失，例如重复计算。 在前面提到了帕斯卡三角的重复计算问题，其中一些中间结果被多次计算。在本文中，将进一步研究递归可能出现的重复计算问题。 然后将提出一种常用的技术，称为​记忆化（memoization）​，可以用来避免这个问题。为了演示重复计算的另一个问题，看一个大多数人可能都很熟悉的例子，斐波那契数。 如果定义函数 ​F(n)​ 表示在索引 ​n​ 处的斐波那契数，那么可以推导出如下的递推关系：​F(n) = F(n - 1) + F(n - 2)​基本情况：​F(0) = 0, F(1) = 1​根据斐波那契数列的定义，可以实现下面的函数：1234567function fibonacci(n) &#123; if(n&lt;2) &#123; return n; &#125;else &#123; return fibonacci(n-1) + fibonacci(n-2); &#125;&#125; 现在，如果想知道 ​F(4)​ 是多少，可以应用上面的公式并进行展开：​F(4) = F(3) + F(2) = (F(2) + F(1)) + F(2)为了得到 f(4) 的结果，需要在上述推导之后计算两次数 ​F(2)​ : 第一次在 ​F(4)​ 的第一次展开中，第二次在中间结果 ​F(3)​ 中。下面的树显示了在计算 ​F(4)​ 时发生的所有重复计算（按颜色分组）。为了消除上述情况中的重复计算，正如许多人已经指出的那样，其中一个想法是将中间结果存储在缓存中，以便以后可以重用它们，而不需要重新计算。这个想法也被称为记忆化，这是一种经常与递归一起使用的技术。​记忆化定义 记忆化是一种优化技术，主要用于加快计算机程序的速度，方法是存储昂贵的函数调用的结果，并在相同的输入再次出现时返回缓存的结果。 回到斐波那契函数 ​F(n)​。 可以使用哈希表来跟踪每个以 ​n​ 为键的 ​F(n)​ 的结果。 散列表作为一个缓存，可以避免重复计算。 记忆化技术是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。为了便于比较，下面提供了带有记忆化功能的斐波那契数列解决方案的实现。作为一种练习，可以尝试使记忆化更加通用和非侵入性，即应用记忆化技术而不改变原来的功能。1234567891011121314const cache = new Map();function fibonacci(n) &#123; if(cache.has(n)) &#123; return cache.get(n); &#125; let result = 0; if(n&lt;2) &#123; result = n; &#125;else &#123; result = fibonacci(n-1) + fibonacci(n-2); &#125; cache.set(n, result); return result;&#125; 斐波那契数应用的一个经典问题是爬楼梯，在第五节再分析。通过记忆化技术，保存每个索引 ​n​ 对应的的斐波那契数的结果。确信每个斐波那契数的计算只会发生一次。而从递推关系来看，斐波纳契数 ​f(n)​ 将取决于其所有 ​n-1​ 个先验斐波纳契数。结果，计算 ​f(n)​ 的递归将被调用 ​n-1​ 次以计算它所依赖的所有先验数字。现在，可以计算一下采用了记忆化技术优化后的时间复杂度，即 O(1)∗n=O(n)。可以得出记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。 空间优化策略：尾递归上一节讨论了递归空间复杂性分析话题，从中了解到递归调用在系统调用栈上会产生额外空间，如果递归调用层级很深，程序执行过程中很可能导致栈溢出。针对这种情况，有一种称为尾递归的特殊递归，它可以控制递归导致空间开销的影响。尾递归定义 尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。 尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）。第五部分将看到尾递归优化阶乘运算的例子。 采用递归解法的几个经典问题 递归在递推关系的数学问题上应用广泛，使用递归法可以解决很多趣味问题，下面来看看都有哪些经典问题。 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 ​char[]​ 的形式给出。不要给另外的数组分配额外的空间，必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。示例：123456// 1输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]// 2输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 分析：此问题是根据递归调用栈的特性做后进先出反转。code:123456789101112function reverseString(arrStr) &#123; help(arrStr, 0, arrStr.length-1); return arrStr;&#125;function help(arrStr, left, right) &#123; if(left &gt;= right) return ; let temp = arrStr[left]; arrStr[left] = arrStr[right]; arrStr[right] = temp; help(arrStr, left+1, right-1);&#125;reverseString(['h', 'e', 'l', 'l', '0']); 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例：1234// 给定1-&gt;2-&gt;3-&gt;4// 你应该返回2-&gt;1-&gt;4-&gt;3 code：12345678910111213141516171819const link5 = &#123;val: 5, name: 5, next: null&#125;;const link4 = &#123;val: 4, name: 4, next: link5&#125;;const link3 = &#123;val: 3, name: 3, next: link4&#125;;const link2 = &#123;val: 2, name: 2, next: link3&#125;;const link1 = &#123;val: 1, name: 1, next: link2&#125;;function swapPairs(head) &#123; if(!head || !head.next) return; let temp = head.val; head.val = head.next.val; head.next.val = temp; swapPairs(head.next.next);&#125;swapPairs(link1);console.log(link1);console.log(link2);console.log(link3);console.log(link4);console.log(link5); 杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。示例：123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 分析：典型的具有递推关系的数据问题，注意通过记忆化优化。code：1234567891011121314151617181920212223242526272829let cache = []; // 缓存function generate(numRows) &#123; // 传入数字不是整数，返回空数组 if(numRows&lt;=0) return []; let arr = []; for(let i=1; i&lt;=numRows; i++) &#123; arr[i-1] = []; for(let j=1; j&lt;=i; j++) &#123; arr[i-1].push(makeNum(i, j)); &#125; &#125; return arr;&#125;function makeNum(row, column) &#123; if(!cache[row]) &#123; cache[row]=[]; &#125; // 有缓存，直接返回 if(cache[row][column]) return cache[row][column]; // 这里是递归的基本情况 if(row===column||column==1) &#123; cache[row][column] = 1; // 记忆化 return 1; &#125; // 记忆化 cache[row][column] = makeNum(row-1, column-1) + makeNum(row-1, column); return cache[row][column];&#125;generate(5); 斐波那契数斐波那契数，通常用 ​F(n)​ 表示，形成的序列称为斐波那契数列。该数列由 ​0​ 和 ​1​ 开始，后面的每一项数字都是前面两项数字的和。也就是：F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1给定 ​N​，计算 ​F(N)​。示例：123456789101112// 1输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1.// 2输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2.// 3输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 分析：递归考虑记忆化优化code：1234567// 未使用记忆化版本function fib(num) &#123; if(num===0) return 0; if(num===1) return 1; return fib(num-1) + fib(num-2);&#125;fib(50); 1234567891011// 使用记忆化版本let cache = new Map(); // 记忆化function fib(num) &#123; if(num===0) return 0; if(num===1) return 1; if(cache.has(num)) return cache.get(num); let result = fib(num-1) + fib(num-2); cache.set(num, result); return result; &#125;fib(50); 上面两个版本，一个做了记忆化，一个没有，求50的斐波那契数，没做记忆化的用浏览器运行直接卡死，而做了记忆化的瞬间出结果。 爬楼梯假设爬楼梯。需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。示例：12345678910111213// 1输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1) 1 阶 + 1 阶2) 2 阶// 2输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1) 1 阶 + 1 阶 + 1 阶2) 1 阶 + 2 阶3) 2 阶 + 1 阶 分析：该问题通过规律发现递推关系就是斐波那契数。code：123456789101112131415function climbStairs(stepNum) &#123; let cache = []; return help(stepNum, cache);&#125;function help(stepNum, cache) &#123; if(stepNum &lt;= 0) return 0; if(cache[stepNum]) return cache[stepNum]; if(stepNum &lt; 4) &#123; cache[stepNum] = stepNum; &#125;else &#123; cache[stepNum] = help(stepNum-1, cache) + help(stepNum-2, cache); &#125; return cache[stepNum];&#125;climbStairs(1000); 二叉树的最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。示例：1234567891011121314151617181920212223242526272829303132let binTree = &#123; left: &#123; left: &#123; left: null, right: &#123; left: null, right: null &#125; &#125;, right: null &#125;, right: &#123; left: null, right: &#123; left: &#123; left: null, right: &#123; left: &#123; left: null, right: &#123; left: null, right: &#123; left: null, right: null, &#125; &#125; &#125;, right: null &#125; &#125;, right: null &#125; &#125;&#125;返回的最大深度是8 分析：二叉树是典型的具有递归属性的数据结构。123456function maxDepth(binTree) &#123; if(!binTree) return 0; if(!binTree.left &amp;&amp; !binTree.right) return 1; return Math.max(maxDepth(binTree.left), maxDepth(binTree.right)) + 1;&#125;maxDepth(binTree); 计算 x 的 n 次幂函数示例：123456// 1输入: 2, 10输出: 1024// 2输入: 2.1, 3输出: 9.261 说明：-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1]分析：n可能很大，需要防止栈溢出，可思考尾递归实现。code：12345678function myPow(x, n) &#123; return n&gt;0 ? help(x, n) : 1/help(x, -n);&#125;function help(x, n) &#123; if(n===0) return 1; return x * help(x, n-1);&#125;myPow(2, 10); 第K个语法符号在第一行写上一个0​。接下来的每一行，将前一行中的​0​替换为​01​，​1​替换为​10​。给定行数N和序数​K​，返回第​N行中第​K​个字符。（​K​从1开始）示例：123456789101112131415161718// 1输入: N = 1, K = 1输出: 0// 2输入: N = 2, K = 1输出: 0// 3输入: N = 2, K = 2输出: 1// 4输入: N = 4, K = 5输出: 1解释:第一行: 0第二行: 01第三行: 0110第四行: 0110100 注意：​N​ 的范围 ​[1, 30]​.​K​ 的范围 ​[1, 2^(N-1)]​.分析：识别具有递归关系问题code：1234567891011function getNStr(n) &#123; if(n==1) return '0'; return getNStr(n-1).replace(/0|1/g, function(c) &#123; if(c==='0') return '01'; if(c==='1') return '10'; &#125;)&#125;function getKChar(n, k) &#123; return getNStr(n).charAt(k-1);&#125;getKChar(4, 5); 总结现在，更加相信递归是一种强大的技术，它能够以一种优雅而有效的方式解决许多问题。同时，它也不是解决任务问题的灵丹妙药。由于时间或空间的限制，并不是所有的问题都可以用递归来解决。递归本身可能会带来一些不希望看到的副作用，如栈溢出。有时，在解决实际问题时乍一看，并不清楚是否可以应用递归算法来解决问题。然而，由于递归的递推性质与所熟悉的数学非常接近，用数学公式来推导某些关系总是有帮助的，也就是说写出递推关系和基本情况是使用递归算法的前置条件。只要有可能，就应用记忆化。在起草递归算法时，可以从最简单的策略开始。有时，在递归过程中，可能会出现重复计算的情况，例如斐波纳契数（Fibonacci）。在这种情况下，可以尝试应用 Memoization 技术，它将中间结果存储在缓存中供以后重用，它可以在空间复杂性上稍加折中，从而极大地提高时间复杂性，因为它可以避免代价较高的重复计算。当堆栈溢出时，尾递归可能会有所帮助。使用递归实现算法通常有几种方法。尾递归是实现递归的一种特殊形式。与记忆化技术不同的是，尾递归通过消除递归带来的堆栈开销，优化了算法的空间复杂度。更重要的是，有了尾递归，就可以避免经常伴随一般递归而来的堆栈溢出问题，而尾递归的另一个优点是，与非尾递归相比，尾部递归更容易阅读和理解。这是由于尾递归不存在调用后依赖（即递归调用是函数中的最后一个动作），这一点不同于非尾递归，因此，只要有可能，就应该尽量运用尾递归。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}]},{"title":"前端编译原理-VUE模板编译概览","slug":"前端编译原理-VUE模板编译概览","date":"2023-01-04T09:01:05.000Z","updated":"2024-01-11T07:00:59.262Z","comments":true,"path":"2023/01/04/前端编译原理-VUE模板编译概览/","link":"","permalink":"/2023/01/04/前端编译原理-VUE模板编译概览/","excerpt":"VUE模板编译工作流程简介","text":"VUE模板编译工作流程简介 概要VUE的模板是要被转换成js渲染函数，在运行时执行的。 主要流程：模板-&gt;parse(str)-&gt;模板AST-&gt;transform(ast)-&gt;javascript AST-&gt;generate(JSAST)-&gt;渲染函数 模板1&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt; parse词法分析 词法分析是把字符串解析成tokens 模板字符串转化后的tokens：12345678910[ &#123; type: &apos;tag&apos;, name: &apos;div&apos; &#125;, &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;, &#123; type: &apos;text&apos;, content: &apos;Vue&apos; &#125;, &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;, &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;, &#123; type: &apos;text&apos;, content: &apos;Template&apos; &#125;, &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;, &#123; type: &apos;tagEnd&apos;, name: &apos;div&apos; &#125;] 实现code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const State = &#123; initial: 1, tagOpen: 2, tagName: 3, text: 4, tagEnd: 5, tagEndName: 6&#125;function isAlpha(char) &#123; return char &gt;= &apos;a&apos; &amp;&amp; char &lt;= &apos;z&apos; || char &gt;= &apos;A&apos; &amp;&amp; char &lt;= &apos;Z&apos;&#125;function tokenize(str) &#123; let currentState = State.initial const chars = [] const tokens = [] while(str) &#123; const char = str[0] switch (currentState) &#123; case State.initial: if (char === &apos;&lt;&apos;) &#123; currentState = State.tagOpen str = str.slice(1) &#125; else if (isAlpha(char)) &#123; currentState = State.text chars.push(char) str = str.slice(1) &#125; break case State.tagOpen: if (isAlpha(char)) &#123; currentState = State.tagName chars.push(char) str = str.slice(1) &#125; else if (char === &apos;/&apos;) &#123; currentState = State.tagEnd str = str.slice(1) &#125; break case State.tagName: if (isAlpha(char)) &#123; chars.push(char) str = str.slice(1) &#125; else if (char === &apos;&gt;&apos;) &#123; currentState = State.initial tokens.push(&#123; type: &apos;tag&apos;, name: chars.join(&apos;&apos;) &#125;) chars.length = 0 str = str.slice(1) &#125; break case State.text: if (isAlpha(char)) &#123; chars.push(char) str = str.slice(1) &#125; else if (char === &apos;&lt;&apos;) &#123; currentState = State.tagOpen tokens.push(&#123; type: &apos;text&apos;, content: chars.join(&apos;&apos;) &#125;) chars.length = 0 str = str.slice(1) &#125; break case State.tagEnd: if (isAlpha(char)) &#123; currentState = State.tagEndName chars.push(char) str = str.slice(1) &#125; break case State.tagEndName: if (isAlpha(char)) &#123; chars.push(char) str = str.slice(1) &#125; else if (char === &apos;&gt;&apos;) &#123; currentState = State.initial tokens.push(&#123; type: &apos;tagEnd&apos;, name: chars.join(&apos;&apos;) &#125;) chars.length = 0 str = str.slice(1) &#125; break &#125; &#125; return tokens&#125; 语法分析 语法分析是把词法分析出来的tokens解析成AST 模板AST：⬇⬇⬇实现code：1234567891011121314151617181920212223242526272829303132333435363738function parse(str) &#123; const tokens = tokenize(str) const root = &#123; type: &apos;Root&apos;, children: [] &#125; const elementStack = [root] while (tokens.length) &#123; const parent = elementStack[elementStack.length - 1] const t = tokens[0] switch (t.type) &#123; case &apos;tag&apos;: const elementNode = &#123; type: &apos;Element&apos;, tag: t.name, children: [] &#125; parent.children.push(elementNode) elementStack.push(elementNode) break case &apos;text&apos;: const textNode = &#123; type: &apos;Text&apos;, content: t.content &#125; parent.children.push(textNode) break case &apos;tagEnd&apos;: elementStack.pop() break &#125; tokens.shift() &#125; return root&#125; 模板AST 通过parse步骤后得到的模板AST： 12345678910111213141516171819202122232425262728293031&#123; &quot;type&quot;: &quot;Root&quot;, &quot;children&quot;: [ &#123; &quot;type&quot;: &quot;Element&quot;, &quot;tag&quot;: &quot;div&quot;, &quot;children&quot;: [ &#123; &quot;type&quot;: &quot;Element&quot;, &quot;tag&quot;: &quot;p&quot;, &quot;children&quot;: [ &#123; &quot;type&quot;: &quot;Text&quot;, &quot;content&quot;: &quot;Vue&quot; &#125; ] &#125;, &#123; &quot;type&quot;: &quot;Element&quot;, &quot;tag&quot;: &quot;p&quot;, &quot;children&quot;: [ &#123; &quot;type&quot;: &quot;Text&quot;, &quot;content&quot;: &quot;Template&quot; &#125; ] &#125; ] &#125; ]&#125; transform 将模板AST转换成javascript AST，此处使用了插件结构，处理转换节点的函数是单独出来的 主函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function transform(ast) &#123; const context = &#123; currentNode: null, parent: null, replaceNode(node) &#123; context.currentNode = node context.parent.children[context.childIndex] = node &#125;, removeNode() &#123; if (context.parent) &#123; context.parent.children.splice(context.childIndex, 1) context.currentNode = null &#125; &#125;, nodeTransforms: [ transformRoot, transformElement, transformText ] &#125; // 调用 traverseNode 完成转换 traverseNode(ast, context)&#125;function traverseNode(ast, context) &#123; context.currentNode = ast const exitFns = [] const transforms = context.nodeTransforms for (let i = 0; i &lt; transforms.length; i++) &#123; const onExit = transforms[i](context.currentNode, context) if (onExit) &#123; exitFns.push(onExit) &#125; if (!context.currentNode) return &#125; const children = context.currentNode.children if (children) &#123; for (let i = 0; i &lt; children.length; i++) &#123; context.parent = context.currentNode context.childIndex = i traverseNode(children[i], context) &#125; &#125; let i = exitFns.length while (i--) &#123; exitFns[i]() &#125;&#125; 插件工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function transformText(node) &#123; if (node.type !== &apos;Text&apos;) &#123; return &#125; node.jsNode = createStringLiteral(node.content)&#125;function transformElement(node) &#123; return () =&gt; &#123; if (node.type !== &apos;Element&apos;) &#123; return &#125; const callExp = createCallExpression(&apos;h&apos;, [ createStringLiteral(node.tag) ]) node.children.length === 1 ? callExp.arguments.push(node.children[0].jsNode) : callExp.arguments.push( createArrayExpression(node.children.map(c =&gt; c.jsNode)) ) node.jsNode = callExp &#125;&#125;function transformRoot(node) &#123; return () =&gt; &#123; if (node.type !== &apos;Root&apos;) &#123; return &#125; const vnodeJSAST = node.children[0].jsNode node.jsNode = &#123; type: &apos;FunctionDecl&apos;, id: &#123; type: &apos;Identifier&apos;, name: &apos;render&apos; &#125;, params: [], body: [ &#123; type: &apos;ReturnStatement&apos;, return: vnodeJSAST &#125; ] &#125; &#125;&#125;function createStringLiteral(value) &#123; return &#123; type: &apos;StringLiteral&apos;, value &#125;&#125;function createIdentifier(name) &#123; return &#123; type: &apos;Identifier&apos;, name &#125;&#125;function createArrayExpression(elements) &#123; return &#123; type: &apos;ArrayExpression&apos;, elements &#125;&#125;function createCallExpression(callee, arguments) &#123; return &#123; type: &apos;CallExpression&apos;, callee: createIdentifier(callee), arguments &#125;&#125; javascript AST 模板字符串经过转换后生成的javascript AST: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; &quot;type&quot;: &quot;FunctionDecl&quot;, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;render&quot; &#125;, &quot;params&quot;: [], &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ReturnStatement&quot;, &quot;return&quot;: &#123; &quot;type&quot;: &quot;CallExpression&quot;, &quot;callee&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;h&quot; &#125;, &quot;arguments&quot;: [ &#123; &quot;type&quot;: &quot;StringLiteral&quot;, &quot;value&quot;: &quot;div&quot; &#125;, &#123; &quot;type&quot;: &quot;ArrayExpression&quot;, &quot;elements&quot;: [ &#123; &quot;type&quot;: &quot;CallExpression&quot;, &quot;callee&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;h&quot; &#125;, &quot;arguments&quot;: [ &#123; &quot;type&quot;: &quot;StringLiteral&quot;, &quot;value&quot;: &quot;p&quot; &#125;, &#123; &quot;type&quot;: &quot;StringLiteral&quot;, &quot;value&quot;: &quot;Vue&quot; &#125; ] &#125;, &#123; &quot;type&quot;: &quot;CallExpression&quot;, &quot;callee&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;h&quot; &#125;, &quot;arguments&quot;: [ &#123; &quot;type&quot;: &quot;StringLiteral&quot;, &quot;value&quot;: &quot;p&quot; &#125;, &#123; &quot;type&quot;: &quot;StringLiteral&quot;, &quot;value&quot;: &quot;Template&quot; &#125; ] &#125; ] &#125; ] &#125; &#125; ]&#125; generate 得到转换后的javascript AST后，生成渲染函数字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function generate(node) &#123; const context = &#123; code: &apos;&apos;, push(code) &#123; context.code += code &#125;, currentIndent: 0, newline() &#123; context.code += &apos;\\n&apos; + ` `.repeat(context.currentIndent) &#125;, indent() &#123; context.currentIndent++ context.newline() &#125;, deIndent() &#123; context.currentIndent-- context.newline() &#125; &#125; genNode(node, context) return context.code&#125;function genNode(node, context) &#123; switch (node.type) &#123; case &apos;FunctionDecl&apos;: genFunctionDecl(node, context) break case &apos;ReturnStatement&apos;: genReturnStatement(node, context) break case &apos;CallExpression&apos;: genCallExpression(node, context) break case &apos;StringLiteral&apos;: genStringLiteral(node, context) break case &apos;ArrayExpression&apos;: genArrayExpression(node, context) break &#125;&#125;function genFunctionDecl(node, context) &#123; const &#123; push, indent, deIndent &#125; = context push(`function $&#123;node.id.name&#125; `) push(`(`) genNodeList(node.params, context) push(`) `) push(`&#123;`) indent() node.body.forEach(n =&gt; genNode(n, context)) deIndent() push(`&#125;`)&#125;function genNodeList(nodes, context) &#123; const &#123; push &#125; = context for (let i = 0; i &lt; nodes.length; i++) &#123; const node = nodes[i] genNode(node, context) if (i &lt; nodes.length - 1) &#123; push(&apos;, &apos;) &#125; &#125;&#125;function genReturnStatement(node, context) &#123; const &#123; push &#125; = context push(`return `) genNode(node.return, context)&#125;function genCallExpression(node, context) &#123; const &#123; push &#125; = context const &#123; callee, arguments: args &#125; = node push(`$&#123;callee.name&#125;(`) genNodeList(args, context) push(`)`)&#125;function genStringLiteral(node, context) &#123; const &#123; push &#125; = context push(`&apos;$&#123;node.value&#125;&apos;`)&#125;function genArrayExpression(node, context) &#123; const &#123; push &#125; = context push(&apos;[&apos;) genNodeList(node.elements, context) push(&apos;]&apos;)&#125; 渲染函数 经过transform转换后生成的渲染函数字符串： 123function render () &#123; return h(&apos;div&apos;, [h(&apos;p&apos;, &apos;Vue&apos;), h(&apos;p&apos;, &apos;Template&apos;)])&#125; 总结最后总结代码：12345678910function compile(template) &#123; // 模板AST const ast = parse(template); // 将模板AST转换为javascript AST transform(ast); // 代码生成 const code = generate(ast.jsNode); return code;&#125; 本篇内容摘取《VUE设计与实现》的第15章，简单的介绍了前端模板的编译解析步骤。本篇codeVUE设计与实现code","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"编译","slug":"编译","permalink":"/tags/编译/"}]},{"title":"前端编译原理-有限状态机","slug":"前端编译原理-有限状态机","date":"2023-01-04T03:34:48.000Z","updated":"2024-01-11T07:00:59.262Z","comments":true,"path":"2023/01/04/前端编译原理-有限状态机/","link":"","permalink":"/2023/01/04/前端编译原理-有限状态机/","excerpt":"有限状态机在词法分析中的应用","text":"有限状态机在词法分析中的应用 概念 有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。 有限状态机在计算机领域的应用非常多，本篇文章主要介绍下在词法解析方面的应用。 应用将字符串100+200-300转化成如下tokens1234567[ &#123; type: &apos;Numeric&apos;, value: &apos;100&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;+&apos; &#125;, &#123; type: &apos;Numeric&apos;, value: &apos;200&apos; &#125;, &#123; type: &apos;Punctuator&apos;, value: &apos;-&apos; &#125;, &#123; type: &apos;Numeric&apos;, value: &apos;300&apos; &#125;] 案例一：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 四则运算字符串const inputStr = &apos;100+200-300&apos;;// 匹配数字的正则const NumReg = /[0-9]/// 匹配标点符号的正则规则const PunctuatorReg = /[\\+\\-\\*\\/]/// 最终输出的所有tokens合集const tokens = []// 当前状态机中正在处理的tokenlet currentToken = &#123;&#125;/** * 词法分析函数 * @param &#123;*&#125; inputStr * @returns tokens */function stateMachine(inputStr) &#123; // 定义状态机的初始状态判断函数 let state = start // 依次迭代输入的字符串 // while(inputStr) &#123; // state = state(inputStr[0]); // inputStr = inputStr.slice(1); // &#125; inputStr.split(&quot;&quot;).forEach(char =&gt; &#123; // 此处的char是每一个字符 // 调用state函数 并且传入char state = state(char) &#125;) // 遍历结束后仍然需要发送一次最后 tokens.push(currentToken) return tokens;&#125;/** * 状态机初始函数 * @param &#123;*&#125; char 输入的字符 * @return &#123;*&#125; */function start (char) &#123; if(NumReg.test(char)) &#123; // 首个输入的char是数字 初始化token为numeric currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125; // 返回的是一个nunmer的处理函数 return numeric &#125;else if (PunctuatorReg.test(char)) &#123; // 首个输入的char是标点符号 初始化current为punctuator currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125; // 返回的是一个punctuator的处理函数 return punctuator &#125;&#125;// 数字处理函数function numeric(char) &#123; if(NumReg.test(char)) &#123; // 如果当前输入是数字 不分词 连续累加value值 currentToken.value += char // 返回numeric函数赋给state return numeric &#125;else if (PunctuatorReg.test(char)) &#123; // 如果是标点符号 分词 // 如果当前输入的标点符号 进行分词 // 首先将旧的token输入到tokens中 emitToken(currentToken) // 修改当前token currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125; // 返回punctuator处理函数 return punctuator &#125;&#125;// 标点符号状态处理函数function punctuator(char) &#123; // 无论如何都要发射 因为标点符号在分词阶段不会被拼接起来 emitToken(currentToken) if (NumReg.test(char)) &#123; currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125; return numeric &#125; else if (PunctuatorReg.test(char)) &#123; currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125; return punctuator &#125; return punctuator&#125;// 将token放入tokens中function emitToken(token) &#123; // 重制 currentToken currentToken = &#123; type: &apos;&apos;, value: &apos;&apos; &#125; // 将上一次传入的token参数保存到最终输入的tokens中 tokens.push(token)&#125;console.log(stateMachine(inputStr)); 案例二：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 四则运算字符串const inputStr = &apos;100+200-300&apos;;// 匹配数字的正则const NumReg = /[0-9]/// 匹配标点符号的正则规则const PunctuatorReg = /[\\+\\-\\*\\/]/// 最终输出的所有tokens合集const tokens = []// 当前状态机中正在处理的tokenlet currentToken = &apos;&apos;;let type = &apos;start&apos;;function start(char, i, str) &#123; if( type===&apos;start&apos;&amp;&amp;NumReg.test(char)) &#123; type = &apos;Numberic&apos;; currentToken += char; &#125;else if(type===&apos;Numberic&apos;&amp;&amp;NumReg.test(char)) &#123; currentToken += char; &#125;else if(type===&apos;Numberic&apos;&amp;&amp;PunctuatorReg.test(char)) &#123; tokens.push(&#123; type: &apos;Numberic&apos;, value: currentToken &#125;); type = &apos;Punctuator&apos;; currentToken = char; &#125;else if(type===&apos;Punctuator&apos;&amp;&amp;NumReg.test(char)) &#123; type = &apos;Numberic&apos;; tokens.push(&#123; type: &apos;Punctuator&apos;, value: currentToken &#125;); currentToken = char; &#125; if(type===&apos;Numberic&apos;&amp;&amp;i===(str.length-1)) &#123; tokens.push(&#123; type: &apos;Numberic&apos;, value: currentToken &#125;); currentToken = &apos;&apos;; &#125;&#125;function stateMachine(str) &#123; for(let i=0; i&lt;str.length; i++) &#123; start(str[i], i, str); &#125; return tokens;&#125;console.log(stateMachine(inputStr)); 上面两个案例结果一样，但是过程不同。案例一的状态变化是以返回函数的形式，对代码进行了抽象解耦。案例二有点面向过程的写法，代码冗余，逻辑复杂的话，肯定是第一种方法好。 总结本篇文章只是简单的介绍下，有限状态机在编译的词法分析阶段的应用。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"编译","slug":"编译","permalink":"/tags/编译/"}]},{"title":"前端编译原理-编译器流程","slug":"前端编译原理-编译器流程","date":"2022-12-30T02:44:56.000Z","updated":"2024-01-11T07:00:59.263Z","comments":true,"path":"2022/12/30/前端编译原理-编译器流程/","link":"","permalink":"/2022/12/30/前端编译原理-编译器流程/","excerpt":"简单介绍前端编译器的工作流程","text":"简单介绍前端编译器的工作流程 引言本篇文章主要针对前端的JSX语法标签进行编译解析。接下来将使用 Esprima 结合一个简单的 Demo 来实现串通整个编译器的工作流程。 解析阶段 (Parsing)首先，在编译器的初始阶段会接受一段代码，通常会是一串字符串。如下JSX代码：1&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt; 编译器拿到这段字符串代码之后会进入解析阶段，在解析阶段主要会做以下两件事：词法分析和语法分析 词法分析当编译器接受到上边的字符串时，首先会将传入的字符串按照词法效果分割成为一系列被称为 Token 的东西，这一步通常被称为分词。先来看看利用 Esprima Api 查看将上述代码进行词法分析后的结果。12345// parse1.jsconst esprima = require(&apos;esprima&apos;);// 配置支持jsx和tokens 利用parseScript Api 打印对应的tokensconst &#123; tokens &#125; = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true, tokens: true &#125;);console.log(tokens,&apos;tokens&apos;) 此时上方的语句经过词法分析会被一步一步拆分成为这样的结构：123456789101112131415161718192021[ &#123;&quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;&lt;&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;id&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;=&quot;&#125;, &#123;&quot;type&quot;: &quot;String&quot;,&quot;value&quot;: &quot;\\&quot;app\\&quot;&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Hello&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Jue Jin&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;, &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;, &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;] 可以看到针对上方传入的 JSX 语法被解析成为了一个 Token 组成的数组，数组中每一个对象即代表一个 Token 。每个 Token 都是拥有对应的 type 属性表示它的类型以及 value 属性表示它的值。这一步通过解析阶段的词法分析将传入的代码分割成为了一个个 Token ，通常使用有限状态机是词法分析的最佳途径。 语法分析上一步通过词法分析将输入的代码分割成为了一个 tokens 的数组，在这之后需要将 tokens 进行语法分析从而转化成为真正的抽象语法树（AST）形式。所谓抽象语法树，你可以将它理解成为一颗圣诞树。上述 tokens 中每一个 token 都可以看作成为该圣诞树中的一个节点。语法分析正式将上述分成的每个 Token 抽象成为一棵树，从而描述每个 Token 节点之间的关系。12345// parse2.jsconst esprima = require(&apos;esprima&apos;);// 调用parseScript获得输入代码生成的抽象语法树const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);console.log(ast, &apos;ast&apos;) 上述的 Token 在经过语法分析后会变成这样的数据结构：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [&#123; &quot;type&quot;: &quot;ExpressionStatement&quot;, &quot;expression&quot;: &#123; &quot;type&quot;: &quot;JSXElement&quot;, &quot;openingElement&quot;: &#123; &quot;type&quot;: &quot;JSXOpeningElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;div&quot; &#125;, &quot;selfClosing&quot;: false, &quot;attributes&quot;: [&#123; &quot;type&quot;: &quot;JSXAttribute&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;id&quot; &#125;, &quot;value&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;app&quot;, &quot;raw&quot;: &quot;\\&quot;app\\&quot;&quot; &#125; &#125;] &#125;, &quot;children&quot;: [&#123; &quot;type&quot;: &quot;JSXElement&quot;, &quot;openingElement&quot;: &#123; &quot;type&quot;: &quot;JSXOpeningElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;p&quot; &#125;, &quot;selfClosing&quot;: false, &quot;attributes&quot;: [] &#125;, &quot;children&quot;: [&#123; &quot;type&quot;: &quot;JSXText&quot;, &quot;value&quot;: &quot;Hello&quot;, &quot;raw&quot;: &quot;Hello&quot; &#125;], &quot;closingElement&quot;: &#123; &quot;type&quot;: &quot;JSXClosingElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;p&quot; &#125; &#125; &#125;, &#123; &quot;type&quot;: &quot;JSXText&quot;, &quot;value&quot;: &quot;Jue Jin&quot;, &quot;raw&quot;: &quot;Jue Jin&quot; &#125;], &quot;closingElement&quot;: &#123; &quot;type&quot;: &quot;JSXClosingElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;div&quot; &#125; &#125; &#125; &#125;], &quot;sourceType&quot;: &quot;script&quot;&#125; 所谓的语法分析阶段其实就是将 Tokens 经过一系列语法分析成为这颗树，树中的每个节点都会保存各自节点对应的信息。同时因为树形的数据结构也很好的反应出了各个节点之间的关系。 转化阶段 (Transformaiton)编译器首先经过转移阶段后将输入的代码转变成为 AST 。之后会进入转化阶段，所谓转化阶段本质上就是对于抽象语法树的一个深度遍历过程。在转化阶段，会遍历这颗抽象语法树从而对于匹配节点进行增删改查从而修改树形结构。比如想为 p 节点上添加一个 id 为 text 的属性，那么此时在遍历 AST 的过程中遍历到对应节点时修改对应的节点属性即可，当然也可以直接粗暴的替换整个节点。 关于 Estraverse ，它是针对 Esprima 生成的抽象语法树进行深度遍历的一个工具库。因为 Estraverse 这个库不支持 JSX 语法，所以这里使用它的一个拓展工具库 estraverse-fb 来实现 JSX 转化的抽象语法树的遍历。 123456789101112131415161718192021222324252627282930313233// transform.jsconst esprima = require(&apos;esprima&apos;);// 深度遍历AST的工具库const esTraverseFb = require(&apos;estraverse-fb&apos;)// 生成AST节点的工具const &#123; builders &#125; = require(&apos;ast-types&apos;)const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);// 深度优先的方式esTraverseFb.traverse(ast, &#123; // 进入每个节点时都会出发enter函数 enter: function (node) &#123; const &#123; type, openingElement &#125; = node // 判断当前进入的节点是否是匹配的p节点 if (type === &apos;JSXElement&apos; &amp;&amp; openingElement.name.name === &apos;p&apos;) &#123; // 生成当前需要添加的属性节点 const attribute = builders.jsxAttribute( // 第一个参数是name builders.jsxIdentifier(&apos;id&apos;), // 第二个参数是value builders.literal(&apos;text&apos;) ) // 为该节点的开始标签中添加生成的属性 id=&apos;text&apos; openingElement.attributes.push(attribute) &#125; &#125;, // 离开每个节点时会触发leave函数 leave: function () &#123; // nothing &#125;&#125;);console.log(ast); 此时经过上述的转化，我们更改了原本的 AST 结构。我们将原始的 p 标签对应的节点修改成为了这样的结构:1234567891011121314151617181920212223242526272829303132&#123; &quot;type&quot;: &quot;JSXElement&quot;, &quot;openingElement&quot;: &#123; &quot;type&quot;: &quot;JSXOpeningElement&quot;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;name&quot;: &quot;p&quot; &#125;, &quot;selfClosing&quot;: false, // 这里我们为attributes中添加了一个属性节点 &quot;attributes&quot;: [&#123; &quot;name&quot;: &#123; &quot;name&quot;: &quot;id&quot;, &quot;loc&quot;: null, &quot;type&quot;: &quot;JSXIdentifier&quot;, &quot;comments&quot;: null, &quot;optional&quot;: false, &quot;typeAnnotation&quot;: null &#125;, &quot;value&quot;: &#123; &quot;value&quot;: &quot;text&quot;, &quot;loc&quot;: null, &quot;type&quot;: &quot;Literal&quot;, &quot;comments&quot;: null, &quot;regex&quot;: null &#125;, &quot;loc&quot;: null, &quot;type&quot;: &quot;JSXAttribute&quot;, &quot;comments&quot;: null &#125;] &#125;&#125; 生成阶段 (Code Generation)上述经过解析阶段 (Parsing) 将输入的字符串转化成了抽象语法树 AST 结构。之后经过转化阶段 (Transformaiton) 对于生成的抽象语法树进行深度遍历节点，从而对于某些节点进行了修改。‘此时编译器拥有了经过处理后的抽象语法树，此时需要做的当然是将所谓的树形结构的抽象语法树转化成为新的代码。这一步通常称为生成阶段(Code Generation)：通过抽象语法树反向转化成为生成的代码，此时最新的代码是根据修改后的 AST 生成的代码。在生成阶段本质上就是遍历抽象语法树，根据抽象语法树上每个节点的类型和属性递归调用从而生成对应的字符串代码。在代码生成阶段，可以借助 EscodeGen 将 AST 转化成为新的字符串代码。 因为 EscodeGen 对于 JSX 语法并不支持，所以这里具体就不详细演示用法了，有兴趣的朋友可以自行尝试。 上方将代码修改的抽象语法树会生成新的代码：1&lt;div id=&quot;app&quot;&gt;&lt;p id=&quot;text&quot;&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt; 总结综上所述，一次编译器工作流程中包括解析、转化、生成这三个步骤。如果自己想实现，请参考本站的【tiny编译工具】上面例子代码","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"编译","slug":"编译","permalink":"/tags/编译/"}]},{"title":"\\r与\\n区别","slug":"r与-n区别","date":"2022-12-26T06:30:06.000Z","updated":"2024-01-11T07:00:59.229Z","comments":true,"path":"2022/12/26/r与-n区别/","link":"","permalink":"/2022/12/26/r与-n区别/","excerpt":"\\r回车与\\n换行的区别","text":"\\r回车与\\n换行的区别 回车和换行来源在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意儿，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。这就是”回车”和”换行”的来历，从它们的英语名字上也可以看出一二。 区别\\r是回车，英文是Carriage return，缩写是CR，作用：使光标到行首。\\n是换行，英文是New line/line feed，缩写是LF，作用：使光标下移一行。 如果用过机械打字机，就知道回车和换行的区别了。回车就是把水平位置复位，不卷动滚筒。换行就是把滚筒卷一格，不改变水平位置。我们平时所说的键盘Enter键换行实则应该叫做叫做回车换行(\\r\\n) 影响✪ Windows系统里面，每行结尾是 回车+换行(CR+LF)，即“\\r\\n”；✪ Unix系统里，每行结尾只有 换行CR，即“\\n”；✪ Mac系统里，每行结尾是 回车CR 即’\\r’；直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 兼容处理在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化。如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"javascript常用中英文惯译法","slug":"javascript常用中英文惯译法","date":"2022-12-06T03:07:18.000Z","updated":"2024-01-11T07:00:59.195Z","comments":true,"path":"2022/12/06/javascript常用中英文惯译法/","link":"","permalink":"/2022/12/06/javascript常用中英文惯译法/","excerpt":"javascript常用中英文惯译法","text":"javascript常用中英文惯译法 语法或词法分析 标识符（identifier）标签（label）关键字，保留字（keyword,reserved words）符号（symbol）标记，记号（token）数据类型（types,data types）无类型的（untype-）变量（variable）声明（declare）赋值（assignment）解构赋值（destructuring assignment）未赋值变量（unassigned variable）未声明变量（undeclared variable）值（values）常量，常数，常值（constant,const）直接量，字面量（literal,literal constant,manifest constant）指数计数法，科学计数法（exponential notation）定点计数法（fixed-point notation）代码逻辑行，物理行（logical line,physical line）语句（statements）语句块（statement block）简单语句（simple statements）单行语句（single line statements）复合语句（compound statements）条件（condition）表达式（expression）一元运算符，单目运算符（unary operator）二元运算符（binary operator）运算符优先级（precedence）运算符，操作符，操作数（operator） 数据结构 数组（array）关联数组（associative array）索引数组（index array）多维数组（multidimensional array）动态数组（dynamic arry）变长数组（variable length array）元素（element）索引，下标（index）字符串（string）Unicode 字符串（Unicode string）转义序列（escape sequence） 编程范型（面向对象，函数式等） 编程范型（programming paradigm）多范型语言（multi-paradigm language）动态绑定（dynamic bind）作用域（scope）引用（reference）域，成员，字段（member,field）类（class）继承（inheritance）多态（polymorphism）封装（encapsulation）类方法（class method）虚方法（virtual method）纯虚方法，抽象方法（abstract method）覆盖（override）对象（object）实例（instance）原型（prototype）构造器，构造函数（constructor,constructor function）属性（property）方法（method）用户定义属性（user-defined properties）预定义属性（pre-defined properties）内部（内建）属性/方法/成员（build-in properties/method/member）事件（event）事件句柄，事件处理器，事件处理代码（event handle）特性，性质，属性（attribute）特性（feature）函数（function）参数（arguments）外部局部变量（external local variable,upvalue）lambda运算（lambda calculus）闭包（closure） 编译、执行及其他 解释器（interpreter）运行期（runtime）宿主（host）上下文（context）环境（environment）执行环境，执行上下文（execution context）异常（exception）错误（error）正则表达式（regular expression）全局（global）局部（local）全局对象（global object）全局变量（global variable）局部变量（local variable）","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"GPU和CSS硬件加速","slug":"GPU和CSS硬件加速","date":"2022-10-21T06:38:55.000Z","updated":"2024-01-11T07:00:59.118Z","comments":true,"path":"2022/10/21/GPU和CSS硬件加速/","link":"","permalink":"/2022/10/21/GPU和CSS硬件加速/","excerpt":"彻底搞懂GPU和CSS硬件加速","text":"彻底搞懂GPU和CSS硬件加速 从 cpu 聊起cpu (central process) 是计算机的大脑，它提供了一套指令集，我们写的程序最终会通过 cpu 指令来控制的计算机的运行。 cpu 会对指令进行译码，然后通过逻辑电路执行该指令。整个执行的流程分为了多个阶段，叫做流水线。指令流水线包括取指令、译码、执行、取数、写回五步，这是一个指令周期。cpu 会不断的执行指令周期来完成各种任务。 指令和数据都会首先加载到内存中，在程序运行时依次取到 cpu 里。cpu 访问内存虽然比较快，但比起 cpu 执行速度来说还是比较慢的，为了缓解这种速度矛盾，cpu 设计了 3 级缓存，也就是 L1、L2、L3 的缓存。如图，多核 cpu 各核心都有自有独立的 L1、L2 缓存，然后共享 L3 缓存，这 3 级缓存容量是逐渐递增的，但是速度是逐渐下降的，但是也会比访问内存快一些。 有了这 3 级缓存以后，cpu 执行速度和访问内存速度的矛盾就可以得到缓解，不需要一直访问内存，cpu 每次会加载一个缓存行，也就是 64 字节大小的数据到缓存中。这样访问临近的数据的时候就可以直接访问缓存。 从内存中把数据和指令加载到 cpu 的缓存中，然后通过控制器控制指令的译码、执行，通过运算器进行运算，之后把结果写回内存。这就是 cpu 的工作流程。 cpu 每个核只有一个线程，也就是单控制流、单数据流。这样的架构导致 cpu 在一些场景下效率是不高的，比如 3d 渲染的场景。 3d 渲染流程3d 的渲染首先是建立 3d 的模型，它由一系列三维空间中的顶点构成，3 个顶点构成一个三角形，然后所有的顶点构成的三角形拼接起来就是 3d 模型。顶点、三角形，这是 3d 的基础。3d 引擎首先要计算顶点数据，确定 3d 图形的形状。之后还要对每个面进行贴图，可以在每个三角形画上不同的纹理。 3d 图形要显示在二维的屏幕上就要做投影，这个投影的过程叫做光栅化。（光栅是一种光学仪器，在这里就代表 3d 投影到 2d 屏幕的过程）光栅化要计算 3d 图形投影到屏幕的每一个像素的颜色，计算完所有的像素之后会写到显存的帧缓冲区，完成了一帧的渲染，之后会继续这样计算下一帧。 也就是说，3d 渲染的流程是： 计算顶点数据，构成 3d 的图形给每个三角形贴图，画上纹理投影到二维的屏幕，计算每个像素的颜色（光栅化）把一帧的数据写入显存的帧缓冲区 顶点的数量是非常庞大的，而 cpu 只能顺序的一个个计算，所以处理这种 3d 渲染会特别费劲，于是就出现了专门用于这种 3d 数据的并行计算的硬件，也就是 GPU。 GPU 的构成和 cpu 的一个一个数据计算不同，gpu 是并行的，有成百上千个核心用于并行计算。gpu 也是有着指令、译码、执行的流程，只不过，每个指令会并行执行 n 个计算，是单控制流多数据流的，而 cpu 是单控制流单数据流。 所以，对于 3d 渲染这种要计算成万个顶点数据和像素点的场景，GPU 会比 CPU 高效很多。 但是，gpu 全是优点么？也不是。 cpu 和 gpu 的区别cpu 是通用的，能够执行各种逻辑和运算，而 gpu 则是主要是用于并行计算大批量的重复任务，不能处理复杂逻辑。 如上图，cpu 中控制器和缓存占据了很大一部分，而 gpu 中这两部分则很少，但是有更多的核心用于计算。 两者对比的话，cpu 相当于一个大学生，能够解决各种难题，但是计算 1 万个加法就没那么快，而 gpu 就像一帮小学生，解决不了难题，但是计算加法这种就很快，因为人多。 也就是说如果逻辑复杂，那么只能用 cpu，如果只是计算量大，并且每个计算都比较重复，那就比较适合 gpu。 3d 的渲染中有大量这种重复却简单的计算，比如顶点数据和光栅化的像素数据，通过 gpu 就可以并发的一次计算成百上千个。 opengl、webgl、css 硬件加速显卡中集成了 gpu，提供了驱动，使用 gpu 能力需要使用驱动的 api。 gpu 的 api 有一套开源标准叫做 opengl，有三百多个函数，用于各种图形的绘制。（在 windows 下有一套自己的标准叫做 DirectX） 我们在网页中绘制 3d 图形是使用 webgl 的 api，而浏览器在实现 webgl 的时候也是基于 opengl 的 api，最终会驱动 gpu 进行渲染。 css 大部分样式还是通过 cpu 来计算的，但 css 中也有一些 3d 的样式和动画的样式，计算这些样式同样有很多重复且大量的计算任务，可以交给 gpu 来跑。 浏览器在处理下面的 css 的时候，会使用 gpu 渲染： transformopacityfilterwill-change 浏览器是把内容分到不同的图层分别渲染的，最后合并到一起，而触发 gpu 渲染会新建一个图层，把该元素样式的计算交给 gpu。 opacity 需要改变每个像素的值，符合重复且大量的特点，会新建图层，交给 gpu 渲染。transform 是动画，每个样式值的计算也符合重复且大量的特点，也默认会使用 gpu 加速。同理 fiter 也是一样。 这里要注意的是 gpu 硬件加速是需要新建图层的，而把该元素移动到新图层是个耗时操作，界面可能会闪一下，所以最好提前做。will-change 就是提前告诉浏览器在一开始就把元素放到新的图层，方便后面用 gpu 渲染的时候，不需要做图层的新建。 当然，有的时候我们想强制触发硬件渲染，就可以通过上面的属性，比如1will-change: transform; 或者1transform:translate3d(0, 0, 0); chrome devtools 可以看到是 cpu 渲染还是 gpu 渲染，打开 rendering 面板，勾选 layer borders，会发现蓝色和黄色的框。蓝色的是 cpu 渲染的，而黄色的是 gpu 渲染的。 比如这段文字，现在没有单独一个图层：添加一个 will-change: transform 的属性，浏览器会新建图层来渲染该元素，然后使用 gpu 渲染：gpu 硬件加速能减轻 cpu 压力，使得渲染更流畅，但是也会增加内存的占用，对于 transform、opacity、filter 默认会开启硬件加速。其余情况，建议只在必要的时候用。 opencl 和神经网络重复且大量的计算任务只有 3d 渲染一种场景么？ 不是的，AI 领域的机器学习也很典型，它的特点是大量的神经元需要计算，但是每个计算都比较简单，也很适合用 gpu 来跑。 现在的 gpu 不只是能跑图形渲染，也提供了一些编程能力，这部分 api 有 opencl 标准。可以通过 gpu 的并行计算能力来跑一些有大量计算但是没有很多逻辑的的任务，会比 cpu 效率更高。 总结cpu 提供了指令集，会不断的执行取指令、译码、执行、取数、写回的指令周期，控制着计算机的运转。 cpu 计算的速度比较快，而访问内存比较慢，为了缓和两者的矛盾，引入了 L1、L2、L3 的多级缓存体系，L1、L2、L3 是容器逐渐变大，访问速度逐渐变慢的关系，但还是比访问内存快。内存会通过一个缓存行（64 字节）的大小为单位来读入缓存，供 cpu 访问。 3d 渲染的流程是计算每一个顶点的数据，连成一个个三角形，然后进行纹理贴图，之后计算投影到二维屏幕的每一个像素的颜色，也就是光栅化，最后写入显存帧缓冲区，这样进行一帧帧的渲染。 cpu 的计算是一个个串行执行的，对于 3d 渲染这种涉及大量顶点、像素要计算的场景就不太合适，于是出现了 gpu。 gpu 可以并行执行大量重复的计算，有成百上千个计算单元，相比 cpu 虽然执行不了复杂逻辑，但是却能执行大量重复的运算。提供了 opengl 的标准 api。 css 中可以使用 gpu 加速渲染来减轻 cpu 压力，使得页面体验更流畅，默认 transform、opacity、filter 都会新建新的图层，交给 gpu 渲染。对于这样的元素可以使用 will-change: 属性名; 来告诉浏览器在最开始就把该元素放到新图层渲染。 gpu 的并行计算能力不只是 3d 渲染可以用，机器学习也有类似的场景，可以通过 opencl 的 api 来控制 gpu 进行计算。 gpu 和前端的关系还是挺密切的，不管是 webgl，还是 css 硬件加速，或者网页的性能都与之相关。希望这篇文章能够帮大家了解 gpu 的原理和应用。","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"},{"name":"3D","slug":"3D","permalink":"/tags/3D/"},{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"css中的单位","slug":"css中的单位","date":"2022-10-21T05:39:28.000Z","updated":"2024-01-11T07:00:59.179Z","comments":true,"path":"2022/10/21/css中的单位/","link":"","permalink":"/2022/10/21/css中的单位/","excerpt":"css中的一些单位","text":"css中的一些单位说起CSS单位，我们最熟悉的可能就是像素单位（px），它是一个绝对单位，也就是说一个10px的文字，放在哪里都是一样大的。单位可以影响颜色、距离、尺寸等一系列的属性。CSS中单位的形式有很多种，下面就分别来看看这些单位。 相对单位相对单位就是相对于另一个长度的长度。CSS中的相对单位主要分为两大类： 字体相对单位，他们都是根据font-size来进行计算的。常见的字体相对单位有：em、rem、ex、ch；视窗相对单位，他们都是根据视窗大小来决定的。常见的视窗相对单位有vw、vh、vmax、vmin。 em 和 rememem是最常见的相对长度单位，适合基于特定的字号进行排版。根据CSS的规定，1em 等于元素的font-size属性的值。em 是相对于父元素的字体大小进行计算的。如果当前对行内文本的字体尺寸未进行显示设置，则相对于浏览器的默认字体尺寸。当DOM元素嵌套加深时，并且同时给很多层级显式的设置了font-size的值的单位是em，那么就需要层层计算，复杂度会很高。如果自身元素是没有设置字体大小的，那么就会根据其父元素的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算。em单位除了可以作用于 font-size之外，还可以运用于其他使用长度的属性，比如border-width、width、height、margin、padding、text-shadow等。所以，em的使用还是比较复杂的，它可能会继承任意一级父元素的字体大小。需要谨慎使用。 remrem相对于em就简单了很多，它是根据页面的根元素（根元素）的字体大小来计算的。如果没有对根元素设定字号的话，font-size: 1rem的作用与font-size: initial相同。 小总结使用 em 和 rem 可以让我们灵活的够控制元素整体的放大和缩小，而不是固定大小。那何时应使用 em，何时应使用 rem 呢？可以根据两者的差异来进行选择： 两者在客户端中计算出来的样式都会以px的形式显示；rem是相对于根元素html的font-size计算，em 相对于元素的font-size计算；当需要根据浏览器的font-size设置缩放时，应该使用 rem；使用 em 应该根据组件的font-size来定，而不是根元素的font-size来定；rem 可以从浏览器字体设置中继承 font-size 值， em 可能受任何继承过来的父元素 font-size 的影响。 ex 和 chex 和 ch 都是排版用的单位，它们的大小取决于元素的font-size 和 font-family属性。 ex 指的是所用字体中小写字母 x 的高度。因此，如果两个字体不一样，那么 ex 的值是不一样的。因为每种字体的小写 x 的高度是不一样的。ch 和 ex 类似，不过它是基于数字 0 的宽度计算的。会随着字体的变化而变化。而0 的宽度通常是对字体的平均字符宽度，它是一个估计值。由于 ch 是一个近似等宽的单元，所以在设置容器的宽度时很有用，比如一个容器想要显示指定个数的字符串时，就可以使用这个单位。 vw、vh、vmax 和 vmin这四个单位都是视窗单位，所谓的视窗，在web端指的就是可视区域，移动端的视窗指的就是布局视窗。如果视窗大小发生了变化，那么这些值都会随之变化。这四个单位指的是： vw：视窗宽度的百分比；vh：视窗高度的百分比；vmax：较大的 vh 和 vw；vmin：较小的 vh 和 vw。 假如一个浏览器的高度是800px，那么1vh的值就是8px。vh和vw的大小总是和视窗的高度和宽度有关。 ​vmin 和 vmax 与视窗宽度和高度的最大值和最小值有关。假如一个浏览器高度为500px，宽度为1200px，那么1vmin就是5px，1vmax就是12px。 绝对单位在 CSS 中，绝对单位包括： px 、pt 、pc、 cm 、 mm 、in 等。绝对单位是一个固定的值，它反应了一个真实的物理尺寸。它不会受屏幕大小或者字体的影响。它们的大小取决于值以及屏幕的分辨率（DPI，每英寸的点数）。px就是我们最常用的绝对单位之一。这些绝对单位的换算关系如下：11in = 25.4mm = 2.54cm = 6pc = 72pt =96px pxpx 全称为 Pixels，表示像素，它并不严格等于显示器的像素，尤其在高清屏下。尽管CSS单位会根据浏览器、操作系统或者硬件适当缩放，在某些设备或者用户的分辨率设置下也会发生变化，但是96px通常等于一个物理英寸的大小。CSS 将光栅图像(如照片等)的显示方式定义为默认每一个图像大小为1px。 一个“600x400”解析度的照片的长宽分别为“600px”和“400px”，所以照片本身的像素并不会与显示装置像素一致，而是与 px 单位一致。如此就可以将图像完整的与网页的其它元素排列起来。 ​很多时候， px 也常被称为 CSS 像素。它是一个绝对单位，但也可以被视为相对单位，因为像素单位相对的是设备像素。在同一个设备上，每 1 个 CSS 像素所代表的物理像素是可以变化的；在不同的设备之间，每 1 个 CSS 像素所代表的物理像素是可以变化的。 ptpt 全称为 Point，表示点。常用于软件设计和排版印刷行业（笔者做的前端系统，最终的产物就是一个需要拿去印刷的PDF，所以会经常用到这个单位）。当使用这个单位时，无论显示器的分辨率是多少，打印在纸上的结果都是一样的。 ​如果单纯为了网页的显示，建议就使用px像素单位，如果需要输出印刷产品，就可以考虑使用pt。 pcpc 全程为 Picas，表示派卡。相当于我国新四号铅字的尺寸。派卡也是印刷的术语，1派卡等于12点。它和 px 的换算关系如下：11pc = 16px cmcm 全称为 Centimeters，表示厘米。它和 px 的换算关系如下：11cm = 37.8px mmmm 全称为 Millimeters，表示毫米。它和 px 的换算关系如下：11mm = 3.78px inin 全称为 Inches，表示英寸。它和 px 的换算关系如下：11in = 96px 频率单位CSS中的频率单位有两个：赫兹（Hz）和千赫兹（kHz）。它们的换算关系如下：11kHz = 1000Hz 通常情况下，频率单位使用在听或说级联样式表中。频率可以被用来改变一个语音阅读文本的音调。低频率就是低音，高频率就是高音。需要注意，当数值为0时，单位对值没有影响，但是单位是不能省略的。也就是说0、0Hz、0kHz是不一样的。所以，在使用频率单位时，不要直接写0。另外，这两个单位是不区分大小写的。 时间单位CSS中的时间单位有两个：秒（s）和毫秒（ms）。这两个时间单位都是CSS新增的单位。这两个单位的换算关系如下：11s = 1000ms 时间单位主要用于过度和动画中，用于定义持续时间或延迟时间。 分辨率单位CSS中的分辨率单位有三个：dpi、dpcm、dppx。这三个单位都是CSS3中华新增的单位。他们都是正值，不允许为负值。这三个单位的换算关系如下：1231dppx = 96dpi1dpi ≈ 0.39dpcm1dpcm ≈ 2.54dpi 分辨率单位主要用于媒体查询等操作。 dpidpi 全称为 dots per inch，表示每英寸包含的点的数量。普通屏幕通常包含 72或96个点，大于 192dpi 的屏幕被称为高分屏。12@media screen and (min-resolution: 96dpi) &#123; ... &#125;@media print and (min-resolution: 300dpi) &#123; ... &#125; dpcmdpcm 全称为 dots per centimeter，表示每厘米包含的点的数量。12@media screen and (min-resolution: 28dpcm) &#123; ... &#125;@media print and (min-resolution: 118dpcm) &#123; ... &#125; dppxdppx 全称为 dots per pixel，表示每像素（px）包含点的数量。由于CSS px的固定比率为1:96，因此1dppx相当于96dpi。它对应于由图像分辨率定义的CSS中显示的图像的默认分辨率。12@media screen and (min-resolution: 2dppx) &#123; ... &#125;@media screen and (min-resolution: 1dppx) and (max-resolution: 1.9dppx) &#123; ... &#125; 角度单位CSS中的角度单位有四个：deg、grad、rad、turn。这些角度单位都是CSS3中新增的单位。它们的换算关系如下：190deg = 100grad = 0.25turn ≈ 1.570796326794897rad 一般这些角度单位用于元素的旋转操作，包括2D旋转、3D旋转等。 当旋转值为正值时，元素会顺时针旋转；当旋转值为负值时，元素会逆时针旋转。 通常情况下，一个完整的旋转就是360度。所以，所有的角度都在0-360度之间。但是，超出这个范围的值也是允许的，只不过都会归到0-360度之间。比如，顺时针旋转450度（450deg）、逆时针旋转270度（-270deg）、顺时针旋转90度（90deg）都是一样的效果，都会归为90deg。但是当使用动画时，这些角度值就非常重要了。CSS的旋转主要依赖于 transform 属性中的 rotate() 、rotate3d、 skew() 等方法。只需给它们传递旋转的角度即可。 ​除了旋转会使用角度之外，线性渐变也会经常使用角度值：1background: linear-gradient(45deg, #000, #fff); degdeg 全称为 Degress，表示度，一个圆总共360度。1transform: rotate(2deg); gradgrad 全称为 Gradians，表示梯度，一个圆总共400梯度。1transform: rotate(2grad); radrad 全称为 Radians，表示弧度，一个圆总共2π弧度。1transform: rotate(2rad); turnturn 全称为 Turns，表示圈（转），一个圆总共一圈（转）。1transform:rotate(.5turn); 百分比单位百分比（%）也是我们比较常用的单位之一，所有接受长度值的属性都可以使用百分比单位。但是不同属性使用该单位的效果可能并不一样。但是都需要有一个参照值，也就是说百分比值是一个相对的值。 ​ 盒模型中的百分比在CSS中的盒模型包含的属性有：width、max-width、min-width、height、max-height、min-height、padding、margin等。这些属性在使用百分比时，参照物不尽相同： width、max-width、min-width：值为百分比时，其相对于包含块的 width 进行计算；height、max-height、min-height：值为百分比时，其相对于包含块的 height 进行计算；padding、margin：值为百分比时，如果是水平的值，就是相对于包含块的 width 进行计算；如果是垂直的值，也是相对于包含块的 width 进行计算。 文本中的百分比在CSS中文本控制的属性有font-size、line-height 、vertical-align、 text-indent等。这些属性在使用百分比时，参照物不尽相同： font-size：根据父元素的font-size 进行计算；line-height：根据font-size进行计算；vertical-align：根据line-height进行计算；text-indent：如果是水平的，则根据width进行计算，如果是垂直的，则根据 height 进行计算。 定位中的百分比在CSS中用控制 position 位置的top、right、bottom、left都可以使用百分比作为单位。其参照物就是包含块的同方向的width和height。不同定位的包含块不尽相同： 如果元素为静态（ static ）或相对定位（ relative ），包含块一般是其父容器；如果元素为绝对定位（ absolute ），包含块应该是离它最近的 position 为 absolute 、 relative 或 fixed 的祖先元素；如果元素为固定定位（ fixed ），包含块就是视窗（ viewport ）。 变换中的百分比CSS 中的 transform 属性中的 translate 和 transform-origin 值也可以设置百分比。 translateX() 根据容器的 width 计算translateY() 根据容器的 height 计算transform-origin 中横坐标（ x ）相对于容器的 width 计算；纵坐标（ y ）相对于容器的 height 计算 注意，在 translate 还有一个 z 轴的函数 translateZ() 。它是不接受百分比为单位的值。","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"github工作流","slug":"github工作流","date":"2022-10-14T03:21:29.000Z","updated":"2024-01-11T07:00:59.181Z","comments":true,"path":"2022/10/14/github工作流/","link":"","permalink":"/2022/10/14/github工作流/","excerpt":"常用的一种github工作流","text":"常用的一种github工作流 1.git clone // 到本地2.git checkout -b xxx 切换至新分支xxx（相当于复制了remote的仓库到本地的xxx分支上3.修改或者添加本地代码（部署在硬盘的源文件上）4.git diff 查看自己对代码做出的改变5.git add 上传更新后的代码至暂存区6.git commit 可以将暂存区里更新后的代码更新到本地git7.git push origin xxx 将本地的xxxgit分支上传至github上的git （如果在写自己的代码过程中发现远端GitHub上代码出现改变）1.git checkout main 切换回main分支2.git pull origin master(main) 将远端修改过的代码再更新到本地3.git checkout xxx 回到xxx分支4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上（-f —》强行）6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit 远端完成更新后1.git branch -d xxx 删除本地的git分支2.git pull origin master 再把远端的最新代码拉至本地 视频教程地址","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"企业信息化常用系统","slug":"企业信息化常用系统","date":"2022-10-12T03:15:40.000Z","updated":"2024-01-11T07:00:59.242Z","comments":true,"path":"2022/10/12/企业信息化常用系统/","link":"","permalink":"/2022/10/12/企业信息化常用系统/","excerpt":"企业信息化常用系统的英文缩写","text":"企业信息化常用系统的英文缩写 企业资源计划（ERP） 客户关系管理（CRM） 供应链管理（SCM） 商业智能（BI） 决策支持系统（DSS） 业务流程重组（BPR） 业务流程管理（BPM） 企业应用集成（EAI） 企业门户 电子政务与电子商务简称 政府 Government 企业 Business 公民 Citizen 线上 Online 线下 Offline G2G G2B B2C C2C等 O2O","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"软考","slug":"软考","permalink":"/tags/软考/"}]},{"title":"h5禁止微信字体设置","slug":"h5禁止微信字体设置","date":"2022-10-10T02:28:42.000Z","updated":"2024-01-11T07:00:59.188Z","comments":true,"path":"2022/10/10/h5禁止微信字体设置/","link":"","permalink":"/2022/10/10/h5禁止微信字体设置/","excerpt":"解除微信字体大小设置，对h5页面的影响","text":"解除微信字体大小设置，对h5页面的影响在开发微信公众号，或者用微信打开一个h5页面，如果调整了微信的字体大小，页面的布局会发生改变，这样就做不到统一。IOS和安卓用不同的方法禁止了微信字体的调整，见下例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;微信字体大小设置&lt;/title&gt;&lt;/head&gt;&lt;style&gt; /* iOS禁止微信调整字体大小 */ body &#123; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; -moz-text-size-adjust: 100% !important; &#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;h1字体大小测试微信&lt;/h1&gt; &lt;h2&gt;h2字体大小测试微信&lt;/h2&gt; &lt;h3&gt;h3字体大小测试微信&lt;/h3&gt; &lt;h4&gt;h4字体大小测试微信&lt;/h4&gt; &lt;h5&gt;h5字体大小测试微信&lt;/h5&gt; &lt;h6&gt;h6字体大小测试微信&lt;/h6&gt; &lt;div style=&quot;font-size:14px;&quot;&gt;div字体大小测试微信px&lt;/div&gt; &lt;div style=&quot;font-size:2rem;&quot;&gt;div字体大小测试微信rem&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 对安卓手机有效 // 强制禁止用户修改微信客户端的字体大小 (function() &#123; if (typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot;) &#123; handleFontSize(); &#125; else &#123; if (document.addEventListener) &#123; document.addEventListener(&quot;WeixinJSBridgeReady&quot;, handleFontSize, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(&quot;WeixinJSBridgeReady&quot;, handleFontSize); document.attachEvent(&quot;onWeixinJSBridgeReady&quot;, handleFontSize); &#125; &#125; function handleFontSize() &#123; // 设置网页字体为默认大小 WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;); // 重写设置网页字体大小的事件 WeixinJSBridge.on(&apos;menu:setfont&apos;, function() &#123; WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;); &#125;); &#125; &#125;)(); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"微信","slug":"微信","permalink":"/tags/微信/"}]},{"title":"canvas-html属性width与css的width区别","slug":"canvas-html属性width与css的width区别","date":"2022-09-15T06:45:32.000Z","updated":"2024-01-11T07:00:59.177Z","comments":true,"path":"2022/09/15/canvas-html属性width与css的width区别/","link":"","permalink":"/2022/09/15/canvas-html属性width与css的width区别/","excerpt":"canvas中标签属性的width，height与css的width，height的区别","text":"canvas中标签属性的width，height与css的width，height的区别canvas中，如果不写width和height，会默认width=300，height=150。 标签属性中的width和height可以理解为虚拟画布的宽高，比如设置width=3000，height=1000，在js中对其进行绘图时，都是在这个宽3000，高1000的画布上进行绘制。而css的width和height是绘制好的这块画布在实际的页面中显示的具体宽高，可以把画布理解为一张宽3000，高1000的图片，当设置其css宽高时，这张图片会根据实际的宽高进行变化。 附上一段代码，可以更改width和height观察其变化1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;canvas&lt;/title&gt;&lt;/head&gt;&lt;style&gt; canvas &#123; border: 1px solid blue; width: 300px; height: 300px; &#125;&lt;/style&gt;&lt;body&gt; &lt;canvas id=&quot;mycanvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;浏览器不支持Canvas,请升级或改用其它浏览器！&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;), ctx = canvas.getContext(&apos;2d&apos;); ctx.moveTo(0,0); ctx.lineTo(300,150); ctx.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"/tags/canvas/"}]},{"title":"微信公众号开发","slug":"微信公众号开发","date":"2022-09-05T06:31:44.000Z","updated":"2024-01-11T07:00:59.266Z","comments":true,"path":"2022/09/05/微信公众号开发/","link":"","permalink":"/2022/09/05/微信公众号开发/","excerpt":"微信公众号开发简介","text":"微信公众号开发简介微信公众号开发比较繁琐，先来看一下大致架构：服务器鉴权这块，应该是比较难的。这里有两个需要鉴权的地方，一个是基本配置里的URL接入鉴权，另一个是JS-SDK的鉴权。 URL接入鉴权上图中的这个URL是微信公众平台接入到自己的后台服务器的接口鉴权，URL可以写成这样http://jinux.top/weixinapi。看一看微信公众平台的定义： 开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：1）将token、timestamp、nonce三个参数进行字典序排序2）将三个参数字符串拼接成一个字符串进行sha1加密3）开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信 官网文档地址验证signature的示例代码12345678910111213function checkSignature() &#123; let &#123; signature, timestamp, nonce, echostr &#125; = req.query; let token = &apos;testweixin&apos;; // 这个token是上图中的填写的Token let array = [timestamp, nonce, token]; array.sort(); // 字典排序 let str = array.join(&apos;&apos;); let resultStr = sha1(str); // 对字符串进行sha1加密，需要const sha1 = require(&apos;sha1&apos;) if(resultStr === signature) &#123; res.send(echostr); &#125;else &#123; res.send(&apos;Error&apos;); &#125;&#125; JS-SDK使用官方文档地址js-sdk使用流程图：在网页中调用微信赋予的功能时，需要config 接口注入权限验证配置：12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名 jsApiList: [] // 必填，需要使用的 JS 接口列表&#125;); timestamp, nonceStr, signature需要后台生成。接下来，看一下生成流程 获取ticket123456789async function getTicket() &#123; let tokenUrl = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`; let token_data = await axios.get(tokenUrl); let access_token = token_data.data.access_token; // 得到access_token let ticketUrl = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=$&#123;access_token&#125;&amp;type=jsapi`; let ticket_data = await axios.get(ticketUrl); let ticket = ticket_data.data.ticket; // 获取jsp_ticket return ticket;&#125; 生成nonceStr123function createNonceStr() &#123; return Math.random().toString(36).subStr(2, 15);&#125; 生成timestamp123function createTimestamp() &#123; return parseInt(new Date().getTime() / 1000) + &apos;&apos;;&#125; 生成signature 签名生成规则如下：1）参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。2）对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用 URL 键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1。3）这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。 1234567891011121314151617181920212223242526272829// 处理数据格式function row(obj) &#123; let keys = Object.keys(obj); keys = keys.sort(); // 字典排序 let newObj = &#123;&#125;; keys.forEach(key=&gt; &#123; newObj[key] = obj[key]; &#125;); let string = &apos;&apos;; for(let k in newObj) &#123; string += &apos;&amp;&apos; + k + &apos;=&apos; + newObj[k]; &#125; string = string.subStr(1); return string;&#125;// 生成signature签名方法async function getSignature(url) &#123; let jsapi_ticket = await getTicket(); var obj = &#123; jsapi_ticket, nonceStr: createNonceStr(), timestamp: createTimestamp(), url &#125; let str = row(obj); let signature = sha1(str); obj.signature = signature; return obj;&#125; 人脸识别认证微信是提供了人脸识别验证接口的，该接口目前是免费的，并且是适用公众号的。由于该接口属于未开放接口，所以在微信JS-SDK说明文档是无法查看到该接口文档的，需要写邮件给腾讯进行申请审核，如果申请通过，腾讯会回复邮件，开通对应公众号的调用权限，并会发送接口文档。开通人脸识别方法 总结以上只是简单的列举了URL接入鉴权和JS-SDK的鉴权，这两个也是公众号中最繁琐的地方。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"微信","slug":"微信","permalink":"/tags/微信/"}]},{"title":"nodejs path模块详解","slug":"nodejs-path模块详解","date":"2022-08-23T02:50:19.000Z","updated":"2024-01-11T07:00:59.225Z","comments":true,"path":"2022/08/23/nodejs-path模块详解/","link":"","permalink":"/2022/08/23/nodejs-path模块详解/","excerpt":"nodejs的path模块用法","text":"nodejs的path模块用法nodejs的path模块包含一系列处理和转换文件路径的工具集 normalize规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠12345678console.log(path.normalize(&apos;a/b/c/../user/bin&apos;));// a\\b\\user\\binconsole.log(path.normalize(&apos;a/b/c///../user/bin/&apos;));// a\\b\\user\\bin\\console.log(path.normalize(&apos;a/b/c/../../user/bin&apos;));// a\\user\\binconsole.log(path.normalize(&apos;a/b/c/.././///../user/bin/..&apos;));// a\\userconsole.log(path.normalize(&apos;a/b/c/../../user/bin/../../&apos;));// a\\console.log(path.normalize(&apos;a/../../user/bin/../../&apos;));// ..\\console.log(path.normalize(&apos;a/../../user/bin/../../../../&apos;));// ..\\..\\..\\console.log(path.normalize(&apos;./a/.././user/bin/./&apos;));// user\\bin\\ joinpath.join([path1], [path2], […])将多个路径结合在一起，并转换为规范化路径1234console.log(path.join(&apos;////./a&apos;, &apos;b////c&apos;, &apos;user/&apos;));// \\a\\b\\c\\userconsole.log(path.join(&apos;./a&apos;, &apos;b//c&apos;, &apos;user&apos;));// a\\b\\c\\userconsole.log(path.join(&apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// ..\\user\\console.log(path.join(__dirname, &apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// E:\\jinux\\node\\study\\user\\ resolve从源地址 from 到目的地址 to 的绝对路径 类似在shell里执行一系列的cd命令path.resolve(‘foo/bar’, ‘/tmp/file/‘, ‘..’, ‘a/../subfile’)类似于:cd foo/barcd /tmp/file/cd ..cd a/../subfilepwd[注意]如果某个from或to参数是绝对路径（比如 ‘E:/abc’，或是以“/”开头的路径），则将忽略之前的from参数 123456console.log(path.resolve(&apos;.&apos;, &apos;testFiles/..&apos;, &apos;trdLayer&apos;));// E:\\jinux\\node\\study\\path模块\\trdLayerconsole.log(path.resolve(&apos;..&apos;, &apos;testFiles&apos;, &apos;a.txt&apos;));// E:\\jinux\\node\\study\\testFiles\\a.txtconsole.log(path.resolve(&apos;D:&apos;, &apos;abc&apos;, &apos;D:/a&apos;));// D:\\aconsole.log(path.resolve(&apos;abc&apos;, &apos;ok.gif&apos;));// E:\\jinux\\node\\study\\path模块\\abc\\ok.gifconsole.log(path.resolve(&apos;abc&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)); // E:\\jinux\\node\\study\\path模块\\subfileconsole.log(path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)); // E:\\b\\c relativepath.relative(from, to)获取从 from 到 to 的相对路径，可以看作 path.resolve 的相反实现123console.log(path.relative(&apos;C:\\\\\\test&apos;, &apos;C:\\\\\\impl\\\\bbb&apos;));//..\\impl\\bbbconsole.log(path.relative(&apos;C:/test/aaa&apos;, &apos;C:/bbb&apos;));//..\\..\\bbbconsole.log(path.relative(&apos;C:/test/aaa&apos;, &apos;D:/bbb&apos;));//D:\\bbb isAbsolutepath.isAbsolute(path)path是一个绝对路径(比如 ‘E:/abc’)，或者是以“/”开头的路径，二者都会返回true123456console.log(path.isAbsolute(&apos;../testFiles/secLayer&apos;));// falseconsole.log(path.isAbsolute(&apos;./join.js&apos;));// falseconsole.log(path.isAbsolute(&apos;temp&apos;));// falseconsole.log(path.isAbsolute(&apos;/temp/../..&apos;));// trueconsole.log(path.isAbsolute(&apos;E:/github/nodeAPI/abc/efg&apos;));// trueconsole.log(path.isAbsolute(&apos;///temp123&apos;));// true dirnamepath.dirname(p)返回路径p所在的目录1234console.log(path.dirname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // /foo/bar/baz/asdfconsole.log(path.dirname(&apos;/foo/bar/baz/asdf/&apos;)); // /foo/bar/bazconsole.log(path.dirname(&apos;C:/test/aaa&apos;)); // C:/testconsole.log(path.dirname(__dirname)); // E:\\jinux\\node\\study basenamepath.basename(p[, ext])返回路径的最后一个部分，即文件名。参数ext为需要截掉的后缀内容1234console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // a.txtconsole.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;,&apos;.txt&apos;)); // aconsole.log(path.basename(&apos;/foo/bar/baz/asdf/&apos;)); // asdfconsole.log(path.basename(&apos;C:/test/aaa&apos;)); // aaa extnamepath.extname(p)返回路径p的扩展名，从最后一个’.’到字符串的末尾。如果最后一个部分没有’.’，或者路径是以’.’开头，则返回空字符串12345console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // .txtconsole.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt.b&apos;)); // .bconsole.log(path.extname(&apos;/foo/bar/baz/asdf/a.&apos;)); // .console.log(path.extname(&apos;C:/test/aaa/.&apos;)); // &apos;&apos;console.log(path.extname(&apos;C:/test/aaa&apos;)); // &apos;&apos; sep返回对应平台下的文件分隔符，win下为’\\’，linux下为’/‘123console.log(path.sep); // win下为\\，linux下为/console.log(&apos;foo\\\\bar\\\\baz&apos;.split(path.sep)); // [ &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos; ]console.log(&apos;foo/bar/baz&apos;.split(path.sep)); // win下返回[&apos;foo/bar/baz&apos;]，但在linux系统下会返回[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;] delimiter返回对应平台下的路径分隔符，win下为’;’ linux下为’:’1console.log(path.delimiter); //win下为“;” linux下为“:” 总结所有代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const path = require(&apos;path&apos;);// 当前文件路径console.log(&apos;当前文件夹路径&apos;, process.cwd());console.log(&apos;-------------------------------------------------------------&apos;);/** * path.normalize * 规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠 */console.log(path.normalize(&apos;a/b/c/../user/bin&apos;));// a\\b\\user\\binconsole.log(path.normalize(&apos;a/b/c///../user/bin/&apos;));// a\\b\\user\\bin\\console.log(path.normalize(&apos;a/b/c/../../user/bin&apos;));// a\\user\\binconsole.log(path.normalize(&apos;a/b/c/.././///../user/bin/..&apos;));// a\\userconsole.log(path.normalize(&apos;a/b/c/../../user/bin/../../&apos;));// a\\console.log(path.normalize(&apos;a/../../user/bin/../../&apos;));// ..\\console.log(path.normalize(&apos;a/../../user/bin/../../../../&apos;));// ..\\..\\..\\console.log(path.normalize(&apos;./a/.././user/bin/./&apos;));// user\\bin\\console.log(&apos;-------------------------------------------------------------&apos;);/** * path.join * path.join([path1], [path2], [...]) * 将多个路径结合在一起，并转换为规范化路径 */console.log(path.join(&apos;////./a&apos;, &apos;b////c&apos;, &apos;user/&apos;));// \\a\\b\\c\\userconsole.log(path.join(&apos;./a&apos;, &apos;b//c&apos;, &apos;user&apos;));// a\\b\\c\\userconsole.log(path.join(&apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// ..\\user\\console.log(path.join(__dirname, &apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// E:\\jinux\\node\\study\\user\\console.log(&apos;-------------------------------------------------------------&apos;);/** * path.resolve * path.resolve([from ...], to) * 从源地址 from 到目的地址 to 的绝对路径，类似在shell里执行一系列的cd命令 * path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;) * 类似于: * cd foo/bar * cd /tmp/file/ * cd .. * cd a/../subfile * pwd * [注意]如果某个from或to参数是绝对路径（比如 &apos;E:/abc&apos;，或是以“/”开头的路径），则将忽略之前的from参数 */console.log(path.resolve(&apos;.&apos;, &apos;testFiles/..&apos;, &apos;trdLayer&apos;));// E:\\jinux\\node\\study\\path模块\\trdLayerconsole.log(path.resolve(&apos;..&apos;, &apos;testFiles&apos;, &apos;a.txt&apos;));// E:\\jinux\\node\\study\\testFiles\\a.txtconsole.log(path.resolve(&apos;D:&apos;, &apos;abc&apos;, &apos;D:/a&apos;));// D:\\aconsole.log(path.resolve(&apos;abc&apos;, &apos;ok.gif&apos;));// E:\\jinux\\node\\study\\path模块\\abc\\ok.gifconsole.log(path.resolve(&apos;abc&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)); // E:\\jinux\\node\\study\\path模块\\subfileconsole.log(path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)); // E:\\b\\cconsole.log(&apos;-------------------------------------------------------------&apos;);/** * path.relative * path.relative(from, to) * 获取从 from 到 to 的相对路径，可以看作 path.resolve 的相反实现 */console.log(path.relative(&apos;C:\\\\\\test&apos;, &apos;C:\\\\\\impl\\\\bbb&apos;));//..\\impl\\bbbconsole.log(path.relative(&apos;C:/test/aaa&apos;, &apos;C:/bbb&apos;));//..\\..\\bbbconsole.log(path.relative(&apos;C:/test/aaa&apos;, &apos;D:/bbb&apos;));//D:\\bbbconsole.log(&apos;-------------------------------------------------------------&apos;);/** * path.dirname * path.dirname(p) * 返回路径p所在的目录 */console.log(path.dirname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // /foo/bar/baz/asdfconsole.log(path.dirname(&apos;/foo/bar/baz/asdf/&apos;)); // /foo/bar/bazconsole.log(path.dirname(&apos;C:/test/aaa&apos;)); // C:/testconsole.log(path.dirname(__dirname)); // E:\\jinux\\node\\studyconsole.log(&apos;-------------------------------------------------------------&apos;);/** * path.basename * path.basename(p[, ext]) * 返回路径的最后一个部分，即文件名。参数ext为需要截掉的后缀内容 */console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // a.txtconsole.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;,&apos;.txt&apos;)); // aconsole.log(path.basename(&apos;/foo/bar/baz/asdf/&apos;)); // asdfconsole.log(path.basename(&apos;C:/test/aaa&apos;)); // aaaconsole.log(&apos;-------------------------------------------------------------&apos;);/** * path.extname * path.extname(p) * 返回路径p的扩展名，从最后一个&apos;.&apos;到字符串的末尾。如果最后一个部分没有&apos;.&apos;，或者路径是以&apos;.&apos;开头，则返回空字符串 */console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // .txtconsole.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt.b&apos;)); // .bconsole.log(path.extname(&apos;/foo/bar/baz/asdf/a.&apos;)); // .console.log(path.extname(&apos;C:/test/aaa/.&apos;)); // &apos;&apos;console.log(path.extname(&apos;C:/test/aaa&apos;)); // &apos;&apos;console.log(&apos;-------------------------------------------------------------&apos;);/** * path.sep * 返回对应平台下的文件分隔符，win下为&apos;\\&apos;，linux下为&apos;/&apos; */console.log(path.sep); // win下为\\，linux下为/console.log(&apos;foo\\\\bar\\\\baz&apos;.split(path.sep)); // [ &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos; ]console.log(&apos;foo/bar/baz&apos;.split(path.sep)); // win下返回[&apos;foo/bar/baz&apos;]，但在linux系统下会返回[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]console.log(&apos;-------------------------------------------------------------&apos;);/** * path.delimiter * 返回对应平台下的路径分隔符，win下为&apos;;&apos; linux下为&apos;:&apos; */console.log(path.delimiter); //win下为“;” linux下为“:”console.log(&apos;-------------------------------------------------------------&apos;);/** * path.isAbsolute * path.isAbsolute(path) * path是一个绝对路径(比如 &apos;E:/abc&apos;)，或者是以“/”开头的路径，二者都会返回true */console.log(path.isAbsolute(&apos;../testFiles/secLayer&apos;));// falseconsole.log(path.isAbsolute(&apos;./join.js&apos;));// falseconsole.log(path.isAbsolute(&apos;temp&apos;));// falseconsole.log(path.isAbsolute(&apos;/temp/../..&apos;));// trueconsole.log(path.isAbsolute(&apos;E:/github/nodeAPI/abc/efg&apos;));// trueconsole.log(path.isAbsolute(&apos;///temp123&apos;));// trueconsole.log(&apos;-------------------------------------------------------------&apos;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"CSS设计模式","slug":"CSS设计模式","date":"2022-08-15T06:00:04.000Z","updated":"2024-01-11T07:00:59.116Z","comments":true,"path":"2022/08/15/CSS设计模式/","link":"","permalink":"/2022/08/15/CSS设计模式/","excerpt":"CSS设计模式","text":"CSS设计模式css的设计模式有OOCSS，BEM，SMACSS，ACSS这几种，接下来逐一介绍。 设计模式:OOCSSOOCSS是比较基础的设计模式，其他设计模式或多或少都有OOCSS的影子,OO就是面向对象，也就是用面向对象的思维来写CSS。 面向对象大家都很熟悉面向对象，我们简单看下下面这一段代码：123456789101112class Person &#123; void study () &#123;&#125;&#125;class Teacher extends Person &#123; void study () &#123;&#125; void teach () &#123;&#125;&#125;class Student extends Person &#123; void study () &#123;&#125;&#125; 有一个Person类，它有一些方法，Teacher和Student都继承Person，并且进行了一些修订和扩展。那么我们可以把Person类看成是别人写代码，在不改变别人源码的情况下,新增Teacher和Student对源码进行修订和扩展。这种写法是完全可以应用到CSS上面的。我们看下面一段代码场景:12345678910&lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;&lt;div class=&quot;menu fix&quot;&gt;&lt;/div&gt;&lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;.menu &#123; color: green; font-size: 14px;&#125;.fix &#123; color: red;&#125; 场景设计师只想让我们改变其中一个盒子的样式，其他的不变。这时不能轻易改变menu，因为一旦改变就会影响不需要改变的地方。那么我们可以直接利用面向对象的思想，在后面单独添加一个类进行修订和扩展。这样一看我们平时在写的CSS，不就是面向对象吗？当然，OOCSS是有具体的原则的。那么它有哪些原则且个原则的具体是什么呢？我们来看一下： 原则一:容器与内容分离容器与内容分离顾名思义，直接看一个代码案例：12345678910111213141516171819&lt;div class=&quot;post&quot;&gt; &lt;p class=&quot;metadata&quot;&gt; &lt;a&gt;Hello&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;comment&quot;&gt; &lt;p class=&quot;metadata&quot;&gt; &lt;a&gt;Hello&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;// ---------code 1-----------.post .metadata &#123; // css code&#125;// ---------code 2-----------.post &#123;&#125;.metadata &#123; // css code&#125; 场景两个不同容器中的内容相同先看样式的code 1，这样显然不好，容器和内容是嵌套依赖关系，并没有做到容器与内容分离。内容的样式无法复用。样式的code 2做到了容器与内容分离，内容在不同的容器中可以复用。 原则二:结构与皮肤分离结构可以看做是一个基础对象,而皮肤可以看做是另外一个对象,也就是对象与对象要分离。基础对象不能改,不断的分离出皮肤对象达到对基础对象的修正和扩展。12345678910&lt;div class=&quot;menu fix&quot;&gt;&lt;/div&gt;// 基础对象.menu &#123; color: green; font-size: 14px;&#125;// 皮肤.fix &#123; color: red;&#125; OOCSS与Vue的关系我们每天都在写OOCSS，Vue的组件就是OOCSS。我们下面一段代码：12345678910111213141516171819202122232425262728293031// -------------定义组件-----------------&lt;template&gt; &lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;MateData&apos; &#125;&lt;/script&gt;&lt;style&gt; // 基础对象.menu &#123; color: green; font-size: 14px;&#125;&lt;/style&gt;// -----------使用组件-------------------&lt;template&gt; &lt;mate-data class=&quot;fix1&quot;&gt;&lt;/mate-data&gt; &lt;mate-data class=&quot;fix2&quot;&gt;&lt;/mate-data&gt;&lt;/template&gt;&lt;style&gt; // 皮肤.fix1 &#123; color: red;&#125;.fix2 &#123; font-size: 20px;&#125;&lt;/style&gt; 设计模式:BEMBEM是什么BEM即块(Block)、元素(Element)、修饰符(Modifier) 是由Yandex（俄罗斯最著名的互联网企业）的开发团队提出的前端开发理论。BEM通过Block、Element、Modifier来描述页面(关键就是为了解决多人协作的命名问题)。Block是页面中独立存在的区块，可以在不同场合下使用。每个页面都可以看做是多个Block组成。Element是构成Block的元素，只有在对应Block内部才具有意义，是依赖于Block的存在。Modifier是描述Block或Element的属性或状态。同一Block或Element可以有多个Modifier，Modifier不可以单独存在。在命名时，Block作为起始开头，不同 Block 和 Element 用 _ 两个底线区隔开来，不同的 Modifier 则用 – 区隔。 进阶版的OOCSSBEM就是进阶版的OOCSS，我们看下图所示: 场景页面两个tab栏，整体布局相似,只有细节部分不同那么使用BEM写样式时，就会定义一个块menu，下面包含元素menu_tab，完成整体布局，细微部分使用修饰符menu_tab-style1进行微调。代码如下：1234567891011121314&lt;!-- BEM --&gt;&lt;div class=&quot;menu menu-style1&quot;&gt; &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;menu&quot;&gt; &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;&lt;/div&gt; 通过上面代码可以看出BEM就是OOCSS。对BEM感兴趣的话，可以访问BEM的官网 设计模式:SMACSSSMACSS is a way to examine your design process and as a way to fit those rigid frameworks into a flexible thought process. (SMACSS通过一个灵活的思维过程来检查你的设计过程和方式是否符合你的架构，更像一种规范~) 核心思想:分类 SMACSS的核心就是分类，它主要要求分为五大类分别是：Base、Layout、Modules、State、Theme Base是对浏览器默认样式的重置，常见的normalize.css就属于此。这里样式只会对标签元素本身做设定，不会出现任何 class 或id，但是可以有属性选择器或是伪类. Layout对页面布局的一些功能，属于较高的一层，它可以作为层级较低的Module Rules元素的容器。左右分栏、栅格系统等都属于布局规范。SMACSS还约定命名使用l-/layout-前缀来标识布局的class。 Modules公共复用的小模块，模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。SMACSS中的模块具有自己的一个命名，隶属于模块下的类皆以该模块为前缀，例如：.menu .menu-title等。 State对不同的展示效果，例如显示、隐藏，与BEM抽取修饰类的方式的不同，SMACSS是抽取更高级别的样式类，得到更强的复用性，命名全都以is-前缀,如:is-hidden。 Theme对不同主题皮肤的维护，可以修改前面4个类别的样式，且应和前面4个类别分离开来（便于切换，也就是“换肤”）。命名规范需要添加theme-前缀。 最小适配深度原则1234/* depth 1 */.sidebar ul h3 &#123;&#125;/* depth 2 */.sub-title &#123;&#125; 两段css的区别在于html和css的耦合度(这一点上和OOCSS的分离容器和内容的原则不谋而合)。可以想到，由于上面的样式规则使用了继承选择符，因此对于html的结构实际是有一定依赖的。如果html发生重构，就有可能不再具有这些样式。对应的，下面的样式规则只有一个选择符，因此不依赖于特定html结构，只要为元素添加class，就可以获得对应样式。当然，继承选择符是有用的，它可以减少因相同命名引发的样式冲突（常发生于多人协作开发）。但是，我们不应过度使用，在不造成样式冲突的允许范围之内，尽可能使用短的、不限定html结构的选择符。这就是SMACSS的最小化适配深度的意义。在项目中使用SMACSS时，每一个分类都是一个目录，但是在Vue中，Layout和Modules不需要单独维护目录，因为我们写的布局组件和模块组件就相当于这两个分类了。如果想要对SMACSS更详细的了解可以访问SMACSS 设计模式:ITCSS这是由csswizardry提倡的一个 CSS 设计方法论，它可以让CSS更好的管理和维护。使用ITCSS主要可以帮助我们以下几点: Manages source order.(管理 CSS 代码的书写顺序) Filters explicitness.(过滤器的明确性，是说分层来明确每层 CSS 的作用) Tames the cascade.(控制好 CSS 的权重) Sanitises inheritance.(安全地使用继承) 核心思想:分层TCSS的核心是分层,主要分为七层, 与SMACSS的分类相比更加精细，层次分的更细主要有: Layer 作用 Settings 项目使用的全局变量 Tools mixin，function Generic 最基本的设定 normalize.css，reset Base type selector Objects 不经过装饰 (Cosmetic-free) 的设计模式，相当于SMACSS的Layout Components UI 组件 Trumps helper 唯一可以使用 !important 的地方 下面就是ITCSS的架构模型:从这个模型可以看出来，越往下就越具体，越局限于使用在某个具体的东西。另外它的下一层永远继承上一层的所有样式。 各个分层例子Settings全局变量，比如颜色，字体大小等等12$yellow: #FAAF00;$yellow-bright: #FAF7F0; Toolsmixin，function 等等123@mixin sample-mixin () &#123; ...&#125; 到 Tools 为止，不会生成具体的 css Genericreset，normalize 等等12345*,*::before,*::after &#123; box-sizing: border-box;&#125; Basetype selector 比如 link, p 等等，只有这一层才使用 type selector1234p &#123; margin: 0 line-height: 1.5;&#125; ObjectsCosmetic-free，不使用比如 color、border-color、background-color 之类的使用这个 CSS 你在浏览器上面只可以看一片空白主要用来做画面的 layout1234.o-container &#123; box-sizing: border-box; margin: 0 auto;&#125; ComponentsUI 组件到这个部分，根据UI分析具体有哪些组件需要实现，可以分给多个人来同时实现12345678910111213141516# button组件.c-btn &#123; display: flex; justify-content: center; align-items: center; ... &amp;--primary &#123; background-color: #ff5959; color: #fff; &#125; &amp;--large &#123; font-size: 16px; padding: 16px 14px; ... &#125;&#125; HTML 类似这样12&lt;a class=&quot;c-btn c-btn--primary&quot; href=&quot;#&quot;&gt;sample&lt;/a&gt;&lt;a class=&quot;c-btn c-btn--primary c-btn--large&quot; href=&quot;#&quot;&gt;sample&lt;/a&gt; Trumps放各种 helper最主要的作用是用在不适合或者不容易放在 Component 的时候比如 margin，很可能不应该放 Component，这时候可以用 Trumps 来微调这样可以防止你的 Component 变得非常大只有这一层才可以使用! important，以此来避免多个! important 的混乱局面12345678.u-color &#123; &amp;--white &#123; color: $white !important; &#125;&#125;.u-hidden &#123; display: hidden !important;&#125; 在使用时，每个分层都维护为一个文件夹。在Vue中使用时，Objects和Components相当于我们的组件，不需要单独维护。另外值得注意的是，无论是SMACSS的分类还是ITCSS的分层，都是一种思想，我们可以根据实际项目来动态的添加或者删除某一个分类或者分层，不能生搬硬套。 设计模式:ACSSACSS使用了紧密的类名库。 这些类名通常被缩写，并与它们影响的内容分开。 在ACSS系统中，我们可以知道类名的作用； 但是类名称与内容类型之间没有关系,即每一个样式对应一个类，也称原子类CSS。123456789101112.float-left &#123; float: left;&#125;.float-right &#123; float: right;&#125;.z-0 &#123; z-index: 0;&#125;.z-auto &#123; z-index: auto;&#125; 从上面的代码中，可以看到ACSS有极强的复用性,维护成本低，但是破坏了css命名的语义化。最终很可能代码会成为下面这样。但是存在即合理，ACSS也有其作用，继续往下看。12345678&lt;div class=&quot;grid grid-cols-3 gap-2 place-content-center h-48 ...&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; tailwindcss是一个典型的ACSS框架。 混合使用CSS设计模式在进行一个项目的设计时,我们可以针对多种CSS设计模式进行选型，结合不同设计模式的优点和缺点，设计一个完整银杏的CSS架构。假如我们选择ITCSS、BEM、ACSS进行组合，设计一个CSS架构。在我们设计CSS架构时,我们首先想到的一定是SMACSS和ITCSS,因为它们两个对CSS进行了分类分层的划分。 SMACSS ITCSS Base Setting Layout Tools Modules Generic State Base Theme Objects Components Trumps 根据上表我们可以看出ITCSS分层更加精细，所以我们选择ITCSS，接着我们继续看ITCSS的Objects和Components层，它就相当于OOCSS且相当于开发Vue组件，所以我们在开发组件时使用选择OOCSS的进阶版BEM。我们知道如果一个项目全部使用ACSS的缺点跟明显，那么我们选择ACSS的原因是因为项目中可能会存在向字体大小的这种的样式,所以我们可以把这一类样式维护在ACSS目录中。Generic和Base类似所以只保留Base即可，我假设Trumps用不到,所以也去掉这一层。所以我们的架构现在就是下面这样。 ITCSS+BEM+ACSS Setting Tools Base Objects Components ACSS 目录结构就是:123456-|comments-|styles--|acss--|base--|settings--|tools 总结CSS设计模式听起来很深奥，但是大家在日常开发时，已经不知不觉的在使用，只不过是没有概念而已。在开发中熟练的使用CSS设计模式，可以使代码结构思路清晰，易于阅读，维护，如果想真正的在项目中写好CSS,CSS设计模式是必不可少的，也是我们开发者应该掌握的。","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"},{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"算法基础-时间复杂度","slug":"算法基础-时间复杂度","date":"2022-08-05T07:20:47.000Z","updated":"2024-01-11T07:00:59.277Z","comments":true,"path":"2022/08/05/算法基础-时间复杂度/","link":"","permalink":"/2022/08/05/算法基础-时间复杂度/","excerpt":"算法基础之时间复杂度","text":"算法基础之时间复杂度对于算法的衡量一般是从两个维度进行的，一是空间维度，即算法执行所需要占据的内存空间；一是时间维度，即算法执行所需要的时间，今天主讲时间维度。 大O符号表示法对于时间复杂度的衡量，我们最常见的就是使用大O符号表示法，例如O(1),O(n)等。之所以采用这样的方式衡量，是因为在不同配置的计算机上，相同的算法代码所呈现出来的性能也不尽相同。所以引入大O符号表示法可以使算法执行所消耗的时间标准化，更加易于对比。大O符号表示法的完整格式是T(n)=O(f(n))，这个函数表示的是代码执行次数与所使用时间之间的正比例关系。其中f(n)表示算法中每行代码执行次数的和，O()表示一个正比例关系。所以大O符号表示法所表示的是算法执行时间的增长变化趋势的，而不是算法实际的执行时间。在使用大O符号表示法的时候，我们一般会假设算法中每一行代码的执行时间都是一样，也就是一个单位时间会运行一行代码，这样我们就能够方便的计算f(n)了。 常见时间复杂度量级一般在代码设计中长长的出现的时间复杂度量级主要有以下这些： 常数阶O(1)。 对数阶O(logN)。 线性阶O(n) 。 线性对数阶O(nlogN)。 平方阶O(n^2)。 立方阶O(n^3)。 K方阶O(n^k)。 指数阶O(2^n)。 组合阶O(n!)。 以上这些复杂度量级从上到下所表示的复杂度越来越大，执行效率也越来越低。下面就一些示例来说明不同形式的代码其时间复杂度的量级。 O(1)代码中没有循环结构，无论执行多少行，代码所消耗的时间始终固定，不随着某个变量的操作发生变化，其复杂度就是O(1) 。1234i = 1j = 2i += 1j += 2 O(n)代码中只有一层循环结构，没有任何嵌套的循环结构，代码执行所消耗的时间只与循环控制变量线性相关，那么这段代码的复杂度就是O(n) 。1234int n =100;for(int i=0; i&lt;n; i++)&#123; System.out.println(i);&#125; O(logN)代码中同样只有一层循环结构，没有任何嵌套的循环结构，但是代码执行所消耗的时间与循环控制变量指数相关，那么这段代码的复杂度就是O(logN)。123456789int i = 1;int n = 1024;while(i &lt; n)&#123; i = i*2;&#125;// 或者for(int i=0; i&lt;n; i*=2)&#123; System.out.println(i);&#125; 从例子可以看出，时间复杂度是O(log2(n)),但是2可以忽略掉，直接写成O(log(n))。 O(nlogN)线性对数阶量级中就已经开始出现多层的循环结构了，在复杂度为O(nlogN)量级的代码中，有两层循环结构，其中一层为O(n)量级的循环，一层为O(logN)量级的循环。1234567int n =100;int m = 1024;for(int i=0; i&lt;n; i++)&#123; while(i &lt; m)&#123; i = i*2; &#125;&#125; O(n^2)平方阶O(n²) 就是把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。1234567int n = 100;int m = 100;for (i=0; i &lt; n ; i++)&#123; for(i=0; i &lt; m ;i++)&#123; System.out.println(i); &#125;&#125; O(n^3) O(n^k)立方阶则是3层循环嵌套。K方阶则是k层循环嵌套。 O(2^n)下例从出现递归的时候，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。1234567long function1(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return function1(n - 1) + function1(n - 2); &#125;&#125; 复杂度分析的4个高阶概念概念 最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 为什么要引入这4个概念？同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 如何分析平均、均摊时间复杂度？平均时间复杂度：代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。均摊时间复杂度：两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。 总结以上是浅浅的介绍下算法的时间复杂度内容。最后介绍一个图形工具数学工具进入网站后，点击函数图像绘制工具，可以把复杂度量级以图形的方式直观的展示出来。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}]},{"title":"node.js中的setTimeout,setImmediate,Promise,process.nextTick","slug":"node-js中的setTimeout-setImmediate-Promise-process-nextTick","date":"2022-08-02T08:37:15.000Z","updated":"2024-01-11T07:00:59.225Z","comments":true,"path":"2022/08/02/node-js中的setTimeout-setImmediate-Promise-process-nextTick/","link":"","permalink":"/2022/08/02/node-js中的setTimeout-setImmediate-Promise-process-nextTick/","excerpt":"nodejs中的事件循环宏任务和微任务","text":"nodejs中的事件循环宏任务和微任务 宏任务首先，看一下nodejs的任务队列1234567891011121314151617181920212223242526272829303132333435363738┌───────────────────────┐┌&gt; │timers │执行setTimeout() 和 setInterval()中到期的callback│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │pending callbacks│执行系统操作的回调, 如:tcp, udp通信的错误callback│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │idle, prepare │只在内部使用│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │poll │执行与I/O相关的回调 │ (除了close回调、定时器回调和setImmediate()之外，几乎所有回调都执行);│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │check │执行setImmediate的callback│ └──────────┬────────────┘│ ┌──────────┴────────────┐└─┤close callbacks │执行close事件的callback，例如socket.on(&quot;close&quot;,func) └───────────────────────┘———————————————— nodejs任务队列有timers，pending callbacks，idle, prepare，poll ，check，close callbacks这6个阶段，其中第2，3个属于nodejs内部的不去探讨，还剩下1，4，5，6.先看两个宏任务的执行顺序：1234567setTimeout(()=&gt; &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);setImmediate(()=&gt; &#123; console.log(&apos;setImmediate&apos;);&#125;); 输出的结果不是固定的，可能是nodejs启动时进入的任务队列时机不一样造成的，再看下边的例子：123456789fs.readFile(&apos;./file.txt&apos;, &apos;utf-8&apos;, (err, data)=&gt; &#123; setTimeout(()=&gt; &#123; console.log(&apos;setTimeout&apos;); &#125;, 0); setImmediate(()=&gt; &#123; console.log(&apos;setImmediate&apos;); &#125;);&#125;); 这个例子的输出就是固定的，永远都是”setImmediate”,”setTimeout”,因为按照按照上边任务队列的表来看，poll之后就是check。 微任务Promise和process.nextTick是两个微任务，他们不在任务队列的表格中。他们的执行跟在浏览器端一样，在宏任务之前执行，就是每个宏任务执行之后都会把微任务都执行完了再去执行宏任务。1234567Promise.resolve().then(()=&gt; &#123; console.log(&apos;Promise&apos;);&#125;);process.nextTick(()=&gt; &#123; console.log(&apos;nextTick&apos;);&#125;); nextTick优先顺序高于Promise 总结最后写一个宏任务和微任务都有的例子：123456789101112131415161718192021setTimeout(()=&gt; &#123; console.log(&apos;setTimeout&apos;); process.nextTick(()=&gt; &#123; console.log(&apos;setTimeout-nextTick&apos;); &#125;);&#125;, 0);setImmediate(()=&gt; &#123; console.log(&apos;setImmediate&apos;); process.nextTick(()=&gt; &#123; console.log(&apos;setImmediate-nextTick&apos;); &#125;);&#125;);Promise.resolve().then(()=&gt; &#123; console.log(&apos;Promise&apos;);&#125;);process.nextTick(()=&gt; &#123; console.log(&apos;nextTick&apos;);&#125;); 执行后发现，当有下边两个微任务在的时候，setTimeout永远在setImmediate前执行，当没有这两个微任务的时候，先后顺序又不一定了，侧面说明微任务可以校准任务队列的执行时机。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"Web Component","slug":"Web-Component","date":"2022-06-22T07:45:43.000Z","updated":"2024-01-11T07:00:59.175Z","comments":true,"path":"2022/06/22/Web-Component/","link":"","permalink":"/2022/06/22/Web-Component/","excerpt":"Web Component初探","text":"Web Component初探 什么是 Web ComponentWeb Component 是一种 W3C标准 支持的 组件化方案，通过它，我们可以编写可复用的 组件，同时，我们也可以对自己的组件做更精细化的控制。正如 PWA 一样，他并非一项单一的技术，而是由三项技术组成： 1.Shadow DOM2.Custom elements3.HTML templates 例子我们准备编写一个 TextReverse 组件，TextReverse 只有一个很简单的功能，就是把传入的 字符串颠倒显示。例如： 将会显示 321。第一步，我们需要 定义 这个自定义组件。12345678910class TextReverse extends HTMLElement &#123; constructor() &#123; super(); const shadowRoot = this.attachShadow(&#123; mode: &apos;open&apos; &#125;); const text = this.getAttribute(&apos;text&apos;) || &apos;&apos;; const wrapper = document.createElement(&apos;span&apos;); wrapper.textContent = text.split(&apos;&apos;).reverse().join(&apos;&apos;); shadowRoot.appendChild(wrapper); &#125;&#125; 定义组件的方式也十分简单，我们只需要 继承一下 HTMLElement，然后在 构造函数 中编写自己的 初始化逻辑 就可以了。初始化过程中，我们首先 创建了一个 shadowRoot，这个相当于是我们整个组件的一个 根结点。紧接着，我们获取到自身的 text 属性，并且将其 倒置 放入新创建的 span 元素中。最后，我们把带有 text 的 span 塞入 shadowRoot。定义完成之后，我们要告知一下系统，也就是 组件注册。1234customElements.define( &apos;text-reverse&apos;, TextReverse) 这里有一个小细节，就是我们注册的名字必须是带短横线的。注册完成之后就可以正式使用啦。1&lt;text-reverse text=&apos;12345&apos;&gt;&lt;/text-reverse&gt; 上面的例子中，我们用到了 shadow root，他承载着我们组件所有的内容。而他也是 Web Component 核心技术。我们都知道 Dom 其实就是一棵树，而我们的组件则是树上的一个节点。我们可以称组件节点为 shadow host。shadow host 中含有一颗与外界隔离的 dom 树，我们称之为 shadow tree。shadow tree 中的内容不会影响到外界。Shadow Root 则是这一课shadow tree 的根节点。 样式隔离shadow dom 一大亮点就是样式隔离。我们可以给之前的例子加上样式。123456789101112class TextReverse extends HTMLElement &#123; constructor() &#123; super(); // ... const style = document.createElement(&apos;style&apos;); style.textContent = `* &#123; background: red; &#125;` shadowRoot.appendChild(style); // ... &#125;&#125; 我们给所有元素添加一个红的背景色。但是，结果只有组件内的元素背景色受到了影响。这种样式隔离的特性很好地避免了不同组件之间的样式干扰。 Template在上面的例子中，我们采用代码的方式来创建修改节点。相较于 React 的 Jsx 和 Vue 的模版，这种方法比较低效。所以，我们可以使用 Template 来解决这问题。12345678910111213141516171819&lt;template id=&apos;text-reverse&apos;&gt; &lt;style&gt; *&#123; background: red; &#125; &lt;/style&gt; &lt;span id=&apos;text&apos;&gt;&lt;/span&gt;&lt;/template&gt;class TextReverse extends HTMLElement &#123; constructor() &#123; super(); const shadowRoot = this.attachShadow(&#123; mode: &apos;open&apos; &#125;); const text = this.getAttribute(&apos;text&apos;) || &apos;&apos;; const template = document.getElementById(&apos;text-reverse&apos;).content.cloneNode(true); template.getElementById(&apos;text&apos;).textContent = text.split(&apos;&apos;).reverse().join(&apos;&apos;); shadowRoot.appendChild(template); &#125;&#125; 我们在 html 中定义了一个 template，然后，就和操作普通元素一样获取到 template 节点，然后深拷贝一份节点内容。最后直接操作这个节点。 Slot和 Vue 的 Slot 相似，Slot 赋予了组件更高的可扩展性。通过 Slot，我们可以给组件传入更多的自定义内容。在上面的例子中，我们给组件添加一个自定义的标题。1234567&lt;text-reverse text=&apos;12345&apos;&gt; &lt;span slot=&apos;title&apos;&gt;text reverse&lt;/span&gt;&lt;/text-reverse&gt;&lt;template id=&apos;text-reverse&apos;&gt; &lt;h1&gt;&lt;slot name=&apos;title&apos;&gt;default title&lt;/slot&gt;&lt;/h1&gt; &lt;span id=&apos;text&apos;&gt;&lt;/span&gt;&lt;/template&gt; 模版中，我们定义一个 slot 元素，命名为 title，并且设置一个无内容时的默认值 default title。 使用的时候，我们在元素中添加一个 slot 属性来与模版中的 slot 相匹配。 继承现有元素至今，我们都是完全自定义组件内容，假如我们想扩展现有系统元素，那就需要定义一个 内置自定义元素。 我们来用一个屏蔽数字的 p 元素来说明。1234567891011121314class PFilter extends HTMLParagraphElement &#123; constructor() &#123; super(); const textContent = this.textContent; this.textContent = textContent.replace(/\\d/g, &apos;*&apos;); &#125;&#125;customElements.define( &apos;p-filter&apos;, PFilter, &#123; extends: &apos;p&apos; &#125;) 我们这边不再是继承 HTMLElement，而是继承需要扩展的 p节点 HTMLParagraphElement。1&lt;p is=&apos;p-filter&apos;&gt;我的手机号是：10086&lt;/p&gt; 不同于独立自定义组件，我们还是需要用原有元素名去声明，并且在 is 属性中填写我们的组件名。 生命周期和大多数框架一样，Web Component 也含有许多控制组件生命周期的方法。 1.connectedCallback：当 custom elemen t首次被插入 DOM 时，被调用。2.disconnectedCallback：当 custom element 从 DOM 中删除时，被调用。3.adoptedCallback：当 custom element 被移动到新的文档时，被调用。4.attributeChangedCallback: 当 custom element 增加、删除、修改自身属性时，被调用。 我们只需在定义组件的类中声明对应的方法即可。attributeChangedCallback 相对与别的属性比较特别，他需要 搭配 observedAttributes 使用。12345678910class TextReverse extends HTMLElement &#123; //... static get observedAttributes () &#123; return [&apos;text&apos;]; &#125; attributeChangedCallback () &#123; const text = this.getAttribute(&apos;text&apos;) || &apos;&apos;; this.shadowRoot.getElementById(&apos;text&apos;).textContent = text.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125;&#125; 我们在 observedAttributes静态方法中添加需要监听的属性值。然后，在 text 改变的时候，触发 attributeChangedCallback方法来更新 text的值。 总结Web Component 的功能十分强大，相较于 React，Vue等框架，他天生自带样式隔离，并且最主要的是拥有浏览器的原生支持。不过，想要达到工程开发标准 的话，他还有一段很长很长的路要走。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"Service Worker","slug":"Service-Worker","date":"2022-06-06T07:51:56.000Z","updated":"2024-01-11T07:00:59.175Z","comments":true,"path":"2022/06/06/Service-Worker/","link":"","permalink":"/2022/06/06/Service-Worker/","excerpt":"Service Worker初探","text":"Service Worker初探 简述service worker定义先不谈，主要简单的介绍下笔者对service worker流程理解,也就是生命周期,直奔主题。 1.第一次进入html文件时，注册service worker文件(sw.js)，接下来sw.js文件中的install事件响应，紧接着activate事件响应，最后是register注册的Promise的then执行，记住，这时registration的状态是installed。在第一次打开网页时，install和activate事件都会执行，可以在install事件里做缓存配置处理，可以在activate事件里做删除无用的缓存处理。2.再次进入这个页面时，因为第一次已经注册了sw.js文件，所以install和activate事件是不会执行的，但是fetch事件可以执行，也可以理解为，再次进入这个页面时，service worker已经接管了这个页面，可以在fetch事件里对请求做处理，也就是service worker的核心功能所在。这时registration的状态是active。3.service worker和html页面是分离的，页面关闭，service worker并不会关闭，每次打开html页面时，这个页面注册过的service worker都会对其进行监管操作，一个页面可以对应多个service worker，只有active状态下的service worker才是正在工作的。因为每次在修改了sw.js文件后，浏览器会自动检查这个文件是否有改变，如果有改变了，会执行步骤1的注册流程，这个时候可以在install事件中，加上self.skipWaiting()，它的作用是将当前的service worker状态提升到active，接管网页操作。 例子sw.html12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/3.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/4.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/5.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./lib/6.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;service worker&lt;/h1&gt; &lt;script&gt; if (&apos;serviceWorker&apos; in navigator) &#123; /* 当页面加载完成就创建一个serviceWorker */ window.addEventListener(&apos;load&apos;, function () &#123; /* 创建并指定对应的执行内容 */ /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 &apos;/&apos;，表示 根网域下的所有内容。这也是默认值。 */ navigator.serviceWorker.register(&apos;./sw.js&apos;, &#123;scope: &apos;./&apos;&#125;) .then(function (registration) &#123; if (registration.installing) &#123; console.log(&apos;Service worker installing&apos;); &#125; else if (registration.waiting) &#123; console.log(&apos;Service worker installed&apos;); &#125; else if (registration.active) &#123; console.log(&apos;Service worker active&apos;); &#125; &#125;) .catch(function (err) &#123; console.log(&apos;ServiceWorker registration failed: &apos;, err); &#125;); &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sw.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var CACHE_NAME = &apos;v1&apos;;/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */this.addEventListener(&apos;install&apos;, function (event) &#123; console.log(&apos;install-&apos;+CACHE_NAME); self.skipWaiting(); event.waitUntil( /* 创建一个名叫V1的缓存版本 */ caches.open(CACHE_NAME).then(function (cache) &#123; /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */ return cache.addAll([ &apos;/sw.html&apos;, &apos;./lib/1.js&apos;, &apos;./lib/2.js&apos;, &apos;./lib/3.js&apos;, ]); &#125;) );&#125;);// 激活事件this.addEventListener(&apos;activate&apos;, function(event) &#123; console.log(&apos;activate&apos;); let cacheWhitelist = [CACHE_NAME]; // 将其他的chace缓存清除 event.waitUntil( caches.keys().then (cacheNames =&gt; &#123; return Promise.all( cacheNames.map( cacheName =&gt; &#123; if (cacheWhitelist.indexOf(cacheName) === -1) &#123; return caches.delete(cacheName) &#125; &#125;) ) &#125;) )&#125;);// fetch事件-是否是install时缓存的文件// this.addEventListener(&apos;fetch&apos;, function(event) &#123;// event.respondWith(caches.match(event.request).then(function (response) &#123;// if (response) &#123;// console.log(response, &apos;------&apos;);// return response// &#125; else &#123;// console.log(event.request, &apos;========&apos;);// return fetch(event.request)// &#125;// &#125;));// &#125;);// fetch事件-this.addEventListener(&apos;fetch&apos;, function(event) &#123; if (navigator.onLine) &#123; return fetch(event.request.clone()).then(function (response) &#123; if (!response || response.status !== 200) &#123; return response &#125; caches.open(CACHE_NAME).then(function (cache) &#123; cache.put(event.request, response.clone()) &#125;) return response &#125;).catch(function (err) &#123; console.log(err) &#125;) &#125; else &#123; event.respondWith(caches.match(event.request).then(function (response) &#123; if (response) &#123; // A cached response has been found! return response &#125; else &#123; // We don&apos;t have a cached response, initiate a fetch... return fetch(event.request) &#125; &#125;)) &#125;&#125;); 总结service worker功能非常强大，PWA就是基于service worker，以上只是简单的介绍，不过生命周期也就这么多内容。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"worker","slug":"worker","permalink":"/tags/worker/"}]},{"title":"Web Worker","slug":"Web-Worker","date":"2022-06-01T08:26:47.000Z","updated":"2024-01-11T07:00:59.175Z","comments":true,"path":"2022/06/01/Web-Worker/","link":"","permalink":"/2022/06/01/Web-Worker/","excerpt":"Web Server的简单介绍","text":"Web Server的简单介绍 概述Web Worker使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行任务，从而允许主（通常是UI）线程运行而不被阻塞。它的作用就是给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。这样做的好处是主线程可以把计算密集型或高延迟的任务交给worker线程执行，这样主线程就会变得轻松，不会被阻塞或拖慢。这并不意味着JS语言本身支持了多线程能力，而是浏览器作为宿主环境提供了JS一个多线程运行的环境。不过因为worker一旦新建，就会一直运行，不会被主线程的活动打断，这样有利于随时响应主线程的通性，但是也会造成资源的浪费，所以不应过度使用，用完注意关闭。或者说：如果worker无实例引用，该worker空闲后立即会被关闭；如果worker实列引用不为0，该worker空闲也不会被关闭。 使用限制 同源限制worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧 文件限制为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源 DOM操作限制worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、window等对象，但是可以获取navigator、location(只读)、XMLHttpRequest、setTimeout族等浏览器API。 通信限制worker线程与主线程不在同一个上下文，不能直接通信，需要通过postMessage方法来通信。 脚本限制worker线程不能执行alert、confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。 例子worker线程的js文件1234567891011// workerThread1.jslet i = 1function simpleCount() &#123; i++ self.postMessage(i) setTimeout(simpleCount, 1000)&#125;simpleCount()self.onmessage = ev =&gt; &#123; postMessage(ev.data + &apos; 呵呵~&apos;)&#125; html文件中12345678910111213141516171819202122232425262728293031&lt;div&gt; Worker 输出内容：&lt;span id=&apos;app&apos;&gt;&lt;/span&gt; &lt;input type=&apos;text&apos; title=&apos;&apos; id=&apos;msg&apos;&gt; &lt;button onclick=&apos;sendMessage()&apos;&gt;发送&lt;/button&gt; &lt;button onclick=&apos;stopWorker()&apos;&gt;stop!&lt;/button&gt;&lt;/div&gt;&lt;script type=&apos;text/javascript&apos;&gt; if (typeof(Worker) === &apos;undefined&apos;) // 使用Worker前检查一下浏览器是否支持 document.writeln(&apos; Sorry! No Web Worker support.. &apos;) else &#123; window.w = new Worker(&apos;workerThread1.js&apos;) window.w.onmessage = ev =&gt; &#123; document.getElementById(&apos;app&apos;).innerHTML = ev.data &#125; window.w.onerror = err =&gt; &#123; w.terminate() console.log(error.filename, error.lineno, error.message) // 发生错误的文件名、行号、错误内容 &#125; function sendMessage() &#123; const msg = document.getElementById(&apos;msg&apos;) window.w.postMessage(msg.value) &#125; function stopWorker() &#123; window.w.terminate() &#125; &#125;&lt;/script&gt; API主线程中的api，worker表示是 Worker 的实例 worker.postMessage: 主线程往worker线程发消息，消息可以是任意类型数据，包括二进制数据worker.terminate: 主线程关闭worker线程worker.onmessage: 指定worker线程发消息时的回调，也可以通过worker.addEventListener(‘message’,cb)的方式worker.onerror: 指定worker线程发生错误时的回调，也可以 worker.addEventListener(‘error’,cb) Worker线程中全局对象为 self，代表子线程自身，这时 this指向self self.postMessage: worker线程往主线程发消息，消息可以是任意类型数据，包括二进制数据self.close: worker线程关闭自己self.onmessage: 指定主线程发worker线程消息时的回调，也可以self.addEventListener(‘message’,cb)self.onerror: 指定worker线程发生错误时的回调，也可以 self.addEventListener(‘error’,cb) 注意，w.postMessage(aMessage, transferList) 方法接受两个参数，aMessage 是可以传递任何类型数据的，包括对象，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。一个可选的 Transferable对象的数组，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用（中止），并且只有在它被发送到的worker中可用。可转移对象是如ArrayBuffer，MessagePort或ImageBitmap的实例对象，transferList数组中不可传入null。 worker线程中加载脚本的api importScripts(‘script1.js’) // 加载单个脚本importScripts(‘script1.js’, ‘script2.js’) // 加载多个脚本 实战场景 加密数据有些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致UI线程无响应，因此这是使用Web Worker的好时机，使用Worker线程可以让用户更加无缝的操作UI。 预取数据有时候为了提升数据加载速度，可以提前使用Worker线程获取数据，因为Worker线程是可以是用 XMLHttpRequest 的。 预渲染在某些渲染场景下，比如渲染复杂的canvas的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用Worker线程来执行，也可以使用多个Worker线程，这里有个射线追踪的示例。 复杂数据处理场景某些检索、排序、过滤、分析会非常耗费时间，这时可以使用Web Worker来进行，不占用主线程。 预加载图片有时候一个页面有很多图片，或者有几个很大的图片的时候，如果业务限制不考虑懒加载，也可以使用Web Worker来加载图片，可以参考一下这篇文章的探索，这里简单提要一下。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"worker","slug":"worker","permalink":"/tags/worker/"}]},{"title":"Map与WeakMap(垃圾回收角度)","slug":"Map与WeakMap-垃圾回收角度","date":"2022-05-30T05:25:18.000Z","updated":"2024-01-11T07:00:59.144Z","comments":true,"path":"2022/05/30/Map与WeakMap-垃圾回收角度/","link":"","permalink":"/2022/05/30/Map与WeakMap-垃圾回收角度/","excerpt":"nodejs环境，垃圾回收角度看Map与WeakMap区别","text":"nodejs环境，垃圾回收角度看Map与WeakMap区别 Map与WeakMap简单区别 Map的键值可以是原始数据类型和引用类型，WeakMap的键值只能说引用类型（object）。Map可以迭代遍历键，WeakMap不可迭代遍历键。WeakMap中的”weak“表示弱映射的键是”弱弱地拿着“的，意思就是，这些键不属于正式的引用。换言之，WeakMap所构建的实例中，其key键所对应引用地址的引用断开或不属于指向同一个内存地址的时候，其对应value值就会被加入垃圾回收队伍。（粗暴理解为：因为key必须是个引用类型，当key引用断了或变了，这个键值对就可以进垃圾桶了）观察内存空间理解WeakMap，因为通常条件下很难察觉WeakMap里面keyValue什么时候消失，但是通过某一个引用类型的值大到足够占据一定内存时候，我们可以通过观察内存的变化来观察WeakMap的特性。 测试环境Node.js的进程Api process.memoryUsage()配合手动垃圾回收global.gc()在终端观察。（也可以使用Chrome浏览器Performance功能录制内存变化） glabal.gc()手动调用一次垃圾回收。需要在运行js文件时候增加命令 –expose-gc，一般环境下不推荐使用，这里做学习用。 process.memoryUsage()查看Node进程的内存占用情况,返回值为对象其中包含五个属性 rss，heapTotal，heapUsed，external，arrayBuffers；其中主要属性是 heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用的内存量,单位都为字节。 代码示例1.WeakMap12345678910111213141516171819202122232425// 第一次手动清理垃圾以确保为最新状态，观察内存情况global.gc();console.log(`第一次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);const wm = new WeakMap();let key = &#123;&#125;;// 给 WeakMap实例 赋值一个 占领内存足够大的 键值对wm.set(key, new Array(114514 * 19));// 手动清理一下垃圾 观察内存占用情况global.gc();console.log(`第二次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);// 此时把 key键 的引用进行断开，并观察内存占用情况key = null;// key = new Array(); // 这种改变引用地址写法也可以引起 弱映射，因为引用地址不再是同块内存地址 WeakMap内对应的value也会被垃圾回收global.gc();console.log(`第三次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);$ node --expose-gc index.js第一次垃圾回收，当前内存使用情况：1.66MB第二次垃圾回收，当前内存使用情况：18.45MB第三次垃圾回收，当前内存使用情况：1.84MB 2.Map12345678910111213141516171819202122232425262728293031323334353637// 第一次手动清理垃圾以确保为最新状态，观察内存情况global.gc();console.log( `第一次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);const m = new Map();let key = &#123;&#125;;m.set(key, new Array(114514 * 19));// 手动清理一下垃圾 观察内存占用情况global.gc();console.log( `第二次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB， 当前Map的长度: $&#123;m.size&#125;`);// 此时把 key键 的引用进行断开，并观察内存占用情况key = null;global.gc();console.log( `第三次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB， 当前Map的长度: $&#123;m.size&#125;`);// 清除Map所有键值对m.clear();global.gc();console.log( `第四次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB， 当前Map的长度: $&#123;m.size&#125;`);$ node --expose-gc index.js第一次垃圾回收，当前内存使用情况：1.66MB第二次垃圾回收，当前内存使用情况：18.45MB，当前Map的长度: 1第三次垃圾回收，当前内存使用情况：18.45MB，当前Map的长度: 1第四次垃圾回收，当前内存使用情况：1.85MB，当前Map的长度: 0 由此可见Map所构建的实例是需要手动清理，才能被垃圾回收清除，而WeakMap只要外部的引用消失，所对应的键值对就会自动被垃圾回收清除。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"函数式编程的核心思想","slug":"函数式编程的核心思想","date":"2022-05-09T05:57:39.000Z","updated":"2024-01-11T07:00:59.258Z","comments":true,"path":"2022/05/09/函数式编程的核心思想/","link":"","permalink":"/2022/05/09/函数式编程的核心思想/","excerpt":"什么是函数式编程","text":"什么是函数式编程函数式编程最近几年越炒越热，有函数式编程的语言鄙视没有函数式编程的语言，纯函数式编程的语言鄙视不纯的函数式编程的语言。 那么，到底什么是函数式编程，函数式编程的核心思想又是什么？ 函数式编程的第一个特点就是可以把函数作为参数传递给另一个函数，也就是所谓的高阶函数。例如，对数组进行排序，可以传入一个排序函数作为参数：12String[] array = &#123; &quot;orange&quot;, &quot;Pear&quot;, &quot;Apple&quot; &#125;;Arrays.sort(array, String::compareToIgnoreCase); 函数式编程的第二个特点就是可以返回一个函数，这样就可以实现闭包或者惰性计算： 以上两个特点还仅仅是简化了代码。从代码的可维护性上讲，函数式编程最大的好处是引用透明，即函数运行的结果只依赖于输入的参数，而不依赖于外部状态，因此，我们常常说函数式编程没有副作用。 没有副作用有个巨大的好处，就是函数内部无状态，即输入确定，输出就是确定的，容易测试和维护。 很多初学者容易纠结“纯”函数式语言，认为只有Haskell这种消除了变量和副作用的语言才是正宗的函数式编程。还有人甚至认为纯函数不能有任何IO操作，包括打行日志都不行。 其实这种纠结是没有意义的，因为计算机底层就是一个完全可变的内存和不可预测输入的系统，追求完美的无副作用是不现实的，我们只需要理解函数式编程的思想，把业务逻辑做到“无副作用”，至于有变量、打日志、读缓存这些无关紧要的“副作用”，根本不用担心，不需要解决，也几乎没法解决。 我们来举个栗子。 比如一个财务软件，需要一个函数专门计算个人所得税，输入是一个IncomeRecord，输出是个税金额： 123double calculateIncomeTax(IncomeRecord record) &#123; ...&#125; 又假设IncomeRecord长这样： 12345class IncomeRecord &#123; String id; // 身份证号 String name; // 姓名 double salary; // 工资&#125; 先不考虑五险一金这些乱七八糟的东西，我们只关注如何计算个税。为了简化，我们假设直接扣除一个免征额后按20%计算： 12345double calculateIncomeTax(IncomeRecord record) &#123; double threshold = 3500; double tax = record.salary &lt;= threshold ? 0 : (record.salary - threshold) * 0.2; return tax;&#125; 上面这个程序在2018年9月1号前是没问题的，问题是2018年9月1号后起征点调整到了5000，那2018年8月和2018年9月，计算结果应该不一样。怎么改？ 普通开发者的改法：那还不简单？直接获取当前日期，返回正确的起征点就行： 12345double calculateIncomeTax(IncomeRecord record) &#123; double threshold = today() &lt; date(2018, 9, 1) ? 3500 : 5000; double tax = record.salary &lt;= threshold ? 0 : (record.salary - threshold) * 0.2; return tax;&#125; 程序是没错，问题是： 同样的输入，8月31号跑，和9月1号跑，结果不一样，难道会计要在9月1号做8月份的工资条，必须把电脑的时间先调到8月份？ 用函数式编程的观点思考一下，就发现问题所在： today()这个函数，返回结果与时间有关，这就造成了calculateIncomeTax()不再是一个纯函数，它与当前时间相关了。 那怎么把calculateIncomeTax()恢复成一个纯函数，同时要支持起征点调整？ 方法是把时间相关的变量作为参数传进来，例如，给IncomeRecord增加几个字段： 1234567class IncomeRecord &#123; String id; // 身份证号 String name; // 姓名 double salary; // 工资 int year; // 年 int month; // 月&#125; 这样我们就可以消除today()的调用： 12345double calculateIncomeTax(IncomeRecord record) &#123; double threshold = date(record.year, record.month) &lt; date(2018, 9) ? 3500 : 5000; double tax = record.salary &lt;= threshold ? 0 : (record.salary - threshold) * 0.2; return tax;&#125; calculateIncomeTax()又变成了一个纯函数，会计就不用改电脑时间了。 是不是觉得这个例子太简单了？其实简单的函数如果都能写成有状态的，那么复杂的业务逻辑必然写成一锅粥。 举个复杂的栗子： 对于一个股票交易系统，如果我们把输入定义为：开盘前所有股民的现金和持股，以及交易时段的所有订单，那么，输出就是收盘后所有股民的现金和持股： 12345678StockStatus process(StockStatus old, List&lt;Order&gt; orders) &#123; ... for (Order order : orders) &#123; ... sendExchangeResult(...); // 给每一笔成交发送信息 &#125; ...&#125; 很显然这是一个纯函数，虽然在处理过程中，这个函数会给股民朋友发送各种心跳消息。 如果把交易系统的模型设计成这样一个纯函数，那么理论上我们只需要从股市开市的那一天开始，把所有订单全部处理一遍，就可以正确得到今天收盘后的状态。 或者说，只要取任意一天开盘前的系统状态的备份（就是整个数据库的备份），把当天的订单重新处理一遍，就得到了当天收盘的状态。这个过程可以做任意次，结果不变，因此，非常适合验证代码的修改是否影响了业务流程。 那么问题来了，交易系统中有无数和时间相关的状态，怎么处理成纯函数？这个模型的处理，可比计算个税复杂多了。 这就是函数式编程的精髓：业务系统模型无状态。模型的好坏，直接影响到代码的正确性、可靠性、稳定性，以及是否需要996。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"fork github仓库后，与原仓库进行同步","slug":"fork-github仓库后，与原仓库进行同步","date":"2022-04-29T03:02:39.000Z","updated":"2024-01-11T07:00:59.180Z","comments":true,"path":"2022/04/29/fork-github仓库后，与原仓库进行同步/","link":"","permalink":"/2022/04/29/fork-github仓库后，与原仓库进行同步/","excerpt":"fork了别人的github仓库，如何与原仓库进行同步？","text":"fork了别人的github仓库，如何与原仓库进行同步？ 前言我们在使用GitHub时，看到好的项目或想给某个项目做贡献，此时通常会将代码仓库fork到自己的账号下。如果在此期间，如果源仓库的代码发生了变动，就需要与源仓库代码进行同步。本篇文章就带大家实操一下，如何实现这一操作。 配置项目的上游仓库首先需要大家将fork的仓库代码clone到本地，后面的所有操作都是基于本地代码库来进行操作的。比如，可以通过git clone先将fork的代码下载到本地：1git clone git@github.com:secbr/nacos.git 后续的一步步操作，都是基于本地仓库来进行操作。 进入到本地仓库目录通过cd操作，进入到clone下来的本地仓库根目录：1cd /Users/apple/develop/nacos-request/nacos 后续的操作无特殊说明，都是在这个本地仓库的目录下进行操作。 查看远程仓库路径执行命令 git remote -v 查看远程仓库的路径：123appledeMacBook-Pro-2:nacos apple$ git remote -vorigin https://github.com/secbr/nacos.git (fetch)origin https://github.com/secbr/nacos.git (push) 如果只显示2行内容，说明该项目还未设置upstream （中文叫：上游代码库），一般情况下，设置好一次 upstream 后就无需重复设置。通过显示远程仓库的路径和clone时的路径对照，会发现，此时远程仓库的路径还是fork项目的路径。 添加upstream路径执行命令 git remote add upstream https://xxx.git，把fork的源仓库设置为 upstream 。这里项目是从alibaba的nacos仓库fork过来的，因此对应的upstream就是alibaba的源仓库地址。 执行上述命令，在此执行git remote -v 检查是否成功。123456appledeMacBook-Pro-2:nacos apple$ git remote add upstream https://github.com/alibaba/nacos.gitappledeMacBook-Pro-2:nacos apple$ git remote -vorigin https://github.com/secbr/nacos.git (fetch)origin https://github.com/secbr/nacos.git (push)upstream https://github.com/alibaba/nacos.git (fetch)upstream https://github.com/alibaba/nacos.git (push) 通过上面的输出可以看出，多了两项upstream的地址，说明添加upstream成功。 检查本地代码状态由于我们的实例是直接从仓库clone下来的，本地还没有修改代码。如果你的本地项目已经修改了一些代码，不确定是否提交了代码，就需要执行git status来检查一下。12345appledeMacBook-Pro-2:nacos apple$ git statusOn branch developYour branch is up to date with &apos;origin/develop&apos;.nothing to commit, working tree clean 上面显示，本地没有需要提交的（commit）的代码。如果本地有修改，需要先从本地仓库推送到GitHub仓库。然后，再执行一次 git status 检查。对应推送到GitHub仓库的基本操作步骤如下：1234git add -A 或者 git add filenamegit commit -m &quot;your note&quot;git push origin mastergit status 完成上面的基本操作之后，确认代码都已经提交，便可以开始执行源仓库与本地仓库的merge操作了。 抓取源仓库的更新经过上面步骤的准备之后，我们可以进行源仓库的代码更新了。执行命令 git fetch upstream 抓取原仓库的更新：123456789101112appledeMacBook-Pro-2:nacos apple$ git fetch upstreamremote: Enumerating objects: 2646, done.remote: Counting objects: 100% (2593/2593), done.remote: Compressing objects: 100% (1157/1157), done.remote: Total 2646 (delta 731), reused 2404 (delta 682), pack-reused 53Receiving objects: 100% (2646/2646), 1.67 MiB | 1.47 MiB/s, done.Resolving deltas: 100% (734/734), completed with 37 local objects.From https://github.com/alibaba/nacos * [new branch] 0.2.1 -&gt; upstream/0.2.1 * [new branch] 0.2.2 -&gt; upstream/0.2.2 * [new branch] 0.3.0 -&gt; upstream/0.3.0//...省略一部分 执行上述命令之后，上游仓库的更新（commit）会本存储为本地的分支，通常名称为：upstream/BRANCHNAME。比如上面的upstream/0.3.0。 切换分支完成了上游仓库分支的拉取之后，先来核查一下本地仓库当前处于哪个分支，也就是需要更新合并的分支。比如，这里我需要将develop分支的内容更新到与上游仓库代码一致。则先切换到develop分支：123appledeMacBook-Pro-2:nacos apple$ git checkout developAlready on &apos;develop&apos;Your branch is up to date with &apos;origin/develop&apos;. 上面提示已经是develop分支了。 执行合并执行命令 git merge upstream/develop 合并远程的develop分支。比如你合并的可能是master，可根据需要将develop的名称替换成对应的master。123456789appledeMacBook-Pro-2:nacos apple$ git merge upstream/developRemoving test/src/test/java/com/alibaba/nacos/test/naming/DeregisterInstance_ITCase.java// ...省略一部分Removing naming/src/test/java/com/alibaba/nacos/naming/core/PushServiceTest.javaAuto-merging client/src/main/java/com/alibaba/nacos/client/naming/remote/http/NamingHttpClientProxy.javaCONFLICT (content): Merge conflict in client/src/main/java/com/alibaba/nacos/client/naming/remote/http/NamingHttpClientProxy.javaRemoving client/src/main/java/com/alibaba/nacos/client/naming/core/HostReactor.javaRemoving .editorconfigAutomatic merge failed; fix conflicts and then commit the result. 执行完上述命令之后，会发现上游代码指定分支的修改内容已经反映到本地代码了。 上传代码到fork分支执行完上一步的合并操作之后，往后还有一些后续处理，比如代码冲突。如果本地修改了内容，上游仓库也修改了对应的代码，则可能会出现冲突。这时就需要对比代码进行修改。本人更习惯使用IDEA中可视化的插件进行代码冲突解决，你也可以选择你喜欢的方式进行解决。 解决完冲突之后，就可以执行正常的代码add、commit和push操作了。这里的一系列操作都是针对自己fork的仓库的，对应操作实例如下：12345678910111213appledeMacBook-Pro-2:nacos apple$ git add .appledeMacBook-Pro-2:nacos apple$ git commit -m &apos;merge from nacos&apos;[develop 8601c1791] merge from nacos appledeMacBook-Pro-2:nacos apple$ git pushEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 281 bytes | 281.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (1/1), completed with 1 local object.To https://github.com/secbr/nacos.git 76a4dcbb1..8601c1791 develop -&gt; develop 上述操作，通过add、commit、push一系列操作，将源仓库中的修改内容，提交到自己fork的分支当中了。此时再查看自己fork的GitHub仓库，发现代码已经更新。 小结本篇文章介绍了当我们fork一个仓库代码之后，如何将上游仓库最新的代码与自己仓库进行同步更新。如果你喜欢fork一些优秀的代码，需要在GitHub上为开源项目做贡献，那么这个基本的操作必须得了解一下。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"JavaScript设计模式与开发实践","slug":"JavaScript设计模式与开发实践","date":"2022-04-12T06:58:23.000Z","updated":"2024-01-11T07:00:59.131Z","comments":true,"path":"2022/04/12/JavaScript设计模式与开发实践/","link":"","permalink":"/2022/04/12/JavaScript设计模式与开发实践/","excerpt":"JavaScript设计模式与开发实践","text":"JavaScript设计模式与开发实践 JavaScript设计模式与开发实践基础知识面向对象的JavaScript::: tip编程语言按照数据类型大体分为两大类：一类是静态类型语言，一类是动态类型语言::: 静态类型语言的优缺点优点： 能够在编译时就能发现类型不匹配的错误 能够根据数据的不同类型进行针对的优化，提高程序的执行速度 缺点: 强迫程序员必须使用强契约来编写程序，为每一个变量规定数据类型 类型的声明会增加更多的代码，这些细节容易让程序员的精力从思考业务逻辑上分散开 动态类型语言的优缺点优点： 编写的代码数量更少，看起来也更简洁，程序员可以把精力更多的放在业务逻辑上面 缺点: 无法保证变量的类型，从而在程序运行期有可能发生跟类型相关的错误 鸭子类型::: tip如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子，鸭子类型指导我们只关注对象的行为，而不关注对象本身:::123456789101112131415161718192021// 鸭子类型var duck = &#123; duckSinging: function()&#123; console.log('嘎嘎嘎'); &#125;&#125;var chicken = &#123; duckSinging: function()&#123; console.log('嘎嘎嘎'); &#125;&#125;// 合唱团var choir = [];var joinChoir = function(animal) &#123; if(animal &amp;&amp; typeof animal.duckSinging === 'function') &#123; choir.push(animal); console.log('恭喜加入合唱团'); &#125;&#125;joinChoir(duck); // 恭喜加入合唱团joinChoir(chicken); // 恭喜加入合唱团 多态::: tip多态的含义是：同一操作作用于不同的对象，可以产生不同的解释和不同的执行结果:::12345678910111213141516171819202122// 多态var makeSound = function(animal) &#123; animal.sound();&#125;var Duck = function() &#123;&#125;;Duck.prototype.sound =function()&#123; console.log('嘎嘎嘎');&#125;var Chicken = function() &#123;&#125;;Chicken.prototype.sound = function() &#123; console.log('咯咯咯');&#125;makeSound(new Duck()); // 嘎嘎嘎makeSound(new Chicken()); // 咯咯咯var Dog = function() &#123;&#125;Dog.prototype.sound = function() &#123; console.log('汪汪汪');&#125;makeSound(new Dog()); // 汪汪汪 this，call和apply::: tipJavaScript中this始终指向一个对象，而具体指向哪个对象，是根据程序运行时的环境所决定的，不是在被声明时决定的::: this指向的四种情况 作为对象的方法调用 作为普通函数调用 构造器调用 Function.prototype.call 或 Function.prototype.apply调用 第一种：作为对象方法调用12345678// 第一种：作为对象方法调用var obj = &#123; a: 1, getA: function() &#123; console.log(this.a) &#125;&#125;obj.getA(); // 输出1 第二种：作为普通函数调用12345678910// 第二种：作为普通函数调用window.name = 'global-name';var obj = &#123; name: 'obj', getName: function() &#123; return this.name; &#125;&#125;var newGetName = obj.getName;console.log(newGetName()); // 输出global-name 第三种：作为构造器调用::: tipnew进行构造器调用时的步骤: 新创建一个对象 新对象进行原型委托 this绑定到这个新对象 如果构造器不返回其他对象，那么默认返回这个新对象:::123456789101112131415// 第三种：作为构造器调用function Student() &#123; this.name = 'why';&#125;var stu = new Student();console.log(stu.name); // 输出whyfunction Teacher() &#123; this.name = 'www'; return &#123; name: 'AAA' &#125;&#125;var teacher = new Teacher();console.log(teacher.name); // 输出AAA，而不是wwww 第四中：call和apply调用1234567891011// 第四中：call和apply调用var obj1 = &#123; name: 'why', getName: function() &#123; return this.name; &#125;&#125;var obj2 = &#123; name: 'AAA'&#125;console.log(obj1.getName.call(obj2)); // 输出AAA call和apply详解::: tip 区别 apply只接受两个参数，其中第二个参数是一个类数组或者数组 call可以接受多个参数，即参数不固定:::1234567// call和apply的区别var func = function(a,b,c) &#123; console.log([a,b,c]);&#125;// 当使用call和apply时，如果第一个参数传递的是null,则此时this指向全局对象func.apply(null,[1,2,3]); // 输出[1,2,3]func.call(null,1,2,3); // 输出[1,2,3] call和apply的用途::: tip 改变this指向 Function.prototype.bind绑定 借用其他对象的方法::: 改变this指向1234567891011121314// call和apply的用途：改变this指向var obj1 = &#123; name: 'why'&#125;var obj2 = &#123; name: 'www'&#125;window.name = 'global-name'var getName =function()&#123; return this.name;&#125;console.log(getName()); // 输出global-nameconsole.log(getName.call(obj1)); // 输出whyconsole.log(getName.apply(obj2)); // 输出www Function.prototype.bind绑定1234567891011121314151617181920212223242526272829303132333435// call和apply的用途：Function.prototype.bind绑定// 基础bind实现Function.prototype.bind = function(context) &#123; var self = this; return function() &#123; return self.apply(context,arguments); &#125;&#125;var obj = &#123; name: 'why'&#125;var func = function() &#123; console.log(this.name);&#125;.bind(obj);func(); // 输出why// 完善版bindFunction.prototype.bind = function() &#123; var self = this; var context = Array.prototype.shift.call(arguments); // 读取第一个参数，即this对象 var args = Array.prototype.slice.call(arguments); // 获取参数 return function () &#123; var newArgs = Array.prototype.concat.call(args,Array.prototype.slice.call(arguments)); return self.apply(context,newArgs); &#125;&#125;var obj1 = &#123; name: 'why'&#125;var func = function(a,b,c,d) &#123; console.log(this.name); console.log([a,b,c,d]);&#125;.bind(obj1,1,2);func(3,4); // 输出why [1,2,3,4] 借用其他对象的方法123456789101112// call和apply的用途：借用其他对象的方法var Foo = function(name) &#123; this.name = name;&#125;var Bar = function() &#123; Foo.apply(this,arguments);&#125;Bar.prototype.getName = function()&#123; return this.name;&#125;var bar = new Bar('why');console.log(bar.getName()); // 输出why 闭包和高阶函数闭包::: tip 全局变量的生存周期是永久的 局部变量在退出函数时，局部变量会被销毁 闭包能够延长局部变量的生存周期:::12345678910111213141516// 变量的生存周期window.name = 'why';function foo() &#123; var sex = '男'; console.log(sex);&#125;function bar() &#123; var age = 10; return function() &#123; return ++age; &#125;&#125;var _bar = bar();console.log(name); // 输出whyconsole.log(sex); // 报错console.log(_bar()); // 输出11 闭包的作用::: tip 封装变量 延续局部变量的寿命:::封装变量12345678910111213141516171819202122232425// 闭包的作用：封装变量// 实例：计算乘积var mult = (function()&#123; var cache = &#123;&#125;; // 小函数提取出来 var calculate = function() &#123; var a = 1; for(var i=0,len=arguments.length;i&lt;len;i++) &#123; a = a * arguments[i]; &#125; return a; &#125; // 闭包计算 return function() &#123; var args = Array.prototype.join.call(arguments,','); if(cache[args]) &#123; return cache[args] &#125; let result = calculate.apply([],arguments); cache[args] = result; return result; &#125;&#125;)()console.log(mult(1,2,3,4)); // 输出24 延续局部变量的寿命12345678910// 闭包的作用：延续局部变量的寿命// 实例：利用img进行数据上报var report = (function() &#123; var imgs = []; return function(src) &#123; var img = new Image(); imgs.push(img); img.src = src; &#125;&#125;)() 闭包和面向对象设计::: tip用面向对象思想能实现的功能，用闭包也能实现，反之亦然。:::12345678910111213141516171819202122232425// 闭包和面向对象设计var extent = function() &#123; var value = 0; return &#123; call: function() &#123; value++; console.log(value); &#125; &#125;&#125;var foo = extent();foo.call(); // 输出1foo.call(); // 输出2foo.call(); // 输出3var extent = &#123; value: 0, call: function() &#123; this.value++; console.log(this.value); &#125;&#125;extent.call(); // 输出1extent.call(); // 输出2extent.call(); // 输出3 面向对象和闭包实现命令模式面向对象实现命令模式12345678910111213141516171819202122232425262728293031// 面向对象实现命令模式var TV = &#123; open: function()&#123; console.log('打开电视'); &#125;, close: function()&#123; console.log('关闭电视') &#125;&#125;var TVCommand = function(receiver) &#123; this.receiver = receiver&#125;TVCommand.prototype.open = function()&#123; this.receiver.open();&#125;TVCommand.prototype.close = function()&#123; this.receiver.close();&#125;var setCommand = function(command) &#123; return &#123; open: function()&#123; command.open(); &#125;, close: function()&#123; command.close(); &#125; &#125;&#125;var obj = setCommand(new TVCommand(TV));obj.open(); // 输出打开电视obj.close(); // 输出关闭电视 闭包实现命令模式12345678910111213141516171819202122232425262728293031323334// 闭包实现命令模式var TV = &#123; open: function() &#123; console.log('打开电视') &#125;, close: function() &#123; console.log('关闭电视'); &#125;&#125;var createCommand = function(receiver) &#123; var open = function()&#123; receiver.open(); &#125;; var close = function()&#123; receiver.close(); &#125; return &#123; open: open, close: close &#125;&#125;var setCommand = function(command) &#123; return &#123; open: function()&#123; command.open(); &#125;, close: function() &#123; command.close(); &#125; &#125;&#125;var obj = setCommand(createCommand(TV));obj.open(); // 输出打开电视obj.close(); // 输出关闭电视 闭包在内存泄露上的争议 局部函数应该在函数退出时就销毁，而闭包却延续了局部变量的生存周期解答：闭包之所以会延长局部变量的生存周期，是因为该局部变量会在以后使用到，而需要使用到的变量，你把它存放在全局或者闭包里，对内存方面的影响是一致的。 使用闭包容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这可能会造成内存泄露解答：在IE浏览器中，垃圾回收机制是基于COM对象的引用计数策略，而基于此的垃圾回收机制无法在两个循环引用的对象之间进行回收，实质是并不是闭包的问题造成的。 高阶函数::: tip 条件 函数可以作为参数被传递 函数可以作为返回值输出:::JavaScript语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数作为参数传递还是让函数的执行结果返回另一个函数，这两种情形都有很多的应用场景。 函数作为参数传递123456789101112131415161718// 高阶函数的应用场景：函数作为参数传递// 应用场景：创建100个div，并将这些div节点设置隐藏var appendDiv = function(callback) &#123; for(var i=0;i&lt;100;i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); if(typeof callback === 'function') &#123; callback(div); &#125; &#125;&#125;// 回调函数var hideDiv = function(div) &#123; div.style.display = 'none';&#125;appendDiv(hideDiv); 函数作为返回值输出12345678910111213// 高阶函数的应用场景：函数作为返回值输出// 应用场景：注册isType方法var isType = function(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === '[object '+ type+']'; &#125;&#125;var isNumber = isType('Number');var isString = isType('String');var isArray = isType('Array');console.log(isNumber(12)); // 输出trueconsole.log(isString('abc')); // 输出trueconsole.log(isArray([1,2,3])); // 输出true 实现AOP::: tipAOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计，安全控制，异常处理等。把这些功能抽离出来后，再通过动态织入的方式掺入业务逻辑模块中:::1234567891011121314151617181920212223242526// 高阶函数的应用场景：实现AOP// 应用场景：装饰者模式Function.prototype.before = function(beforeFn) &#123; var _self = this; return function() &#123; beforeFn.apply(this,arguments); return _self.apply(this,arguments); &#125;&#125;Function.prototype.after = function(afterFn) &#123; var _self = this; return function() &#123; var ret = _self.apply(this,arguments); afterFn.apply(this,arguments); return ret; &#125;&#125;var func = function() &#123; console.log(2);&#125;func = func.before(function()&#123; console.log(1);&#125;).after(function()&#123; console.log(3);&#125;)func(); 高阶函数的其他用法柯里化：又称部分求值，一个柯里化参数首先会接受一些参数，接受这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到合适的时机一起求值。 其他用法：柯里化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 高阶函数其他用法：柯里化// 不完整的柯里化var cost = (function()&#123; var costs = []; return function() &#123; // 开始计算 if(arguments.length==0) &#123; var total = 0; for(var i=0;i&lt;costs.length;i++) &#123; total += costs[i]; &#125; return total; &#125; else &#123; Array.prototype.push.apply(costs,arguments); &#125; &#125;&#125;)()cost(100); // 未真正计算cost(200); // 未真正计算cost(20); // 未真正计算cost(10); // 未真正计算console.log(cost()); // 真正计算，输出330// 通用的柯里化var currying = function(fn) &#123; var args = []; return function() &#123; if(arguments.length==0) &#123; return fn.apply(this,args); &#125; else &#123; Array.prototype.push.apply(args,arguments); return arguments.callee; &#125; &#125;&#125;var cost = (function()&#123; var money = 0; return function() &#123; for(var i = 0,len = arguments.length;i&lt;len;i++) &#123; money +=arguments[i]; &#125; return money; &#125;&#125;)()var cost = currying(cost);cost(100);cost(200);cost(20);cost(10);console.log(cost()); // 输出330 其他用法：函数节流将原本一秒执行10次的事件，节流成一秒执行2次或者3次::: tip 函数节流的场景 window.onresize事件 mouseover事件 scroll事件 其他:::1234567891011121314151617181920212223242526272829// 高阶函数其他用法：函数节流// 应用场景：window.onresize事件var throttle = function(fn,interval) &#123; var timer = null; var firstTime = true; var _self = fn; return function() &#123; var that = this; var args = arguments; // 判断是否第一次执行 if(firstTime) &#123; _self.apply(that,args); return firstTime = false &#125; // 判断定时器是否执行完毕 if(timer) &#123; return false; &#125; timer = setTimeout(function() &#123; clearTimeout(timer); timer = null; _self.apply(that,args); &#125;,interval || 500) &#125;&#125;window.onresize = throttle(function()&#123; console.log('window onsize');&#125;, 500) 其他用法：分时函数12345678910111213141516171819202122232425262728293031323334353637383940// 高阶函数其他用法：分时函数// 应用场景：分批次创建1000个DOM节点// 分时函数// 参数arr：要填充的数据// 参数fn：要分时的函数// 参数count：每一次分时的数量// 参数interval：分时的间隔var timeChunk = function(arr,fn,count,interval) &#123; var timer = null; var data = null; var start = function() &#123; for(var i = 0 ; i &lt; Math.min(count || 1 , arr.length) ; i++) &#123; data = arr.shift(); fn(data); &#125; &#125; return function() &#123; timer = setInterval(function()&#123; if(arr.length == 0) &#123; clearInterval(timer); timer = null; return; &#125; start(); &#125;, interval || 200) &#125;&#125;var arr = [];for(var i = 0 ; i &lt; 1000 ; i++) &#123; arr.push(i);&#125;var renderDOMList = timeChunk(arr, function(data) &#123; var div = document.createElement('div'); div.innerHTML = data; document.body.appendChild(div);&#125;,8,200);renderDOMList(); 设计模式第二部分设计模式并没有全部覆盖GoF所提出的23种设计模式，而是选择了在JavaScript开发中更常见的14种设计模式 单例设计模式::: tip 定义单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。::: 单例设计模式的案例 线程池 全局缓存 浏览器中的window对象 网页登录浮窗 等等 单例设计模式的实现：面向对象1234567891011121314151617181920212223// 单例设计模式的实现：面向对象var Singleton = function(name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function()&#123; return this.name;&#125;Singleton.getInstance = function(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var instance1 = Singleton.getInstance('why');var instance2 = Singleton.getInstance('www');console.log(instance1===instance2); // 输出truevar obj1 = new Singleton('why');var obj2 = new Singleton('www');console.log(obj1.getName()); // 输出whyconsole.log(obj2.getName()); // 输出www 单例设计模式的实现：闭包1234567891011121314151617181920// 单例设计模式的实现：闭包var Singleton = function(name) &#123; this.name = name;&#125;Singleton.prototype.getName = function() &#123; return this.name;&#125;Singleton.getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name) &#125; return instance; &#125;&#125;)()var instance1 = Singleton.getInstance('why');var instance2 = Singleton.getInstance('www');console.log(instance1 === instance2); // 输出true 透明的单例设计模式无论以上面向对象的单例实现还是闭包的单例实现，都通过Singleton.getInstance来获取Singleton类的唯一对象，这增加了这个类的不透明性，使用者必须知道Singleton是一个单例类，然后通过Singleton.getInstance方法才能获取单例对象，要解决这一问题，可以使用透明的单例设计模式1234567891011121314151617181920212223// 透明的单例模式var CreateDiv = (function()&#123; var instance = null; var CreateDiv = function(html) &#123; if(instance) &#123; return instance; &#125; this.html = html; this.init(); instance = this; return instance; &#125; CreateDiv.prototype.init = function() &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div); &#125; return CreateDiv;&#125;)()var instance1 = new CreateDiv('why');var instance2 = new CreateDiv('www');console.log(instance1===instance2); // 输出true 用代理实现单例模式虽然上述透明的单例设计模式解决了不用通过Singleton.getInstance来获取单例类的唯一对象，但是在透明的单例设计模式中，构造函数CreateDiv违反了单一职责，它不仅要负责创建对象，而且还要负责保证单例，假如某一天需求变化了，不再需要创建单例的div，则需要改写CreateDiv函数，解决这种问题，可以使用代理来实现单例模式1234567891011121314151617181920212223// 用代理实现单例模式var CreateDiv = function(html) &#123; this.html = html; this.init();&#125;CreateDiv.prototype.init = function() &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125;var ProxyCreateDiv = (function()&#123; var instance = null; return function(html) &#123; // 惰性单例 if(!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)()var divInstance1 = new ProxyCreateDiv('why');var divInstance2 = new ProxyCreateDiv('www');console.log(divInstance1===divInstance2); // 输出true 策略模式::: tip 定义策略模式：定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换。::: 策略模式的优点 策略模式利用组合、委托和多态等技术的思想，可以有效的避免多重条件分支语句 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的策略类中，使它们易于切换、易于理解、易于扩展。 策略模式中的算法也可以复用在系统的其他地方 策略模式利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 策略模式案例：计算奖金案例描述：某公司的年终奖是根据员工的工资基数和年底绩效来发放的。例如，绩效为S的人年终奖有4倍工资，绩效为A的人年终奖有3倍工资，绩效为B的人年终奖有2倍工资，财务部要求我们提供一段代码，来方便他们计算员工的年终奖。 计算奖金：最初版本123456789101112131415// 计算奖金：最初版本var calculateBouns = function(level,salary) &#123; if(level=='S') &#123; return salary * 4; &#125; if(level=='A') &#123; return salary * 3; &#125; if(level=='B') &#123; return salary * 2; &#125;&#125;console.log(calculateBouns('S',4000)); // 输出16000console.log(calculateBouns('A',3000)); // 输出9000console.log(calculateBouns('B',2000)); // 输出4000 计算奖金：面向对象完善版本1234567891011121314151617181920212223242526272829303132333435363738394041// 计算奖金：面向对象完善版本var PerformanceS = function()&#123;&#125;;PerformanceS.prototype.calculate = function(salary) &#123; return salary * 4;&#125;var PerformanceA = function()&#123;&#125;;PerformanceA.prototype.calculate = function(salary) &#123; return salary * 3;&#125;var PerformanceB = function()&#123;&#125;;PerformanceB.prototype.calculate = function(salary) &#123; return salary * 2;&#125;var Bouns = function() &#123; this.salary = null; this.strategy = null;&#125;Bouns.prototype.setSalary = function(salary) &#123; this.salary = salary;&#125;Bouns.prototype.setStrategy = function(strategy) &#123; this.strategy = strategy;&#125;Bouns.prototype.getBouns = function() &#123; return this.strategy.calculate(this.salary);&#125;var bouns = new Bouns();bouns.setSalary(4000);bouns.setStrategy(new PerformanceS());console.log(bouns.getBouns()); // 输出16000bouns.setSalary(3000);bouns.setStrategy(new PerformanceA());console.log(bouns.getBouns()); // 输出9000bouns.setSalary(2000);bouns.setStrategy(new PerformanceB());console.log(bouns.getBouns()); // 输出4000 计算奖金：JavaScript的完善版本123456789101112131415161718// 计算奖金：JavaScript的完善版本var strategy = &#123; 'S': function(salary) &#123; return salary * 4; &#125;, 'A': function(salary) &#123; return salary * 3; &#125;, 'B': function(salary) &#123; return salary * 2; &#125;&#125;var calcluateBouns = function(level,salary) &#123; return strategy[level](salary);&#125;console.log(calcluateBouns('S',4000)); // 输出16000console.log(calcluateBouns('A',3000)); // 输出9000console.log(calcluateBouns('B',2000)); // 输出4000 策略模式案例：表单验证::: tip 表单标签 用户名(验证是否为空) 密码(验证长度不能小于6位) 手机号(验证是否是手机号格式):::1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 策略模式案例：表单验证var strategies = &#123; isEmpty: function(value,errMsg) &#123; if(value==='') &#123; return errMsg &#125; &#125;, minLength: function(value,length,errMsg) &#123; if(value.length&lt;length) &#123; return errMsg &#125; &#125;, isMobile: function(value,errMsg) &#123; if(!(/^1[34578]\\d&#123;9&#125;$/.test(value))) &#123; return errMsg &#125; &#125;&#125;var Validator = function() &#123; this.cache = [];&#125;Validator.prototype.add = function(dom,rule,msg) &#123; var ary = rule.split(':'); this.cache.push(function()&#123; var strategy = ary.shift(); ary.unshift(dom.value); ary.push(msg); return strategies[strategy].apply(dom,ary); &#125;);&#125;Validator.prototype.run = function() &#123; for (let index = 0; index &lt; this.cache.length; index++) &#123; var msg = this.cache[index](); if(msg) &#123; return msg; &#125; &#125;&#125;var validateFunc = function() &#123; var validator = new Validator(); validator.add(registerForm.username,'isEmpty','用户名不能为空'); validator.add(registerForm.password,'minLength:6','密码长度不能小于6位'); validator.add(registerForm.phone,'isMobile','手机号格式不正确'); var errMsg = validator.run(); return errMsg;&#125;var submitBtn = document.getElementById('submitBtn');var registerForm = document.getElementById('registerForm');submitBtn.onclick = function() &#123; var errMsg = validateFunc(); if(errMsg) &#123; console.log(errMsg); return false; &#125; else &#123; console.log('表单验证成功') &#125;&#125; 代理模式::: tip 定义代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。:::代理模式的关键所在就是：当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象，替身对象作出一些请求后再把请求转接给本体对象 简单的代理：小明追女神::: tip 场景小明打算向女神表白，又怕直接被拒绝而尴尬，决定找女神的同学帮忙转接鲜花给女神:::12345678910111213141516171819var Flower = function() &#123;&#125;;var xiaoming = &#123; sendFlower: function(target) &#123; var flower = new Flower(); target.receive(flower); &#125;&#125;var classmate = &#123; receive: function(flower) &#123; girl.receive(flower); &#125;&#125;var girl = &#123; receive: function(flower) &#123; console.log('女神收到了花'); &#125;&#125;xiaoming.sendFlower(classmate); // 输出女神收到了花 保护代理::: tip在代理模式中，替身对象能做到过滤一些对本体不合理的请求时，这种代理就叫保护代理:::123456789101112131415161718192021222324252627282930313233343536// 保护代理function Flower() &#123;&#125;;function Person(name,age,salary) &#123; this.age = age; this.name = name; this.salary = salary;&#125;Person.prototype.sendFlower = function(target,person)&#123; var flower = new Flower(); target.receive(flower,person);&#125;var person1 = new Person('www',20,4000);var person2 = new Person('AAA',25,8000);var person3 = new Person('BBB',45,16000);var proxyObj = &#123; receive: function(flower,person) &#123; if(person.age&gt;=40) &#123; console.log(person.name+',你年龄太大了'); return false; &#125; if(person.salary&lt;5000) &#123; console.log(person.name+',你工资太低了'); return false; &#125; originObj.receive(flower); console.log(person.name+',恭喜你,女神收下了你的花'); &#125;&#125;var originObj = &#123; receive: function(flower) &#123; &#125;&#125;person1.sendFlower(proxyObj,person1); // 输出www,你工资太低了person2.sendFlower(proxyObj,person2); // 输出AAA,恭喜你,女神收下了你的花person3.sendFlower(proxyObj,person3); // 输出BBB,你年龄太大了 虚拟代理::: tip将一些代价昂贵的操作放置在代理对象中，待到机会合适时再进行，这种代理就叫虚拟代理:::123456789101112131415161718192021222324252627282930// 虚拟代理function Flower() &#123;&#125;;var xiaoming = &#123; sendFlower: function(target) &#123; target.receiveFlower(); &#125;&#125;var classmate = &#123; receiveFlower: function() &#123; girl.listenMood(function() &#123; var flower = new Flower(); console.log('同学帮你买了花,并送了出去'); girl.receiveFlower(flower); &#125;) &#125;&#125;var girl = &#123; mood: 0, receiveFlower: function(flower) &#123; console.log('女神收下了你的花'); &#125;, listenMood: function(fn) &#123; setTimeout(function()&#123; fn(); &#125;,1500) &#125;&#125;// 首先输出：同学帮你买了花,并送了出去、// 最后输出：女神收下了你的花xiaoming.sendFlower(classmate); 代理模式实现图片懒加载不用代理实现12345678910111213141516// 不用代理实现图片懒加载var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); var img = new Image(); img.onload = function() &#123; imgNode.src = img.src; &#125; return &#123; setSrc: function(src) &#123; imgNode.src = 'file:///C:/Users/admin/Desktop/mask/img/7.jpg' img.src = src; &#125; &#125;&#125;)()myImage.setSrc('https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg') 用代理实现图片懒加载123456789101112131415161718192021222324// 用代理实现图片懒加载var myImage = (function()&#123; var image = document.createElement('img'); document.body.appendChild(image); return &#123; setSrc: function(src) &#123; image.src = src; &#125; &#125;&#125;)();var proxyImage = (function()&#123; var img = new Image(); img.onload = function() &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; myImage.setSrc('file:///C:/Users/admin/Desktop/mask/img/7.jpg'); img.src = src; &#125; &#125;&#125;)()proxyImage.setSrc('https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg'); 缓存代理::: tip缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一样，则可以直接返回前面存储的运算结果。:::123456789101112131415161718192021// 缓存代理：计算乘积var mult = function() &#123; console.log('开始计算乘积'); var sum = 1; for(var i=0;i&lt;arguments.length;i++) &#123; sum = sum * arguments[i]; &#125; return sum;&#125;var proxyMult = (function()&#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments,','); if(cache.hasOwnProperty(args)) &#123; return cache[args]; &#125; return cache[args] = mult.apply(this,arguments) &#125;&#125;)()console.log(proxyMult(1,2,3,4)); // 输出：开始计算乘积 24console.log(proxyMult(1,2,3,4)); // 输出24 举一反三代理工厂12345678910111213141516171819202122232425262728293031323334// 代理工厂(累加和乘积)var mult = function() &#123; console.log('开始计算乘积') var sum = 1; for (let index = 0; index &lt; arguments.length; index++) &#123; sum = sum * arguments[index] &#125; return sum;&#125;var plus = function() &#123; console.log('开始计算累加') var sum = 0; for (let index = 0; index &lt; arguments.length; index++) &#123; sum = sum + arguments[index] &#125; return sum;&#125;var createProxyFactory = function(fn) &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments,','); if(cache.hasOwnProperty(args)) &#123; return cache[args] &#125; return cache[args] = fn.apply(this,arguments); &#125;&#125;var proxyMult = createProxyFactory(mult);var proxyPlus = createProxyFactory(plus);console.log(proxyMult(1,2,3,4)); // 输出：开始计算乘积 24console.log(proxyMult(1,2,3,4)); // 输出： 24console.log(proxyPlus(3,4,5,6)); // 输出：开始计算累加 18console.log(proxyPlus(3,4,5,6)); // 输出 18 迭代器模式::: tip迭代器模式是指提供一种顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器分为两种，一种是内部迭代器，另外一种是外部迭代器::: 内部迭代器::: tip内部迭代器在调用的时候非常方便，外界不用关心迭代器内部到底是如何实现的，跟迭代器的交互也只有一次初始调用，而这也正好是内部迭代器的缺点。:::Jquery中的迭代器12345// Jquery中的迭代器$.each([1,2,3],function(index,value) &#123; console.log(index); console.log(value);&#125;) 实现自己的each迭代器12345678910// 实现自己的each迭代器var each = function(array,callback) &#123; for(var i=0;i&lt;array.length;i++) &#123; callback.call(null,i,array[i]); &#125;&#125;each([1,2,3],function(index,value)&#123; console.log(index);// 依次输出0 1 2 console.log(value);// 依次输出1 2 3&#125;) 外部迭代器::: tip外部迭代器必须显示的请求迭代下一个元素:::123456789101112131415161718192021222324252627282930313233343536// 自定义外部迭代器实现比较两个数组的值是否完全相等var Iterator = function(obj) &#123; var current = 0; var next = function() &#123; current++; &#125; var isDone = function() &#123; return current &gt;=obj.length; &#125; var getCurrentItem = function() &#123; return obj[current]; &#125; return &#123; next: next, isDone: isDone, getCurrentItem:getCurrentItem, length: obj.length &#125;&#125;var compare = function(iterator1,iterator2) &#123; if(iterator1.length!=iterator2.length) &#123; console.log('两个数组不相等'); return false; &#125; while(!iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123; if(iterator1.getCurrentItem()!=iterator2.getCurrentItem()) &#123; throw new Error('两个数组不相等') &#125; iterator1.next(); iterator2.next(); &#125; console.log('两个数组相等')&#125;var iterator1 = Iterator([1,2,3]);var iterator2 = Iterator([1,2,4]);compare(iterator1,iterator2); // 报错，两个数组不相等 发布-订阅模式::: tip 定义发布-订阅模式又叫观察者模式，他定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。::: 优点：发布-订阅模式一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更加松耦合的代码编写。发布-订阅模式还可以用来帮助实现一些其他的设计模式，例如中介者模式。缺点：创建订阅者本身要消耗一定的时间和内存，而当你订阅一个消息后，也许此消息最后都没有发生，但订阅者依然存在于内存中，造成了一种浪费。发布-订阅模式虽然弱化了对象之间的联系，但过度使用的话，对象和对象之间的必要联系也将深埋在背后，会导致程序难以追踪维护和理解。 DOM事件中的发布-订阅只要我们曾经在DOM节点上绑定了事件函数，那我们就曾经使用过发布-订阅模式。1234567891011121314// DOM事件中的发布-订阅模式document.body.addEventListener('click',function()&#123; console.log(1);&#125;)document.body.addEventListener('click',function() &#123; console.log(2);&#125;)document.body.addEventListener('click',function() &#123; console.log(3);&#125;)document.body.addEventListener('click',function()&#123; console.log(4);&#125;)document.body.click(); // 输出1 2 3 4 自定义发布-订阅背景：小明最近看中一套房子，到销售中心才告知已经卖完了，好在销售楼中心准备出后期工程，但不知道什么时候出，只要小明留下自己的联系方式，楼盘开启后销售中心会通知小明相关信息。而对于其他像小明那样的客户，只要同样留下联系方式都可以收到相关信息。123456789101112131415161718192021222324252627282930313233// 自定义发布-订阅事件var sales = &#123; clientList: &#123;&#125;, listen: function(key,fn) &#123; if(!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn) &#125;, trigger: function() &#123; var type = Array.prototype.shift.call(arguments); var fns = this.clientList[type]; if(!fns || fns.length&lt;1) &#123; return false; &#125; for (let index = 0; index &lt; fns.length; index++) &#123; fns[index].apply(this,arguments) &#125; &#125;&#125;// 订阅sales.listen('88',function(price)&#123; console.log('88平米的房子价格是：'+price);&#125;)sales.listen('100',function(price)&#123; console.log('100平米的房子价格是：'+price);&#125;)// 发布sales.trigger('88',200000); // 88平米的房子价格是：200000sales.trigger('100',300000); // 100平米的房子价格是：300000 取消订阅的事件发布-订阅模式中，既然可以订阅事件，那么一定可以取消订阅，假设小明突然不想买房子了，为避免销售中心发短信打搅自己，他决定取消订阅。12345678910111213141516171819202122232425262728293031323334353637383940414243// 取消订阅事件var sales = &#123; clientList: &#123;&#125;, listen: function(key,fn) &#123; if(!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger: function() &#123; var type = Array.prototype.shift.call(arguments); var fns = this.clientList[type] if(!fns || fns.length&lt;1) &#123; return false; &#125; for (let index = 0; index &lt; fns.length; index++) &#123; fns[index].apply(this,arguments); &#125; &#125;, remove: function(type) &#123; var fns = this.clientList[type]; if(!fns || fns.length&lt;1) &#123; return false; &#125; // 全部取消订阅 fns.length = 0; &#125;&#125;// 订阅sales.listen('88',function(price)&#123; console.log('88平米的房子价格是：'+price);&#125;)sales.listen('100',function(price)&#123; console.log('100平米的房子价格是：'+price);&#125;)// 取消订阅sales.remove('88');// 发布sales.trigger('88',200000); // 不输出sales.trigger('100',300000); // 100平米的房子价格是：300000 一个真实的例子：网站登录背景：一个商场网站，有头部header，有导航nav，有购物车cart，有消息列表message等等模块度依赖于登录成功后的用户信息。而用户不知道什么时候会登陆。需要将以上各个模块与登录模块做一个发布-订阅12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 一个真实的发布-订阅例子：网站登录var login = &#123; clientList: &#123;&#125;, listen: function(key,fn) &#123; if(!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger: function() &#123; var type = Array.prototype.shift.call(arguments); var fns = this.clientList[type]; if(!fns || fns.length&lt;1) &#123; return false; &#125; for (let index = 0; index &lt; fns.length; index++) &#123; fns[index].apply(this,arguments); &#125; &#125;&#125;// 头部var header = (function()&#123; login.listen('loginSuccess',function(data) &#123; header.setAvatar(data.avatar); &#125;) return &#123; setAvatar: function(avatar) &#123; console.log('设置header头像：'+avatar); &#125; &#125;&#125;)()// 导航var nav = (function()&#123; login.listen('loginSuccess',function(data) &#123; nav.setAvatar(data.avatar); &#125;) return &#123; setAvatar: function(avatar) &#123; console.log('设置nav头像：'+avatar); &#125; &#125;&#125;)()// 购物车var cart = (function()&#123; login.listen('loginSuccess',function(data) &#123; cart.getOrders(data); &#125;) return &#123; getOrders: function(data) &#123; console.log('获取'+data.name+'的购物车订单列表'); &#125; &#125;&#125;)()setTimeout(function() &#123; // 依次输出 // 设置header头像：https://www.baidu.com/1.jpg // 设置nav头像：https://www.baidu.com/1.jpg // 获取AAA的购物车订单列表 login.trigger('loginSuccess',&#123;name:'AAA',avatar: 'https://www.baidu.com/1.jpg'&#125;);&#125;, 1500) 命令模式::: tip 定义命令模式是最简单和优雅的模式之一，命令模式中的命令指的是一个执行某些特定事件的指令。::: 应用场景有时候需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是什么。此时希望有一种松耦合的方式来设计程序，使得请求发送者和接受者能够消除彼此之间的耦合关系。 命令模式案例：面向对象版故事背景：有一个用户界面程序，该用户界面上至少有数十个Button按钮，因为项目比较复杂，所以我们觉得让某个程序员负责Button按钮的绘制，另外一个程序员负责编写点击按钮的具体行为，这些行为都将封装在对象里。123&lt;button type=\"button\" id=\"button1\"&gt;刷新界面&lt;/button&gt;&lt;button type=\"button\" id=\"button2\"&gt;添加子菜单&lt;/button&gt;&lt;button type=\"button\" id=\"button3\"&gt;删除子菜单&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 面向对象版本var button1 = document.getElementById('button1');var button2 = document.getElementById('button2');var button3 = document.getElementById('button3');// 设置命令var setCommand = function(button,command) &#123; button.onclick = function() &#123; command.execute(); &#125;&#125;// 具体行为var MenuBar = &#123; refresh: function() &#123; console.log('刷新界面'); &#125;&#125;var SubMenu = &#123; add: function()&#123; console.log('添加子菜单'); &#125;, remove: function() &#123; console.log('删除子菜单'); &#125;&#125;// 封装具体行为到对象中var RefreshBarCommand = function(receiver) &#123; this.receiver = receiver;&#125;RefreshBarCommand.prototype.execute = function() &#123; this.receiver.refresh();&#125;var AddSubMenuCommand = function(receiver) &#123; this.receiver = receiver;&#125;AddSubMenuCommand.prototype.execute = function() &#123; this.receiver.add();&#125;var RemoveSubMenuCommand = function(receiver) &#123; this.receiver = receiver;&#125;RemoveSubMenuCommand.prototype.execute = function() &#123; this.receiver.remove();&#125;// 传入命令接受者var refreshBarCommand = new RefreshBarCommand(MenuBar);var addSubMenuCommand = new AddSubMenuCommand(SubMenu);var removeSubMenuCommand = new RemoveSubMenuCommand(SubMenu);setCommand(button1,refreshBarCommand); // 点击按钮输出：刷新界面setCommand(button2,addSubMenuCommand); // 点击按钮输出：添加子菜单setCommand(button3,removeSubMenuCommand); // 点击按钮输出：删除子菜单 命令模式案例：闭包版本123&lt;button type=\"button\" id=\"button1\"&gt;刷新界面&lt;/button&gt;&lt;button type=\"button\" id=\"button2\"&gt;添加子菜单&lt;/button&gt;&lt;button type=\"button\" id=\"button3\"&gt;删除子菜单&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 闭包版本var button1 = document.getElementById('button1');var button2 = document.getElementById('button2');var button3 = document.getElementById('button3');// 设置命令var setCommand = function(button,func) &#123; button.onclick = function() &#123; func(); &#125;&#125;// 定义具体行为var MenuBar = &#123; refresh: function() &#123; console.log('刷新界面'); &#125;&#125;var SubMenu = &#123; add: function() &#123; console.log('添加子菜单'); &#125;, remove: function() &#123; console.log('删除子菜单'); &#125;&#125;// 封装具体行为到对象var RefreshBarCommand = function(receiver) &#123; return function() &#123; receiver.refresh(); &#125;&#125;var AddSubMenuCommand = function(receiver) &#123; return function() &#123; receiver.add(); &#125;&#125;var RemoveSubMenuCommand = function(receiver) &#123; return function() &#123; receiver.remove(); &#125;&#125;// 传入命令接受者var refreshBarCommand = RefreshBarCommand(MenuBar);var addSubMenuCommand = AddSubMenuCommand(SubMenu);var removeSubMenuCommand = RemoveSubMenuCommand(SubMenu);setCommand(button1,refreshBarCommand); // 点击按钮输出：刷新界面setCommand(button2,addSubMenuCommand); // 点击按钮输出：添加子菜单setCommand(button3,removeSubMenuCommand); // 点击按钮输出：删除子菜单 更为简单的回调函数版本123&lt;button type=\"button\" id=\"button1\"&gt;刷新界面&lt;/button&gt;&lt;button type=\"button\" id=\"button2\"&gt;添加子菜单&lt;/button&gt;&lt;button type=\"button\" id=\"button3\"&gt;删除子菜单&lt;/button&gt; 12345678910111213141516171819202122232425// 更为简单的回调函数版本// 绑定事件var bindClick = function(button,func) &#123; button.onclick = func;&#125;// 定义具体行为var MenuBar = &#123; refresh: function() &#123; console.log('刷新界面'); &#125;&#125;var SubMenu = &#123; add: function()&#123; console.log('添加子菜单'); &#125;, remove: function() &#123; console.log('删除子菜单'); &#125;&#125;// 回调函数bindClick(button1,MenuBar.refresh); // 点击按钮输出：刷新界面bindClick(button2,SubMenu.add); // 点击按钮输出：添加子菜单bindClick(button3,SubMenu.remove); // 点击按钮输出：删除子菜单 宏命令::: tip 定义宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行多个命令。:::1234567891011121314151617181920212223242526272829303132333435363738394041// 宏命令// 基础命令var CloseDoorCommand = &#123; execute: function() &#123; console.log('关门') &#125;&#125;var OpenTVCommand = &#123; execute: function() &#123; console.log('打开电视') &#125;&#125;var OpenQQComand = &#123; execute: function() &#123; console.log('登QQ') &#125;&#125;// 宏命令var MacroCommand = function() &#123; return &#123; commandList: [], add: function(command) &#123; this.commandList.push(command) &#125;, execute: function() &#123; for (let index = 0; index &lt; this.commandList.length; index++) &#123; this.commandList[index].execute(); &#125; &#125; &#125;&#125;// 添加命令到宏命令var macroCommand = MacroCommand();macroCommand.add(CloseDoorCommand);macroCommand.add(OpenTVCommand);macroCommand.add(OpenQQComand);// 执行宏命令macroCommand.execute(); // 依次输出：关门 打开电视 登QQ 组合模式::: tip组合模式将对象组合成树形结构，以表示”部分-整体”的层次结构。::: 传递顺序对宏命令为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求做出相应的处理。如果当前处理请求的是组合对象，则遍历该组合对象下的子节点，将请求继续传递给这些子节点。 更强大的宏命令万能遥控器: 打开空调 打开电视和音响 关门、打开电脑、登录QQ1&lt;button type=\"button\" id=\"SuperButton\"&gt;万能遥控器&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 更强大的宏命令var MacroCommand = function() &#123; return &#123; commandList: [], add: function(command) &#123; this.commandList.push(command) &#125;, execute: function() &#123; for (let index = 0; index &lt; this.commandList.length; index++) &#123; this.commandList[index].execute(); &#125; &#125; &#125;&#125;// 打开空调var openAcCommand = &#123; execute: function() &#123; console.log('打开空调'); &#125;&#125;// 打开电视和音响var openTVCommand = &#123; execute: function() &#123; console.log('打开电视'); &#125;&#125;var openSoundCommand = &#123; execute: function() &#123; console.log('打开音响') &#125;&#125;var macroCommand1 = MacroCommand();macroCommand1.add(openTVCommand);macroCommand1.add(openSoundCommand);// 关门、开电脑、登QQvar closeCommand = &#123; execute: function() &#123; console.log('关门') &#125;&#125;var openPcCommand = &#123; execute: function() &#123; console.log('打开电脑') &#125;&#125;var openQQCommand = &#123; execute: function() &#123; console.log('登录QQ') &#125;&#125;var macroCommand2 = MacroCommand();macroCommand2.add(closeCommand);macroCommand2.add(openPcCommand);macroCommand2.add(openQQCommand);// 宏命令var macroCommand = MacroCommand();macroCommand.add(openAcCommand);macroCommand.add(macroCommand1);macroCommand.add(macroCommand2);// 触发宏命令var setCommand = (function(command)&#123; document.getElementById('SuperButton').onclick = function() &#123; // 依次输出：打开空调 打开电视 打开音响 关门 打开电脑 登录QQ command.execute(); &#125;&#125;)(macroCommand) 组合模式案例：扫描文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 组合模式案例：文件扫描// 文件夹类var Folder = function(name) &#123; this.name = name; this.files = [];&#125;Folder.prototype.add = function(file) &#123; this.files.push(file);&#125;Folder.prototype.scan = function() &#123; console.log('开始扫描文件夹:'+this.name); for (let index = 0; index &lt; this.files.length; index++) &#123; this.files[index].scan(); &#125;&#125;// 文件类var File = function(name) &#123; this.name = name;&#125;File.prototype.add = function() &#123; throw new Error('文件下面不能添加文件');&#125;File.prototype.scan = function() &#123; console.log('开始扫描文件：'+this.name)&#125;var folder = new Folder('学习资料');var folder1 = new Folder('JavaScript');var folder2 = new Folder('jQuery');var folder3 = new Folder('重构与实现');var folder4 = new Folder('NodeJs');var file1 = new File('JavaScript设计模式');var file2 = new File('精通jQuery');var file3 = new File('JavaScript语言精粹');var file4 = new File('深入浅出的Node.js');folder1.add(file1);folder2.add(file2);folder4.add(file4);folder.add(folder1);folder.add(folder2);folder.add(file3);folder.add(folder3);folder.add(folder4);// 执行扫描// 开始扫描文件夹:学习资料// 开始扫描文件夹:JavaScript// 开始扫描文件：JavaScript设计模式// 开始扫描文件夹:jQuery// 开始扫描文件：精通jQuery// 开始扫描文件：JavaScript语言精粹// 开始扫描文件夹:重构与实现// 开始扫描文件夹:NodeJs// 开始扫描文件：深入浅出的Node.jsfolder.scan(); 模板方法模式::: tip 定义模板方法是一种只需使用继承就可以实现的非常简单的模式。模板方法由两部分组成，一部分是抽象的父类，另一部分是具体的子类。:::通常而言，在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承抽象的父类，也继承了整个算法结构。 模板方法：经典案例泡咖啡的步骤： 把水煮沸 用沸水泡咖啡 把咖啡倒进杯子 加糖和牛奶123456789101112131415161718192021222324// 泡咖啡var Coffee = function()&#123;&#125;;Coffee.prototype.boilWater = function() &#123; console.log('把水煮沸');&#125;Coffee.prototype.brewCoffee = function() &#123; console.log('冲泡咖啡');&#125;Coffee.prototype.purInCup = function() &#123; console.log('把咖啡倒进杯子里');&#125;Coffee.prototype.addSugarAndMilk = function() &#123; console.log('加牛奶和糖')&#125;Coffee.prototype.init = function() &#123; this.boilWater(); this.brewCoffee(); this.purInCup(); this.addSugarAndMilk();&#125;var coffee = new Coffee();// 依次输出： 把水煮沸 冲泡咖啡 把咖啡倒进杯子里 加牛奶和糖coffee.init(); 泡茶的步骤: 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬1234567891011121314151617181920212223// 泡茶var Tea = function() &#123;&#125;;Tea.prototype.boilWater = function() &#123; console.log('把水煮沸');&#125;Tea.prototype.brewTea = function() &#123; console.log('用沸水浸泡茶叶');&#125;Tea.prototype.purInCup = function() &#123; console.log('把茶水倒进杯子')&#125;Tea.prototype.addLemon = function() &#123; console.log('加柠檬');&#125;Tea.prototype.init = function() &#123; this.boilWater(); this.brewTea(); this.purInCup(); this.addLemon();&#125;var tea = new Tea();// 依次输出： 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬tea.init(); 泡茶经典案例重构经过对比分析，泡咖啡和泡茶虽然具体实现的方法是不一样的，但是步骤大致是类似的： 把水煮沸 用沸水 倒进杯子 加调料 泡咖啡和泡茶主要的不同点 原料不同，一个是咖啡，一个是茶，统称为饮料 泡的方式不同，一个是冲泡，一个是浸泡，统称为泡 加入的调料不同，一个是牛奶和糖，另一个是柠檬。 1234567891011121314151617// 抽象父类提取var Beverage = function()&#123;&#125;Beverage.prototype.boilWater = function() &#123; console.log('把水煮沸');&#125;// 抽象方法，由子类去具体实现Beverage.prototype.brew = function() &#123;&#125;;// 抽象方法，由子类去具体实现Beverage.prototype.pourInCur = function()&#123;&#125;;// 抽象方法，由子类去具体实现Beverage.prototype.addCondiments = function()&#123;&#125;;Beverage.prototype.init = function() &#123; this.boilWater(); this.brew(); this.pourInCur(); this.addCondiments();&#125; 123456789101112131415161718192021222324252627282930// 创建子类以及实例化子类var Coffee = function() &#123;&#125;;Coffee.prototype = new Beverage();Coffee.prototype.brew = function() &#123; console.log('用沸水冲泡咖啡');&#125;Coffee.prototype.pourInCur = function() &#123; console.log('把咖啡到进杯子里');&#125;Coffee.prototype.addCondiments = function() &#123; console.log('加糖和牛奶');&#125;var Tea = function() &#123;&#125; ;Tea.prototype = new Beverage();Tea.prototype.brew = function() &#123; console.log('用沸水浸泡茶');&#125;Tea.prototype.pourInCur = function() &#123; console.log('把茶到进杯子里');&#125;Tea.prototype.addCondiments = function() &#123; console.log('加柠檬');&#125;// 实例化子类var coffee = new Coffee();// 依次输出：用沸水冲泡咖啡 把咖啡到进杯子里 加糖和牛奶coffee.init();var tea = new Tea();// 依次输出：用沸水浸泡茶 把茶到进杯子里 加柠檬tea.init(); 泡茶经典案例解析在泡咖啡和茶的经典案例中，到底谁才是真正的模板方法呢？答案是Beverage.prototype.init,这是因为该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。 好莱坞原则重写经典案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 重构父类var Beverage = function(params) &#123; var boilWater = function() &#123; console.log('把水煮沸'); &#125; var brew = params.brew || function() &#123; throw new Error('子类必须重写brew方法'); &#125; var pourInCup = params.pourInCup || function() &#123; throw new Error('子类必须重写pourInCup方法'); &#125; var addCondiments = params.addCondiments || function() &#123; throw new Error('子类必须重写addCondiments方法'); &#125; var F = function() &#123;&#125;; F.prototype.init = function() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; return F;&#125;// 创建子类var Coffee = Beverage(&#123; brew: function() &#123; console.log('冲泡咖啡'); &#125;, pourInCup: function() &#123; console.log('把咖啡倒进杯子里'); &#125;, addCondiments: function() &#123; console.log('加牛奶和糖'); &#125;&#125;)var Tea = Beverage(&#123; brew: function() &#123; console.log('用沸水浸泡茶叶'); &#125;, pourInCup: function() &#123; console.log('把茶水倒进杯子'); &#125;, addCondiments: function() &#123; console.log('加柠檬'); &#125;&#125;)// 实例化子类var coffee = new Coffee();// 依次输出： 把水煮沸 冲泡咖啡 把咖啡倒进杯子里 加牛奶和糖coffee.init();var tea = new Tea();// 依次输出： 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬tea.init(); 享元模式::: tip亨元模式是一种用于性能优化的模式，其核心是运用共享技术来有效支持大量细粒度的对象。亨元模式要求将对象的属性划分为内部状态和外部状态。::: 亨元模式雏形背景：某内衣厂生产有50种男士内衣和50种女士内衣，正常情况下，需要50个男模特和50个女模特来完成对内衣的试穿拍照，在不使用亨元模式的情况下，在程序里也许会这样写12345678910111213141516// 亨元模式雏形var Model = function(sex,underwear) &#123; this.sex = sex; this.underwear = underwear;&#125;Model.prototype.takePhoto = function() &#123; console.log('sex='+this.sex+',underwear='+this.underwear);&#125;for (let index = 0; index &lt; 50; index++) &#123; var model = new Model('male','underwear'+index); model.takePhoto();&#125;for (let index = 0; index &lt; 50; index++) &#123; var model = new Model('female','underwear'+index); model.takePhoto();&#125; 思考： 在上列中，要得到一张照片，每次需要传入sex和underwear参数，一共有50种男士内衣和50种女士内衣，一共需要100个对象，将来如果生产1000种内衣，则需要的对象会更多。 利用亨元模式后，虽然有100种内衣，但只需要男、女两个模特即可，即只需要两个对象 亨元模式初运用1234567891011121314151617var Model = function (sex) &#123; this.sex = sex;&#125;Model.prototype.takePhoto = function () &#123; console.log('sex=' + this.sex + ',underwear=' + this.underwear);&#125;var male = new Model('male');var female = new Model('female');for (let index = 0; index &lt; 50; index++) &#123; male.underwear = index+1; male.takePhoto();&#125;for (let index = 0; index &lt; 50; index++) &#123; female.underwear = index+1; female.takePhoto();&#125; 亨元模式初运用思考： 我们通过new来创建男女两个model对象，在其他情况下，也许并不是一开始就需要共享所有的对象。 给model手动添加了underwear属性，在更加复杂的系统中，这并不是一个最好的方法，因为外部状态可能是相对比较复杂的，他们与共享对象的联系会变得更加困难。 真实案例：文件上传背景：在微云文件上传模块的开发中，曾爆发过对象爆炸的问题。微云文件上传分为浏览器插件上传，flash上传和表单上传等。用户对于不用的上传模式，都能一个一个上传，或者批量上传。在最初版时，同时上传2000个文件，在IE浏览器中直接进入假死状态。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 真实案例：文件上传// 文件上传对象var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;Upload.prototype.init = function (id) &#123; var _self = this; this.id = id; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称：' + this.fileName + ',文件大小：' + this.fileSize + 'kb&lt;/span&gt;' + '&lt;button type=\"button\" class=\"delFile\"&gt;删除&lt;/button&gt;'; this.dom.querySelector('.delFile').onclick = function () &#123; _self.deleteFile(); &#125; document.body.appendChild(this.dom);&#125;Upload.prototype.deleteFile = function () &#123; if (this.fileSize &lt; 3000) &#123; console.log('成功删除' + this.fileName + '文件'); return this.dom.parentNode.removeChild(this.dom); &#125; if (confirm('是否确定删除此文件?')) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;// 上传方法var id = 0;window.startUpload = function (uploadType, fileList) &#123; for (let index = 0; index &lt; fileList.length; index++) &#123; var file = fileList[index]; var upload = new Upload(uploadType, file.name, file.size); upload.init(id++); &#125;&#125;// 用户上传startUpload('plugin', [ &#123; name: '1.txt', size: 1000 &#125;, &#123; name: '2.txt', size: 3000 &#125;, &#123; name: '3.txt', size: 5000 &#125;])startUpload('flash', [ &#123; name: '4.txt', size: 1000 &#125;, &#123; name: '5.txt', size: 3000 &#125;, &#123; name: '6.txt', size: 5000 &#125;]) 真实案例：文件上传结果 真实案例：亨元模式重构文件上传::: tip 如何划分内部状态和外部状态 内部状态存储于对象内部 内部状态可以被一些对象共享 内部状态独立于具体的场景，通常不会改变 外部状态取决于具体的场景，并根据场景的变化而变化，外部状态通常是不能被共享的。:::::: tip 文件上传内部状态划分内部状态：uploadType外部状态：fileName,fileSize(文件名和文件大小不能被共享，它随不同的文件不同而不同):::123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 真实案例：亨元模式重构文件上传// 文件上传对象var Upload = function (uploadType) &#123; this.uploadType = uploadType;&#125;// 工厂模式：解决一开始就共享所有对象的问题var UploadFactory = (function()&#123; var createFactoryList = &#123;&#125;; return &#123; create: function(uploadType) &#123; if(createFactoryList[uploadType]) &#123; return createFactoryList[uploadType] &#125; return createFactoryList[uploadType] = new Upload(uploadType); &#125; &#125;&#125;)();// 管理器：封装外部状态，使程序在运行时给upload对象设置外部状态var uploadManage = (function()&#123; var uploadDataBase = &#123;&#125;; return &#123; add: function(id,type,name,size) &#123; var uploadObj = UploadFactory.create(type); var dom = document.createElement('div'); dom.innerHTML = '&lt;span&gt;文件名称：' + name + ',文件大小：' + size + 'kb&lt;/span&gt;' + '&lt;button type=\"button\" class=\"delFile\"&gt;删除&lt;/button&gt;'; dom.querySelector('.delFile').onclick = function () &#123; uploadObj.deleteFile(id); &#125; document.body.appendChild(dom); uploadDataBase[id] = &#123; fileName: name, fileSize: size, dom: dom &#125; return uploadObj; &#125;, setExternalState: function(id,uploadObj) &#123; var uploadData = uploadDataBase[id]; for (var i in uploadData) &#123; uploadObj[i] = uploadData[i]; &#125; &#125; &#125;&#125;)();Upload.prototype.deleteFile = function () &#123; uploadManage.setExternalState(id,this); if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (confirm('是否确定删除此文件?')) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;// 上传方法var id = 0;window.startUpload = function (uploadType, fileList) &#123; for (let index = 0; index &lt; fileList.length; index++) &#123; var file = fileList[index]; var upload = uploadManage.add(++id,uploadType,file.name,file.size); &#125;&#125;// 用户上传startUpload('plugin', [ &#123; name: '1.txt', size: 1000 &#125;, &#123; name: '2.txt', size: 3000 &#125;, &#123; name: '3.txt', size: 5000 &#125;])startUpload('flash', [ &#123; name: '4.txt', size: 1000 &#125;, &#123; name: '5.txt', size: 3000 &#125;, &#123; name: '6.txt', size: 5000 &#125;]) 真实案例：亨元模式重构文件上传 职责链模式::: tip 定义职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链传递该请求，直到有一个对象处理它为止。:::优点： 解耦发送者和N个接受者之间的关系 可以手动设置起始节点，并不是必须从第一个开始 可以与其他设计模式在一起实现更加复杂的功能，例如职责链模式+命令模式 缺点： 请求不能保证一定能在接受者中被处理 请求链过长的情况下，可能某些节点并没有起到实质性的作用，造成性能损耗。 现实中的职责链模式 高峰坐公交时，从后门上车的乘客需要把卡一个一个传递，最后一个人打卡或者投币。 考试写小纸条，往后一个一个传递，直到有一个人把正确答案给你为止。 实际开发中的职责链模式: if-else版背景：某公司电商网站，准备做一个活动，用户分别交纳500元定金，可得100元优惠券；交纳200元定金，可得50元优惠券；不交纳定金，正常购买，不享受优惠券，切在库存不充足时，不一定保证能买到商品。字段描述: orderType: 1代表500元定金用户；2代表200元定金用户；3代表普通用户 pay：是否已支付定金 stock：库存，支付了定金的用户不受库存限制 1234567891011121314151617181920212223242526272829303132333435363738// if else版var order = function(orderType,pay,stock) &#123; if(orderType==1) &#123; if(pay) &#123; console.log('500元定金预购，享受100元优惠券'); &#125; else &#123; // 未支付定金，降级到普通订单 if(stock&gt;0) &#123; console.log('普通订单，无优惠券'); &#125; else &#123; console.log('库存不足'); &#125; &#125; &#125; else if(orderType==2) &#123; if(pay) &#123; console.log('200元定金预购，享受50元优惠券'); &#125; else &#123; // 未支付定金，降级到普通订单 if(stock&gt;0) &#123; console.log('普通订单，无优惠券'); &#125; else &#123; console.log('库存不足'); &#125; &#125; &#125; else if(orderType==3) &#123; if(stock&gt;0) &#123; console.log('普通订单，无优惠券'); &#125; else &#123; console.log('库存不足'); &#125; &#125;&#125;// 订单测试order(1, true, 500); // 输出：500元定金预购，享受100元优惠券order(1, false,500); // 输出：普通订单，无优惠券order(2, true, 500); // 输出：200元定金预购，享受50元优惠券order(3, true, 500); // 输出：普通订单，无优惠券 实际开发中的职责链模式: 职责链重构版12345678910111213141516171819202122232425262728// 职责链重构版var order500 = function(orderType,pay,stock) &#123; if(orderType==1 &amp;&amp; pay) &#123; console.log('500元定金预购，享受100元优惠券'); &#125; else &#123; order200(orderType,pay,stock); &#125;&#125;var order200 = function(orderType,pay,stock) &#123; if(orderType==2 &amp;&amp; pay) &#123; console.log('200元定金预购，享受50元优惠券'); &#125; else &#123; orderNormal(orderType,pay,stock); &#125;&#125;var orderNormal = function(orderType,pay,stock) &#123; if(stock&gt;0) &#123; console.log('普通订单，无优惠券'); &#125; else &#123; console.log('库存不足'); &#125;&#125;// 订单测试order500(1, true, 500); // 输出：500元定金预购，享受100元优惠券order500(1, false,500); // 输出：普通订单，无优惠券order500(2, true, 500); // 输出：200元定金预购，享受50元优惠券order500(3, true, 500); // 输出：普通订单，无优惠券 存在的问题: 传递请求的代码被严格耦合在了一起，违反开放-封闭原则 当要新增300元订单时，必须把原来的职责链拆解，移动后才能运行起来 实际开发中的职责链模式: 职责链重构完善版::: tip 约定我们约定，在某个节点处理不了请求时，返回一个字段，把请求往后传递:::1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 职责链重构完善版var order500 = function(orderType,pay,stock) &#123; if(orderType==1 &amp;&amp; pay) &#123; console.log('500元定金预购，享受100元优惠券'); &#125; else &#123; return 'next'; &#125;&#125;var order200 = function(orderType,pay,stock) &#123; if(orderType==2 &amp;&amp; pay) &#123; console.log('200元定金预购，享受50元优惠券'); &#125; else &#123; return 'next'; &#125;&#125;var orderNormal = function(orderType,pay,stock) &#123; if(stock&gt;0) &#123; console.log('普通订单，无优惠券'); &#125; else &#123; console.log('库存不足'); &#125;&#125;// 新增职责链类var Chain = function(fn) &#123; this.fn = fn; this.receiver = null;&#125;Chain.prototype.setReceiver = function(receiver) &#123; this.receiver = receiver;&#125;Chain.prototype.passRequest = function() &#123; var returnMsg = this.fn.apply(this,arguments); if(returnMsg=='next') &#123; return this.receiver &amp;&amp; this.receiver.passRequest.apply(this.receiver,arguments); &#125; return returnMsg;&#125;var chainOrder500 = new Chain(order500);var chainOrder200 = new Chain(order200);var chainOrderNormal = new Chain(orderNormal);chainOrder500.setReceiver(chainOrder200);chainOrder200.setReceiver(chainOrderNormal);// 订单测试chainOrder500.passRequest(1, true, 500); // 输出：500元定金预购，享受100元优惠券chainOrder500.passRequest(1, false,500); // 输出：普通订单，无优惠券chainOrder500.passRequest(2, true, 500); // 输出：200元定金预购，享受50元优惠券chainOrder500.passRequest(3, true, 500); // 输出：普通订单，无优惠券 实际开发中的职责链模式: AOP实现123456789101112131415161718192021222324252627282930313233343536373839// AOP实现职责链模式Function.prototype.after = function(fn) &#123; var self = this; return function() &#123; var returnMsg = self.apply(this,arguments); if(returnMsg=='next') &#123; return fn.apply(this,arguments); &#125; return returnMsg; &#125;&#125;var order500 = function(orderType,pay,stock) &#123; if(orderType==1 &amp;&amp; pay) &#123; console.log('500元定金预购，享受100元优惠券'); &#125; else &#123; return 'next'; &#125;&#125;var order200 = function(orderType,pay,stock) &#123; if(orderType==2 &amp;&amp; pay) &#123; console.log('200元定金预购，享受50元优惠券'); &#125; else &#123; return 'next'; &#125;&#125;var orderNormal = function(orderType,pay,stock) &#123; if(stock&gt;0) &#123; console.log('普通订单，无优惠券'); &#125; else &#123; console.log('库存不足'); &#125;&#125;var order = order500.after(order200).after(orderNormal);// 订单测试order(1, true, 500); // 输出：500元定金预购，享受100元优惠券order(1, false,500); // 输出：普通订单，无优惠券order(2, true, 500); // 输出：200元定金预购，享受50元优惠券order(3, true, 500); // 输出：普通订单，无优惠券 中介者模式::: tip中介者模式：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者即可。::: 中介者模式的缺点 中介者模式本身就要新增一个中介者对象 将对象与对象之间交互的复杂性，转移到对象与中介者之间的复杂性，使得中介者对象经常是巨大的 中介者本身就是一个难以维护的对象。 现实中的案例 机场指挥塔机场指挥塔扮演者中介者，而不同的飞机扮演对象，他们通过与指挥塔进行通信，从而得知消息，什么时候可以起飞，什么时候可以降落。 博彩公司在世界杯期间，博彩公司通过扮演中介者，把成千上万的用户投注情况进行汇总，根据比赛的输赢，进行计算相关的赔率。 中介者模式案例：泡泡堂(原始版)::: tip 分为红蓝两队 只有某队全部死亡，才算失败:::1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 中介者模式案例：泡泡堂(原始版)var Player = function(name,teamColor) &#123; this.partners = []; // 队友列表 this.emeies = []; // 敌人列表 this.name = name; // 名字 this.teamColor = teamColor; // 队伍颜色 this.state = 'live'; // 生存状态&#125;Player.prototype.win = function() &#123; console.log(this.name+'胜利了');&#125;Player.prototype.lose = function() &#123; console.log(this.name+'失败了');&#125;Player.prototype.die = function() &#123; var allDie = true; this.state = 'dead'; // 遍历队友是否全部阵亡 for (let index = 0,len = this.partners.length; index &lt; len; index++) &#123; if(this.partners[index].state!='dead') &#123; allDie = false; break; &#125; &#125; // 如果全部阵亡，遍历通知队友失败，通知敌人胜利 if(allDie) &#123; this.lose(); for (let index = 0,len = this.partners.length; index &lt; len; index++) &#123; this.partners[index].lose(); &#125; for (let index = 0,len = this.emeies.length; index &lt; len; index++) &#123; this.emeies[index].win(); &#125; &#125;&#125;// 工厂方法创建玩家var players = [];var playerFactory = function(name,teamColor) &#123; var newPlayer = new Player(name,teamColor); for (let index = 0,len = players.length; index &lt; len; index++) &#123; if(players[index].teamColor==teamColor) &#123; players[index].partners.push(newPlayer); newPlayer.partners.push(players[index]); &#125; else &#123; players[index].emeies.push(newPlayer); newPlayer.emeies.push(players[index]); &#125; &#125; players.push(newPlayer); return newPlayer;&#125;// 红队var player1 = playerFactory('张三','red'), player2 = playerFactory('张四','red'), player3 = playerFactory('张五','red'), player4 = playerFactory('张六','red');// 蓝队var player5 = playerFactory('辰大','blue'), player6 = playerFactory('辰二','blue'), player7 = playerFactory('辰三','blue'), player8 = playerFactory('辰四','blue');// 淘汰玩家// 依次输出：辰四失败了 辰大失败了 辰二失败了 辰三失败了 张三胜利了 张四胜利了// 张五胜利了 张六胜利了player5.die();player6.die();player7.die();player8.die(); 思考： 虽然我们可以随意创建任意对个玩家，但玩家和其他玩家紧紧耦合在了一起 某一个玩家的状态改变，必须通知其他对象，当其它对象很多时，会非常不合适。 不利于扩展，今后如果要添加新的功能，如：玩家掉线，解除队伍，添加到别的队伍会非常不方便。 中介者模式案例：泡泡堂(引入中介者)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// 中介者模式案例：泡泡堂(引入中介者)var playerDirector = (function()&#123; var players = &#123;&#125;; var operations = &#123; addPlayer: function(player) &#123; var teamColor = player.teamColor; if(!players[teamColor]) &#123; players[teamColor] = []; &#125; players[teamColor].push(player) &#125;, removePlayer: function(player) &#123; var teamColor = player.teamColor; var teamPlayers = players[teamColor] || []; for (let index = 0,len=teamPlayers.length; index &lt; len; index++) &#123; if(teamPlayers[index]==player) &#123; teamPlayers.splice(index,1); break; &#125; &#125; &#125;, changeTeam: function(player,newTeamColor) &#123; operations.removePlayer(player); player.teamColor = newTeamColor; operations.addPlayer(player); &#125;, playerDead: function(player) &#123; var teamColor = player.teamColor; var teamPlayers = players[teamColor]; var allDead = true; player.state = 'dead'; for (let index = 0,len=teamPlayers.length; index &lt; len; index++) &#123; if(teamPlayers[index].state!='dead') &#123; allDead = false; break; &#125; &#125; if(allDead) &#123; for (let index = 0,len=teamPlayers.length; index &lt; len; index++) &#123; teamPlayers[index].lose(); &#125; for (var color in players) &#123; if(color!=teamColor) &#123; for (let index = 0,len=players[color].length; index &lt; len; index++) &#123; players[color][index].win(); &#125; &#125; &#125; &#125; &#125; &#125;; var ReceiveMessage = function() &#123; var message = Array.prototype.shift.call(arguments); operations[message].apply(this,arguments); &#125; return &#123; ReceiveMessage: ReceiveMessage &#125;&#125;)()var Player = function(name,teamColor) &#123; this.name = name; this.teamColor = teamColor; this.state = 'live';&#125;Player.prototype.win = function() &#123; console.log(this.name+'胜利了');&#125;Player.prototype.lose = function() &#123; console.log(this.name+'失败了');&#125;Player.prototype.remove = function() &#123; console.log(this.name+'掉线了'); playerDirector.ReceiveMessage('removePlayer',this);&#125;Player.prototype.die = function() &#123; console.log(this.name+'死亡'); playerDirector.ReceiveMessage('playerDead',this);&#125;Player.prototype.changeTeam = function(color) &#123; console.log(this.name+'换队'); playerDirector.ReceiveMessage('changeTeam',this,color);&#125;// 工厂模式创建玩家var playerFactory = function(name,teamColor) &#123; var newPlayer = new Player(name,teamColor); playerDirector.ReceiveMessage('addPlayer',newPlayer); return newPlayer;&#125;// 红队var player1 = playerFactory('张三','red'), player2 = playerFactory('张四','red'), player3 = playerFactory('张五','red'), player4 = playerFactory('张六','red');// 蓝队var player5 = playerFactory('辰大','blue'), player6 = playerFactory('辰二','blue'), player7 = playerFactory('辰三','blue'), player8 = playerFactory('辰四','blue');// 掉线// 依次输出：张三掉线了 张四掉线了player1.remove();player2.remove();// 更换队伍// 依次输出：张五换队 张五死亡player3.changeTeam('blue');// 阵亡// 依次输出：辰大死亡 辰二死亡 辰三死亡 辰四死亡// 辰大失败了 辰二失败了 辰三失败了 辰四失败了 张五失败了// 张六胜利了player3.die();player5.die();player6.die();player7.die();player8.die(); 装饰者模式::: tip 定义装饰者模式可以动态的给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。::: 继承的问题在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但继承的方式并不灵活，还会带来许多问题 超类和子类之间存在强耦合关系，当改变超类时，子类也会随之改变。 超类的内部细节对子类是可见的，继承常常被认为破坏了封装性。 在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸式增长。 模拟面向对象语言的装饰者模式1234567891011121314151617181920212223242526// 飞机大战案例: 面向对象版var Plane = function() &#123;&#125;;var Missile = function(plane) &#123; this.plane = plane;&#125;;var Atom = function(plane) &#123; this.plane = plane;&#125;Plane.prototype.fire = function() &#123; console.log('发射普通子弹');&#125;;Missile.prototype.fire = function() &#123; this.plane.fire(); console.log('发射导弹');&#125;Atom.prototype.fire = function() &#123; this.plane.fire(); console.log('发射原子弹');&#125;// 调用var plane = new Plane();plane = new Missile(plane);plane = new Atom(plane);plane.fire(); // 依次输出：发射普通子弹 发射导弹 发射原子弹 JavaScript中的装饰者12345678910111213141516171819202122232425// JavaScript版var plane = &#123; fire: function() &#123; console.log('发射普通子弹'); &#125;&#125;var missile = function() &#123; console.log('发射导弹');&#125;var atom = function() &#123; console.log('发射原子弹');&#125;var fire1 = plane.fire;plane.fire = function() &#123; fire1(); missile();&#125;var fire2 = plane.fire;plane.fire = function() &#123; fire2(); atom();&#125;plane.fire();// 依次输出：发射普通子弹 发射导弹 发射原子弹 解析：这种给对象添加职责的方式，并没有真正的改动对象自身，而是将对象放入另外一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。 AOP用AOP装饰函数的技巧在实际开发中非常有用，无论是业务代码的编写，还是在框架层面，我们都可以把行为依照职责分成粒度更细的函数，随后通过装饰把他们合并在一起，这有助于我们编写一个松耦合和高复用性的系统。 AOP的两个装饰函数123456789101112131415161718// before函数Function.prototype.before = function(beforeFn) &#123; var _self = this; return function() &#123; beforeFn.apply(this,arguments); return _self.apply(this,arguments); &#125;&#125;// after函数Function.prototype.after = function(afterFn) &#123; var _self = this; return function() &#123; var ret = _self.apply(this,arguments); afterFn.apply(this,arguments); return ret; &#125;&#125; AOP应用实例一：数据上报分离业务代码和数据统计代码，无论在什么语言中，都是AOP的经典应用之一。1&lt;button id=\"btnLogin\"&gt;点击打开登录浮层&lt;/button&gt; 1234567891011121314151617181920212223242526// 数据上报Function.prototype.before = function (beforeFn) &#123; var _self = this; return function () &#123; beforeFn.apply(this, arguments); return _self.apply(this, arguments); &#125;&#125;Function.prototype.after = function (afterFn) &#123; var _self = this; return function () &#123; var ret = _self.apply(this, arguments); afterFn.apply(this, arguments); return ret; &#125;&#125;var showLogin = function() &#123; console.log('打开登录浮层');&#125;// 依次输出：按钮点击之前上报 打开登录浮层 按钮点击之后上报document.getElementById('btnLogin').onclick = showLogin.before(function()&#123; console.log('按钮点击之前上报');&#125;).after(function() &#123; console.log('按钮点击之后上报');&#125;); AOP应用实例一：插件式表单123用户名：&lt;input type=\"text\" id=\"username\"&gt;密码：&lt;input type=\"password\" id=\"password\"&gt;&lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738// 插件式表单Function.prototype.before = function (beforeFn) &#123; var _self = this; return function () &#123; if(beforeFn.apply(this,arguments)===false) &#123; // 未验证通过，不再执行原函数 return ; &#125; return _self.apply(this, arguments); &#125;&#125;var username = document.getElementById('username');var password = document.getElementById('password');var loginBtn = document.getElementById('loginBtn');// 验证函数var validate = function() &#123; if(username.value === '') &#123; console.log('用户名不能为空'); return false; &#125; if(password.value === '') &#123; console.log('密码不能为空'); return false; &#125;&#125;// 登录ajaxvar formSubmit = function() &#123; var params = &#123; username: username, password: password &#125; console.log('登录ajax...');&#125;// 登录按钮点击formSubmit = formSubmit.before(validate);loginBtn.onclick = function() &#123; formSubmit();&#125;; 状态模式::: tip状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。::: 初识状态模式我们想象这样一个场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，我们按一下开关，电灯会切换到关闭状态;再按一次开关，电灯又将被打开。同一个开关按钮，在不同的状态下，表现出来的行为是不一样的。12345678910111213141516171819202122232425262728// 电灯类var Light = function() &#123; this.state = 'off'; this.button = null;&#125;// 初始化方法Light.prototype.init = function() &#123; var button = document.createElement('button'); var _self = this; button.innerHTML = '开关'; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; _self.buttonPresssed(); &#125;&#125;// 开关点击Light.prototype.buttonPresssed = function() &#123; if (this.state == 'off') &#123; this.state = 'on'; console.log('开灯'); &#125; else if(this.state == 'on') &#123; this.state = 'off'; console.log('关灯'); &#125;&#125;var light = new Light();light.init(); 分析：现在看来，我们已经编写了一个强壮的状态机，这个状态机的逻辑既简单又缜密，看起来这段代码设计得无懈可击。但令人遗憾的是，这个世界上的电灯并非只有一种。许多酒店里有另外一种电灯，这种电灯也只有一种开关，但它的表现是：当第一次按下时，出现弱光;第二次按下时，出现强光；第三次按下时才是关闭电灯。12345678910111213// 改写开关点击事件Light.prototype.buttonPresssed = function() &#123; if (this.state == 'off') &#123; this.state = 'weakLight'; console.log('弱光'); &#125; else if(this.state == 'weakLight') &#123; this.state = 'strongLight'; console.log('强光'); &#125;else if(this.state == 'strongLight') &#123; this.state = 'off'; console.log('关灯'); &#125;&#125; 再次分析：以上代码存在如下的缺点 开关点击事件中的代码，违反了开放-封闭原则，每次新增或者修改light的状态，都要改动开关点击事件中的代码 所有跟状态有关的行为，都被封装在buttonPresssed方法里，后续如果再扩展一种灯光的话，将十分难以维护。 状态的切换不明显，仅仅表现在对state变量的赋值。 buttonPresssed方法里，对于状态的判断，仅仅是if-else的堆砌，不利于后续的维护和扩展 状态模式改写电灯程序::: tip状态模式的核心是区分对象的状态，将电灯程序中三种状态分别设计成单独的一个类，与此种状态有关的行为被封装在这个类的内部。:::12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 关闭var OffLightState = function(light) &#123; this.light = light;&#125;OffLightState.prototype.buttonPressed = function() &#123; console.log('弱光'); this.light.setState(this.light.weakLightState);&#125;// 弱光var WeakLightState = function(light) &#123; this.light = light;&#125;WeakLightState.prototype.buttonPressed = function() &#123; console.log('强光'); this.light.setState(this.light.strongLightState);&#125;// 强光var StrongLightState = function(light) &#123; this.light = light;&#125;StrongLightState.prototype.buttonPressed = function() &#123; console.log('关闭'); this.light.setState(this.light.offLightState);&#125;// 电灯类var Light = function() &#123; this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.button = null;&#125;Light.prototype.init = function() &#123; var button = document.createElement('button'); var _self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开关'; this.currState = this.offLightState; this.button.onclick = function() &#123; _self.currState.buttonPressed(); &#125;&#125;Light.prototype.setState = function(state) &#123; this.currState = state;&#125;// 初始化测试var light = new Light();light.init(); 状态模式的优缺点现在我们已经大概掌握了状态模式，现在是时候来总结一下状态模式的优缺点了。优点： 状态模式定义了状态和行为之间的关系，并将他们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。 避免了Context无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context中原本过多的条件分支 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 Context中的请求动作和状态类中封装的行为可以非常容易的独立变化而不影响。 缺点： 状态模式会根据系统中多少种状态来定义多少个类，这将是一项枯燥和无味的过程 状态模式会将逻辑分散在各个状态类中，虽然可以避免条件分支语句判断，但也造成了逻辑分散，我们无法在一个地方就看出整个状态机的逻辑。适配器模式:::tip适配器模式的作用是解决两个软件实体间的接口不兼容的问题，使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。::: 适配器运用:地图渲染12345678910111213141516171819202122232425262728// 谷歌地图var googleMap = &#123; show: function() &#123; console.log('开始渲染谷歌地图'); &#125;&#125;// 百度地图var baiduMap = &#123; // 地图渲染接口不兼容 display: function() &#123; console.log('开始渲染百度地图'); &#125;&#125;// 百度地图适配器var baiduMapAdapter = &#123; show: function() &#123; return baiduMap.display(); &#125;&#125;// 地图渲染var renderMap = function(map) &#123; if(map.show instanceof Function) &#123; map.show(); &#125;&#125;// 测试地图渲染renderMap(googleMap); // 开始渲染谷歌地图renderMap(baiduMapAdapter); // 开始渲染百度地图 设计原则和编程技巧前辈们总结的这些设计原则通常指单一职责原则、里氏转换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。 单一职责原则::: tip单一职责原则(SRP)体现为：一个对象(方法)只做一件事情，它被广泛运用在代理模式、迭代器模式、单例模式和装饰者模式中。:::单一职责原则被定义为”引起变化的原因”，如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每一个职责的变化都是一个轴线，如果一个人承担了过多的职责，那么在需求变迁的过程中，需要改写这个方法的可能性就越大。 何时应该分离职责SRP原则是所有原则中最简单也是最难正确运用的原则之一，要明确的是，并不是所有的职责都应该一一分离。 一方面，如果随着需求的变化，有两个职责总是同时变化，那就不比分离他们。比如Ajax请求时，创建xhr对象和发送xhr请求几乎总是在一起，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。 另一方面，职责的变化轴线仅当他们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但他们还没有发生改变的征兆，那么也许没有必要主动分离他们，在代码需要重构的时候再进行分离也不迟。 SRP原则的优缺点优点：降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。缺点：最明显的是会增加编写代码的复杂度，当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。 最少知识原则::: tip最少知识原则(LKP)说的是一个软件实体应当尽可能少的于其他实体发生相互作用，它常用在中介者模式和外观模式中。::: 指导思想最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此通信，那么这两个对象就不要发生直接的相互联系，常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发送请求，可以通过第三者对象来转发这些请求。 开放-封闭原则::: tip开放-封闭原则(OCP)是最重要的一条原则，它的定义是：软件实体(类，模块，函数)等应该是可以扩展的，但是不可修改。::: 指导思想当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 设计模式中的开放-封闭原则 发布-订阅模式 模板方法模式 策略模式 代理模式 职责连模式 代码重构::: tip模式和重构之间有着一种与生俱来的关系，从某种角度来看，设计模式的目的就是为许多重构行为提供目标。::: 提炼函数如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另一个独立的函数中，这是一种很常见的优化工作，这样做的好处主要有以下几点： 避免出现超大的函数 独立出来的函数有助于代码复用 独立出来的函数更容易被覆写。 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。 1234567891011121314151617181920// 提炼函数var getUserInfo = function() &#123; ajax('http://xxx.com/userInfo', function(data) &#123; console.log('userId:' + data.userId); console.log('userName:'+ data.userName); console.log('nickName:'+data.nickName); &#125;);&#125;;// 改写成var getUserInfo = function() &#123; ajax('http://xxx.com/userInfo', function(data) &#123; printDetails(data); &#125;);&#125;;var printDetails = function(data) &#123; console.log('userId:' + data.userId); console.log('userName:'+ data.userName); console.log('nickName:'+data.nickName);&#125; 合并重复的条件片段如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散步了一些重复的代码，那么就有必要进行合并去重工作。123456789101112131415161718192021var paging = function(currPage) &#123; if(currPage&lt;0) &#123; currPage = 0; jump(currPage); &#125; else if(currPage &gt;= totalPage) &#123; currPage = totalPage; jump(currPage); &#125; else &#123; jump(currPage); &#125;&#125;// 改写成var paging = function(currPage) &#123; if(currPage&lt;0) &#123; currPage = 0; &#125; else if(currPage &gt;= totalPage) &#123; currPage = totalPage; &#125; jump(currPage);&#125; 把条件分支语句提炼成函数在程序设计中，复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。1234567891011121314151617181920// 根据季节打折var getPrice = function(price) &#123; var date = new Date(); if(data.getMonth() &gt;=6 &amp;&amp; data.getMonth() &lt;= 9) &#123; return price * 0.8; &#125; return price;&#125;// 改写成var isSummer = function() &#123; var date = new Date(); return data.getMonth() &gt;=6 &amp;&amp; data.getMonth() &lt;= 9&#125;var getPrice = function(price) &#123; if(isSummer()) &#123; return price * 0.8; &#125; return price;&#125; 合理利用循环在函数体内，如果有些代码实际上负责的是一些重复性的工作，那么合理利用循环不仅可以完成同样的功能，还可以是代码量更少。12345678910111213141516171819202122232425var createXHR = function() &#123; var xhr; try&#123; xhr = new ActiveXObject('MSXML2.XMLHttp.6.0'); &#125;catch(e) &#123; try&#123; xhr = new ActiveXObject('MSXML2.XMLHttp.3.0'); &#125;catch(e) &#123; xhr = new ActiveXObject('MSXML2.XMLHttp'); &#125; &#125; return xhr;&#125;// 改写成var createXHR = function() &#123; var versions = ['MSXML2.XMLHttp.6.0','MSXML2.XMLHttp.3.0','MSXML2.XMLHttp']; for(var i = 0,version;version = version[i++];) &#123; try&#123; return new ActiveXObject(version); &#125;catch(e) &#123; &#125; &#125;&#125; 提前让函数退出代替嵌套条件分支1234567891011121314151617181920212223var del = function(obj) &#123; var ret; if(!obj.isReadOnly) &#123; if(obj.isFolder) &#123; ret = deleteFolder(obj); &#125; else if(obj.isFile) &#123; ret = deleteFile(obj); &#125; &#125;&#125;// 改写成var del = function(obj) &#123; if(obj.isReadOnly) &#123; return; &#125; if(obj.isFolder) &#123; return deleteFolder(obj); &#125; if(obj.isFile) &#123; return deleteFile(obj); &#125;&#125; 传递对象参数代替过长的参数列表有时候一个函数有可能接受多个参数，而参数的数量越多，函数就越难理解和使用。123456789101112131415161718192021222324252627var setUserInfo = function(id,name,address,sex,mobile,qq) &#123; console.log('id='+id); console.log('name='+name); console.log('address='+address); console.log('sex='+sex); console.log('mobile='+mobile); console.log('qq='+qq);&#125;setUserInfo(1314,'sven','shenzhen','male','13886867272','33223311');// 改写成var setUserInfo = function(userInfo) &#123; console.log('id='+userInfo.id); console.log('name='+userInfo.name); console.log('address='+userInfo.address); console.log('sex='+userInfo.sex); console.log('mobile='+userInfo.mobile); console.log('qq='+userInfo.qq);&#125;setUserInfo(&#123; id:1314, name:'sven', address:'shenzhen', sex:'male', mobile:'13886867272', qq:'33223311'&#125;); 合理使用链式调用12345678910111213var User = &#123; id: null, name: null, setId: function(id) &#123; this.id = id; return this; &#125;, setName: function(name) &#123; this.name = name; return this; &#125;&#125;console.log(User.setId(1314).setName('sven')); 代码分析：链式调用的方式并不会造成太多阅读上的困难，也确实能省下一些字符和中间变量，但节省下来的字符数量同样是微不足道的。链式调用带来的坏处就是在调试的时候非常不方便，如果有一条链有错误出现，必须得先把这条链拆开才能加上一些调试log或者断点，这样才能定位错误出现的地方。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"工具库licia（二）","slug":"js工具库licia（二）","date":"2022-02-17T01:34:21.000Z","updated":"2024-02-20T07:11:25.728Z","comments":true,"path":"2022/02/17/js工具库licia（二）/","link":"","permalink":"/2022/02/17/js工具库licia（二）/","excerpt":"licia使用文档(1.34.0)","text":"licia使用文档(1.34.0) $类似 jQuery 的 dom 操作库。 类型定义namespace $ { class $ extends Select { find(selector: string): $; each(fn: types.AnyFn): $; offset(): $offset.IOffset; hide(): $; show(): $; first(): $; last(): $; get(index: number): Element; eq(index: number): $; on(event: string, selector: string, handler: types.AnyFn): $; on(event: string, handler: types.AnyFn): $; off(event: string, selector: string, handler: types.AnyFn): $; off(event: string, handler: types.AnyFn): $; html(): string; html(value: string): $; text(): string; text(value: string): $; val(): string; val(value: string): $; css(name: string): string; css(name: string, value: string): $; css(properties: types.PlainObj&lt;string | number&gt;): $; attr(name: string): string; attr(name: string, value: string): $; attr(attributes: types.PlainObj&lt;string&gt;): $; data(name: string): string; data(name: string, value: string): $; data(attributes: types.PlainObj&lt;string&gt;): $; rmAttr(name: string): $; remove(): $; addClass(name: string | string[]): $; rmClass(name: string): $; toggleClass(name: string): $; hasClass(name: string): boolean; parent(): $; append(content: string | Element): $; prepend(content: string | Element): $; before(content: string | Element): $; after(content: string | Element): $; }}declare function $(selector: string | Element | Document): $.$; 支持方法列表offset, hide, show, first, last, get, eq, on, off, html, text, val, css, attr,data, rmAttr, remove, addClass, rmClass, toggleClass, hasClass, append, prepend,before, after 1234567const $btn = $('#btn');$btn.html('eustia');$btn.addClass('btn');$btn.show();$btn.on('click', function() &#123; // Do something...&#125;); $attr操作元素属性。 类型定义namespace $attr { function remove(element: $safeEls.El, name: string): void;}function $attr( element: $safeEls.El, name: string, value: string): void;function $attr( element: $safeEls.El, attributes: types.PlainObj&lt;string&gt;): void;function $attr(element: $safeEls.El, name: string): string; 获取元素集中第一个元素的指定属性值。 参数名 说明 element 目标元素集 name 属性名 返回值 第一个元素的属性值 设置元素集中一个或多个属性的值。 参数名 说明 element 目标元素集 name 属性名 val 属性值 参数名 说明 element 目标元素集 attributes 包含多个要设置属性-值对的对象 remove对元素集中的所有元素，移除指定的属性。 参数名 说明 element 目标元素集 name 属性名 1234567$attr('#test', 'attr1', 'test');$attr('#test', 'attr1'); // -&gt; test$attr.remove('#test', 'attr1');$attr('#test', &#123; attr1: 'test', attr2: 'test'&#125;); $class操作元素 class。 类型定义const $class: { add(element: $safeEls.El, name: string | string[]): void; has(element: $safeEls.El, name: string): boolean; toggle(element: $safeEls.El, name: string): void; remove(element: $safeEls.El, name: string): void;}; add对元素集中的所有元素，添加指定的 class。 参数名 说明 element 目标元素集 names 添加的 class has判断元素集中是否有元素含有指定的 class。 参数名 说明 element 目标元素集 name class 值 返回值 如果有，返回真 toggle对于元素集中的每个元素，如果含有指定的 class 就将其删除，反之则添加。 参数名 说明 element 目标元素集 name class 值 remove对于元素集中的所有元素，移除指定的 class。 参数名 说明 element 目标元素集 name class 值 1234567$class.add('#test', 'class1');$class.add('#test', ['class1', 'class2']);$class.has('#test', 'class1'); // -&gt; true$class.remove('#test', 'class1');$class.has('#test', 'class1'); // -&gt; false$class.toggle('#test', 'class1');$class.has('#test', 'class1'); // -&gt; true $css操作元素样式。 类型定义function $css(element: $safeEls.El, name: string): string;function $css( element: $safeEls.El, name: string, val: string): void;function $css( element: $safeEls.El, properties: types.PlainObj&lt;string | number&gt;): void; 获取元素集中第一个元素的指定样式。 参数名 说明 element 目标元素集 name 样式名 返回值 样式值 设置元素集中一个或多个样式的值。 参数名 说明 element 目标元素集 name 样式名 val 样式值 参数名 说明 element 目标元素集 properties 包含多个要设置样式-值对的对象 1234567$css('#test', &#123; color: '#fff', background: 'black', opacity: 0.5&#125;);$css('#test', 'display', 'block');$css('#test', 'color'); // -&gt; #fff $data同 $attr，自动给属性名加 data- 前缀。 类型定义function $data( element: $safeEls.El, name: string, value: string): void;function $data( element: $safeEls.El, attributes: types.PlainObj&lt;string&gt;): void;function $data(element: $safeEls.El, name: string): string; 1$data('#test', 'attr1', 'eustia'); $event给指定 dom 元素绑定事件。 类型定义const $event: { on( element: $safeEls.El, event: string, selector: string, handler: types.AnyFn ): void; on(element: $safeEls.El, event: string, handler: types.AnyFn): void; off( element: $safeEls.El, event: string, selector: string, handler: types.AnyFn ): void; off(element: $safeEls.El, event: string, handler: types.AnyFn): void;}; 12345function clickHandler() &#123; // Do something...&#125;$event.on('#test', 'click', clickHandler);$event.off('#test', 'click', clickHandler); $insert插入 html 到不同位置。 类型定义namespace $insert { type IInsert = (element: $safeEls.El, content: string | Element) =&gt; void;}const $insert: { before: $insert.IInsert; after: $insert.IInsert; append: $insert.IInsert; prepend: $insert.IInsert;}; before插入 html 到元素前。 after插入 html 到元素后。 prepend插入 html 到元素内部前。 append插入 html 到元素内部后。 参数名 说明 element 目标元素集 content html 字符串或元素 123456789// &lt;div id=\"test\"&gt;&lt;div class=\"mark\"&gt;&lt;/div&gt;&lt;/div&gt;$insert.before('#test', '&lt;div&gt;licia&lt;/div&gt;');// -&gt; &lt;div&gt;licia&lt;/div&gt;&lt;div id=\"test\"&gt;&lt;div class=\"mark\"&gt;&lt;/div&gt;&lt;/div&gt;$insert.after('#test', '&lt;div&gt;licia&lt;/div&gt;');// -&gt; &lt;div id=\"test\"&gt;&lt;div class=\"mark\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;licia&lt;/div&gt;$insert.prepend('#test', '&lt;div&gt;licia&lt;/div&gt;');// -&gt; &lt;div id=\"test\"&gt;&lt;div&gt;licia&lt;/div&gt;&lt;div class=\"mark\"&gt;&lt;/div&gt;&lt;/div&gt;$insert.append('#test', '&lt;div&gt;licia&lt;/div&gt;');// -&gt; &lt;div id=\"test\"&gt;&lt;div class=\"mark\"&gt;&lt;/div&gt;&lt;div&gt;licia&lt;/div&gt;&lt;/div&gt; $offset获取元素在文档中的位置。 类型定义namespace $offset { interface IOffset { left: number; top: number; width: number; height: number; }}function $offset(element: $safeEls.El): $offset.IOffset; 参数名 说明 element 目标元素集 返回值 元素位置 1$offset('#test'); // -&gt; &#123;left: 0, top: 0, width: 0, height: 0&#125; $property设置或获取元素的 html， text，val 等值。 类型定义namespace $property { interface IProperty { (element: $safeEls.El, value: string): void; (element: $safeEls.El): string; }}const $property: { html: $property.IProperty; val: $property.IProperty; text: $property.IProperty;}; html设置或获取元素的 html 值。 text设置或获取元素的 text 值。 val设置或获取元素的 val 值。 12$property.html('#test', 'licia');$property.html('#test'); // -&gt; licia $remove移除指定元素集。 类型定义function $remove(element: $safeEls.El); 参数名 说明 element 目标元素集 1$remove('#test'); $safeEls将值转换为数组，如果值为字符串，使用 querySelector 获取元素集。 类型定义namespace $safeEls { type El = Element | Element[] | NodeListOf&lt;Element&gt; | string;}function $safeEls(val: $safeEls.El): Element[]; 参数名 说明 val 要转换的值 返回值 元素集 123$safeEls(document.querySelector('.test'));$safeEls(document.querySelectorAll('.test'));$safeEls('.test'); // -&gt; Array of elements with test class $show显示元素。 类型定义function $show(element: $safeEls.El): void; 参数名 说明 element 目标元素集 1$show('#test'); BenchmarkJavaScript 基准测试。 类型定义namespace Benchmark { interface IOptions { minTime?: number; maxTime?: number; minSamples?: number; delay?: number; name?: string; } interface IResult { name: string; mean: number; variance: number; deviation: number; sem: number; moe: number; rme: number; hz: number; sample: number[]; }}class Benchmark { constructor(fn: types.AnyFn, options?: Benchmark.IOptions); run(): Promise&lt;Benchmark.IResult&gt;; static all( benches: Array&lt;types.AnyFn | Benchmark&gt;, options?: Benchmark.IOptions ): Promise&lt;Benchmark.IResult[]&gt;;} constructor 参数名 说明 fn 要测试的代码 options 测试选项 可用选项： 参数名 说明 minTime=50 用于减少误差的时间 maxTime=5000 测试运行最大时间 minSamples=5 最小样本数量 delay=5 测试周期间隔 name 测试名称 run运行基准测试，返回 promise。 all[static] 运行多个基准测试。 123456789101112131415161718192021222324const benchmark = new Benchmark( function test() &#123; !!'Hello World!'.match(/o/); &#125;, &#123; maxTime: 1500 &#125;);benchmark.run().then(result =&gt; &#123; console.log(String(result));&#125;);Benchmark.all([ function regExp() &#123; /o/.test('Hello World!'); &#125;, function indexOf() &#123; 'Hello World!'.indexOf('o') &gt; -1; &#125;, function match() &#123; !!'Hello World!'.match(/o/); &#125;]).then(results =&gt; &#123; console.log(String(results));&#125;); Blob如果支持 Blob，直接返回 Blob，否则使用 BlobBuilder 进行兼容。 constructor 参数名 说明 parts Blob 分片 options 选项 1const blob = new Blob([]); BloomFilter布隆过滤器实现。 类型定义class BloomFilter { constructor(size?: number, k?: number); add(val: string): void; test(val: string): boolean;} constructor 参数名 说明 size=1024 桶数目 k=3 哈希函数数目 add添加元素。 参数名 说明 val 要加的值 test检测元素是否在过滤器中。 参数名 说明 val 要检查的值 返回值 如果可能在返回真，如果绝对不在返回假 123456const bloom = new BloomFilter(256, 3);bloom.add('Bruce Wayne');bloom.add('Clark Kent');bloom.test('Clark Kent'); // -&gt; truebloom.test('Bruce Wayne'); // -&gt; truebloom.test('Tony Stark'); // -&gt; false Caseless修复对象的属性值时，无需关心键值的大小写情况。 类型定义class Caseless { constructor(obj: any); getKey(key: string): string | void; set(key: string, val: any): void; get(key: string): any; remove(key: string): void; has(key: string): boolean;} constructor 参数名 说明 obj 目标对象 getKey获取原始键值。 参数名 说明 key 不区分大小写的键名 返回值 原始键值 set设置值。 参数名 说明 key 不区分大小写的键名 val 要设置的值 get获取值。 参数名 说明 key 不区分大小写的键名 返回值 键值 remove移除值。 参数名 说明 key 不区分大小写的键名 has判断是否存在给定的键名。 参数名 说明 key 不区分大小写的键名 返回值 如果有，返回真 1234567const headers = &#123; 'Content-Type': 'text/javascript' &#125;;const c = new Caseless(headers);c.set('content-type', 'text/css');console.log(headers); // -&gt; &#123; 'Content-Type': 'text/css' &#125;c.getKey('content-type'); // -&gt; 'Content-Type'c.remove('content-type');c.has('content-type'); // -&gt; false Class创建 JavaScript 类。 类型定义namespace Class { class Base { toString(): string; } class IConstructor extends Base { constructor(…args: any[]); static extend(methods: any, statics: any): IConstructor; static inherits(Class: types.AnyFn): void; static methods(methods: any): IConstructor; static statics(statics: any): IConstructor; [method: string]: any; }}function Class(methods: any, statics?: any): Class.IConstructor; 参数名 说明 methods 公有方法 statics 静态方法 返回值 用于创建实例的函数 123456789101112131415161718192021222324252627282930313233343536const People = Class(&#123; initialize: function People(name, age) &#123; this.name = name; this.age = age; &#125;, introduce: function() &#123; return 'I am ' + this.name + ', ' + this.age + ' years old.'; &#125;&#125;);const Student = People.extend( &#123; initialize: function Student(name, age, school) &#123; this.callSuper(People, 'initialize', arguments); this.school = school; &#125;, introduce: function() &#123; return ( this.callSuper(People, 'introduce') + '\\n I study at ' + this.school + '.' ); &#125; &#125;, &#123; is: function(obj) &#123; return obj instanceof Student; &#125; &#125;);const a = new Student('allen', 17, 'Hogwarts');a.introduce(); // -&gt; 'I am allen, 17 years old. \\n I study at Hogwarts.'Student.is(a); // -&gt; true Color颜色转换。 类型定义namespace Color { interface IColor { val: number[]; model: string; }}class Color { constructor(color: string | Color.IColor); toRgb(): string; toHex(): string; toHsl(): string; static parse(colorStr: string): Color.IColor;} constructor 参数名 说明 color 要转换的颜色 toRgb获取颜色 rgb 格式。 toHex获取颜色十六进制格式。 toHsl获取颜色 hsl 格式。 parse【静态】将颜色字符串转换为含有值及颜色模型的对象。 参数名 说明 color 颜色字符串 返回值 含有值及颜色模型的对象 1234Color.parse('rgb(170, 287, 204, 0.5)'); // -&gt; &#123;val: [170, 187, 204, 0.5], model: 'rgb'&#125;const color = new Color('#abc');color.toRgb(); // -&gt; 'rgb(170, 187, 204)'color.toHsl(); // -&gt; 'hsl(210, 25%, 73%)' Delegator对象委托。 类型定义class Delegator { constructor(host: object, target: object | string); method(name: string, target?: string): Delegator; getter(name: string, target?: string): Delegator; setter(name: string, target?: string): Delegator; access(name: string, target?: string): Delegator;} constructor 参数名 说明 host 宿主对象 target 委托目标 method允许在宿主对象上访问目标方法。 参数名 说明 name 宿主方法名 target=name 目标方法名 getter创建 getter。 setter创建 setter。 access创建 accessor，效果等于同时调用 setter 和 getter。 1234567891011121314151617181920212223242526const host = &#123; target: &#123; a() &#123; return 'a'; &#125;, b: 'b', c: 'c', d: 'd', e() &#123; return 'e'; &#125; &#125;&#125;;const delegator = new Delegator(host, 'target');delegator .method('a') .getter('b') .setter('c') .access('d');host.a(); // -&gt; 'a'host.b; // -&gt; 'b'host.c = 5;host.target.c; // -&gt; 5host.d; // -&gt; 'd'host.d = 5;host.d; // -&gt; 5 DispatcherFlux 调度器。 类型定义class Dispatcher { dispatch(payload: any); register(cb: types.AnyFn): void; waitFor(ids: string[]): void; unregister(id: string): void; isDispatching(): boolean;} 相关文档 12345678910111213const dispatcher = new Dispatcher();dispatcher.register(function(payload) &#123; switch ( payload.actionType // Do something ) &#123; &#125;&#125;);dispatcher.dispatch(&#123; actionType: 'action'&#125;); Emitter提供观察者模式的 Event emitter 类。 类型定义class Emitter { on(event: string, listener: types.AnyFn): Emitter; off(event: string, listener: types.AnyFn): Emitter; once(event: string, listener: types.AnyFn): Emitter; emit(event: string, …args: any[]): Emitter; removeAllListeners(event?: string): Emitter; static mixin(obj: any): any;} on绑定事件。 off解绑事件。 once绑定只触发一次的事件。 参数名 说明 event 事件名称 listener 事件监听器 emit触发事件。 参数名 说明 event 事件名称 …args 传递给监听器的参数 removeAllListeners解绑所有事件。 参数名 说明 event 事件名称 mixin【静态】 将 Emitter 类的方法绑定到指定对象上去。 参数名 说明 obj 目标对象 123456const event = new Emitter();event.on('test', function(name) &#123; console.log(name);&#125;);event.emit('test', 'licia'); // Logs out 'licia'.Emitter.mixin(&#123;&#125;); EnumEnum 类实现。 类型定义class Enum { size: number; constructor(map: string[] | { [member: string]: any }); [key: string]: any;} constructor 参数名 说明 arr 字符串数组 参数名 说明 obj 键值对 1234567891011const importance = new Enum([ 'NONE', 'TRIVIAL', 'REGULAR', 'IMPORTANT', 'CRITICAL']);const val = 1;if (val === importance.CRITICAL) &#123; // Do something.&#125; FileBlobStore二进制文件存储。 类型定义class FileBlobStore extends Emitter { constructor(path: string, data?: types.PlainObj&lt;Buffer&gt;); set(key: string, buf: Buffer): void; set(values: types.PlainObj&lt;Buffer&gt;): void; get(key: string): Buffer | void; get(keys: string[]): types.PlainObj&lt;Buffer&gt;; remove(key: string): void; remove(keys: string[]): void; clear(): void; each(fn: (val: Buffer, key: string) =&gt; void): void; save(): void;} API 基本与 Store 模块一致，主要不同点是只接收 Buffer 类型。 save保存内容到磁盘。 123const store = new FileBlobStore('path/to/file');store.set('name', Buffer.from('licia'));process.on('exit', () =&gt; store.save()); FileStoreconstructor类型定义class FileStore extends Store { constructor(path: string, data?: any);} 参数名 说明 path 存储文件路径 data 默认数据 12const store = new FileStore('path/to/file');store.set('name', 'licia'); HashTable哈希表实现。 类型定义class HashTable { constructor(size?: number); set(key: string, val: any): void; get(key: string): any; has(key: string): boolean; delete(key: string): void;} constructor 参数名 说明 size=32 桶数目 set设置值。 参数名 说明 key 键名 val 键值 get获取值。 参数名 说明 key 键名 返回值 键值 has检查是否有指定值。 参数名 说明 key 键名 返回值 如果值存在，返回真 delete删除值。 123456const hashTable = new HashTable(128);hashTable.set('name', 'redhoodsu');hashTable.get('name'); // -&gt; 'redhoodsu'hashTable.has('name'); // -&gt; truehashTable.delete('name');hashTable.has('name'); // -&gt; false Heap堆实现。 类型定义class Heap { size: number; constructor(cmp?: types.AnyFn); clear(): void; add(item: any): number; poll(): any; peek(): any;} size堆大小。 constructor 参数名 说明 cmp 比较器 clear清空堆数据。 add往堆里添加元素。 参数名 说明 item 入堆元素 返回值 当前大小 poll获取并删除堆的根元素。 peek与 poll 一样，只是不删除。 123456789const heap = new Heap(function(a, b) &#123; return b - a;&#125;);heap.add(2);heap.add(1);heap.add(4);heap.add(5);heap.poll(); // -&gt; 5console.log(heap.size); // -&gt; 4 HeapSnapshotV8 内存快照操作库。 类型定义class HeapSnapshot { nodes: LinkedList; edges: LinkedList; constructor(profile: any);} constructor 参数名 说明 profile 要解析的内存快照 nodes解析后的节点信息。 edges解析后的边信息。 123456const fs = require('fs');const data = fs.readFileSync('path/to/heapsnapshot', 'utf8');const heapSnapshot = new HeapSnapshot(data);let totalSize = 0;heapSnapshot.nodes.forEach(node =&gt; (totalSize += node.selfSize));console.log(totalSize); I18n简单国际化库。 类型定义class I18n { constructor(locale: string, langs: types.PlainObj&lt;any&gt;); set(locale: string, lang: types.PlainObj&lt;any&gt;): void; t(path: string | string[], data?: types.PlainObj&lt;any&gt;): string; locale(locale: string): void;} constructor 参数名 说明 locale 地区代码 langs 语言数据 set添加语言或者向已有的语言新增键值。 参数名 说明 locale 地区代码 lang 语言数据 locale设置当前地区。 参数名 说明 locale 地区代码 t获取翻译文本。 参数名 说明 path 要获取文本的键值 data 要传递的数据 返回值 翻译文本 12345678910111213141516171819const i18n = new I18n('en', &#123; en: &#123; welcome: 'Hello, &#123;&#123;name&#125;&#125;!', curTime(data) &#123; return 'Current time is ' + data.time; &#125; &#125;, cn: &#123; welcome: '你好，&#123;&#123;name&#125;&#125;！' &#125;&#125;);i18n.set('cn', &#123; curTime(data) &#123; return '当前时间是 ' + data.time; &#125;&#125;);i18n.t('welcome', &#123; name: 'licia' &#125;); // -&gt; 'Hello, licia!'i18n.locale('cn');i18n.t('curTime', &#123; time: '5:47 pm' &#125;); // -&gt; '当前时间是 5:47 pm' JsonTransformerJSON 转换器。 类型定义class JsonTransformer { constructor(data: any); set(key: string, val: any): JsonTransformer; get(key?: string): any; map(from: string, to: string, fn: types.AnyFn): JsonTransformer; map(from: string, fn: types.AnyFn): JsonTransformer; filter(from: string, to: string, fn: types.AnyFn): JsonTransformer; filter(from: string, fn: types.AnyFn): JsonTransformer; remove(keys: string | string[]): JsonTransformer; compute( from: string | string[], to: string, fn: types.AnyFn ): JsonTransformer; compute(from: string, fn: types.AnyFn): JsonTransformer; toString(): string;} constructor 参数名 说明 data={} 目标 JSON 对象 set设置属性值。 参数名 说明 key 属性路径 val 值 如果属性路径为空，整个对象将被值替换。 get获取属性值。 参数名 说明 key 属性路径 返回值 指定值或整个对象 remove移除属性值。 参数名 说明 key 属性路径 map数组 map 的快捷方式。 参数名 说明 from 源对象路径 to 目标对象路径 fn 真值检测函数 filter数组 filter 的快捷方式。 compute从多个属性值计算新值。 参数名 说明 from 源属性路径 to 目标属性路径 fn 计算函数 123456789101112131415161718192021222324const data = new JsonTransformer(&#123; books: [ &#123; title: 'Book 1', price: 5 &#125;, &#123; title: 'Book 2', price: 10 &#125; ], author: &#123; lastname: 'Su', firstname: 'RedHood' &#125;&#125;);data.filter('books', function(book) &#123; return book.price &gt; 5;&#125;);data.compute('author', function(author) &#123; return author.firstname + author.lastname;&#125;);data.set('count', data.get('books').length);data.get(); // -&gt; &#123;books: [&#123;title: 'Book 2', price: 10&#125;], author: 'RedHoodSu', count: 1&#125; LinkedList双向链表实现。 类型定义namespace LinkedList { class Node { value: any; prev: Node | null; next: Node | null; }}class LinkedList { size: number; head: LinkedList.Node; tail: LinkedList.Node; push(val: any): number; pop(): any; unshift(val: any): number; shift(): any; find(fn: types.AnyFn): LinkedList.Node | void; delNode(node: LinkedList.Node): void; forEach(iterator: types.AnyFn, ctx?: any); toArr(): any[];} size链表大小。 head链表首结点。 tail链表尾结点。 push向链表尾部添加值。 参数名 说明 val 要添加的值 返回值 链表大小 pop获取链表尾部值。 unshift向链表头部添加值。 shift获取链表头部值。 rmNode删除节点。 find查找节点。 参数名 说明 fn 真值检测函数 返回值 第一个通过的节点 forEach遍历链表。 toArr将链表转换成 JavaScript 数组。 123const linkedList = new LinkedList();linkedList.push(5);linkedList.pop(); // -&gt; 5 LocalStoreLocalStorage 存储。 类型定义class LocalStore extends Store { constructor(name: string, data?: {});} 继承自 Store 类。 constructor 参数名 说明 name LocalStorage 存储名 data 默认数据 12const store = new LocalStore('licia');store.set('name', 'licia'); Logger带日志级别的简单日志库。 类型定义class Logger extends Emitter { name: string; formatter(type: string, argList: any[]): any[]; constructor(name: string, level?: string | number); setLevel(level: string | number): Logger; getLevel(): number; trace(…args: any[]): Logger; debug(…args: any[]): Logger; info(…args: any[]): Logger; warn(…args: any[]): Logger; error(…args: any[]): Logger; static level: Enum;} constructor 参数名 说明 name 日志名称 level=DEBUG 日志级别 setLevel设置日志级别。 参数名 说明 level 日志级别 getLevel获取当前日志级别。 trace，debug，info，warn，error打日志方法。 日志级别TRACE，DEBUG，INFO，WARN，ERROR 和 SILENT。 1234567891011121314151617const logger = new Logger('licia', Logger.level.ERROR);logger.trace('test');// Format output.logger.formatter = function(type, argList) &#123; argList.push(new Date().getTime()); return argList;&#125;;logger.on('all', function(type, argList) &#123; // It's not affected by log level.&#125;);logger.on('debug', function(argList) &#123; // Affected by log level.&#125;); Lru简单 LRU 缓存。 类型定义class Lru { constructor(max: number); has(key: string): boolean; remove(key: string): void; get(key: string): any; set(key: string, val: any): void; clear(): void;} constructor 参数名 说明 max 最大缓存数 has检查是否有缓存。 参数名 说明 key 缓存键名 返回值 如果有，返回真 remove删除缓存。 参数名 说明 key 缓存键名 get获取缓存。 参数名 说明 key 缓存键名 返回值 缓存值 set设置缓存。 参数名 说明 key 缓存键名 val 缓存值 clear清除所有缓存。 123const cache = new Lru(50);cache.set('test', 'licia');cache.get('test'); // -&gt; 'licia' MediaQueryCSS 媒体查询监听器。 类型定义class MediaQuery extends Emitter { constructor(query: string); isMatch(): boolean;} 继承自 Emitter 类。 constructor 参数名 说明 query 媒体查询字符串 isMatch如果媒体查询匹配，返回真。 事件match当媒体查询匹配时触发。 unmatch与 match 事件相反。 12345const mediaQuery = new MediaQuery('screen and (max-width:1000px)');mediaQuery.isMatch(); // -&gt; falsemediaQuery.on('match', () =&gt; &#123; // Do something...&#125;); MutationObserverMutationObserver 安全版本，如果不支持，则什么也不做。 12345const observer = new MutationObserver(function(mutations) &#123; // Do something.&#125;);observer.observe(document.documentElement);observer.disconnect(); PriorityQueue优先队列实现。 类型定义class PriorityQueue { size: number; constructor(cmp?: types.AnyFn); clear(): void; enqueue(item: any): number; dequeue(): any; peek(): any;} size队列大小。 constructor 参数名 说明 cmp 比较器 clear清空队列。 enqueue元素入列。 参数名 说明 item 入列元素 返回值 当前大小 dequeue获取并删除队列中拥有最高优先级的元素。 peek同 dequeue，只是不删除。 1234567891011121314const queue = new PriorityQueue(function(a, b) &#123; if (a.priority &gt; b.priority) return 1; if (a.priority === b.priority) return -1; return 0;&#125;);queue.enqueue(&#123; priority: 1000, value: 'apple'&#125;);queue.enqueue(&#123; priority: 500, value: 'orange'&#125;);queue.dequeue(); // -&gt; &#123; priority: 1000, value: 'apple' &#125; Promise轻量 Promise 实现。 Promises 标准 12345678910111213141516171819function get(url) &#123; return new Promise(function(resolve, reject) &#123; const req = new XMLHttpRequest(); req.open('GET', url); req.onload = function() &#123; req.status == 200 ? resolve(req.response) : reject(Error(req.statusText)); &#125;; req.onerror = function() &#123; reject(Error('Network Error')); &#125;; req.send(); &#125;);&#125;get('test.json').then(function(result) &#123; // Do something...&#125;); PseudoMap类似 es6 的 Map，不支持遍历器。 类型定义const PseudoMap: typeof Map; 只支持字符串键名，当 Map 存在时会直接使用 Map。 123const map = new PseudoMap();map.set('1', 1);map.get('1'); // -&gt; 1 Queue队列数据结构。 类型定义class Queue { size: number; clear(): void; enqueue(item: any): number; dequeue(): any; peek(): any; forEach(iterator: types.AnyFn, context?: any): void; toArr(): any[];} size队列大小。 clear清空队列。 enqueue元素入列。 参数名 说明 item 入列元素 返回值 当前大小 dequeue元素出列。 peek获取第一个元素但不移除它。 forEach遍历队列。 参数名 说明 iterator 调用函数 ctx * 函数上下文 toArr将队列转换为 JavaScript 数组。 123456789const queue = new Queue();console.log(queue.size); // -&gt; 0queue.enqueue(2);queue.enqueue(3);queue.dequeue(); // -&gt; 2console.log(queue.size); // -&gt; 1queue.peek(); // -&gt; 3console.log(queue.size); // -&gt; 1 QuickLru不使用链表的 LRU 实现。 类型定义class QuickLru { constructor(max: number); has(key: string): boolean; remove(key: string): void; get(key: string): any; set(key: string, val: any): void; clear(): void;} 参考 hashlru 算法，空间占用相比使用链表更多。 API 与 Lru 模块保持一致。 123const cache = new QuickLru(50);cache.set('test', 'licia');cache.get('test'); // -&gt; 'licia' Readiness任务就绪回调管理。 类型定义class Readiness { signal(tasks: string | string[]): void; isReady(tasks: string | string[]): boolean; ready(tasks: string | string[], fn?: types.AnyFn): Promise&lt;void&gt;;} signal设置任务为就绪状态。 参数名 说明 tasks 就绪任务 ready注册任务就绪回调。 参数名 说明 tasks 要监听的任务 fn 任务就绪时触发的回调函数 返回值 任务就绪时 resolve 的 Promise isReady检查任务是否准备就绪。 参数名 说明 tasks 要检查的任务 返回值 任务准备就绪，返回真 123456const readiness = new Readiness();readiness.ready('serverCreated', function() &#123; // Do something.&#125;);readiness.signal('serverCreated');readiness.isReady('serverCreated'); // -&gt; true ReduceStore简单类 redux 状态管理。 类型定义class ReduceStore { constructor(reducer: types.AnyFn, initialState: any); subscribe(listener: types.AnyFn): types.AnyFn; dispatch(action: any): any; getState(): any;} constructor 参数名 说明 reducer 生成下一个状态的函数 initialState 初始状态 subscribe订阅状态改变事件。 参数名 说明 listener 回调函数 返回值 取消订阅函数 dispatch发出动作。 参数名 说明 action 描述改变内容的对象 返回值 传入对象 getState获取当前状态。 123456789101112131415161718const store = new ReduceStore(function(state, action) &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;, 0);store.subscribe(function() &#123; console.log(store.getState());&#125;);store.dispatch(&#123; type: 'INCREMENT' &#125;); // 1store.dispatch(&#123; type: 'INCREMENT' &#125;); // 2store.dispatch(&#123; type: 'DECREMENT' &#125;); // 1 ResizeSensor检查元素的大小是否发生变化。 类型定义class ResizeSensor extends SingleEmitter { constructor(el: HTMLElement); destroy(): void;} constructor 参数名 说明 element 要监听大小的元素 destroy停止监听大小变化事件。 12345const target = document.getElementById('test');const sensor = new ResizeSensor(target);sensor.addListener(function() &#123; // Trigger if element's size changed.&#125;); SelectquerySelectorAll 的简单包装类。 类型定义class Select { constructor(selector: string | Element | Document); find(selector: string): Select; each(fn: types.AnyFn): Select;} constructor 参数名 说明 selector 选择器 find查找子元素。 参数名 说明 selector 选择器 each遍历匹配的元素。 参数名 说明 fn 调用函数 1234const $test = new Select('#test');$test.find('.test').each(function(idx, element) &#123; // Manipulate dom nodes&#125;); Semaphore限制资源同时访问次数。 类型定义class Semaphore { constructor(counter?: number); wait(fn: () =&gt; void): void; signal(): void;} constructor 参数名 说明 counter=1 初始计数 wait等待计数器大于 0 时，执行函数。 参数名 说明 fn 要执行的函数 signal执行队列中未执行任务。 123456789const sem = new Semaphore(10);require('http') .createServer((req, res) =&gt; &#123; sem.wait(function() &#123; res.end('.'); setTimeout(() =&gt; sem.signal(), 500); &#125;); &#125;) .listen(3000); SessionStoreSessionStorage 存储。 类型定义class SessionStore extends Store { constructor(name: string, data?: any);} 继承自 Store 类。 constructor 参数名 说明 name SessionStorage 存储名 data 默认数据 12const store = new SessionStore('licia');store.set('name', 'licia'); SingleEmitter与 Event emitter 类似，但仅有一种事件类型。 类型定义class SingleEmitter { addListener(listener: types.AnyFn): void; rmListener(listener: types.AnyFn): void; emit(…args: any[]): void; rmAllListeners(): void; static mixin(obj: any): void;} addListener添加监听器。 rmListener移除监听器。 参数名 说明 listener 事件监听器 rmAllListeners移除所有监听器。 emit触发监听器。 参数名 说明 …args 传递给监听器的参数 mixin【静态】将 SingleEmitter 类的方法绑定到指定对象上去。 参数名 说明 obj 目标对象 12345const event = new SingleEmitter();event.addListener(function(name) &#123; console.log(name);&#125;);event.emit('licia'); // Logs out 'licia'. SocketWebSocket 类的简单包装。 类型定义class Socket extends Emitter { constructor( url: string, options?: { protocols?: string | string[]; reconnect?: boolean; } ); send(message: any): void; close(code?: number, reason?: string): void; connect(): void;} 继续自 Emitter 类。 constructor 参数名 说明 url WebSocket 地址 options 连接选项 可用选项： 参数名 说明 protocols 协议 reconnect=true 是否尝试重新连接 send发送数据。 参数名 说明 message 要发送的数据 close关闭 WebSocket 连接。 参数名 说明 code 状态码 reason 关闭原因 connect连接 WebSocket，初始化时就会被调用。 12const ws = new Socket('ws://localhost:8001');ws.on('open', e =&gt; ws.send('Hello')); Stack栈数据结构。 类型定义class Stack { size: number; clear(): void; push(item: any): number; pop(): any; peek(): any; forEach(iterator: types.AnyFn, context?: any): void; toArr(): any[];} size栈大小。 clear清空栈。 push元素入栈。 参数名 说明 item 入栈元素 返回值 当前大小 pop元素出栈。 peek获取最后一个元素但不移除它。 forEach遍历栈。 参数名 说明 iterator 调用函数 ctx 函数上下文 toArr将栈转换为 JavaScript 数组。 12345const stack = new Stack();stack.push(2); // -&gt; 1stack.push(3); // -&gt; 2stack.pop(); // -&gt; 3 State简单状态机。 类型定义class State extends Emitter { constructor(initial: string, events: any); is(state: string): boolean; [event: string]: any;} 继承自 Emitter 类。 constructor 参数名 说明 initial 初始状态 events 改变状态的事件 is检查当前状态是否是指定状态。 参数名 说明 state 要检查的状态 返回值 如果是，返回真 1234567891011121314151617const state = new State('empty', &#123; load: &#123; from: 'empty', to: 'pause' &#125;, play: &#123; from: 'pause', to: 'play' &#125;, pause: &#123; from: ['play', 'empty'], to: 'pause' &#125;, unload: &#123; from: ['play', 'pause'], to: 'empty' &#125;&#125;);state.is('empty'); // -&gt; truestate.load();state.is('pause'); // -&gt; truestate.on('play', function(src) &#123; console.log(src); // -&gt; 'eustia'&#125;);state.on('error', function(err, event) &#123; // Error handler&#125;);state.play('eustia'); Store内存存储。 类型定义class Store extends Emitter { constructor(data?: {}); set(key: string, val: any): void; set(values: {}): void; get(key: string): any; get(keys: string[]): {}; remove(key: string): void; remove(keys: string[]): void; clear(): void; each(fn: (…args: any[]) =&gt; void): void;} 继承自 Emitter 类。 constructor 参数名 说明 data 初始数据 set设置值。 参数名 说明 key 键名 val 键值 设置多个值。 参数名 说明 values 包含多个键值对的对象 该方法被调用时发触发 change 事件。 get获取值。 参数名 说明 key 键名 返回值 键值 获取多个值。 参数名 说明 keys 键名列表 返回值 包含多个键值对的对象 remove移除值。 参数名 说明 key 键名 clear清空数据。 each遍历数据。 参数名 说明 fn 遍历函数 12345678910const store = new Store('test');store.set('user', &#123; name: 'licia' &#125;);store.get('user').name; // -&gt; 'licia'store.clear();store.each(function(val, key) &#123; // Do something.&#125;);store.on('change', function(key, newVal, oldVal) &#123; // It triggers whenever set is called.&#125;); Trace解析、处理和生成 Chrome Trace 格式数据。 类型定义namespace Trace { interface IEvent { name: string; cat: string; ph: string; ts: number; pid: number; tid: number; args: any; [key: string]: any; } class Process { constructor(id); id(): string; name(): string; addEvent(IEvent): void; rmEvent(IEvent): void; getThread(id: number): Thread; rmThread(id: number): void; threads(): Thread[]; toJSON(): IEvent[]; } class Thread { constructor(id, pid); id(): string; name(): string; addEvent(IEvent): void; rmEvent(IEvent): void; events(): IEvent[]; toJSON(): IEvent[]; }}class Trace { constructor(events: Trace.IEvent[]); addEvent(event: Trace.IEvent); rmEvent(event: Trace.IEvent); getProcess(id: number): Trace.Process; rmProcess(id: number): void; processes(): Trace.Process[]; toJSON(): Trace.IEvent[];} 12345678910const fs = require('fs');const data = fs.readFileSync('path/to/trace', 'utf8');const trace = new Trace(JSON.parse(data));trace.rmProcess(627);fs.writeFileSync( 'path/to/trace', JSON.stringify(trace.toJSON()), 'utf8', function() &#123;&#125;); Tracing创建 chrome trace 格式数据。 类型定义class Tracing { constructor(options?: { pid?: number; tid?: number; processName?: string; threadName?: string; }); start(cat?: string): void; stop(): Trace.IEvent[]; metadata(name: string, args: any): void; begin(cat: string, name: string, args?: any): void; end(args?: any): void; asyncBegin(cat: string, name: string, id?: string, args?: any): string; asyncEnd(id: string, args?: any): void; instant( cat: string, name: string, scope?: &#x27;g&#x27; | &#x27;p&#x27; | &#x27;t&#x27;, args?: any ): void; id(): string;} constructor 参数名 说明 options 录制选项 可用选项： 参数名 说明 pid 进程 id tid 线程 id processName 进程名称 threadName 线程名称 start开始录制。 参数名 说明 cat 开启类别 stop停止录制并获取事件列表。 begin记录开始事件。 参数名 说明 cat 事件类别 name 事件名称 args 参数 end记录结束事件。 asyncBegin记录异步开始事件。 asyncEnd记录异步结束事件。 instant记录 instant 事件。 id获取一个唯一 id。 123456789101112const fs = require('fs');const tracing = new Tracing();tracing.start();tracing.begin('cat', 'name');// Do something...tracing.end();fs.writeFileSync( 'path/to/trace', JSON.stringify(tracing.stop()), 'utf8', function() &#123;&#125;); Trie字典树数据结构。 类型定义class Trie { add(word: string): void; remove(word: string): void; has(word: string): boolean; words(prefix: string): string[]; clear(): void;} add添加单词到字典数。 参数名 说明 word 要添加的单词 remove从字典树中移除单词。 has检查字典树中是否存在单词。 words获取所有带指定前缀的单词。 参数名 说明 prefix 单词前缀 返回值 所有带指定前缀的单词 clear清除字典树中的所有单词。 12345678910const trie = new Trie();trie.add('carpet');trie.add('car');trie.add('cat');trie.add('cart');trie.has('cat'); // -&gt; truetrie.remove('carpet');trie.has('carpet'); // -&gt; falsetrie.words('car'); // -&gt; ['car', 'cart']trie.clear(); TweenJavaScript 补间动画库。 类型定义class Tween extends Emitter { constructor(target: any); to(props: any, duration?: number, ease?: string | Function): Tween; progress(): number; progress(progress: number): Tween; play(): Tween; pause(): Tween; paused(): boolean;} 继承自 Emitter 类。 constructor 参数名 说明 obj 要补间的对象 to 参数名 说明 destination 目标属性值 duration 补间时长 ease 缓动函数 play开始播放。 pause暂停动画。 paused检查动画是否暂停。 progress设置或获取动画进度。 参数名 说明 progress 介于 0 到 1 之间的数字 1234567891011const pos = &#123; x: 0, y: 0 &#125;;const tween = new Tween(pos);tween .on('update', function(target) &#123; console.log(target.x, target.y); &#125;) .on('end', function(target) &#123; console.log(target.x, target.y); // -&gt; 100, 100 &#125;);tween.to(&#123; x: 100, y: 100 &#125;, 1000, 'inElastic').play(); Url简单 url 操作库。 类型定义namespace Url { interface IUrl { protocol: string; auth: string; hostname: string; hash: string; query: any; port: string; pathname: string; slashes: boolean; }}class Url { protocol: string; auth: string; hostname: string; hash: string; query: any; port: string; pathname: string; slashes: boolean; constructor(url?: string); setQuery(name: string, val: string | number): Url; setQuery(query: types.PlainObj&lt;string | number&gt;): Url; rmQuery(name: string | string[]): Url; toString(): string; static parse(url: string): Url.IUrl; static stringify(object: Url.IUrl): string;} constructor 参数名 说明 url=location url 地址 setQuery设置 query 值。 参数名 说明 name query 名 val query 值 返回值 this 参数名 说明 query query 对象 返回值 this rmQuery移除 query 值。 参数名 说明 name query 名 返回值 this parse【静态】将 url 解析成对象。 参数名 说明 url url 地址 返回值 url 对象 stringify【静态】将 url 对象转换为 url 地址。 参数名 说明 url url 对象 返回值 url 地址 url 对象包含以下属性值： 属性名 说明 protocol 协议名，（如 http:） slashes 协议名后是否有双斜杠 auth 身份验证（例如 用户名:密码） hostname Host 名，不带端口号 port 端口号 pathname URL 路径 query query 对象 hash URL # 字符后边的部分，# 包含在内 12345const url = new Url('http://example.com:8080?eruda=true');console.log(url.port); // -&gt; '8080'url.query.foo = 'bar';url.rmQuery('eruda');url.toString(); // -&gt; 'http://example.com:8080/?foo=bar' Validator对象属性值校验。 类型定义class Validator { constructor(options: types.PlainObj&lt;any&gt;); validate(object: any): string | boolean; static plugins: any; static addPlugin(name: string, plugin: types.AnyFn): void;} constructor 参数名 说明 options 校验配置 validate校验对象。 参数名 说明 obj 目标对象 返回值 校验结果，true 表示通过 addPlugin【静态】添加插件。 参数名 说明 name 插件名 plugin 校验函数 默认插件required，number，boolean，string 和 regexp。 1234567891011121314Validator.addPlugin('custom', function(val, key, config) &#123; if (typeof val === 'string' &amp;&amp; val.length === 5) return true; return key + ' should be a string with length 5';&#125;);const validator = new Validator(&#123; test: &#123; required: true, custom: true &#125;&#125;);validator.validate(&#123;&#125;); // -&gt; 'test is required'validator.validate(&#123; test: 1 &#125;); // -&gt; 'test should be a string with length 5';validator.validate(&#123; test: 'licia' &#125;); // -&gt; true Wrr加权轮询调度算法实现。 类型定义class Wrr { size: number; set(val: any, weight: number): void; get(val: any): number | void; remove(val: any): void; clear(): void; next(): any;} size池大小。 set设置值和权重，如果值已存在则更新其权重。 参数名 说明 val 要设置的值 weight 值的权重 get获取指定值的权重。 参数名 说明 val 要获取的值 返回值 值的权重 remove移除指定值。 参数名 说明 val 要移除的值 next从池中获取下一个值。 clear清除所有值。 1234567const pool = new Wrr();pool.set('A', 4);pool.set('B', 8);pool.set('C', 2);pool.next();pool.remove('A');console.log(pool.size); // -&gt; 2 abbrev计算字符串集的缩写集合。 类型定义function abbrev(…names: string[]): types.PlainObj&lt;string&gt;; 参数名 说明 names 字符串集 返回值 缩写集合 12abbrev('lina', 'luna');// -&gt; &#123;li: 'lina', lin: 'lina', lina: 'lina', lu: 'luna', lun: 'luna', luna: 'luna'&#125; after创建一个函数，只有在调用 n 次后才会调用一次。 类型定义function after&lt;T extends types.AnyFn&gt;(n: number, fn: T): T; 参数名 说明 n 调用次数 fn 源函数 返回值 输出函数 123const fn = after(5, function() &#123; // -&gt; Only invoke after fn is called 5 times.&#125;); ajax执行异步 HTTP 请求。 类型定义namespace ajax { function get( url: string, data: string | {}, success: types.AnyFn, dataType?: string ): XMLHttpRequest; function get( url: string, success: types.AnyFn, dataType?: string ): XMLHttpRequest; function post( url: string, data: string | {}, success: types.AnyFn, dataType?: string ): XMLHttpRequest; function post( url: string, success: types.AnyFn, dataType?: string ): XMLHttpRequest;}function ajax(options: { type?: string; url: string; data?: string | {}; dataType?: string; contentType?: string; success?: types.AnyFn; error?: types.AnyFn; complete?: types.AnyFn; timeout?: number;}): XMLHttpRequest; 参数名 说明 options Ajax 选项 可用选项： 参数名 说明 type 请求类型 url 请求地址 data 请求数据 dataType=json 响应类型（json，xml） contentType=application/x-www-form-urlencoded 请求内容类型 success 成功回调 error 失败回调 complete 结束回调 timeout 请求超时 gettype = GET 的快捷方式。 posttype = POST 的快捷方式。 参数名 说明 url 请求地址 data 请求数据 success 成功回调 dataType 响应类型 12345678910111213ajax(&#123; url: 'http://example.com', data: &#123; test: 'true' &#125;, error() &#123;&#125;, success(data) &#123; // ... &#125;, dataType: 'json'&#125;);ajax.get('http://example.com', &#123;&#125;, function(data) &#123; // ...&#125;); allKeys获取对象的所有键名，包括自身的及继承的。 类型定义namespace allKeys { interface IOptions { prototype?: boolean; unenumerable?: boolean; }}function allKeys( obj: any, options: { symbol: true } &amp; allKeys.IOptions): Array&lt;string | Symbol&gt;;function allKeys( obj: any, options?: ({ symbol: false } &amp; allKeys.IOptions) | allKeys.IOptions): string[]; 参数名 说明 obj 目标对象 options 选项 返回值 包含所有键名的数组 可用选项： 参数名 说明 prototype=true 包含原型键名 unenumerable=false 包含不可枚举键名 symbol=false 包含 Symbol 键名 Object 对象原型上的方法不会被获取到。 123const obj = Object.create(&#123; zero: 0 &#125;);obj.one = 1;allKeys(obj); // -&gt; ['zero', 'one'] ansiColor控制台颜色。 类型定义namespace ansiColor { type IFn = (str: string) =&gt; string;}const ansiColor: { black: ansiColor.IFn; red: ansiColor.IFn; green: ansiColor.IFn; yellow: ansiColor.IFn; blue: ansiColor.IFn; magenta: ansiColor.IFn; cyan: ansiColor.IFn; white: ansiColor.IFn; gray: ansiColor.IFn; grey: ansiColor.IFn; bgBlack: ansiColor.IFn; bgRed: ansiColor.IFn; bgGreen: ansiColor.IFn; bgYellow: ansiColor.IFn; bgBlue: ansiColor.IFn; bgMagenta: ansiColor.IFn; bgCyan: ansiColor.IFn; bgWhite: ansiColor.IFn; blackBright: ansiColor.IFn; redBright: ansiColor.IFn; greenBright: ansiColor.IFn; yellowBright: ansiColor.IFn; blueBright: ansiColor.IFn; magentaBright: ansiColor.IFn; cyanBright: ansiColor.IFn; whiteBright: ansiColor.IFn; bgBlackBright: ansiColor.IFn; bgRedBright: ansiColor.IFn; bgGreenBright: ansiColor.IFn; bgYellowBright: ansiColor.IFn; bgBlueBright: ansiColor.IFn; bgMagentaBright: ansiColor.IFn; bgCyanBright: ansiColor.IFn; bgWhiteBright: ansiColor.IFn;}; 支持颜色black, red, green, yellow, blue, magenta, cyan, white, gray, grey bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, blackBright, redBright, greenBright, yellowBright, blueBright, magentaBright, cyanBright, whiteBright bgBlackBright, bgRedBright, bgGreenBright, bgYellowBright, bgBlueBright, bgMagentaBright, bgCyanBright, bgWhiteBright 1ansiColor.red('Warning'); arrToMap将字符串列表转换为映射。 类型定义function arrToMap&lt;T&gt;( arr: string[], val?: T): { [key: string]: T }; 参数名 说明 arr 字符串列表 val=true 键值 返回值 映射 12345678910111213const needPx = arrToMap([ 'column-count', 'columns', 'font-weight', 'line-weight', 'opacity', 'z-index', 'zoom']);const key = 'column-count';let val = '5';if (needPx[key]) val += 'px';console.log(val); // -&gt; '5px' atobwindow.atob，运行在 node 环境时使用 Buffer 进行模拟。 类型定义function atob(str: string): string; 1atob('SGVsbG8gV29ybGQ='); // -&gt; 'Hello World' average获取数字的平均值。 类型定义function average(…numbers: number[]): number; 参数名 说明 numbers 要计算的数字 返回值 平均值 1average(5, 3, 1); // -&gt; 3 base64base64 编解码。 类型定义const base64: { encode(bytes: number[]): string; decode(str: string): number[];}; encode将字节数组编码为 base64 字符串。 参数名 说明 bytes 字节数组 返回值 base64 编码的字符串 decode将 base64 字符串解码为字节数组。 参数名 说明 str base64 编码的字符串 返回值 字节数组 12base64.encode([168, 174, 155, 255]); // -&gt; 'qK6b/w=='base64.decode('qK6b/w=='); // -&gt; [168, 174, 155, 255] before创建一个函数，只能调用少于 n 次。 类型定义function before&lt;T extends types.AnyFn&gt;(n: number, fn: T): T; 参数名 说明 n 调用次数 fn 源函数 返回值 输出函数 超过 n 次后再次调用函数将直接返回最后一次函数的调用结果。 12const fn = before(5, function() &#123;&#125;);fn(); // Allow function to be call 4 times at last. binarySearch二分查找实现。 类型定义function binarySearch( array: any[], val: any, cmp?: types.AnyFn): number; 参数名 说明 array 目标数组 val 要查找的值 cmp 比较器 返回值 第一次出现的位置，如果没有，返回 -1 1234567891011121314151617binarySearch([1, 2, 3], 2); // -&gt; 1binarySearch([1, 2], 3); // -&gt; -1binarySearch( [ &#123; key: 1 &#125;, &#123; key: 2 &#125; ], &#123; key: 1 &#125;, (a, b) =&gt; &#123; if (a.key === b.key) return 0; return a.key &lt; b.key ? -1 : 1; &#125;); // -&gt; 0 bind创建一个绑定到指定对象的函数。 类型定义function bind( fn: types.AnyFn, ctx: any, …args: any[]): types.AnyFn; 参数名 说明 fn 源函数 ctx 绑定对象 args 可选参数 返回值 输出函数 12345678const fn = bind( function(msg) &#123; console.log(this.name + ':' + msg); &#125;, &#123; name: 'eustia' &#125;, 'I am a utility library.');fn(); // -&gt; 'eustia: I am a utility library.' btoawindow.btoa，运行在 node 环境时使用 Buffer 进行模拟。 类型定义function btoa(str: string): string; 1btoa('Hello World'); // -&gt; 'SGVsbG8gV29ybGQ=' bubbleSort冒泡排序实现。 类型定义function bubbleSort(arr: any[], cmp?: types.AnyFn): any[]; 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1bubbleSort([2, 1]); // -&gt; [1, 2] bytesToStr将字节数组转换为字符串。 类型定义function bytesToStr(bytes: number[], encoding?: string): string; 参数名 说明 bytes 字节数组 encoding=utf8 字符串编码 返回值 目标字符串 1bytesToStr([108, 105, 99, 105, 97]); // -&gt; 'licia' bytesToWords将字节数组转换为 32 位字长数组。 类型定义function bytesToWords(bytes: number[]): number[]; 在使用 CryptoJS 时会派上用处。 参数名 说明 bytes 字节数组 返回值 字长数组 1bytesToWords([0x12, 0x34, 0x56, 0x78]); // -&gt; [0x12345678] cacheRequire缓存模块加载，提高应用启动速度。 类型定义function cacheRequire(options?: { dir?: string; requirePath?: boolean; code?: boolean; compileCache?: boolean;}): void; 参数名 说明 options 缓存选项 可用选项： 参数名 说明 dir 缓存文件夹 requirePath=true Whether require path should be cached code=false Whether js code should be cached compileCache=true Whether compile cache should be used 123cacheRequire(&#123; dir: 'path/to/cache/dir'&#125;); callbackify将返回 Promise 的函数转换为使用回调的函数。 类型定义function callbackify(fn: types.AnyFn): types.AnyFn; 参数名 说明 fn 返回 Promise 的函数 返回值 使用回调的函数 1234567891011function fn() &#123; return new Promise(function(resolve, reject) &#123; // ... &#125;);&#125;const cbFn = callbackify(fn);cbFn(function(err, value) &#123; // ...&#125;); camelCase将字符串转换为驼峰式。 类型定义function camelCase(str: string): string; 参数名 说明 str 源字符串 返回值 驼峰式字符串 1234camelCase('foo-bar'); // -&gt; fooBarcamelCase('foo bar'); // -&gt; fooBarcamelCase('foo_bar'); // -&gt; fooBarcamelCase('foo.bar'); // -&gt; fooBar capitalize将字符串的第一个字符转换为大写，其余字符转换为小写。 类型定义function capitalize(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1capitalize('rED'); // -&gt; Red castPath将值转换为属性路径数组。 类型定义function castPath(path: string | string[], obj?: any): string[]; 参数名 说明 path 要转换的值 obj 目标对象 返回值 属性路径数组 1234castPath('a.b.c'); // -&gt; ['a', 'b', 'c']castPath(['a']); // -&gt; ['a']castPath('a[0].b'); // -&gt; ['a', '0', 'b']castPath('a.b.c', &#123; 'a.b.c': true &#125;); // -&gt; ['a.b.c'] centerAlign字符串居中。 类型定义function centerAlign( str: string | string[], width?: number): string; 参数名 说明 str 源字符串 width 每行宽度 返回值 居中字符串 123centerAlign('test', 8); // -&gt; ' test'centerAlign('test\\nlines', 8); // -&gt; ' test\\n lines'centerAlign(['test', 'lines'], 8); // -&gt; ' test\\n lines' char根据指定的整数返回 unicode 编码为该整数的字符。 类型定义function char(num: number): string; 参数名 说明 num 要转换的整数 返回值 对应字符 12char(65); // -&gt; 'A'char(97); // -&gt; 'a' chunk将数组拆分为指定长度的子数组。 类型定义function chunk(arr: any[], size?: number): Array&lt;any[]&gt;; 参数名 说明 arr 源数组 size=1 子数组的长度 返回值 目标数组 123chunk([1, 2, 3, 4], 2); // -&gt; [[1, 2], [3, 4]]chunk([1, 2, 3, 4], 3); // -&gt; [[1, 2, 3], [4]]chunk([1, 2, 3, 4]); // -&gt; [[1], [2], [3], [4]] clamp将数字限定于指定区间。 类型定义function clamp(n: number, lower: number, upper: number): number;function clamp(n: number, upper: number): number; 参数名 说明 n 要处理的数字 lower 下限 upper 上限 返回值 限定后的数字 12345clamp(-10, -5, 5); // -&gt; -5clamp(10, -5, 5); // -&gt; 5clamp(2, -5, 5); // -&gt; 2clamp(10, 5); // -&gt; 5clamp(2, 5); // -&gt; 2 className合并 class。 类型定义function className(…names: any[]): string; 参数名 说明 names 要合并的 class 返回值 合并后的 class 字符串 12345className('a', 'b', 'c'); // -&gt; 'a b c'className('a', false, 'b', 0, 1, 'c'); // -&gt; 'a b 1 c'className('a', ['b', 'c']); // -&gt; 'a b c'className('a', &#123; b: false, c: true &#125;); // -&gt; 'a c'className('a', ['b', 'c', &#123; d: true, e: false &#125;]); // -&gt; 'a b c d'; cliHelp输出命令行帮助。 类型定义namespace cliHelp { interface IOption { name: string; shorthand?: string; desc: string; } interface ICommand { name: string; desc: string; usage: string | string[]; options?: IOption[]; } interface IData { name: string; usage: string | string[]; commands: ICommand[]; }}function cliHelp(data: cliHelp.IData | cliHelp.ICommand): string; 参数名 说明 data 帮助数据 返回值 命令行帮助 1234567891011121314151617181920const test = &#123; name: 'test', desc: 'Generate test files', usage: ['&lt;module-name&gt; [options]', 'lpad --browser'], options: [ &#123; name: 'browser', shorthand: 'b', desc: 'True if test should run in a browser' &#125; ]&#125;;const data = &#123; name: 'licia', usage: '&lt;command&gt; [options]', commands: [test]&#125;;cliHelp(data);cliHelp(test); clone对指定对象进行浅复制。 类型定义function clone&lt;T&gt;(val: T): T; 任何嵌套的对象或数组只会拷贝其引用。 参数名 说明 val 要克隆的值 返回值 克隆值 1clone(&#123; name: 'eustia' &#125;); // -&gt; &#123;name: 'eustia'&#125; cloneDeep深复制。 类型定义function cloneDeep&lt;T&gt;(val: T): T; 参数名 说明 val 要克隆的值 返回值 克隆值 123const obj = [&#123; a: 1 &#125;, &#123; a: 2 &#125;];const obj2 = cloneDeep(obj);console.log(obj[0] === obj2[1]); // -&gt; false cmpVersion比较版本号。 类型定义function cmpVersion(v1: string, v2: string): number; 参数名 说明 v1 版本号 v2 版本号 返回值 比较结果 12345cmpVersion('1.1.8', '1.0.4'); // -&gt; 1cmpVersion('1.0.2', '1.0.2'); // -&gt; 0cmpVersion('2.0', '2.0.0'); // -&gt; 0cmpVersion('3.0.1', '3.0.0.2'); // -&gt; 1cmpVersion('1.1.1', '1.2.3'); // -&gt; -1 combine创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值。 类型定义function combine(keys: string[], values: any[]): any; 参数名 说明 keys 键名数组 values 键值数组 返回值 目标对象 1combine(['a', 'b', 'c'], [1, 2, 3]); // -&gt; &#123;a: 1, b: 2, c: 3&#125; compact返回数组的拷贝并移除其中的虚值。 类型定义function compact(arr: any[]): any[]; 虚值包括 false，null，0，空字符串，undefined 和 NaN。 参数名 说明 arr 源数组 返回值 目标数组 1compact([0, 1, false, 2, '', 3]); // -&gt; [1, 2, 3] compose将多个函数组合成一个函数。 类型定义function compose(…fn: types.AnyFn[]): types.AnyFn; 每个函数使用下一个函数的返回值作为参数。 参数名 说明 …fn 要组合的函数 返回值 目标函数 12345678910const welcome = compose( function(name) &#123; return 'hi: ' + name; &#125;, function(name) &#123; return name.toUpperCase() + '!'; &#125;);welcome('licia'); // -&gt; 'hi: LICIA!' compressImg使用 canvas 对图像进行压缩。 类型定义function compressImg( file: File | Blob | string, cb: types.AnyFn): void;function compressImg( file: File | Blob | string, options?: { maxWidth?: number; maxHeight?: number; width?: number; height?: number; mimeType?: string; quality?: number; }, cb?: types.AnyFn): void; 参数名 说明 file 图片文件或 url options 选项 cb 回调 可用选项： 参数名 说明 maxWidth 最大宽度 maxHeight 最大高度 width 输出图片宽度 height 输出图片高度 mimeType Mine 类型 quality=0.8 图片质量，从 0 到 1 为了保持图片比例，当宽度设置时高度将被忽略。 如果设置了宽高，最大宽度跟最大高度将被忽略。 12345678910const file = new Blob([]);compressImg( file, &#123; maxWidth: 200 &#125;, function(err, file) &#123; // ... &#125;); concat将多个数组合并成一个数组。 类型定义function concat(…args: Array&lt;any[]&gt;): any[]; 参数名 说明 …arr 要合并的数组 返回值 合并后的数组 1concat([1, 2], [3], [4, 5]); // -&gt; [1, 2, 3, 4, 5] contain检查数组中是否有指定值。 类型定义function contain(arr: any[] | {} | string, val: any): boolean; 参数名 说明 target 目标对象 val 要检查的值 返回值 如果有，返回真 123contain([1, 2, 3], 1); // -&gt; truecontain(&#123; a: 1, b: 2 &#125;, 1); // -&gt; truecontain('abc', 'a'); // -&gt; true convertBase对数字进行进制转换。 类型定义function convertBase( num: number | string, from: number, to: number): string; 参数名 说明 num 要转换的数字 from 源进制 to 目标进制 返回值 转换后的数字 12convertBase('10', 2, 10); // -&gt; '2'convertBase('ff', 16, 2); // -&gt; '11111111' convertBin二进制数据格式转换。 类型定义namespace convertBin { function blobToArrBuffer(blob: any): Promise&lt;ArrayBuffer&gt;;}function convertBin(bin: any, type: string): any; 参数名 说明 bin 源二进制数据 type 二进制类型 返回值 目标二进制数据 支持格式base64, ArrayBuffer, Array, Uint8Array, Blob(browser), Buffer(node) 因为将 Blob 转换为其它格式是个异步过程，所以你不能直接对它进行转换。 blobToArrBuffer将 Blob 类型转换为 ArrayBuffer 类型。 参数名 说明 blob Blob 数据 返回值 ArrayBuffer promise 1234convertBin('qK6b/w==', 'Uint8Array'); // -&gt; [168, 174, 155, 255]convertBin.blobToArrBuffer(new Blob([])).then(arrBuffer =&gt; &#123; // Do something...&#125;); cookie浏览器 cookie 操作库。 类型定义namespace cookie { interface IOptions { path?: string; expires?: number; domain?: string; secure?: boolean; } interface ICookie { get(key: string, options?: cookie.IOptions): string; set(key: string, val: string, options?: cookie.IOptions): ICookie; remove(key: string, options?: cookie.IOptions): ICookie; }}const cookie: cookie.ICookie; get获取 cookie 值。 参数名 说明 key Cookie 键名 返回值 对应的 cookie 值 set设置 cookie 值。 参数名 说明 key cookie 键名 val cookie 值 options cookie 选项 返回值 cookie 模块 remove移除 cookie 值。 参数名 说明 key Cookie 键名 options Cookie 选项 返回值 cookie 模块 123cookie.set('a', '1', &#123; path: '/' &#125;);cookie.get('a'); // -&gt; '1'cookie.remove('a'); copy使用 document.execCommand 将文本拷贝到剪贴板。 类型定义function copy(text: string, cb?: types.AnyFn): void; 参数名 说明 text 要拷贝的文本 cb 可选回调 123copy('text', function(err) &#123; // Handle errors.&#125;); crc1CRC1 算法实现。 类型定义function crc1( input: string | number[], previous?: number): number; 参数名 说明 input 信息码 previous 用于累积计算的 CRC1 校验码 返回值 CRC1 校验码 1crc1('1234567890').toString(16); // -&gt; 'd' crc16CRC16 算法实现。 类型定义function crc16( input: string | number[], previous?: number): number; 参数名 说明 input 信息码 previous 用于累积计算的 CRC16 校验码 返回值 CRC16 校验码 1crc16('1234567890').toString(16); // -&gt; 'c57a' crc32CRC32 算法实现。 类型定义function crc32( input: string | number[], previous?: number): number; 参数名 说明 input 信息码 previous 用于累积计算的 CRC32 校验码 返回值 CRC32 校验码 1crc32('1234567890').toString(16); // -&gt; '261daee5' crc8CRC8 算法实现。 类型定义function crc8( input: string | number[], previous?: number): number; 参数名 说明 input 信息码 previous 用于累积计算的 CRC8 校验码 返回值 CRC8 校验码 1crc8('1234567890').toString(16); // -&gt; '52' create创建对象并指定它的原型。 类型定义function create(proto?: object): any; 参数名 说明 proto 新对象原型 返回值 目标对象 12const obj = create(&#123; a: 1 &#125;);console.log(obj.a); // -&gt; 1 createAssigner用于创建 extend，extendOwn 和 defaults 等模块。 类型定义function createAssigner( keysFn: types.AnyFn, defaults: boolean): types.AnyFn; 参数名 说明 keysFn 获取对象键名的函数 defaults 设置为真时不对值进行覆盖 返回值 目标函数 createUrlCreateObjectURL 的包裹函数。 类型定义function createUrl( data: any, options?: { type?: string }): string; 参数名 说明 data 数据 options 当数据不是 File 或者 Blob 对象时使用 返回值 Blob 地址 1234createUrl('test', &#123; type: 'text/plain' &#125;); // -&gt; Blob urlcreateUrl(['test', 'test']);createUrl(new Blob([]));createUrl(new File(['test'], 'test.txt')); cssCSS 解析器。 类型定义const css: { parse(css: string): object; stringify(stylesheet: object, options?: { indent?: string }): string;}; 注释会被移除掉。 parse将 CSS 字符串转换为 js 对象。 参数名 说明 css CSS 字符串 返回值 js 对象 stringify将 js 对象序列化成 CSS 字符串。 参数名 说明 stylesheet 要序列化的对象 options 序列化选项 返回值 CSS 字符串 选项： 参数名 说明 indent=’ ‘ 缩进 123const stylesheet = css.parse('.name &#123; background: #000; color: red; &#125;');// &#123;type: 'stylesheet', rules: [&#123;type: 'rule', selector: '.name', declarations: [...]&#125;]&#125;css.stringify(stylesheet); cssPriority计算与比较 CSS 选择器/样式的优先级。 类型定义namespace cssPriority { function compare(p1: number[], p2: number[]): number;}function cssPriority( selector: string, options?: { important?: boolean; inlineStyle?: boolean; position?: number; }): number[]; 参数名 说明 selector CSS 选择器 options 样式额外信息 返回值 优先级数组 优先级数组包括六个数字值。 important 标识 内联样式 ID 选择器 类选择器 类型选择器 样式位置 compare比较优先级。 参数名 说明 p1 优先级数组 p2 优先级数组 返回值 比较结果 12345cssPriority('a.button &gt; i.icon:before', &#123; important: true, inlineStyle: false, position: 100&#125;); // -&gt; [1, 0, 0, 2, 3, 100] cssSupports检查浏览器是否支持某项 CSS 特性。 类型定义function cssSupports(name: string, val?: string): boolean; 参数名 说明 name Css 属性名 val Css 属性值 返回值 如果支持，返回真 12345cssSupports('display', 'flex'); // -&gt; truecssSupports('display', 'invalid'); // -&gt; falsecssSupports('text-decoration-line', 'underline'); // -&gt; truecssSupports('grid'); // -&gt; truecssSupports('invalid'); // -&gt; false curry函数柯里化。 类型定义function curry(fn: types.AnyFn): types.AnyFn; 参数名 说明 fn 源函数 返回值 目标函数 12345const add = curry(function(a, b) &#123; return a + b;&#125;);const add1 = add(1);add1(2); // -&gt; 3 dateFormat简单日期格式化。 类型定义function dateFormat( date: Date, mask: string, utc?: boolean, gmt?: boolean): string;function dateFormat( mask: string, utc?: boolean, gmt?: boolean): string; 参数名 说明 date=new Date 要格式化的日期对象 mask 日期掩码 utc=false 是否是 UTC gmt=false 是否是 GMT 返回值 格式化日期 掩码 说明 d 月份天数，不补零 dd 月份天数，不足两位补零 ddd 星期几，简称 dddd 星期几，全称 m 月份，数字，不补零 mm 月份，数字，不足两位补零 mmm 月份，简称 mmmm 月份，全称 yy 年份，只显示后两位数字，不足两位补零 yyyy 年份，显示四位数字 h 小时，不补零 (12 小时制) hh 小时，不足两位补零（12 小时制） H 小时，不补零（24 小时制） HH 小时，不足两位补零（24 小时制） M 分钟，不补零 MM 分钟，不足两位补零 s 秒数，不补零 ss 秒数，不足两位补零 l L 毫秒，l 显示 3 位， L 显示 2 位 t 小写显示上午下午，a 或 p tt 小写显示上午下午，am 或 pm T 大写显示上午下午，A 或 P TT 大写显示上午下午，AM 或 PM Z 美国时区缩写，比如 EST 或 MDT o GMT/UTC 时区时差，比如 -0500 或 +0230 S 月份天数序数后缀 （st，nd，rd，或 th） UTC: 是否是 UTC，必须写在最前面 123dateFormat('isoDate'); // -&gt; 2016-11-19dateFormat('yyyy-mm-dd HH:MM:ss'); // -&gt; 2016-11-19 19:00:04dateFormat(new Date(), 'yyyy-mm-dd'); // -&gt; 2016-11-19 debounce返回函数的防反跳版本。 类型定义function debounce&lt;T extends types.AnyFn&gt;(fn: T, wait: number): T; 参数名 说明 fn 源函数 wait 延迟毫秒数 返回值 目标函数 12const calLayout = debounce(function() &#123;&#125;, 300);// $(window).resize(calLayout); debug简单的 JavaScript 输出 debug 日志函数。 类型定义function debug(name: string): any; 参数名 说明 name 名称 返回值 打印格式化日志的函数 123const d = debug('test');d('doing lots of uninteresting work');d.enabled = false; deburr转换拉丁语-1补充字母和拉丁语扩展字母-A为基本拉丁字母，并且去除组合变音标记。 类型定义function deburr(str: string): string; 参数名 说明 str 要处理的字符串 返回值 目标字符串 1deburr('déjà vu'); // -&gt; 'deja vu' decodeUriComponent类似 decodeURIComponent 函数，只是输入不合法时不抛出错误并尽可能地对其进行解码。 类型定义function decodeUriComponent(str: string): string; 参数名 说明 str 要解码的字符串 返回值 解码后的字符串 12decodeUriComponent('%%25%'); // -&gt; '%%%'decodeUriComponent('%E0%A4%A'); // -&gt; '\\xE0\\xA4%A' defaults填充对象的默认值。 类型定义function defaults(obj: any, …src: any[]): any; 参数名 说明 obj 目标对象 …src 提供默认值对象 返回值 目标对象 1defaults(&#123; name: 'RedHood' &#125;, &#123; name: 'Unknown', age: 24 &#125;); // -&gt; &#123;name: 'RedHood', age: 24&#125; define定义一个模块，需要跟 use 模块配合使用。 类型定义function define( name: string, requires: string[], method: types.AnyFn): void;function define(name: string, method: types.AnyFn): void; 参数名 说明 name 模块名 requires 依赖 method 模块主体函数 模块主体函数只有被 use 模块使用时才会被执行。 123456define('A', function() &#123; return 'A';&#125;);define('B', ['A'], function(A) &#123; return 'B' + A;&#125;); definePropObject.defineProperty(defineProperties) 的快捷方式。 类型定义function defineProp&lt;T&gt;( obj: T, prop: string, descriptor: PropertyDescriptor): T;function defineProp&lt;T&gt;( obj: T, descriptor: PropertyDescriptorMap): T; 参数名 说明 obj 要定义的对象 prop 属性路径 descriptor 属性描述 返回值 传入对象 参数名 说明 obj 要定义的对象 prop 属性描述 返回值 传入对象 1234567891011121314151617181920212223242526272829303132const obj = &#123; b: &#123; c: 3 &#125;, d: 4, e: 5 &#125;;defineProp(obj, 'a', &#123; get: function() &#123; return this.e * 2; &#125;&#125;);// obj.a is equal to 10defineProp(obj, 'b.c', &#123; set: function(val) &#123; // this is pointed to obj.b this.e = val; &#125;.bind(obj)&#125;);obj.b.c = 2;// obj.a is equal to 4const obj2 = &#123; a: 1, b: 2, c: 3 &#125;;defineProp(obj2, &#123; a: &#123; get: function() &#123; return this.c; &#125; &#125;, b: &#123; set: function(val) &#123; this.c = val / 2; &#125; &#125;&#125;);// obj2.a is equal to 3obj2.b = 4;// obj2.a is equal to 2 defined返回第一个不是未定义的参数。 类型定义function defined(…args: any[]): any; 参数名 说明 …args 参数列表 返回值 第一个定义了的参数 1defined(false, 2, void 0, 100); // -&gt; false delRequireCache删除 node.js require 缓存。 类型定义function delRequireCache(id: string): void; 参数名 说明 id 模块名或路径 1234const licia = require('licia');licia.a = 5;delRequireCache('licia');require('licia').a; // -&gt; undefined delay在指定时长后执行函数。 类型定义function delay( fn: types.AnyFn, wait: number, …args: any[]): void; 参数名 说明 fn 源函数 wait 延迟的毫秒数 …args 绑定参数 12345678delay( function(text) &#123; console.log(text); &#125;, 1000, 'later');// -&gt; Logs 'later' after one second delegate事件委托。 类型定义const delegate: { add(el: Element, type: string, selector: string, cb: types.AnyFn): void; remove(el: Element, type: string, selector: string, cb: types.AnyFn): void;}; add添加事件委托。 参数名 说明 el 父元素 type 事件类型 selector 匹配选择器 cb 事件回调 remove移除事件委托。 123456const container = document.getElementById('container');function clickHandler() &#123; // Do something...&#125;delegate.add(container, 'click', '.children', clickHandler);delegate.remove(container, 'click', '.children', clickHandler); deprecateNode.js util.deprecate 方法，支持浏览器。 类型定义function deprecate(fn: types.AnyFn, msg: string): types.AnyFn; 参数名 说明 fn 即将废弃的方法 msg 调用警告 返回值 废弃方法，调用时会打印警告 123const fn = () =&gt; &#123;&#125;;const obsoleteFn = deprecate(fn, 'obsoleteFn is deprecated.');obsoleteFn(); detectBrowser使用 ua 检测浏览器信息。 类型定义function detectBrowser( ua?: string): { name: string; version: number;}; 参数名 说明 ua=navigator.userAgent 浏览器用户代理 返回值 包含名称和版本的对象 支持浏览器：ie，chrome，edge，firefox，opera，safari，ios（mobile safari），android（android browser） 1234const browser = detectBrowser();if (browser.name === 'ie' &amp;&amp; browser.version &lt; 9) &#123; // Do something about old IE...&#125; detectMocha检测是否有 mocha 测试框架在运行。 类型定义function detectMocha(): boolean; 1detectMocha(); // -&gt; True if mocha is running. detectOs使用 ua 检测操作系统。 类型定义function detectOs(ua?: string): string; 参数名 说明 ua=navigator.userAgent 浏览器用户代理 返回值 操作系统名称 支持操作系统: windows, os x, linux, ios, android, windows phone 123if (detectOs() === 'ios') &#123; // Do something about ios...&#125; difference创建一个数组，该数组的元素不存在于给定的其它数组中。 类型定义function difference(arr: any[], …args: any[]): any[]; 参数名 说明 arr 源数组 …args 要排除的元素 返回值 目标数组 1difference([3, 2, 1], [4, 2]); // -&gt; [3, 1] dotCase将字符串转换为点式。 类型定义function dotCase(str: string): string; 参数名 说明 str 源字符串 返回值 点式字符串 12dotCase('fooBar'); // -&gt; foo.bardotCase('foo bar'); // -&gt; foo.bar download在浏览器端触发文件下载。 类型定义function download( data: Blob | File | string | any[], name: string, type?: string): void; 参数名 说明 data 下载的数据 name 文件名 type=text/plain 数据类型 1download('test', 'test.txt'); durationFormat简单时间格式化。 类型定义function durationFormat(duration: number, mask?: string): string; 参数名 说明 duration 要格式化的时间，单位为毫秒 mask=’hh:mm:ss’ 时间掩码 返回值 格式化时间 掩码 说明 d 天数 h 小时数 m 分钟数 s 秒数 l 毫秒数 12durationFormat(12345678); // -&gt; '03:25:45'durationFormat(12345678, 'h:m:s:l'); // -&gt; '3:25:45:678' each遍历集合中的所有元素，用每个元素当做参数调用迭代器。 类型定义function each&lt;T&gt;( list: types.List&lt;T&gt;, iterator: types.ListIterator&lt;T, void&gt;, ctx?: any): types.List&lt;T&gt;;function each&lt;T&gt;( object: types.Dictionary&lt;T&gt;, iterator: types.ObjectIterator&lt;T, void&gt;, ctx?: any): types.Collection&lt;T&gt;; 参数名 说明 obj 目标集合 iterator 迭代器 ctx 函数上下文 1each(&#123; a: 1, b: 2 &#125;, function(val, key) &#123;&#125;); easing缓动函数，参考 http://jqueryui.com/ 。 类型定义const easing: { linear(percent: number): number; inQuad(percent: number): number; outQuad(percent: number): number; inOutQuad(percent: number): number; outInQuad(percent: number): number; inCubic(percent: number): number; outCubic(percent: number): number; inQuart(percent: number): number; outQuart(percent: number): number; inQuint(percent: number): number; outQuint(percent: number): number; inExpo(percent: number): number; outExpo(percent: number): number; inSine(percent: number): number; outSine(percent: number): number; inCirc(percent: number): number; outCirc(percent: number): number; inElastic(percent: number, elasticity?: number): number; outElastic(percent: number, elasticity?: number): number; inBack(percent: number): number; outBack(percent: number): number; inOutBack(percent: number): number; outInBack(percent: number): number; inBounce(percent: number): number; outBounce(percent: number): number;}; 参数名 说明 percent 位于 0 到 1 之前的数字 返回值 计算结果 12easing.linear(0.5); // -&gt; 0.5easing.inElastic(0.5, 500); // -&gt; 0.03125 emulateTouch在桌面端浏览器模拟 touch 事件。 类型定义function emulateTouch(el: Element): void; 参数名 说明 el 目标元素 123const el = document.querySelector('#test');emulateTouch(el);el.addEventListener('touchstart', () =&gt; &#123;&#125;, false); endWith检查字符串是否以指定字符串结尾。 类型定义function endWith(str: string, suffix: string): boolean; 参数名 说明 str 目标字符串 suffix 字符串后缀 返回值 如果是后缀，返回真 1endWith('ab', 'b'); // -&gt; true escape转义 HTML 字符串，替换 &amp;，&lt;，&gt;，”，`，和 ‘ 字符。 类型定义function escape(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1escape('You &amp; Me'); // -&gt; 'You &amp;amp; Me' escapeJsStr转义字符串为合法的 JavaScript 字符串字面量。 类型定义function escapeJsStr(str: string): string; http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4 参数名 说明 str 源字符串 返回值 目标字符串 1escapeJsStr('\"\\n'); // -&gt; '\\\\\"\\\\\\\\n' escapeRegExp转义特殊字符用于 RegExp 构造函数。 类型定义function escapeRegExp(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1escapeRegExp('[licia]'); // -&gt; '\\\\[licia\\\\]' evalCss加载 css 到页面中。 类型定义function evalCss(css: string): HTMLStyleElement; 参数名 说明 css css 代码 返回值 style 节点 1evalCss('body&#123;background:#08c&#125;'); evalJs在指定的上下文执行 js 代码。 类型定义function evalJs(js: string, ctx?: any): void; 参数名 说明 js JavaScript 代码 ctx=global 上下文 12evalJs('5+2'); // -&gt; 7evalJs('this.a', &#123; a: 2 &#125;); // -&gt; 2 every检查是否集合中的所有元素都能通过真值检测。 类型定义function every&lt;T&gt;( object: types.List&lt;T&gt;, iterator?: types.ListIterator&lt;T, boolean&gt;, context?: any): boolean;function every&lt;T&gt;( object: types.Dictionary&lt;T&gt;, iterator?: types.ObjectIterator&lt;T, boolean&gt;, context?: any): boolean; 参数名 说明 object 目标集合 iterator 真值检测函数 context 函数上下文 返回值 如果都能通过，返回真 123every([2, 4], function(val) &#123; return val % 2 === 0;&#125;); // -&gt; true extend复制多个对象中的所有属性到目标对象上。 类型定义function extend(destination: any, …sources: any[]): any; 参数名 说明 destination 目标对象 …sources 源对象 返回值 目标对象 1extend(&#123; name: 'RedHood' &#125;, &#123; age: 24 &#125;); // -&gt; &#123;name: 'RedHood', age: 24&#125; extendDeep类似 extend，但会递归进行扩展。 类型定义function extendDeep(destination: any, …sources: any[]): any; 参数名 说明 destination 目标对象 …sources 源对象 返回值 目标对象 123456789101112131415extendDeep( &#123; name: 'RedHood', family: &#123; mother: 'Jane', father: 'Jack' &#125; &#125;, &#123; family: &#123; brother: 'Bruce' &#125; &#125;);// -&gt; &#123;name: 'RedHood', family: &#123;mother: 'Jane', father: 'Jack', brother: 'Bruce'&#125;&#125; extendOwn类似 extend，但只复制自己的属性，不包括原型链上的属性。 类型定义function extendOwn(destination: any, …sources: any[]): any; 参数名 说明 obj 目标对象 …sources 源对象 返回值 目标对象 1extendOwn(&#123; name: 'RedHood' &#125;, &#123; age: 24 &#125;); // -&gt; &#123;name: 'RedHood', age: 24&#125; extractBlockCmts从源码中提取块注释。 类型定义function extractBlockCmts(str: string): string[]; 参数名 说明 str 源码 返回值 块注释 1extractBlockCmts('\\/*licia*\\/'); // -&gt; ['licia'] extractUrls从文本中提取 url。 类型定义function extractUrls(str: string): string[]; 参数名 说明 str 文本 返回值 url 列表 123const str = '[Official site: http://eustia.liriliri.io](http://eustia.liriliri.io)';extractUrls(str); // -&gt; ['http://eustia.liriliri.io'] fetch将 XMLHttpRequest 转换为 promise 的形式。 类型定义namespace fetch { interface IResult { ok: boolean; status: number; statusText: string; url: string; clone(): IResult; text(): Promise&lt;string&gt;; json(): Promise&lt;any&gt;; xml(): Promise&lt;Document | null&gt;; blob(): Promise&lt;Blob&gt;; headers: { keys(): string[]; entries(): Array&lt;string[]&gt;; get(name: string): string; has(name: string): boolean; }; }}function fetch( url: string, options?: { method?: string; timeout?: number; headers?: types.PlainObj&lt;string&gt;; body?: any; }): Promise&lt;fetch.IResult&gt;; 注意：这并不是 fetch 的 pollyfill。 参数名 说明 url 请求地址 options 请求选项 返回值 请求 promise 123456789101112fetch('test.json', &#123; method: 'GET', timeout: 3000, headers: &#123;&#125;, body: ''&#125;) .then(function(res) &#123; return res.json(); &#125;) .then(function(data) &#123; console.log(data); &#125;); fibonacci计算斐波那契数列中某位数字。 类型定义function fibonacci(n: number): number; 参数名 说明 n 序号 n 返回值 斐波那契数列 n 位的数字 12fibonacci(1); // -&gt; 1fibonacci(3); // -&gt; 2 fileSize将字节数转换为易于阅读的形式。 类型定义function fileSize(bytes: number): string; 参数名 说明 bytes 文件字节大小 返回值 易于阅读的文件大小 12345fileSize(5); // -&gt; '5'fileSize(1500); // -&gt; '1.46K'fileSize(1500000); // -&gt; '1.43M'fileSize(1500000000); // -&gt; '1.4G'fileSize(1500000000000); // -&gt; '1.36T' fileType使用幻数检测文件类型。 类型定义function fileType( input: Buffer | ArrayBuffer | Uint8Array): | { ext: string; mime: string; } | undefined; 参数名 说明 input 文件输入 返回值 包括扩展名和 mime 类型的对象 支持的文件类型jpg, png, gif, webp, bmp, gz, zip, rar, pdf, exe 123const fs = require('fs');const file = fs.readFileSync('path/to/file');console.log(fileType(file)); // -&gt; &#123; ext: 'jpg', mime: 'image/jpeg' &#125; fill在数组指定位置填充指定值。 类型定义function fill( list: any[], val: any, start?: number, end?: number): any[]; 参数名 说明 list 源数组 val 填充数组的值 start=0 起始位置 end=arr.length 结束位置，不包括 返回值 目标数组 12fill([1, 2, 3], '*'); // -&gt; ['*', '*', '*']fill([1, 2, 3], '*', 1, 2); // -&gt; [1, '*', 3] filter遍历集合中的每个元素，返回所有通过真值检测的元素组成的数组。 类型定义function filter&lt;T&gt;( list: types.List&lt;T&gt;, iterator: types.ListIterator&lt;T, boolean&gt;, context?: any): T[];function filter&lt;T&gt;( object: types.Dictionary&lt;T&gt;, iterator: types.ObjectIterator&lt;T, boolean&gt;, context?: any): T[]; 参数名 说明 obj 要遍历的集合 predicate 真值检测函数 ctx 函数上下文 返回值 包含所有通过真值检测元素的数组 123filter([1, 2, 3, 4, 5], function(val) &#123; return val % 2 === 0;&#125;); // -&gt; [2, 4] find找到集合中第一个通过真值检测的元素。 类型定义function find&lt;T&gt;( object: types.List&lt;T&gt;, iterator: types.ListIterator&lt;T, boolean&gt;, context?: any): T | undefined;function find&lt;T&gt;( object: types.Dictionary&lt;T&gt;, iterator: types.ObjectIterator&lt;T, boolean&gt;, context?: any): T | undefined; 参数名 说明 object 目标集合 iterator 真值检测函数 context 函数上下文 返回值 第一个通过的元素 123456789101112131415find( [ &#123; name: 'john', age: 24 &#125;, &#123; name: 'jane', age: 23 &#125; ], function(val) &#123; return val.age === 23; &#125;); // -&gt; &#123;name: 'jane', age: 23&#125; findIdx返回第一个通过真值检测元素在数组中的位置。 类型定义function findIdx(arr: any[], predicate: types.AnyFn): number; 参数名 说明 arr 目标集合 predicate 真值检测函数 返回值 第一个符合条件元素的位置 123456789101112131415findIdx( [ &#123; name: 'john', age: 24 &#125;, &#123; name: 'jane', age: 23 &#125; ], function(val) &#123; return val.age === 23; &#125;); // -&gt; 1 findKey返回对象中第一个通过真值检测的属性键名。 类型定义function findKey( obj: any, predicate: types.AnyFn, ctx?: any): string | void; 参数名 说明 obj 目标对象 predicate 真值检测函数 ctx 函数上下文 返回值 符合条件的键名 123findKey(&#123; a: 1, b: 2 &#125;, function(val) &#123; return val === 1;&#125;); // -&gt; a findLastIdx同 findIdx，只是查找顺序改为从后往前。 类型定义function findLastIdx(arr: any[], predicate: types.AnyFn): number; 参数名 说明 arr 目标集合 predicate 真值检测函数 返回值 从后往前，第一个符合条件元素的位置 12345678910111213141516171819findLastIdx( [ &#123; name: 'john', age: 24 &#125;, &#123; name: 'jane', age: 23 &#125;, &#123; name: 'kitty', age: 24 &#125; ], function(val) &#123; return val.age === 24; &#125;); // -&gt; 2 flatten递归拍平数组。 类型定义function flatten(arr: any[]): any[]; 参数名 说明 arr 源数组 返回值 目标数组 1flatten(['a', ['b', ['c']], 'd', ['e']]); // -&gt; ['a', 'b', 'c', 'd', 'e'] fnArgs检验函数参数。 类型定义function fnArgs(types: string[], args: any): void; 参数名 说明 types 参数类型 args Argument 对象 如果检验失败，抛出异常。 12345678910function test(a, b, c) &#123; fnArgs(['number|string', '?Function', '...number'], arguments); // Do something.&#125;test(15);test('test', () =&gt; &#123;&#125;);test('test', () =&gt; &#123;&#125;, 5);test(); // Throw errortest('test', 'test'); // Throw errortest('test', () =&gt; &#123;&#125;, 5, 'test'); // Throw error fnParams获取函数的参数名列表。 类型定义function fnParams(fn: types.AnyFn | string): string[]; 参数名 说明 fn 目标函数 返回值 参数名 1fnParams(function(a, b) &#123;&#125;); // -&gt; ['a', 'b'] fnv1a简单 FNV-1a 哈希算法实现。 类型定义function fnv1a(str: string): number; 参数名 说明 str 目标字符串 返回值 哈希结果 1fnv1a('test'); // -&gt; 2949673445 format使用类似于 printf 的方式来格式化字符串。 类型定义function format(str: string, …values: any[]): string; 参数名 说明 str 源字符串 …values 替换占位符的值 返回值 目标字符串 格式占位符 占位符 说明 %s 字符串 %d, %i 整数 %f 浮点数 %o 对象 1format('%s_%s', 'foo', 'bar'); // -&gt; 'foo_bar' fraction转换数字为分数形式。 类型定义function fraction(num: number): string; 参数名 说明 num 数字 返回值 对应的分数 1fraction(1.2); // -&gt; '6/5' freezeObject.freeze 的快捷方式。 类型定义function freeze&lt;T&gt;(obj: T): T; 如果不支持 Object.freeze，使用 Object.defineProperties 进行模拟。 参数名 说明 obj 目标对象 返回值 目标对象 1234const a = &#123; b: 1 &#125;;freeze(a);a.b = 2;console.log(a); // -&gt; &#123;b: 1&#125; freezeDeep递归进行 Object.freeze。 类型定义function freezeDeep&lt;T&gt;(obj: T): T; 参数名 说明 obj 目标对象 返回值 目标对象 1234const a = &#123; b: &#123; c: 1 &#125; &#125;;freezeDeep(a);a.b.c = 2;console.log(a); // -&gt; &#123;b: &#123;c: 1&#125;&#125; fsnode.js fs 模块的 promise 版本。 类型定义const fs: { readFile(path: string, encoding: string): Promise&lt;string&gt;; readFile(path: string): Promise&lt;Buffer&gt;; exists(path: string): Promise&lt;boolean&gt;; unlink(path: string): Promise&lt;void&gt;; writeFile(path: string, data: string, options?: string): Promise&lt;void&gt;; writeFile(path: string, data: Buffer): Promise&lt;void&gt;; readdir(path: string): Promise&lt;string[]&gt;; rmdir(path: string): Promise&lt;void&gt;; [key: string]: any;}; 1234567fs.readFile('test.js') .then(function(data) &#123; // Do something &#125;) .catch(function(err) &#123; // Handle errors &#125;); fullscreen全屏接口封装。 类型定义namespace fullscreen { interface IFullscreen extends Emitter { request(el?: Element): void; exit(): void; toggle(el?: Element): void; isActive(): boolean; getEl(): Element | null; isEnabled(): boolean; }}const fullscreen: fullscreen.IFullscreen; request进入全屏。 参数名 说明 el Element 全屏元素 exit退出全屏。 toggle切换全屏。 参数名 说明 el 全屏元素 isActive是否全屏。 getEl获取全屏元素。 isEnabled是否可以进入全屏。 1234fullscreen.request();fullscreen.isActive(); // -&gt; false, not a synchronous apifullscreen.on('error', () =&gt; &#123;&#125;);fullscreen.on('change', () =&gt; &#123;&#125;); fuzzySearch模糊搜索。 类型定义function fuzzySearch( needle: string, haystack: any[], options?: { caseSensitive?: boolean; key?: string | string[]; }): any[]; 参数名 说明 needle 搜索字符串 haystacks 搜索集合 options 搜索选项 可用选项： 参数名 说明 caseSensitive=false 是否大小写敏感 key 搜索项是对象时的字符串路径 123456789101112131415fuzzySearch('lic', ['licia', 'll', 'lic']); // -&gt; ['lic', 'licia']fuzzySearch( 'alpha-test', [ &#123; name: 'alpha-test-1' &#125;, &#123; name: 'beta-test' &#125; ], &#123; key: 'name' &#125;); // -&gt; [&#123; name: 'alpha-test-1' &#125;] gcd使用欧几里德算法求最大公约数。 类型定义function gcd(a: number, b: number): number; 参数名 说明 a 要计算的数字 b 要计算的数字 返回值 最大公约数 1gcd(121, 44); // -&gt; 11 getPort获取有效的 TCP 端口。 类型定义function getPort( port?: number | number[], host?: string): Promise&lt;number&gt;; 参数名 说明 port 首选端口 host 地址 返回值 有效端口 如果首选端口无法使用，将会返回一个有效的随机端口。 123getPort([3000, 3001], '127.0.0.1').then(port =&gt; &#123; console.log(port);&#125;); getProto获取对象的原型。 类型定义function getProto(obj: any): any; 参数名 说明 obj 目标对象 返回值 对象原型，如果不存在，返回 null 12const a = &#123;&#125;;getProto(Object.create(a)); // -&gt; a getUrlParam获取 url 参数值。 类型定义function getUrlParam( name: string, url?: string): string | undefined; 参数名 说明 name 参数名 url=location 目标 url 返回值 参数值 1getUrlParam('test', 'http://example.com/?test=true'); // -&gt; 'true' golangify像 Go 一样处理错误。 类型定义function golangify&lt;T, U = Error&gt;( fn: (…args: any[]) =&gt; Promise&lt;T&gt;): (…args: any[]) =&gt; Promise&lt;[T | undefined, U | null]&gt;;function golangify&lt;T, U = Error&gt;( p: Promise&lt;T&gt;): Promise&lt;[T | undefined, U | null]&gt;; 参数名 说明 fn 返回 Promise 的函数 返回值 同上，但 Promise 的结果形式为 [result, error] 参数名 说明 p 要转换的 Promise 返回值 目标 Promise，结果形式为 [result, error] 1234567891011(async () =&gt; &#123; let fnA = golangify(async () =&gt; &#123; throw Error('err'); &#125;); await fnA(); // -&gt; [undefined, Error] let fnB = golangify(async num =&gt; num * 2); await fnB(2); // -&gt; [4, null] await golangify(Promise.reject(Error('err'))); // -&gt; [undefined, Error] await golangify(Promise.resolve(4)); // -&gt; [4, null]&#125;)(); h创建 HTML 元素。 类型定义function h( tag: string, attrs?: types.PlainObj&lt;any&gt;, …child: Array&lt;string | HTMLElement&gt;): HTMLElement; 参数名 说明 tag 标签名 attrs 属性 …child 子节点 返回值 目标元素 123456789const el = h( 'div#test.title', &#123; onclick: function() &#123;&#125;, title: 'test' &#125;, 'inner text');document.body.appendChild(el); has检查属性是否是对象自身的属性（原型链上的不算）。 类型定义function has(obj: {}, key: string): boolean; 参数名 说明 obj 目标对象 key 键名 返回值 如果是自身的属性，返回真 1has(&#123; one: 1 &#125;, 'one'); // -&gt; true heapSort堆排序实现。 类型定义function heapSort(arr: any[], cmp?: types.AnyFn): any[]; 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1heapSort([2, 1]); // -&gt; [1, 2] hexhex 编解码。 类型定义const hex: { encode(bytes: number[]): string; decode(str: string): number[];}; encode将字节数组编码为 hex 字符串。 参数名 说明 bytes 字节数组 返回值 hex 编码的字符串 decode将 hex 字符串解码为字节数组。 参数名 说明 str hex 编码的字符串 返回值 字节数组 12hex.encode([168, 174, 155, 255]); // -&gt; 'a8ae9bff'hex.decode('a8ae9bff'); // -&gt; [168, 174, 155, 255] highlight高亮代码。 类型定义function highlight( str: string, lang?: string, style?: { comment?: string; string?: string; number?: string; keyword?: string; operator?: string; }): string; 参数名 说明 str 代码字符串 lang=js 语言，js，html 或者 css style 高亮样式 返回值 高亮后的 html 代码字符串 可设置样式： comment，string，number，keyword，operator 123highlight('const a = 5;', 'js', &#123; keyword: 'color:#569cd6;'&#125;); // -&gt; '&lt;span class=\"keyword\" style=\"color:#569cd6;\"&gt;const&lt;/span&gt; a &lt;span class=\"operator\" style=\"color:#994500;\"&gt;=&lt;/span&gt; &lt;span class=\"number\" style=\"color:#0086b3;\"&gt;5&lt;/span&gt;;' hookFn监听，修改函数参数和结果。 类型定义function hookFn&lt;T&gt;( fn: T, options: { before?: types.AnyFn; after?: types.AnyFn; error?: types.AnyFn; }): T; 参数名 说明 fn 要监听修改的函数 options 监听选项 返回值 包装后的函数 可用选项： 参数名 说明 before 参数处理函数 after 结果处理函数 error 异常处理函数 1234567891011121314151617181920let sum = function(a, b) &#123; if (a &gt; 100) &#123; throw Error('a is bigger than 100'); &#125; return a + b;&#125;;let totalSum = 0;sum = hookFn(sum, &#123; before(a, b) &#123; return [+a, +b]; &#125;, after(result) &#123; totalSum += result; return totalSum; &#125;, error() &#123; return totalSum; &#125;&#125;);sum('2', '5'); // -&gt; 7 hotkey监听键盘触发对应的事件。 类型定义const hotkey: { on(key: string, listener: types.AnyFn): void; off(key: string, listener: types.AnyFn): void;}; on注册键盘按键监听器。 参数名 说明 key 按键 listener 监听器 off注销监听器。 123456hotkey.on('k', function() &#123; console.log('k is pressed');&#125;);function keyDown() &#123;&#125;hotkey.on('shift+a, shift+b', keyDown);hotkey.off('shift+a', keyDown); hslToRgb将 hsl 格式的颜色值转换为 rgb 格式。 类型定义function hslToRgb(hsl: number[]): number[]; 参数名 说明 hsl hsl 值 返回值 rgb 值 1hslToRgb([165, 59, 50, 0.8]); // -&gt; [52, 203, 165, 0.8] htmlHTML 解析器。 类型定义const html: { parse(html: string): any[]; stringify(tree: any[]): string;}; parse将 HTML 字符串转换为 js 对象。 参数名 说明 html HTML 字符串 返回值 js 对象 stringify将 js 对象序列化成 HTML 字符串。 参数名 说明 tree 要序列化的对象 返回值 HTML 字符串 123const tree = html.parse('&lt;div id=\"name\"&gt;licia&lt;/div&gt;');// -&gt; [&#123;tag: 'div', attrs: &#123;id: 'name'&#125;, content: ['licia']&#125;]html.stringify(tree); identity返回传入的第一个参数。 类型定义function identity&lt;T&gt;(val: T): T; 参数名 说明 val 任何值 返回值 第一个参数 1identity('a'); // -&gt; 'a' idxOf返回指定值第一次在数组中出现的位置。 类型定义function idxOf(arr: any[], val: any, fromIdx?: number): number; 参数名 说明 arr 目标数组 val 要查找的值 fromIdx=0 查找起始位置 返回值 第一次出现的位置，如果没有，返回 -1 1idxOf([1, 2, 1, 2], 2, 2); // -&gt; 3 indent对文本的每一行进行缩进处理。 类型定义function indent( str: string, char?: string, len?: number): string; 参数名 说明 str 源字符串 char 缩进字符 len 缩进长度 返回值 目标字符串 1indent('foo\\nbar', ' ', 4); // -&gt; ' foo\\n bar' inherits使构造函数继承另一个构造函数原型链上的方法。 类型定义function inherits( Class: types.AnyFn, SuperClass: types.AnyFn): void; 参数名 说明 Class 子类 SuperClass 父类 1234567891011121314function People(name) &#123; this._name = name;&#125;People.prototype = &#123; getName: function() &#123; return this._name; &#125;&#125;;function Student(name) &#123; this._name = name;&#125;inherits(Student, People);const s = new Student('RedHood');s.getName(); // -&gt; 'RedHood' iniini 文件解析器。 类型定义const ini: { parse(ini: string): any; stringify( obj: any, options?: { section?: string; whitespace: boolean; } ): string;}; parse将 ini 文件转换为 js 对象。 参数名 说明 ini ini 文件 返回值 js 对象 stringify将 js 对象序列化成 ini 文件格式。 参数名 说明 obj 要序列化的对象 options 序列化选项 返回值 ini 文件 选项： 参数名 说明 section 顶部名称 whitespace=false 是否在 = 周围添加空格 1234567891011const config = ini.parse(`; This is a commentlibrary = licia[user.info]name = surunzialias[] = redhoodsualias[] = red`); // -&gt; &#123;library: 'licia', user: &#123;info: &#123;name: 'surunzi', alias: ['redhoodsu', 'red']&#125;&#125;&#125;ini.stringify(config); insertionSort插入排序实现。 类型定义function insertionSort(arr: any[], cmp?: types.AnyFn): any[]; 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1insertionSort([2, 1]); // -&gt; [1, 2] intersect计算所有数组的交集。 类型定义function intersect(…arr: Array&lt;any[]&gt;): any[]; 参数名 说明 …arr 源数组 返回值 交集 1intersect([1, 2, 3, 4], [2, 1, 10], [2, 1]); // -&gt; [1, 2] intersectRange计算两个区间的交集。 类型定义namespace intersectRange { interface IRange { start: number; end: number; }}function intersectRange( a: intersectRange.IRange, b: intersectRange.IRange): intersectRange.IRange | void; 参数名 说明 a 区间 a b 区间 b 返回值 如果存在区间交集，返回它 1234intersectRange(&#123; start: 0, end: 12 &#125;, &#123; start: 11, end: 13 &#125;);// -&gt; &#123;start: 11, end: 12&#125;intersectRange(&#123; start: 0, end: 5 &#125;, &#123; start: 6, end: 7 &#125;);// -&gt; undefined invariantFacebook 的 invariant 模块。 类型定义function invariant( condition: boolean, format?: string, a?: string, b?: string, c?: string, d?: string, e?: string, f?: string): void; 相关文档 1234invariant(true, 'This will not throw');// No errorsinvariant(false, 'This will throw an error with this message');// Error: Invariant Violation: This will throw an error with this message invert生成一个新对象，该对象的键名和键值进行调换。 类型定义function invert(obj: any): any; 参数名 说明 obj 源对象 返回值 目标对象 如果对象存在重复的键值，后面的值会覆盖前面的值。 1invert(&#123; a: 'b', c: 'd', e: 'f' &#125;); // -&gt; &#123;b: 'a', d: 'c', f: 'e'&#125; isAbsoluteUrl检查 url 是否是绝对地址。 类型定义function isAbsoluteUrl(url: string): boolean; 参数名 说明 url 目标 url 返回值 如果是绝对地址，返回真 123isAbsoluteUrl('http://www.surunzi.com'); // -&gt; trueisAbsoluteUrl('//www.surunzi.com'); // -&gt; falseisAbsoluteUrl('surunzi.com'); // -&gt; false isArgs检查值是否是参数类型。 类型定义function isArgs(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是参数类型，返回真 12345isArgs( (function() &#123; return arguments; &#125;)()); // -&gt; true isArr检查值是否是数组类型。 类型定义function isArr(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是数组类型，返回真 12isArr([]); // -&gt; trueisArr(&#123;&#125;); // -&gt; false isArrBuffer检查值是否是 ArrayBuffer 类型。 类型定义function isArrBuffer(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 ArrayBuffer 类型，返回真 1isArrBuffer(new ArrayBuffer(8)); // -&gt; true isArrLike检查值是否是类数组对象。 类型定义function isArrLike(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是类数组对象，返回真 对于函数，返回假。 123isArrLike('test'); // -&gt; trueisArrLike(document.body.children); // -&gt; true;isArrLike([1, 2, 3]); // -&gt; true isAsyncFn检查值是否是 Async 函数。 类型定义function isAsyncFn(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Async 函数，返回真 123isAsyncFn(function*() &#123;&#125;); // -&gt; falseisAsyncFn(function() &#123;&#125;); // -&gt; falseisAsyncFn(async function() &#123;&#125;); // -&gt; true isBlob检查值是否是 Blob 类型。 类型定义function isBlob(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Blob 类型，返回真 12isBlob(new Blob([])); // -&gt; true;isBlob([]); // -&gt; false isBool检查值是否是布尔类型。 类型定义function isBool(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是布尔类型，返回真 123isBool(true); // -&gt; trueisBool(false); // -&gt; trueisBool(1); // -&gt; false isBrowser检测是否运行于浏览器环境。 类型定义const isBrowser: boolean; 1console.log(isBrowser); // -&gt; true if running in a browser isBuffer检查值是否是 Buffer 类型。 类型定义function isBuffer(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Buffer 类型，返回真 1isBuffer(new Buffer(4)); // -&gt; true isClose检查两个数字是否近似相等。 类型定义function isClose( a: number, b: number, relTol?: number, absTol?: number): boolean; abs(a-b) &lt;= max(relTol * max(abs(a), abs(b)), absTol) 参数名 说明 a 要比较的数字 b 要比较的数字 relTol=1e-9 相对误差 absTol=0 绝对误差 返回值 如果近似相等，返回真 1234isClose(1, 1.0000000001); // -&gt; trueisClose(1, 2); // -&gt; falseisClose(1, 1.2, 0.3); // -&gt; trueisClose(1, 1.2, 0.1, 0.3); // -&gt; true isCyclic检查值是否存在循环引用。 类型定义function isCyclic(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果存在循环引用，返回真 1234isCyclic(&#123;&#125;); // -&gt; falseconst obj = &#123; a: 1 &#125;;obj.b = obj;isCyclic(obj); // -&gt; true isDarkMode检测是否暗黑模式。 类型定义function isDarkMode(): boolean; 1console.log(isDarkMode()); // true if dark mode isDataUrl检查字符串是否是有效的 Data Url。 类型定义function isDataUrl(str: string): boolean; 参数名 说明 str 要检查的字符串 返回值 如果是有效的 Data Url，返回真 12isDataUrl('http://eustia.liriliri.io'); // -&gt; falseisDataUrl('data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D'); // -&gt; true isDate检查值是否是 Date 类型。 类型定义function isDate(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Date 类型，返回真 1isDate(new Date()); // -&gt; true isDir检查路径是否是文件夹。 类型定义function isDir(path: string): Promise&lt;boolean&gt;; 参数名 说明 path 要检查的路径 返回值 如果是文件夹，返回真 1isDir('/foo/bar'); isEl检查值是否是 DOM 元素。 类型定义function isEl(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 DOM 元素，返回真 1isEl(document.body); // -&gt; true isEmail简单检查值是否是合法的邮件地址。 类型定义function isEmail(val: string): boolean; 参数名 说明 val 要检查的值 返回值 如果是合法的邮件地址，返回真 1isEmail('surunzi@foxmail.com'); // -&gt; true isEmpty检查值是否是空对象或空数组。 类型定义function isEmpty(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果为空，返回真 123isEmpty([]); // -&gt; trueisEmpty(&#123;&#125;); // -&gt; trueisEmpty(''); // -&gt; true isEqual对两个对象进行深度比较，如果相等，返回真。 类型定义function isEqual(val: any, other: any): boolean; 参数名 说明 val 要比较的对象 other 要比较的对象 返回值 如果相等，返回真 1isEqual([1, 2, 3], [1, 2, 3]); // -&gt; true isErr检查值是否是 Error 类型。 类型定义function isErr(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Error 类型，返回真 1isErr(new Error()); // -&gt; true isEven检查数字是否是偶数。 类型定义function isEven(num: number): boolean; 参数名 说明 num 要检查的数字 返回值 如果是偶数，返回真 123isEven(0); // -&gt; trueisEven(1); // -&gt; falseisEven(2); // -&gt; true isFile检查值是否是 File 类型。 类型定义function isFile(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 File 类型，返回真 1isFile(new File(['test'], 'test.txt', &#123; type: 'text/plain' &#125;)); // -&gt; true isFinite检查值是否是有限数字。 类型定义function isFinite(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是有限数字，返回真 12isFinite(3); // -&gt; trueisFinite(Infinity); // -&gt; false isFn检查值是否是函数。 类型定义function isFn(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是函数，返回真 Generator 函数返回真。 123isFn(function() &#123;&#125;); // -&gt; trueisFn(function*() &#123;&#125;); // -&gt; trueisFn(async function() &#123;&#125;); // -&gt; true isFullWidth检查值是否是全角字符。 类型定义function isFullWidth(codePoint: number): boolean; 参数名 说明 codePoint Unicode 码点 返回值 如果字符是全角，返回真 1234isFullWidth('a'.codePointAt(0)); // -&gt; falseisFullWidth(','.codePointAt(0)); // -&gt; falseisFullWidth('我'.codePointAt(0)); // -&gt; trueisFullWidth('，'.codePointAt(0)); // -&gt; true isGeneratorFn检查值是否是 Generator 函数。 类型定义function isGeneratorFn(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Generator 函数，返回真 12isGeneratorFn(function*() &#123;&#125;); // -&gt; trueisGeneratorFn(function() &#123;&#125;); // -&gt; false isHidden检查元素是否隐藏。 类型定义function isHidden( el: Element, options?: { display?: boolean; visibility?: boolean; opacity?: boolean; size?: boolean; viewport?: boolean; overflow?: boolean; }): boolean; 参数名 说明 el 目标元素 options 检查选项 返回值 如果元素隐藏，返回真 可用选项： 参数名 说明 display=true 检查是否显示 visibility=false 检查 visibility css 属性 opacity=false 检查 opacity css 属性 size=false 检查宽高 viewport=false 检查是否在可视区域 overflow=false 检查是否因 overflow 隐藏 1isHidden(document.createElement('div')); // -&gt; true isInt检查值是否是整数。 类型定义function isInt(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是整数，返回真 123isInt(5); // -&gt; trueisInt(5.1); // -&gt; falseisInt(&#123;&#125;); // -&gt; false isIp检查值是否是 IP 地址。 类型定义namespace isIp { function v4(str: string): boolean; function v6(str: string): boolean;}function isIp(str: string): boolean; 参数名 说明 str 要检查的字符串 返回值 如果是 IP 地址，返回真 v4检查值是否是 IPv4 地址。 v6检查值是否是 IPv6 地址。 12345isIp('192.168.191.1'); // -&gt; trueisIp('1:2:3:4:5:6:7:8'); // -&gt; trueisIp('test'); // -&gt; falseisIp.v4('192.168.191.1'); // -&gt; trueisIp.v6('1:2:3:4:5:6:7:8'); // -&gt; true isJson检查值是否是有效的 JSON。 类型定义function isJson(val: string): boolean; 该模块使用 JSON.parse() 和 try... catch 进行检测。 参数名 说明 val JSON 字符串 返回值 如果是有效的 JSON，返回真 12isJson('&#123;\"a\": 5&#125;'); // -&gt; trueisJson(\"&#123;'a': 5&#125;\"); // -&gt; false isLeapYear检查年份是否是闰年。 类型定义function isLeapYear(year: number): boolean; 参数名 说明 year 要检查的年份 返回值 如果是闰年，返回真 12isLeapYear(2000); // -&gt; trueisLeapYear(2002); // -&gt; false isMap检查值是否是 Map 对象。 类型定义function isMap(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Map 类型，返回真 12isMap(new Map()); // -&gt; trueisMap(new WeakMap()); // -&gt; false isMatch检查对象所有键名和键值是否在指定的对象中。 类型定义function isMatch(obj: any, src: any): boolean; 参数名 说明 obj 目标对象 src 进行匹配的对象 返回值 如果匹配，返回真 1isMatch(&#123; a: 1, b: 2 &#125;, &#123; a: 1 &#125;); // -&gt; true isMiniProgram检测是否运行于微信小程序环境中。 类型定义const isMiniProgram: boolean; 1console.log(isMiniProgram); // -&gt; true if running in mini program. isMobile使用 ua 检测是否运行于移动端浏览器。 类型定义function isMobile(ua?: string): boolean; 参数名 说明 ua=navigator.userAgent 浏览器用户代理 返回值 如果是移动端浏览器，返回真 1isMobile(navigator.userAgent); isNaN检测值是否是 NaN。 类型定义function isNaN(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 NaN，返回真 跟全局 isNaN 不同的是，Undefined 不是 NaN。 12isNaN(0); // -&gt; falseisNaN(NaN); // -&gt; true isNative检查值是否是原生函数。 类型定义function isNative(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是原生函数，返回真 12isNative(function() &#123;&#125;); // -&gt; falseisNative(Math.min); // -&gt; true isNil检查值是否是 null 或 undefined，等价于 value == null。 类型定义function isNil(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 null 或 undefined，返回真 123456isNil(null); // -&gt; trueisNil(void 0); // -&gt; trueisNil(undefined); // -&gt; trueisNil(false); // -&gt; falseisNil(0); // -&gt; falseisNil([]); // -&gt; false isNode检测是否运行于 node 环境中。 类型定义const isNode: boolean; 1console.log(isNode); // -&gt; true if running in node isNull检查值是否是 Null 类型。 类型定义function isNull(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Null 类型，返回真 1isNull(null); // -&gt; true isNum检测值是否是数字类型。 类型定义function isNum(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是数字，返回真 123isNum(5); // -&gt; trueisNum(5.1); // -&gt; trueisNum(&#123;&#125;); // -&gt; false isNumeric检查值是否是数字，包括数字字符串。 类型定义function isNumeric(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是数字，返回真 1234567isNumeric(1); // -&gt; trueisNumeric('1'); // -&gt; trueisNumeric(Number.MAX_VALUE); // -&gt; trueisNumeric(0xff); // -&gt; trueisNumeric(''); // -&gt; falseisNumeric('1.1.1'); // -&gt; falseisNumeric(NaN); // -&gt; false isObj检查值是否是对象。 类型定义function isObj(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是对象，返回真 标准定义 12isObj(&#123;&#125;); // -&gt; trueisObj([]); // -&gt; true isOdd检查数字是否是奇数。 类型定义function isOdd(num: number): boolean; 参数名 说明 num 要检查的数字 返回值 如果是奇数，返回真 123isOdd(0); // -&gt; falseisOdd(1); // -&gt; trueisOdd(2); // -&gt; false isPlainObj检查值是否是用 Object 构造函数创建的对象。 类型定义function isPlainObj(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 plain object，返回真 123isPlainObj(&#123;&#125;); // -&gt; trueisPlainObj([]); // -&gt; falseisPlainObj(function() &#123;&#125;); // -&gt; false isPortFree检查 TCP 端口是否可用。 类型定义function isPortFree( port: number, host?: string): Promise&lt;boolean&gt;; 参数名 说明 port TCP 端口 host 地址 返回值 如果端口可用，返回真 123isPortFree(3000).then(isFree =&gt; &#123; // Do something.&#125;); isPrime检查整数是否是质数。 类型定义function isPrime(num: number): boolean; 参数名 说明 num 要检查的数字 返回值 如果是质数，返回真 12isPrime(11); // -&gt; trueisPrime(8); // -&gt; false isPrimitive检测值是否是字符串，数字，布尔值或 null。 类型定义function isPrimitive(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是原始类型，返回真 123isPrimitive(5); // -&gt; trueisPrimitive('abc'); // -&gt; trueisPrimitive(false); // -&gt; true isPromise检查值是否是类 promise 对象。 类型定义function isPromise(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是类 promise 对象，返回真 12isPromise(new Promise(function() &#123;&#125;)); // -&gt; trueisPromise(&#123;&#125;); // -&gt; false isRegExp检查值是否是正则类型。 类型定义function isRegExp(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是正则类型，返回真 1isRegExp(/a/); // -&gt; true isRelative检查路径是否是相对路径。 类型定义function isRelative(path: string): boolean; 参数名 说明 path 要检查的路径 返回值 如果是相对路径，返回真 1isRelative('README.md'); // -&gt; true isRetina判断是否运行在 retina 屏幕的设备上。 类型定义const isRetina: boolean; 1console.log(isRetina); // -&gt; true if high DPR isRunning检查进程是否运行中。 类型定义function isRunning(pid: number): boolean; 参数名 说明 pid 进程 id 返回值 如果进程运行中，返回真 1isRunning(123456); // true if running isSet检查值是否是 Set 类型。 类型定义function isSet(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Set 类型，返回真 12isSet(new Set()); // -&gt; trueisSet(new WeakSet()); // -&gt; false isSorted检查数组是否有序。 类型定义function isSorted(arr: any[], cmp?: types.AnyFn): boolean; 参数名 说明 arr 目标数组 cmp 比较器 返回值 如果数组有序，返回真 12isSorted([1, 2, 3]); // -&gt; trueisSorted([3, 2, 1]); // -&gt; false isStr检查值是否是字符串。 类型定义function isStr(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是字符串，返回真 1isStr('licia'); // -&gt; true isStream检查值是否是 Node.js Stream 类型。 类型定义function isStream(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Node.js Stream 类型，返回真 123const stream = require('stream');isStream(new stream.Stream()); // -&gt; true isSymbol检查值是否是 Symbol 类型。 类型定义function isSymbol(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 Symbol 类型，返回真 1isSymbol(Symbol('test')); // -&gt; true isTypedArr检查值是否 TypedArray 类型。 类型定义function isTypedArr(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果值是 TypedArray 类型，返回真 12isTypedArr([]); // -&gt; falseisTypedArr(new Uint8Array(8)); // -&gt; true isUndef检查值是否是 undefined。 类型定义function isUndef(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 undefined，返回真 12isUndef(void 0); // -&gt; trueisUndef(null); // -&gt; false isUrl简单检查值是否是有效的 url 地址。 类型定义function isUrl(val: string): boolean; 参数名 说明 val 要检查的值 返回值 如果是有效的 url 地址，返回真 1isUrl('http://www.example.com?foo=bar&amp;param=test'); // -&gt; true isWeakMap检查值是否是 WeakMap 类型。 类型定义function isWeakMap(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 WeakMap 类型，返回真 12isWeakMap(new Map()); // -&gt; falseisWeakMap(new WeakMap()); // -&gt; true isWeakSet检查值是否是 WeakSet 类型。 类型定义function isWeakSet(val: any): boolean; 参数名 说明 val 要检查的值 返回值 如果是 WeakSet 类型，返回真 12isWeakSet(new Set()); // -&gt; falseisWeakSet(new WeakSet()); // -&gt; true isWindows检测是否运行在 windows 操作系统上。 类型定义const isWindows: boolean; 1console.log(isWindows); // -&gt; true if running on windows jsonClone使用 JSON parse 和 stringify 方法对指定对象进行复制。 类型定义function jsonClone&lt;T&gt;(val: T): T; 参数名 说明 val 要克隆的值 返回值 克隆值 1jsonClone(&#123; name: 'licia' &#125;); // -&gt; &#123; name: 'licia' &#125; jsonp简单 jsonp 实现。 类型定义function jsonp(options: { url: string; data?: any; success?: types.AnyFn; param?: string; name?: string; error?: types.AnyFn; complete?: types.AnyFn; timeout?: number;}): void; 参数名 说明 options jsonp 选项 可用选项： 参数名 说明 url 请求地址 data 请求数据 success 成功回调 param=callback 回调参数名 name 回调函数名 error 失败回调 complete 结束回调 timeout 请求超时 1234567jsonp(&#123; url: 'http://example.com', data: &#123; test: 'true' &#125;, success: function(data) &#123; // ... &#125;&#125;); kebabCase将字符串转换为短横线式。 类型定义function kebabCase(str: string): string; 参数名 说明 str 源字符串 返回值 短横线式字符串 1234kebabCase('fooBar'); // -&gt; foo-barkebabCase('foo bar'); // -&gt; foo-barkebabCase('foo_bar'); // -&gt; foo-barkebabCase('foo.bar'); // -&gt; foo-bar keyCode键码键名转换。 类型定义function keyCode(name: string): number;function keyCode(code: number): string; 获取键码对应的键名。 参数名 说明 code 键码 返回值 对应的键名 获取键名对应的键码。 参数名 说明 name 键名 返回值 对应的键码 12keyCode(13); // -&gt; 'enter'keyCode('enter'); // -&gt; 13 keys返回包含对象自身可遍历所有键名的数组。 类型定义function keys(obj: any): string[]; 参数名 说明 obj 目标对象 返回值 所有键名 1keys(&#123; a: 1 &#125;); // -&gt; ['a'] kill杀死进程。 类型定义function kill(pid: number): void; 参数名 说明 pid 进程 ID 1kill(9420); last获取数组的最后一个元素。 类型定义function last(arr: any[]): any; 参数名 说明 arr 目标数组 返回值 数组的最后一个元素 1last([1, 2]); // -&gt; 2 lazyImport模块懒加载，底层使用 Proxy。 类型定义function lazyImport&lt;T&gt;( importFn: (moduleId: string) =&gt; T, dirname?: string): (moduleId: string) =&gt; T; 参数名 说明 importFn 实际引入模块的方法 dirname 当前脚本所在目录 返回值 用于引入模块的新方法 12345const r = lazyImport(require);const _ = r('underscore');_.isNumber(5); lazyRequire模块懒加载。 类型定义function lazyRequire&lt;T&gt;( requireFn: (moduleId: string) =&gt; T): (moduleId: string) =&gt; T; 123456const r = lazyRequire(require);const _ = r('underscore');// underscore is required only when _ is called._().isNumber(5); levenshtein计算字符串编辑距离，使用 levenshtein 算法。 类型定义function levenshtein(a: string, b: string): number; 参数名 说明 a 字符串 a b 字符串 b 返回值 a 和 b 的字符串编辑距离 1levenshtein('cat', 'cake'); // -&gt; 2 linkify将文本中的 url 地址转换为超链接。 类型定义function linkify(str: string, hyperlink?: types.AnyFn): string; 参数名 说明 str 源字符串 hyperlink 转换超链接函数 返回值 目标字符串 12345const str = 'Official site: http://eustia.liriliri.io';linkify(str); // -&gt; 'Official site: &lt;a href=\"http://eustia.liriliri.io\"&gt;http://eustia.liriliri.io&lt;/a&gt;'linkify(str, function(url) &#123; return '&lt;a href=\"' + url + '\" target=\"_blank\"&gt;' + url + '&lt;/a&gt;';&#125;); loadCss往页面插入样式链接。 类型定义function loadCss(src: string, cb?: types.AnyFn): void; 参数名 说明 src 样式文件地址 cb 加载完回调 123loadCss('style.css', function(isLoaded) &#123; // Do something...&#125;); loadImg加载指定地址的图片。 类型定义function loadImg(src: string, cb?: types.AnyFn): void; 参数名 说明 src 图片地址 cb 加载完回调 123loadImg('http://eustia.liriliri.io/img.jpg', function(err, img) &#123; console.log(img.width, img.height);&#125;); loadJs往页面插入脚本链接。 类型定义function loadJs(src: string, cb?: types.AnyFn): void; 参数名 说明 src 脚本地址 cb 加载完回调 123loadJs('main.js', function(isLoaded) &#123; // Do something...&#125;); longest获取数组中最长的一项。 类型定义function longest(arr: string[]): string; 参数名 说明 arr 目标数组 返回值 最长的一项 1longest(['a', 'abcde', 'abc']); // -&gt; 'abcde' lowerCase转换字符串为小写。 类型定义function lowerCase(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1lowerCase('TEST'); // -&gt; 'test' lpad对字符串进行左填充。 类型定义function lpad(str: string, len: number, chars?: string): string; 参数名 说明 str 源字符串 len 填充长度 chars 填充字符串 返回值 目标字符串 1234lpad('a', 5); // -&gt; ' a'lpad('a', 5, '-'); // -&gt; '----a'lpad('abc', 3, '-'); // -&gt; 'abc'lpad('abc', 5, 'ab'); // -&gt; 'ababc' ltrim删除字符串头部指定字符或空格。 类型定义function ltrim(str: string, chars?: string | string[]): string; 参数名 说明 str 源字符串 chars 删除字符 返回值 目标字符串 123ltrim(' abc '); // -&gt; 'abc 'ltrim('_abc_', '_'); // -&gt; 'abc_'ltrim('_abc_', ['a', '_']); // -&gt; 'bc_' map对集合的每个元素调用转换函数生成与之对应的数组。 类型定义function map&lt;T, TResult&gt;( list: types.List&lt;T&gt;, iterator: types.ListIterator&lt;T, TResult&gt;, context?: any): TResult[];function map&lt;T, TResult&gt;( object: types.Dictionary&lt;T&gt;, iterator: types.ObjectIterator&lt;T, TResult&gt;, context?: any): TResult[]; 参数名 说明 object 源集合 iterator 转换函数 context 函数上下文 返回值 目标集合 123map([4, 8], function(n) &#123; return n * n;&#125;); // -&gt; [16, 64] mapObj类似 map，但针对对象，生成一个新对象。 类型定义function mapObj&lt;T, TResult&gt;( object: types.Dictionary&lt;T&gt;, iterator: types.ObjectIterator&lt;T, TResult&gt;, context?: any): types.Dictionary&lt;TResult&gt;; 参数名 说明 object 源对象 iterator 转换函数 context 函数上下文 返回值 目标对象 123mapObj(&#123; a: 1, b: 2 &#125;, function(val, key) &#123; return val + 1;&#125;); // -&gt; &#123;a: 2, b: 3&#125; matcher传入对象返回函数，如果传入参数中包含该对象则返回真。 类型定义function matcher(attrs: any): types.AnyFn; 参数名 说明 attrs 要匹配的对象 返回值 真值检测函数 1234567const filter = require('licia/filter');const objects = [ &#123; a: 1, b: 2, c: 3 &#125;, &#123; a: 4, b: 5, c: 6 &#125;];filter(objects, matcher(&#123; a: 4, c: 6 &#125;)); // -&gt; [&#123;a: 4, b: 5, c: 6&#125;] max获取数字中的最大值。 类型定义function max(…num: number[]): number; 参数名 说明 …num 要计算的数字 返回值 最大值 1max(2.3, 1, 4.5, 2); // 4.5 md5MD5 算法实现。 类型定义function md5(msg: string | number[]): string; 参数名 说明 msg 密文 返回值 MD5 摘要 1md5('licia'); // -&gt; 'e59f337d85e9a467f1783fab282a41d0' memStorageWeb Storage 接口的纯内存实现。 类型定义const memStorage: typeof window.localStorage; 当 localStorage 或者 sessionStorage 无法使用时可以使用其作为替代。 12const localStorage = window.localStorage || memStorage;localStorage.setItem('test', 'licia'); memoize缓存函数计算结果。 类型定义function memoize( fn: types.AnyFn, hashFn?: types.AnyFn): types.AnyFn; 参数名 说明 fn 源函数 hashFn 计算缓存键名函数 返回值 目标函数 123const fibonacci = memoize(function(n) &#123; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;); mergeArr将数组合并到第一个数组里。 类型定义function mergeArr&lt;T, U&gt;( first: ArrayLike&lt;T&gt;, …arrays: ArrayLike&lt;U&gt;[]): ArrayLike&lt;T | U&gt;; 参数名 说明 first 要修改的数组 arrays 合并到第一个数组的数组 返回值 第一个数组 123const a = [1, 2];mergeArr(a, [3, 4], [5, 6]);console.log(a); // -&gt; [1, 2, 3, 4, 5, 6] mergeSort归并排序实现。 类型定义function mergeSort(arr: any[], cmp?: types.AnyFn): any[]; 注意：它不改变原数组。 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1mergeSort([2, 1]); // -&gt; [1, 2] metameta 操作库，将 name 和 content 属性值转换为键值对。 类型定义namespace meta { function remove(nameList: string | string[]): void;}function meta(): {};function meta(key: string): string;function meta(keys: string[]): {};function meta(key, value): void;function meta(pairs: {}): void; 获取指定 meta 值。如果忽略 meta 名，所有的 meta 键值对都被返回。 参数名 说明 name meta 名 返回值 meta 值 设置 meta 值。 参数名 说明 name meta 名 content meta 值 参数名 说明 metas 包含所有 meta 键值对的对象 remove移除指定 meta。 参数名 说明 name meta 名 123456789101112// &lt;meta name=\"a\" content=\"1\"/&gt; &lt;meta name=\"b\" content=\"2\"/&gt; &lt;meta name=\"c\" content=\"3\"/&gt;meta(); // -&gt; &#123;a: '1', b: '2', c: '3'&#125;meta('a'); // -&gt; '1'meta(['a', 'c']); // -&gt; &#123;a: '1', c: '3'&#125;meta('d', '4');meta(&#123; d: '5', e: '6', f: '7'&#125;);meta.remove('d');meta.remove(['e', 'f']); methods获取对象中所有方法名。 类型定义function methods(obj: any): string[]; 参数名 说明 obj 目标对象 返回值 方法名列表 1methods(console); // -&gt; ['Console', 'assert', 'dir', ...] mime常用 mime 类型。 类型定义function mime(name: string): string | undefined; 参数名 说明 name 扩展名 返回值 mime 类型 参数名 说明 name mime 类型 返回值 扩展名 该模块只包含常用的文件类型。 1234mime('jpg'); // -&gt; 'image/jpeg'mime('bmp'); // -&gt; 'image/bmp'mime('video/mp4'); // -&gt; 'mp4'mime('test'); // -&gt; undefined min获取数字中的最小值。 类型定义function min(…num: number[]): number; 参数名 说明 …num 要计算的数字 返回值 最小值 1min(2.3, 1, 4.5, 2); // 1 mkdir递归地创建文件夹。 类型定义namespace mkdir { function sync(dir: string, mode?: number): void;}function mkdir( dir: string, mode?: number, cb?: types.AnyFn): void;function mkdir(dir: string, cb?: types.AnyFn): void; 参数名 说明 dir 文件夹路径 mode=0777 文件夹模式 cb 回调 sync同步版本。 12345mkdir('/tmp/foo/bar/baz', function(err) &#123; if (err) console.log(err); else console.log('Done');&#125;);mkdir.sync('/tmp/foo2/bar/baz'); moment简单的类 moment.js 实现。 类型定义namespace moment { class M { constructor(value: string | Date); format(mask: string): string; isValid(): boolean; isLeapYear(): boolean; isSame(that: M): boolean; valueOf(): number; isBefore(that: M): boolean; isAfter(that: M): boolean; year(): number; year(number): M; month(): number; month(number): M; date(): number; date(number): M; hour(): number; hour(number): M; minute(): number; minute(number): M; second(): number; second(number): M; millisecond(): number; millisecond(number): M; unix(): number; clone(): M; toDate(): Date; toArray(): number[]; toJSON(): string; toISOString(): string; toObject(): any; toString(): string; set(unit: string, num: number): M; startOf(unit: string): M; endOf(unit: string): M; daysInMonth(): number; add(num: number, unit: string): M; subtract(num: number, unit: string): M; diff(input: M | string | Date, unit: string, asFloat: boolean): number; }}function moment(value: string | Date): moment.M; 它只支持一小部分的 moment.js api。 可用方法format，isValid，isLeapYear，isSame，isBefore，isAfter，year，month，date，hour，minute，second，millisecond，unix，clone，toDate，toArray，toJSON，toISOString，toObject，toString，set，startOf，endOf，add，subtract，diff 不支持特性时区以及 quarter 和 week 单位。 注意：格式化功能使用 dateFormat 模块，所以掩码格式并不完全与 moment.js 一致。 1moment('20180501').format('yyyy-mm-dd'); // -&gt; '2018-05-01' morphDom将 DOM 树变化成目标 DOM 树。 类型定义function morphDom(from: Node, to: Node | string): Node; 参数名 说明 from 原始 DOM 树 to 要变化的 DOM 树 返回值 变化后的 DOM 树 123456const el1 = document.createElement('div');el1.className = 'test';const el2 = document.createElement('div');el2.className = 'licia';morphDom(el1, el2);console.log(el1.className); // -&gt; 'licia' morse摩尔斯电码编解码。 类型定义const morse: { encode(txt: string): string; decode(morse: string): string;}; encode将文本转换为摩尔斯电码。 参数名 说明 txt 要编码的文本 返回值 摩尔斯电码 decode将摩尔斯电码转换为文本。 参数名 说明 morse 摩尔斯电码 返回值 解码后的文本 123const str = morse.encode('Hello, world.');// -&gt; '.... . .-.. .-.. --- --..-- ....... .-- --- .-. .-.. -.. .-.-.-'morse.decode(str); // -&gt; 'Hello, world.' ms时长字符串与毫秒转换库。 类型定义function ms(str: string): number;function ms(num: number): string; 转换时长字符串为毫秒。 参数名 说明 str 字符串格式 返回值 毫秒 转换毫秒为时长字符串。 参数名 说明 num 毫秒 返回值 字符串格式 12345678ms('1s'); // -&gt; 1000ms('1m'); // -&gt; 60000ms('1.5h'); // -&gt; 5400000ms('1d'); // -&gt; 86400000ms('1y'); // -&gt; 31557600000ms('1000'); // -&gt; 1000ms(1500); // -&gt; '1.5s'ms(60000); // -&gt; '1m' naturalSort以自然顺序排序数组。 类型定义function naturalSort&lt;T extends any[]&gt;(arr: T): T; 参数名 说明 arr 要排序的数组 返回值 有序数组 123naturalSort(['img12', 'img11', '$img', '_img', '1', '2', '12']);// -&gt; ['1', '2', '12', '$img', 'img11', 'img12', '_img']naturalSort([2, '1', 13]); // -&gt; ['1', 2, 13] negate创建一个将原函数结果取反的函数。 类型定义function negate&lt;T extends types.AnyFn&gt;(predicate: T): T; 参数名 说明 predicate 源函数 返回值 目标函数 1234function even(n) &#123; return n % 2 === 0;&#125;[1, 2, 3, 4, 5, 6].filter(negate(even)); // -&gt; [1, 3, 5] nextTick能够同时运行在 node 和浏览器端的 next tick 实现。 类型定义function nextTick(cb: types.AnyFn): void; 参数名 说明 cb 调用函数 如果支持 process.nextTick，则调用它，否则使用 setImmediate 或 setTimeout 进行兼容。 123nextTick(function() &#123; // Do something...&#125;); noop一个什么也不做的空函数。 类型定义function noop(): void; 1noop(); // Does nothing normalizeHeader标准化 HTTP 头部名。 类型定义function normalizeHeader(header: string): string; 参数名 说明 header 源头部名 返回值 目标头部名 12normalizeHeader('content-type'); // -&gt; 'Content-Type'normalizeHeader('etag'); // -&gt; 'ETag' normalizePath标准化文件路径中的斜杠。 类型定义function normalizePath(path: string): string; 参数名 说明 path 源路径 返回值 目标路径 12normalizePath('\\\\foo\\\\bar\\\\'); // -&gt; '/foo/bar/'normalizePath('./foo//bar'); // -&gt; './foo/bar' normalizePhone标准化电话号码为 E.164 格式。 类型定义function normalizePhone( phone: string, options: { countryCode: number; trunkPrefix?: boolean; }): string; 参数名 说明 phone 电话号码 options 标准化选项 返回值 E.164 格式电话号码 可用选项： 参数名 说明 countryCode 国家代码 trunkPrefix=false 如果本地格式有长途字冠，设为真 12345678910normalizePhone('13512345678', &#123; countryCode: 86&#125;); // -&gt; '+8613512345678'normalizePhone('(415) 555-2671', &#123; countryCode: 1&#125;); // -&gt; '+14155552671'normalizePhone('020 7183 8750', &#123; countryCode: 44, trunkPrefix: true&#125;); // -&gt; '+442071838750' notifyWeb Notifications 接口简单包装。 类型定义namespace notify { class Notification extends Emitter { constructor(title: string, options?: object); show(): void; }}function notify(title: string, options?: object): void; 参数名 说明 title 通知标题 options 通知选项 你可以传入所有在 Web Notification 中支持的选项。 Notification如果你想要监听并处理像 close，show，click 或者 error 等事件，使用这个类创建实例。 123456789notify('licia', &#123; body: 'This is the notification content'&#125;);const notification = new notify.Notification('licia', &#123; body: 'This is the notification content'&#125;);notification.on('error', err =&gt; console.log(err));notification.on('click', e =&gt; console.log(e));notification.show(); now获取当前时间戳。 类型定义function now(): number; 1now(); // -&gt; 1468826678701 objToStrObject.prototype.toString 的别名。 类型定义function objToStr(val: any): string; 参数名 说明 val 目标值 返回值 字符串表示 1objToStr(5); // -&gt; '[object Number]' omit类似 pick，但结果相反。 类型定义function omit( obj: any, filter: string | string[] | Function): any; 参数名 说明 obj 源对象 filter 对象过滤器 返回值 目标对象 12345omit(&#123; a: 1, b: 2 &#125;, 'a'); // -&gt; &#123;b: 2&#125;omit(&#123; a: 1, b: 2, c: 3 &#125;, ['b', 'c']); // -&gt; &#123;a: 1&#125;omit(&#123; a: 1, b: 2, c: 3, d: 4 &#125;, function(val, key) &#123; return val % 2;&#125;); // -&gt; &#123;b: 2, d: 4&#125; once创建只能调用一次的函数。 类型定义function once(fn: types.AnyFn): types.AnyFn; 参数名 说明 fn 源函数 返回值 目标函数 1234function init() &#123;&#125;const initOnce = once(init);initOnce();initOnce(); // -&gt; init is invoked once open打开 url 地址或文件。 类型定义function open(target: string): any; 参数名 说明 target 要打开的目标 返回值 子进程对象 1open('https://eustia.liriliri.io/'); openFile在浏览器中打开文件选择框。 类型定义function openFile(options?: { accept?: string; multiple?: boolean;}): Promise&lt;File[]&gt;; 参数名 说明 options 选项 返回值 文件列表 可用选项： 参数名 说明 accept 文件类型 multiple=false 是否支持多选 123openFile(&#123; multiple: true &#125;).then(fileList =&gt; &#123; console.log(fileList);&#125;); optimizeCb用于高效的函数上下文绑定。 类型定义function optimizeCb( fn: types.AnyFn, ctx: any, argCount?: number): types.AnyFn; ordinal转换数字为序数形式。 类型定义function ordinal(num: number): string; 参数名 说明 num 要转换的数字 返回值 目标序数 12ordinal(1); // -&gt; '1st'ordinal(2); // -&gt; '2nd' orientation屏幕方向工具库。 类型定义namespace orientation { interface IOrientation extends Emitter { get(): string; }}const orientation: orientation.IOrientation; on绑定 change 事件。 off解绑 change 事件。 get获取当前屏幕方向（横屏 landscape 或 竖屏 portrait）。 1234orientation.on('change', function(direction) &#123; console.log(direction); // -&gt; 'portrait'&#125;);orientation.get(); // -&gt; 'landscape' pad对字符串进行左右填充。 类型定义function pad(str: string, len: number, chars?: string): string; 参数名 说明 str 源字符串 len 填充长度 chars 填充字符串 返回值 目标字符串 12345pad('a', 5); // -&gt; ' a 'pad('a', 5, '-'); // -&gt; '--a--'pad('abc', 3, '-'); // -&gt; 'abc'pad('abc', 5, 'ab'); // -&gt; 'babca'pad('ab', 5, 'ab'); // -&gt; 'ababa' pairs将对象转换为包含【键名，键值】对的数组。 类型定义function pairs(obj: any): Array&lt;any[]&gt;; 参数名 说明 obj 目标对象 返回值 键值对数组 1pairs(&#123; a: 1, b: 2 &#125;); // -&gt; [['a', 1], ['b', 2]] parallel同时执行多个函数。 类型定义function parallel(tasks: types.AnyFn[], cb?: types.AnyFn): void; 参数名 说明 tasks 函数数组 cb 结束回调 1234567891011121314151617parallel( [ function(cb) &#123; setTimeout(function() &#123; cb(null, 'one'); &#125;, 200); &#125;, function(cb) &#123; setTimeout(function() &#123; cb(null, 'two'); &#125;, 100); &#125; ], function(err, results) &#123; // results -&gt; ['one', 'two'] &#125;); parseArgs命令行参数简单解析。 类型定义function parseArgs( args: string[], options: { names: any; shorthands: any; }): any; 参数名 说明 args 参数数组 options 解析选项 返回值 解析结果 options 参数名 说明 names 选项名及类型 shorthands 选项名缩写 1234567891011parseArgs(['eustia', '--output', 'util.js', '-w'], &#123; names: &#123; output: 'string', watch: 'boolean' &#125;, shorthands: &#123; output: 'o', watch: 'w' &#125;&#125;);// -&gt; &#123;remain: ['eustia'], output: 'util.js', watch: true&#125; parseHtmlHTML 解析器。 类型定义function parseHtml( html: string, handlers: { start?: (tag: string, attrs: any, unary: boolean) =&gt; void; end?: (tag: string) =&gt; void; comment?: (text: string) =&gt; void; text?: (text: string) =&gt; void; }): void; 参数名 说明 html 要解析的 HTML handler 处理函数 123456parseHtml('&lt;div&gt;licia&lt;/div&gt;', &#123; start: (tag, attrs, unary) =&gt; &#123;&#125;, end: tag =&gt; &#123;&#125;, comment: text =&gt; &#123;&#125;, text: text =&gt; &#123;&#125;&#125;); partial返回局部填充参数的函数，与 bind 模块相似。 类型定义function partial( fn: types.AnyFn, …partials: any[]): types.AnyFn; 参数名 说明 fn 源函数 …partials 局部填充参数 返回值 目标函数 1234const sub5 = partial(function(a, b) &#123; return b - a;&#125;, 5);sub5(20); // -&gt; 15 pascalCase将字符串转换为帕斯卡式。 类型定义function pascalCase(str: string): string; 参数名 说明 str 源字符串 返回值 帕斯卡式字符串 1234pascalCase('fooBar'); // -&gt; FooBarpascalCase('foo bar'); // -&gt; FooBarpascalCase('foo_bar'); // -&gt; FooBarpascalCase('foo.bar'); // -&gt; FooBar perfNow高精度时间戳。 类型定义function perfNow(): number; 12345const start = perfNow();// Do something.console.log(perfNow() - start); pick过滤对象。 类型定义function pick( object: any, filter: string | string[] | Function): any; 参数名 说明 object 源对象 filter 对象过滤器 返回值 目标对象 12345pick(&#123; a: 1, b: 2 &#125;, 'a'); // -&gt; &#123;a: 1&#125;pick(&#123; a: 1, b: 2, c: 3 &#125;, ['b', 'c']); // -&gt; &#123;b: 2, c: 3&#125;pick(&#123; a: 1, b: 2, c: 3, d: 4 &#125;, function(val, key) &#123; return val % 2;&#125;); // -&gt; &#123;a: 1, c: 3&#125; pipe将所有的 stream 流连接起来。 类型定义import stream = require(&#x27;stream&#x27;);function pipe(…streams: stream.Stream[]): void; 参数名 说明 …streams 要连接的 stream 流 12345678910const fs = require('fs');const through = require('licia/through');pipe( fs.createReadStream('in.txt'), through(function(chunk, enc, cb) &#123; this.push(chunk); cb(); &#125;), fs.createWriteStream('out.txt')); pluck提取数组对象中指定属性值，返回一个数组。 类型定义function pluck(object: any, key: string | string[]): any[]; 参数名 说明 obj 目标集合 key 属性路径 返回值 指定属性值列表 123456const stooges = [ &#123; name: 'moe', age: 40 &#125;, &#123; name: 'larry', age: 50 &#125;, &#123; name: 'curly', age: 60 &#125;];pluck(stooges, 'name'); // -&gt; ['moe', 'larry', 'curly'] precision获取数字的精度。 类型定义function precision(num: number): number; 参数名 说明 num 要检查的数字 返回值 精度 1precision(1.234); // -&gt; 3; prefetch预获取指定的 url。 类型定义function prefetch(url: string): Promise&lt;void&gt;; 参数名 说明 url 目标 url 如果支持，它将使用&lt;link rel=prefetch&gt;进行预加载。 1prefetch('https://eustia.liriliri.io/'); prefix给 css 属性名增加浏览器前缀。 类型定义namespace prefix { function dash(name: string): string;}function prefix(name: string): string; 参数名 说明 name 源属性名 返回值 目标属性名 dash同上，但返回短横线命名方式的版本。 123prefix('text-emphasis'); // -&gt; 'WebkitTextEmphasis'prefix.dash('text-emphasis'); // -&gt; '-webkit-text-emphasis'prefix('color'); // -&gt; 'color' promisify转换使用回调的异步函数，使其返回 Promise。 类型定义function promisify( fn: types.AnyFn, multiArgs?: boolean): types.AnyFn; 参数名 说明 fn 源函数 multiArgs=false 回调是否有多个结果 返回值 目标函数 如果 multiArgs 设为真，返回的 Promise 会将回调的结果合并成一个数组。 123456const fs = require('fs');const readFile = promisify(fs.readFile);readFile('test.js', 'utf-8').then(function(data) &#123; // Do something with file content.&#125;); property返回一个函数，该函数返回任何传入对象的指定属性。 类型定义function property(path: string | string[]): types.AnyFn; 参数名 说明 path 属性路径 返回值 目标函数 123const obj = &#123; a: &#123; b: 1 &#125; &#125;;property('a')(obj); // -&gt; &#123;b: 1&#125;property(['a', 'b'])(obj); // -&gt; 1 query解析序列化 url 的 query 部分。 类型定义const query: { parse(str: string): any; stringify(object: any): string;}; parse将 query 字符串解析成对象。 参数名 说明 str query 字符串 返回值 query 对象 stringify将对象序列化成 query 字符串。 参数名 说明 obj query 对象 返回值 query 字符串 123query.parse('foo=bar&amp;eruda=true'); // -&gt; &#123;foo: 'bar', eruda: 'true'&#125;query.stringify(&#123; foo: 'bar', eruda: 'true' &#125;); // -&gt; 'foo=bar&amp;eruda=true'query.parse('name=eruda&amp;name=eustia'); // -&gt; &#123;name: ['eruda', 'eustia']&#125; quickSort快排实现。 类型定义function quickSort(arr: any[], cmp?: types.AnyFn): any[]; 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1quickSort([2, 1]); // -&gt; [1, 2] rafrequestAnimationFrame 快捷方式。 类型定义namespace raf { function cancel(id: number): void;}function raf(cb: types.AnyFn): number; 如果原生 requestAnimationFrame 不支持，使用 setTimeout 进行兼容。 12345const id = raf(function tick() &#123; // Animation stuff raf(tick);&#125;);raf.cancel(id); random在给定区间内生成随机数。 类型定义function random( min: number, max?: number, floating?: boolean): number; 参数名 说明 min 最小值 max 最大值 floating=false 是否允许浮点数 返回值 随机数 123random(1, 5); // -&gt; an integer between 0 and 5random(5); // -&gt; an integer between 0 and 5random(1.2, 5.2, true); /// -&gt; a floating-point number between 1.2 and 5.2 randomBytes随机字节序列生成器。 类型定义function randomBytes(size: number): Uint8Array; 如果支持，使用 node 的 crypto 模块或浏览器的 crypto 对象。 参数名 说明 size 字节序列长度 返回值 随机字节序列 1randomBytes(5); // -&gt; [55, 49, 153, 30, 122] randomColor随机颜色生成器。 类型定义function randomColor(): string;function randomColor(options: { count?: number; hue?: number; lightness?: number; format?: string; seed?: number;}): string | string[]; 参数名 说明 options 随机选项 返回值 随机颜色 可用选项： 参数名 说明 count=1 生成数 hue 色调，取值为 0 - 360 lightness 亮度，取值为 0 - 1 format=hex 颜色格式，hex，hsl 或者 rgb seed 随机种子 123randomColor(&#123; count: 2&#125;); // -&gt; ['#fed7f4', '#526498'] randomId简单 id 生成器，类似于 nanoid。 类型定义function randomId(size?: number, symbols?: string): string; 参数名 说明 size=21 id 长度 symbols 生成 id 字符，默认为 a-zA-Z0-9_- 123randomId(); // -&gt; 'oKpy4HwU8E6IvU5I03gyQ'randomId(5); // -&gt; 'sM6E9'randomId(5, 'abc'); // -&gt; 'cbbcb' randomItem随机获取数组中的某项。 类型定义function randomItem(arr: any[]): any; 参数名 说明 arr 目标数组 返回值 随机项 1randomItem([1, 2, 3]); // -&gt; 2 range创建整数数组。 类型定义function range( start: number, end?: number, step?: number): number[]; 参数名 说明 start 起始值 end 结束值 step=1 相邻差 返回值 整数数组 12range(5); // -&gt; [0, 1, 2, 3, 4]range(0, 5, 2); // -&gt; [0, 2, 4] rc4RC4 对称加密算法实现。 类型定义const rc4: { encrypt(key: string, str: string): string; decrypt(key: string, str: string): string;}; encryptRC4 加密，结果表示为 base64 字符串。 decryptRC4 解密，传入 base64 字符串。 参数名 说明 key 密钥 str 源字符串 返回值 目标字符串 12rc4.encrypt('licia', 'Hello world'); // -&gt; 'j9y2VpSfR3AdNN8='rc4.decrypt('licia', 'j9y2VpSfR3AdNN8='); // -&gt; 'Hello world' readydom 准备好时调用回调函数，类似于 jQuery 的 ready 方法。 类型定义function ready(fn: types.AnyFn): void; 参数名 说明 fn 回调函数 123ready(function() &#123; // It's safe to manipulate dom here.&#125;); reduce合并多个值成一个值。 类型定义function reduce&lt;T, TResult&gt;( list: types.List&lt;T&gt;, iterator: types.MemoIterator&lt;T, TResult&gt;, memo?: TResult, context?: any): TResult;function reduce&lt;T, TResult&gt;( list: types.Dictionary&lt;T&gt;, iterator: types.MemoObjectIterator&lt;T, TResult&gt;, memo?: TResult, context?: any): TResult; 参数名 说明 obj 目标集合 iteratee=identity 合并函数 initial 初始值 ctx 函数上下文 返回值 合并值 1234567reduce( [1, 2, 3], function(sum, n) &#123; return sum + n; &#125;, 0); // -&gt; 6 reduceRight类似于 reduce，只是从后往前合并。 类型定义function reduceRight&lt;T, TResult&gt;( list: types.Collection&lt;T&gt;, iterator: types.MemoIterator&lt;T, TResult&gt;, memo?: TResult, context?: any): TResult; 1234567reduceRight( [[1], [2], [3]], function(a, b) &#123; return a.concat(b); &#125;, []); // -&gt; [3, 2, 1] reject类似 filter，但结果相反。 类型定义function reject&lt;T&gt;( list: types.List&lt;T&gt;, iterator: types.ListIterator&lt;T, boolean&gt;, context?: any): T[];function reject&lt;T&gt;( object: types.Dictionary&lt;T&gt;, iterator: types.ObjectIterator&lt;T, boolean&gt;, context?: any): T[]; 参数名 说明 obj 要遍历的集合 predicate 真值检测函数 ctx 函数上下文 返回值 包含所有未通过真值检测元素的数组 123reject([1, 2, 3, 4, 5], function(val) &#123; return val % 2 === 0;&#125;); // -&gt; [1, 3, 5] remove移除集合中所有通过真值检测的元素，返回包含所有删除元素的数组。 类型定义function remove&lt;T, TResult&gt;( list: types.List&lt;T&gt;, iterator: types.ListIterator&lt;T, boolean&gt;, context?: any): TResult[]; 与 filter 不同，该模块会改变原数组。 参数名 说明 list 要遍历的集合 iterator 真值检测函数 context 函数上下文 返回值 包含所有删除元素的数组 123456const arr = [1, 2, 3, 4, 5];const evens = remove(arr, function(val) &#123; return val % 2 === 0;&#125;);console.log(arr); // -&gt; [1, 3, 5]console.log(evens); // -&gt; [2, 4] repeat重复字符串指定次数。 类型定义function repeat(str: string, n: number): string; 参数名 说明 str 源字符串 n 重复次数 返回值 目标字符串 123repeat('a', 3); // -&gt; 'aaa'repeat('ab', 2); // -&gt; 'abab'repeat('*', 0); // -&gt; '' replaceAll替换字符串中所有指定字符串。 类型定义function replaceAll( str: string, substr: string, newSubstr: string): string; 参数名 说明 str 源字符串 substr 被替换的子串 newSubstr 替换的子串 返回值 所有子串被替换后的新字符串 1replaceAll('hello world goodbye world', 'world', 'licia'); // -&gt; 'hello licia goodbye licia' restArgs将给定序号后的参数合并成一个数组。 类型定义function restArgs( fn: types.AnyFn, startIndex?: number): types.AnyFn; 参数名 说明 function 源函数 startIndex 合并参数起始位置 返回值 目标函数 1234const paramArr = restArgs(function(rest) &#123; return rest;&#125;);paramArr(1, 2, 3, 4); // -&gt; [1, 2, 3, 4] reverse将数组元素颠倒，不改变原数组。 类型定义function reverse(arr: any[]): any[]; 参数名 说明 arr 源数组 返回值 目标数组 1reverse([1, 2, 3]); // -&gt; [3, 2, 1] rgbToHsl将 rgb 格式的颜色值转换为 hsl 格式。 类型定义function rgbToHsl(rgb: number[]): number[]; 参数名 说明 rgb rgb 值 返回值 hsl 值 1rgbToHsl([52, 203, 165, 0.8]); // -&gt; [165, 59, 50, 0.8] ricrequestIdleCallback 的快捷方式。 类型定义namespace ric { function cancel(id: number): void;}function ric(cb: types.AnyFn): number; 如果原生 requestIdleCallback 不支持，使用 setTimeout 进行兼容。 1234const id = ric(function() &#123; // Called during a browser's idle periods&#125;);ric.cancel(id); rmCookie遍历所有可能的路径和域名将 cookie 删除。 类型定义function rmCookie(key: string): void; 参数名 说明 key cookie 名 1rmCookie('test'); rmdir递归地删除文件夹。 类型定义function rmdir(dir: string, cb?: types.AnyFn): void; 参数名 说明 dir 文件夹路径 cb 回调 1234rmdir('/tmp/foo/bar/baz', function(err) &#123; if (err) console.log(err); else console.log('Done');&#125;); root根对象引用，对于 nodeJs，取 global 对象，对于浏览器，取 window 对象。 类型定义const root: any; rpad对字符串进行右填充。 类型定义function rpad(str: string, len: number, chars?: string): string; 参数名 说明 str 源字符串 len 填充长度 chars 填充字符 返回值 目标字符串 1234rpad('a', 5); // -&gt; 'a 'rpad('a', 5, '-'); // -&gt; 'a----'rpad('abc', 3, '-'); // -&gt; 'abc'rpad('abc', 5, 'ab'); // -&gt; 'abcab' rtrim删除字符串尾部指定字符或空格。 类型定义function rtrim(str: string, chars?: string | string[]): string; 参数名 说明 str 源字符串 chars 删除字符 返回值 目标字符串 123rtrim(' abc '); // -&gt; ' abc'rtrim('_abc_', '_'); // -&gt; '_abc'rtrim('_abc_', ['c', '_']); // -&gt; '_ab' safeCb创建回调函数，内部模块使用。 类型定义function safeCb( val?: any, ctx?: any, argCount?: number): types.AnyFn; safeDel删除对象属性。 类型定义function safeDel(obj: any, path: string | string[]): any; 参数名 说明 obj 目标对象 path 属性路径 返回值 删除值或 undefined 1234const obj = &#123; a: &#123; aa: &#123; aaa: 1 &#125; &#125; &#125;;safeDel(obj, 'a.aa.aaa'); // -&gt; 1safeDel(obj, ['a', 'aa']); // -&gt; &#123;&#125;safeDel(obj, 'a.b'); // -&gt; undefined safeGet获取对象属性值，路径不存在时不报错。 类型定义function safeGet(obj: any, path: string | string[]): any; 参数名 说明 obj 目标对象 path 属性路径 返回值 属性值或 undefined 1234const obj = &#123; a: &#123; aa: &#123; aaa: 1 &#125; &#125; &#125;;safeGet(obj, 'a.aa.aaa'); // -&gt; 1safeGet(obj, ['a', 'aa']); // -&gt; &#123;aaa: 1&#125;safeGet(obj, 'a.b'); // -&gt; undefined safeSet设置对象属性值。 类型定义function safeSet( obj: any, path: string | string[], val: any): void; 如果路径的某一层不存在，将会创建一个空对象。 参数名 说明 obj 目标对象 path 属性路径 val 要设置的值 1234const obj = &#123;&#125;;safeSet(obj, 'a.aa.aaa', 1); // obj = &#123;a: &#123;aa: &#123;aaa: 1&#125;&#125;&#125;safeSet(obj, ['a', 'aa'], 2); // obj = &#123;a: &#123;aa: 2&#125;&#125;safeSet(obj, 'a.b', 3); // obj = &#123;a: &#123;aa: 2, b: 3&#125;&#125; safeStorage安全地使用 storage，使其在旧浏览器及 safari 无痕模式下能正常运行。 类型定义function safeStorage(type?: string): typeof window.localStorage; 参数名 说明 type=’local’ 模式，local 或 session 返回值 指定 storage 12const localStorage = safeStorage('local');localStorage.setItem('licia', 'util'); sameOrigin检查两个 url 是否同源。 类型定义function sameOrigin(url1: string, url2: string): boolean; 参数名 说明 url1 要检查的 url url2 要检查的 url 返回值 同源，返回真 12345const url1 = 'http://example.com/a.html';const url2 = 'http://example.com/b.html';const url3 = 'http://licia.liriliri.io';sameOrigin(url1, url2); // -&gt; truesameOrigin(url1, url3); // -&gt; false sample从集合中随机抽取部分样本。 类型定义function sample(obj: any, n: number): any[]; 参数名 说明 obj 目标集合 n 样本数量 返回值 样本 12sample([2, 3, 1], 2); // -&gt; [2, 3]sample(&#123; a: 1, b: 2, c: 3 &#125;, 1); // -&gt; [2] scrollTo以动画的形式滚动到指定目标。 类型定义function scrollTo( target: Element | string | number, options: { tolerance?: number; duration?: number; easing?: string | Function; callback?: types.AnyFn; }); 参数名 说明 target 滚动目标 options 滚动选项 选项 选项名 说明 tolerance=0 偏移 duration=800 时长 easing=outQuart 缓动函数 callback=noop 结束回调 123456scrollTo('body', &#123; tolerance: 0, duration: 800, easing: 'outQuart', callback: function() &#123;&#125;&#125;); seedRandom随机数生成器。 类型定义function seedRandom( seed: number, min?: number, max?: number, floating?: boolean): () =&gt; number; 参数名 说明 seed 随机种子 min=0 最小值 max=1 最大值 floating=true 是否允许浮点数 返回值 生成随机数字序列的函数 123const random = seedRandom(19920719, 0, 100, false);random(); // -&gt; 7random(); // -&gt; 68 selectionSort选择排序实现。 类型定义function selectionSort(arr: any[], cmp?: types.AnyFn): any[]; 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1selectionSort([2, 1]); // -&gt; [1, 2] selectorCSS 选择器解析器。 类型定义namespace selector { interface IToken { type: string; value: string; }}const selector: { parse(selector: string): Array&lt;selector.IToken[]&gt;; stringify(selector: Array&lt;selector.IToken[]&gt;): string;}; parse将 CSS 选择器转换为 js 对象。 参数名 说明 selector CSS 选择器 返回值 js 对象 stringify将 js 对象序列化成 CSS 选择器。 参数名 说明 groups 要序列化的对象 返回值 CSS 选择器 123const groups = selector.parse('#test, input.user[name=\"licia\"]');// -&gt; [[&#123;type: 'id', value: 'test'&#125;],[&#123;type: 'tag', value: 'input'&#125;...]]selector.stringify(groups); shebang获取 shebang 命令。 类型定义function shebang(str: string): string | void; 参数名 说明 str 要获取命令的文本 返回值 Shebang 命令 123shebang('#!/usr/bin/env node'); // -&gt; '/usr/bin/env node'shebang('#!/bin/bash'); // -&gt; '/bin/bash'shebang('node'); // -&gt; undefined shellSort希尔排序实现。 类型定义function shellSort(arr: any[], cmp?: types.AnyFn): any[]; 参数名 说明 arr 要排序的数组 cmp 比较器 返回值 有序数组 1shellSort([2, 1]); // -&gt; [1, 2] shuffle将数组中元素的顺序打乱。 类型定义function shuffle(arr: any[]): any[]; 参数名 说明 arr 源数组 返回值 目标数组 1shuffle([1, 2, 3]); // -&gt; [3, 1, 2] size获取对象的大小或类数组元素的长度。 类型定义function size(obj: any): number; 参数名 说明 obj 目标集合 返回值 集合大小 12size(&#123; a: 1, b: 2 &#125;); // -&gt; 2size([1, 2, 3]); // -&gt; 3 sizeof计算 js 对象大概的内存占用。 类型定义function sizeof(obj: any): number; 参数名 说明 obj 要计算的对象 返回值 对象大小，单位是字节 一个字符占用 2 字节，布尔值 4 字节，数字 8 字节。 对象键名当成字符串来计算。 12345sizeof('a'); // -&gt; 2sizeof(8); // -&gt; 8sizeof(false); // -&gt; 4sizeof(function() &#123;&#125;); // -&gt; 0sizeof(&#123; a: 'b' &#125;); // -&gt; 4 sleep使用 Promise 模拟暂停方法。 类型定义function sleep(timeout: number): Promise&lt;void&gt;; 参数名 说明 timeout 暂停时长 123(async function() &#123; await sleep(2000);&#125;)(); slice截取数组的一部分生成新数组。 类型定义function slice( array: any[], start?: number, end?: number): any[]; 参数名 说明 array 目标数组 start=0 起始位置 end=array.length 结束位置，不包含 1slice([1, 2, 3, 4], 1, 2); // -&gt; [2] slugifySlug 化字符串。 类型定义function slugify( str: string, replacement?: { [index: string]: string }): string; 参数名 说明 str 源字符串 replacement 自定义替换 返回值 目标字符串 12slugify('I ♥ pony'); // -&gt; 'I-love-pony'slugify('I ♥ pony', &#123; ' ': '_' &#125;); // -&gt; 'I_love_pony' snakeCase转换字符串为下划线式。 类型定义function snakeCase(str: string): string; 参数名 说明 str 源字符串 返回值 下划线式字符串 123snakeCase('fooBar'); // -&gt; foo_barsnakeCase('foo bar'); // -&gt; foo_barsnakeCase('foo.bar'); // -&gt; foo_bar some检查集合中是否有元素通过真值检测。 类型定义function some&lt;T&gt;( list: types.List&lt;T&gt;, iterator?: types.ListIterator&lt;T, boolean&gt;, context?: any): boolean;function some&lt;T&gt;( object: types.Dictionary&lt;T&gt;, iterator?: types.ObjectIterator&lt;T, boolean&gt;, context?: any): boolean; 参数名 说明 obj 目标集合 predicate 真值检测函数 ctx 函数上下文 返回值 如果有元素通过真值检测，返回真 123some([2, 5], function(val) &#123; return val % 2 === 0;&#125;); // -&gt; true sortBy遍历集合中的元素，将其作为参数调用函数，并以得到的结果为依据对数组进行排序。 类型定义function sortBy( arr: any, iterator?: types.AnyFn, ctx?: any): any[]; 参数名 说明 arr 源集合 iteratee=identity 排序依据生成函数 ctx 函数上下文 返回值 排序后的数组 123sortBy([1, 2, 3, 4, 5, 6], function(num) &#123; return Math.sin(num);&#125;); // -&gt; [5, 4, 6, 3, 1, 2] sortKeys排序对象的键名。 类型定义function sortKeys( obj: object, options?: { deep?: boolean; comparator?: types.AnyFn; }): object; 参数名 说明 obj 要排序的对象 options 排序选项 返回值 排序后的对象 可用选项： 参数名 说明 deep=false 是否递归 comparator 比较器 123456sortKeys( &#123; b: &#123; d: 2, c: 1 &#125;, a: 0 &#125;, &#123; deep: true &#125;); // -&gt; &#123;a: 0, b: &#123;c: 1, d: 2&#125;&#125; spaceCase将字符串转换为空格式。 类型定义function spaceCase(str: string): string; 参数名 说明 str 源字符串 返回值 空格式字符串 123spaceCase('fooBar'); // -&gt; foo barspaceCase('foo.bar'); // -&gt; foo barspaceCase('foo.bar'); // -&gt; foo bar splitCase将不同命名式的字符串拆分成数组。 类型定义function splitCase(str: string): string[]; 参数名 说明 str 目标字符串 返回值 拆分成的数组 123456splitCase('foo-bar'); // -&gt; ['foo', 'bar']splitCase('foo bar'); // -&gt; ['foo', 'bar']splitCase('foo_bar'); // -&gt; ['foo', 'bar']splitCase('foo.bar'); // -&gt; ['foo', 'bar']splitCase('fooBar'); // -&gt; ['foo', 'bar']splitCase('foo-Bar'); // -&gt; ['foo', 'bar'] splitPath将路径拆分为文件夹路径，文件名和扩展名。 类型定义function splitPath( path: string): { dir: string; name: string; ext: string;}; 参数名 说明 path 目标路径 返回值 包含文件夹路径，文件名和扩展名的对象 12splitPath('f:/foo/bar.txt'); // -&gt; &#123;dir: 'f:/foo/', name: 'bar.txt', ext: '.txt'&#125;splitPath('/home/foo/bar.txt'); // -&gt; &#123;dir: '/home/foo/', name: 'bar.txt', ext: '.txt'&#125; stackTrace获取 v8 的 CallSite 对象。 类型定义function stackTrace(): any[]; Stack trace 接口说明 1stackTrace(); // -&gt; List of CallSite objects startWith检查字符串是否以指定字符串开头。 类型定义function startWith(str: string, prefix: string): boolean; 参数名 说明 str 目标字符串 prefix 字符串前缀 返回值 如果是前缀，返回真 1startWith('ab', 'a'); // -&gt; true strHash使用 djb2 算法进行字符串哈希。 类型定义function strHash(str: string): number; 参数名 说明 str 目标字符串 返回值 哈希结果 1strHash('test'); // -&gt; 2090770981 strToBytes将字符串转换为字节数组。 类型定义function strToBytes(str: string, encoding?: string): number[]; 参数名 说明 str 目标字符串 encoding=utf8 字符串编码 返回值 字节数组 支持编码：utf8，hex，base64 12strToBytes('licia'); // -&gt; [108, 105, 99, 105, 97]strToBytes('qK6b/w==', 'base64'); // -&gt; [168, 174, 155, 255] strTpl简单的字符串模板。 类型定义function strTpl(str: string, data: types.PlainObj&lt;any&gt;): string; 参数名 说明 str 模板字符串 data 渲染数据 返回值 目标字符串 1strTpl('Hello, &#123;&#123;name.first&#125;&#125;!', &#123; name: &#123; first: 'licia' &#125; &#125;); // -&gt; 'Hello, licia!' strWidth获取字符串的可见宽度。 类型定义function strWidth(str: string): number; 参数名 说明 str 要获取宽度的字符串 返回值 可见宽度 12strWidth('Hello \\nworld!'); // -&gt; 12strWidth('\\u001b[4m你好，世界！\\u001b[0m'); // -&gt; 12 stringifyJSON 序列化，支持循环引用和函数。 类型定义function stringify(obj: any, spaces?: number): string; undefined 被当作 null 处理。 参数名 说明 obj 目标对象 spaces 缩进 返回值 序列化后的字符串 1234stringify(&#123; a: function() &#123;&#125; &#125;); // -&gt; '&#123;\"a\":\"[Function function () &#123;&#125;]\"&#125;'const obj = &#123; a: 1, b: &#123;&#125; &#125;;obj.b = obj;stringify(obj); // -&gt; '&#123;\"a\":1,\"b\":\"[Circular ~]\"&#125;' stringifyAll序列化对象，保留类型信息。 类型定义namespace stringifyAll { function parse(str: string): any;}function stringifyAll( obj: any, options?: { unenumerable?: boolean; symbol?: boolean; accessGetter?: boolean; timeout?: number; depth?: number; ignore?: any[]; }): string; 参数名 说明 obj 源对象 options 序列化选项 返回值 序列化后的字符串 可用选项： 参数名 说明 unenumerable=false 包含不可枚举值 symbol=false 包含 Symbol 键名 accessGetter=false 获取 getter 值 timeout=0 序列化超时时间 depth=0 遍历对象的最大深度 ignore 忽略的对象 超时后，所有未序列化的值都会变成 “Timeout”。 parse将字符串反序列化回对象。 参数名 说明 obj 序列化后的字符串 返回值 目标对象 1stringifyAll(function test() &#123;&#125;); // -&gt; '&#123;\"value\":\"function test() &#123;&#125;\",\"type\":\"Function\",...&#125;' stripAnsi清除字符串中的 ansi 控制码。 类型定义function stripAnsi(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1stripAnsi('\\u001b[4mcake\\u001b[0m'); // -&gt; 'cake' stripCmt清除源码中的注释。 类型定义function stripCmt(str: string): string; 参数名 说明 str 源码 返回值 无注释代码 1stripCmt('// comment \\n var a = 5; \\/* comment2\\n * comment3\\n *\\/'); // -&gt; ' var a = 5; ' stripColor清除字符串中的 ansi 颜色控制码。 类型定义function stripColor(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1stripColor('\\u001b[31mred\\u001b[39m'); // -&gt; 'red' stripHtmlTag清除字符串中的 html 标签。 类型定义function stripHtmlTag(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1stripHtmlTag('&lt;p&gt;Hello&lt;/p&gt;'); // -&gt; 'Hello' stripIndent清除多行文本的缩进。 类型定义function stripIndent(str: string): string;function stripIndent( literals: TemplateStringsArray, …placeholders: any[]): string; 参数名 说明 str 源字符串 返回值 目标字符串 它可以像函数一样调用，也可以当成标签模板使用。 12345stripIndent` Test string * item one * item two`; // -&gt; 'Test string\\n * item one\\n * item two' stripNum将数字转换为指定的精度。 类型定义function stripNum(num: number, precision?: number): number; 参数名 说明 num 源数字 precision=12 精度 返回值 目标数字 1stripNum(0.1 + 0.2); // -&gt; 0.3 sum计算数字和。 类型定义function sum(…num: number[]): number; 参数名 说明 …num 要计算的数字 返回值 数字和 1sum(1, 2, 5); // -&gt; 8 swap交换数组中的两项。 类型定义function swap(arr: any[], a: number, b: number): any[]; 参数名 说明 arr 目标数组 a 序号一 b 序号二 返回值 数组本身 12const arr = [1, 2];swap(arr, 0, 1); // -&gt; [2, 1] table输出表格字符串。 类型定义function table(rows: Array&lt;string[]&gt;): string; 参数名 说明 rows 表格数据 返回值 表格字符串 123456table([ ['', 'firstName', 'lastName'], ['daughter', 'Emily', 'Smith'], ['father', 'John', 'Smith'], ['mother', 'Jane', 'Smith']]); template将模板字符串编译成函数用于渲染。 类型定义function template(str: string, util?: any): types.AnyFn; 参数名 说明 str 模板字符串 util 模板函数 返回值 编译后的模板函数 12345678template('Hello &lt;%= name %&gt;!')(&#123; name: 'licia' &#125;); // -&gt; 'Hello licia!'template('&lt;p&gt;&lt;%- name %&gt;&lt;/p&gt;')(&#123; name: '&lt;licia&gt;' &#125;); // -&gt; '&lt;p&gt;&amp;lt;licia&amp;gt;&lt;/p&gt;'template('&lt;%if (echo) &#123;%&gt;Hello licia!&lt;%&#125;%&gt;')(&#123; echo: true &#125;); // -&gt; 'Hello licia!'template('&lt;p&gt;&lt;%= util[\"upperCase\"](name) %&gt;&lt;/p&gt;', &#123; upperCase: function(str) &#123; return str.toLocaleUpperCase(); &#125;&#125;)(&#123; name: 'licia' &#125;); // -&gt; '&lt;p&gt;LICIA&lt;/p&gt;' throttle返回函数的节流阀版本。 类型定义function throttle&lt;T extends types.AnyFn&gt;(fn: T, wait: number): T; 参数名 说明 fn 源函数 wait 延迟毫秒数 返回值 目标函数 12const updatePos = throttle(function() &#123;&#125;, 100);// $(window).scroll(updatePos); throughstream Transform 类的简单包装。 类型定义import stream = require(&#x27;stream&#x27;);namespace through { interface ThroughConstructor extends stream.Transform { new (opts?: stream.DuplexOptions): stream.Transform; (opts?: stream.DuplexOptions): stream.Transform; } type TransformCallback = (err?: any, data?: any) =&gt; void; type TransformFunction = ( this: stream.Transform, chunk: any, enc: string, callback: TransformCallback ) =&gt; void; type FlushCallback = ( this: stream.Transform, flushCallback: () =&gt; void ) =&gt; void; function obj( transform?: TransformFunction, flush?: FlushCallback ): stream.Transform; function ctor( transform?: TransformFunction, flush?: FlushCallback ): ThroughConstructor; function ctor( opts?: stream.DuplexOptions, transform?: TransformFunction, flush?: FlushCallback ): ThroughConstructor;}function through( transform?: through.TransformFunction, flush?: through.FlushCallback): stream.Transform;function through( opts?: stream.DuplexOptions, transform?: through.TransformFunction, flush?: through.FlushCallback): stream.Transform; 参数名 说明 opts={} 初始化流选项 transform Transform 实现 flush Flush 实现 obj设置 objectMode 为真的快捷方式。 ctor返回继承 Transform 的类。 12345678910const fs = require('fs');fs.createReadStream('in.txt') .pipe( through(function(chunk, enc, cb) &#123; // Do something to chunk this.push(chunk); cb(); &#125;) ) .pipe(fs.createWriteStream('out.txt')); timeAgo将时间格式化成多久之前的形式。 类型定义function timeAgo( date: Date | number, now?: Date | number): string; 参数名 说明 date 目标日期 now=new Date 当时日期 返回值 格式化时间表示 1234const now = new Date().getTime();timeAgo(now - 1000 * 6); // -&gt; right nowtimeAgo(now + 1000 * 15); // -&gt; in 15 minutestimeAgo(now - 1000 * 60 * 60 * 5, now); // -&gt; 5 hours ago timeTaken获取函数的执行时间。 类型定义function timeTaken(fn: types.AnyFn): number; 参数名 说明 fn 要计算执行时间的函数 返回值 执行时间，单位毫秒 123timeTaken(function() &#123; // Do something.&#125;); // -&gt; Time taken to execute given function. times调用目标函数 n 次。 类型定义function times&lt;T&gt;( n: number, fn: (n: number) =&gt; T, ctx?: any): T[]; 参数名 说明 n 调用次数 fn 目标函数 ctx 函数上下文 返回值 结果数组 1times(3, String); // -&gt; ['0', '1', '2'] toArr将任意值转换为数组。 类型定义function toArr(val: any): any[]; 参数名 说明 val 要转换的值 返回值 转换后的数组 1234toArr(&#123; a: 1, b: 2 &#125;); // -&gt; [&#123;a: 1, b: 2&#125;]toArr('abc'); // -&gt; ['abc']toArr(1); // -&gt; [1]toArr(null); // -&gt; [] toAsync让 generator 可以像 async/await 一样使用。 类型定义function toAsync(fn: types.AnyFn): types.AnyFn; 参数名 说明 fn Generator 函数 返回值 目标函数 12345678const sleep = require('licia/sleep');const fn = toAsync(function*() &#123; yield sleep(200); return 'licia';&#125;);fn().then(str =&gt; &#123;&#125;); toBool将任意值转换为布尔值。 类型定义function toBool(val: any): boolean; 参数名 说明 val 要转换的值 返回值 转换后的布尔值 1234567toBool(true); // -&gt; truetoBool(null); // -&gt; falsetoBool(1); // -&gt; truetoBool(0); // -&gt; falsetoBool('0'); // -&gt; falsetoBool('1'); // -&gt; truetoBool('false'); // -&gt; false toDate将任意值转换为日期类型。 类型定义function toDate(val: any): Date; 参数名 说明 val 要转换的值 返回值 转换后的日期值 123toDate('20180501');toDate('2018-05-01');toDate(1525107450849); toEl将 html 字符串转换为 dom 元素。 类型定义function toEl(str: string): Element; 必须只有一个根元素。 参数名 说明 str html 字符串 返回值 html 元素 1toEl('&lt;div&gt;test&lt;/div&gt;'); toInt将任意值转换为整数。 类型定义function toInt(val: any): number; 参数名 说明 val 要转换的值 返回值 转换后的整数 12toInt(1.1); // -&gt; 1toInt(undefined); // -&gt; 0 toNum将任意值转换为数字。 类型定义function toNum(val: any): number; 参数名 说明 val 要转换的值 返回值 转换后的数字 1toNum('5'); // -&gt; 5 toSrc将函数转换为源码。 类型定义function toSrc(fn: types.AnyFn): string; 参数名 说明 fn 目标函数 返回值 源码 12toSrc(Math.min); // -&gt; 'function min() &#123; [native code] &#125;'toSrc(function() &#123;&#125;); // -&gt; 'function () &#123; &#125;' toStr将任意值转换为字符串。 类型定义function toStr(val: any): string; 参数名 说明 val 要转换的值 返回值 转换后的字符串 1234toStr(null); // -&gt; ''toStr(1); // -&gt; '1'toStr(false); // -&gt; 'false'toStr([1, 2, 3]); // -&gt; '1,2,3' topoSort拓扑排序实现。 类型定义function topoSort(edges: any[]): any[]; 参数名 说明 edges 依赖关系 返回值 排序后的数组 12345topoSort([ [1, 2], [1, 3], [3, 2]]); // -&gt; [1, 3, 2] trigger触发浏览器事件。 类型定义function trigger(el: Element, type: string, options?: any);function trigger(type: string, options?: any); 参数名 说明 el=document 目标元素 type 事件类型 options 选项 12trigger(document.getElementById('test'), 'mouseup');trigger('keydown', &#123; keyCode: 65 &#125;); trim删除字符串两边指定字符或空格。 类型定义function trim(str: string, chars?: string | string[]): string; 参数名 说明 str 源字符串 chars 删除字符 返回值 目标字符串 123trim(' abc '); // -&gt; 'abc'trim('_abc_', '_'); // -&gt; 'abc'trim('_abc_', ['a', 'c', '_']); // -&gt; 'b' truncate截取字符串，使其长度为指定值。 类型定义function truncate( txt: string, width: number, options?: { ellipsis?: string; separator: string; }): string; 参数名 说明 txt 要截取的字符串 width 最大字符串长度 options 选项 返回值 截取后的字符串 选项： 参数名 说明 ellipsis=’…’ 表示截取掉部分的符号 separator 分隔符，尽可能使截取位置在该处 12345truncate('ORA ORA ORA ORA ORA ORA', 12); // -&gt; 'ORA ORA O...'truncate('ORA ORA ORA ORA ORA ORA', 10, &#123; separator: ' ', ellipsis: '……'&#125;); // -&gt; 'ORA ORA……' tryIt在 try catch 块中运行函数。 类型定义function tryIt(fn: types.AnyFn, cb?: types.AnyFn): void; 参数名 说明 fn 目标函数 cb 回调 12345678tryIt( function() &#123; // Do something that might cause an error. &#125;, function(err, result) &#123; if (err) console.log(err); &#125;); type获取 JavaScript 对象的内部类型。 类型定义function type(val: any, lowerCase?: boolean): string; 参数名 说明 val 目标对象 lowerCase=true 是否小写 返回值 对象类型 123456type(5); // -&gt; 'number'type(&#123;&#125;); // -&gt; 'object'type(function() &#123;&#125;); // -&gt; 'function'type([]); // -&gt; 'array'type([], false); // -&gt; 'Array'type(async function() &#123;&#125;, false); // -&gt; 'AsyncFunction' types仅用于生成 ts 定义文件。 类型定义namespace types { interface Collection&lt;T&gt; {} interface List&lt;T&gt; extends Collection&lt;T&gt; { [index: number]: T; length: number; } interface ListIterator&lt;T, TResult&gt; { (value: T, index: number, list: List&lt;T&gt;): TResult; } interface Dictionary&lt;T&gt; extends Collection&lt;T&gt; { [index: string]: T; } interface ObjectIterator&lt;T, TResult&gt; { (element: T, key: string, list: Dictionary&lt;T&gt;): TResult; } interface MemoIterator&lt;T, TResult&gt; { (prev: TResult, curr: T, index: number, list: List&lt;T&gt;): TResult; } interface MemoObjectIterator&lt;T, TResult&gt; { (prev: TResult, curr: T, key: string, list: Dictionary&lt;T&gt;): TResult; } type Fn&lt;T&gt; = (…args: any[]) =&gt; T; type AnyFn = Fn&lt;any&gt;; type PlainObj&lt;T&gt; = { [name: string]: T };}const types: {}; ucs2UCS-2 编解码。 类型定义const ucs2: { encode(arr: number[]): string; decode(str: string): number[];}; encode通过码点序列创建字符串。 参数名 说明 arr 码点序列 返回值 编码后的字符串 decode通过字符串创建码点序列。 参数名 说明 str 字符串 返回值 码点序列 1234ucs2.encode([0x61, 0x62, 0x63]); // -&gt; 'abc'ucs2.decode('abc'); // -&gt; [0x61, 0x62, 0x63]'𝌆'.length; // -&gt; 2ucs2.decode('𝌆').length; // -&gt; 1 uncaught全局错误监听。 类型定义const uncaught: { start(): void; stop(): void; addListener(fn: (err: Error) =&gt; void): void; rmListener(fn: (err: Error) =&gt; void): void; rmAllListeners(): void;}; start开始监听错误。 stop停止监听错误。 addListener添加监听器。 参数名 说明 fn 错误监听器 rmListener移除监听器。 rmAllListeners移除所有监听器。 1234uncaught.start();uncaught.addListener(err =&gt; &#123; // Do something.&#125;); unescape和 escape 相反，转义 HTML 实体回去。 类型定义function unescape(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1unescape('You &amp;amp; Me'); // -&gt; 'You &amp; Me' union返回传入所有数组的并集。 类型定义function union(…arr: Array&lt;any[]&gt;): any[]; 参数名 说明 …arr 要合并的数组 返回值 数组并集 1union([2, 1], [4, 2], [1, 2]); // -&gt; [2, 1, 4] uniqId生成全局唯一 id。 类型定义function uniqId(prefix?: string): string; 参数名 说明 prefix id 前缀 返回值 全局唯一 id 1uniqId('eustia_'); // -&gt; 'eustia_xxx' unique返回数组去重后的副本。 类型定义function unique( arr: any[], cmp?: (a: any, b: any) =&gt; boolean | number): any[]; 参数名 说明 arr 源数组 cmp 比较器 返回值 目标数组 1unique([1, 2, 3, 1]); // -&gt; [1, 2, 3] universalify使用异步函数同时支持 promise 及回调模式。 类型定义function universalify( fn: types.AnyFn, type: string): types.AnyFn; 参数名 说明 fn 异步函数 type 源类型，promise 或 callback 返回值 目标函数 12345678910111213function callbackFn(str, cb) &#123; setTimeout(() =&gt; &#123; cb(null, str); &#125;, 10);&#125;const fn = universalify(callbackFn, 'callback');fn('licia', (err, result) =&gt; &#123; console.log(result); // -&gt; 'licia'&#125;);fn('licia').then(result =&gt; &#123; console.log(result); // -&gt; 'licia'&#125;); unzip与 zip 相反。 类型定义declare function unzip(arr: Array&lt;any[]&gt;): Array&lt;any[]&gt;; 参数名 说明 arr 源数组 返回值 目标数组 1234unzip([ ['a', 1, true], ['b', 2, false]]); // -&gt; [['a', 'b'], [1, 2], [true, false]] upperCase转换字符串为大写。 类型定义function upperCase(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1upperCase('test'); // -&gt; 'TEST' upperFirst将字符串的第一个字符转换为大写。 类型定义function upperFirst(str: string): string; 参数名 说明 str 源字符串 返回值 目标字符串 1upperFirst('red'); // -&gt; Red use使用 define 创建的模块。 类型定义function use(requires: string[], method: types.AnyFn): void;function use(method: types.AnyFn): void; 参数名 说明 requires 依赖 method 要执行的代码 1234// define('A', () =&gt; 'A');use(['A'], function(A) &#123; console.log(A + 'B'); // -&gt; 'AB'&#125;); utf8UTF-8 编解码。 类型定义const utf8: { encode(str: string): string; decode(str: string, safe?: boolean): string;}; encodeUTF-8 编码。 参数名 说明 str 源字符串 返回值 目标字符串 decodeUTF-8 解码。 参数名 说明 str 源字符串 safe=false 如果设为真，不抛错误 返回值 目标字符串 12utf8.encode('\\uD800\\uDC00'); // -&gt; '\\xF0\\x90\\x80\\x80'utf8.decode('\\xF0\\x90\\x80\\x80'); // -&gt; '\\uD800\\uDC00' uuid生成符合 RFC4112 版本 4 协议的 uuid。 类型定义function uuid(): string; 相关标准 RFC4122 4.4。 1uuid(); // -&gt; '53ce0497-6554-49e9-8d79-347406d2a88b' values返回对象所有的属性值。 类型定义function values(obj: any): any[]; 参数名 说明 obj 目标对象 返回值 所有属性值 1values(&#123; one: 1, two: 2 &#125;); // -&gt; [1, 2] viewportScale获取窗口缩放比。 类型定义function viewportScale(): number; 1viewportScale(); // -&gt; 3 vlqvlq 编解码。 类型定义const vlq: { encode(number: number | number[]): string; decode(string: string): number[];}; encode将数字编码为 vlq 字符串。 参数名 说明 number 源数字 返回值 目标字符串 decode将 vlq 字符串解码为数字。 参数名 说明 string 源字符串 返回值 目标数字 1234vlq.encode(123); // -&gt; '2H'vlq.encode([123, 456, 789]); // -&gt; '2HwcqxB'vlq.decode('2H'); // -&gt; [123]vlq.decode('2HwcqxB'); // -&gt; [123, 456, 789] waitUntil等待直到条件函数返回真值。 类型定义function waitUntil( condition: types.AnyFn, timeout?: number, interval?: number): Promise&lt;any&gt;; 参数名 说明 condition 条件函数 timeout=0 超时 interval=250 等待间隔 12345let a = 5;setTimeout(() =&gt; (a = 10), 500);waitUntil(() =&gt; a === 10).then(() =&gt; &#123; console.log(a); // -&gt; 10&#125;); waterfall按顺序执行函数序列。 类型定义function waterfall(tasks: types.AnyFn[], cb?: types.AnyFn): void; 参数名 说明 tasks 函数序列 cb 结束回调 1234567891011121314waterfall( [ function(cb) &#123; cb(null, 'one'); &#125;, function(arg1, cb) &#123; // arg1 -&gt; 'one' cb(null, 'done'); &#125; ], function(err, result) &#123; // result -&gt; 'done' &#125;); wordWrap按照指定长度对字符串进行折行处理。 类型定义function wordWrap(txt: string, width: number): string; 参数名 说明 txt 要折行的字符串 width 最大行宽度 返回值 折行后的字符串 12wordWrap('Licia is a utility library.', 10);// -&gt; 'Licia is \\na utility \\nlibrary.' wordsToBytes将 32 位字长数组转换为字节数组。 类型定义function wordsToBytes(words: number[]): number[]; 参数名 说明 words 字长数组 返回值 字节数组 1wordsToBytes([0x12345678]); // -&gt; [0x12, 0x34, 0x56, 0x78] workerize将函数运行在 worker 线程中。 类型定义function workerize(fn: types.AnyFn): types.AnyFn; 参数名 说明 fn 源函数 返回值 目标函数 123456const worker = workerize(function(a, b) &#123; return a + b;&#125;);worker(1, 2).then(function(value) &#123; console.log(value); // -&gt; 3&#125;); wrap将函数封装到包裹函数里面, 并把它作为第一个参数传给包裹函数。 类型定义function wrap( fn: types.AnyFn, wrapper: types.AnyFn): types.AnyFn; 参数名 说明 fn 要包裹的函数 wrapper 包裹函数 返回值 目标函数 1234const p = wrap(escape, function(fn, text) &#123; return '&lt;p&gt;' + fn(text) + '&lt;/p&gt;';&#125;);p('You &amp; Me'); // -&gt; '&lt;p&gt;You &amp;amp; Me&lt;/p&gt;' wx小程序 wx 对象的 promise 版本。 类型定义const wx: any; 123wx.getStorage('test').then(res =&gt; &#123; console.log(res.data);&#125;); xpath使用 xpath 选择元素，不支持 IE。 类型定义function xpath(xpath: string): HTMLElement[]; 参数名 说明 xpath Xpath 返回值 目标元素集 1xpath('//html/body'); // -&gt; [body] zip将每个数组中相应位置的值合并在一起。 类型定义function zip(…arr: Array&lt;any[]&gt;): Array&lt;any[]&gt;; 参数名 说明 arr 源数组 返回值 目标数组 1zip(['a', 'b'], [1, 2], [true, false]); // -&gt; [['a', 1, true], ['b', 2, false]]","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"工具库licia（一）","slug":"js工具库licia（一）","date":"2022-02-17T01:34:06.000Z","updated":"2024-02-20T07:11:25.730Z","comments":true,"path":"2022/02/17/js工具库licia（一）/","link":"","permalink":"/2022/02/17/js工具库licia（一）/","excerpt":"licia工具库的代码文件","text":"licia工具库的代码文件licia是一款很全的常用工具库，github地址licia。由于直接下载licia源码，相关依赖一直没安装好，所以没有打包成功。直接用npm i licia安装，发现下载下来的是es6的源代码，于是笔者使用rollup打包，licia-rollup。目前使用的licia版本是1.34.0。相对应的使用文档也是1.34.0，licia使用文档下面贴出es模块形式源码一份，便于复制使用1var commonjsGlobal=&quot;undefined&quot;!=typeof globalThis?globalThis:&quot;undefined&quot;!=typeof window?window:&quot;undefined&quot;!=typeof global?global:&quot;undefined&quot;!=typeof self?self:&#123;&#125;;function createCommonjsModule(fn,module)&#123;return fn(module=&#123;exports:&#123;&#125;&#125;,module.exports),module.exports&#125;var isUndef=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return void 0===val&#125;&#125;),objToStr=createCommonjsModule(function(module,exports)&#123;var ObjToStr=Object.prototype.toString;module.exports=function(val)&#123;return ObjToStr.call(val)&#125;&#125;),isNum=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Number]&quot;===objToStr(val)&#125;&#125;),isFn=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;val=objToStr(val);return&quot;[object Function]&quot;===val||&quot;[object GeneratorFunction]&quot;===val||&quot;[object AsyncFunction]&quot;===val&#125;&#125;),isArrLike=createCommonjsModule(function(module,exports)&#123;var MAX_ARR_IDX=Math.pow(2,53)-1;module.exports=function(val)&#123;if(!val)return!1;var len=val.length;return isNum(len)&amp;&amp;0&lt;=len&amp;&amp;len&lt;=MAX_ARR_IDX&amp;&amp;!isFn(val)&#125;&#125;),has=createCommonjsModule(function(module,exports)&#123;var hasOwnProp=Object.prototype.hasOwnProperty;module.exports=function(obj,key)&#123;return hasOwnProp.call(obj,key)&#125;&#125;),keys=createCommonjsModule(function(module,exports)&#123;exports=Object.keys||function(obj)&#123;var key,ret=[];for(key in obj)has(obj,key)&amp;&amp;ret.push(key);return ret&#125;,module.exports=exports&#125;),optimizeCb=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,ctx,argCount)&#123;if(isUndef(ctx))return fn;switch(null==argCount?3:argCount)&#123;case 1:return function(val)&#123;return fn.call(ctx,val)&#125;;case 3:return function(val,idx,collection)&#123;return fn.call(ctx,val,idx,collection)&#125;;case 4:return function(accumulator,val,idx,collection)&#123;return fn.call(ctx,accumulator,val,idx,collection)&#125;&#125;return function()&#123;return fn.apply(ctx,arguments)&#125;&#125;&#125;),each=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,iterator,ctx)&#123;if(iterator=optimizeCb(iterator,ctx),isArrLike(obj))for(i=0,len=obj.length;i&lt;len;i++)iterator(obj[i],i,obj);else for(var _keys=keys(obj),i=0,len=_keys.length;i&lt;len;i++)iterator(obj[_keys[i]],_keys[i],obj);return obj&#125;&#125;),createAssigner=createCommonjsModule(function(module,exports)&#123;module.exports=function(keysFn,defaults)&#123;return function(obj)&#123;return each(arguments,function(src,idx)&#123;0!==idx&amp;&amp;(idx=keysFn(src),each(idx,function(key)&#123;defaults&amp;&amp;!isUndef(obj[key])||(obj[key]=src[key])&#125;))&#125;),obj&#125;&#125;&#125;),isObj=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;var type=typeof val;return!!val&amp;&amp;(&quot;function&quot;==type||&quot;object&quot;==type)&#125;&#125;),getProto=createCommonjsModule(function(module,exports)&#123;var getPrototypeOf=Object.getPrototypeOf,ObjectCtr=&#123;&#125;.constructor;module.exports=function(obj)&#123;if(isObj(obj))&#123;if(getPrototypeOf)return getPrototypeOf(obj);var proto=obj.__proto__;return proto||null===proto?proto:isFn(obj.constructor)?obj.constructor.prototype:obj instanceof ObjectCtr?ObjectCtr.prototype:void 0&#125;&#125;&#125;),isArr=createCommonjsModule(function(module,exports)&#123;exports=Array.isArray||function(val)&#123;return&quot;[object Array]&quot;===objToStr(val)&#125;,module.exports=exports&#125;),extendOwn=createCommonjsModule(function(module,exports)&#123;exports=createAssigner(keys),module.exports=exports&#125;),isMatch=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,src)&#123;var _keys=keys(src),len=_keys.length;if(null==obj)return!len;obj=Object(obj);for(var i=0;i&lt;len;i++)&#123;var key=_keys[i];if(src[key]!==obj[key]||!(key in obj))return!1&#125;return!0&#125;&#125;),matcher=createCommonjsModule(function(module,exports)&#123;module.exports=function(attrs)&#123;return attrs=extendOwn(&#123;&#125;,attrs),function(obj)&#123;return isMatch(obj,attrs)&#125;&#125;&#125;),identity=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return val&#125;&#125;),castPath=createCommonjsModule(function(module,exports)&#123;var regPropName=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([&quot;&apos;])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,regEscapeChar=/\\\\(\\\\)?/g;module.exports=function(str,obj)&#123;if(isArr(str))return str;if(obj&amp;&amp;has(obj,str))return[str];var ret=[];return str.replace(regPropName,function(match,number,quote,str)&#123;ret.push(quote?str.replace(regEscapeChar,&quot;$1&quot;):number||match)&#125;),ret&#125;&#125;),safeGet=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,path)&#123;for(var prop=(path=castPath(path,obj)).shift();!isUndef(prop);)&#123;if(null==(obj=obj[prop]))return;prop=path.shift()&#125;return obj&#125;&#125;),property=createCommonjsModule(function(module,exports)&#123;module.exports=function(path)&#123;return isArr(path)?function(obj)&#123;return safeGet(obj,path)&#125;:(key=path,function(obj)&#123;return null==obj?void 0:obj[key]&#125;);var key&#125;&#125;),safeCb=createCommonjsModule(function(module,exports)&#123;module.exports=function(val,ctx,argCount)&#123;return null==val?identity:isFn(val)?optimizeCb(val,ctx,argCount):(isObj(val)&amp;&amp;!isArr(val)?matcher:property)(val)&#125;&#125;),filter=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,predicate,ctx)&#123;var ret=[];return predicate=safeCb(predicate,ctx),each(obj,function(val,idx,list)&#123;predicate(val,idx,list)&amp;&amp;ret.push(val)&#125;),ret&#125;&#125;),unique=createCommonjsModule(function(module,exports)&#123;function isEqual(a,b)&#123;return a===b&#125;module.exports=function(arr,cmp)&#123;return cmp=cmp||isEqual,filter(arr,function(item,idx,arr)&#123;for(var len=arr.length;++idx&lt;len;)if(cmp(item,arr[idx]))return!1;return!0&#125;)&#125;&#125;),allKeys=createCommonjsModule(function(module,exports)&#123;var getOwnPropertyNames=Object.getOwnPropertyNames,getOwnPropertySymbols=Object.getOwnPropertySymbols;module.exports=function(obj)&#123;var _ref=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,_ref$prototype=_ref.prototype,prototype=void 0===_ref$prototype||_ref$prototype,_ref$prototype=_ref.unenumerable,_ref$prototype=void 0!==_ref$prototype&amp;&amp;_ref$prototype,_ref=_ref.symbol,symbol=void 0!==_ref&amp;&amp;_ref,ret=[];if((_ref$prototype||symbol)&amp;&amp;getOwnPropertyNames)&#123;var getKeys=keys;for(_ref$prototype&amp;&amp;getOwnPropertyNames&amp;&amp;(getKeys=getOwnPropertyNames);ret=ret.concat(getKeys(obj)),symbol&amp;&amp;getOwnPropertySymbols&amp;&amp;(ret=ret.concat(getOwnPropertySymbols(obj))),prototype&amp;&amp;(obj=getProto(obj))&amp;&amp;obj!==Object.prototype;);ret=unique(ret)&#125;else if(prototype)for(var key in obj)ret.push(key);else ret=keys(obj);return ret&#125;&#125;),extend=createCommonjsModule(function(module,exports)&#123;exports=createAssigner(allKeys),module.exports=exports&#125;),map=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,iterator,ctx)&#123;iterator=safeCb(iterator,ctx);for(var _keys=!isArrLike(obj)&amp;&amp;keys(obj),len=(_keys||obj).length,results=Array(len),i=0;i&lt;len;i++)&#123;var curKey=_keys?_keys[i]:i;results[i]=iterator(obj[curKey],curKey,obj)&#125;return results&#125;&#125;),isStr=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object String]&quot;===objToStr(val)&#125;&#125;),toArr=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return val?isArr(val)?val:isArrLike(val)&amp;&amp;!isStr(val)?map(val):[val]:[]&#125;&#125;),create=createCommonjsModule(function(module,exports)&#123;var objCreate=Object.create;module.exports=function(proto)&#123;return isObj(proto)?objCreate?objCreate(proto):(noop.prototype=proto,new noop):&#123;&#125;;function noop()&#123;&#125;&#125;&#125;),inherits=createCommonjsModule(function(module,exports)&#123;module.exports=function(Class,SuperClass)&#123;Class.prototype=create(SuperClass.prototype)&#125;&#125;),isMiniProgram=createCommonjsModule(function(module,exports)&#123;exports=&quot;undefined&quot;!=typeof wx&amp;&amp;isFn(wx.openLocation),module.exports=exports&#125;),Class=createCommonjsModule(function(module,exports)&#123;var Base=(exports=function(methods,statics)&#123;return Base.extend(methods,statics)&#125;).Base=function makeClass(parent,methods,statics)&#123;statics=statics||&#123;&#125;;var className=methods.className||safeGet(methods,&quot;initialize.name&quot;)||&quot;&quot;,ctor=(delete methods.className,function()&#123;var args=toArr(arguments);return this.initialize&amp;&amp;this.initialize.apply(this,args)||this&#125;);if(!isMiniProgram)try&#123;ctor=new Function(&quot;toArr&quot;,&quot;return function &quot;+className+&quot;()&#123;var args = toArr(arguments);return this.initialize ? this.initialize.apply(this, args) || this : this;&#125;;&quot;)(toArr)&#125;catch(e)&#123;&#125;return inherits(ctor,parent),(ctor.prototype.constructor=ctor).extend=function(methods,statics)&#123;return makeClass(ctor,methods,statics)&#125;,ctor.inherits=function(Class)&#123;inherits(ctor,Class)&#125;,ctor.methods=function(methods)&#123;return extend(ctor.prototype,methods),ctor&#125;,ctor.statics=function(statics)&#123;return extend(ctor,statics),ctor&#125;,ctor.methods(methods).statics(statics),ctor&#125;(Object,&#123;className:&quot;Base&quot;,callSuper:function(parent,name,args)&#123;return parent.prototype[name].apply(this,args)&#125;,toString:function()&#123;return this.constructor.name&#125;&#125;);module.exports=exports&#125;),Class_1=Class.Base,restArgs=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,startIdx)&#123;return startIdx=null==startIdx?fn.length-1:+startIdx,function()&#123;for(var len=Math.max(arguments.length-startIdx,0),rest=new Array(len),i=0;i&lt;len;i++)rest[i]=arguments[i+startIdx];switch(startIdx)&#123;case 0:return fn.call(this,rest);case 1:return fn.call(this,arguments[0],rest);case 2:return fn.call(this,arguments[0],arguments[1],rest)&#125;var args=new Array(startIdx+1);for(i=0;i&lt;startIdx;i++)args[i]=arguments[i];return args[startIdx]=rest,fn.apply(this,args)&#125;&#125;&#125;),mergeArr=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(first,arrays)&#123;for(var end=first.length,i=0,len=arrays.length;i&lt;len;i++)for(var arr=arrays[i],j=0,_len=arr.length;j&lt;_len;j++)first[end++]=arr[j];return first.length=end,first&#125;),module.exports=exports&#125;),Select=createCommonjsModule(function(module,exports)&#123;var rootSelect=new(exports=Class(&#123;className:&quot;Select&quot;,initialize:function(selector)&#123;return this.length=0,selector?isStr(selector)?rootSelect.find(selector):void(selector.nodeType&amp;&amp;(this[0]=selector,this.length=1)):this&#125;,find:function(selector)&#123;var ret=new exports;return this.each(function()&#123;mergeArr(ret,this.querySelectorAll(selector))&#125;),ret&#125;,each:function(fn)&#123;return each(this,function(element,idx)&#123;fn.call(element,idx,element)&#125;),this&#125;&#125;))(document);module.exports=exports&#125;),$safeEls=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return toArr(isStr(val)?new Select(val):val)&#125;&#125;),$offset=createCommonjsModule(function(module,exports)&#123;module.exports=function(els)&#123;els=(els=$safeEls(els))[0].getBoundingClientRect();return&#123;left:els.left+window.pageXOffset,top:els.top+window.pageYOffset,width:Math.round(els.width),height:Math.round(els.height)&#125;&#125;&#125;),$show=createCommonjsModule(function(module,exports)&#123;var elDisplay=&#123;&#125;;module.exports=function(els)&#123;els=$safeEls(els),each(els,function(el)&#123;!function(el)&#123;return&quot;none&quot;==getComputedStyle(el,&quot;&quot;).getPropertyValue(&quot;display&quot;)&#125;(el)||(el.style.display=function(elName)&#123;var el,display;elDisplay[elName]||(el=document.createElement(elName),document.documentElement.appendChild(el),display=getComputedStyle(el,&quot;&quot;).getPropertyValue(&quot;display&quot;),el.parentNode.removeChild(el),&quot;none&quot;==display&amp;&amp;(display=&quot;block&quot;),elDisplay[elName]=display);return elDisplay[elName]&#125;(el.nodeName))&#125;)&#125;&#125;),splitCase=createCommonjsModule(function(module,exports)&#123;var regUpperCase=/([A-Z])/g,regSeparator=/[_.\\- ]+/g,regTrim=/(^-)|(-$)/g;module.exports=function(str)&#123;return(str=str.replace(regUpperCase,&quot;-$1&quot;).toLowerCase().replace(regSeparator,&quot;-&quot;).replace(regTrim,&quot;&quot;)).split(&quot;-&quot;)&#125;&#125;),kebabCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return splitCase(str).join(&quot;-&quot;)&#125;&#125;),idxOf=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,val,fromIdx)&#123;return Array.prototype.indexOf.call(arr,val,fromIdx)&#125;&#125;),values=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;var ret=[];return each(obj,function(val)&#123;ret.push(val)&#125;),ret&#125;&#125;),contain=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,val)&#123;return isStr(arr)?-1&lt;arr.indexOf(val):(isArrLike(arr)||(arr=values(arr)),0&lt;=idxOf(arr,val))&#125;&#125;),memoize=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,hashFn)&#123;function memoize(key)&#123;var cache=memoize.cache,address=&quot;&quot;+(hashFn?hashFn.apply(this,arguments):key);return has(cache,address)||(cache[address]=fn.apply(this,arguments)),cache[address]&#125;return memoize.cache=&#123;&#125;,memoize&#125;&#125;),camelCase=createCommonjsModule(function(module,exports)&#123;function capitalize(val,idx)&#123;this[idx]=val.replace(/\\w/,function(match)&#123;return match.toUpperCase()&#125;)&#125;module.exports=function(str)&#123;var str=splitCase(str),ret=str[0];return str.shift(),str.forEach(capitalize,str),ret+=str.join(&quot;&quot;)&#125;&#125;),upperFirst=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return str.length&lt;1?str:str[0].toUpperCase()+str.slice(1)&#125;&#125;),prefix=createCommonjsModule(function(module,exports)&#123;(exports=memoize(function(name)&#123;if(name=name.replace(regPrefixes,&quot;&quot;),name=camelCase(name),has(style,name))return name;for(var i=prefixes.length;i--;)&#123;var prefixName=prefixes[i]+upperFirst(name);if(has(style,prefixName))return prefixName&#125;return name&#125;)).dash=memoize(function(name)&#123;name=exports(name);return(regPrefixes.test(name)?&quot;-&quot;:&quot;&quot;)+kebabCase(name)&#125;);var prefixes=[&quot;O&quot;,&quot;ms&quot;,&quot;Moz&quot;,&quot;Webkit&quot;],regPrefixes=/^(O)|(ms)|(Moz)|(Webkit)|(-o-)|(-ms-)|(-moz-)|(-webkit-)/g,style=document.createElement(&quot;p&quot;).style;module.exports=exports&#125;),prefix_1=prefix.dash,$css=createCommonjsModule(function(module,exports)&#123;var cssNumProps=[&quot;column-count&quot;,&quot;columns&quot;,&quot;font-weight&quot;,&quot;line-weight&quot;,&quot;opacity&quot;,&quot;z-index&quot;,&quot;zoom&quot;];module.exports=function(nodes,name,val)&#123;if(nodes=$safeEls(nodes),isUndef(val)&amp;&amp;isStr(name))return function(node,name)&#123;return node.style[prefix(name)]||getComputedStyle(node,&quot;&quot;).getPropertyValue(name)&#125;(nodes[0],name);var css=name;isObj(css)||((css=&#123;&#125;)[name]=val),function(nodes,css)&#123;each(nodes,function(node)&#123;var cssText=&quot;;&quot;;each(css,function(val,key)&#123;key=prefix.dash(key),cssText+=key+&quot;:&quot;+function(key,val)&#123;return isNum(val)&amp;&amp;!contain(cssNumProps,kebabCase(key))?val+&quot;px&quot;:val&#125;(key,val)+&quot;;&quot;&#125;),node.style.cssText+=cssText&#125;)&#125;(nodes,css)&#125;&#125;),$attr=createCommonjsModule(function(module,exports)&#123;(exports=function(els,name,val)&#123;if(els=$safeEls(els),isUndef(val)&amp;&amp;isStr(name))return function(el,name)&#123;return el.getAttribute(name)&#125;(els[0],name);var attrs=name;isObj(attrs)||((attrs=&#123;&#125;)[name]=val),function(els,attrs)&#123;each(els,function(el)&#123;each(attrs,function(val,name)&#123;el.setAttribute(name,val)&#125;)&#125;)&#125;(els,attrs)&#125;).remove=function(els,names)&#123;els=$safeEls(els),names=toArr(names),each(els,function(node)&#123;each(names,function(name)&#123;node.removeAttribute(name)&#125;)&#125;)&#125;,module.exports=exports&#125;),$attr_1=$attr.remove,$property=createCommonjsModule(function(module,exports)&#123;function propFactory(name)&#123;return function(nodes,val)&#123;var node=(nodes=$safeEls(nodes))[0];if(isUndef(val))return node?node[name]:&quot;&quot;;node&amp;&amp;each(nodes,function(node)&#123;node[name]=val&#125;)&#125;&#125;exports=&#123;html:propFactory(&quot;innerHTML&quot;),text:propFactory(&quot;textContent&quot;),val:propFactory(&quot;value&quot;)&#125;,module.exports=exports&#125;),last=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;var len=arr?arr.length:0;if(len)return arr[len-1]&#125;&#125;),$remove=createCommonjsModule(function(module,exports)&#123;module.exports=function(els)&#123;els=$safeEls(els),each(els,function(el)&#123;var parent=el.parentNode;parent&amp;&amp;parent.removeChild(el)&#125;)&#125;&#125;),$data=createCommonjsModule(function(module,exports)&#123;module.exports=function(nodes,name,val)&#123;var dataName=name;return isStr(name)&amp;&amp;(dataName=&quot;data-&quot;+name),isObj(name)&amp;&amp;(dataName=&#123;&#125;,each(name,function(val,key)&#123;dataName[&quot;data-&quot;+key]=val&#125;)),$attr(nodes,dataName,val)&#125;&#125;),delegate=createCommonjsModule(function(module,exports)&#123;function retTrue()&#123;return!0&#125;function retFalse()&#123;return!1&#125;function trigger(e)&#123;for(var handler,j,matched,handlers=this.events[e.type],handlerQueue=function(e,handlers)&#123;var selector,matches,handler,i,current=e.target,ret=[],delegateCount=handlers.delegateCount;if(current.nodeType)for(;current!==this;current=current.parentNode||this)&#123;for(matches=[],i=0;i&lt;delegateCount;i++)handler=handlers[i],selector=handler.selector+&quot; &quot;,void 0===matches[selector]&amp;&amp;(matches[selector]=contain(this.querySelectorAll(selector),current)),matches[selector]&amp;&amp;matches.push(handler);matches.length&amp;&amp;ret.push(&#123;el:current,handlers:matches&#125;)&#125;delegateCount&lt;handlers.length&amp;&amp;ret.push(&#123;el:this,handlers:handlers.slice(delegateCount)&#125;);return ret&#125;.call(this,e,handlers),i=(e=new exports.Event(e),0);(matched=handlerQueue[i++])&amp;&amp;!e.isPropagationStopped();)for(e.curTarget=matched.el,j=0;(handler=matched.handlers[j++])&amp;&amp;!e.isImmediatePropagationStopped();)!1===handler.handler.apply(matched.el,[e])&amp;&amp;(e.preventDefault(),e.stopPropagation())&#125;exports=&#123;add:function(el,type,selector,fn)&#123;var handlers,fn=&#123;selector:selector,handler:fn&#125;;el.events||(el.events=&#123;&#125;),(handlers=el.events[type])||((handlers=el.events[type]=[]).delegateCount=0,el.addEventListener(type,function()&#123;trigger.apply(el,arguments)&#125;,!1)),selector?handlers.splice(handlers.delegateCount++,0,fn):handlers.push(fn)&#125;,remove:function(el,type,selector,fn)&#123;el=el.events;if(el&amp;&amp;el[type])for(var handler,handlers=el[type],i=handlers.length;i--;)handler=handlers[i],selector&amp;&amp;handler.selector!=selector||handler.handler!=fn||(handlers.splice(i,1),handler.selector&amp;&amp;handlers.delegateCount--)&#125;,Event:Class(&#123;className:&quot;Event&quot;,initialize:function(e)&#123;this.origEvent=e&#125;,isDefaultPrevented:retFalse,isPropagationStopped:retFalse,isImmediatePropagationStopped:retFalse,preventDefault:function()&#123;var e=this.origEvent;this.isDefaultPrevented=retTrue,e&amp;&amp;e.preventDefault&amp;&amp;e.preventDefault()&#125;,stopPropagation:function()&#123;var e=this.origEvent;this.isPropagationStopped=retTrue,e&amp;&amp;e.stopPropagation&amp;&amp;e.stopPropagation()&#125;,stopImmediatePropagation:function()&#123;var e=this.origEvent;this.isImmediatePropagationStopped=retTrue,e&amp;&amp;e.stopImmediatePropagation&amp;&amp;e.stopImmediatePropagation(),this.stopPropagation()&#125;&#125;)&#125;,module.exports=exports&#125;),$event=createCommonjsModule(function(module,exports)&#123;function eventFactory(type)&#123;return function(nodes,event,selector,handler)&#123;nodes=$safeEls(nodes),isUndef(handler)&amp;&amp;(handler=selector,selector=void 0),each(nodes,function(node)&#123;delegate[type](node,event,selector,handler)&#125;)&#125;&#125;exports=&#123;on:eventFactory(&quot;add&quot;),off:eventFactory(&quot;remove&quot;)&#125;,module.exports=exports&#125;),some=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,predicate,ctx)&#123;predicate=safeCb(predicate,ctx);for(var _keys=!isArrLike(obj)&amp;&amp;keys(obj),len=(_keys||obj).length,i=0;i&lt;len;i++)&#123;var key=_keys?_keys[i]:i;if(predicate(obj[key],key,obj))return!0&#125;return!1&#125;&#125;),$class=createCommonjsModule(function(module,exports)&#123;function safeName(name)&#123;return isStr(name)?name.split(/\\s+/):toArr(name)&#125;exports=&#123;add:function(els,name)&#123;els=$safeEls(els);var names=safeName(name);each(els,function(el)&#123;var classList=[];each(names,function(name)&#123;exports.has(el,name)||classList.push(name)&#125;),0!==classList.length&amp;&amp;(el.className+=(el.className?&quot; &quot;:&quot;&quot;)+classList.join(&quot; &quot;))&#125;)&#125;,has:function(els,name)&#123;els=$safeEls(els);var regName=new RegExp(&quot;(^|\\\\s)&quot;+name+&quot;(\\\\s|$)&quot;);return some(els,function(el)&#123;return regName.test(el.className)&#125;)&#125;,toggle:function(els,name)&#123;els=$safeEls(els),each(els,function(el)&#123;if(!exports.has(el,name))return exports.add(el,name);exports.remove(el,name)&#125;)&#125;,remove:function(els,name)&#123;els=$safeEls(els);var names=safeName(name);each(els,function(el)&#123;each(names,function(name)&#123;el.classList.remove(name)&#125;)&#125;)&#125;&#125;,module.exports=exports&#125;),$insert=createCommonjsModule(function(module,exports)&#123;function insertFactory(type)&#123;return function(nodes,val)&#123;nodes=$safeEls(nodes),each(nodes,function(node)&#123;if(isStr(val))node.insertAdjacentHTML(type,val);else&#123;var parentNode=node.parentNode;switch(type)&#123;case&quot;beforebegin&quot;:parentNode&amp;&amp;parentNode.insertBefore(val,node);break;case&quot;afterend&quot;:parentNode&amp;&amp;parentNode.insertBefore(val,node.nextSibling);break;case&quot;beforeend&quot;:node.appendChild(val);break;case&quot;afterbegin&quot;:node.prepend(val)&#125;&#125;&#125;)&#125;&#125;exports=&#123;before:insertFactory(&quot;beforebegin&quot;),after:insertFactory(&quot;afterend&quot;),append:insertFactory(&quot;beforeend&quot;),prepend:insertFactory(&quot;afterbegin&quot;)&#125;,module.exports=exports&#125;),$=createCommonjsModule(function(module,exports)&#123;exports=function(selector)&#123;return new Select(selector)&#125;,Select.methods(&#123;offset:function()&#123;return $offset(this)&#125;,hide:function()&#123;return this.css(&quot;display&quot;,&quot;none&quot;)&#125;,show:function()&#123;return $show(this),this&#125;,first:function()&#123;return exports(this[0])&#125;,last:function()&#123;return exports(last(this))&#125;,get:function(idx)&#123;return this[idx]&#125;,eq:function(idx)&#123;return exports(this[idx])&#125;,on:function(event,selector,handler)&#123;return $event.on(this,event,selector,handler),this&#125;,off:function(event,selector,handler)&#123;return $event.off(this,event,selector,handler),this&#125;,html:function(val)&#123;var result=$property.html(this,val);return isUndef(val)?result:this&#125;,text:function(val)&#123;var result=$property.text(this,val);return isUndef(val)?result:this&#125;,val:function(val)&#123;var result=$property.val(this,val);return isUndef(val)?result:this&#125;,css:function(name,val)&#123;var result=$css(this,name,val);return isGetter(name,val)?result:this&#125;,attr:function(name,val)&#123;var result=$attr(this,name,val);return isGetter(name,val)?result:this&#125;,data:function(name,val)&#123;var result=$data(this,name,val);return isGetter(name,val)?result:this&#125;,rmAttr:function(name)&#123;return $attr.remove(this,name),this&#125;,remove:function()&#123;return $remove(this),this&#125;,addClass:function(name)&#123;return $class.add(this,name),this&#125;,rmClass:function(name)&#123;return $class.remove(this,name),this&#125;,toggleClass:function(name)&#123;return $class.toggle(this,name),this&#125;,hasClass:function(name)&#123;return $class.has(this,name)&#125;,parent:function()&#123;return exports(this[0].parentNode)&#125;,append:function(val)&#123;return $insert.append(this,val),this&#125;,prepend:function(val)&#123;return $insert.prepend(this,val),this&#125;,before:function(val)&#123;return $insert.before(this,val),this&#125;,after:function(val)&#123;return $insert.after(this,val),this&#125;&#125;);var isGetter=function(name,val)&#123;return isUndef(val)&amp;&amp;isStr(name)&#125;;module.exports=exports&#125;),defaults=createCommonjsModule(function(module,exports)&#123;exports=createAssigner(allKeys,!0),module.exports=exports&#125;),slice=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,start,end)&#123;for(var len=arr.length,ret=(start=null==start?0:start&lt;0?Math.max(len+start,0):Math.min(start,len),end=null==end?len:end&lt;0?Math.max(len+end,0):Math.min(end,len),[]);start&lt;end;)ret.push(arr[start++]);return ret&#125;&#125;),partial=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(fn,partials)&#123;return function()&#123;var args=[];return args=(args=args.concat(partials)).concat(toArr(arguments)),fn.apply(this,args)&#125;&#125;),module.exports=exports&#125;),before=createCommonjsModule(function(module,exports)&#123;module.exports=function(n,fn)&#123;var memo;return function()&#123;return 0&lt;--n&amp;&amp;(memo=fn.apply(this,arguments)),n&lt;=1&amp;&amp;(fn=null),memo&#125;&#125;&#125;),once=createCommonjsModule(function(module,exports)&#123;exports=partial(before,2),module.exports=exports&#125;),clone=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;return isObj(obj)?isArr(obj)?obj.slice():extend(&#123;&#125;,obj):obj&#125;&#125;),Emitter=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._events=this._events||&#123;&#125;&#125;,on:function(event,listener)&#123;return this._events[event]=this._events[event]||[],this._events[event].push(listener),this&#125;,off:function(event,listener)&#123;var events=this._events;if(has(events,event))return listener=events[event].indexOf(listener),-1&lt;listener&amp;&amp;events[event].splice(listener,1),this&#125;,once:function(event,listener)&#123;return this.on(event,once(listener)),this&#125;,emit:function(event)&#123;var args,events,_this=this;if(has(this._events,event))return args=slice(arguments,1),events=clone(this._events[event]),each(events,function(val)&#123;return val.apply(_this,args)&#125;,this),this&#125;,removeAllListeners:function(event)&#123;return event?delete this._events[event]:this._events=&#123;&#125;,this&#125;&#125;,&#123;mixin:function(obj)&#123;each([&quot;on&quot;,&quot;off&quot;,&quot;once&quot;,&quot;emit&quot;,&quot;removeAllListeners&quot;],function(val)&#123;obj[val]=exports.prototype[val]&#125;),obj._events=obj._events||&#123;&#125;&#125;&#125;),module.exports=exports&#125;),State=createCommonjsModule(function(module,exports)&#123;exports=Emitter.extend(&#123;className:&quot;State&quot;,initialize:function(initial,events)&#123;this.callSuper(Emitter,&quot;initialize&quot;),this.current=initial;var self=this;each(events,function(event,key)&#123;self[key]=function(name,event)&#123;var from=toArr(event.from),to=event.to;return function()&#123;var args=toArr(arguments);args.unshift(name),some(from,function(val)&#123;return this.current===val&#125;,this)?(this.current=to,this.emit.apply(this,args)):this.emit(&quot;error&quot;,new Error(this.current+&quot; =&gt; &quot;+to+&quot; error&quot;),name)&#125;&#125;(key,event)&#125;)&#125;,is:function(state)&#123;return this.current===state&#125;&#125;),module.exports=exports&#125;),bind=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(fn,ctx,args)&#123;return restArgs(function(callArgs)&#123;return fn.apply(ctx,args.concat(callArgs))&#125;)&#125;),module.exports=exports&#125;),nextTick=createCommonjsModule(function(module,exports)&#123;function ensureCallable(fn)&#123;if(&quot;function&quot;!=typeof fn)throw new TypeError(fn+&quot; is not a function&quot;);return fn&#125;exports=&quot;object&quot;==typeof process&amp;&amp;process.nextTick?process.nextTick:&quot;function&quot;==typeof setImmediate?function(cb)&#123;setImmediate(ensureCallable(cb))&#125;:function(cb)&#123;setTimeout(ensureCallable(cb),0)&#125;,module.exports=exports&#125;),noop=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;&#125;&#125;),_Promise=createCommonjsModule(function(module,exports)&#123;var Promise=exports=Class(&#123;initialize:function(fn)&#123;if(!isObj(this))throw new TypeError(&quot;Promises must be constructed via new&quot;);if(!isFn(fn))throw new TypeError(fn+&quot; is not a function&quot;);var self=this;function assignVal(val)&#123;self._value=val&#125;this._state=new State(&quot;pending&quot;,&#123;fulfill:&#123;from:&quot;pending&quot;,to:&quot;fulfilled&quot;&#125;,reject:&#123;from:&quot;pending&quot;,to:&quot;rejected&quot;&#125;,adopt:&#123;from:&quot;pending&quot;,to:&quot;adopted&quot;&#125;&#125;).on(&quot;fulfill&quot;,assignVal).on(&quot;reject&quot;,assignVal).on(&quot;adopt&quot;,assignVal),this._handled=!1,this._value=void 0,this._deferreds=[],doResolve(fn,this)&#125;,catch:function(onRejected)&#123;return this.then(null,onRejected)&#125;,then:function(onFulfilled,onRejected)&#123;var promise=new Promise(noop);return handle(this,new Handler(onFulfilled,onRejected,promise)),promise&#125;&#125;,&#123;all:function(arr)&#123;var args=toArr(arr);return new Promise(function(resolve,reject)&#123;if(0===args.length)return resolve([]);var remaining=args.length;for(var i=0;i&lt;args.length;i++)!function res(i,val)&#123;try&#123;if(val&amp;&amp;(isObj(val)||isFn(val)))&#123;var then=val.then;if(isFn(then))return void then.call(val,function(val)&#123;res(i,val)&#125;,reject)&#125;args[i]=val,0==--remaining&amp;&amp;resolve(args)&#125;catch(e)&#123;reject(e)&#125;&#125;(i,args[i])&#125;)&#125;,resolve:function(val)&#123;return val&amp;&amp;isObj(val)&amp;&amp;val.constructor===Promise?val:new Promise(function(resolve)&#123;resolve(val)&#125;)&#125;,reject:function(val)&#123;return new Promise(function(resolve,reject)&#123;reject(val)&#125;)&#125;,race:function(values)&#123;return new Promise(function(resolve,reject)&#123;for(var i=0,len=values.length;i&lt;len;i++)values[i].then(resolve,reject)&#125;)&#125;&#125;),Handler=Class(&#123;initialize:function(onFulfilled,onRejected,promise)&#123;this.onFulfilled=isFn(onFulfilled)?onFulfilled:null,this.onRejected=isFn(onRejected)?onRejected:null,this.promise=promise&#125;&#125;);function reject(self,err)&#123;self._state.reject(err),finale(self)&#125;function resolve(self,val)&#123;try&#123;if(val===self)throw new TypeError(&quot;A promise cannot be resolved with itself&quot;);if(val&amp;&amp;(isObj(val)||isFn(val)))&#123;var then=val.then;if(val instanceof Promise)return self._state.adopt(val),finale(self);if(isFn(then))return doResolve(bind(then,val),self)&#125;self._state.fulfill(val),finale(self)&#125;catch(e)&#123;reject(self,e)&#125;&#125;function finale(self)&#123;for(var i=0,len=self._deferreds.length;i&lt;len;i++)handle(self,self._deferreds[i]);self._deferreds=null&#125;function handle(self,deferred)&#123;for(;self._state.is(&quot;adopted&quot;);)self=self._value;if(self._state.is(&quot;pending&quot;))return self._deferreds.push(deferred);self._handled=!0,nextTick(function()&#123;var ret,isFulfilled=self._state.is(&quot;fulfilled&quot;),cb=isFulfilled?deferred.onFulfilled:deferred.onRejected;if(null===cb)return(isFulfilled?resolve:reject)(deferred.promise,self._value);try&#123;ret=cb(self._value)&#125;catch(e)&#123;return reject(deferred.promise,e)&#125;resolve(deferred.promise,ret)&#125;)&#125;function doResolve(fn,self)&#123;var done=!1;try&#123;fn(function(val)&#123;done||(done=!0,resolve(self,val))&#125;,function(reason)&#123;done||(done=!0,reject(self,reason))&#125;)&#125;catch(e)&#123;if(done)return;done=!0,reject(self,e)&#125;&#125;module.exports=exports&#125;),now=createCommonjsModule(function(module,exports)&#123;exports=Date.now||function()&#123;return(new Date).getTime()&#125;,module.exports=exports&#125;),isBrowser=createCommonjsModule(function(module,exports)&#123;exports=&quot;object&quot;==typeof window&amp;&amp;&quot;object&quot;==typeof document&amp;&amp;9===document.nodeType,module.exports=exports&#125;),root=createCommonjsModule(function(module,exports)&#123;exports=isBrowser?window:commonjsGlobal,module.exports=exports&#125;),perfNow=createCommonjsModule(function(module,exports)&#123;var getNanoSeconds,loadTime,performance=root.performance,process=root.process;exports=performance&amp;&amp;performance.now?function()&#123;return performance.now()&#125;:process&amp;&amp;process.hrtime?(loadTime=(getNanoSeconds=function()&#123;var hr=process.hrtime();return 1e9*hr[0]+hr[1]&#125;)()-1e9*process.uptime(),function()&#123;return(getNanoSeconds()-loadTime)/1e6&#125;):(loadTime=now(),function()&#123;return now()-loadTime&#125;),module.exports=exports&#125;),delay=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(fn,wait,args)&#123;return setTimeout(function()&#123;return fn.apply(null,args)&#125;,wait)&#125;),module.exports=exports&#125;),average=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var arr=arguments,sum=0,len=arr.length,i=0;i&lt;len;i++)sum+=arr[i];return sum/len&#125;&#125;),reduce=createCommonjsModule(function(module,exports)&#123;function createReduce(dir)&#123;return function(obj,iterator,initial,ctx)&#123;var key;if(iterator=optimizeCb(iterator,ctx),isArrLike(obj))for(len=obj.length,i=0&lt;dir?0:len-1,isUndef(initial)&amp;&amp;(initial=obj[i],i+=dir);i&lt;len&amp;&amp;0&lt;=i;i+=dir)initial=iterator(initial,obj[i],i,obj);else&#123;var _keys=keys(obj),len=_keys.length,i=0&lt;dir?0:len-1;for(isUndef(initial)&amp;&amp;(initial=obj[_keys[i]],i+=dir);i&lt;len&amp;&amp;0&lt;=i;i+=dir)initial=iterator(initial,obj[key=_keys[i]],key,obj)&#125;return initial&#125;&#125;(exports=createReduce(1)).create=createReduce,module.exports=exports&#125;),reduce_1=reduce.create,stripAnsi=createCommonjsModule(function(module,exports)&#123;var regAnsi=/[\\u001b\\u009b][[()#;?]*(?:[0-9]&#123;1,4&#125;(?:;[0-9]&#123;0,4&#125;)*)?[0-9A-ORZcf-nqry=&gt;&lt;]/g;module.exports=function(str)&#123;return str.replace(regAnsi,&quot;&quot;)&#125;&#125;),isInt=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return isNum(val)&amp;&amp;val%1==0&#125;&#125;),isFullWidth=createCommonjsModule(function(module,exports)&#123;module.exports=function(c)&#123;return!!isInt(c)&amp;&amp;(4352&lt;=c&amp;&amp;(c&lt;=4447||9001===c||9002===c||11904&lt;=c&amp;&amp;c&lt;=12871&amp;&amp;12351!==c||12880&lt;=c&amp;&amp;c&lt;=19903||19968&lt;=c&amp;&amp;c&lt;=42182||43360&lt;=c&amp;&amp;c&lt;=43388||44032&lt;=c&amp;&amp;c&lt;=55203||63744&lt;=c&amp;&amp;c&lt;=64255||65040&lt;=c&amp;&amp;c&lt;=65049||65072&lt;=c&amp;&amp;c&lt;=65131||65281&lt;=c&amp;&amp;c&lt;=65376||65504&lt;=c&amp;&amp;c&lt;=65510||110592&lt;=c&amp;&amp;c&lt;=110593||127488&lt;=c&amp;&amp;c&lt;=127569||131072&lt;=c&amp;&amp;c&lt;=262141))&#125;&#125;),strWidth=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;for(var width=0,i=0,len=(str=stripAnsi(str)).length;i&lt;len;i++)&#123;var c=str.codePointAt(i);c&lt;=31||127===c||(width+=isFullWidth(c)?2:1)&#125;return width&#125;&#125;),repeat=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,n)&#123;var ret=&quot;&quot;;if(n&lt;1)return&quot;&quot;;for(;0&lt;n;)1&amp;n&amp;&amp;(ret+=str),n&gt;&gt;=1,str+=str;return ret&#125;&#125;),mapObj=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,iterator,ctx)&#123;iterator=safeCb(iterator,ctx);for(var _keys=keys(obj),len=_keys.length,ret=&#123;&#125;,i=0;i&lt;len;i++)&#123;var curKey=_keys[i];ret[curKey]=iterator(obj[curKey],curKey,obj)&#125;return ret&#125;&#125;),cloneDeep=createCommonjsModule(function(module,exports)&#123;module.exports=exports=function(obj)&#123;return isArr(obj)?obj.map(exports):isObj(obj)&amp;&amp;!isFn(obj)?mapObj(obj,exports):obj&#125;&#125;),table=createCommonjsModule(function(module,exports)&#123;function loopData(rows,handler)&#123;for(var i=0,len=rows.length;i&lt;len;i++)for(var row=rows[i],j=0,_len=row.length;j&lt;_len;j++)&#123;var data=handler(row[j],i,j);data&amp;&amp;(row[j]=data)&#125;&#125;function renderBorder(type,options)&#123;var border=options.border,options=options.columns,left=border[type+&quot;Left&quot;],right=border[type+&quot;Right&quot;],body=border[type+&quot;Body&quot;],border=border[type+&quot;Join&quot;],left=left+(left=map(options,function(column)&#123;return repeat(body,column.width)&#125;).join(border))+right;return&quot;bottom&quot;!==type&amp;&amp;(left+=&quot;\\n&quot;),left&#125;var defBorder=&#123;topBody:&quot;─&quot;,topJoin:&quot;┬&quot;,topLeft:&quot;┌&quot;,topRight:&quot;┐&quot;,bottomBody:&quot;─&quot;,bottomJoin:&quot;┴&quot;,bottomLeft:&quot;└&quot;,bottomRight:&quot;┘&quot;,bodyLeft:&quot;│&quot;,bodyRight:&quot;│&quot;,bodyJoin:&quot;│&quot;,joinBody:&quot;─&quot;,joinLeft:&quot;├&quot;,joinRight:&quot;┤&quot;,joinJoin:&quot;┼&quot;&#125;;module.exports=function(rows)&#123;rows=cloneDeep(rows);var options=&#123;border:defBorder&#125;;return options.columns=function(rows)&#123;var columns=[];return loopData(rows,function(data,row,column)&#123;columns[column]=columns[column]||&#123;width:2,paddingLeft:1,paddingRight:1&#125;;data=strWidth(data)+1+1;data&gt;columns[column].width&amp;&amp;(columns[column].width=data)&#125;),columns&#125;(rows),function(rows,options)&#123;for(var columnCount=options.columns.length,i=0,len=rows.length;i&lt;len;i++)for(;rows[i].length&lt;columnCount;)rows[i].push(&quot;&quot;);loopData(rows,function(data,row,column)&#123;var column=options.columns[column],paddingLeft=column.paddingLeft,width=column.width,column=column.paddingRight;return repeat(&quot; &quot;,paddingLeft)+data+repeat(&quot; &quot;,width-strWidth(data)-column)&#125;)&#125;(rows,options),function(rows,options)&#123;var ret=&quot;&quot;;return ret+=renderBorder(&quot;top&quot;,options),each(rows,function(row,idx)&#123;ret+=function(columns,options)&#123;options=options.border;return options.bodyLeft+columns.join(options.bodyJoin)+options.bodyRight+&quot;\\n&quot;&#125;(row,options),idx===rows.length-1?ret+=renderBorder(&quot;bottom&quot;,options):ret+=renderBorder(&quot;join&quot;,options)&#125;),ret&#125;(rows,options)&#125;&#125;),toStr=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return null==val?&quot;&quot;:val.toString()&#125;&#125;),Benchmark=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(fn)&#123;var options=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;;defaults(options,defOpts),this._fn=fn,this._isRunning=!1,this._options=options&#125;,run:function()&#123;var _this=this;if(this._isRunning)return this._pendingPromise;this._reset(),this._isRunning=!0;var options=this._options,pendingPromise=new _Promise(function(resolve,reject)&#123;function runSample()&#123;var initCount=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:1;delay(function()&#123;_this._runSample(initCount).then(function(_ref)&#123;var period=_ref.period,_ref=_ref.count,sample=_this._sample;sample.push(period),perfNow()-_this._timeStamp&lt;options.maxTime||sample.length&lt;options.minSamples?runSample(_ref):resolve(_this._calcResult())&#125;).catch(function(err)&#123;reject(err)&#125;)&#125;,options.delay)&#125;runSample()&#125;);function complete()&#123;this._isRunning=!1,delete this._pendingPromise&#125;return pendingPromise.then(complete).catch(complete),this._pendingPromise=pendingPromise&#125;,_reset:function()&#123;this._timeStamp=perfNow(),this._sample=[]&#125;,_calcResult:function()&#123;var sample=this._sample,result=&#123;sample:sample,toString:function()&#123;var hz=this.hz,rme=this.rme,name=this.name,size=this.sample.length;return&quot;&quot;.concat(name,&quot; x &quot;).concat(formatNumber(hz.toFixed(hz&lt;100?2:0)),&quot; ops/sec ±&quot;).concat(rme.toFixed(2),&quot;% (&quot;).concat(size,&quot; run&quot;).concat(1===size?&quot;&quot;:&quot;s&quot;,&quot; sampled)&quot;)&#125;&#125;,size=sample.length;result.name=this._options.name||this._fn.name||&quot;anonymous&quot;,result.mean=average.apply(null,sample),result.variance=reduce(sample,function(sum,x)&#123;return sum+Math.pow(x-result.mean,2)&#125;,0)/(size-1)||0,result.deviation=Math.sqrt(result.variance),result.sem=result.deviation/Math.sqrt(size);sample=tTable[Math.round(size-1)||1]||tTable.infinity;return result.moe=result.sem*sample,result.rme=result.moe/result.mean*100||0,result.hz=1e3/result.mean,result&#125;,_runSample:function(count)&#123;var _this2=this,options=this._options,minTime=options.minTime;return new _Promise(function(resolve,reject)&#123;function runCycle(count)&#123;delay(function()&#123;var elapsed=0;try&#123;elapsed=_this2._runCycle(count)&#125;catch(e)&#123;return reject(e)&#125;var period=elapsed/count;elapsed&lt;minTime?(0===elapsed?count*=100:count+=Math.ceil((minTime-elapsed)/period),runCycle(count)):resolve(&#123;count:count,period:period&#125;)&#125;,options.delay)&#125;runCycle(count)&#125;)&#125;,_runCycle:function(count)&#123;for(var fn=this._fn,now=perfNow();count--;)fn();return perfNow()-now&#125;&#125;,&#123;all:function(benches,options)&#123;var promises=[];return each(benches,function(bench)&#123;bench instanceof exports||(bench=new exports(bench,options)),promises.push(bench.run())&#125;),_Promise.all(promises).then(function(results)&#123;return results.toString=function()&#123;var data=map(results,function(_ref2,idx)&#123;var name=_ref2.name,sample=_ref2.sample,hz=_ref2.hz,_ref2=_ref2.rme,columns=[],sample=sample.length;return columns.push(toStr(idx+1),name||&quot;anonymous&quot;,formatNumber(hz.toFixed(hz&lt;100?2:0)),&quot;±&quot;.concat(_ref2.toFixed(2),&quot;%&quot;),&quot;&quot;.concat(sample,&quot; run&quot;).concat(1===sample?&quot;&quot;:&quot;s&quot;)),columns&#125;);return data.unshift([&quot;index&quot;,&quot;name&quot;,&quot;ops/sec&quot;,&quot;rme&quot;,&quot;sampled&quot;]),table(data)&#125;,results&#125;)&#125;&#125;);var defOpts=&#123;minTime:50,maxTime:5e3,minSamples:5,delay:5,name:&quot;&quot;&#125;,tTable=&#123;1:12.706,2:4.303,3:3.182,4:2.776,5:2.571,6:2.447,7:2.365,8:2.306,9:2.262,10:2.228,11:2.201,12:2.179,13:2.16,14:2.145,15:2.131,16:2.12,17:2.11,18:2.101,19:2.093,20:2.086,21:2.08,22:2.074,23:2.069,24:2.064,25:2.06,26:2.056,27:2.052,28:2.048,29:2.045,30:2.042,infinity:1.96&#125;;function formatNumber(number)&#123;return(number=String(number).split(&quot;.&quot;))[0].replace(/(?=(?:\\d&#123;3&#125;)+$)(?!\\b)/g,&quot;,&quot;)+(number[1]?&quot;.&quot;+number[1]:&quot;&quot;)&#125;module.exports=exports&#125;),Blob$1=createCommonjsModule(function(module,exports)&#123;exports=root.Blob||function(parts,options)&#123;options=options||&#123;&#125;;var blobBuilder=new BlobBuilder;return each(parts,function(part)&#123;blobBuilder.append(part)&#125;),options.type?blobBuilder.getBlob(options.type):blobBuilder.getBlob()&#125;;var BlobBuilder=root.BlobBuilder||root.WebKitBlobBuilder||root.MSBlobBuilder||root.MozBlobBuilder;module.exports=exports&#125;),fill=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,val,start,end)&#123;var len=arr.length;if(!len)return[];for(isUndef(end)&amp;&amp;(end=len),isUndef(start)&amp;&amp;(start=0);start&lt;end;)arr[start++]=val;return arr&#125;&#125;),fnv1a=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;for(var ret=2166136261,i=0,len=str.length;i&lt;len;i++)ret=(ret^=str.charCodeAt(i))+((ret&lt;&lt;1)+(ret&lt;&lt;4)+(ret&lt;&lt;7)+(ret&lt;&lt;8)+(ret&lt;&lt;24));return ret&gt;&gt;&gt;0&#125;&#125;),strHash=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;for(var hash=5381,i=str.length;i;)hash=(hash&lt;&lt;5)+hash+str.charCodeAt(--i);return hash&gt;&gt;&gt;0&#125;&#125;),BloomFilter=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;var size=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:1024,k=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:3;this._buckets=fill(new Array(size),0),this._k=k,this._size=size&#125;,add:function(val)&#123;var _this=this;each(this._locations(val),function(location)&#123;return _this._buckets[location]=1&#125;)&#125;,test:function(val)&#123;var _this2=this;return!some(this._locations(val),function(location)&#123;return 0===_this2._buckets[location]&#125;)&#125;,_locations:function(val)&#123;for(var ret=[],size=this._size,a=fnv1a(val),b=strHash(val),i=0;i&lt;this._k;i++)ret[i]=(a+b*i)%size;return console.log(ret),ret&#125;&#125;),module.exports=exports&#125;),lowerCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return toStr(str).toLocaleLowerCase()&#125;&#125;),Caseless=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(obj)&#123;this._target=obj&#125;,set:function(key,val)&#123;var name=this.getKey(key);this._target[key=name?name:key]=val&#125;,get:function(key)&#123;if(key=this.getKey(key))return this._target[key]&#125;,getKey:function(key)&#123;for(var name=lowerCase(key),_keys=keys(this._target),i=0,len=_keys.length;i&lt;len;i++)&#123;var _key=_keys[i];if(lowerCase(_key)===name)return _key&#125;&#125;,remove:function(key)&#123;delete this._target[this.getKey(key)]&#125;,has:function(key)&#123;return!!this.getKey(key)&#125;&#125;),module.exports=exports&#125;),clamp=createCommonjsModule(function(module,exports)&#123;module.exports=function(n,lower,upper)&#123;return isUndef(upper)&amp;&amp;(upper=lower,lower=void 0),!isUndef(lower)&amp;&amp;n&lt;lower?lower:upper&lt;n?upper:n&#125;&#125;),rgbToHsl=createCommonjsModule(function(module,exports)&#123;var mMin=Math.min,mMax=Math.max,round=Math.round;module.exports=function(rgb)&#123;var r=rgb[0]/255,g=rgb[1]/255,b=rgb[2]/255,min=mMin(r,g,b),max=mMax(r,g,b),delta=max-min,b=max===min?0:r===max?(g-b)/delta:g===max?2+(b-r)/delta:4+(r-g)/delta,r=((b=mMin(60*b,360))&lt;0&amp;&amp;(b+=360),(min+max)/2),g=max===min?0:r&lt;=.5?delta/(max+min):delta/(2-max-min),delta=[round(b),round(100*g),round(100*r)];return rgb[3]&amp;&amp;(delta[3]=rgb[3]),delta&#125;&#125;),hslToRgb=createCommonjsModule(function(module,exports)&#123;var round=Math.round;module.exports=function(hsl)&#123;var t3,val,h=hsl[0]/360,s=hsl[1]/100,l=hsl[2]/100,ret=[];if(hsl[3]&amp;&amp;(ret[3]=hsl[3]),0==s)return val=round(255*l),ret[0]=ret[1]=ret[2]=val,ret;for(var t2,t1=2*l-(t2=l&lt;.5?l*(1+s):l+s-l*s),i=0;i&lt;3;i++)(t3=h+1/3*-(i-1))&lt;0&amp;&amp;t3++,1&lt;t3&amp;&amp;t3--,ret[i]=round(255*(val=6*t3&lt;1?t1+6*(t2-t1)*t3:2*t3&lt;1?t2:3*t3&lt;2?t1+(t2-t1)*(2/3-t3)*6:t1));return ret&#125;&#125;),isOdd=createCommonjsModule(function(module,exports)&#123;module.exports=function(num)&#123;return!!isInt(num)&amp;&amp;num%2!=0&#125;&#125;),hex=createCommonjsModule(function(module,exports)&#123;module.exports=&#123;encode:function(bytes)&#123;for(var hex=[],i=0,len=bytes.length;i&lt;len;i++)&#123;var byte=bytes[i];hex.push((byte&gt;&gt;&gt;4).toString(16)),hex.push((15&amp;byte).toString(16))&#125;return hex.join(&quot;&quot;)&#125;,decode:function(str)&#123;var bytes=[],len=str.length;isOdd(len)&amp;&amp;len--;for(var i=0;i&lt;len;i+=2)bytes.push(parseInt(str.substr(i,2),16));return bytes&#125;&#125;&#125;),Color=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(color)&#123;isStr(color)&amp;&amp;(color=exports.parse(color)),this.model=color.model,this.val=color.val&#125;,toRgb:function()&#123;var val=this.val,prefix=&quot;rgba&quot;;return 1===(val=&quot;hsl&quot;===this.model?hslToRgb(val):val)[3]&amp;&amp;(prefix=&quot;rgb&quot;,val=val.slice(0,3)),prefix+&quot;(&quot;+val.join(&quot;, &quot;)+&quot;)&quot;&#125;,toHex:function()&#123;var val=this.val,val=(&quot;hsl&quot;===this.model&amp;&amp;(val=hslToRgb(val)),hex.encode(val.slice(0,3)));return&quot;#&quot;+(val=val[0]===val[1]&amp;&amp;val[2]===val[3]&amp;&amp;val[4]===val[5]?val[0]+val[2]+val[5]:val)&#125;,toHsl:function()&#123;var val=this.val,prefix=&quot;hsla&quot;;return 1===(val=&quot;rgb&quot;===this.model?rgbToHsl(val):val)[3]&amp;&amp;(prefix=&quot;hsl&quot;,val=val.slice(0,3)),val[1]=val[1]+&quot;%&quot;,val[2]=val[2]+&quot;%&quot;,prefix+&quot;(&quot;+val.join(&quot;, &quot;)+&quot;)&quot;&#125;&#125;,&#123;parse:function(colorStr)&#123;var i,match,val=[0,0,0,1],model=&quot;rgb&quot;;if(match=colorStr.match(regHexAbbr))for(match=match[1],i=0;i&lt;3;i++)val[i]=parseInt(match[i]+match[i],16);else if(match=colorStr.match(regHex))for(match=match[1],i=0;i&lt;3;i++)&#123;var i2=2*i;val[i]=parseInt(match.slice(i2,2+i2),16)&#125;else if(match=colorStr.match(regRgba))&#123;for(i=0;i&lt;3;i++)val[i]=parseInt(match[i+1],0);match[4]&amp;&amp;(val[3]=parseFloat(match[4]))&#125;else if(match=colorStr.match(regRgbaPer))&#123;for(i=0;i&lt;3;i++)val[i]=Math.round(2.55*parseFloat(match[i+1]));match[4]&amp;&amp;(val[3]=parseFloat(match[4]))&#125;else(match=colorStr.match(regHsla))&amp;&amp;(model=&quot;hsl&quot;,val=[(parseFloat(match[1])%360+360)%360,clamp(parseFloat(match[2]),0,100),clamp(parseFloat(match[3]),0,100),clamp(parseFloat(match[4]),0,1)]);return&#123;val:val,model:model&#125;&#125;&#125;);var regHexAbbr=/^#([a-fA-F0-9]&#123;3&#125;)$/,regHex=/^#([a-fA-F0-9]&#123;6&#125;)$/,regRgba=/^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/,regRgbaPer=/^rgba?\\(\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/,regHsla=/^hsla?\\(\\s*([+-]?\\d*[.]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/;module.exports=exports&#125;),defineProp_1=createCommonjsModule(function(module,exports)&#123;function defineProp(obj,prop,descriptor)&#123;for(var path=castPath(prop,obj),lastProp=path.pop();prop=path.shift();)obj[prop]||(obj[prop]=&#123;&#125;),obj=obj[prop];Object.defineProperty(obj,lastProp,descriptor)&#125;module.exports=function(obj,prop,descriptor)&#123;return isStr(prop)?defineProp(obj,prop,descriptor):isObj(prop)&amp;&amp;each(prop,function(descriptor,prop)&#123;defineProp(obj,prop,descriptor)&#125;),obj&#125;&#125;),Delegator=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(host,target)&#123;this._host=host,isStr(target)&amp;&amp;(target=safeGet(host,target)),this._target=target&#125;,method:function(name,targetName)&#123;var target=this._target,fn=target[targetName||name];return this._host[name]=function()&#123;return fn.apply(target,arguments)&#125;,this&#125;,getter:function(name,targetName)&#123;var target=this._target;return targetName=targetName||name,defineProp_1(this._host,name,&#123;get:function()&#123;return target[targetName]&#125;,configurable:!0&#125;),this&#125;,setter:function(name,targetName)&#123;var target=this._target;return targetName=targetName||name,defineProp_1(this._host,name,&#123;set:function(val)&#123;return target[targetName]=val&#125;,configurable:!0&#125;),this&#125;,access:function(name,targetName)&#123;return this.getter(name,targetName).setter(name,targetName)&#125;&#125;),module.exports=exports&#125;),uniqId=createCommonjsModule(function(module,exports)&#123;var idCounter=0;module.exports=function(prefix)&#123;var id=++idCounter+&quot;&quot;;return prefix?prefix+id:id&#125;&#125;),Dispatcher=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._callbacks=&#123;&#125;,this._isDispatching=!1,this._isHandled=&#123;&#125;,this._isPending=&#123;&#125;&#125;,dispatch:function(payload)&#123;for(var id in this._startDispatching(payload),this._callbacks)this._isPending[id]||this._invokeCb(id);this._stopDispatching()&#125;,register:function(cb)&#123;var id=uniqId(&quot;ID_&quot;);return this._callbacks[id]=cb,id&#125;,waitFor:function(ids)&#123;for(var i=0,len=ids.length;i&lt;len;i++)&#123;var id=ids[i];this._isPending[id]||this._invokeCb(id)&#125;&#125;,unregister:function(id)&#123;delete this._callbacks[id]&#125;,isDispatching:function()&#123;return this._isDispatching&#125;,_startDispatching:function(payload)&#123;for(var id in this._callbacks)this._isPending[id]=!1,this._isHandled[id]=!1;this._pendingPayload=payload,this._isDispatching=!0&#125;,_stopDispatching:function()&#123;delete this._pendingPayload,this._isDispatching=!1&#125;,_invokeCb:function(id)&#123;this._isPending[id]=!0,this._callbacks[id](this._pendingPayload),this._isHandled[id]=!0&#125;&#125;),module.exports=exports&#125;),freeze=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;return Object.freeze?Object.freeze(obj):(keys(obj).forEach(function(prop)&#123;Object.getOwnPropertyDescriptor(obj,prop).configurable&amp;&amp;Object.defineProperty(obj,prop,&#123;writable:!1,configurable:!1&#125;)&#125;),obj)&#125;&#125;),Enum=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(map)&#123;isArr(map)?(this.size=map.length,each(map,function(member,val)&#123;this[member]=val&#125;,this)):(this.size=keys(map).length,each(map,function(val,member)&#123;this[member]=val&#125;,this)),freeze(this)&#125;&#125;),module.exports=exports&#125;),LinkedList=createCommonjsModule(function(module,exports)&#123;var Node=(exports=Class(&#123;initialize:function()&#123;this.tail=null,this.head=null,this.size=0&#125;,push:function(val)&#123;val=new Node(val,this.tail,null,this);return this.tail=val,this.head=this.head||val,this.size++,this.size&#125;,pop:function()&#123;var node;if(this.tail)return node=this.tail,this.tail=node.prev,this.tail?this.tail.next=null:this.head=null,this.size--,node.value&#125;,unshift:function(val)&#123;val=new Node(val,null,this.head,this);return this.head=val,this.tail=this.tail||val,this.size++,this.size&#125;,shift:function()&#123;var node;if(this.head)return node=this.head,this.head=node.next,this.head?this.head.prev=null:this.tail=null,this.size--,node.value&#125;,rmNode:function(node)&#123;if(node.list!==this)throw Error(&quot;Node does not belong to this list&quot;);var next=node.next,prev=node.prev;next&amp;&amp;(next.prev=prev),prev&amp;&amp;(prev.next=next),node===this.head&amp;&amp;(this.head=next),node===this.tail&amp;&amp;(this.tail=prev),node.list=null,node.prev=null,node.next=null,this.size--&#125;,find:function(fn)&#123;for(var current=this.head;null!==current;0)&#123;if(fn(current.value))return current;current=current.next&#125;&#125;,forEach:function(iterator,ctx)&#123;ctx=1&lt;arguments.length?ctx:this;for(var i=0,current=this.head;null!==current;i++)iterator.call(ctx,current.value,i,this),current=current.next&#125;,toArr:function()&#123;for(var arr=new Array(this.size),i=0,current=this.head;null!==current;i++)arr[i]=current.value,current=current.next;return arr&#125;&#125;)).Node=Class(&#123;initialize:function(val,prev,next,list)&#123;this.value=val,this.list=list,prev?(prev.next=this).prev=prev:this.prev=null,next?(next.prev=this).next=next:this.next=null&#125;&#125;);module.exports=exports&#125;),LinkedList_1=LinkedList.Node,HashTable=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._buckets=map(Array(0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:32),function()&#123;return new LinkedList&#125;),this._keys=&#123;&#125;&#125;,set:function(key,val)&#123;var keyHash=this._hash(key),keyHash=(this._keys[key]=keyHash,this._buckets[keyHash]),node=keyHash.find(function(val)&#123;return val.key===key&#125;);node?node.value.value=val:keyHash.push(&#123;key:key,value:val&#125;)&#125;,get:function(key)&#123;var node=this._buckets[this._hash(key)].find(function(val)&#123;return val.key===key&#125;);if(node)return node.value.value&#125;,has:function(key)&#123;return has(this._keys,key)&#125;,delete:function(key)&#123;var keyHash=this._hash(key),keyHash=(delete this._keys[key],this._buckets[keyHash]),node=keyHash.find(function(val)&#123;return val.key===key&#125;);node&amp;&amp;keyHash.rmNode(node)&#125;,_hash:function(key)&#123;return strHash(key)%this._buckets.length&#125;&#125;),module.exports=exports&#125;),swap=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,a,b)&#123;var tmp=arr[a];return arr[a]=arr[b],arr[b]=tmp,arr&#125;&#125;),isSorted=createCommonjsModule(function(module,exports)&#123;(exports=function(arr)&#123;for(var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:exports.defComparator,i=0,len=arr.length;i&lt;len-1;i++)if(0&lt;cmp(arr[i],arr[i+1]))return!1;return!0&#125;).defComparator=function(a,b)&#123;return a&lt;b?-1:b&lt;a?1:0&#125;,module.exports=exports&#125;),isSorted_1=isSorted.defComparator,Heap=createCommonjsModule(function(module,exports)&#123;function parentIdx(idx)&#123;return Math.floor((idx-1)/2)&#125;function rightChildIdx(idx)&#123;return 2*idx+2&#125;exports=Class(&#123;initialize:function()&#123;var cmp=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:isSorted.defComparator;this._cmp=cmp,this.clear()&#125;,clear:function()&#123;this._data=[],this.size=0&#125;,add:function(item)&#123;return this._data.push(item),this.size++,this._heapifyUp(this.size-1),this.size&#125;,poll:function()&#123;var item,data=this._data;if(0&lt;this.size)return item=data[0],data[0]=data[this.size-1],this.size--,this._heapifyDown(0),item&#125;,peek:function()&#123;if(0&lt;this.size)return this._data[0]&#125;,_heapifyUp:function(idx)&#123;for(var data=this._data,parent=parentIdx(idx);0&lt;idx&amp;&amp;0&lt;this._cmp(data[parent],data[idx]);)swap(data,parent,idx),parent=parentIdx(idx=parent)&#125;,_heapifyDown:function(idx)&#123;for(var size=this.size,cmp=this._cmp,data=this._data;2*idx+1&lt;size;)&#123;var smallerIdx=2*idx+1,rightChild=2*idx+2;if(rightChild&lt;size&amp;&amp;cmp(data[rightChildIdx],data[smallerIdx])&lt;0&amp;&amp;(smallerIdx=rightChild),cmp(data[idx],data[smallerIdx])&lt;0)break;swap(data,idx,smallerIdx),idx=smallerIdx&#125;&#125;&#125;),module.exports=exports&#125;),toBool=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return isStr(val)?&quot;0&quot;!==(val=val.toLowerCase())&amp;&amp;&quot;&quot;!==val&amp;&amp;&quot;false&quot;!==val:!!val&#125;&#125;),HeapSnapshot=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(profile)&#123;isStr(profile)&amp;&amp;(profile=JSON.parse(profile)),this.nodes=new LinkedList,this.edges=new LinkedList;var meta=profile.snapshot.meta;this.nodeFields=map(meta.node_fields,camelCase),this.nodeTypes=meta.node_types[this.nodeFields.indexOf(&quot;type&quot;)],this.edgeFields=map(meta.edge_fields,camelCase),this.edgeTypes=meta.edge_types[this.edgeFields.indexOf(&quot;type&quot;)],this._init(profile)&#125;,_init:function(profile)&#123;for(var _this=this,nodes=profile.nodes,edges=profile.edges,strings=profile.strings,profile=this.nodeFields,edgeFields=this.edgeFields,curEdgeIdx=0,nodeFieldCount=profile.length,edgeFieldCount=edgeFields.length,nodeMap=&#123;&#125;,i=0,len=nodes.length;i&lt;len;i+=nodeFieldCount)&#123;var node=new Node(this);node.init(nodes.slice(i,i+nodeFieldCount),strings),this.nodes.push(node),nodeMap[i]=node&#125;this.nodes.forEach(function(node)&#123;for(var edgeCount=node.edgeCount,maxEdgeIdx=(delete node.edgeCount,curEdgeIdx+edgeCount*edgeFieldCount),_i=curEdgeIdx;_i&lt;maxEdgeIdx;_i+=edgeFieldCount)&#123;var edge=new Edge(_this,node);edge.init(edges.slice(_i,_i+edgeFieldCount),strings,nodeMap),_this.edges.push(edge)&#125;curEdgeIdx=maxEdgeIdx&#125;)&#125;&#125;);var Node=Class(&#123;initialize:function(heapSnapshot)&#123;this._heapSnapshot=heapSnapshot&#125;,init:function(fields,strings)&#123;var _this2=this,heapSnapshot=this._heapSnapshot,nodeFields=heapSnapshot.nodeFields,nodeTypes=heapSnapshot.nodeTypes;each(nodeFields,function(field,idx)&#123;var val=fields[idx];switch(field)&#123;case&quot;name&quot;:val=strings[val];break;case&quot;detachedness&quot;:val=toBool(val);break;case&quot;type&quot;:val=nodeTypes[val]&#125;_this2[field]=val&#125;)&#125;&#125;),Edge=Class(&#123;initialize:function(heapSnapshot,fromNode)&#123;this._heapSnapshot=heapSnapshot,this.fromNode=fromNode&#125;,init:function(fields,strings,nodeMap)&#123;var _this3=this,heapSnapshot=this._heapSnapshot,edgeFields=heapSnapshot.edgeFields,edgeTypes=heapSnapshot.edgeTypes;each(edgeFields,function(field,idx)&#123;var val=fields[idx];switch(field)&#123;case&quot;nameOrIndex&quot;:val=strings[val];break;case&quot;type&quot;:val=edgeTypes[val];break;case&quot;toNode&quot;:val=nodeMap[val]&#125;_this3[field]=val&#125;)&#125;&#125;);module.exports=exports&#125;),strTpl=createCommonjsModule(function(module,exports)&#123;var regSep=/&#123;&#123;(.*?)&#125;&#125;/g;module.exports=function(str,data)&#123;return str.replace(regSep,function(match,key)&#123;return toStr(safeGet(data,key))&#125;)&#125;&#125;),I18n=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(locale,langs)&#123;this._locale=locale,this._langs=langs&#125;,set:function(locale,lang)&#123;this._langs[locale]?extend(this._langs[locale],lang):this._langs[locale]=lang&#125;,t:function(path,data)&#123;var val=&quot;&quot;,lang=this._langs[this._locale];return lang?(val=safeGet(lang,path),data&amp;&amp;(isStr(val)?val=strTpl(val,data):isFn(val)&amp;&amp;(val=val(data))),val||&quot;&quot;):&quot;&quot;&#125;,locale:function(locale)&#123;this._locale=locale&#125;&#125;),module.exports=exports&#125;),isSymbol=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;symbol&quot;==typeof val&#125;&#125;),safeSet=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,path,val)&#123;for(var lastProp=(path=castPath(path,obj)).pop(),prop=path.shift();!isUndef(prop);)&#123;if(&quot;__proto__&quot;===(prop=isStr(prop)||isSymbol(prop)?prop:toStr(prop))||&quot;constructor&quot;===prop||&quot;prototype&quot;===prop)return;obj[prop]||(obj[prop]=&#123;&#125;),obj=obj[prop],prop=path.shift()&#125;obj[lastProp]=val&#125;&#125;),safeDel=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,path)&#123;var prop,ret;for(path=castPath(path,obj);prop=path.shift();)if(ret=obj[prop],0===path.length&amp;&amp;delete obj[prop],isUndef(obj=ret))return;return ret&#125;&#125;),JsonTransformer=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;className:&quot;JsonTransformer&quot;,initialize:function(data)&#123;this._data=data||&#123;&#125;&#125;,set:function(key,val)&#123;return 1===arguments.length?this._data=key:safeSet(this._data,key,val),this&#125;,get:function(key)&#123;return null==key?this._data:safeGet(this._data,key)&#125;,map:function(from,to,fn)&#123;return isFn(from)?this.set(map(this._data,from,this)):(isFn(to)&amp;&amp;(fn=to,to=from),this.set(to,map(this.get(from),fn,this)))&#125;,filter:function(from,to,fn)&#123;return isFn(from)?this.set(filter(this._data,from,this)):(isFn(to)&amp;&amp;(fn=to,to=from),this.set(to,filter(this.get(from),fn,this)))&#125;,remove:function(keys)&#123;keys=toArr(keys);var data=this._data;return each(keys,function(key)&#123;safeDel(data,key)&#125;),this&#125;,compute:function(from,to,fn)&#123;return isFn(from)?this.set(from.call(this,this._data)):isFn(to)?this.set(from,to.call(this,this.get(from))):(from=map(toArr(from),function(key)&#123;return safeGet(this._data,key)&#125;,this),this.set(to,fn.apply(this,from)))&#125;,toString:function()&#123;return JSON.stringify(this._data)&#125;&#125;),module.exports=exports&#125;),Store=createCommonjsModule(function(module,exports)&#123;exports=Emitter.extend(&#123;initialize:function(data)&#123;this.callSuper(Emitter,&quot;initialize&quot;,arguments),this._data=data||&#123;&#125;,this.save(this._data)&#125;,set:function(key,val)&#123;isStr(key)?(data=&#123;&#125;)[key]=val:isObj(key)&amp;&amp;(data=key);var data,self=this;each(data,function(val,key)&#123;var oldVal=self._data[key];self._data[key]=val,self.emit(&quot;change&quot;,key,val,oldVal)&#125;),this.save(this._data)&#125;,get:function(key)&#123;var data=this._data;if(isStr(key))return data[key];var ret=&#123;&#125;;return each(key,function(val)&#123;ret[val]=data[val]&#125;),ret&#125;,remove:function(key)&#123;key=toArr(key);var data=this._data;each(key,function(val)&#123;delete data[val]&#125;),this.save(data)&#125;,clear:function()&#123;this._data=&#123;&#125;,this.save(this._data)&#125;,each:function(fn)&#123;each(this._data,fn)&#125;,save:function(data)&#123;this._data=data&#125;&#125;),module.exports=exports&#125;),memStorage=createCommonjsModule(function(module,exports)&#123;var keys$1=keys,cloak=(exports=&#123;getItem:function(key)&#123;return(API_KEYS[key]?cloak:this)[key]||null&#125;,setItem:function(key,val)&#123;API_KEYS[key]?cloak[key]=val:this[key]=val&#125;,removeItem:function(key)&#123;API_KEYS[key]?delete cloak[key]:delete this[key]&#125;,key:function(i)&#123;var keys=enumerableKeys();return 0&lt;=i&amp;&amp;i&lt;keys.length?keys[i]:null&#125;,clear:function()&#123;for(var key,keys=uncloakedKeys(),i=0;key=keys[i];i++)delete this[key];for(var _key,keys=keys$1(cloak),_i=0;_key=keys[_i];_i++)delete cloak[_key]&#125;&#125;,Object.defineProperty(exports,&quot;length&quot;,&#123;enumerable:!1,configurable:!0,get:function()&#123;return enumerableKeys().length&#125;&#125;),&#123;&#125;),API_KEYS=&#123;getItem:1,setItem:1,removeItem:1,key:1,clear:1,length:1&#125;;function enumerableKeys()&#123;return uncloakedKeys().concat(keys$1(cloak))&#125;function uncloakedKeys()&#123;return keys$1(exports).filter(function(key)&#123;return!API_KEYS[key]&#125;)&#125;module.exports=exports&#125;),safeStorage=createCommonjsModule(function(module,exports)&#123;module.exports=function(type)&#123;var ret;switch(type=type||&quot;local&quot;)&#123;case&quot;local&quot;:ret=window.localStorage;break;case&quot;session&quot;:ret=window.sessionStorage&#125;try&#123;var x=&quot;test-localStorage-&quot;+Date.now(),y=(ret.setItem(x,x),ret.getItem(x));if(ret.removeItem(x),y!==x)throw new Error&#125;catch(e)&#123;return memStorage&#125;return ret&#125;&#125;),isArgs=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Arguments]&quot;===objToStr(val)&#125;&#125;),isEmpty=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return null==val||(isArrLike(val)&amp;&amp;(isArr(val)||isStr(val)||isArgs(val))?0===val.length:0===keys(val).length)&#125;&#125;),_isNaN=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return isNum(val)&amp;&amp;val!==+val&#125;&#125;),isBuffer=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return null!=val&amp;&amp;(!!val._isBuffer||val.constructor&amp;&amp;isFn(val.constructor.isBuffer)&amp;&amp;val.constructor.isBuffer(val))&#125;&#125;),type=createCommonjsModule(function(module,exports)&#123;var regObj=/^\\[object\\s+(.*?)]$/;module.exports=function(val)&#123;var ret,lower=!(1&lt;arguments.length&amp;&amp;void 0!==arguments[1])||arguments[1];return null===val&amp;&amp;(ret=&quot;Null&quot;),void 0===val&amp;&amp;(ret=&quot;Undefined&quot;),_isNaN(val)&amp;&amp;(ret=&quot;NaN&quot;),(ret=(ret=isBuffer(val)?&quot;Buffer&quot;:ret)||(ret=objToStr(val).match(regObj))&amp;&amp;ret[1])?lower?lowerCase(ret):ret:&quot;&quot;&#125;&#125;),isRegExp=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object RegExp]&quot;===objToStr(val)&#125;&#125;),stringify=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,spaces)&#123;return JSON.stringify(obj,(stack=[],keys=[],function(key,val)&#123;var pos;return 0&lt;stack.length?(-1&lt;(pos=stack.indexOf(this))?(stack.splice(pos+1),keys.splice(pos,1/0,key)):(stack.push(this),keys.push(key)),-1&lt;(pos=stack.indexOf(val))&amp;&amp;(val=stack[0]===val?&quot;[Circular ~]&quot;:&quot;[Circular ~.&quot;+keys.slice(0,pos).join(&quot;.&quot;)+&quot;]&quot;)):stack.push(val),isRegExp(val)||isFn(val)?val=&quot;[&quot;+upperFirst(type(val))+&quot; &quot;+toStr(val)+&quot;]&quot;:isUndef(val)&amp;&amp;(val=null),val&#125;),spaces);var stack,keys&#125;&#125;),LocalStore=createCommonjsModule(function(module,exports)&#123;var localStorage=safeStorage(&quot;local&quot;);exports=Store.extend(&#123;initialize:function(name,data)&#123;this._name=name,data=data||&#123;&#125;;name=localStorage.getItem(name);try&#123;name=JSON.parse(name)&#125;catch(e)&#123;name=&#123;&#125;&#125;isObj(name)||(name=&#123;&#125;),data=defaults(name,data),this.callSuper(Store,&quot;initialize&quot;,[data])&#125;,save:function(data)&#123;if(isEmpty(data))return localStorage.removeItem(this._name);localStorage.setItem(this._name,stringify(data))&#125;&#125;),module.exports=exports&#125;),Logger=createCommonjsModule(function(module,exports)&#123;exports=Emitter.extend(&#123;initialize:function(name,level)&#123;this.name=name,this.setLevel(isUndef(level)?exports.level.DEBUG:level),this.callSuper(Emitter,&quot;initialize&quot;,arguments)&#125;,setLevel:function(level)&#123;return isStr(level)?(level=exports.level[level.toUpperCase()])&amp;&amp;(this._level=level):isNum(level)&amp;&amp;(this._level=level),this&#125;,getLevel:function()&#123;return this._level&#125;,formatter:function(type,argList)&#123;return argList&#125;,trace:function()&#123;return this._log(&quot;trace&quot;,arguments)&#125;,debug:function()&#123;return this._log(&quot;debug&quot;,arguments)&#125;,info:function()&#123;return this._log(&quot;info&quot;,arguments)&#125;,warn:function()&#123;return this._log(&quot;warn&quot;,arguments)&#125;,error:function()&#123;return this._log(&quot;error&quot;,arguments)&#125;,_log:function(type,argList)&#123;return 0===(argList=toArr(argList)).length?this:(this.emit(&quot;all&quot;,type,clone(argList)),exports.level[type.toUpperCase()]&lt;this._level||(this.emit(type,clone(argList)),(&quot;debug&quot;===type?console.log:console[type]).apply(console,this.formatter(type,argList))),this)&#125;&#125;,&#123;level:new Enum(&#123;TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5&#125;)&#125;),module.exports=exports&#125;),PseudoMap=createCommonjsModule(function(module,exports)&#123;exports=root.Map||Class(&#123;initialize:function(data)&#123;this.clear();var self=this;defineProp_1(this,&quot;size&quot;,&#123;get:function()&#123;return keys(self._data).length&#125;,set:function()&#123;&#125;,enumerable:!0,configurable:!0&#125;),data instanceof exports?data.forEach(function(val,key)&#123;this.set(key,val)&#125;,this):isArr(data)&amp;&amp;each(data,function(val)&#123;this.set(val[0],val[1])&#125;,this)&#125;,forEach:function(fn,ctx)&#123;each(this._data,function(val,key)&#123;fn.call(this,val,key)&#125;,ctx)&#125;,has:function(key)&#123;return!isUndef(this._data[key])&#125;,get:function(key)&#123;return this._data[key]&#125;,set:function(key,val)&#123;this._data[key]=val&#125;,delete:function(key)&#123;delete this._data[key]&#125;,clear:function()&#123;this._data=&#123;&#125;&#125;&#125;),module.exports=exports&#125;),Lru=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(max)&#123;this._max=max,this._list=new LinkedList,this._map=new PseudoMap&#125;,has:function(key)&#123;return this._map.has(key)&#125;,remove:function(key)&#123;var node,map=this._map;this.has(key)&amp;&amp;(node=map.get(key),this._list.rmNode(node),map.delete(key))&#125;,get:function(key)&#123;var node,ret,list=this._list,map=this._map;return this.has(key)&amp;&amp;(ret=(node=map.get(key)).value.val,list.rmNode(node),list.unshift(node.value),map.set(key,list.head)),ret&#125;,set:function(key,val)&#123;var node,list=this._list,map=this._map;this.has(key)?(node=map.get(key),list.rmNode(node),list.unshift(&#123;key:key,val:val&#125;),map.set(key,list.head)):(list.unshift(&#123;key:key,val:val&#125;),map.set(key,list.head),list.size&gt;this._max&amp;&amp;(node=list.pop(),map.delete(node.key)))&#125;,clear:function()&#123;this._map=new PseudoMap,this._list=new LinkedList&#125;&#125;),module.exports=exports&#125;),MediaQuery=createCommonjsModule(function(module,exports)&#123;exports=Emitter.extend(&#123;className:&quot;MediaQuery&quot;,initialize:function(query)&#123;var _this=this;this.callSuper(Emitter,&quot;initialize&quot;),this._mql=window.matchMedia(query),this._mql.addListener(function()&#123;_this.emit(_this.isMatch()?&quot;match&quot;:&quot;unmatch&quot;)&#125;)&#125;,isMatch:function()&#123;return this._mql.matches&#125;&#125;),module.exports=exports&#125;),MutationObserver=createCommonjsModule(function(module,exports)&#123;exports=(exports=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver)||Class(&#123;initialize:function()&#123;&#125;,observe:function()&#123;&#125;,disconnect:function()&#123;&#125;,takeRecords:function()&#123;&#125;&#125;),module.exports=exports&#125;),wrap=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,wrapper)&#123;return partial(wrapper,fn)&#125;&#125;),PriorityQueue=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;var cmp=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:isSorted.defComparator;this._heap=new Heap(wrap(cmp,function(fn,a,b)&#123;return-1*fn(a,b)&#125;)),this.size=0&#125;,clear:function()&#123;this._heap.clear(),this.size=0&#125;,enqueue:function(item)&#123;return this._heap.add(item),this.size++,this.size&#125;,dequeue:function()&#123;var item=this._heap.poll();if(item)return this.size--,item&#125;,peek:function()&#123;return this._heap.peek()&#125;&#125;),module.exports=exports&#125;),Queue=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this.clear()&#125;,clear:function()&#123;this._items=[],this.size=0&#125;,enqueue:function(item)&#123;return this._items.push(item),++this.size&#125;,dequeue:function()&#123;if(this.size)return this.size--,this._items.shift()&#125;,peek:function()&#123;if(this.size)return this._items[0]&#125;,forEach:function(iterator,ctx)&#123;ctx=1&lt;arguments.length?ctx:this;for(var items=this._items,i=0,size=this.size;i&lt;size;i++)iterator.call(ctx,items[i],i,this)&#125;,toArr:function()&#123;return this._items.slice(0)&#125;&#125;),module.exports=exports&#125;),QuickLru=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(max)&#123;this._max=max,this._cache=&#123;&#125;,this._oldCache=&#123;&#125;,this._size=0&#125;,has:function(key)&#123;return!isUndef(this._cache[key])||!isUndef(this._oldCache[key])&#125;,remove:function(key)&#123;isUndef(this._cache[key])||(this._cache[key]=void 0),isUndef(this._oldCache[key])||(this._oldCache[key]=void 0)&#125;,get:function(key)&#123;if(!isUndef(this._cache[key]))return this._cache[key];var val=this._oldCache[key];return isUndef(val)?void 0:(this._update(key,val),val)&#125;,set:function(key,val)&#123;isUndef(this._cache[key])?this._update(key,val):this._cache[key]=val&#125;,clear:function()&#123;this._cache=&#123;&#125;,this._oldCache=&#123;&#125;&#125;,_update:function(key,val)&#123;this._cache[key]=val,this._size++,this._size&gt;this._max&amp;&amp;(this._size=0,this._oldCache=this._cache,this._cache=&#123;&#125;)&#125;&#125;),module.exports=exports&#125;),Readiness=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._promises=&#123;&#125;,this._resolves=&#123;&#125;,this._states=&#123;&#125;&#125;,signal:function(tasks)&#123;var states=this._states;each(this._getPromises(toArr(tasks)),function(val)&#123;val.state||(states[val.task]=!0,val.resolve())&#125;)&#125;,isReady:function(tasks)&#123;return!some(this._getPromises(toArr(tasks)),function(val)&#123;return!val.state&#125;)&#125;,ready:function(tasks)&#123;var fn=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:noop;return Promise.all(map(this._getPromises(toArr(tasks)),function(val)&#123;return val.promise&#125;)).then(fn)&#125;,_getPromises:function(tasks)&#123;var promises=this._promises,resolves=this._resolves,states=this._states;return map(tasks,function(task)&#123;return promises[task]||(promises[task]=new Promise(function(resolve)&#123;resolves[task]=resolve,states[task]=!1&#125;)),&#123;task:task,promise:promises[task],resolve:resolves[task],state:states[task]&#125;&#125;)&#125;&#125;),module.exports=exports&#125;),remove=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,iterator,ctx)&#123;for(var ret=[],i=(iterator=safeCb(iterator,ctx),-1),len=arr.length;++i&lt;len;)&#123;var val=arr[i];iterator(val,i,arr)&amp;&amp;(ret.push(val),arr.splice(i,1))&#125;return ret&#125;&#125;),ReduceStore=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function(reducer,initialState)&#123;this._reducer=reducer,this._state=initialState,this._curListeners=[],this._nextListeners=this._curListeners&#125;,subscribe:function(listener)&#123;var isSubscribed=!0,self=(this._ensureCanMutateNextListeners(),this._nextListeners.push(listener),this);return function()&#123;isSubscribed&amp;&amp;(isSubscribed=!1,self._ensureCanMutateNextListeners(),remove(self._nextListeners,function(val)&#123;return val===listener&#125;))&#125;&#125;,dispatch:function(action)&#123;this._state=this._reducer(this._state,action);for(var listeners=this._curListeners=this._nextListeners,i=0,len=listeners.length;i&lt;len;i++)listeners[i]();return action&#125;,getState:function()&#123;return this._state&#125;,_ensureCanMutateNextListeners:function()&#123;this._nextListeners===this._curListeners&amp;&amp;(this._nextListeners=clone(this._curListeners))&#125;&#125;),module.exports=exports&#125;),SingleEmitter=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._listeners=[]&#125;,addListener:function(listener)&#123;this._listeners.push(listener)&#125;,rmListener:function(listener)&#123;listener=this._listeners.indexOf(listener);-1&lt;listener&amp;&amp;this._listeners.splice(listener,1)&#125;,rmAllListeners:function()&#123;this._listeners=[]&#125;,emit:function()&#123;var _this=this,args=toArr(arguments),listeners=clone(this._listeners);each(listeners,function(listener)&#123;return listener.apply(_this,args)&#125;,this)&#125;&#125;,&#123;mixin:function(obj)&#123;each([&quot;addListener&quot;,&quot;rmListener&quot;,&quot;emit&quot;,&quot;rmAllListeners&quot;],function(val)&#123;obj[val]=exports.prototype[val]&#125;),obj._listeners=obj._listeners||[]&#125;&#125;),module.exports=exports&#125;),isEl=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return!(!val||1!==val.nodeType)&#125;&#125;),startWith=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,prefix)&#123;return 0===str.indexOf(prefix)&#125;&#125;),h=createCommonjsModule(function(module,exports)&#123;module.exports=function(tag,attrs)&#123;for(var _len=arguments.length,children=new Array(2&lt;_len?_len-2:0),_key=2;_key&lt;_len;_key++)children[_key-2]=arguments[_key];(isEl(attrs)||isStr(attrs))&amp;&amp;(children.unshift(attrs),attrs=null),attrs=attrs||&#123;&#125;;var _parseTag=function(tag)&#123;for(var tagName=&quot;div&quot;,id=&quot;&quot;,classes=[],words=[],word=&quot;&quot;,i=0,len=tag.length;i&lt;len;i++)&#123;var c=tag[i];&quot;#&quot;===c||&quot;.&quot;===c?(words.push(word),word=c):word+=c&#125;words.push(word);for(var _i=0,_len2=words.length;_i&lt;_len2;_i++)(word=words[_i])&amp;&amp;(startWith(word,&quot;#&quot;)?id=word.slice(1):startWith(word,&quot;.&quot;)?classes.push(word.slice(1)):tagName=word);return&#123;tagName:tagName,id:id,classes:classes&#125;&#125;(tag),tagName=_parseTag.tagName,id=_parseTag.id,_parseTag=_parseTag.classes,el=document.createElement(tagName);return id&amp;&amp;el.setAttribute(&quot;id&quot;,id),$class.add(el,_parseTag),each(children,function(child)&#123;isStr(child)?el.appendChild(document.createTextNode(child)):isEl(child)&amp;&amp;el.appendChild(child)&#125;),each(attrs,function(val,key)&#123;isStr(val)?el.setAttribute(key,val):isFn(val)&amp;&amp;startWith(key,&quot;on&quot;)?el.addEventListener(key.slice(2),val,!1):&quot;style&quot;===key&amp;&amp;$css(el,val)&#125;),el&#125;&#125;),ResizeSensor=createCommonjsModule(function(module,exports)&#123;exports=root.ResizeObserver?SingleEmitter.extend(&#123;initialize:function(el)&#123;var _this=this;if(el._resizeSensor)return el._resizeSensor;this.callSuper(SingleEmitter,&quot;initialize&quot;);var resizeObserver=new root.ResizeObserver(function()&#123;return _this.emit()&#125;);resizeObserver.observe(el),(el._resizeSensor=this)._resizeObserver=resizeObserver,this._el=el&#125;,destroy:function()&#123;var el=this._el;el._resizeSensor&amp;&amp;(this.rmAllListeners(),delete el._resizeSensor,this._resizeObserver.unobserve(el))&#125;&#125;):SingleEmitter.extend(&#123;initialize:function(el)&#123;if(el._resizeSensor)return el._resizeSensor;this.callSuper(SingleEmitter,&quot;initialize&quot;),(this._el=el)._resizeSensor=this,contain([&quot;absolute&quot;,&quot;relative&quot;,&quot;fixed&quot;,&quot;sticky&quot;],$css(el,&quot;position&quot;))||$css(el,&quot;position&quot;,&quot;relative&quot;),this._appendResizeSensor(),this._bindEvent()&#125;,destroy:function()&#123;var el=this._el;el._resizeSensor&amp;&amp;(this.rmAllListeners(),delete el._resizeSensor,el.removeChild(this._resizeSensorEl))&#125;,_appendResizeSensor:function()&#123;var el=this._el,style=&#123;pointerEvents:&quot;none&quot;,position:&quot;absolute&quot;,left:&quot;0px&quot;,top:&quot;0px&quot;,right:&quot;0px&quot;,bottom:&quot;0px&quot;,overflow:&quot;hidden&quot;,zIndex:&quot;-1&quot;,visibility:&quot;hidden&quot;,maxWidth:&quot;100%&quot;&#125;,styleChild=&#123;position:&quot;absolute&quot;,left:&quot;0px&quot;,top:&quot;0px&quot;,transition:&quot;0s&quot;&#125;,expandChildEl=h(&quot;div&quot;,&#123;style:styleChild&#125;),expandEl=h(&quot;div.resize-sensor-expand&quot;,&#123;style:style&#125;,expandChildEl),styleChild=h(&quot;div.resize-sensor-shrink&quot;,&#123;style:style&#125;,h(&quot;div&quot;,&#123;style:extend(&#123;width:&quot;200%&quot;,height:&quot;200%&quot;&#125;,styleChild)&#125;)),style=h(&quot;div.resize-sensor&quot;,&#123;dir:&quot;ltr&quot;,style:style&#125;,expandEl,styleChild);this._expandEl=expandEl,this._expandChildEl=expandChildEl,this._shrinkEl=styleChild,this._resizeSensorEl=style,el.appendChild(style),this._resetExpandShrink()&#125;,_bindEvent:function()&#123;var _this2=this;$event.on(this._expandEl,&quot;scroll&quot;,function()&#123;return _this2._onScroll()&#125;),$event.on(this._shrinkEl,&quot;scroll&quot;,function()&#123;return _this2._onScroll()&#125;)&#125;,_onScroll:function()&#123;this.emit(),this._resetExpandShrink()&#125;,_resetExpandShrink:function()&#123;var el=this._el,width=el.offsetWidth,el=el.offsetHeight;$css(this._expandChildEl,&#123;width:width+10,height:el+10&#125;),extend(this._expandEl,&#123;scrollLeft:width+10,scrollTop:el+10&#125;),extend(this._shrinkEl,&#123;scrollLeft:width+10,scrollTop:el+10&#125;)&#125;&#125;),module.exports=exports&#125;),Semaphore=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._counter=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:1,this._tasks=new Queue&#125;,wait:function(fn)&#123;if(0&lt;this._counter)return this._counter--,fn();this._tasks.enqueue(fn)&#125;,signal:function()&#123;var task=this._tasks.dequeue();if(task)return task();this._counter++&#125;&#125;),module.exports=exports&#125;),SessionStore=createCommonjsModule(function(module,exports)&#123;var sessionStorage=safeStorage(&quot;session&quot;);exports=Store.extend(&#123;initialize:function(name,data)&#123;this._name=name,data=data||&#123;&#125;;name=sessionStorage.getItem(name);try&#123;name=JSON.parse(name)&#125;catch(e)&#123;name=&#123;&#125;&#125;isObj(name)||(name=&#123;&#125;),data=defaults(name,data),this.callSuper(Store,&quot;initialize&quot;,[data])&#125;,save:function(data)&#123;if(isEmpty(data))return sessionStorage.removeItem(this._name);sessionStorage.setItem(this._name,stringify(data))&#125;&#125;),module.exports=exports&#125;),Socket=createCommonjsModule(function(module,exports)&#123;exports=Emitter.extend(&#123;initialize:function(url)&#123;var options=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;;this.callSuper(Emitter,&quot;initialize&quot;),defaults(options,defOpts),this._options=options,this._url=url,this.connect()&#125;,send:function(message)&#123;this._ws.send(message)&#125;,close:function(code,reason)&#123;this._ws.close(code||1e3,reason)&#125;,connect:function()&#123;var _this=this,options=this._options,ws=new WebSocket(this._url,options.protocols);ws.onmessage=function(e)&#123;return _this.emit(&quot;message&quot;,e)&#125;,ws.onopen=function(e)&#123;return _this.emit(&quot;open&quot;,e)&#125;,ws.onclose=function(e)&#123;var code=e.code;1e3!==code&amp;&amp;1001!==code&amp;&amp;1005!==code&amp;&amp;options.reconnect&amp;&amp;_this.connect(),_this.emit(&quot;close&quot;,e)&#125;,ws.onerror=function(e)&#123;e&amp;&amp;&quot;ECONNREFUSED&quot;===e.code&amp;&amp;options.reconnect?_this.connect():_this.emit(&quot;error&quot;,e)&#125;,this._ws=ws&#125;&#125;);var defOpts=&#123;protocols:[],reconnect:!0&#125;;module.exports=exports&#125;),reverse=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;var len=arr.length,ret=Array(len);len--;for(var i=0;i&lt;=len;i++)ret[len-i]=arr[i];return ret&#125;&#125;),Stack=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this.clear()&#125;,clear:function()&#123;this._items=[],this.size=0&#125;,push:function(item)&#123;return this._items.push(item),++this.size&#125;,pop:function()&#123;if(this.size)return this.size--,this._items.pop()&#125;,peek:function()&#123;return this._items[this.size-1]&#125;,forEach:function(iterator,ctx)&#123;ctx=1&lt;arguments.length?ctx:this;for(var items=this._items,i=this.size-1,j=0;0&lt;=i;i--,j++)iterator.call(ctx,items[i],j,this)&#125;,toArr:function()&#123;return reverse(this._items)&#125;&#125;),module.exports=exports&#125;),Trace=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;var _this=this,events=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:[];this._processes=&#123;&#125;,each(events,function(event)&#123;return _this.addEvent(event)&#125;)&#125;,addEvent:function(event)&#123;this.getProcess(event.pid).addEvent(event)&#125;,rmEvent:function(event)&#123;this.getProcess(event.pid).rmEvent(event)&#125;,getProcess:function(id)&#123;var process=this._processes[id];return process||(process=new Process(id),this._processes[id]=process),process&#125;,rmProcess:function(id)&#123;delete this._processes[id]&#125;,processes:function()&#123;return map(this._processes)&#125;,toJSON:function()&#123;var events=[];return each(this.processes(),function(process)&#123;events.push.apply(events,process.toJSON())&#125;),events&#125;&#125;);var Process=Class(&#123;initialize:function(id)&#123;this._id=id,this._name=&quot;&quot;,this._threads=&#123;&#125;,this._metadata=&#123;&#125;&#125;,id:function()&#123;return this._id&#125;,name:function()&#123;return this._name&#125;,addEvent:function(event)&#123;&quot;__metadata&quot;!==event.cat||(&quot;process_name&quot;===event.name&amp;&amp;(this._name=event.args.name),0!==event.tid)?this.getThread(event.tid).addEvent(event):this._metadata[event.name]=event.args&#125;,rmEvent:function(event)&#123;this.getThread(event.tid).rmEvent(event)&#125;,getThread:function(id)&#123;var thread=this._threads[id];return thread||(thread=new Thread(id,this.id()),this._threads[id]=thread),thread&#125;,rmThread:function(id)&#123;delete this._threads[id]&#125;,threads:function()&#123;return map(this._threads)&#125;,toJSON:function()&#123;var _this2=this,events=[];return each(this._metadata,function(args,name)&#123;events.push(createMetaEvent(_this2._id,0,name,args))&#125;),each(this.threads(),function(thread)&#123;events.push.apply(events,thread.toJSON())&#125;),events&#125;&#125;),Thread=Class(&#123;initialize:function(id,pid)&#123;this._id=id,this._pid=pid,this._name=&quot;&quot;,this._events=[],this._metadata=&#123;&#125;&#125;,id:function()&#123;return this._id&#125;,name:function()&#123;return this._name&#125;,addEvent:function(event)&#123;if(&quot;__metadata&quot;===event.cat)return&quot;thread_name&quot;===event.name&amp;&amp;(this._name=event.args.name),void(this._metadata[event.name]=event.args);this._events.push(event)&#125;,rmEvent:function(event)&#123;var events=this._events;events.splice(events.indexOf(event),1)&#125;,events:function()&#123;return map(this._events)&#125;,toJSON:function()&#123;var _this3=this,events=[];return each(this._metadata,function(args,name)&#123;events.push(createMetaEvent(_this3._pid,_this3._id,name,args))&#125;),each(this.events(),function(event)&#123;events.push(event)&#125;),events&#125;&#125;);function createMetaEvent(pid,tid,name,args)&#123;return&#123;args:args,cat:&quot;__metadata&quot;,name:name,ph:&quot;M&quot;,pid:pid,tid:tid,ts:0&#125;&#125;module.exports=exports&#125;),isNode=createCommonjsModule(function(module,exports)&#123;exports=&quot;undefined&quot;!=typeof process&amp;&amp;&quot;[object process]&quot;===objToStr(process),module.exports=exports&#125;),ltrim=createCommonjsModule(function(module,exports)&#123;var regSpace=/^\\s+/;module.exports=function(str,chars)&#123;if(null==chars)return str.trimLeft?str.trimLeft():str.replace(regSpace,&quot;&quot;);for(var i,c,start=0,len=str.length,charLen=chars.length,found=!0;found&amp;&amp;start&lt;len;)for(found=!1,i=-1,c=str.charAt(start);++i&lt;charLen;)if(c===chars[i])&#123;found=!0,start++;break&#125;return len&lt;=start?&quot;&quot;:str.substr(start,len)&#125;&#125;),rtrim=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,chars)&#123;if(null==chars)&#123;if(str.trimRight)return str.trimRight();chars=&quot; \\r\\n\\t\\f\\v&quot;&#125;for(var i,c,end=str.length-1,charLen=chars.length,found=!0;found&amp;&amp;0&lt;=end;)for(found=!1,i=-1,c=str.charAt(end);++i&lt;charLen;)if(c===chars[i])&#123;found=!0,end--;break&#125;return 0&lt;=end?str.substring(0,end+1):&quot;&quot;&#125;&#125;),trim=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,chars)&#123;return null==chars&amp;&amp;str.trim?str.trim():ltrim(rtrim(str,chars),chars)&#125;&#125;),intersect=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var ret=[],args=toArr(arguments),argsLen=args.length,i=0,len=arr.length;i&lt;len;i++)&#123;var item=arr[i];if(!contain(ret,item))&#123;for(var j=1;j&lt;argsLen&amp;&amp;contain(args[j],item);j++);j===argsLen&amp;&amp;ret.push(item)&#125;&#125;return ret&#125;&#125;),convertBase=createCommonjsModule(function(module,exports)&#123;module.exports=function(num,from,to)&#123;return parseInt(num,from).toString(to)&#125;&#125;),Tracing=createCommonjsModule(function(module,exports)&#123;var defPid=0,defTid=0,id=0;if(isNode)&#123;defPid=process.pid;try&#123;defTid=eval(&quot;require&quot;)(&quot;worker_threads&quot;).threadId&#125;catch(e)&#123;&#125;&#125;exports=Class(&#123;initialize:function()&#123;var _ref=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:&#123;&#125;,_ref$pid=_ref.pid,_ref$pid=void 0===_ref$pid?defPid:_ref$pid,_ref$tid=_ref.tid,_ref$tid=void 0===_ref$tid?defTid:_ref$tid,_ref$processName=_ref.processName,_ref$processName=void 0===_ref$processName?&quot;Process&quot;:_ref$processName,_ref=_ref.threadName,_ref=void 0===_ref?&quot;Thread&quot;:_ref;this._pid=_ref$pid,this._tid=_ref$tid,this._processName=_ref$processName,this._threadName=_ref&#125;,start:function()&#123;this._targetCat=processCat(0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:&quot;&quot;),isEmpty(this._targetCat)||this._targetCat.push(&quot;__metadata&quot;),this._traceEventStack=new Stack,this._asyncEventMap=&#123;&#125;,this._trace=new Trace,this.metadata(&quot;process_name&quot;,&#123;name:this._processName&#125;,&#123;tid:0,ts:0&#125;),this.metadata(&quot;thread_name&quot;,&#123;name:this._threadName&#125;,&#123;ts:0&#125;)&#125;,stop:function()&#123;var trace=this._trace;if(!trace)throw Error(&quot;Need to call start first&quot;);return delete this._targetCat,delete this._traceEventStack,delete this._asyncEventMap,delete this._trace,trace.toJSON()&#125;,metadata:function(name,args,extra)&#123;this._addEvent(&quot;__metadata&quot;,name,Phase.Metadata,args,extra)&#125;,begin:function(cat,name)&#123;this._traceEventStack&amp;&amp;this._traceEventStack.push(&#123;cat:cat,name:name,args:2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:&#123;&#125;,ts:this._getCurTs()&#125;)&#125;,end:function(args)&#123;if(this._traceEventStack)&#123;var beginEvent=this._traceEventStack.pop();if(!beginEvent)throw Error(&quot;Need to call begin first&quot;);var cat=beginEvent.cat,name=beginEvent.name,ts=beginEvent.ts;args=extend(beginEvent.args,args),this._addEvent(cat,name,Phase.Complete,args,&#123;dur:this._getCurTs()-ts,ts:ts&#125;)&#125;&#125;,asyncBegin:function(cat,name)&#123;var id=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:this.id(),args=3&lt;arguments.length&amp;&amp;void 0!==arguments[3]?arguments[3]:&#123;&#125;;return this._asyncEventMap&amp;&amp;(this._asyncEventMap[id]=&#123;cat:cat,name:name&#125;,this._addEvent(cat,name,Phase.NestableAsyncBegin,args,&#123;id:id&#125;)),id&#125;,asyncEnd:function(id)&#123;var args=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;;if(this._asyncEventMap)&#123;var asyncBeginEvent=this._asyncEventMap[id];if(!asyncBeginEvent)throw Error(&quot;Need to call async begin first&quot;);var cat=asyncBeginEvent.cat,asyncBeginEvent=asyncBeginEvent.name;delete this._asyncEventMap[id],this._addEvent(cat,asyncBeginEvent,Phase.NestableAsyncEnd,args,&#123;id:id&#125;)&#125;&#125;,instant:function(cat,name)&#123;var scope=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:&quot;t&quot;;this._addEvent(cat,name,Phase.Instant,3&lt;arguments.length?arguments[3]:void 0,&#123;s:scope&#125;)&#125;,id:function()&#123;return&quot;0x&quot;+convertBase(id++,10,16)&#125;,_addEvent:function(cat,name,ph)&#123;var args=3&lt;arguments.length&amp;&amp;void 0!==arguments[3]?arguments[3]:&#123;&#125;,extra=4&lt;arguments.length&amp;&amp;void 0!==arguments[4]?arguments[4]:&#123;&#125;;if(this._trace)&#123;var targetCat=this._targetCat;if(!isEmpty(targetCat))&#123;var catArr=processCat(cat);if(isEmpty(intersect(catArr,targetCat)))return&#125;catArr=extend(&#123;name:name,cat:cat,ph:ph,ts:this._getCurTs(),pid:this._pid,tid:this._tid,args:args&#125;,extra);this._trace.addEvent(catArr)&#125;&#125;,_getCurTs:function()&#123;return Math.round(1e3*perfNow())&#125;&#125;);var Phase=&#123;Begin:&quot;B&quot;,End:&quot;E&quot;,Complete:&quot;X&quot;,Instant:&quot;I&quot;,NestableAsyncBegin:&quot;b&quot;,NestableAsyncEnd:&quot;e&quot;,Metadata:&quot;M&quot;&#125;;function processCat(cat)&#123;return&quot;&quot;===(cat=trim(cat))?[]:map(cat.split(&quot;,&quot;),trim)&#125;module.exports=exports&#125;),Trie=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this.clear()&#125;,add:function(word)&#123;var edges=this._edges,node=this._root;this._wordsInSubtree[node]++;for(var i=0,len=word.length;i&lt;len;i++)&#123;var edge=word[i],next=edges[node][edge];next||(this._freeNodes.length?next=this._freeNodes.pop():(next=this._idx++,this._isWord.push(!1),this._wordsInSubtree.push(0),edges.push(&#123;&#125;)),edges[node][edge]=next),this._wordsInSubtree[next]++,node=next&#125;this._isWord[node]=!0&#125;,remove:function(word)&#123;if(this.has(word))&#123;var node=this._root;this._wordsInSubtree[node]--;for(var i=0,len=word.length;i&lt;len;i++)&#123;var edge=word[i],next=this._edges[node][edge];--this._wordsInSubtree[next]||(delete this._edges[node][edge],this._freeNodes.push(next)),node=next&#125;this._isWord[node]=!1&#125;&#125;,has:function(word)&#123;for(var node=this._root,i=0,len=word.length;i&lt;len;i++)if(!(node=this._edges[node][word[i]]))return!1;return this._isWord[node]&#125;,words:function(prefix)&#123;for(var node=this._root,i=0,len=prefix.length;i&lt;len;i++)if(!(node=this._edges[node][prefix[i]]))return[];var result=[];return this._dfs(node,prefix,result),result&#125;,clear:function()&#123;this._idx=1,this._root=0,this._edges=[&#123;&#125;],this._isWord=[!1],this._wordsInSubtree=[0],this._freeNodes=[]&#125;,_dfs:function(node,prefix,result)&#123;var _this=this,node=(this._isWord[node]&amp;&amp;result.push(prefix),this._edges[node]);each(node,function(node,edge)&#123;return _this._dfs(node,prefix+edge,result)&#125;)&#125;&#125;),module.exports=exports&#125;),easing=createCommonjsModule(function(module,exports)&#123;exports.linear=function(t)&#123;return t&#125;;var pow=Math.pow,sqrt=Math.sqrt,sin=Math.sin,min=Math.min,asin=Math.asin,PI=Math.PI,fns=&#123;sine:function(t)&#123;return 1+sin(PI/2*t-PI/2)&#125;,circ:function(t)&#123;return 1-sqrt(1-t*t)&#125;,elastic:function(t,m)&#123;if(0===t||1===t)return t;var m=1-min(m=m||DEFAULT_ELASTICITY,998)/1e3,t=+t-1,s=m/(2*PI)*asin(1);return-(pow(2,10*t)*sin(2*PI*(t-s)/m))&#125;,back:function(t)&#123;return t*t*(3*t-2)&#125;,bounce:function(t)&#123;for(var pow2,bounce=4;t&lt;((pow2=pow(2,--bounce))-1)/11;);return 1/pow(4,3-bounce)-7.5625*pow((3*pow2-2)/22-t,2)&#125;&#125;,DEFAULT_ELASTICITY=(each([&quot;quad&quot;,&quot;cubic&quot;,&quot;quart&quot;,&quot;quint&quot;,&quot;expo&quot;],function(name,i)&#123;fns[name]=function(t)&#123;return pow(t,i+2)&#125;&#125;),400);each(fns,function(fn,name)&#123;name=upperFirst(name),exports[&quot;in&quot;+name]=fn,exports[&quot;out&quot;+name]=function(t,m)&#123;return 1-fn(1-t,m)&#125;,exports[&quot;inOut&quot;+name]=function(t,m)&#123;return t&lt;.5?fn(2*t,m)/2:1-fn(-2*t+2,m)/2&#125;,exports[&quot;outIn&quot;+name]=function(t,m)&#123;return t&lt;.5?(1-fn(1-2*t,m))/2:(fn(2*t-1,m)+1)/2&#125;&#125;),module.exports=exports&#125;),easing_1=easing.linear,raf_1=createCommonjsModule(function(module,exports)&#123;var lastTime=0;if(isBrowser)for(var raf=window.requestAnimationFrame,cancel=window.cancelAnimationFrame,vendors=[&quot;ms&quot;,&quot;moz&quot;,&quot;webkit&quot;,&quot;o&quot;],i=0,len=vendors.length;i&lt;len&amp;&amp;!raf;i++)raf=window[vendors[i]+&quot;RequestAnimationFrame&quot;],cancel=window[vendors[i]+&quot;CancelAnimationFrame&quot;]||window[vendors[i]+&quot;CancelRequestAnimationFrame&quot;];(raf=raf||function(cb)&#123;var curTime=now(),timeToCall=Math.max(0,16-(curTime-lastTime)),id=setTimeout(function()&#123;cb(curTime+timeToCall)&#125;,timeToCall);return lastTime=curTime+timeToCall,id&#125;).cancel=cancel=cancel||function(id)&#123;clearTimeout(id)&#125;,exports=raf,module.exports=exports&#125;),Tween=createCommonjsModule(function(module,exports)&#123;exports=Emitter.extend(&#123;className:&quot;Tween&quot;,initialize:function(target)&#123;this.callSuper(Emitter,&quot;initialize&quot;,arguments),this._target=target,this._dest=&#123;&#125;,this._duration=0,this._progress=0,this._origin=&#123;&#125;,this._diff=&#123;&#125;,this._ease=easing.linear,this._state=new State(&quot;pause&quot;,&#123;play:&#123;from:&quot;pause&quot;,to:&quot;play&quot;&#125;,pause:&#123;from:&quot;play&quot;,to:&quot;pause&quot;&#125;&#125;)&#125;,to:function(props,duration,ease)&#123;var origin=&#123;&#125;,target=this._target,diff=&#123;&#125;;return ease=ease||this._ease,this._dest=props,this._duration=duration||this._duration,this._ease=isFn(ease)?ease:easing[ease],each(props,function(val,key)&#123;origin[key]=target[key],diff[key]=val-origin[key]&#125;),this._origin=origin,this._diff=diff,this&#125;,progress:function(progress)&#123;var ease=this._ease,target=this._target,origin=this._origin,diff=this._diff,dest=this._dest;return null!=progress?(progress=progress&lt;1?progress:1,this._progress=progress,each(dest,function(val,key)&#123;target[key]=origin[key]+diff[key]*ease(progress)&#125;),this.emit(&quot;update&quot;,target),this):this._progress&#125;,play:function()&#123;var startTime,progress,duration,target,self,state=this._state;if(!state.is(&quot;play&quot;))return state.play(),startTime=now(),progress=this._progress,duration=this._duration*(1-progress),target=this._target,self=this,raf_1(function render()&#123;if(!state.is(&quot;pause&quot;))&#123;var time=now();if(self.progress(progress+(time-startTime)/duration),1===self._progress)return state.pause(),void self.emit(&quot;end&quot;,target);raf_1(render)&#125;&#125;),this&#125;,pause:function()&#123;var state=this._state;if(!state.is(&quot;pause&quot;))return state.pause(),this&#125;,paused:function()&#123;return this._state.is(&quot;pause&quot;)&#125;&#125;),module.exports=exports&#125;),query=createCommonjsModule(function(module,exports)&#123;exports=&#123;parse:function(str)&#123;var ret=&#123;&#125;;return str=trim(str).replace(regIllegalChars,&quot;&quot;),each(str.split(&quot;&amp;&quot;),function(param)&#123;var param=param.split(&quot;=&quot;),key=param.shift(),param=0&lt;param.length?param.join(&quot;=&quot;):null,key=decodeURIComponent(key),param=decodeURIComponent(param);isUndef(ret[key])?ret[key]=param:isArr(ret[key])?ret[key].push(param):ret[key]=[ret[key],param]&#125;),ret&#125;,stringify:function(obj,arrKey)&#123;return filter(map(obj,function(val,key)&#123;return isObj(val)&amp;&amp;isEmpty(val)?&quot;&quot;:isArr(val)?exports.stringify(val,key):(arrKey?encodeURIComponent(arrKey):encodeURIComponent(key))+&quot;=&quot;+encodeURIComponent(val)&#125;),function(str)&#123;return 0&lt;str.length&#125;).join(&quot;&amp;&quot;)&#125;&#125;;var regIllegalChars=/^(\\?|#|&amp;)/g;module.exports=exports&#125;),Url=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;className:&quot;Url&quot;,initialize:function(url)&#123;!url&amp;&amp;isBrowser&amp;&amp;(url=window.location.href),extend(this,exports.parse(url||&quot;&quot;))&#125;,setQuery:function(name,val)&#123;var query=this.query;return isObj(name)?each(name,function(val,key)&#123;query[key]=toStr(val)&#125;):query[name]=toStr(val),this&#125;,rmQuery:function(name)&#123;var query=this.query;return isArr(name)||(name=toArr(name)),each(name,function(key)&#123;delete query[key]&#125;),this&#125;,toString:function()&#123;return exports.stringify(this)&#125;&#125;,&#123;parse:function(url)&#123;var ret=&#123;protocol:&quot;&quot;,auth:&quot;&quot;,hostname:&quot;&quot;,hash:&quot;&quot;,query:&#123;&#125;,port:&quot;&quot;,pathname:&quot;&quot;,slashes:!1&#125;,rest=trim(url),url=!1,proto=rest.match(regProto);if(proto&amp;&amp;(proto=proto[0],ret.protocol=proto.toLowerCase(),rest=rest.substr(proto.length)),proto&amp;&amp;(url=&quot;//&quot;===rest.substr(0,2))&amp;&amp;(rest=rest.slice(2),ret.slashes=!0),url)&#123;for(var proto=rest,hostEnd=-1,i=0,len=hostEndingChars.length;i&lt;len;i++)&#123;var pos=rest.indexOf(hostEndingChars[i]);-1!==pos&amp;&amp;(-1===hostEnd||pos&lt;hostEnd)&amp;&amp;(hostEnd=pos)&#125;-1&lt;hostEnd&amp;&amp;(proto=rest.slice(0,hostEnd),rest=rest.slice(hostEnd));url=proto.lastIndexOf(&quot;@&quot;),url=(-1!==url&amp;&amp;(ret.auth=decodeURIComponent(proto.slice(0,url)),proto=proto.slice(url+1)),(ret.hostname=proto).match(regPort));url&amp;&amp;(&quot;:&quot;!==(url=url[0])&amp;&amp;(ret.port=url.substr(1)),ret.hostname=proto.substr(0,proto.length-url.length))&#125;proto=rest.indexOf(&quot;#&quot;),-1!==proto&amp;&amp;(ret.hash=rest.substr(proto),rest=rest.slice(0,proto)),url=rest.indexOf(&quot;?&quot;);return-1!==url&amp;&amp;(ret.query=query.parse(rest.substr(url+1)),rest=rest.slice(0,url)),ret.pathname=rest||&quot;/&quot;,ret&#125;,stringify:function(obj)&#123;var ret=obj.protocol+(obj.slashes?&quot;//&quot;:&quot;&quot;)+(obj.auth?encodeURIComponent(obj.auth)+&quot;@&quot;:&quot;&quot;)+obj.hostname+(obj.port?&quot;:&quot;+obj.port:&quot;&quot;)+obj.pathname;return isEmpty(obj.query)||(ret+=&quot;?&quot;+query.stringify(obj.query)),obj.hash&amp;&amp;(ret+=obj.hash),ret&#125;&#125;);var regProto=/^([a-z0-9.+-]+:)/i,regPort=/:[0-9]*$/,hostEndingChars=[&quot;/&quot;,&quot;?&quot;,&quot;#&quot;];module.exports=exports&#125;),isBool=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return!0===val||!1===val&#125;&#125;),Validator=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;className:&quot;Validator&quot;,initialize:function(options)&#123;this._options=options,this._optKeys=keys(options)&#125;,validate:function(obj)&#123;obj=obj||&#123;&#125;;for(var options=this._options,objKeys=this._optKeys,i=0,len=objKeys.length;i&lt;len;i++)&#123;var key=objKeys[i],key=this._validateVal(safeGet(obj,key),options[key],key);if(!0!==key)return key&#125;return!0&#125;,_validateVal:function(val,rules,objKey)&#123;var plugins=exports.plugins;if(isFn(rules))return rules(val);for(var ruleKeys=keys(rules),i=0,len=ruleKeys.length;i&lt;len;i++)&#123;var key=ruleKeys[i],config=rules[key],result=!0,key=(isFn(config)&amp;&amp;(result=config(val,objKey)),plugins[key]);if(!0!==(result=key?key(val,objKey,config):result))return result&#125;return!0&#125;&#125;,&#123;plugins:&#123;required:function(val,key,config)&#123;return!config||!isUndef(val)||key+&quot; is required&quot;&#125;,number:function(val,key,config)&#123;return!(config&amp;&amp;!isUndef(val)&amp;&amp;!isNum(val))||key+&quot; should be a number&quot;&#125;,boolean:function(val,key,config)&#123;return!(config&amp;&amp;!isUndef(val)&amp;&amp;!isBool(val))||key+&quot; should be a boolean&quot;&#125;,string:function(val,key,config)&#123;return!(config&amp;&amp;!isUndef(val)&amp;&amp;!isStr(val))||key+&quot; should be a string&quot;&#125;,regexp:function(val,key,config)&#123;return!(isStr(val)&amp;&amp;!config.test(val))||key+&quot; should match given regexp &quot;+config.toString()&#125;&#125;,addPlugin:function(name,plugin)&#123;exports.plugins[name]=plugin&#125;&#125;),module.exports=exports&#125;),max=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var arr=arguments,ret=arr[0],i=1,len=arr.length;i&lt;len;i++)ret&lt;arr[i]&amp;&amp;(ret=arr[i]);return ret&#125;&#125;),gcd=createCommonjsModule(function(module,exports)&#123;module.exports=exports=function(a,b)&#123;return 0===b?a:exports(b,a%b)&#125;&#125;),Wrr=createCommonjsModule(function(module,exports)&#123;exports=Class(&#123;initialize:function()&#123;this._peers=[]&#125;,set:function(val,weight)&#123;for(var peers=this._peers,size=this.size,i=0;i&lt;size;i++)&#123;var peer=peers[i];if(peer.val===val)return peer.weight=weight,void this._reset()&#125;peers.push(&#123;val:val,weight:weight&#125;),this._reset()&#125;,get:function(val)&#123;for(var peers=this._peers,size=this.size,i=0;i&lt;size;i++)&#123;var peer=peers[i];if(peer.val===val)return peer.weight&#125;&#125;,remove:function(val)&#123;this._peers=filter(this._peers,function(peer)&#123;return peer.val!==val&#125;),this._reset()&#125;,next:function()&#123;var peers=this._peers,size=this.size;if(0!==size)for(;;)&#123;if(this._i=(this._i+1)%size,0===this._i&amp;&amp;(this._cw=this._cw-this._gcdS,this._cw&lt;=0&amp;&amp;(this._cw=this._maxS)),0===this._cw)return;if(peers[this._i].weight&gt;=this._cw)return peers[this._i].val&#125;&#125;,clear:function()&#123;this._peers=[],this._reset()&#125;,_reset:function()&#123;var peers=this._peers,peers=(this.size=peers.length,map(peers,function(peer)&#123;return peer.weight&#125;));this._i=-1,this._cw=0,this._maxS=max.apply(null,peers),this._gcdS=reduce(peers,function(prev,weight)&#123;return gcd(prev,weight)&#125;,0)&#125;&#125;),module.exports=exports&#125;),abbrev=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(names)&#123;for(var ret=&#123;&#125;,idleMap=&#123;&#125;,i=0,len=(names=names.sort(isSorted.defComparator)).length;i&lt;len;i++)&#123;var str=names[i],nextStr=names[i+1]||&quot;&quot;;if(str!==nextStr)for(var start=!1,abbrev=&quot;&quot;,j=0,strLen=str.length;j&lt;strLen;j++)abbrev+=str[j],(start=start||str[j]===nextStr[j]&amp;&amp;j!==strLen-1?start:!0)?ret[abbrev]||idleMap[abbrev]||(ret[abbrev]=str):idleMap[abbrev]=str&#125;return ret&#125;),module.exports=exports&#125;),after=createCommonjsModule(function(module,exports)&#123;module.exports=function(n,fn)&#123;return function()&#123;if(--n&lt;1)return fn.apply(this,arguments)&#125;&#125;&#125;),ajax=createCommonjsModule(function(module,exports)&#123;function parseArgs(url,data,success,dataType)&#123;return isFn(data)&amp;&amp;(dataType=success,success=data,data=&#123;&#125;),&#123;url:url,data:data,success:success,dataType:dataType&#125;&#125;(exports=function(options)&#123;defaults(options,exports.setting);var abortTimeout,type=options.type,url=options.url,data=options.data,dataType=options.dataType,success=options.success,error=options.error,timeout=options.timeout,complete=options.complete,xhr=options.xhr();return xhr.onreadystatechange=function()&#123;if(4===xhr.readyState)&#123;clearTimeout(abortTimeout);var status=xhr.status;if(200&lt;=status&amp;&amp;status&lt;300||304===status)&#123;status=xhr.responseText,&quot;xml&quot;===dataType&amp;&amp;(status=xhr.responseXML);try&#123;&quot;json&quot;===dataType&amp;&amp;(status=JSON.parse(status))&#125;catch(e)&#123;&#125;success(status,xhr)&#125;else error(xhr);complete(xhr)&#125;&#125;,&quot;GET&quot;===type?(data=query.stringify(data),url+=-1&lt;url.indexOf(&quot;?&quot;)?&quot;&amp;&quot;+data:&quot;?&quot;+data):&quot;application/x-www-form-urlencoded&quot;===options.contentType?isObj(data)&amp;&amp;(data=query.stringify(data)):&quot;application/json&quot;===options.contentType&amp;&amp;isObj(data)&amp;&amp;(data=JSON.stringify(data)),xhr.open(type,url,!0),xhr.setRequestHeader(&quot;Content-Type&quot;,options.contentType),0&lt;timeout&amp;&amp;(abortTimeout=setTimeout(function()&#123;xhr.onreadystatechange=noop,xhr.abort(),error(xhr,&quot;timeout&quot;),complete(xhr)&#125;,timeout)),xhr.send(&quot;GET&quot;===type?null:data),xhr&#125;).setting=&#123;type:&quot;GET&quot;,success:noop,error:noop,complete:noop,dataType:&quot;json&quot;,contentType:&quot;application/x-www-form-urlencoded&quot;,data:&#123;&#125;,xhr:function()&#123;return new XMLHttpRequest&#125;,timeout:0&#125;,exports.get=function()&#123;return exports(parseArgs.apply(null,arguments))&#125;,exports.post=function()&#123;var options=parseArgs.apply(null,arguments);return options.type=&quot;POST&quot;,exports(options)&#125;,module.exports=exports&#125;),ajax_1=ajax.setting,ajax_2=ajax.get,ajax_3=ajax.post,arrToMap=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,val)&#123;isUndef(val)&amp;&amp;(val=!0);var _isFn=isFn(val),ret=&#123;&#125;;return each(arr,function(key)&#123;ret[key]=_isFn?val(key):val&#125;),ret&#125;&#125;),base64=createCommonjsModule(function(module,exports)&#123;exports=&#123;encode:function(bytes)&#123;var ret=[],len=bytes.length,remain=len%3;len-=remain;for(var num,tmp,i=0;i&lt;len;i+=3)ret.push((num=(bytes[i]&lt;&lt;16)+(bytes[i+1]&lt;&lt;8)+bytes[i+2],code[num&gt;&gt;18&amp;63]+code[num&gt;&gt;12&amp;63]+code[num&gt;&gt;6&amp;63]+code[63&amp;num]));return len=bytes.length,1==remain?(tmp=bytes[len-1],ret.push(code[tmp&gt;&gt;2]),ret.push(code[tmp&lt;&lt;4&amp;63]),ret.push(&quot;==&quot;)):2==remain&amp;&amp;(tmp=(bytes[len-2]&lt;&lt;8)+bytes[len-1],ret.push(code[tmp&gt;&gt;10]),ret.push(code[tmp&gt;&gt;4&amp;63]),ret.push(code[tmp&lt;&lt;2&amp;63]),ret.push(&quot;=&quot;)),ret.join(&quot;&quot;)&#125;,decode:function(str)&#123;for(var str2,str3,str4,tmp,remain=0,ret=(&quot;=&quot;===str[(len=str.length)-2]?remain=2:&quot;=&quot;===str[len-1]&amp;&amp;(remain=1),new Array(3*len/4-remain)),len=0&lt;remain?len-4:len,i=0,j=0;i&lt;len;i+=4)&#123;str1=str[i],str2=str[i+1],str3=str[i+2],str4=str[i+3];var str1=codeMap[str1.charCodeAt(0)]&lt;&lt;18|codeMap[str2.charCodeAt(0)]&lt;&lt;12|codeMap[str3.charCodeAt(0)]&lt;&lt;6|codeMap[str4.charCodeAt(0)];ret[j++]=str1&gt;&gt;16&amp;255,ret[j++]=str1&gt;&gt;8&amp;255,ret[j++]=255&amp;str1&#125;return 2===remain?(tmp=codeMap[str.charCodeAt(i)]&lt;&lt;2|codeMap[str.charCodeAt(i+1)]&gt;&gt;4,ret[j++]=255&amp;tmp):1===remain&amp;&amp;(tmp=codeMap[str.charCodeAt(i)]&lt;&lt;10|codeMap[str.charCodeAt(i+1)]&lt;&lt;4|codeMap[str.charCodeAt(i+2)]&gt;&gt;2,ret[j++]=tmp&gt;&gt;8&amp;255,ret[j++]=255&amp;tmp),ret&#125;&#125;;for(var codeMap=[],code=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,i=0,len=code.length;i&lt;len;i++)codeMap[code.charCodeAt(i)]=i;module.exports=exports&#125;),atob=createCommonjsModule(function(module,exports)&#123;exports=isNode?function(str)&#123;return new Buffer(str,&quot;base64&quot;).toString(&quot;binary&quot;)&#125;:root.atob||function(str)&#123;return map(base64.decode(str),function(c)&#123;return String.fromCharCode(c)&#125;).join(&quot;&quot;)&#125;,module.exports=exports&#125;),binarySearch=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,val)&#123;for(var cmp=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:isSorted.defComparator,startIdx=0,endIdx=arr.length-1;startIdx&lt;=endIdx;)&#123;var middleIdx=startIdx+Math.floor((endIdx-startIdx)/2),middleVal=arr[middleIdx];if(0===cmp(middleVal,val))return middleIdx;cmp(middleVal,val)&lt;0?startIdx=middleIdx+1:endIdx=middleIdx-1&#125;return-1&#125;&#125;),btoa=createCommonjsModule(function(module,exports)&#123;exports=isNode?function(str)&#123;return new Buffer(str,&quot;binary&quot;).toString(&quot;base64&quot;)&#125;:root.btoa||function(str)&#123;return base64.encode(map(str,function(c)&#123;return c.charCodeAt(0)&#125;))&#125;,module.exports=exports&#125;),bubbleSort=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator,i=0,len=arr.length;i&lt;len;i++)for(var j=i;0&lt;j;j--)cmp(arr[j],arr[j-1])&lt;0&amp;&amp;swap(arr,j,j-1);return arr&#125;&#125;),chunk=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,size)&#123;var ret=[];size=size||1;for(var i=0,len=Math.ceil(arr.length/size);i&lt;len;i++)&#123;var start=i*size;ret.push(arr.slice(start,start+size))&#125;return ret&#125;&#125;),ucs2=createCommonjsModule(function(module,exports)&#123;module.exports=&#123;encode:function(arr)&#123;return arr.length&lt;32768?String.fromCodePoint.apply(String,arr):map(chunk(arr,32767),function(nums)&#123;return String.fromCodePoint.apply(String,nums)&#125;).join(&quot;&quot;)&#125;,decode:function(str)&#123;for(var ret=[],i=0,len=str.length;i&lt;len;)&#123;var tail,c=str.charCodeAt(i++);55296&lt;=c&amp;&amp;c&lt;=56319&amp;&amp;i&lt;len?56320==(64512&amp;(tail=str.charCodeAt(i++)))?ret.push(((1023&amp;c)&lt;&lt;10)+(1023&amp;tail)+65536):(ret.push(c),i--):ret.push(c)&#125;return ret&#125;&#125;&#125;),utf8=createCommonjsModule(function(module,exports)&#123;var byteArr,byteIdx,byteCount,codePoint,bytesSeen,bytesNeeded,lowerBoundary,upperBoundary,fromCharCode=String.fromCharCode;function goBack()&#123;var start=byteIdx-bytesSeen-1;return byteIdx=1+start,bytesSeen=bytesNeeded=codePoint=0,lowerBoundary=128,upperBoundary=191,byteArr[start]&#125;module.exports=&#123;encode:function(str)&#123;for(var codePoints=ucs2.decode(str),byteArr=&quot;&quot;,i=0,len=codePoints.length;i&lt;len;i++)byteArr+=function(codePoint)&#123;if(0==(4294967168&amp;codePoint))return fromCharCode(codePoint);var count,offset,ret=&quot;&quot;;0==(4294965248&amp;codePoint)?(count=1,offset=192):0==(4294901760&amp;codePoint)?(count=2,offset=224):0==(4292870144&amp;codePoint)&amp;&amp;(count=3,offset=240);ret+=fromCharCode((codePoint&gt;&gt;6*count)+offset);for(;0&lt;count;)ret+=fromCharCode(128|63&amp;codePoint&gt;&gt;6*(count-1)),count--;return ret&#125;(codePoints[i]);return byteArr&#125;,decode:function(str,safe)&#123;byteArr=ucs2.decode(str),byteIdx=0,byteCount=byteArr.length,bytesNeeded=bytesSeen=codePoint=0,lowerBoundary=128,upperBoundary=191;for(var tmp,codePoints=[];!1!==(tmp=function(safe)&#123;for(;;)&#123;if(byteCount&lt;=byteIdx&amp;&amp;bytesNeeded)&#123;if(safe)return goBack();throw new Error(&quot;Invalid byte index&quot;)&#125;if(byteIdx===byteCount)return!1;var tmp,byte=byteArr[byteIdx];if(byteIdx++,bytesNeeded)&#123;if(byte&lt;lowerBoundary||upperBoundary&lt;byte)&#123;if(safe)return byteIdx--,goBack();throw new Error(&quot;Invalid continuation byte&quot;)&#125;if(lowerBoundary=128,upperBoundary=191,codePoint=codePoint&lt;&lt;6|63&amp;byte,++bytesSeen===bytesNeeded)return tmp=codePoint,bytesSeen=bytesNeeded=codePoint=0,tmp&#125;else&#123;if(0==(128&amp;byte))return byte;if(192==(224&amp;byte))bytesNeeded=1,codePoint=31&amp;byte;else if(224==(240&amp;byte))224===byte&amp;&amp;(lowerBoundary=160),237===byte&amp;&amp;(upperBoundary=159),bytesNeeded=2,codePoint=15&amp;byte;else&#123;if(240!=(248&amp;byte))&#123;if(safe)return goBack();throw new Error(&quot;Invalid UTF-8 detected&quot;)&#125;240===byte&amp;&amp;(lowerBoundary=144),244===byte&amp;&amp;(upperBoundary=143),bytesNeeded=3,codePoint=7&amp;byte&#125;&#125;&#125;&#125;(safe));)codePoints.push(tmp);return ucs2.encode(codePoints)&#125;&#125;&#125;),bytesToStr=createCommonjsModule(function(module,exports)&#123;module.exports=function(bytes)&#123;var encoding=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&quot;utf8&quot;;if(&quot;hex&quot;===encoding)return hex.encode(bytes);if(&quot;base64&quot;===encoding)return base64.encode(bytes);for(var str=[],i=0,len=bytes.length;i&lt;len;i++)str.push(String.fromCharCode(bytes[i]));return str=str.join(&quot;&quot;),str=&quot;utf8&quot;===encoding?utf8.decode(str):str&#125;&#125;),bytesToWords=createCommonjsModule(function(module,exports)&#123;module.exports=function(bytes)&#123;for(var words=[],i=0,len=bytes.length;i&lt;len;i++)words[i&gt;&gt;&gt;2]|=bytes[i]&lt;&lt;24-i%4*8;return words&#125;&#125;),callbackify=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn)&#123;return restArgs(function(args)&#123;var cb=args.pop();fn.apply(this,args).then(function(value)&#123;cb(null,value)&#125;,function(err)&#123;null===err&amp;&amp;(err=new Error),cb(err)&#125;)&#125;)&#125;&#125;),capitalize=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return str.charAt(0).toUpperCase()+str.substring(1).toLowerCase()&#125;&#125;),size=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;return(isArrLike(obj)?obj:keys(obj)).length&#125;&#125;),longest=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;if(!(arr.length&lt;1))&#123;for(var ret=arr[0],retSize=size(arr[0]),i=1,len=arr.length;i&lt;len;i++)&#123;var elSize=size(arr[i]);retSize&lt;elSize&amp;&amp;(ret=arr[i],retSize=elSize)&#125;return ret&#125;&#125;&#125;),lpad=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,len,chars)&#123;var strLen=(str=toStr(str)).length;return chars=chars||&quot; &quot;,str=strLen&lt;len?(repeat(chars,len-strLen)+str).slice(-len):str&#125;&#125;),centerAlign=createCommonjsModule(function(module,exports)&#123;var regLineBreak=/\\n/g,floor=Math.floor;module.exports=function(str,width)&#123;var ret=str;return isArr(ret)||(ret=ret.split(regLineBreak)),isUndef(width)&amp;&amp;(width=longest(str)),(ret=map(ret,function(str)&#123;var len=str.length;return lpad(str,floor((width-len)/2)+len)&#125;)).join(&quot;\\n&quot;)&#125;&#125;),char_1=createCommonjsModule(function(module,exports)&#123;module.exports=function(num)&#123;return String.fromCodePoint(num)&#125;&#125;),className=createCommonjsModule(function(module,exports)&#123;module.exports=exports=function()&#123;var ret=[];return each(arguments,function(arg)&#123;if(arg)return isStr(arg)||isNum(arg)?ret.push(arg):isArr(arg)?ret.push(exports.apply(null,arg)):void(isObj(arg)&amp;&amp;each(arg,function(val,key)&#123;val&amp;&amp;ret.push(key)&#125;))&#125;),ret.join(&quot; &quot;)&#125;&#125;),_escape=createCommonjsModule(function(module,exports)&#123;var map=(exports=function(str)&#123;return regTest.test(str)?str.replace(regReplace,replaceFn):str&#125;).map=&#123;&quot;&amp;&quot;:&quot;&amp;amp;&quot;,&quot;&lt;&quot;:&quot;&amp;lt;&quot;,&quot;&gt;&quot;:&quot;&amp;gt;&quot;,&apos;&quot;&apos;:&quot;&amp;quot;&quot;,&quot;&apos;&quot;:&quot;&amp;#x27;&quot;,&quot;`&quot;:&quot;&amp;#x60;&quot;&#125;,regSrc=&quot;(?:&quot;+keys(map).join(&quot;|&quot;)+&quot;)&quot;,regTest=new RegExp(regSrc),regReplace=new RegExp(regSrc,&quot;g&quot;),replaceFn=function(match)&#123;return map[match]&#125;;module.exports=exports&#125;),_escape_1=_escape.map,escapeJsStr=createCommonjsModule(function(module,exports)&#123;var regEscapeChars=/[&quot;&apos;\\\\\\n\\r\\u2028\\u2029]/g;module.exports=function(str)&#123;return toStr(str).replace(regEscapeChars,function(char)&#123;switch(char)&#123;case&apos;&quot;&apos;:case&quot;&apos;&quot;:case&quot;\\\\&quot;:return&quot;\\\\&quot;+char;case&quot;\\n&quot;:return&quot;\\\\n&quot;;case&quot;\\r&quot;:return&quot;\\\\r&quot;;case&quot;\\u2028&quot;:return&quot;\\\\u2028&quot;;case&quot;\\u2029&quot;:return&quot;\\\\u2029&quot;&#125;&#125;)&#125;&#125;),template=createCommonjsModule(function(module,exports)&#123;var regMatcher=/&lt;%-([\\s\\S]+?)%&gt;|&lt;%=([\\s\\S]+?)%&gt;|&lt;%([\\s\\S]+?)%&gt;|$/g;module.exports=function(str,util)&#123;util?defaults(util,&#123;escape:_escape&#125;):util=&quot;object&quot;==typeof _?_:&#123;escape:_escape&#125;;var index=0,src=&quot;__p+=&apos;&quot;,render=(str.replace(regMatcher,function(match,escape,interpolate,evaluate,offset)&#123;return src+=escapeJsStr(str.slice(index,offset)),index=offset+match.length,escape?src+=&quot;&apos;+\\n((__t=(&quot;.concat(escape,&quot;))==null?&apos;&apos;:util.escape(__t))+\\n&apos;&quot;):interpolate?src+=&quot;&apos;+\\n((__t=(&quot;.concat(interpolate,&quot;))==null?&apos;&apos;:__t)+\\n&apos;&quot;):evaluate&amp;&amp;(src+=&quot;&apos;;\\n&quot;.concat(evaluate,&quot;\\n__p+=&apos;&quot;)),match&#125;),src+=&quot;&apos;;\\n&quot;,src=&quot;with(obj||&#123;&#125;)&#123;\\n&quot;.concat(src,&quot;&#125;\\n&quot;),src=&quot;var __t,__p=&apos;&apos;,__j=Array.prototype.join,print=function()&#123;__p+=__j.call(arguments,&apos;&apos;);&#125;;\\n&quot;.concat(src,&quot;return __p;\\n&quot;),new Function(&quot;obj&quot;,&quot;util&quot;,src));return function(data)&#123;return render.call(null,data,util)&#125;&#125;&#125;),rpad=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,len,chars)&#123;var strLen=(str=toStr(str)).length;return chars=chars||&quot; &quot;,str=strLen&lt;len?(str+repeat(chars,len-strLen)).slice(0,len):str&#125;&#125;),ansiColor=createCommonjsModule(function(module,exports)&#123;function genColor(codes)&#123;const open=`\u001b[$&#123;codes[0]&#125;m`,close=`\u001b[$&#123;codes[1]&#125;m`;return input=&gt;open+input+close&#125;exports=&#123;black:genColor([0,0]),red:genColor([31,39]),green:genColor([32,39]),yellow:genColor([33,39]),blue:genColor([34,39]),magenta:genColor([35,39]),cyan:genColor([36,39]),white:genColor([37,39]),gray:genColor([90,39]),grey:genColor([90,39]),bgBlack:genColor([40,49]),bgRed:genColor([41,49]),bgGreen:genColor([42,49]),bgYellow:genColor([43,49]),bgBlue:genColor([44,49]),bgMagenta:genColor([45,49]),bgCyan:genColor([46,49]),bgWhite:genColor([47,49]),blackBright:genColor([90,39]),redBright:genColor([91,39]),greenBright:genColor([92,39]),yellowBright:genColor([93,39]),blueBright:genColor([94,39]),magentaBright:genColor([95,39]),cyanBright:genColor([96,39]),whiteBright:genColor([97,39]),bgBlackBright:genColor([100,49]),bgRedBright:genColor([101,49]),bgGreenBright:genColor([102,49]),bgYellowBright:genColor([103,49]),bgBlueBright:genColor([104,49]),bgMagentaBright:genColor([105,49]),bgCyanBright:genColor([106,49]),bgWhiteBright:genColor([107,49])&#125;,module.exports=exports&#125;),cliHelp=createCommonjsModule(function(module,exports)&#123;exports=function(data)&#123;if((data=cloneDeep(data)).usage=toArr(data.usage),data.commands)return cmdNameWidths=map(data.commands,function(command)&#123;return strWidth(command.name)&#125;),data.maxNameWidth=max.apply(null,cmdNameWidths),helpTpl(data);each(data.options,function(option)&#123;option.name=(option.shorthand?&quot;-&quot;+option.shorthand+&quot;, &quot;:&quot; &quot;)+&quot;--&quot;+option.name&#125;);var cmdNameWidths=map(data.options,function(option)&#123;return strWidth(option.name)&#125;);return data.maxNameWidth=max.apply(null,cmdNameWidths),cmdTpl(data)&#125;;var tplUtil=&#123;each:each,rpad:function(text,len)&#123;return rpad(text,len,&quot; &quot;)&#125;&#125;,cmdTpl=(each([&quot;yellow&quot;,&quot;green&quot;,&quot;cyan&quot;,&quot;red&quot;,&quot;white&quot;,&quot;magenta&quot;],function(color)&#123;tplUtil[color]=function(text)&#123;return ansiColor[color](text)&#125;&#125;),template([&quot;Usage:&quot;,&quot;&quot;,&quot;&lt;% util.each(usage, function (value) &#123; %&gt; &lt;%=util.cyan(name)%&gt; &lt;%=value%&gt;&lt;%=&apos;\\\\n&apos;%&gt;&lt;% &#125;); %&gt;&quot;,&quot;&lt;% if (options) &#123; %&gt;Options:&quot;,&quot;&quot;,&quot;&lt;% util.each(options, function (option) &#123; %&gt; &lt;%=util.yellow(util.rpad(option.name, maxNameWidth))%&gt; &lt;%=option.desc%&gt;&lt;%=&apos;\\\\n&apos;%&gt;&lt;% &#125;); %&gt;&quot;,&quot;&lt;% &#125; %&gt;Description:&quot;,&quot;&quot;,&quot; &lt;%=desc%&gt;&quot;].join(&quot;\\n&quot;),tplUtil)),helpTpl=template([&quot;Usage:&quot;,&quot;&quot;,&quot;&lt;% util.each(usage, function (value) &#123; %&gt; &lt;%=util.cyan(name)%&gt; &lt;%=value%&gt;&lt;%=&apos;\\\\n&apos;%&gt;&lt;% &#125;); %&gt;&quot;,&quot;Commands:&quot;,&quot;&quot;,&quot;&lt;% util.each(commands, function (command) &#123; %&gt; &lt;%=util.yellow(util.rpad(command.name, maxNameWidth))%&gt; &lt;%=command.desc%&gt;&lt;%=&apos;\\\\n&apos;%&gt;&lt;% &#125;); %&gt;&quot;,&quot;Run &apos;&lt;%=util.cyan(name + &apos; help &lt;command&gt;&apos;)%&gt;&apos; for more information on a specific command&quot;].join(&quot;\\n&quot;),tplUtil);module.exports=exports&#125;),toNum=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return isNum(val)?val:(isObj(val)&amp;&amp;(temp=isFn(val.valueOf)?val.valueOf():val,val=isObj(temp)?temp+&quot;&quot;:temp),!isStr(val)&amp;&amp;0===val?val:+val);var temp&#125;&#125;),toInt=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return val?(val=toNum(val))-val%1:0===val?val:0&#125;&#125;),cmpVersion=createCommonjsModule(function(module,exports)&#123;module.exports=function(v1,v2)&#123;v1=v1.split(&quot;.&quot;),v2=v2.split(&quot;.&quot;);for(var len=max(v1.length,v2.length),i=0;i&lt;len;i++)&#123;var num1=toInt(v1[i]),num2=toInt(v2[i]);if(num2&lt;num1)return 1;if(num1&lt;num2)return-1&#125;return 0&#125;&#125;),combine=createCommonjsModule(function(module,exports)&#123;module.exports=function(keys,values)&#123;for(var ret=&#123;&#125;,i=0,len=keys.length;i&lt;len;i++)ret[keys[i]]=values[i];return ret&#125;&#125;),compact=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;return filter(arr,function(val)&#123;return!!val&#125;)&#125;&#125;),compose=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(fnList)&#123;return function()&#123;for(var i=fnList.length-1,result=fnList[i].apply(this,arguments);i--;)result=fnList[i].call(this,result);return result&#125;&#125;),module.exports=exports&#125;),loadImg=createCommonjsModule(function(module,exports)&#123;module.exports=function(src,cb)&#123;cb=cb||noop;var img=new Image;img.onload=function()&#123;cb(null,img)&#125;,img.onerror=function(err)&#123;cb(err)&#125;,img.src=src&#125;&#125;),isBlob=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Blob]&quot;===objToStr(val)&#125;&#125;),isFile=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object File]&quot;===objToStr(val)&#125;&#125;),createUrl=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;type:&quot;text/plain&quot;&#125;;module.exports=function(data,options)&#123;return defaults(options=options||&#123;&#125;,defOpts),isBlob(data)||isFile(data)||(data=new Blob$1(toArr(data),options)),URL.createObjectURL(data)&#125;&#125;),compressImg=createCommonjsModule(function(module,exports)&#123;var defOptions=&#123;maxWidth:1/0,maxHeight:1/0,quality:.8&#125;,floor=Math.floor;module.exports=function(file,options,cb)&#123;isFn(options)&amp;&amp;(cb=options,options=&#123;&#125;),cb=cb||noop,defaults(options=options||&#123;&#125;,defOptions),options.mimeType=options.mimeType||file.type,isStr(file)?options.isUrl=!0:file=createUrl(file),loadImg(file,function(err,img)&#123;if(err)return cb(err);!function(img,options,cb)&#123;var canvas=document.createElement(&quot;canvas&quot;),ctx=canvas.getContext(&quot;2d&quot;),width=img.width,height=img.height,ratio=width/height,maxWidth=options.maxWidth,maxHeight=options.maxHeight;options.width||options.height?options.width?(width=options.width,height=width/ratio):options.height&amp;&amp;(height=options.height,width=height*ratio):(maxWidth&lt;width&amp;&amp;(height=(width=maxWidth)/ratio),maxHeight&lt;height&amp;&amp;(width=(height=maxHeight)*ratio));width=floor(width),height=floor(height),canvas.width=width,canvas.height=height,ctx.drawImage(img,0,0,width,height),URL&amp;&amp;options.isUrl&amp;&amp;URL.revokeObjectURL(img.src);if(canvas.toBlob)try&#123;canvas.toBlob(function(file)&#123;cb(null,file)&#125;,options.mimeType,options.quality)&#125;catch(e)&#123;cb(e)&#125;else cb(new Error(&quot;Canvas toBlob is not supported&quot;))&#125;(img,options,cb)&#125;)&#125;&#125;),concat=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var args=toArr(arguments),ret=[],i=0,len=args.length;i&lt;len;i++)ret=ret.concat(toArr(args[i]));return ret&#125;&#125;),isArrBuffer=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object ArrayBuffer]&quot;===objToStr(val)&#125;&#125;),convertBin=createCommonjsModule(function(module,exports)&#123;(exports=function(bin,t)&#123;if(t=lowerCase(t),isStr(bin))result=new Uint8Array(base64.decode(bin));else if(isArrBuffer(bin))bin=bin.slice(0),result=new Uint8Array(bin);else if(isArr(bin))result=new Uint8Array(bin);else if(&quot;uint8array&quot;===type(bin))result=bin.slice(0);else if(isBuffer(bin))for(var result=new Uint8Array(bin.length),i=0;i&lt;bin.length;i++)result[i]=bin[i];if(result)switch(t)&#123;case&quot;base64&quot;:result=base64.encode(result);break;case&quot;arraybuffer&quot;:result=result.buffer;break;case&quot;array&quot;:result=[].slice.call(result);break;case&quot;buffer&quot;:result=Buffer.from(result);break;case&quot;blob&quot;:result=new Blob([result.buffer])&#125;return result&#125;).blobToArrBuffer=function(blob)&#123;return new Promise(function(resolve,reject)&#123;var fileReader=new FileReader;fileReader.onload=function(e)&#123;resolve(e.target.result)&#125;,fileReader.onerror=function(err)&#123;reject(err)&#125;,fileReader.readAsArrayBuffer(blob)&#125;)&#125;,module.exports=exports&#125;),convertBin_1=convertBin.blobToArrBuffer,decodeUriComponent=createCommonjsModule(function(module,exports)&#123;function hexToInt(numStr)&#123;return+(&quot;0x&quot;+numStr)&#125;var regMatcher=/(%[a-f0-9]&#123;2&#125;)+/gi;module.exports=function(str)&#123;try&#123;return decodeURIComponent(str)&#125;catch(e)&#123;var matches=str.match(regMatcher);return matches?(each(matches,function(match)&#123;str=str.replace(match,function(str)&#123;str=str.split(&quot;%&quot;).slice(1);var bytes=map(str,hexToInt);return str=ucs2.encode(bytes),str=utf8.decode(str,!0)&#125;(match))&#125;),str):str&#125;&#125;&#125;),cookie=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;path:&quot;/&quot;&#125;;function setCookie(key,val,options)&#123;var expires;if(!isUndef(val))return options=defaults(options=options||&#123;&#125;,defOpts),isNum(options.expires)&amp;&amp;((expires=new Date).setMilliseconds(expires.getMilliseconds()+864e5*options.expires),options.expires=expires),val=encodeURIComponent(val),key=encodeURIComponent(key),document.cookie=[key,&quot;=&quot;,val,options.expires&amp;&amp;&quot;; expires=&quot;+options.expires.toUTCString(),options.path&amp;&amp;&quot;; path=&quot;+options.path,options.domain&amp;&amp;&quot;; domain=&quot;+options.domain,options.secure?&quot;; secure&quot;:&quot;&quot;].join(&quot;&quot;),exports;for(var cookies=document.cookie?document.cookie.split(&quot;; &quot;):[],result=key?void 0:&#123;&#125;,i=0,len=cookies.length;i&lt;len;i++)&#123;var parts=(c=cookies[i]).split(&quot;=&quot;),name=decodeUriComponent(parts.shift()),c=parts.join(&quot;=&quot;);if(c=decodeUriComponent(c),key===name)&#123;result=c;break&#125;key||(result[name]=c)&#125;return result&#125;exports=&#123;get:setCookie,set:setCookie,remove:function(key,options)&#123;return(options=options||&#123;&#125;).expires=-1,setCookie(key,&quot;&quot;,options)&#125;&#125;,module.exports=exports&#125;),copy=createCommonjsModule(function(module,exports)&#123;module.exports=function(text,cb)&#123;cb=cb||noop;var el=document.createElement(&quot;textarea&quot;),body=document.body;extend(el.style,&#123;fontSize:&quot;12pt&quot;,border:&quot;0&quot;,padding:&quot;0&quot;,margin:&quot;0&quot;,position:&quot;absolute&quot;,left:&quot;-9999px&quot;&#125;),el.value=text,body.appendChild(el),el.setAttribute(&quot;readonly&quot;,&quot;&quot;),el.select(),el.setSelectionRange(0,text.length);try&#123;document.execCommand(&quot;copy&quot;),cb()&#125;catch(e)&#123;cb(e)&#125;finally&#123;body.removeChild(el)&#125;&#125;&#125;),strToBytes=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;var encoding=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&quot;utf8&quot;;if(&quot;hex&quot;===encoding)return hex.decode(str);if(&quot;base64&quot;===encoding)return base64.decode(str);for(var bytes=[],i=0,len=(str=&quot;utf8&quot;===encoding?utf8.encode(str):str).length;i&lt;len;i++)bytes.push(255&amp;str.charCodeAt(i));return bytes&#125;&#125;),crc1=createCommonjsModule(function(module,exports)&#123;(exports=function(input,previous)&#123;return exports.signed(input,previous)&gt;&gt;&gt;0&#125;).signed=function(input,previous)&#123;for(var previous=~~previous,accum=0,i=0,len=(input=isStr(input)?strToBytes(input):input).length;i&lt;len;i++)accum+=input[i];return(previous+=accum%256)%256&#125;,module.exports=exports&#125;),crc1_1=crc1.signed,crc16=createCommonjsModule(function(module,exports)&#123;var TABLE=[0,49345,49537,320,49921,960,640,49729,50689,1728,1920,51009,1280,50625,50305,1088,52225,3264,3456,52545,3840,53185,52865,3648,2560,51905,52097,2880,51457,2496,2176,51265,55297,6336,6528,55617,6912,56257,55937,6720,7680,57025,57217,8e3,56577,7616,7296,56385,5120,54465,54657,5440,55041,6080,5760,54849,53761,4800,4992,54081,4352,53697,53377,4160,61441,12480,12672,61761,13056,62401,62081,12864,13824,63169,63361,14144,62721,13760,13440,62529,15360,64705,64897,15680,65281,16320,16e3,65089,64001,15040,15232,64321,14592,63937,63617,14400,10240,59585,59777,10560,60161,11200,10880,59969,60929,11968,12160,61249,11520,60865,60545,11328,58369,9408,9600,58689,9984,59329,59009,9792,8704,58049,58241,9024,57601,8640,8320,57409,40961,24768,24960,41281,25344,41921,41601,25152,26112,42689,42881,26432,42241,26048,25728,42049,27648,44225,44417,27968,44801,28608,28288,44609,43521,27328,27520,43841,26880,43457,43137,26688,30720,47297,47489,31040,47873,31680,31360,47681,48641,32448,32640,48961,32e3,48577,48257,31808,46081,29888,30080,46401,30464,47041,46721,30272,29184,45761,45953,29504,45313,29120,28800,45121,20480,37057,37249,20800,37633,21440,21120,37441,38401,22208,22400,38721,21760,38337,38017,21568,39937,23744,23936,40257,24320,40897,40577,24128,23040,39617,39809,23360,39169,22976,22656,38977,34817,18624,18816,35137,19200,35777,35457,19008,19968,36545,36737,20288,36097,19904,19584,35905,17408,33985,34177,17728,34561,18368,18048,34369,33281,17088,17280,33601,16640,33217,32897,16448];&quot;undefined&quot;!=typeof Int32Array&amp;&amp;(TABLE=new Int32Array(TABLE)),(exports=function(input,previous)&#123;return exports.signed(input,previous)&gt;&gt;&gt;0&#125;).signed=function(input,previous)&#123;for(var crc=~~previous,i=0,len=(input=isStr(input)?strToBytes(input):input).length;i&lt;len;i++)var byte=input[i],crc=65535&amp;(TABLE[255&amp;(crc^byte)]^crc&gt;&gt;8);return crc&#125;,module.exports=exports&#125;),crc16_1=crc16.signed,crc32=createCommonjsModule(function(module,exports)&#123;for(var TABLE=[],n=0;n&lt;256;n++)&#123;for(var c=n,k=0;k&lt;8;k++)1&amp;c?c=3988292384^c&gt;&gt;&gt;1:c&gt;&gt;&gt;=1;TABLE[n]=c&gt;&gt;&gt;0&#125;&quot;undefined&quot;!=typeof Int32Array&amp;&amp;(TABLE=new Int32Array(TABLE)),(exports=function(input,previous)&#123;return exports.signed(input,previous)&gt;&gt;&gt;0&#125;).signed=function(input,previous)&#123;for(var crc=0===previous?0:-1^~~previous,i=0,len=(input=isStr(input)?strToBytes(input):input).length;i&lt;len;i++)var byte=input[i],crc=TABLE[255&amp;(crc^byte)]^crc&gt;&gt;&gt;8;return-1^crc&#125;,module.exports=exports&#125;),crc32_1=crc32.signed,crc8=createCommonjsModule(function(module,exports)&#123;var TABLE=[0,7,14,9,28,27,18,21,56,63,54,49,36,35,42,45,112,119,126,121,108,107,98,101,72,79,70,65,84,83,90,93,224,231,238,233,252,251,242,245,216,223,214,209,196,195,202,205,144,151,158,153,140,139,130,133,168,175,166,161,180,179,186,189,199,192,201,206,219,220,213,210,255,248,241,246,227,228,237,234,183,176,185,190,171,172,165,162,143,136,129,134,147,148,157,154,39,32,41,46,59,60,53,50,31,24,17,22,3,4,13,10,87,80,89,94,75,76,69,66,111,104,97,102,115,116,125,122,137,142,135,128,149,146,155,156,177,182,191,184,173,170,163,164,249,254,247,240,229,226,235,236,193,198,207,200,221,218,211,212,105,110,103,96,117,114,123,124,81,86,95,88,77,74,67,68,25,30,23,16,5,2,11,12,33,38,47,40,61,58,51,52,78,73,64,71,82,85,92,91,118,113,120,127,106,109,100,99,62,57,48,55,34,37,44,43,6,1,8,15,26,29,20,19,174,169,160,167,178,181,188,187,150,145,152,159,138,141,132,131,222,217,208,215,194,197,204,203,230,225,232,239,250,253,244,243];&quot;undefined&quot;!=typeof Int32Array&amp;&amp;(TABLE=new Int32Array(TABLE)),(exports=function(input,previous)&#123;return exports.signed(input,previous)&gt;&gt;&gt;0&#125;).signed=function(input,previous)&#123;for(var crc=~~previous,i=0,len=(input=isStr(input)?strToBytes(input):input).length;i&lt;len;i++)var byte=input[i],crc=255&amp;TABLE[255&amp;(crc^byte)];return crc&#125;,module.exports=exports&#125;),crc8_1=crc8.signed,css=createCommonjsModule(function(module,exports)&#123;exports=&#123;parse:function(css)&#123;return new Parser(css).parse()&#125;,stringify:function(stylesheet,options)&#123;return new Compiler(stylesheet,options).compile()&#125;&#125;;var regComments=/(\\/\\*[\\s\\S]*?\\*\\/)/gi,regOpen=/^&#123;\\s*/,regClose=/^&#125;/,regWhitespace=/^\\s*/,regProperty=/^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/,regValue=/^((?:&apos;(?:\\\\&apos;|.)*?&apos;|&quot;(?:\\\\&quot;|.)*?&quot;|\\([^)]*?\\)|[^&#125;;])+)/,regSelector=/^([^&#123;]+)/,regSemicolon=/^[;\\s]*/,regColon=/^:\\s*/,regMedia=/^@media *([^&#123;]+)/,regKeyframes=/^@([-\\w]+)?keyframes\\s*/,regFontFace=/^@font-face\\s*/,regSupports=/^@supports *([^&#123;]+)/,regIdentifier=/^([-\\w]+)\\s*/,regKeyframeSelector=/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/,regComma=/^,\\s*/,Parser=Class(&#123;initialize:function(css)&#123;this.input=stripCmt(css),this.open=this._createMatcher(regOpen),this.close=this._createMatcher(regClose),this.whitespace=this._createMatcher(regWhitespace),this.atImport=this._createAtRule(&quot;import&quot;),this.atCharset=this._createAtRule(&quot;charset&quot;),this.atNamespace=this._createAtRule(&quot;namespace&quot;)&#125;,parse:function()&#123;return this.stylesheet()&#125;,stylesheet:function()&#123;return&#123;type:&quot;stylesheet&quot;,rules:this.rules()&#125;&#125;,rules:function()&#123;var rule,rules=[];for(this.whitespace();this.input.length&amp;&amp;&quot;&#125;&quot;!==this.input[0]&amp;&amp;(rule=this.atRule()||this.rule());)rules.push(rule),this.whitespace();return rules&#125;,atRule:function()&#123;if(&quot;@&quot;===this.input[0])return this.atKeyframes()||this.atMedia()||this.atSupports()||this.atImport()||this.atCharset()||this.atNamespace()||this.atFontFace()&#125;,atKeyframes:function()&#123;if(matched=this.match(regKeyframes))&#123;var vendor=matched[1]||&quot;&quot;;if(!(matched=this.match(regIdentifier)))throw Error(&quot;@keyframes missing name&quot;);var matched=matched[1];if(!this.open())throw Error(&quot;@keyframes missing &apos;&#123;&apos;&quot;);for(var keyframe,keyframes=[];keyframe=this.keyframe();)keyframes.push(keyframe);if(!this.close())throw Error(&quot;@keyframes missing &apos;&#125;&apos;&quot;);return&#123;type:&quot;keyframes&quot;,name:matched,vendor:vendor,keyframes:keyframes&#125;&#125;&#125;,keyframe:function()&#123;for(var matched,selector=[];matched=this.match(regKeyframeSelector);)selector.push(matched[1]),this.match(regComma);if(selector.length)return this.whitespace(),&#123;type:&quot;keyframe&quot;,selector:selector.join(&quot;, &quot;),declarations:this.declarations()&#125;&#125;,atSupports:function()&#123;var matched=this.match(regSupports);if(matched)&#123;matched=trim(matched[1]);if(!this.open())throw Error(&quot;@supports missing &apos;&#123;&apos;&quot;);var rules=this.rules();if(!this.close())throw Error(&quot;@supports missing &apos;&#125;&apos;&quot;);return&#123;type:&quot;supports&quot;,supports:matched,rules:rules&#125;&#125;&#125;,atFontFace:function()&#123;if(this.match(regFontFace))&#123;if(!this.open())throw Error(&quot;@font-face missing &apos;&#123;&apos;&quot;);for(var declaration,declarations=[];declaration=this.declaration();)declarations.push(declaration);if(!this.close())throw Error(&quot;@font-face missing &apos;&#125;&apos;&quot;);return&#123;type:&quot;font-face&quot;,declarations:declarations&#125;&#125;&#125;,atMedia:function()&#123;var matched=this.match(regMedia);if(matched)&#123;matched=trim(matched[1]);if(!this.open())throw Error(&quot;@media missing &apos;&#123;&apos;&quot;);this.whitespace();var rules=this.rules();if(!this.close())throw Error(&quot;@media missing &apos;&#125;&apos;&quot;);return&#123;type:&quot;media&quot;,media:matched,rules:rules&#125;&#125;&#125;,rule:function()&#123;var selector=this.selector();if(!selector)throw Error(&quot;missing selector&quot;);return&#123;type:&quot;rule&quot;,selector:selector,declarations:this.declarations()&#125;&#125;,declarations:function()&#123;var declaration,declarations=[];if(!this.open())throw Error(&quot;missing &apos;&#123;&apos;&quot;);for(this.whitespace();declaration=this.declaration();)declarations.push(declaration);if(!this.close())throw Error(&quot;missing &apos;&#125;&apos;&quot;);return this.whitespace(),declarations&#125;,declaration:function()&#123;var property=this.match(regProperty);if(property)&#123;if(property=trim(property[0]),!this.match(regColon))throw Error(&quot;property missing &apos;:&apos;&quot;);var value=this.match(regValue);return this.match(regSemicolon),this.whitespace(),&#123;type:&quot;declaration&quot;,property:property,value:value?trim(value[0]):&quot;&quot;&#125;&#125;&#125;,selector:function()&#123;var matched=this.match(regSelector);if(matched)return trim(matched[0])&#125;,match:function(reg)&#123;reg=reg.exec(this.input);if(reg)return this.input=this.input.slice(reg[0].length),reg&#125;,_createMatcher:function(reg)&#123;var _this=this;return function()&#123;return _this.match(reg)&#125;&#125;,_createAtRule:function(name)&#123;var reg=new RegExp(&quot;^@&quot;+name+&quot;\\\\s*([^;]+);&quot;);return function()&#123;var ret,matched=this.match(reg);if(matched)return ret=&#123;type:name&#125;,ret[name]=trim(matched[1]),ret&#125;&#125;&#125;),Compiler=Class(&#123;initialize:function(input)&#123;var options=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;;defaults(options,&#123;indent:&quot; &quot;&#125;),this.input=input,this.indentLevel=0,this.indentation=options.indent&#125;,compile:function()&#123;return this.stylesheet(this.input)&#125;,stylesheet:function(node)&#123;return this.mapVisit(node.rules,&quot;\\n\\n&quot;)&#125;,media:function(node)&#123;return&quot;@media &quot;+node.media+&quot; &#123;\\n&quot;+this.indent(1)+this.mapVisit(node.rules,&quot;\\n\\n&quot;)+this.indent(-1)+&quot;\\n&#125;&quot;&#125;,keyframes:function(node)&#123;return&quot;@&quot;.concat(node.vendor,&quot;keyframes &quot;)+node.name+&quot; &#123;\\n&quot;+this.indent(1)+this.mapVisit(node.keyframes,&quot;\\n&quot;)+this.indent(-1)+&quot;\\n&#125;&quot;&#125;,supports:function(node)&#123;return&quot;@supports &quot;+node.supports+&quot; &#123;\\n&quot;+this.indent(1)+this.mapVisit(node.rules,&quot;\\n\\n&quot;)+this.indent(-1)+&quot;\\n&#125;&quot;&#125;,keyframe:function(node)&#123;return this.rule(node)&#125;,mapVisit:function(nodes,delimiter)&#123;for(var str=&quot;&quot;,i=0,len=nodes.length;i&lt;len;i++)&#123;var node=nodes[i];str+=this[camelCase(node.type)](node),delimiter&amp;&amp;i&lt;len-1&amp;&amp;(str+=delimiter)&#125;return str&#125;,fontFace:function(node)&#123;return&quot;@font-face &#123;\\n&quot;+this.indent(1)+this.mapVisit(node.declarations,&quot;\\n&quot;)+this.indent(-1)+&quot;\\n&#125;&quot;&#125;,rule:function(node)&#123;return this.indent()+node.selector+&quot; &#123;\\n&quot;+this.indent(1)+this.mapVisit(node.declarations,&quot;\\n&quot;)+this.indent(-1)+&quot;\\n&quot;+this.indent()+&quot;&#125;&quot;&#125;,declaration:function(node)&#123;return this.indent()+node.property+&quot;: &quot;+node.value+&quot;;&quot;&#125;,import:function(node)&#123;return&quot;@import &quot;.concat(node.import,&quot;;&quot;)&#125;,charset:function(node)&#123;return&quot;@charset &quot;.concat(node.charset,&quot;;&quot;)&#125;,namespace:function(node)&#123;return&quot;@namespace &quot;.concat(node.namespace,&quot;;&quot;)&#125;,indent:function(level)&#123;return level?(this.indentLevel+=level,&quot;&quot;):repeat(this.indentation,this.indentLevel)&#125;&#125;),stripCmt=function(str)&#123;return str.replace(regComments,&quot;&quot;)&#125;;module.exports=exports&#125;),selector=createCommonjsModule(function(module,exports)&#123;var whitespace=&quot;[\\\\x20\\\\t\\\\r\\\\n\\\\f]&quot;,identifier=&quot;(?:\\\\\\\\[\\\\da-fA-F]&#123;1,6&#125;&quot;.concat(whitespace,&quot;?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+&quot;),attributes=&quot;\\\\[&quot;.concat(whitespace,&quot;*(&quot;).concat(identifier,&quot;)(?:&quot;).concat(whitespace,&quot;*([*^$|!~]?=)&quot;).concat(whitespace,&quot;*(?:&apos;((?:\\\\\\\\.|[^\\\\\\\\&apos;])*)&apos;|\\&quot;((?:\\\\\\\\.|[^\\\\\\\\\\&quot;])*)\\&quot;|(&quot;).concat(identifier,&quot;))|)&quot;).concat(whitespace,&quot;*\\\\]&quot;),pseudos=&quot;::?(&quot;.concat(identifier,&quot;)(?:\\\\(((&apos;((?:\\\\\\\\.|[^\\\\\\\\&apos;])*)&apos;|\\&quot;((?:\\\\\\\\.|[^\\\\\\\\\\&quot;])*)\\&quot;)|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|&quot;).concat(attributes,&quot;)*)|.*)\\\\)|)&quot;),regComma=new RegExp(&quot;^&quot;.concat(whitespace,&quot;*,&quot;).concat(whitespace,&quot;*&quot;)),regCombinators=new RegExp(&quot;^&quot;.concat(whitespace,&quot;*([&gt;+~]|&quot;).concat(whitespace,&quot;)&quot;).concat(whitespace,&quot;*&quot;)),matchExpr=&#123;id:&#123;reg:new RegExp(&quot;^#(&quot;.concat(identifier,&quot;)&quot;)),value:function(raw)&#123;return raw.slice(1)&#125;,toStr:function(value)&#123;return&quot;#&quot;.concat(value)&#125;&#125;,class:&#123;reg:new RegExp(&quot;^\\\\.(&quot;.concat(identifier,&quot;)&quot;)),value:function(raw)&#123;return raw.slice(1)&#125;,toStr:function(value)&#123;return&quot;.&quot;.concat(value)&#125;&#125;,tag:&#123;reg:new RegExp(&quot;^(&quot;.concat(identifier,&quot;|[*])&quot;)),value:identity&#125;,attribute:&#123;reg:new RegExp(&quot;^&quot;.concat(attributes)),value:function(raw)&#123;return raw.slice(1,raw.length-1)&#125;,toStr:function(value)&#123;return&quot;[&quot;.concat(value,&quot;]&quot;)&#125;&#125;,pseudo:&#123;reg:new RegExp(&quot;^&quot;.concat(pseudos)),value:identity&#125;&#125;;each(matchExpr,function(item)&#123;item.value||(item.value=identity),item.toStr||(item.toStr=identity)&#125;),module.exports=&#123;parse:function(selector)&#123;selector=trim(selector);for(var tokens,match,matched,groups=[];selector&amp;&amp;(matched&amp;&amp;!(match=regComma.exec(selector))||(match&amp;&amp;(selector=selector.slice(match[0].length)),tokens=[],groups.push(tokens)),matched=!1,(match=regCombinators.exec(selector))&amp;&amp;(matched=match.shift(),selector=selector.slice(matched.length),matched=(matched=trim(matched))||&quot; &quot;,tokens.push(&#123;value:matched,type:&quot;combinator&quot;&#125;)),each(matchExpr,function(_ref,type)&#123;var reg=_ref.reg,_ref=_ref.value;(match=reg.exec(selector))&amp;&amp;(matched=match.shift(),selector=selector.slice(matched.length),matched=trim(matched),tokens.push(&#123;value:_ref(matched),type:type&#125;))&#125;),matched););return groups&#125;,stringify:function(groups)&#123;return map(groups,function(group)&#123;return(group=map(group,function(_ref2)&#123;var type=_ref2.type,_ref2=_ref2.value;return&quot;combinator&quot;===type?&quot; &quot;===_ref2?_ref2:&quot; &quot;.concat(_ref2,&quot; &quot;):matchExpr[type].toStr(_ref2)&#125;)).join(&quot;&quot;)&#125;).join(&quot;, &quot;)&#125;&#125;&#125;),cssPriority=createCommonjsModule(function(module,exports)&#123;var PSEUDO_ELEMS=[&quot;first-letter&quot;,&quot;last-letter&quot;,&quot;first-line&quot;,&quot;last-line&quot;,&quot;first-child&quot;,&quot;last-child&quot;,&quot;before&quot;,&quot;after&quot;];(exports=function(sel)&#123;var _ref=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,_ref$important=_ref.important,_ref$inlineStyle=_ref.inlineStyle,_ref$inlineStyle=void 0!==_ref$inlineStyle&amp;&amp;_ref$inlineStyle,_ref=_ref.position,ret=[0,0,0,0,0,void 0===_ref?0:_ref],_ref=(void 0!==_ref$important&amp;&amp;_ref$important&amp;&amp;(ret[0]=1),_ref$inlineStyle&amp;&amp;(ret[1]=1),selector.parse(sel)[0]);return each(_ref,function(_ref2)&#123;var type=_ref2.type,value=_ref2.value;switch(type)&#123;case&quot;id&quot;:ret[2]++;break;case&quot;class&quot;:case&quot;attribute&quot;:ret[3]++;break;case&quot;pseudo&quot;:contain(PSEUDO_ELEMS,value.replace(/:/g,&quot;&quot;))?ret[4]++:startWith(value,&quot;::&quot;)||ret[3]++;break;case&quot;tag&quot;:&quot;*&quot;!==value&amp;&amp;ret[4]++&#125;&#125;),ret&#125;).compare=function(p1,p2)&#123;return cmpVersion(p1.join(&quot;.&quot;),p2.join(&quot;.&quot;))&#125;,module.exports=exports&#125;),cssPriority_1=cssPriority.compare,cssSupports=createCommonjsModule(function(module,exports)&#123;exports=memoize(function(name,value)&#123;return isUndef(value)?(name=camelCase(name),!isUndef(style[name])):(style.cssText=&quot;&quot;,style.cssText=name+&quot;:&quot;+value,!!style.length)&#125;,function(name,value)&#123;return name+&quot; &quot;+value&#125;);var style=document.createElement(&quot;p&quot;).style;module.exports=exports&#125;),curry=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn)&#123;var len=fn.length;return function curriedFn()&#123;var args=toArr(arguments);return args.length&lt;len?function()&#123;return curriedFn.apply(null,args.concat(toArr(arguments)))&#125;:fn.apply(null,args)&#125;&#125;&#125;),isDate=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Date]&quot;===objToStr(val)&#125;&#125;),dateFormat=createCommonjsModule(function(module,exports)&#123;var padZero=function(str)&#123;var len=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:2;return lpad(toStr(str),len,&quot;0&quot;)&#125;,regToken=/d&#123;1,4&#125;|m&#123;1,4&#125;|yy(?:yy)?|([HhMsTt])\\1?|[LloSZWN]|&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;/g,regTimezone=/\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d&#123;4&#125;)?)\\b/g,regNum=/\\d/,regTimezoneClip=/[^-+\\dA-Z]/g;(exports=function(date,mask,utc,gmt)&#123;1===arguments.length&amp;&amp;isStr(date)&amp;&amp;!regNum.test(date)&amp;&amp;(mask=date,date=void 0),date=date||new Date,isDate(date)||(date=new Date(date));var maskSlice=(mask=toStr(exports.masks[mask]||mask||exports.masks.default)).slice(0,4),maskSlice=(&quot;UTC:&quot;!==maskSlice&amp;&amp;&quot;GMT:&quot;!==maskSlice||(mask=mask.slice(4),utc=!0,&quot;GMT:&quot;===maskSlice&amp;&amp;(gmt=!0)),utc?&quot;getUTC&quot;:&quot;get&quot;),d=date[maskSlice+&quot;Date&quot;](),D=date[maskSlice+&quot;Day&quot;](),m=date[maskSlice+&quot;Month&quot;](),y=date[maskSlice+&quot;FullYear&quot;](),H=date[maskSlice+&quot;Hours&quot;](),M=date[maskSlice+&quot;Minutes&quot;](),s=date[maskSlice+&quot;Seconds&quot;](),maskSlice=date[maskSlice+&quot;Milliseconds&quot;](),o=utc?0:date.getTimezoneOffset(),flags=&#123;d:d,dd:padZero(d),ddd:exports.i18n.dayNames[D],dddd:exports.i18n.dayNames[D+7],m:m+1,mm:padZero(m+1),mmm:exports.i18n.monthNames[m],mmmm:exports.i18n.monthNames[m+12],yy:toStr(y).slice(2),yyyy:y,h:H%12||12,hh:padZero(H%12||12),H:H,HH:padZero(H),M:M,MM:padZero(M),s:s,ss:padZero(s),l:padZero(maskSlice,3),L:padZero(Math.round(maskSlice/10)),t:H&lt;12?&quot;a&quot;:&quot;p&quot;,tt:H&lt;12?&quot;am&quot;:&quot;pm&quot;,T:H&lt;12?&quot;A&quot;:&quot;P&quot;,TT:H&lt;12?&quot;AM&quot;:&quot;PM&quot;,Z:gmt?&quot;GMT&quot;:utc?&quot;UTC&quot;:(toStr(date).match(regTimezone)||[&quot;&quot;]).pop().replace(regTimezoneClip,&quot;&quot;),o:(0&lt;o?&quot;-&quot;:&quot;+&quot;)+padZero(100*Math.floor(Math.abs(o)/60)+Math.abs(o)%60,4),S:[&quot;th&quot;,&quot;st&quot;,&quot;nd&quot;,&quot;rd&quot;][3&lt;d%10?0:(d%100-d%10!=10)*d%10]&#125;;return mask.replace(regToken,function(match)&#123;return match in flags?flags[match]:match.slice(1,match.length-1)&#125;)&#125;).masks=&#123;default:&quot;ddd mmm dd yyyy HH:MM:ss&quot;,shortDate:&quot;m/d/yy&quot;,mediumDate:&quot;mmm d, yyyy&quot;,longDate:&quot;mmmm d, yyyy&quot;,fullDate:&quot;dddd, mmmm d, yyyy&quot;,shortTime:&quot;h:MM TT&quot;,mediumTime:&quot;h:MM:ss TT&quot;,longTime:&quot;h:MM:ss TT Z&quot;,isoDate:&quot;yyyy-mm-dd&quot;,isoTime:&quot;HH:MM:ss&quot;,isoDateTime:&quot;yyyy-mm-dd&apos;T&apos;HH:MM:sso&quot;,isoUtcDateTime:&quot;UTC:yyyy-mm-dd&apos;T&apos;HH:MM:ss&apos;Z&apos;&quot;,expiresHeaderFormat:&quot;ddd, dd mmm yyyy HH:MM:ss Z&quot;&#125;,exports.i18n=&#123;dayNames:[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;],monthNames:[&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;,&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;]&#125;,module.exports=exports&#125;),dateFormat_1=dateFormat.masks,dateFormat_2=dateFormat.i18n,debounce=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,wait,immediate)&#123;var timeout;return function()&#123;var ctx=this,args=arguments;immediate||clearTimeout(timeout),immediate&amp;&amp;timeout||(timeout=setTimeout(function()&#123;timeout=null,fn.apply(ctx,args)&#125;,wait))&#125;&#125;&#125;),format=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(str,values)&#123;for(var ret=&quot;&quot;,i=0,len=str.length;i&lt;len;i++)&#123;var c=str[i];if(&quot;%&quot;===c&amp;&amp;0!==values.length)&#123;i++;var val=values.shift();switch(str[i])&#123;case&quot;i&quot;:case&quot;d&quot;:ret+=toInt(val);break;case&quot;f&quot;:ret+=toNum(val);break;case&quot;s&quot;:ret+=toStr(val);break;case&quot;o&quot;:ret+=function(obj)&#123;try&#123;return JSON.stringify(obj)&#125;catch(err)&#123;return&quot;[Error Stringify]&quot;&#125;&#125;(val);break;default:i--,values.unshift(val),ret+=c&#125;&#125;else ret+=c&#125;return ret&#125;),module.exports=exports&#125;),ms=createCommonjsModule(function(module,exports)&#123;exports=function(str)&#123;var match;if(isStr(str))return(match=str.match(regStrTime))?toNum(match[1])*factor[match[2]||&quot;ms&quot;]:0;for(var num=str,suffix=&quot;ms&quot;,i=0,len=suffixList.length;i&lt;len;i++)if(num&gt;=factor[suffixList[i]])&#123;suffix=suffixList[i];break&#125;return+(num/factor[suffix]).toFixed(2)+suffix&#125;;var factor=&#123;ms:1,s:1e3&#125;,suffixList=(factor.m=60*factor.s,factor.h=60*factor.m,factor.d=24*factor.h,factor.y=365.25*factor.d,[&quot;y&quot;,&quot;d&quot;,&quot;h&quot;,&quot;m&quot;,&quot;s&quot;]),regStrTime=/^((?:\\d+)?\\.?\\d+) *(s|m|h|d|y)?$/;module.exports=exports&#125;),debug=createCommonjsModule(function(module,exports)&#123;var browserColors=[&quot;#0000CC&quot;,&quot;#0000FF&quot;,&quot;#0033CC&quot;,&quot;#0033FF&quot;,&quot;#0066CC&quot;,&quot;#0066FF&quot;,&quot;#0099CC&quot;,&quot;#0099FF&quot;,&quot;#00CC00&quot;,&quot;#00CC33&quot;,&quot;#00CC66&quot;,&quot;#00CC99&quot;,&quot;#00CCCC&quot;,&quot;#00CCFF&quot;,&quot;#3300CC&quot;,&quot;#3300FF&quot;,&quot;#3333CC&quot;,&quot;#3333FF&quot;,&quot;#3366CC&quot;,&quot;#3366FF&quot;,&quot;#3399CC&quot;,&quot;#3399FF&quot;,&quot;#33CC00&quot;,&quot;#33CC33&quot;,&quot;#33CC66&quot;,&quot;#33CC99&quot;,&quot;#33CCCC&quot;,&quot;#33CCFF&quot;,&quot;#6600CC&quot;,&quot;#6600FF&quot;,&quot;#6633CC&quot;,&quot;#6633FF&quot;,&quot;#66CC00&quot;,&quot;#66CC33&quot;,&quot;#9900CC&quot;,&quot;#9900FF&quot;,&quot;#9933CC&quot;,&quot;#9933FF&quot;,&quot;#99CC00&quot;,&quot;#99CC33&quot;,&quot;#CC0000&quot;,&quot;#CC0033&quot;,&quot;#CC0066&quot;,&quot;#CC0099&quot;,&quot;#CC00CC&quot;,&quot;#CC00FF&quot;,&quot;#CC3300&quot;,&quot;#CC3333&quot;,&quot;#CC3366&quot;,&quot;#CC3399&quot;,&quot;#CC33CC&quot;,&quot;#CC33FF&quot;,&quot;#CC6600&quot;,&quot;#CC6633&quot;,&quot;#CC9900&quot;,&quot;#CC9933&quot;,&quot;#CCCC00&quot;,&quot;#CCCC33&quot;,&quot;#FF0000&quot;,&quot;#FF0033&quot;,&quot;#FF0066&quot;,&quot;#FF0099&quot;,&quot;#FF00CC&quot;,&quot;#FF00FF&quot;,&quot;#FF3300&quot;,&quot;#FF3333&quot;,&quot;#FF3366&quot;,&quot;#FF3399&quot;,&quot;#FF33CC&quot;,&quot;#FF33FF&quot;,&quot;#FF6600&quot;,&quot;#FF6633&quot;,&quot;#FF9900&quot;,&quot;#FF9933&quot;,&quot;#FFCC00&quot;,&quot;#FFCC33&quot;],terminalColors=[&quot;black&quot;,&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;magenta&quot;,&quot;cyan&quot;,&quot;white&quot;,&quot;gray&quot;,&quot;grey&quot;,&quot;blackBright&quot;,&quot;redBright&quot;,&quot;greenBright&quot;,&quot;yellowBright&quot;,&quot;blueBright&quot;,&quot;magentaBright&quot;,&quot;cyanBright&quot;,&quot;whiteBright&quot;];module.exports=function(name)&#123;var prevTime;function debug()&#123;var duration,cur,args,style;debug.enabled&amp;&amp;(args=toArr(arguments),cur=now(),duration=ms(cur-(prevTime||cur)),prevTime=cur,cur=format.apply(null,args),args=debug.color,isBrowser?(style=&quot;color:&quot;+args,console.log(&quot;%c&quot;+name+&quot; %c&quot;+cur+&quot; %c+&quot;+duration,style,&quot;color:inherit&quot;,style)):console.log(ansiColor[args](name)+&quot;: &quot;+cur+ansiColor[args](&quot; +&quot;+duration)))&#125;return debug.enabled=!0,debug.color=function(name)&#123;name=strHash(name);return isBrowser?browserColors[name%browserColors.length]:terminalColors[name%terminalColors.length]&#125;(name),debug&#125;&#125;),deburr=createCommonjsModule(function(module,exports)&#123;var regComboMark=/[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]/g,regLatin=/[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g,deburredLetters=&#123;&quot;À&quot;:&quot;A&quot;,&quot;Á&quot;:&quot;A&quot;,&quot;Â&quot;:&quot;A&quot;,&quot;Ã&quot;:&quot;A&quot;,&quot;Ä&quot;:&quot;A&quot;,&quot;Å&quot;:&quot;A&quot;,&quot;à&quot;:&quot;a&quot;,&quot;á&quot;:&quot;a&quot;,&quot;â&quot;:&quot;a&quot;,&quot;ã&quot;:&quot;a&quot;,&quot;ä&quot;:&quot;a&quot;,&quot;å&quot;:&quot;a&quot;,&quot;Ç&quot;:&quot;C&quot;,&quot;ç&quot;:&quot;c&quot;,&quot;Ð&quot;:&quot;D&quot;,&quot;ð&quot;:&quot;d&quot;,&quot;È&quot;:&quot;E&quot;,&quot;É&quot;:&quot;E&quot;,&quot;Ê&quot;:&quot;E&quot;,&quot;Ë&quot;:&quot;E&quot;,&quot;è&quot;:&quot;e&quot;,&quot;é&quot;:&quot;e&quot;,&quot;ê&quot;:&quot;e&quot;,&quot;ë&quot;:&quot;e&quot;,&quot;Ì&quot;:&quot;I&quot;,&quot;Í&quot;:&quot;I&quot;,&quot;Î&quot;:&quot;I&quot;,&quot;Ï&quot;:&quot;I&quot;,&quot;ì&quot;:&quot;i&quot;,&quot;í&quot;:&quot;i&quot;,&quot;î&quot;:&quot;i&quot;,&quot;ï&quot;:&quot;i&quot;,&quot;Ñ&quot;:&quot;N&quot;,&quot;ñ&quot;:&quot;n&quot;,&quot;Ò&quot;:&quot;O&quot;,&quot;Ó&quot;:&quot;O&quot;,&quot;Ô&quot;:&quot;O&quot;,&quot;Õ&quot;:&quot;O&quot;,&quot;Ö&quot;:&quot;O&quot;,&quot;Ø&quot;:&quot;O&quot;,&quot;ò&quot;:&quot;o&quot;,&quot;ó&quot;:&quot;o&quot;,&quot;ô&quot;:&quot;o&quot;,&quot;õ&quot;:&quot;o&quot;,&quot;ö&quot;:&quot;o&quot;,&quot;ø&quot;:&quot;o&quot;,&quot;Ù&quot;:&quot;U&quot;,&quot;Ú&quot;:&quot;U&quot;,&quot;Û&quot;:&quot;U&quot;,&quot;Ü&quot;:&quot;U&quot;,&quot;ù&quot;:&quot;u&quot;,&quot;ú&quot;:&quot;u&quot;,&quot;û&quot;:&quot;u&quot;,&quot;ü&quot;:&quot;u&quot;,&quot;Ý&quot;:&quot;Y&quot;,&quot;ý&quot;:&quot;y&quot;,&quot;ÿ&quot;:&quot;y&quot;,&quot;Æ&quot;:&quot;Ae&quot;,&quot;æ&quot;:&quot;ae&quot;,&quot;Þ&quot;:&quot;Th&quot;,&quot;þ&quot;:&quot;th&quot;,&quot;ß&quot;:&quot;ss&quot;,&quot;Ā&quot;:&quot;A&quot;,&quot;Ă&quot;:&quot;A&quot;,&quot;Ą&quot;:&quot;A&quot;,&quot;ā&quot;:&quot;a&quot;,&quot;ă&quot;:&quot;a&quot;,&quot;ą&quot;:&quot;a&quot;,&quot;Ć&quot;:&quot;C&quot;,&quot;Ĉ&quot;:&quot;C&quot;,&quot;Ċ&quot;:&quot;C&quot;,&quot;Č&quot;:&quot;C&quot;,&quot;ć&quot;:&quot;c&quot;,&quot;ĉ&quot;:&quot;c&quot;,&quot;ċ&quot;:&quot;c&quot;,&quot;č&quot;:&quot;c&quot;,&quot;Ď&quot;:&quot;D&quot;,&quot;Đ&quot;:&quot;D&quot;,&quot;ď&quot;:&quot;d&quot;,&quot;đ&quot;:&quot;d&quot;,&quot;Ē&quot;:&quot;E&quot;,&quot;Ĕ&quot;:&quot;E&quot;,&quot;Ė&quot;:&quot;E&quot;,&quot;Ę&quot;:&quot;E&quot;,&quot;Ě&quot;:&quot;E&quot;,&quot;ē&quot;:&quot;e&quot;,&quot;ĕ&quot;:&quot;e&quot;,&quot;ė&quot;:&quot;e&quot;,&quot;ę&quot;:&quot;e&quot;,&quot;ě&quot;:&quot;e&quot;,&quot;Ĝ&quot;:&quot;G&quot;,&quot;Ğ&quot;:&quot;G&quot;,&quot;Ġ&quot;:&quot;G&quot;,&quot;Ģ&quot;:&quot;G&quot;,&quot;ĝ&quot;:&quot;g&quot;,&quot;ğ&quot;:&quot;g&quot;,&quot;ġ&quot;:&quot;g&quot;,&quot;ģ&quot;:&quot;g&quot;,&quot;Ĥ&quot;:&quot;H&quot;,&quot;Ħ&quot;:&quot;H&quot;,&quot;ĥ&quot;:&quot;h&quot;,&quot;ħ&quot;:&quot;h&quot;,&quot;Ĩ&quot;:&quot;I&quot;,&quot;Ī&quot;:&quot;I&quot;,&quot;Ĭ&quot;:&quot;I&quot;,&quot;Į&quot;:&quot;I&quot;,&quot;İ&quot;:&quot;I&quot;,&quot;ĩ&quot;:&quot;i&quot;,&quot;ī&quot;:&quot;i&quot;,&quot;ĭ&quot;:&quot;i&quot;,&quot;į&quot;:&quot;i&quot;,&quot;ı&quot;:&quot;i&quot;,&quot;Ĵ&quot;:&quot;J&quot;,&quot;ĵ&quot;:&quot;j&quot;,&quot;Ķ&quot;:&quot;K&quot;,&quot;ķ&quot;:&quot;k&quot;,&quot;ĸ&quot;:&quot;k&quot;,&quot;Ĺ&quot;:&quot;L&quot;,&quot;Ļ&quot;:&quot;L&quot;,&quot;Ľ&quot;:&quot;L&quot;,&quot;Ŀ&quot;:&quot;L&quot;,&quot;Ł&quot;:&quot;L&quot;,&quot;ĺ&quot;:&quot;l&quot;,&quot;ļ&quot;:&quot;l&quot;,&quot;ľ&quot;:&quot;l&quot;,&quot;ŀ&quot;:&quot;l&quot;,&quot;ł&quot;:&quot;l&quot;,&quot;Ń&quot;:&quot;N&quot;,&quot;Ņ&quot;:&quot;N&quot;,&quot;Ň&quot;:&quot;N&quot;,&quot;Ŋ&quot;:&quot;N&quot;,&quot;ń&quot;:&quot;n&quot;,&quot;ņ&quot;:&quot;n&quot;,&quot;ň&quot;:&quot;n&quot;,&quot;ŋ&quot;:&quot;n&quot;,&quot;Ō&quot;:&quot;O&quot;,&quot;Ŏ&quot;:&quot;O&quot;,&quot;Ő&quot;:&quot;O&quot;,&quot;ō&quot;:&quot;o&quot;,&quot;ŏ&quot;:&quot;o&quot;,&quot;ő&quot;:&quot;o&quot;,&quot;Ŕ&quot;:&quot;R&quot;,&quot;Ŗ&quot;:&quot;R&quot;,&quot;Ř&quot;:&quot;R&quot;,&quot;ŕ&quot;:&quot;r&quot;,&quot;ŗ&quot;:&quot;r&quot;,&quot;ř&quot;:&quot;r&quot;,&quot;Ś&quot;:&quot;S&quot;,&quot;Ŝ&quot;:&quot;S&quot;,&quot;Ş&quot;:&quot;S&quot;,&quot;Š&quot;:&quot;S&quot;,&quot;ś&quot;:&quot;s&quot;,&quot;ŝ&quot;:&quot;s&quot;,&quot;ş&quot;:&quot;s&quot;,&quot;š&quot;:&quot;s&quot;,&quot;Ţ&quot;:&quot;T&quot;,&quot;Ť&quot;:&quot;T&quot;,&quot;Ŧ&quot;:&quot;T&quot;,&quot;ţ&quot;:&quot;t&quot;,&quot;ť&quot;:&quot;t&quot;,&quot;ŧ&quot;:&quot;t&quot;,&quot;Ũ&quot;:&quot;U&quot;,&quot;Ū&quot;:&quot;U&quot;,&quot;Ŭ&quot;:&quot;U&quot;,&quot;Ů&quot;:&quot;U&quot;,&quot;Ű&quot;:&quot;U&quot;,&quot;Ų&quot;:&quot;U&quot;,&quot;ũ&quot;:&quot;u&quot;,&quot;ū&quot;:&quot;u&quot;,&quot;ŭ&quot;:&quot;u&quot;,&quot;ů&quot;:&quot;u&quot;,&quot;ű&quot;:&quot;u&quot;,&quot;ų&quot;:&quot;u&quot;,&quot;Ŵ&quot;:&quot;W&quot;,&quot;ŵ&quot;:&quot;w&quot;,&quot;Ŷ&quot;:&quot;Y&quot;,&quot;ŷ&quot;:&quot;y&quot;,&quot;Ÿ&quot;:&quot;Y&quot;,&quot;Ź&quot;:&quot;Z&quot;,&quot;Ż&quot;:&quot;Z&quot;,&quot;Ž&quot;:&quot;Z&quot;,&quot;ź&quot;:&quot;z&quot;,&quot;ż&quot;:&quot;z&quot;,&quot;ž&quot;:&quot;z&quot;,&quot;Ĳ&quot;:&quot;IJ&quot;,&quot;ĳ&quot;:&quot;ij&quot;,&quot;Œ&quot;:&quot;Oe&quot;,&quot;œ&quot;:&quot;oe&quot;,&quot;ŉ&quot;:&quot;&apos;n&quot;,&quot;ſ&quot;:&quot;s&quot;&#125;;module.exports=function(str)&#123;return str.replace(regLatin,function(key)&#123;return deburredLetters[key]&#125;).replace(regComboMark,&quot;&quot;)&#125;&#125;),define_1=createCommonjsModule(function(module,exports)&#123;var modules=(exports=function(name,requires,method)&#123;2===arguments.length&amp;&amp;(method=requires,requires=[]),function(name,requires,method)&#123;modules[name]=&#123;requires:toArr(requires),body:method&#125;&#125;(name,requires,method)&#125;)._modules=&#123;&#125;;module.exports=exports&#125;),define_2=define_1._modules,defined=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var i=0,len=arguments.length;i&lt;len;i++)if(!isUndef(arguments[i]))return arguments[i]&#125;&#125;),deprecate=createCommonjsModule(function(module,exports)&#123;var localStorage;exports=isNode?eval(&quot;require&quot;)(&quot;util&quot;).deprecate:(localStorage=root.localStorage||memStorage,function(fn,msg)&#123;if(localStorage.getItem(&quot;noDeprecation&quot;))return fn;var warned=!1;function deprecated()&#123;warned||(warned=!0,console.warn(msg));for(var _len=arguments.length,args=new Array(_len),_key=0;_key&lt;_len;_key++)args[_key]=arguments[_key];return fn.apply(this,args)&#125;return Object.setPrototypeOf(deprecated,fn),fn.prototype&amp;&amp;(deprecated.prototype=fn.prototype),deprecated&#125;),module.exports=exports&#125;),detectBrowser=createCommonjsModule(function(module,exports)&#123;exports=function(ua)&#123;var ieVer=getVer(ua=(ua=ua||(isBrowser?navigator.userAgent:&quot;&quot;)).toLowerCase(),&quot;msie &quot;);if(ieVer)return&#123;version:ieVer,name:&quot;ie&quot;&#125;;if(regIe11.test(ua))return&#123;version:11,name:&quot;ie&quot;&#125;;for(var i=0,len=browsers.length;i&lt;len;i++)&#123;var name=browsers[i],match=ua.match(regBrowsers[name]);if(null!=match)return match=toInt(match[1].split(&quot;.&quot;)[0]),&#123;name:name,version:match=&quot;opera&quot;===name?getVer(ua,&quot;version/&quot;)||match:match&#125;&#125;return&#123;name:&quot;unknown&quot;,version:-1&#125;&#125;;var regBrowsers=&#123;edge:/edge\\/([0-9._]+)/,firefox:/firefox\\/([0-9.]+)(?:\\s|$)/,opera:/opera\\/([0-9.]+)(?:\\s|$)/,android:/android\\s([0-9.]+)/,ios:/version\\/([0-9._]+).*mobile.*safari.*/,safari:/version\\/([0-9._]+).*safari/,chrome:/(?!chrom.*opr)chrom(?:e|ium)\\/([0-9.]+)(:?\\s|$)/&#125;,regIe11=/trident\\/7\\./,browsers=keys(regBrowsers);function getVer(ua,mark)&#123;var idx=ua.indexOf(mark);if(-1&lt;idx)return toInt(ua.substring(idx+mark.length,ua.indexOf(&quot;.&quot;,idx)))&#125;module.exports=exports&#125;),detectMocha=createCommonjsModule(function(module,exports)&#123;var methods=[&quot;afterEach&quot;,&quot;after&quot;,&quot;beforeEach&quot;,&quot;before&quot;,&quot;describe&quot;,&quot;it&quot;];module.exports=function()&#123;for(var i=0,len=methods.length;i&lt;len;i++)&#123;var method=methods[i];if(&quot;function&quot;!=typeof root[method])return!1&#125;return!0&#125;&#125;),detectOs=createCommonjsModule(function(module,exports)&#123;module.exports=function(ua)&#123;return ua=(ua=ua||(isBrowser?navigator.userAgent:&quot;&quot;)).toLowerCase(),detect(&quot;windows phone&quot;)?&quot;windows phone&quot;:detect(&quot;win&quot;)?&quot;windows&quot;:detect(&quot;android&quot;)?&quot;android&quot;:detect(&quot;ipad&quot;)||detect(&quot;iphone&quot;)||detect(&quot;ipod&quot;)?&quot;ios&quot;:detect(&quot;mac&quot;)?&quot;os x&quot;:detect(&quot;linux&quot;)?&quot;linux&quot;:&quot;unknown&quot;;function detect(keyword)&#123;return-1&lt;ua.indexOf(keyword)&#125;&#125;&#125;),flatten=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;return function flat(arr,res)&#123;var cur,len=arr.length,i=-1;for(;len--;)cur=arr[++i],isArr(cur)?flat(cur,res):res.push(cur);return res&#125;(arr,[])&#125;&#125;),difference=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(arr,args)&#123;return args=flatten(args),filter(arr,function(val)&#123;return!contain(args,val)&#125;)&#125;),module.exports=exports&#125;),dotCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return splitCase(str).join(&quot;.&quot;)&#125;&#125;),download=createCommonjsModule(function(module,exports)&#123;module.exports=function(data,name,type)&#123;type=type||&quot;text/plain&quot;;var el=document.createElement(&quot;a&quot;);el.setAttribute(&quot;href&quot;,createUrl(data,&#123;type:type&#125;)),el.setAttribute(&quot;download&quot;,name),el.addEventListener(&quot;click&quot;,function(e)&#123;e.stopImmediatePropagation()&#125;),document.body.appendChild(el),el.click(),document.body.removeChild(el)&#125;&#125;),durationFormat=createCommonjsModule(function(module,exports)&#123;var floor=Math.floor,padZero=function(str)&#123;var len=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:2;return lpad(toStr(str),len,&quot;0&quot;)&#125;,regToken=/d&#123;1,2&#125;|h&#123;1,2&#125;|m&#123;1,2&#125;|s&#123;1,2&#125;|l&#123;1,2&#125;|&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;/g;module.exports=function(duration)&#123;var mask=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&quot;hh:mm:ss&quot;,d=(duration=toInt(duration),floor(duration/864e5)),h=floor(duration/36e5)%24,m=floor(duration/6e4)%60,s=floor(duration/1e3)%60,l=floor(duration)%1e3,flags=&#123;d:d,h:h,hh:padZero(h),m:m,mm:padZero(m),s:s,ss:padZero(s),l:l,ll:padZero(l,3)&#125;;return mask.replace(regToken,function(match)&#123;return match in flags?flags[match]:match.slice(1,match.length-1)&#125;)&#125;&#125;),trigger=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;bubbles:!0,cancelable:!0&#125;;module.exports=function(el,type,opts)&#123;isStr(el)&amp;&amp;(opts=type,type=el,el=document),defaults(opts=opts||&#123;&#125;,defOpts);var event=document.createEvent(&quot;Event&quot;);event.initEvent(type,opts.bubbles,opts.cancelable),delete opts.bubbles,delete opts.cancelable,extend(event,opts),el.dispatchEvent(event)&#125;&#125;),emulateTouch=createCommonjsModule(function(module,exports)&#123;var hasTouchSupport=&quot;ontouchstart&quot;in root;function onMouse(type)&#123;return function(e)&#123;1===e.which&amp;&amp;trigger(e.target,type,&#123;altKey:e.altKey,ctrlKey:e.ctrlKey,metaKey:e.metaKey,shiftKey:e.shiftKey,touches:getActiveTouches(e),targetTouches:getActiveTouches(e),changedTouches:createTouchList(e)&#125;)&#125;&#125;function getActiveTouches(e)&#123;return&quot;mouseup&quot;==e.type?createTouchList():createTouchList(e)&#125;function Touch(target,identifier,pos,deltaX,deltaY)&#123;deltaX=deltaX||0,deltaY=deltaY||0,this.identifier=identifier,this.target=target,this.clientX=pos.clientX+deltaX,this.clientY=pos.clientY+deltaY,this.screenX=pos.screenX+deltaX,this.screenY=pos.screenY+deltaY,this.pageX=pos.pageX+deltaX,this.pageY=pos.pageY+deltaY&#125;function createTouchList(e)&#123;var touchList=[];return touchList.item=function(index)&#123;return this[index]||null&#125;,e&amp;&amp;touchList.push(new Touch(e.target,1,e,0,0)),touchList&#125;module.exports=function()&#123;var el=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:document;hasTouchSupport||el._isEmulated||(el._isEmulated=!0,el.addEventListener(&quot;mousedown&quot;,onMouse(&quot;touchstart&quot;),!0),el.addEventListener(&quot;mousemove&quot;,onMouse(&quot;touchmove&quot;),!0),el.addEventListener(&quot;mouseup&quot;,onMouse(&quot;touchend&quot;),!0))&#125;&#125;),endWith=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,suffix)&#123;var idx=str.length-suffix.length;return 0&lt;=idx&amp;&amp;str.indexOf(suffix,idx)===idx&#125;&#125;),escapeRegExp=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return str.replace(/\\W/g,&quot;\\\\$&amp;&quot;)&#125;&#125;),evalCss=createCommonjsModule(function(module,exports)&#123;module.exports=function(css)&#123;var style=document.createElement(&quot;style&quot;);return style.textContent=css,style.type=&quot;text/css&quot;,document.head.appendChild(style),style&#125;&#125;),evalJs=createCommonjsModule(function(module,exports)&#123;module.exports=function(js,ctx)&#123;ctx=ctx||root;try&#123;return new Function(&quot;return (&quot;+js+&quot;);&quot;).call(ctx)&#125;catch(e)&#123;try&#123;return new Function(&quot;return &quot;+js).call(ctx)&#125;catch(e)&#123;return new Function(js).call(ctx)&#125;&#125;&#125;&#125;),every=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,predicate,ctx)&#123;predicate=safeCb(predicate,ctx);for(var _keys=!isArrLike(obj)&amp;&amp;keys(obj),len=(_keys||obj).length,i=0;i&lt;len;i++)&#123;var curKey=_keys?_keys[i]:i;if(!predicate(obj[curKey],curKey,obj))return!1&#125;return!0&#125;&#125;),isPlainObj=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;if(!isObj(val))return!1;var ctor=val.constructor;return!!isFn(ctor)&amp;&amp;(!!has(ctor.prototype,&quot;isPrototypeOf&quot;)&amp;&amp;(!isArr(val)&amp;&amp;!isFn(val)))&#125;&#125;),extendDeep=createCommonjsModule(function(module,exports)&#123;module.exports=exports=function(obj)&#123;for(var i=0,ret=obj,len=arguments.length;++i&lt;len;)obj=arguments[i],isPlainObj(ret)&amp;&amp;isPlainObj(obj)?each(obj,function(val,key)&#123;&quot;__proto__&quot;!==key&amp;&amp;&quot;constructor&quot;!==key&amp;&amp;&quot;prototype&quot;!==key&amp;&amp;(ret[key]=exports(ret[key],obj[key]))&#125;):ret=cloneDeep(obj);return ret&#125;&#125;),extractBlockCmts=createCommonjsModule(function(module,exports)&#123;var regBlockCmt=/(\\/\\*[\\s\\S]*?\\*\\/)/gm;module.exports=function(str)&#123;str=str.match(regBlockCmt);return str?map(str,function(comment)&#123;return trim(map(comment.split(&quot;\\n&quot;),function(line)&#123;return trim(line).replace(/^\\/\\*+|\\*+\\/$|^\\*+/g,&quot;&quot;)&#125;).join(&quot;\\n&quot;))&#125;):[]&#125;&#125;),extractUrls=createCommonjsModule(function(module,exports)&#123;var regUrl=/((https?)|(ftp)):\\/\\/[\\w.]+[^ \\f\\n\\r\\t\\v&quot;\\\\&lt;&gt;[\\]\\u2100-\\uFFFF(),]*/gi;module.exports=function(str)&#123;str=toArr(str.match(regUrl));return unique(map(str,function(url)&#123;return trim(url)&#125;))&#125;&#125;),fetch=createCommonjsModule(function(module,exports)&#123;var Promise=root.Promise,regHeaders=/^(.*?):\\s*([\\s\\S]*?)$/gm;(exports=function(url,options)&#123;return defaults(options=options||&#123;&#125;,exports.setting),new Promise(function(resolve,reject)&#123;var xhr=options.xhr(),headers=options.headers,body=options.body,timeout=options.timeout;xhr.withCredentials=&quot;include&quot;==options.credentials,xhr.onload=function()&#123;clearTimeout(void 0),resolve(function getRes(xhr)&#123;var keys=[];var all=[];var headers=&#123;&#125;;var header;xhr.getAllResponseHeaders().replace(regHeaders,function(m,key,val)&#123;key=key.toLowerCase(),keys.push(key),all.push([key,val]),header=headers[key],headers[key]=header?header+&quot;,&quot;+val:val&#125;);return&#123;ok:200&lt;=xhr.status&amp;&amp;xhr.status&lt;400,status:xhr.status,statusText:xhr.statusText,url:xhr.responseURL,clone:function()&#123;return getRes(xhr)&#125;,text:function()&#123;return Promise.resolve(xhr.responseText)&#125;,json:function()&#123;return Promise.resolve(xhr.responseText).then(JSON.parse)&#125;,xml:function()&#123;return Promise.resolve(xhr.responseXML)&#125;,blob:function()&#123;return Promise.resolve(new Blob([xhr.response]))&#125;,headers:&#123;keys:function()&#123;return keys&#125;,entries:function()&#123;return all&#125;,get:function(name)&#123;return headers[name.toLowerCase()]&#125;,has:function(name)&#123;return has(headers,name)&#125;&#125;&#125;&#125;(xhr))&#125;,xhr.onerror=reject,xhr.open(options.method,url,!0),each(headers,function(val,key)&#123;xhr.setRequestHeader(key,val)&#125;),0&lt;timeout&amp;&amp;setTimeout(function()&#123;xhr.onload=noop,xhr.abort(),reject(Error(&quot;timeout&quot;))&#125;,timeout),xhr.send(body)&#125;)&#125;).setting=&#123;method:&quot;GET&quot;,headers:&#123;&#125;,timeout:0,xhr:function()&#123;return new XMLHttpRequest&#125;&#125;,module.exports=exports&#125;),fetch_1=fetch.setting,fibonacci=createCommonjsModule(function(module,exports)&#123;exports=memoize(function(n)&#123;return n&lt;2?n:exports(n-1)+exports(n-2)&#125;),module.exports=exports&#125;),fileSize=createCommonjsModule(function(module,exports)&#123;var suffixList=[&quot;&quot;,&quot;K&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;];module.exports=function(bytes)&#123;if(bytes&lt;=0)return&quot;0&quot;;var suffixIdx=Math.floor(Math.log(bytes)/Math.log(1024));return+(bytes/Math.pow(2,10*suffixIdx)).toFixed(2)+suffixList[suffixIdx]&#125;&#125;),mime=createCommonjsModule(function(module,exports)&#123;var exts=&#123;&quot;image/jpeg&quot;:[&quot;jpeg&quot;,&quot;jpg&quot;],&quot;image/png&quot;:[&quot;png&quot;],&quot;image/gif&quot;:[&quot;gif&quot;],&quot;image/webp&quot;:[&quot;webp&quot;],&quot;image/tiff&quot;:[&quot;tif&quot;,&quot;tiff&quot;],&quot;image/bmp&quot;:[&quot;bmp&quot;],&quot;image/vnd.adobe.photoshop&quot;:[&quot;psd&quot;],&quot;image/svg+xml&quot;:[&quot;svg&quot;],&quot;audio/mp4&quot;:[&quot;m4a&quot;,&quot;mp4a&quot;],&quot;audio/midi&quot;:[&quot;midi&quot;],&quot;audio/mpeg&quot;:[&quot;mpga&quot;,&quot;mp2&quot;,&quot;mp2a&quot;,&quot;mp3&quot;,&quot;m2a&quot;,&quot;m3a&quot;],&quot;audio/ogg&quot;:[&quot;ogg&quot;],&quot;audio/wav&quot;:[&quot;wav&quot;],&quot;video/mp4&quot;:[&quot;mp4&quot;,&quot;mp4v&quot;,&quot;mpg4&quot;],&quot;video/x-matroska&quot;:[&quot;mkv&quot;],&quot;video/webm&quot;:[&quot;webm&quot;],&quot;video/x-msvideo&quot;:[&quot;avi&quot;],&quot;video/quicktime&quot;:[&quot;qt&quot;,&quot;mov&quot;],&quot;video/mpeg&quot;:[&quot;mpeg&quot;,&quot;mpg&quot;,&quot;mpe&quot;,&quot;m1v&quot;,&quot;m2v&quot;],&quot;video/3gpp&quot;:[&quot;3gp&quot;,&quot;3gpp&quot;],&quot;text/css&quot;:[&quot;css&quot;],&quot;text/html&quot;:[&quot;html&quot;,&quot;htm&quot;,&quot;shtml&quot;],&quot;text/yaml&quot;:[&quot;yaml&quot;,&quot;yml&quot;],&quot;text/csv&quot;:[&quot;csv&quot;],&quot;text/markdown&quot;:[&quot;markdown&quot;,&quot;md&quot;],&quot;text/plain&quot;:[&quot;txt&quot;,&quot;text&quot;,&quot;conf&quot;,&quot;log&quot;,&quot;ini&quot;],&quot;font/ttf&quot;:[&quot;ttf&quot;],&quot;font/woff&quot;:[&quot;woff&quot;],&quot;font/woff2&quot;:[&quot;woff2&quot;],&quot;application/zip&quot;:[&quot;zip&quot;],&quot;application/x-tar&quot;:[&quot;tar&quot;],&quot;application/x-rar-compressed&quot;:[&quot;rar&quot;],&quot;application/gzip&quot;:[&quot;gz&quot;],&quot;application/x-7z-compressed&quot;:[&quot;7z&quot;],&quot;application/octet-stream&quot;:[&quot;bin&quot;,&quot;so&quot;,&quot;exe&quot;,&quot;dll&quot;,&quot;dmg&quot;,&quot;iso&quot;,&quot;msi&quot;],&quot;application/epub+zip&quot;:[&quot;epub&quot;],&quot;application/javascript&quot;:[&quot;js&quot;],&quot;application/json&quot;:[&quot;json&quot;],&quot;application/msword&quot;:[&quot;doc&quot;,&quot;docx&quot;,&quot;dot&quot;,&quot;dotx&quot;],&quot;application/vnd.ms-excel&quot;:[&quot;xls&quot;,&quot;xlsx&quot;,&quot;xla&quot;,&quot;xlt&quot;],&quot;application/vnd.ms-powerpoint&quot;:[&quot;ppt&quot;,&quot;pptx&quot;,&quot;pps&quot;,&quot;pot&quot;],&quot;application/pdf&quot;:[&quot;pdf&quot;],&quot;application/wasm&quot;:[&quot;wasm&quot;],&quot;application/xml&quot;:[&quot;xml&quot;],&quot;application/xml-dtd&quot;:[&quot;dtd&quot;]&#125;,mimeTypes=&#123;&#125;;each(exts,function(ext,mimeType)&#123;each(ext,function(e)&#123;mimeTypes[e]=mimeType&#125;)&#125;),module.exports=function(name)&#123;return(-1&lt;name.indexOf(&quot;/&quot;)?function(name)&#123;if(exts[name])return exts[name][0]&#125;:function(name)&#123;return mimeTypes[name]&#125;)(name)||void 0&#125;&#125;),fileType=createCommonjsModule(function(module,exports)&#123;function _slicedToArray(arr,i)&#123;return function(arr)&#123;if(Array.isArray(arr))return arr&#125;(arr)||function(arr,i)&#123;if(&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.iterator in Object(arr))&#123;var _arr=[],_n=!0,_d=!1,_e=void 0;try&#123;for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&amp;&amp;(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);&#125;catch(err)&#123;_d=!0,_e=err&#125;finally&#123;try&#123;_n||null==_i.return||_i.return()&#125;finally&#123;if(_d)throw _e&#125;&#125;return _arr&#125;&#125;(arr,i)||function(o,minLen)&#123;if(o)&#123;if(&quot;string&quot;==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return&quot;Map&quot;===(n=&quot;Object&quot;===n&amp;&amp;o.constructor?o.constructor.name:n)||&quot;Set&quot;===n?Array.from(o):&quot;Arguments&quot;===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0&#125;&#125;(arr,i)||function()&#123;throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;)&#125;()&#125;function _arrayLikeToArray(arr,len)&#123;(null==len||len&gt;arr.length)&amp;&amp;(len=arr.length);for(var i=0,arr2=new Array(len);i&lt;len;i++)arr2[i]=arr[i];return arr2&#125;var types=[[&quot;jpg&quot;,[255,216,255]],[&quot;png&quot;,[137,80,78,71,13,10,26,10]],[&quot;gif&quot;,[71,73,70]],[&quot;webp&quot;,[87,69,66,80],8],[&quot;bmp&quot;,[66,77]],[&quot;gz&quot;,[31,139,8]],[&quot;zip&quot;,function(input)&#123;return check(input,[80,75])&amp;&amp;(3===input[2]||5===input[2]||7===input[2])&amp;&amp;(4===input[3]||6===input[3]||8===input[3])&#125;],[&quot;rar&quot;,function(input)&#123;return check(input,[82,97,114,33,26,7])&amp;&amp;(0===input[6]||1===input[6])&#125;],[&quot;pdf&quot;,[37,80,68,70]],[&quot;exe&quot;,[77,90]]];function check(input,magic,argument_2)&#123;for(var offset=2&lt;arguments.length&amp;&amp;void 0!==argument_2?argument_2:0,i=0,len=magic.length;i&lt;len;i++)if(input[offset+i]!==magic[i])return!1;return!0&#125;module.exports=function(input)&#123;&quot;uint8array&quot;!==type(input)&amp;&amp;(input=new Uint8Array(input));for(var i=0,len=types.length;i&lt;len;i++)&#123;var _type2=_slicedToArray(types[i],3),ext=_type2[0],magic=_type2[1],_type2=_type2[2];if(isFn(magic))&#123;if(magic(input))return&#123;ext:ext,mime:mime(ext)&#125;&#125;else if(check(input,magic,_type2))return&#123;ext:ext,mime:mime(ext)&#125;&#125;&#125;&#125;),findKey=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,predicate,ctx)&#123;predicate=safeCb(predicate,ctx);for(var key,_keys=keys(obj),i=0,len=_keys.length;i&lt;len;i++)if(predicate(obj[key=_keys[i]],key,obj))return key&#125;&#125;),findIdx=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,predicate,ctx,dir)&#123;dir=dir||1,predicate=safeCb(predicate,ctx);for(var len=arr.length,i=0&lt;dir?0:len-1;0&lt;=i&amp;&amp;i&lt;len;)&#123;if(predicate(arr[i],i,arr))return i;i+=dir&#125;return-1&#125;&#125;),find=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,predicate,ctx)&#123;predicate=(isArrLike(obj)?findIdx:findKey)(obj,predicate,ctx);if(!isUndef(predicate)&amp;&amp;-1!==predicate)return obj[predicate]&#125;&#125;),findLastIdx=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr,predicate,ctx)&#123;return findIdx(arr,predicate,ctx,-1)&#125;&#125;),fnArgs=createCommonjsModule(function(module,exports)&#123;function validateArg(value,types,num)&#123;for(var isValid=!1,i=0,len=types.length;i&lt;len;i++)&#123;var t=lowerCase(types[i]);if(&quot;any&quot;===t||&quot;object&quot;===t&amp;&amp;isObj(value)||type(value)===t)&#123;isValid=!0;break&#125;&#125;if(!isValid)throw TypeError(&quot;Argument &quot;.concat(num,&quot; should be type &quot;).concat(types.join(&quot;|&quot;)))&#125;module.exports=function(types,args)&#123;for(var argsLen=args.length,typesLen=types.length,minLen=typesLen,maxLen=typesLen,i=0;i&lt;typesLen;i++)&#123;var _type=types[i].split(&quot;|&quot;);startWith(_type[0],&quot;?&quot;)&amp;&amp;(_type[0]=_type[0].slice(1),minLen===typesLen&amp;&amp;(minLen=i)),i===typesLen-1&amp;&amp;startWith(_type[0],&quot;...&quot;)&amp;&amp;(maxLen=1/0,_type[0]=_type[0].slice(3),minLen===typesLen&amp;&amp;(minLen=i)),types[i]=_type&#125;if(argsLen&lt;minLen)throw Error(&quot;Expected at least &quot;.concat(minLen,&quot; args but got &quot;).concat(argsLen));if(maxLen&lt;argsLen)throw Error(&quot;Expected at most &quot;.concat(maxLen,&quot; args but got &quot;).concat(argsLen));for(var _i=0;_i&lt;argsLen;_i++)&#123;var arg=args[_i];validateArg(arg,typesLen&lt;=_i?last(types):types[_i],_i)&#125;&#125;&#125;),isNil=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return null==val&#125;&#125;),toSrc=createCommonjsModule(function(module,exports)&#123;var fnToStr=Function.prototype.toString;module.exports=function(fn)&#123;if(isNil(fn))return&quot;&quot;;try&#123;return fnToStr.call(fn)&#125;catch(e)&#123;&#125;try&#123;return fn+&quot;&quot;&#125;catch(e)&#123;&#125;return&quot;&quot;&#125;&#125;),stripCmt=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;for(var mode=&#123;singleQuote:!1,doubleQuote:!1,regex:!1,blockComment:!1,lineComment:!1,condComp:!1&#125;,i=0,l=(str=(&quot;__&quot;+str+&quot;__&quot;).split(&quot;&quot;)).length;i&lt;l;i++)mode.regex?&quot;/&quot;===str[i]&amp;&amp;&quot;\\\\&quot;!==str[i-1]&amp;&amp;(mode.regex=!1):mode.singleQuote?&quot;&apos;&quot;===str[i]&amp;&amp;&quot;\\\\&quot;!==str[i-1]&amp;&amp;(mode.singleQuote=!1):mode.doubleQuote?&apos;&quot;&apos;===str[i]&amp;&amp;&quot;\\\\&quot;!==str[i-1]&amp;&amp;(mode.doubleQuote=!1):mode.blockComment?(&quot;*&quot;===str[i]&amp;&amp;&quot;/&quot;===str[i+1]&amp;&amp;(str[i+1]=&quot;&quot;,mode.blockComment=!1),str[i]=&quot;&quot;):mode.lineComment?(&quot;\\n&quot;===str[i+1]&amp;&amp;(mode.lineComment=!1),str[i]=&quot;&quot;):(mode.doubleQuote=&apos;&quot;&apos;===str[i],mode.singleQuote=&quot;&apos;&quot;===str[i],&quot;/&quot;===str[i]&amp;&amp;(&quot;*&quot;!==str[i+1]?&quot;/&quot;!==str[i+1]?mode.regex=!0:(str[i]=&quot;&quot;,mode.lineComment=!0):(str[i]=&quot;&quot;,mode.blockComment=!0)));return str.join(&quot;&quot;).slice(2,-2)&#125;&#125;),fnParams=createCommonjsModule(function(module,exports)&#123;var regArgNames=/[^\\s,]+/g;module.exports=function(fn)&#123;var open,fn=stripCmt(isStr(fn)?fn:toSrc(fn)),close=startWith(fn,&quot;async&quot;)||startWith(fn,&quot;function&quot;)||startWith(fn,&quot;(&quot;)?(open=fn.indexOf(&quot;(&quot;)+1,fn.indexOf(&quot;)&quot;)):(open=0,fn.indexOf(&quot;=&gt;&quot;)),fn=fn.slice(open,close);return null===(fn=fn.match(regArgNames))?[]:fn&#125;&#125;),precision=createCommonjsModule(function(module,exports)&#123;var regExponential=/^(-?\\d?\\.?\\d+)e([+-]\\d)+/;module.exports=function(num)&#123;var coefficient=(num=num.toExponential().match(regExponential))[1],num=parseInt(num[2],10),coefficient=(coefficient.split(&quot;.&quot;)[1]||&quot;&quot;).length-num;return coefficient&lt;0?0:coefficient&#125;&#125;),fraction=createCommonjsModule(function(module,exports)&#123;var abs=Math.abs,pow=Math.pow;module.exports=function(num)&#123;if(0===num)return&quot;0&quot;;var _precision=precision(num),num=num*(_precision=pow(10,_precision)),_gcd=abs(gcd(num,_precision));return(num/=_gcd)+&quot;/&quot;+(_precision/=_gcd)&#125;&#125;),freezeDeep=createCommonjsModule(function(module,exports)&#123;module.exports=exports=function(obj)&#123;return freeze(obj),keys(obj).forEach(function(prop)&#123;prop=obj[prop];isObj(prop)&amp;&amp;!Object.isFrozen(prop)&amp;&amp;exports(prop)&#125;),obj&#125;&#125;),fullscreen=createCommonjsModule(function(module,exports)&#123;for(var fn,fnMap=[[&quot;requestFullscreen&quot;,&quot;exitFullscreen&quot;,&quot;fullscreenElement&quot;,&quot;fullscreenEnabled&quot;,&quot;fullscreenchange&quot;,&quot;fullscreenerror&quot;],[&quot;webkitRequestFullscreen&quot;,&quot;webkitExitFullscreen&quot;,&quot;webkitFullscreenElement&quot;,&quot;webkitFullscreenEnabled&quot;,&quot;webkitfullscreenchange&quot;,&quot;webkitfullscreenerror&quot;],[&quot;mozRequestFullScreen&quot;,&quot;mozCancelFullScreen&quot;,&quot;mozFullScreenElement&quot;,&quot;mozFullScreenEnabled&quot;,&quot;mozfullscreenchange&quot;,&quot;mozfullscreenerror&quot;],[&quot;msRequestFullscreen&quot;,&quot;msExitFullscreen&quot;,&quot;msFullscreenElement&quot;,&quot;msFullscreenEnabled&quot;,&quot;MSFullscreenChange&quot;,&quot;MSFullscreenError&quot;]],i=0,len=fnMap.length;i&lt;len&amp;&amp;!((fn=fnMap[i])[1]in document);i++);exports=&#123;request:function()&#123;(0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:document.documentElement)[fn[0]]()&#125;,exit:function()&#123;document[fn[1]]()&#125;,toggle:function()&#123;var el=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:document.documentElement;this.isActive()?this.exit():this.request(el)&#125;,isActive:function()&#123;return toBool(this.getEl())&#125;,isEnabled:function()&#123;return toBool(document[fn[3]])&#125;,getEl:function()&#123;return document[fn[2]]&#125;&#125;,Emitter.mixin(exports),document.addEventListener(fn[4],function()&#123;exports.emit(&quot;change&quot;)&#125;),document.addEventListener(fn[5],function()&#123;exports.emit(&quot;error&quot;)&#125;),module.exports=exports&#125;),levenshtein=createCommonjsModule(function(module,exports)&#123;var vector=[],bChars=[];module.exports=function(a,b)&#123;if(a===b)return 0;a.length&gt;b.length&amp;&amp;(tmp=a,a=b,b=tmp);var tmp,aLen=a.length,bLen=b.length;if(!aLen)return bLen;if(!bLen)return aLen;for(;0&lt;aLen&amp;&amp;a.charCodeAt(aLen-1)===b.charCodeAt(bLen-1);)aLen--,bLen--;if(!aLen)return bLen;for(var start=0;start&lt;aLen&amp;&amp;a.charCodeAt(start)===b.charCodeAt(start);)start++;if(bLen-=start,!(aLen-=start))return bLen;for(var above,current=0,i=0;i&lt;bLen;)bChars[i]=b.charCodeAt(start+i),vector[i]=++i;for(var _i=0;_i&lt;aLen;_i++)for(var left=_i,current=_i+1,charA=a.charCodeAt(start+_i),j=0;j&lt;bLen;j++)above=current,current=left,left=vector[j],charA!==bChars[j]&amp;&amp;(above&lt;(current=left&lt;current?left:current)&amp;&amp;(current=above),current++),vector[j]=current;return current&#125;&#125;),pluck=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,key)&#123;return map(obj,property(key))&#125;&#125;),fuzzySearch=createCommonjsModule(function(module,exports)&#123;module.exports=function(needle,haystacks)&#123;var options=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:&#123;&#125;;return options.caseSensitive||(needle=needle.toLowerCase()),haystacks=map(haystacks,function(haystack)&#123;var string=function(haystack,options)&#123;return isStr(haystack)?haystack:safeGet(haystack,options.key)||&quot;&quot;&#125;(haystack,options);return options.caseSensitive||(string=string.toLowerCase()),&#123;value:haystack,levenshtein:levenshtein(needle,string),string:string&#125;&#125;),(haystacks=filter(haystacks,function(haystack)&#123;return function(needle,haystack)&#123;var hLen=haystack.length,nLen=needle.length;if(hLen&lt;nLen)return!1;if(nLen===hLen)return needle===haystack;for(var i=0,j=0;i&lt;nLen;i++)&#123;for(var c=needle.charCodeAt(i),has=!1;j&lt;hLen;)if(haystack.charCodeAt(j++)===c)&#123;has=!0;break&#125;if(!has)return!1&#125;return!0&#125;(needle,haystack.string)&#125;)).sort(function(a,b)&#123;return a.levenshtein-b.levenshtein&#125;),pluck(haystacks,&quot;value&quot;)&#125;&#125;),getUrlParam=createCommonjsModule(function(module,exports)&#123;module.exports=function(name,url)&#123;return new Url(url).query[name]&#125;&#125;),golangify=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn)&#123;return isFn(fn)?restArgs(function(args)&#123;return fn.apply(this,args).then(function(v)&#123;return[v,null]&#125;).catch(function(err)&#123;return[void 0,err]&#125;)&#125;):fn.then(function(v)&#123;return[v,null]&#125;).catch(function(err)&#123;return[void 0,err]&#125;)&#125;&#125;),heapSort=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator,heap=new Heap(cmp),len=arr.length,i=0;i&lt;len;i++)heap.add(arr[i]);for(var _i=0;_i&lt;len;_i++)arr[_i]=heap.poll();return arr&#125;&#125;),highlight=createCommonjsModule(function(module,exports)&#123;exports=function(str)&#123;var lang=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&quot;js&quot;,style=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:&#123;&#125;,subLangSi=(defaults(style,defStyle),str=str.replace(/&lt;/g,&quot;&amp;lt;&quot;).replace(/&gt;/g,&quot;&amp;gt;&quot;),lang=language[lang],0),subLangs=[],levels=(each(lang,function(val)&#123;val.language&amp;&amp;(str=str.replace(val.re,function($1,$2)&#123;return $2?(subLangs[subLangSi++]=exports($2,val.language,style),$1.replace($2,&quot;___subtmpl&quot;+(subLangSi-1)+&quot;___&quot;)):$1&#125;))&#125;),each(lang,function(val,key)&#123;language[val.language]||(str=str.replace(val.re,&quot;___&quot;+key+&quot;___$1___end&quot;+key+&quot;___&quot;))&#125;),[]);return str=str.replace(/___(?!subtmpl)\\w+?___/g,function($0)&#123;var end=&quot;end&quot;===$0.substr(3,3),tag=(end?$0.substr(6):$0.substr(3)).replace(/_/g,&quot;&quot;),lastTag=0&lt;levels.length?levels[levels.length-1]:null;return!end&amp;&amp;(null==lastTag||tag==lastTag||null!=lastTag&amp;&amp;lang[lastTag]&amp;&amp;null!=lang[lastTag].embed&amp;&amp;-1&lt;lang[lastTag].embed.indexOf(tag))?(levels.push(tag),$0):end&amp;&amp;tag==lastTag?(levels.pop(),$0):&quot;&quot;&#125;),each(lang,function(val,key)&#123;var s=style[val.style]?&apos; style=&quot;&apos;.concat(style[val.style],&apos;&quot;&apos;):&quot;&quot;;str=str.replace(new RegExp(&quot;___end&quot;+key+&quot;___&quot;,&quot;g&quot;),&quot;&lt;/span&gt;&quot;).replace(new RegExp(&quot;___&quot;+key+&quot;___&quot;,&quot;g&quot;),&apos;&lt;span class=&quot;&apos;.concat(val.style,&apos;&quot;&apos;).concat(s,&quot;&gt;&quot;))&#125;),each(lang,function(val)&#123;val.language&amp;&amp;(str=str.replace(/___subtmpl\\d+___/g,function($tmpl)&#123;$tmpl=parseInt($tmpl.replace(/___subtmpl(\\d+)___/,&quot;$1&quot;),10);return subLangs[$tmpl]&#125;))&#125;),str&#125;;var defStyle=&#123;comment:&quot;color:#63a35c;&quot;,string:&quot;color:#183691;&quot;,number:&quot;color:#0086b3;&quot;,keyword:&quot;color:#a71d5d;&quot;,operator:&quot;color:#994500;&quot;&#125;,language=&#123;js:&#123;comment:&#123;re:/(\\/\\/.*|\\/\\*([\\s\\S]*?)\\*\\/)/g,style:&quot;comment&quot;&#125;,string:&#123;re:/((&apos;.*?&apos;)|(&quot;.*?&quot;))/g,style:&quot;string&quot;&#125;,numbers:&#123;re:/(-?(\\d+|\\d+\\.\\d+|\\.\\d+))/g,style:&quot;number&quot;&#125;,keywords:&#123;re:/(?:\\b)(function|for|foreach|while|if|else|elseif|switch|break|as|return|this|class|self|default|var|const|let|false|true|null|undefined)(?:\\b)/gi,style:&quot;keyword&quot;&#125;,operator:&#123;re:/(\\+|-|\\/|\\*|%|=|&amp;lt;|&amp;gt;|\\||\\?|\\.)/g,style:&quot;operator&quot;&#125;&#125;&#125;;language.html=&#123;comment:&#123;re:/(&amp;lt;!--([\\s\\S]*?)--&amp;gt;)/g,style:&quot;comment&quot;&#125;,tag:&#123;re:/(&amp;lt;\\/?\\w(.|\\n)*?\\/?&amp;gt;)/g,style:&quot;keyword&quot;,embed:[&quot;string&quot;]&#125;,string:language.js.string,css:&#123;re:/(?:&amp;lt;style.*?&amp;gt;)([\\s\\S]*)?(?:&amp;lt;\\/style&amp;gt;)/gi,language:&quot;css&quot;&#125;,script:&#123;re:/(?:&amp;lt;script.*?&amp;gt;)([\\s\\S]*?)(?:&amp;lt;\\/script&amp;gt;)/gi,language:&quot;js&quot;&#125;&#125;,language.css=&#123;comment:language.js.comment,string:language.js.string,numbers:&#123;re:/((-?(\\d+|\\d+\\.\\d+|\\.\\d+)(%|px|em|pt|in)?)|#[0-9a-fA-F]&#123;3&#125;[0-9a-fA-F]&#123;3&#125;)/g,style:&quot;number&quot;&#125;,keywords:&#123;re:/(@\\w+|:?:\\w+|[a-z-]+:)/g,style:&quot;keyword&quot;&#125;&#125;,module.exports=exports&#125;),isErr=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Error]&quot;===objToStr(val)&#125;&#125;),hookFn=createCommonjsModule(function(module,exports)&#123;var defOptions=&#123;before:noop,after:noop,error:noop&#125;;module.exports=function(fn,options)&#123;return defaults(options,defOptions),function()&#123;var args=toArr(arguments),newArgs=options.before.apply(this,args);isArr(newArgs)&amp;&amp;(args=newArgs);try&#123;var result=fn.apply(this,args),newResult=options.after.call(this,result);return result=newResult?newResult:result&#125;catch(e)&#123;newArgs=options.error(e);if(newArgs)&#123;if(isErr(newArgs))throw newArgs;return newArgs&#125;throw e&#125;&#125;&#125;&#125;),invert=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;var ret=&#123;&#125;;return each(obj,function(val,key)&#123;ret[val]=key&#125;),ret&#125;&#125;),keyCode=createCommonjsModule(function(module,exports)&#123;exports=function(val)&#123;return(isStr(val)?codeMap:nameMap)[val]&#125;;for(var codeMap=&#123;backspace:8,tab:9,enter:13,shift:16,ctrl:17,alt:18,&quot;pause/break&quot;:19,&quot;caps lock&quot;:20,esc:27,space:32,&quot;page up&quot;:33,&quot;page down&quot;:34,end:35,home:36,left:37,up:38,right:39,down:40,insert:45,delete:46,windows:91,&quot;right windows&quot;:92,&quot;windows menu&quot;:93,&quot;numpad *&quot;:106,&quot;numpad +&quot;:107,&quot;numpad -&quot;:109,&quot;numpad .&quot;:110,&quot;numpad /&quot;:111,&quot;num lock&quot;:144,&quot;scroll lock&quot;:145,&quot;;&quot;:186,&quot;=&quot;:187,&quot;,&quot;:188,&quot;-&quot;:189,&quot;.&quot;:190,&quot;/&quot;:191,&quot;`&quot;:192,&quot;[&quot;:219,&quot;\\\\&quot;:220,&quot;]&quot;:221,&quot;&apos;&quot;:222&#125;,i=97;i&lt;123;i++)codeMap[String.fromCharCode(i)]=i-32;for(var _i=48;_i&lt;58;_i++)codeMap[_i-48]=_i;for(var _i2=1;_i2&lt;13;_i2++)codeMap[&quot;f&quot;+_i2]=_i2+111;for(var _i3=0;_i3&lt;10;_i3++)codeMap[&quot;numpad &quot;+_i3]=_i3+96;var nameMap=invert(codeMap);module.exports=exports&#125;),hotkey=createCommonjsModule(function(module,exports)&#123;exports=&#123;on:function(keys,listener)&#123;keys=keys.split(regComma),each(keys,function(key)&#123;emitter.on(normalizeKey(key),listener)&#125;)&#125;,off:function(keys,listener)&#123;keys=keys.split(regComma),each(keys,function(key)&#123;emitter.off(normalizeKey(key),listener)&#125;)&#125;&#125;;var emitter=new Emitter;function normalizeKey(keyStr)&#123;keyStr=keyStr.split(regPlus),keyStr=map(keyStr,function(key)&#123;return trim(key)&#125;);return(keyStr=unique(keyStr)).sort(),keyStr.join(&quot;+&quot;)&#125;document.addEventListener(&quot;keydown&quot;,function(e)&#123;var keys=[];e.ctrlKey&amp;&amp;keys.push(&quot;ctrl&quot;),e.shiftKey&amp;&amp;keys.push(&quot;shift&quot;),keys.push(keyCode(e.keyCode)),emitter.emit(normalizeKey(keys.join(&quot;+&quot;)),e)&#125;);var regComma=/,/g,regPlus=/\\+/g;module.exports=exports&#125;),parseHtml=createCommonjsModule(function(module,exports)&#123;exports=function(html,handler)&#123;for(var stack=[],lastHtml=html;html;)&#123;var execRes,_text2,_match,_text,text=!0;if(last(stack)&amp;&amp;SPECIAL[last(stack)]?((execRes=new RegExp(&quot;&lt;/&quot;.concat(last(stack),&quot;[^&gt;]*&gt;&quot;)).exec(html))&amp;&amp;(_text2=html.substring(0,execRes.index),html=html.substring(execRes.index+execRes[0].length),_text2&amp;&amp;handler.text&amp;&amp;handler.text(_text2)),parseEndTag(0,last(stack))):(startWith(html,&quot;\\x3c!--&quot;)?0&lt;=(execRes=html.indexOf(&quot;--\\x3e&quot;))&amp;&amp;(handler.comment&amp;&amp;handler.comment(html.substring(4,execRes)),html=html.substring(execRes+3),text=!1):startWith(html,&quot;&lt;!&quot;)?(_text2=html.match(regDoctype))&amp;&amp;(handler.text&amp;&amp;handler.text(html.substring(0,_text2[0].length)),html=html.substring(_text2[0].length),text=!1):startWith(html,&quot;&lt;/&quot;)?(_match=html.match(regEndTag))&amp;&amp;(html=html.substring(_match[0].length),_match[0].replace(regEndTag,parseEndTag),text=!1):!startWith(html,&quot;&lt;&quot;)||(_match=html.match(regStartTag))&amp;&amp;(html=html.substring(_match[0].length),_match[0].replace(regStartTag,parseStartTag),text=!1),text&amp;&amp;(_text=(text=html.indexOf(&quot;&lt;&quot;))&lt;0?html:html.substring(0,text),html=text&lt;0?&quot;&quot;:html.substring(text),handler.text&amp;&amp;handler.text(_text))),lastHtml===html)throw Error(&quot;Parse Error: &quot;+html);lastHtml=html&#125;function parseStartTag(tag,tagName,rest,unary)&#123;var attrs;tagName=lowerCase(tagName),(unary=!!unary)||stack.push(tagName),handler.start&amp;&amp;(attrs=&#123;&#125;,rest.replace(regAttr,function(all,$1,$2,$3,$4)&#123;attrs[$1]=$2||$3||$4||&quot;&quot;&#125;),handler.start(tagName,attrs,unary))&#125;function parseEndTag(tag,tagName)&#123;var pos;if(tagName=lowerCase(tagName))for(pos=stack.length-1;0&lt;=pos&amp;&amp;stack[pos]!==tagName;pos--);else pos=0;if(0&lt;=pos)&#123;for(var i=stack.length-1;pos&lt;=i;i--)handler.end&amp;&amp;handler.end(stack[i]);stack.length=pos&#125;&#125;parseEndTag()&#125;;var regDoctype=/^&lt;!\\s*doctype((?:\\s+[\\w:]+(?:\\s*=\\s*(?:(?:&quot;[^&quot;]*&quot;)|(?:&apos;[^&apos;]*&apos;)|[^&gt;\\s]+))?)*)\\s*(\\/?)&gt;/i,regEndTag=/^&lt;\\/([-A-Za-z0-9_]+)[^&gt;]*&gt;/,regStartTag=/^&lt;([-A-Za-z0-9_]+)((?:\\s+[-A-Za-z0-9_:@.]+(?:\\s*=\\s*(?:(?:&quot;[^&quot;]*&quot;)|(?:&apos;[^&apos;]*&apos;)|[^&gt;\\s]+))?)*)\\s*(\\/?)&gt;/i,regAttr=/([-A-Za-z0-9_:@.]+)(?:\\s*=\\s*(?:(?:&quot;((?:\\\\.|[^&quot;])*)&quot;)|(?:&apos;((?:\\\\.|[^&apos;])*)&apos;)|([^&gt;\\s]+)))?/g,SPECIAL=arrToMap(&quot;script,style&quot;.split(&quot;,&quot;));module.exports=exports&#125;),html=createCommonjsModule(function(module,exports)&#123;module.exports=&#123;parse:function(html)&#123;var ret=[],stack=new Stack;return parseHtml(html,&#123;start:function(tag,attrs)&#123;attrs=mapObj(attrs,function(val)&#123;return val.replace(/&amp;quot;/g,&apos;&quot;&apos;)&#125;),stack.push(&#123;tag:tag,attrs:attrs&#125;)&#125;,end:function()&#123;var lastNode,node=stack.pop();stack.size?(lastNode=stack.peek(),isArr(lastNode.content)||(lastNode.content=[]),lastNode.content.push(node)):ret.push(node)&#125;,comment:function(text)&#123;var text=&quot;\\x3c!--&quot;.concat(text,&quot;--\\x3e&quot;),lastNode=stack.peek();lastNode?(lastNode.content||(lastNode.content=[]),lastNode.content.push(text)):ret.push(text)&#125;,text:function(text)&#123;var lastNode=stack.peek();lastNode?(lastNode.content||(lastNode.content=[]),lastNode.content.push(text)):ret.push(text)&#125;&#125;),ret&#125;,stringify:function stringify(tree)&#123;var ret=&quot;&quot;;return isArr(tree)?each(tree,function(node)&#123;return ret+=stringify(node)&#125;):isStr(tree)?ret=tree:(ret+=&quot;&lt;&quot;.concat(tree.tag),each(tree.attrs,function(val,key)&#123;return ret+=&quot; &quot;.concat(key,&apos;=&quot;&apos;).concat(val.replace(/&quot;/g,&quot;&amp;quot;&quot;),&apos;&quot;&apos;)&#125;),ret+=&quot;&gt;&quot;,tree.content&amp;&amp;(ret+=stringify(tree.content)),ret+=&quot;&lt;/&quot;.concat(tree.tag,&quot;&gt;&quot;)),ret&#125;&#125;&#125;),indent=createCommonjsModule(function(module,exports)&#123;var regLineBegin=/^(?!\\s*$)/gm;module.exports=function(str,char,len)&#123;return isNum(char)&amp;&amp;(len=char,char=&quot; &quot;),isUndef(len)&amp;&amp;(len=4),isUndef(char)&amp;&amp;(char=&quot; &quot;),char=repeat(char,len),str.replace(regLineBegin,char)&#125;&#125;),ini=createCommonjsModule(function(module,exports)&#123;var regSection=/^\\[([^\\]]*)\\]$/i,regKeyVal=/^([^=]+)(=(.*))?$/i,regComment=/^\\s*[;#]/;module.exports=&#123;parse:function(ini)&#123;var ret=&#123;&#125;,section=ret;return each(ini.split(&quot;\\n&quot;),function(line)&#123;if((line=trim(line))&amp;&amp;!line.match(regComment))&#123;var _key,match=line.match(regSection);if(match&amp;&amp;match[1])return _key=match[1],section=safeGet(ret,_key)||&#123;&#125;,safeSet(ret,_key,section);(match=line.match(regKeyVal))&amp;&amp;(_key=trim(match[1]),&quot;null&quot;===(line=&quot;false&quot;===(line=&quot;true&quot;===(line=!match[2]||trim(match[3]))?!0:line)?!1:line)&amp;&amp;(line=null),endWith(_key,&quot;[]&quot;)&amp;&amp;(_key=_key.substring(0,_key.length-2),section[_key]||(section[_key]=[])),isArr(section[_key])?section[_key].push(line):section[_key]=line)&#125;&#125;),ret&#125;,stringify:function stringify(obj)&#123;var options=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,ret=&quot;&quot;,section=options.section,separator=options.whitespace?&quot; = &quot;:&quot;=&quot;,children=[];return each(obj,function(val,key)&#123;isArr(val)?each(val,function(item)&#123;ret+=&quot;&quot;.concat(key,&quot;[]&quot;).concat(separator).concat(item,&quot;\\n&quot;)&#125;):isObj(val)?children.push(&#123;key:key,val:val&#125;):ret+=&quot;&quot;.concat(key).concat(separator).concat(val,&quot;\\n&quot;)&#125;),section&amp;&amp;ret&amp;&amp;(ret=&quot;[&quot;.concat(section,&quot;]\\n&quot;)+ret),section=section?section+&quot;.&quot;:&quot;&quot;,each(children,function(child)&#123;(child=stringify(child.val,&#123;section:section+child.key,whitespace:options.whitespace&#125;))&amp;&amp;(ret&amp;&amp;(ret+=&quot;\\n&quot;),ret+=child)&#125;),ret&#125;&#125;&#125;),insertionSort=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator,i=1,len=arr.length;i&lt;len;i++)for(var j=i;0&lt;j&amp;&amp;cmp(arr[j],arr[j-1])&lt;0;j--)swap(arr,j,j-1);return arr&#125;&#125;),intersectRange=createCommonjsModule(function(module,exports)&#123;module.exports=function(a,b)&#123;var min=a.start&lt;b.start?a:b,b=min===a?b:a;if(!(min.end&lt;b.start))return&#123;start:b.start,end:(min.end&lt;b.end?min:b).end&#125;&#125;&#125;),invariant=createCommonjsModule(function(module,exports)&#123;module.exports=function(condition,format,a,b,c,d,e,f)&#123;var args,argIndex,error,process=root.process||&#123;env:&#123;NODE_ENV:&quot;development&quot;&#125;&#125;;if(&quot;production&quot;!==process.env.NODE_ENV&amp;&amp;void 0===format)throw new Error(&quot;invariant requires an error message argument&quot;);if(!condition)throw void 0===format?error=new Error(&quot;Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.&quot;):(args=[a,b,c,d,e,f],argIndex=0,(error=new Error(format.replace(/%s/g,function()&#123;return args[argIndex++]&#125;))).name=&quot;Invariant Violation&quot;),error.framesToPop=1,error&#125;&#125;),isAbsoluteUrl=createCommonjsModule(function(module,exports)&#123;var regAbsolute=/^[a-z][a-z0-9+.-]*:/;module.exports=function(url)&#123;return regAbsolute.test(url)&#125;&#125;),isAsyncFn=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object AsyncFunction]&quot;===objToStr(val)&#125;&#125;),isClose=createCommonjsModule(function(module,exports)&#123;var abs=Math.abs,max=Math.max;module.exports=function(a,b,relTol,absTol)&#123;return isNum(relTol)||(relTol=1e-9),isNum(absTol)||(absTol=0),abs(a-b)&lt;=max(relTol*max(abs(a),abs(b)),absTol)&#125;&#125;),isCyclic=createCommonjsModule(function(module,exports)&#123;exports=function(val,parents)&#123;if(!isObj(val))return!1;if(parents&amp;&amp;parents.contains(val))return!0;parents=new Node(val,parents);for(var _keys=keys(val),i=0,len=_keys.length;i&lt;len;i++)if(exports(val[_keys[i]],parents))return!0;return!1&#125;;var Node=Class(&#123;initialize:function(val,next)&#123;this.val=val,this.next=next&#125;,contains:function(val)&#123;for(var cursor=this;cursor;)&#123;if(cursor.val===val)return!0;cursor=cursor.next&#125;return!1&#125;&#125;);module.exports=exports&#125;),isDarkMode=createCommonjsModule(function(module,exports)&#123;var m=new MediaQuery(&quot;(prefers-color-scheme: dark)&quot;);module.exports=function()&#123;return m.isMatch()&#125;&#125;),isDataUrl=createCommonjsModule(function(module,exports)&#123;var regDataUrl=/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.&#123;&#125;|~`]+=[a-z0-9-.!#$%*+.&#123;&#125;|~`]+)*)?(;base64)?,([a-z0-9!$&amp;&apos;,()*+;=\\-._~:@/?%\\s]*?)$/i;module.exports=function(str)&#123;return regDataUrl.test(trim(str))&#125;&#125;),isEmail=createCommonjsModule(function(module,exports)&#123;var regEmail=/.+@.+\\..+/;module.exports=function(val)&#123;return regEmail.test(val)&#125;&#125;),isEqual=createCommonjsModule(function(module,exports)&#123;function eq(a,b,aStack,bStack)&#123;if(a===b)return 0!==a||1/a==1/b;if(null==a||null==b)return a===b;if(a!=a)return b!=b;var type=typeof a;return(&quot;function&quot;==type||&quot;object&quot;==type||&quot;object&quot;==typeof b)&amp;&amp;function(a,b,aStack,bStack)&#123;var className=toString.call(a);if(className!==toString.call(b))return!1;switch(className)&#123;case&quot;[object RegExp]&quot;:case&quot;[object String]&quot;:return&quot;&quot;+a==&quot;&quot;+b;case&quot;[object Number]&quot;:return+a!=+a?+b!=+b:0==+a?1/+a==1/b:+a==+b;case&quot;[object Date]&quot;:case&quot;[object Boolean]&quot;:return+a==+b&#125;if(!(className=&quot;[object Array]&quot;===className))&#123;if(&quot;object&quot;!=typeof a||&quot;object&quot;!=typeof b)return!1;var aCtor=a.constructor,bCtor=b.constructor;if(aCtor!==bCtor&amp;&amp;!(isFn(aCtor)&amp;&amp;aCtor instanceof aCtor&amp;&amp;isFn(bCtor)&amp;&amp;bCtor instanceof bCtor)&amp;&amp;&quot;constructor&quot;in a&amp;&amp;&quot;constructor&quot;in b)return!1&#125;bStack=bStack||[];for(var length=(aStack=aStack||[]).length;length--;)if(aStack[length]===a)return bStack[length]===b;if(aStack.push(a),bStack.push(b),className)&#123;if((length=a.length)!==b.length)return!1;for(;length--;)if(!eq(a[length],b[length],aStack,bStack))return!1&#125;else&#123;var key,_keys=keys(a),length=_keys.length;if(keys(b).length!==length)return!1;for(;length--;)if(key=_keys[length],!has(b,key)||!eq(a[key],b[key],aStack,bStack))return!1&#125;return aStack.pop(),bStack.pop(),!0&#125;(a,b,aStack,bStack)&#125;module.exports=function(a,b)&#123;return eq(a,b)&#125;&#125;),isEven=createCommonjsModule(function(module,exports)&#123;module.exports=function(num)&#123;return!!isInt(num)&amp;&amp;num%2==0&#125;&#125;),_isFinite=createCommonjsModule(function(module,exports)&#123;var nativeIsFinite=root.isFinite,nativeIsNaN=root.isNaN;module.exports=function(val)&#123;return nativeIsFinite(val)&amp;&amp;!nativeIsNaN(parseFloat(val))&#125;&#125;),isGeneratorFn=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object GeneratorFunction]&quot;===objToStr(val)&#125;&#125;),isHidden=createCommonjsModule(function(module,exports)&#123;var getComputedStyle=root.getComputedStyle,document=root.document;function isOutside(clientRect,containerRect)&#123;return clientRect.right&lt;containerRect.left||clientRect.left&gt;containerRect.right||clientRect.bottom&lt;containerRect.top||clientRect.top&gt;containerRect.bottom&#125;module.exports=function(el)&#123;var _ref=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,_ref$display=_ref.display,_ref$visibility=_ref.visibility,_ref$visibility=void 0!==_ref$visibility&amp;&amp;_ref$visibility,_ref$opacity=_ref.opacity,_ref$opacity=void 0!==_ref$opacity&amp;&amp;_ref$opacity,_ref$size=_ref.size,_ref$size=void 0!==_ref$size&amp;&amp;_ref$size,_ref$viewport=_ref.viewport,_ref$viewport=void 0!==_ref$viewport&amp;&amp;_ref$viewport,_ref=_ref.overflow,_ref=void 0!==_ref&amp;&amp;_ref;if(void 0===_ref$display||_ref$display)return null===el.offsetParent;_ref$display=getComputedStyle(el);if(_ref$visibility&amp;&amp;&quot;hidden&quot;===_ref$display.visibility)return!0;if(_ref$opacity)&#123;if(&quot;0&quot;===_ref$display.opacity)return!0;for(var cur=el;cur=cur.parentElement;)if(&quot;0&quot;===getComputedStyle(cur).opacity)return!0&#125;var clientRect=el.getBoundingClientRect();if(_ref$size&amp;&amp;(0===clientRect.width||0===clientRect.height))return!0;if(_ref$viewport)return isOutside(clientRect,&#123;top:0,left:0,right:document.documentElement.clientWidth,bottom:document.documentElement.clientHeight&#125;);if(_ref)for(var _cur=el;_cur=_cur.parentElement;)&#123;var _overflow=getComputedStyle(_cur).overflow;if(&quot;scroll&quot;===_overflow||&quot;hidden&quot;===_overflow)if(isOutside(clientRect,_cur.getBoundingClientRect()))return!0&#125;return!1&#125;&#125;),isIp=createCommonjsModule(function(module,exports)&#123;exports=function(str)&#123;return exports.v4(str)||exports.v6(str)&#125;;var v4=&quot;(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d))&#123;3&#125;&quot;,regV4=new RegExp(&quot;^&quot;.concat(v4,&quot;$&quot;)),v6seg=&quot;[a-fA-F\\\\d]&#123;1,4&#125;&quot;,v4=[&quot;(&quot;,&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;7&#125;(?:&quot;).concat(v6seg,&quot;|:)|&quot;),&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;6&#125;(?:&quot;).concat(v4,&quot;|:&quot;).concat(v6seg,&quot;|:)|&quot;),&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;5&#125;(?::&quot;).concat(v4,&quot;|(:&quot;).concat(v6seg,&quot;)&#123;1,2&#125;|:)|&quot;),&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;4&#125;(?:(:&quot;).concat(v6seg,&quot;)&#123;0,1&#125;:&quot;).concat(v4,&quot;|(:&quot;).concat(v6seg,&quot;)&#123;1,3&#125;|:)|&quot;),&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;3&#125;(?:(:&quot;).concat(v6seg,&quot;)&#123;0,2&#125;:&quot;).concat(v4,&quot;|(:&quot;).concat(v6seg,&quot;)&#123;1,4&#125;|:)|&quot;),&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;2&#125;(?:(:&quot;).concat(v6seg,&quot;)&#123;0,3&#125;:&quot;).concat(v4,&quot;|(:&quot;).concat(v6seg,&quot;)&#123;1,5&#125;|:)|&quot;),&quot;(?:&quot;.concat(v6seg,&quot;:)&#123;1&#125;(?:(:&quot;).concat(v6seg,&quot;)&#123;0,4&#125;:&quot;).concat(v4,&quot;|(:&quot;).concat(v6seg,&quot;)&#123;1,6&#125;|:)|&quot;),&quot;(?::((?::&quot;.concat(v6seg,&quot;)&#123;0,5&#125;:&quot;).concat(v4,&quot;|(?::&quot;).concat(v6seg,&quot;)&#123;1,7&#125;|:))&quot;),&quot;)(%[0-9a-zA-Z]&#123;1,&#125;)?&quot;].join(&quot;&quot;),regV6=new RegExp(&quot;^&quot;.concat(v4,&quot;$&quot;));exports.v4=function(str)&#123;return regV4.test(str)&#125;,exports.v6=function(str)&#123;return regV6.test(str)&#125;,module.exports=exports&#125;),isIp_1=isIp.v4,isIp_2=isIp.v6,isJson=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;try&#123;return JSON.parse(val),!0&#125;catch(e)&#123;return!1&#125;&#125;&#125;),isLeapYear=createCommonjsModule(function(module,exports)&#123;module.exports=function(year)&#123;return year%400==0||year%4==0&amp;&amp;year%100!=0&#125;&#125;),isMap=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Map]&quot;===objToStr(val)&#125;&#125;),isMobile=createCommonjsModule(function(module,exports)&#123;var regMobileAll=/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,regMobileFour=/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i;exports=memoize(function(ua)&#123;return ua=ua||(isBrowser?navigator.userAgent:&quot;&quot;),regMobileAll.test(ua)||regMobileFour.test(ua.substr(0,4))&#125;),module.exports=exports&#125;),isNative=createCommonjsModule(function(module,exports)&#123;exports=function(val)&#123;return!!isObj(val)&amp;&amp;(isFn(val)?regIsNative:regIsHostCtor).test(toSrc(val))&#125;;var hasOwnProperty=Object.prototype.hasOwnProperty,regIsNative=new RegExp(&quot;^&quot;+toSrc(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]&#123;&#125;|]/g,&quot;\\\\$&amp;&quot;).replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,&quot;$1.*?&quot;)+&quot;$&quot;),regIsHostCtor=/^\\[object .+?Constructor\\]$/;module.exports=exports&#125;),isNull=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return null===val&#125;&#125;),isNumeric=createCommonjsModule(function(module,exports)&#123;var regComma=/,/g;module.exports=function(val)&#123;return isStr(val)&amp;&amp;(val=val.replace(regComma,&quot;&quot;)),!_isNaN(parseFloat(val))&amp;&amp;_isFinite(val)&amp;&amp;!isArr(val)&#125;&#125;),isPrime=createCommonjsModule(function(module,exports)&#123;module.exports=function(num)&#123;for(var boundary=Math.floor(Math.sqrt(num)),i=2;i&lt;=boundary;i++)if(num%i==0)return!1;return 2&lt;=num&#125;&#125;),isPrimitive=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;var type=typeof val;return null==val||&quot;function&quot;!=type&amp;&amp;&quot;object&quot;!=type&#125;&#125;),isPromise=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return isObj(val)&amp;&amp;isFn(val.then)&amp;&amp;isFn(val.catch)&#125;&#125;),isRelative=createCommonjsModule(function(module,exports)&#123;var regAbsolute=/^([a-z]+:)?[\\\\/]/i;module.exports=function(path)&#123;return!regAbsolute.test(path)&#125;&#125;),isRetina=createCommonjsModule(function(module,exports)&#123;exports=isBrowser&amp;&amp;(1.25&lt;window.devicePixelRatio||window.matchMedia&amp;&amp;window.matchMedia(&quot;(-webkit-min-device-pixel-ratio: 1.25), (min--moz-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5/4), (min-resolution: 1.25dppx)&quot;).matches),module.exports=exports&#125;),isSet=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object Set]&quot;===objToStr(val)&#125;&#125;),isTypedArr=createCommonjsModule(function(module,exports)&#123;exports=function(val)&#123;return!!map[objToStr(val)]&#125;;var map=&#123;&#125;;each([&quot;Int8Array&quot;,&quot;Int16Array&quot;,&quot;Int32Array&quot;,&quot;Uint8Array&quot;,&quot;Uint8ClampedArray&quot;,&quot;Uint16Array&quot;,&quot;Uint32Array&quot;,&quot;Float32Array&quot;,&quot;Float64Array&quot;],function(val)&#123;map[&quot;[object &quot;+val+&quot;]&quot;]=!0&#125;),module.exports=exports&#125;),isUrl=createCommonjsModule(function(module,exports)&#123;var regUrl=/^(?:\\w+:)?\\/\\/([^\\s.]+\\.\\S&#123;2&#125;|localhost[:?\\d]*)\\S*$/;module.exports=function(val)&#123;return regUrl.test(val)&#125;&#125;),isWeakMap=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object WeakMap]&quot;===objToStr(val)&#125;&#125;),isWeakSet=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return&quot;[object WeakSet]&quot;===objToStr(val)&#125;&#125;),jsonClone=createCommonjsModule(function(module,exports)&#123;module.exports=function(val)&#123;return JSON.parse(JSON.stringify(val))&#125;&#125;),loadJs=createCommonjsModule(function(module,exports)&#123;module.exports=function(src,cb)&#123;var script=document.createElement(&quot;script&quot;);script.src=src,script.onload=function()&#123;var isNotLoaded=script.readyState&amp;&amp;&quot;complete&quot;!=script.readyState&amp;&amp;&quot;loaded&quot;!=script.readyState;cb&amp;&amp;cb(!isNotLoaded)&#125;,script.onerror=function()&#123;cb(!1)&#125;,document.body.appendChild(script)&#125;&#125;),jsonp=createCommonjsModule(function(module,exports)&#123;(exports=function(options)&#123;defaults(options,exports.settings);var timer,name=options.name||uniqId(&quot;jsonp&quot;),param=options.param,timeout=options.timeout,error=options.error,success=options.success,complete=options.complete,data=options.data,options=options.url,isTimeout=!1;0&lt;timeout&amp;&amp;(timer=setTimeout(function()&#123;isTimeout=!0,error(new Error(&quot;Timeout&quot;)),complete()&#125;,timeout)),window[name]=function(data)&#123;success(data),complete(),window[name]=noop&#125;,data[param]=name,data=query.stringify(data),options+=-1&lt;options.indexOf(&quot;?&quot;)?&quot;&amp;&quot;+data:&quot;?&quot;+data,loadJs(options,function(isLoaded)&#123;isTimeout||(timer&amp;&amp;clearTimeout(timer),isLoaded||(error(new Error),complete()))&#125;)&#125;).settings=&#123;data:&#123;&#125;,param:&quot;callback&quot;,success:noop,error:noop,complete:noop,timeout:0&#125;,module.exports=exports&#125;),jsonp_1=jsonp.settings,linkify=createCommonjsModule(function(module,exports)&#123;function defHyperlink(url)&#123;return&apos;&lt;a href=&quot;&apos;+url+&apos;&quot;&gt;&apos;+url+&quot;&lt;/a&gt;&quot;&#125;module.exports=function(str,hyperlink)&#123;hyperlink=hyperlink||defHyperlink;var urlList=extractUrls(str);return each(urlList,function(url)&#123;str=str.replace(new RegExp(escapeRegExp(url),&quot;g&quot;),hyperlink)&#125;),str&#125;&#125;),loadCss=createCommonjsModule(function(module,exports)&#123;module.exports=function(src,cb)&#123;cb=cb||noop;var link=document.createElement(&quot;link&quot;);link.rel=&quot;stylesheet&quot;,link.type=&quot;text/css&quot;,link.onerror=function()&#123;cb(!1)&#125;,link.onload=function()&#123;cb(!0)&#125;,link.href=src,document.head.appendChild(link)&#125;&#125;),wordsToBytes=createCommonjsModule(function(module,exports)&#123;module.exports=function(words)&#123;for(var bytes=[],b=0,len=32*words.length;b&lt;len;b+=8)bytes.push(words[b&gt;&gt;&gt;5]&gt;&gt;&gt;24-b%32&amp;255);return bytes&#125;&#125;),md5=createCommonjsModule(function(module,exports)&#123;function FF(a,b,c,d,x,s,t)&#123;a=a+(b&amp;c|~b&amp;d)+(x&gt;&gt;&gt;0)+t;return(a&lt;&lt;s|a&gt;&gt;&gt;32-s)+b&#125;function GG(a,b,c,d,x,s,t)&#123;a=a+(b&amp;d|c&amp;~d)+(x&gt;&gt;&gt;0)+t;return(a&lt;&lt;s|a&gt;&gt;&gt;32-s)+b&#125;function HH(a,b,c,d,x,s,t)&#123;a=a+(b^c^d)+(x&gt;&gt;&gt;0)+t;return(a&lt;&lt;s|a&gt;&gt;&gt;32-s)+b&#125;function II(a,b,c,d,x,s,t)&#123;a=a+(c^(b|~d))+(x&gt;&gt;&gt;0)+t;return(a&lt;&lt;s|a&gt;&gt;&gt;32-s)+b&#125;function rotl(n,b)&#123;return n&lt;&lt;b|n&gt;&gt;&gt;32-b&#125;module.exports=function(msg)&#123;isStr(msg)&amp;&amp;(msg=strToBytes(msg));for(var m=bytesToWords(msg),msg=8*msg.length,a=1732584193,b=-271733879,c=-1732584194,d=271733878,i=0;i&lt;m.length;i++)m[i]=16711935&amp;(m[i]&lt;&lt;8|m[i]&gt;&gt;&gt;24)|4278255360&amp;(m[i]&lt;&lt;24|m[i]&gt;&gt;&gt;8);m[msg&gt;&gt;&gt;5]|=128&lt;&lt;msg%32,m[14+(64+msg&gt;&gt;&gt;9&lt;&lt;4)]=msg;for(var _i=0;_i&lt;m.length;_i+=16)&#123;var aa=a,bb=b,cc=c,dd=d,a=FF(a,b,c,d,m[_i+0],7,-680876936),d=FF(d,a,b,c,m[_i+1],12,-389564586),c=FF(c,d,a,b,m[_i+2],17,606105819),b=FF(b,c,d,a,m[_i+3],22,-1044525330);a=FF(a,b,c,d,m[_i+4],7,-176418897),d=FF(d,a,b,c,m[_i+5],12,1200080426),c=FF(c,d,a,b,m[_i+6],17,-1473231341),b=FF(b,c,d,a,m[_i+7],22,-45705983),a=FF(a,b,c,d,m[_i+8],7,1770035416),d=FF(d,a,b,c,m[_i+9],12,-1958414417),c=FF(c,d,a,b,m[_i+10],17,-42063),b=FF(b,c,d,a,m[_i+11],22,-1990404162),a=FF(a,b,c,d,m[_i+12],7,1804603682),d=FF(d,a,b,c,m[_i+13],12,-40341101),c=FF(c,d,a,b,m[_i+14],17,-1502002290),a=GG(a,b=FF(b,c,d,a,m[_i+15],22,1236535329),c,d,m[_i+1],5,-165796510),d=GG(d,a,b,c,m[_i+6],9,-1069501632),c=GG(c,d,a,b,m[_i+11],14,643717713),b=GG(b,c,d,a,m[_i+0],20,-373897302),a=GG(a,b,c,d,m[_i+5],5,-701558691),d=GG(d,a,b,c,m[_i+10],9,38016083),c=GG(c,d,a,b,m[_i+15],14,-660478335),b=GG(b,c,d,a,m[_i+4],20,-405537848),a=GG(a,b,c,d,m[_i+9],5,568446438),d=GG(d,a,b,c,m[_i+14],9,-1019803690),c=GG(c,d,a,b,m[_i+3],14,-187363961),b=GG(b,c,d,a,m[_i+8],20,1163531501),a=GG(a,b,c,d,m[_i+13],5,-1444681467),d=GG(d,a,b,c,m[_i+2],9,-51403784),c=GG(c,d,a,b,m[_i+7],14,1735328473),a=HH(a,b=GG(b,c,d,a,m[_i+12],20,-1926607734),c,d,m[_i+5],4,-378558),d=HH(d,a,b,c,m[_i+8],11,-2022574463),c=HH(c,d,a,b,m[_i+11],16,1839030562),b=HH(b,c,d,a,m[_i+14],23,-35309556),a=HH(a,b,c,d,m[_i+1],4,-1530992060),d=HH(d,a,b,c,m[_i+4],11,1272893353),c=HH(c,d,a,b,m[_i+7],16,-155497632),b=HH(b,c,d,a,m[_i+10],23,-1094730640),a=HH(a,b,c,d,m[_i+13],4,681279174),d=HH(d,a,b,c,m[_i+0],11,-358537222),c=HH(c,d,a,b,m[_i+3],16,-722521979),b=HH(b,c,d,a,m[_i+6],23,76029189),a=HH(a,b,c,d,m[_i+9],4,-640364487),d=HH(d,a,b,c,m[_i+12],11,-421815835),c=HH(c,d,a,b,m[_i+15],16,530742520),a=II(a,b=HH(b,c,d,a,m[_i+2],23,-995338651),c,d,m[_i+0],6,-198630844),d=II(d,a,b,c,m[_i+7],10,1126891415),c=II(c,d,a,b,m[_i+14],15,-1416354905),b=II(b,c,d,a,m[_i+5],21,-57434055),a=II(a,b,c,d,m[_i+12],6,1700485571),d=II(d,a,b,c,m[_i+3],10,-1894986606),c=II(c,d,a,b,m[_i+10],15,-1051523),b=II(b,c,d,a,m[_i+1],21,-2054922799),a=II(a,b,c,d,m[_i+8],6,1873313359),d=II(d,a,b,c,m[_i+15],10,-30611744),c=II(c,d,a,b,m[_i+6],15,-1560198380),b=II(b,c,d,a,m[_i+13],21,1309151649),a=II(a,b,c,d,m[_i+4],6,-145523070),d=II(d,a,b,c,m[_i+11],10,-1120210379),c=II(c,d,a,b,m[_i+2],15,718787259),b=II(b,c,d,a,m[_i+9],21,-343485551),a=a+aa&gt;&gt;&gt;0,b=b+bb&gt;&gt;&gt;0,c=c+cc&gt;&gt;&gt;0,d=d+dd&gt;&gt;&gt;0&#125;return hex.encode(wordsToBytes(function endian(n)&#123;if(n.constructor==Number)return 16711935&amp;rotl(n,8)|4278255360&amp;rotl(n,24);for(var i=0;i&lt;n.length;i++)n[i]=endian(n[i]);return n&#125;([a,b,c,d])))&#125;&#125;),mergeSort=createCommonjsModule(function(module,exports)&#123;exports=function(arr)&#123;var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator;if(arr.length&lt;=1)return arr;var middle=floor(arr.length/2),left=arr.slice(0,middle),middle=arr.slice(middle);return function(left,right,cmp)&#123;var ret=[],i=0,j=0;for(;i&lt;left.length&amp;&amp;j&lt;right.length;)cmp(left[i],right[j])&lt;0?ret.push(left[i++]):ret.push(right[j++]);for(;i&lt;left.length;)ret.push(left[i++]);for(;j&lt;right.length;)ret.push(right[j++]);return ret&#125;(exports(left,cmp),exports(middle,cmp),cmp)&#125;;var floor=Math.floor;module.exports=exports&#125;),meta=createCommonjsModule(function(module,exports)&#123;(exports=function(name,content)&#123;if(isUndef(name))return ret=&#123;&#125;,metaEach(function(name,content)&#123;ret[name]=content&#125;),ret;var ret;if(isStr(name)&amp;&amp;isUndef(content)||isArr(name))return function(name)&#123;&#123;var ret;&#123;if(!isStr(name))return ret=&#123;&#125;,metaEach(function(key,val)&#123;contain(name,key)&amp;&amp;(ret[key]=val)&#125;),ret;var meta=selectMeta(name);if(meta)return meta.getAttribute(&quot;content&quot;)&#125;&#125;&#125;(name);var metas=name;isObj(metas)||((metas=&#123;&#125;)[name]=content),function(metas)&#123;each(metas,function(content,name)&#123;var meta=selectMeta(name);if(meta)return meta.setAttribute(&quot;content&quot;,content);(meta=doc.createElement(&quot;meta&quot;)).setAttribute(&quot;name&quot;,name),meta.setAttribute(&quot;content&quot;,content),doc.head.appendChild(meta)&#125;)&#125;(metas)&#125;).remove=function(nameList)&#123;nameList=toArr(nameList),each(nameList,function(name)&#123;name=selectMeta(name);name&amp;&amp;doc.head.removeChild(name)&#125;)&#125;;var doc=document;function metaEach(fn)&#123;var metaList=doc.querySelectorAll(&quot;meta&quot;);each(metaList,function(meta)&#123;var name=meta.getAttribute(&quot;name&quot;),meta=meta.getAttribute(&quot;content&quot;);name&amp;&amp;meta&amp;&amp;fn(name,meta)&#125;)&#125;function selectMeta(name)&#123;return doc.querySelector(&apos;meta[name=&quot;&apos;+name+&apos;&quot;]&apos;)&#125;module.exports=exports&#125;),meta_1=meta.remove,methods=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;var key,ret=[];for(key in obj)isFn(obj[key])&amp;&amp;ret.push(key);return ret.sort()&#125;&#125;),min=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var arr=arguments,ret=arr[0],i=1,len=arr.length;i&lt;len;i++)arr[i]&lt;ret&amp;&amp;(ret=arr[i]);return ret&#125;&#125;),toDate=createCommonjsModule(function(module,exports)&#123;var regDate=/^(\\d&#123;4&#125;)-?(\\d&#123;2&#125;)-?(\\d&#123;1,2&#125;)$/;module.exports=function(val)&#123;if(!val)return new Date;if(isDate(val))return val;if(isStr(val))&#123;var match=val.match(regDate);if(match)return new Date(match[1],match[2]-1,match[3])&#125;return new Date(val)&#125;&#125;),moment=createCommonjsModule(function(module,exports)&#123;exports=function(val)&#123;return new Moment(val)&#125;;var Moment=Class(&#123;initialize:function(val)&#123;this._d=toDate(val),this._init()&#125;,_init:function()&#123;var d=this._d;return extend(this,&#123;_year:d.getFullYear(),_month:d.getMonth(),_date:d.getDate(),_hour:d.getHours(),_minute:d.getMinutes(),_second:d.getSeconds(),_millisecond:d.getMilliseconds()&#125;),this&#125;,format:function(mask)&#123;return dateFormat(this._d,mask)&#125;,isValid:function()&#123;return!(&quot;Invalid Date&quot;===this._d.toString())&#125;,isLeapYear:function()&#123;return isLeapYear(this._year)&#125;,isSame:function(that)&#123;return this.valueOf()===that.valueOf()&#125;,valueOf:function()&#123;return this._d.getTime()&#125;,isBefore:function(that)&#123;return this.valueOf()&lt;that.valueOf()&#125;,isAfter:function(that)&#123;return this.valueOf()&gt;that.valueOf()&#125;,year:makeGetSet(&quot;year&quot;),month:makeGetSet(&quot;month&quot;),date:makeGetSet(&quot;date&quot;),hour:makeGetSet(&quot;hour&quot;),minute:makeGetSet(&quot;minute&quot;),second:makeGetSet(&quot;second&quot;),millisecond:makeGetSet(&quot;millisecond&quot;),unix:function()&#123;return floor(this.valueOf()/1e3)&#125;,clone:function()&#123;return new Moment(this)&#125;,toDate:function()&#123;return new Date(this._d)&#125;,toArray:function()&#123;return[this._year,this._month,this._date,this._hour,this._minute,this._second,this._millisecond]&#125;,toJSON:function()&#123;return this.toISOString()&#125;,toISOString:function()&#123;return this.toDate().toISOString()&#125;,toObject:function()&#123;return&#123;years:this._year,months:this._month,date:this._date,hours:this._hour,minutes:this._minute,seconds:this._second,milliseconds:this._millisecond&#125;&#125;,toString:function()&#123;return this._d.toUTCString()&#125;,set:function(unit,num)&#123;var d=this._d;switch(unit=normalizeUnit(unit))&#123;case&quot;year&quot;:d.setFullYear(num);break;case&quot;month&quot;:d.setMonth(num);break;case&quot;date&quot;:d.setDate(num);break;case&quot;hour&quot;:d.setHours(num);break;case&quot;minute&quot;:d.setMinutes(num);break;case&quot;second&quot;:d.setSeconds(num);break;case&quot;millisecond&quot;:d.setMilliseconds(num)&#125;return this._init()&#125;,startOf:function(unit)&#123;switch(unit=normalizeUnit(unit))&#123;case&quot;year&quot;:this.month(0);case&quot;month&quot;:this.date(1);case&quot;day&quot;:case&quot;date&quot;:this.hour(0);case&quot;hour&quot;:this.minute(0);case&quot;minute&quot;:this.second(0);case&quot;second&quot;:this.millisecond(0)&#125;return this&#125;,endOf:function(unit)&#123;return this.startOf(unit).add(1,unit).subtract(1,&quot;ms&quot;)&#125;,daysInMonth:function()&#123;return this.clone().endOf(&quot;month&quot;).date()&#125;,add:createAdder(1),subtract:createAdder(-1),diff:function(input,unit,asFloat)&#123;var ret,that=input instanceof Moment?input:new Moment(input),diff=this-that;switch(unit=normalizeUnit(unit))&#123;case&quot;year&quot;:ret=monthDiff(this,that)/12;break;case&quot;month&quot;:ret=monthDiff(this,that);break;case&quot;second&quot;:ret=diff/1e3;break;case&quot;minute&quot;:ret=diff/6e4;break;case&quot;hour&quot;:ret=diff/36e5;break;case&quot;day&quot;:ret=diff/864e5;break;default:ret=diff&#125;return asFloat?ret:(input=ret)&lt;0?ceil(input)||0:floor(input)&#125;&#125;),floor=Math.floor,ceil=Math.ceil;var unitShorthandMap=&#123;y:&quot;year&quot;,M:&quot;month&quot;,D:&quot;date&quot;,d:&quot;day&quot;,h:&quot;hour&quot;,m:&quot;minute&quot;,s:&quot;second&quot;,ms:&quot;millisecond&quot;&#125;,regEndS=/s$/;function normalizeUnit(unit)&#123;return unit=toStr(unit),unitShorthandMap[unit]||unit.toLowerCase().replace(regEndS,&quot;&quot;)&#125;function makeGetSet(unit)&#123;return function(num)&#123;return isNil(num)?this[&quot;_&quot;+unit]:this.set(unit,num)&#125;&#125;function createAdder(dir)&#123;return function(num,unit)&#123;if(&quot;month&quot;===(unit=normalizeUnit(unit)))return this.month(this._month+dir*num);if(&quot;year&quot;===unit)return this.year(this._year+dir*num);num=function(num,unit)&#123;return ms(num+msMap[unit])&#125;(num,unit);return this._d=new Date(this.valueOf()+dir*num),this._init()&#125;&#125;var msMap=&#123;day:&quot;d&quot;,hour:&quot;h&quot;,minute:&quot;m&quot;,second:&quot;s&quot;,millisecond:&quot;&quot;&#125;;function monthDiff(a,b)&#123;var wholeMonthDiff=12*(b.year()-a.year())+(b.month()-a.month()),anchor=a.clone().add(wholeMonthDiff,&quot;months&quot;),b=b-anchor&lt;0?(b-anchor)/(anchor-a.clone().add(wholeMonthDiff-1,&quot;months&quot;)):(b-anchor)/(a.clone().add(1+wholeMonthDiff,&quot;months&quot;)-anchor);return-(wholeMonthDiff+b)||0&#125;module.exports=exports&#125;),toEl=createCommonjsModule(function(module,exports)&#123;var range,doc=document;exports=function(str)&#123;var fragment=doc.createElement(&quot;body&quot;);return fragment.innerHTML=str,fragment.childNodes[0]&#125;,doc.createRange&amp;&amp;doc.body&amp;&amp;((range=doc.createRange()).selectNode(doc.body),range.createContextualFragment&amp;&amp;(exports=function(str)&#123;return range.createContextualFragment(str).childNodes[0]&#125;)),module.exports=exports&#125;),morphDom=createCommonjsModule(function(module,exports)&#123;var ELEMENT_NODE=1,TEXT_NODE=3,COMMENT_NODE=8;function morphEl(from,to)&#123;!function(from,to)&#123;var attrs=to.attributes,removedAttrNames=(each(attrs,function(_ref)&#123;var name=_ref.name,_ref=_ref.value;from.getAttribute(name)!==_ref&amp;&amp;from.setAttribute(name,_ref)&#125;),attrs=from.attributes,[]);each(attrs,function(_ref2)&#123;_ref2=_ref2.name;isNull(to.getAttribute(_ref2))&amp;&amp;removedAttrNames.push(_ref2)&#125;),each(removedAttrNames,function(name)&#123;return from.removeAttribute(name)&#125;)&#125;(from,to),function(from,to)&#123;var toNextSibling,fromNextSibling,curToChild=to.firstChild,curFromChild=from.firstChild;outer:for(;curToChild;)&#123;for(toNextSibling=curToChild.nextSibling;curFromChild;)&#123;fromNextSibling=curFromChild.nextSibling;var isCompatible=!1,curFromType=curFromChild.nodeType,curToType=curToChild.nodeType;if(curFromType===curToType&amp;&amp;(curFromType===ELEMENT_NODE?curFromChild.nodeName===curToChild.nodeName&amp;&amp;(isCompatible=!0,morphEl(curFromChild,curToChild)):curFromType!==TEXT_NODE&amp;&amp;curFromType!==COMMENT_NODE||(isCompatible=!0,curFromChild.nodeValue!==curToChild.nodeValue&amp;&amp;(curFromChild.nodeValue=curToChild.nodeValue))),isCompatible)&#123;curToChild=toNextSibling,curFromChild=fromNextSibling;continue outer&#125;from.removeChild(curFromChild),curFromChild=fromNextSibling&#125;from.appendChild(curToChild),curFromChild=fromNextSibling,curToChild=toNextSibling&#125;if(curFromChild)for(;curFromChild;)fromNextSibling=curFromChild.nextSibling,from.removeChild(curFromChild),curFromChild=fromNextSibling&#125;(from,to)&#125;module.exports=function(from,to)&#123;isStr(to)&amp;&amp;(to=toEl(to));var morphed=from,morphedType=morphed.nodeType;if(morphedType===to.nodeType)&#123;if(morphedType===ELEMENT_NODE)morphed.nodeName!==to.nodeName&amp;&amp;function(from,to)&#123;var curChild=from.firstChild;for(;curChild;)&#123;var nextChild=curChild.nextSibling;to.appendChild(curChild),curChild=nextChild&#125;&#125;(from,morphed=h(to.nodeName));else if(morphedType===TEXT_NODE||morphedType===COMMENT_NODE)return morphed.nodeValue!==to.nodeValue&amp;&amp;(morphed.nodeValue=to.nodeValue),morphed&#125;else morphed=to;return morphed!==to&amp;&amp;morphEl(morphed,to),from.parentNode&amp;&amp;from.parentNode.replaceChild(morphed,from),morphed&#125;&#125;),upperCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return toStr(str).toLocaleUpperCase()&#125;&#125;),morse=createCommonjsModule(function(module,exports)&#123;exports=&#123;encode:function(txt)&#123;for(var len=txt.length,ret=Array(len),i=0;i&lt;len;i++)&#123;var c=upperCase(txt[i]);ret[i]=map[c]||&quot;?&quot;&#125;return ret.join(&quot; &quot;)&#125;,decode:function(morse)&#123;for(var ret=morse.split(&quot; &quot;),i=0,len=ret.length;i&lt;len;i++)ret[i]=decodeMap[ret[i]]||&quot; &quot;;return ret.join(&quot;&quot;)&#125;&#125;;var map=&#123;A:&quot;.-&quot;,B:&quot;-...&quot;,C:&quot;-.-.&quot;,D:&quot;-..&quot;,E:&quot;.&quot;,F:&quot;..-.&quot;,G:&quot;--.&quot;,H:&quot;....&quot;,I:&quot;..&quot;,J:&quot;.---&quot;,K:&quot;-.-&quot;,L:&quot;.-..&quot;,M:&quot;--&quot;,N:&quot;-.&quot;,O:&quot;---&quot;,P:&quot;.--.&quot;,Q:&quot;--.-&quot;,R:&quot;.-.&quot;,S:&quot;...&quot;,T:&quot;-&quot;,U:&quot;..-&quot;,V:&quot;...-&quot;,W:&quot;.--&quot;,X:&quot;-..-&quot;,Y:&quot;-.--&quot;,Z:&quot;--..&quot;,&quot;Á&quot;:&quot;.--.-&quot;,&quot;Ä&quot;:&quot;.-.-&quot;,&quot;É&quot;:&quot;..-..&quot;,&quot;Ñ&quot;:&quot;--.--&quot;,&quot;Ö&quot;:&quot;---.&quot;,&quot;Ü&quot;:&quot;..--&quot;,1:&quot;.----&quot;,2:&quot;..---&quot;,3:&quot;...--&quot;,4:&quot;....-&quot;,5:&quot;.....&quot;,6:&quot;-....&quot;,7:&quot;--...&quot;,8:&quot;---..&quot;,9:&quot;----.&quot;,0:&quot;-----&quot;,&quot;,&quot;:&quot;--..--&quot;,&quot;.&quot;:&quot;.-.-.-&quot;,&quot;?&quot;:&quot;..--..&quot;,&quot;;&quot;:&quot;-.-.-&quot;,&quot;:&quot;:&quot;---...&quot;,&quot;/&quot;:&quot;-..-.&quot;,&quot;-&quot;:&quot;-....-&quot;,&quot;&apos;&quot;:&quot;.----.&quot;,&quot;()&quot;:&quot;-.--.-&quot;,_:&quot;..--.-&quot;,&quot;@&quot;:&quot;.--.-.&quot;,&quot; &quot;:&quot;.......&quot;&#125;,decodeMap=invert(map);module.exports=exports&#125;),naturalSort=createCommonjsModule(function(module,exports)&#123;function naturalOrderComparator(a,b)&#123;if(a=toStr(a),b=toStr(b),startWith(a,&quot;_&quot;)&amp;&amp;!startWith(b,&quot;_&quot;))return 1;if(startWith(b,&quot;_&quot;)&amp;&amp;!startWith(a,&quot;_&quot;))return-1;for(var chunka,chunkb,bnum,chunk=/^\\d+|^\\D+/;;)&#123;if(!a)return b?-1:0;if(!b)return 1;if(chunka=a.match(chunk)[0],chunkb=b.match(chunk)[0],anum=!root.isNaN(chunka),bnum=!root.isNaN(chunkb),anum&amp;&amp;!bnum)return-1;if(bnum&amp;&amp;!anum)return 1;if(anum&amp;&amp;bnum)&#123;var anum=chunka-chunkb;if(anum)return anum;if(chunka.length!==chunkb.length)return+chunka||+chunkb?chunkb.length-chunka.length:chunka.length-chunkb.length&#125;else if(chunka!==chunkb)return chunka&lt;chunkb?-1:1;a=a.substring(chunka.length),b=b.substring(chunkb.length)&#125;&#125;module.exports=function(arr)&#123;return arr.sort(naturalOrderComparator)&#125;&#125;),negate=createCommonjsModule(function(module,exports)&#123;module.exports=function(predicate)&#123;return function()&#123;return!predicate.apply(this,arguments)&#125;&#125;&#125;),normalizeHeader=createCommonjsModule(function(module,exports)&#123;var specialHeaders=&#123;&quot;content-md5&quot;:&quot;Content-MD5&quot;,dnt:&quot;DNT&quot;,etag:&quot;ETag&quot;,&quot;last-event-id&quot;:&quot;Last-Event-ID&quot;,tcn:&quot;TCN&quot;,te:&quot;TE&quot;,&quot;www-authenticate&quot;:&quot;WWW-Authenticate&quot;,&quot;x-dnsprefetch-control&quot;:&quot;X-DNSPrefetch-Control&quot;&#125;;module.exports=function(header)&#123;return specialHeaders[header.toLowerCase()]||map(header.split(&quot;-&quot;),capitalize).join(&quot;-&quot;)&#125;&#125;),normalizePath=createCommonjsModule(function(module,exports)&#123;var regSlashes=/[\\\\/]+/g;module.exports=function(path)&#123;return path.replace(regSlashes,&quot;/&quot;)&#125;&#125;),normalizePhone=createCommonjsModule(function(module,exports)&#123;var regPlusSign=/^\\+/,regNotDigit=/\\D/g,regTrunkPrefix=/^\\d/;module.exports=function(phone,options)&#123;phone=trim(phone);var countryCode=options.countryCode,options=options.trunkPrefix,options=void 0!==options&amp;&amp;options,plusSign=regPlusSign.test(phone);return phone=phone.replace(regNotDigit,&quot;&quot;),plusSign&amp;&amp;(phone=phone.replace(new RegExp(&quot;^&quot;.concat(countryCode)),&quot;&quot;)),options&amp;&amp;(phone=phone.replace(regTrunkPrefix,&quot;&quot;)),&quot;+&quot;.concat(countryCode+phone)&#125;&#125;),notify=createCommonjsModule(function(module,exports)&#123;var Notification=root.Notification;(exports=function(title,options)&#123;new exports.Notification(title,options).show()&#125;).Notification=Emitter.extend(&#123;initialize:function(title)&#123;this._options=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,this._title=title,this.callSuper(Emitter,&quot;initialize&quot;,arguments)&#125;,handleEvent:function(e)&#123;this.emit(e.type,e)&#125;,show:function()&#123;var _this=this;if(!Notification)return this.emit(&quot;error&quot;,Error(&quot;Notification is not supported&quot;));&quot;granted&quot;===Notification.permission?this._show():Notification.requestPermission(function(permission)&#123;switch(permission)&#123;case&quot;granted&quot;:_this._show();break;case&quot;denied&quot;:_this.emit(&quot;error&quot;,Error(&quot;Notification permission is denied&quot;))&#125;&#125;)&#125;,_show:function()&#123;var _this2=this,notification=new Notification(this._title,this._options);each([&quot;show&quot;,&quot;close&quot;,&quot;click&quot;],function(type)&#123;notification.addEventListener(type,_this2,!1)&#125;)&#125;&#125;),module.exports=exports&#125;),notify_1=notify.Notification,pick=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,filter,omit)&#123;isStr(filter)&amp;&amp;(filter=[filter]),isArr(filter)&amp;&amp;(keys=filter,filter=function(val,key)&#123;return contain(keys,key)&#125;);var keys,ret=&#123;&#125;;return each(obj,omit?function(val,key)&#123;filter(val,key)||(ret[key]=val)&#125;:function(val,key)&#123;filter(val,key)&amp;&amp;(ret[key]=val)&#125;),ret&#125;&#125;),omit=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,filter)&#123;return pick(obj,filter,!0)&#125;&#125;),openFile=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;var options=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:&#123;&#125;;return new Promise(function(resolve)&#123;var input=document.createElement(&quot;input&quot;);input.style.position=&quot;fixed&quot;,input.style.bottom=&quot;0&quot;,input.style.left=&quot;0&quot;,input.style.visibility=&quot;hidden&quot;,input.setAttribute(&quot;type&quot;,&quot;file&quot;),options.accept&amp;&amp;input.setAttribute(&quot;accept&quot;,options.accept),options.multiple&amp;&amp;input.setAttribute(&quot;multiple&quot;,&quot;&quot;),document.body.appendChild(input),input.addEventListener(&quot;change&quot;,function()&#123;document.body.removeChild(input),resolve(input.files)&#125;),input.click()&#125;)&#125;&#125;),ordinal=createCommonjsModule(function(module,exports)&#123;module.exports=function(num)&#123;var j=num%10,k=num%100;return num+(3==j&amp;&amp;13!=k?&quot;rd&quot;:2==j&amp;&amp;12!=k?&quot;nd&quot;:1==j&amp;&amp;11!=k?&quot;st&quot;:&quot;th&quot;)&#125;&#125;),orientation=createCommonjsModule(function(module,exports)&#123;var screen=window.screen;exports=&#123;get:function()&#123;if(screen)&#123;var orientation=safeGet(screen,&quot;orientation.type&quot;);if(orientation)return orientation.split(&quot;-&quot;).shift()&#125;return window.innerWidth&gt;window.innerHeight?&quot;landscape&quot;:&quot;portrait&quot;&#125;&#125;,Emitter.mixin(exports),window.addEventListener(&quot;orientationchange&quot;,function()&#123;setTimeout(function()&#123;exports.emit(&quot;change&quot;,exports.get())&#125;,200)&#125;,!1),module.exports=exports&#125;),pad=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,len,chars)&#123;var strLen=(str=toStr(str)).length;return chars=chars||&quot; &quot;,str=strLen&lt;len?(str=(chars=repeat(chars,Math.ceil((len-strLen)/2)))+str+chars).substr(Math.ceil((str.length-len)/2),len):str&#125;&#125;),pairs=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;for(var _keys=keys(obj),len=_keys.length,ret=Array(len),i=0;i&lt;len;i++)ret[i]=[_keys[i],obj[_keys[i]]];return ret&#125;&#125;),parallel=createCommonjsModule(function(module,exports)&#123;module.exports=function(tasks,cb)&#123;cb=cb||noop;var results=[],pending=tasks.length;if(!pending)return done(null);function done(err)&#123;nextTick(function()&#123;cb(err,results),cb=noop&#125;)&#125;each(tasks,function(task,i)&#123;task(function(err,result)&#123;!function(i,err,result)&#123;results[i]=result,0!=--pending&amp;&amp;!err||done(err)&#125;(i,err,result)&#125;)&#125;)&#125;&#125;),parseArgs=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;names:&#123;&#125;,shorthands:&#123;&#125;&#125;,regDoubleDash=/^--(.+)/,regSingleDash=/^-([^-]+)/,regDashStart=/^-/;module.exports=function(args,opts)&#123;defaults(opts=opts||&#123;&#125;,defOpts);for(var type,names=opts.names,shorthands=invert(opts.shorthands),remain=[],ret=&#123;remain:remain&#125;,i=0,len=args.length;i&lt;len;i++)&#123;var arg=args[i],nextArg=args[i+1],match=arg.match(regDoubleDash);if(match)name=match[1],(type=names[name])?nextArg&amp;&amp;!regDashStart.test(nextArg)?(setArg(name,nextArg),i++):&quot;boolean&quot;===type&amp;&amp;(setArg(name,!0),i++):remain.push(arg);else if(match=arg.match(regSingleDash))for(var letters=match[1],j=0;j&lt;letters.length;j++)&#123;var name,letter=letters[j];(name=shorthands[letter])&amp;&amp;&quot;boolean&quot;===(type=names[name])&amp;&amp;setArg(shorthands[letter],!0)&#125;else remain.push(arg)&#125;function setArg(name,val)&#123;switch(names[name])&#123;case&quot;number&quot;:val=toNum(val);break;case&quot;boolean&quot;:val=toBool(val)&#125;ret[name]=val&#125;return ret&#125;&#125;),pascalCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return upperFirst(camelCase(str))&#125;&#125;),prefetch=createCommonjsModule(function(module,exports)&#123;var link=document.createElement(&quot;link&quot;),link=(link.relList||&#123;&#125;).supports&amp;&amp;link.relList.supports(&quot;prefetch&quot;);module.exports=link?function(url)&#123;return new Promise(function(resolve,reject)&#123;var link=document.createElement(&quot;link&quot;);link.rel=&quot;prefetch&quot;,link.href=url,link.onload=resolve,link.onerror=reject,document.head.appendChild(link)&#125;)&#125;:function(url)&#123;return new Promise(function(resolve,reject)&#123;var req=new XMLHttpRequest;req.open(&quot;GET&quot;,url,req.withCredentials=!0),req.onload=function()&#123;(200===req.status?resolve:reject)()&#125;,req.send()&#125;)&#125;&#125;),promisify=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,multiArgs)&#123;return restArgs(function(args)&#123;return new root.Promise(function(resolve,reject)&#123;args.push(restArgs(function(err,values)&#123;return err?reject(err):multiArgs?void resolve(values):resolve(values[0])&#125;)),fn.apply(this,args)&#125;)&#125;)&#125;&#125;),quickSort_1=createCommonjsModule(function(module,exports)&#123;function partition(arr,left,right,cmp)&#123;for(var pivot=arr[floor((right+left)/2)];left&lt;=right;)&#123;for(;cmp(arr[left],pivot)&lt;0;)left++;for(;0&lt;cmp(arr[right],pivot);)right--;left&lt;=right&amp;&amp;(swap(arr,left,right),left++,right--)&#125;return left&#125;var floor=Math.floor;module.exports=function(arr)&#123;var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator;return function quickSort(arr,left,right,cmp)&#123;if(arr.length&lt;=1)return arr;var idx=partition(arr,left,right,cmp);left&lt;idx-1&amp;&amp;quickSort(arr,left,idx-1,cmp);idx&lt;right&amp;&amp;quickSort(arr,idx,right,cmp);return arr&#125;(arr,0,arr.length-1,cmp)&#125;&#125;),random=createCommonjsModule(function(module,exports)&#123;module.exports=function(min,max,floating)&#123;null==max&amp;&amp;(max=min,min=0);var rand=Math.random();return floating||min%1||max%1?Math.min(min+rand*(max-min+parseFloat(&quot;1e-&quot;+((rand+&quot;&quot;).length-1))),max):min+Math.floor(rand*(max-min+1))&#125;&#125;),randomBytes=createCommonjsModule(function(module,exports)&#123;var crypto;exports=function(size)&#123;for(var ret=new Uint8Array(size),i=0;i&lt;size;i++)ret[i]=random(0,255);return ret&#125;,isBrowser?(crypto=window.crypto||window.msCrypto,crypto&amp;&amp;(exports=function(size)&#123;size=new Uint8Array(size);return crypto.getRandomValues(size),size&#125;)):isNode&amp;&amp;(crypto=eval(&quot;require&quot;)(&quot;crypto&quot;),exports=function(size)&#123;return crypto.randomBytes(size)&#125;),module.exports=exports&#125;),seedRandom=createCommonjsModule(function(module,exports)&#123;module.exports=function(seed)&#123;var min=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:0,max=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:1,floating=!(3&lt;arguments.length&amp;&amp;void 0!==arguments[3])||arguments[3];return function()&#123;var rnd=min+(seed=(9301*seed+49297)%233280)/233280*(max-min);return floating?rnd:Math.floor(rnd)&#125;&#125;&#125;),randomColor=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;count:1,format:&quot;hex&quot;&#125;;module.exports=exports=function()&#123;var options=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:&#123;&#125;,count=(defaults(options,defOpts),options.count),randomH=options.randomH,randomL=options.randomL,randomS=options.randomS;if(isFn(randomH)||(seed=options.seed||random(0,1e5),randomH=seedRandom(seed,0,360,!1),randomL=seedRandom(seed+1,0,1),randomS=seedRandom(seed+2,0,1)),1&lt;count)&#123;for(var colors=[],i=0;i&lt;count;i++)colors.push(exports(defaults(&#123;count:1,randomH:randomH,randomL:randomL,randomS:randomS&#125;,options)));return colors&#125;var seed=options.hue||randomH(),lightness=options.lightness||randomL().toFixed(2),saturation=options.saturation||randomS().toFixed(2),color=new Color(&#123;val:[seed,Math.round(100*saturation),Math.round(100*lightness)],model:&quot;hsl&quot;&#125;);switch(options.format)&#123;case&quot;hsl&quot;:return color.toHsl();case&quot;rgb&quot;:return color.toRgb();default:return color.toHex()&#125;&#125;&#125;),randomId=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var size=0&lt;arguments.length&amp;&amp;void 0!==arguments[0]?arguments[0]:21,symbols=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&quot;ModuleSymbhasOwnPr-0123456789ABCDEFGHIJKLNQRTUVWXYZ_cfgijkpqtvxz&quot;,id=&quot;&quot;,len=symbols.length,bytes=randomBytes(21);0&lt;size--;)id+=symbols[bytes[size]%len];return id&#125;&#125;),randomItem=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;return arr[random(0,arr.length-1)]&#125;&#125;),range=createCommonjsModule(function(module,exports)&#123;module.exports=function(start,end,step)&#123;null==end&amp;&amp;(end=start||0,start=0),step=step||(end&lt;start?-1:1);for(var len=Math.max(Math.ceil((end-start)/step),0),ret=Array(len),i=0;i&lt;len;i++,start+=step)ret[i]=start;return ret&#125;&#125;),rc4_1=createCommonjsModule(function(module,exports)&#123;function rc4(key,str,decrypt)&#123;key=strToBytes(key),str=decrypt?base64.decode(str):strToBytes(str);for(var x,result=[],s=[],j=0,i=0,i=0;i&lt;256;i++)s[i]=i;for(i=0;i&lt;256;i++)j=(j+s[i]+key[i%key.length])%256,x=s[i],s[i]=s[j],s[j]=x;for(var j=i=0,y=0,len=str.length;y&lt;len;y++)j=(j+s[i=(i+1)%256])%256,x=s[i],s[i]=s[j],s[j]=x,result.push(str[y]^s[(s[i]+s[j])%256]);return decrypt?bytesToStr(result):base64.encode(result)&#125;module.exports=&#123;encrypt:function(key,str)&#123;return rc4(key,str,!1)&#125;,decrypt:function(key,str)&#123;return rc4(key,str,!0)&#125;&#125;&#125;),ready=createCommonjsModule(function(module,exports)&#123;var listener,fns=[],doc=document,hack=doc.documentElement.doScroll,loaded=(hack?/^loaded|^c/:/^loaded|^i|^c/).test(doc.readyState);loaded||doc.addEventListener(&quot;DOMContentLoaded&quot;,listener=function()&#123;for(doc.removeEventListener(&quot;DOMContentLoaded&quot;,listener),loaded=1;listener=fns.shift();)listener()&#125;),module.exports=function(fn)&#123;loaded?setTimeout(fn,0):fns.push(fn)&#125;&#125;),reduceRight=createCommonjsModule(function(module,exports)&#123;exports=reduce.create(-1),module.exports=exports&#125;),reject=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,predicate,ctx)&#123;return predicate=safeCb(negate(predicate),ctx),filter(obj,predicate)&#125;&#125;),replaceAll=createCommonjsModule(function(module,exports)&#123;module.exports=function(str,substr,newSubstr)&#123;return str.replace(new RegExp(escapeRegExp(substr),&quot;g&quot;),newSubstr)&#125;&#125;),ric=createCommonjsModule(function(module,exports)&#123;(exports=root.requestIdleCallback||function(cb)&#123;var start=now();return setTimeout(function()&#123;cb(&#123;didTimeout:!1,timeRemaining:function()&#123;return Math.max(0,50-(now()-start))&#125;&#125;)&#125;,1)&#125;).cancel=root.cancelIdleCallback||function(id)&#123;clearTimeout(id)&#125;,module.exports=exports&#125;),ric_1=ric.cancel,rmCookie=createCommonjsModule(function(module,exports)&#123;module.exports=function(key)&#123;var path,location=window.location,hostname=location.hostname,location=location.pathname,hostNames=hostname.split(&quot;.&quot;),pathNames=location.split(&quot;/&quot;),domain=&quot;&quot;,pathLen=pathNames.length;if(!del())for(var i=hostNames.length-1;0&lt;=i;i--)&#123;var hostName=hostNames[i];if(&quot;&quot;!==hostName)&#123;if(del(&#123;domain:domain=&quot;&quot;===domain?hostName:hostName+&quot;.&quot;+domain,path:path=&quot;/&quot;&#125;)||del(&#123;domain:domain&#125;))return;for(var j=0;j&lt;pathLen;j++)&#123;var pathName=pathNames[j];if(&quot;&quot;!==pathName)&#123;if(del(&#123;domain:domain,path:path+=pathName&#125;)||del(&#123;path:path&#125;))return;if(del(&#123;domain:domain,path:path+=&quot;/&quot;&#125;)||del(&#123;path:path&#125;))return&#125;&#125;&#125;&#125;function del(options)&#123;return cookie.remove(key,options=options||&#123;&#125;),!cookie.get(key)&#125;&#125;&#125;),sameOrigin=createCommonjsModule(function(module,exports)&#123;module.exports=function(url1,url2)&#123;return url1=new Url(url1),url2=new Url(url2),url1.port=0|url1.port||(&quot;https&quot;===url1.protocol?443:80),url2.port=0|url2.port||(&quot;https&quot;===url2.protocol?443:80),url1.protocol===url2.protocol&amp;&amp;url1.hostname===url2.hostname&amp;&amp;url1.port===url2.port&#125;&#125;),sample=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,n)&#123;for(var sample=(isArrLike(obj)?clone:values)(obj),obj=sample.length,last=(n=Math.max(Math.min(n,obj),0),obj-1),i=0;i&lt;n;i++)&#123;var rand=random(i,last);swap(sample,i,rand)&#125;return sample.slice(0,n)&#125;&#125;),scrollTo=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;tolerance:0,duration:800,easing:&quot;outQuart&quot;,callback:noop&#125;;module.exports=function(target,options)&#123;defaults(options=options||&#123;&#125;,defOpts),isNum(target)||(target=$offset(target).top),new Tween(&#123;y:window.pageYOffset&#125;).on(&quot;update&quot;,function(target)&#123;window.scroll(0,target.y)&#125;).on(&quot;end&quot;,function()&#123;options.callback()&#125;).to(&#123;y:target-options.tolerance&#125;,options.duration,options.easing).play()&#125;&#125;),selectionSort=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator,i=0,len=arr.length;i&lt;len;i++)&#123;for(var min=i,j=i+1;j&lt;len;j++)cmp(arr[j],arr[min])&lt;0&amp;&amp;(min=j);i!=min&amp;&amp;swap(arr,i,min)&#125;return arr&#125;&#125;),shebang=createCommonjsModule(function(module,exports)&#123;var regShebang=/^#!(.*)/;module.exports=function(str)&#123;str=str.match(regShebang);if(str)return trim(str[1])&#125;&#125;),shellSort=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var cmp=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:isSorted.defComparator,len=arr.length,gap=Math.floor(len/2);0&lt;gap;)&#123;for(var i=gap;i&lt;=len-gap;i++)for(var j=i;0&lt;j&amp;&amp;cmp(arr[j],arr[j-gap])&lt;0;j-=gap)swap(arr,j,j-gap);gap=Math.floor(gap/2)&#125;return arr&#125;&#125;),shuffle=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj)&#123;return sample(obj,1/0)&#125;&#125;),sizeof_1=createCommonjsModule(function(module,exports)&#123;var strSize=2,boolSize=4,numSize=8;module.exports=function(obj)&#123;return function sizeof(obj,_ref)&#123;var values=_ref.values;_ref=typeof obj;if(&quot;string&quot;==_ref)return obj.length*strSize;if(&quot;number&quot;==_ref)return numSize;if(&quot;boolean&quot;==_ref)return boolSize;var size=0;if(&quot;object&quot;==_ref&amp;&amp;!isNull(obj))&#123;if(-1&lt;values.indexOf(obj))return 0;if(values.push(obj),isArr(obj))for(var i=0,len=obj.length;i&lt;len;i++)size+=sizeof(obj[i],&#123;values:values&#125;);else for(var _keys=keys(obj),_i=0,_len=_keys.length;_i&lt;_len;_i++)&#123;var key=_keys[_i];size=(size+=key.length*strSize)+sizeof(obj[key],&#123;values:values&#125;)&#125;&#125;if(isBuffer(obj))return obj.length;return size&#125;(obj,&#123;values:[]&#125;)&#125;&#125;),sleep=createCommonjsModule(function(module,exports)&#123;module.exports=function(timeout)&#123;return new Promise(function(resolve)&#123;return setTimeout(resolve,timeout)&#125;)&#125;&#125;),slugify=createCommonjsModule(function(module,exports)&#123;exports=function(str)&#123;var replacement=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;;return defaults(replacement,defReplacement),reduce(str,function(result,char)&#123;return result+(replacement[char]||char)&#125;,&quot;&quot;).replace(regForbidden,&quot;&quot;)&#125;;var regForbidden=/[^\\w\\s$*_+~.()&apos;&quot;!\\-:@]/g,defReplacement=&#123;&#125;;each(&quot;$ dollar,% percent,&amp; and,&lt; less,&gt; greater,| or,¢ cent,£ pound,¤ currency,¥ yen,© (c),ª a,® (r),º o,À A,Á A,Â A,Ã A,Ä A,Å A,Æ AE,Ç C,È E,É E,Ê E,Ë E,Ì I,Í I,Î I,Ï I,Ð D,Ñ N,Ò O,Ó O,Ô O,Õ O,Ö O,Ø O,Ù U,Ú U,Û U,Ü U,Ý Y,Þ TH,ß ss,à a,á a,â a,ã a,ä a,å a,æ ae,ç c,è e,é e,ê e,ë e,ì i,í i,î i,ï i,ð d,ñ n,ò o,ó o,ô o,õ o,ö o,ø o,ù u,ú u,û u,ü u,ý y,þ th,ÿ y,Ā A,ā a,Ă A,ă a,Ą A,ą a,Ć C,ć c,Č C,č c,Ď D,ď d,Đ DJ,đ dj,Ē E,ē e,Ė E,ė e,Ę e,ę e,Ě E,ě e,Ğ G,ğ g,Ģ G,ģ g,Ĩ I,ĩ i,Ī i,ī i,Į I,į i,İ I,ı i,Ķ k,ķ k,Ļ L,ļ l,Ľ L,ľ l,Ł L,ł l,Ń N,ń n,Ņ N,ņ n,Ň N,ň n,Ő O,ő o,Œ OE,œ oe,Ŕ R,ŕ r,Ř R,ř r,Ś S,ś s,Ş S,ş s,Š S,š s,Ţ T,ţ t,Ť T,ť t,Ũ U,ũ u,Ū u,ū u,Ů U,ů u,Ű U,ű u,Ų U,ų u,Ź Z,ź z,Ż Z,ż z,Ž Z,ž z,ƒ f,Ơ O,ơ o,Ư U,ư u,ǈ LJ,ǉ lj,ǋ NJ,ǌ nj,Ș S,ș s,Ț T,ț t,˚ o,Ά A,Έ E,Ή H,Ί I,Ό O,Ύ Y,Ώ W,ΐ i,Α A,Β B,Γ G,Δ D,Ε E,Ζ Z,Η H,Θ 8,Ι I,Κ K,Λ L,Μ M,Ν N,Ξ 3,Ο O,Π P,Ρ R,Σ S,Τ T,Υ Y,Φ F,Χ X,Ψ PS,Ω W,Ϊ I,Ϋ Y,ά a,έ e,ή h,ί i,ΰ y,α a,β b,γ g,δ d,ε e,ζ z,η h,θ 8,ι i,κ k,λ l,μ m,ν n,ξ 3,ο o,π p,ρ r,ς s,σ s,τ t,υ y,φ f,χ x,ψ ps,ω w,ϊ i,ϋ y,ό o,ύ y,ώ w,Ё Yo,Ђ DJ,Є Ye,І I,Ї Yi,Ј J,Љ LJ,Њ NJ,Ћ C,Џ DZ,А A,Б B,В V,Г G,Д D,Е E,Ж Zh,З Z,И I,Й J,К K,Л L,М M,Н N,О O,П P,Р R,С S,Т T,У U,Ф F,Х H,Ц C,Ч Ch,Ш Sh,Щ Sh,Ъ U,Ы Y,Ь ,Э E,Ю Yu,Я Ya,а a,б b,в v,г g,д d,е e,ж zh,з z,и i,й j,к k,л l,м m,н n,о o,п p,р r,с s,т t,у u,ф f,х h,ц c,ч ch,ш sh,щ sh,ъ u,ы y,ь ,э e,ю yu,я ya,ё yo,ђ dj,є ye,і i,ї yi,ј j,љ lj,њ nj,ћ c,џ dz,Ґ G,ґ g,฿ baht,ა a,ბ b,გ g,დ d,ე e,ვ v,ზ z,თ t,ი i,კ k,ლ l,მ m,ნ n,ო o,პ p,ჟ zh,რ r,ს s,ტ t,უ u,ფ f,ქ k,ღ gh,ყ q,შ sh,ჩ ch,ც ts,ძ dz,წ ts,ჭ ch,ხ kh,ჯ j,ჰ h,ẞ SS,Ạ A,ạ a,Ả A,ả a,Ấ A,ấ a,Ầ A,ầ a,Ẩ A,ẩ a,Ẫ A,ẫ a,Ậ A,ậ a,Ắ A,ắ a,Ằ A,ằ a,Ẳ A,ẳ a,Ẵ A,ẵ a,Ặ A,ặ a,Ẹ E,ẹ e,Ẻ E,ẻ e,Ẽ E,ẽ e,Ế E,ế e,Ề E,ề e,Ể E,ể e,Ễ E,ễ e,Ệ E,ệ e,Ỉ I,ỉ i,Ị I,ị i,Ọ O,ọ o,Ỏ O,ỏ o,Ố O,ố o,Ồ O,ồ o,Ổ O,ổ o,Ỗ O,ỗ o,Ộ O,ộ o,Ớ O,ớ o,Ờ O,ờ o,Ở O,ở o,Ỡ O,ỡ o,Ợ O,ợ o,Ụ U,ụ u,Ủ U,ủ u,Ứ U,ứ u,Ừ U,ừ u,Ử U,ử u,Ữ U,ữ u,Ự U,ự u,Ỳ Y,ỳ y,Ỵ Y,ỵ y,Ỷ Y,ỷ y,Ỹ Y,ỹ y,‘ &apos;,’ &apos;,“ \\&quot;,” \\&quot;,† +,• *,… ...,₠ ecu,₢ cruzeiro,₣ french franc,₤ lira,₥ mill,₦ naira,₧ peseta,₨ rupee,₩ won,₪ new shequel,₫ dong,€ euro,₭ kip,₮ tugrik,₯ drachma,₰ penny,₱ peso,₲ guarani,₳ austral,₴ hryvnia,₵ cedi,₹ indian rupee,₽ russian ruble,₿ bitcoin,℠ sm,™ tm,∂ d,∆ delta,∑ sum,∞ infinity,♥ love,元 yuan,円 yen,﷼ rial&quot;.split(&quot;,&quot;),function(item)&#123;item=item.split(&quot; &quot;),defReplacement[item[0]]=item[1]&#125;),defReplacement[&quot; &quot;]=&quot;-&quot;,module.exports=exports&#125;),snakeCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return splitCase(str).join(&quot;_&quot;)&#125;&#125;),sortBy=createCommonjsModule(function(module,exports)&#123;module.exports=function(obj,iteratee,ctx)&#123;iteratee=safeCb(iteratee,ctx);var idx=0;return pluck(map(obj,function(val,key)&#123;return&#123;val:val,idx:idx++,criteria:iteratee(val,key,obj)&#125;&#125;).sort(function(left,right)&#123;var a=left.criteria,b=right.criteria;if(a!==b)&#123;if(b&lt;a||isUndef(a))return 1;if(a&lt;b||isUndef(b))return-1&#125;return left.idx-right.idx&#125;),&quot;val&quot;)&#125;&#125;),sortKeys=createCommonjsModule(function(module,exports)&#123;var defOpts=&#123;deep:!(exports=function(obj)&#123;var options=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,deep=(defaults(options,defOpts),options.deep),comparator=options.comparator,visited=[],visitedResult=[];return function sort(obj)&#123;var result,idx=visited.indexOf(obj);if(-1&lt;idx)return visitedResult[idx];if(isArr(obj))&#123;result=[],visited.push(obj),visitedResult.push(result);for(var i=0,len=obj.length;i&lt;len;i++)&#123;var value=obj[i];deep&amp;&amp;isObj(value)?result[i]=sort(value):result[i]=value&#125;&#125;else&#123;result=&#123;&#125;,visited.push(obj),visitedResult.push(result);for(var _keys=keys(obj).sort(comparator),_i=0,_len=_keys.length;_i&lt;_len;_i++)&#123;var key=_keys[_i],_value=obj[key];deep&amp;&amp;isObj(_value)?result[key]=sort(_value):result[key]=_value&#125;&#125;return result&#125;(obj)&#125;),comparator:isSorted.defComparator&#125;;module.exports=exports&#125;),spaceCase=createCommonjsModule(function(module,exports)&#123;module.exports=function(str)&#123;return splitCase(str).join(&quot; &quot;)&#125;&#125;),splitPath=createCommonjsModule(function(module,exports)&#123;var regSplit=/^([\\s\\S]*?)((?:\\.&#123;1,2&#125;|[^\\\\/]+?|)(\\.[^./\\\\]*|))(?:[\\\\/]*)$/;module.exports=function(path)&#123;path=path.match(regSplit);return&#123;dir:path[1],name:path[2],ext:path[3]&#125;&#125;&#125;),stackTrace=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;var orig=Error.prepareStackTrace,stack=(Error.prepareStackTrace=function(_,stack)&#123;return stack&#125;,(new Error).stack.slice(1));return Error.prepareStackTrace=orig,stack&#125;&#125;),stringifyAll=createCommonjsModule(function(module,exports)&#123;function iterateObj(name,keys,obj,options)&#123;var parts=[];return each(keys,function(key)&#123;var val,descriptor=Object.getOwnPropertyDescriptor(obj,key),hasGetter=descriptor&amp;&amp;descriptor.get,hasSetter=descriptor&amp;&amp;descriptor.set;if(!options.accessGetter&amp;&amp;hasGetter)val=&quot;(...)&quot;;else try&#123;if(val=obj[key],contain(options.ignore,val))return;isPromise(val)&amp;&amp;val.catch(function()&#123;&#125;)&#125;catch(e)&#123;val=e.message&#125;parts.push(&quot;&quot;.concat(wrapKey(key),&quot;:&quot;).concat(exports(val,options))),hasGetter&amp;&amp;parts.push(&quot;&quot;.concat(wrapKey(&quot;get &quot;+toStr(key)),&quot;:&quot;).concat(exports(descriptor.get,options))),hasSetter&amp;&amp;parts.push(&quot;&quot;.concat(wrapKey(&quot;set &quot;+toStr(key)),&quot;:&quot;).concat(exports(descriptor.set,options)))&#125;),&apos;&quot;&apos;.concat(name,&apos;&quot;:&#123;&apos;)+parts.join(&quot;,&quot;)+&quot;&#125;&quot;&#125;function wrapKey(key)&#123;return&apos;&quot;&apos;.concat(escapeJsonStr(key),&apos;&quot;&apos;)&#125;function wrapStr(str)&#123;return&apos;&quot;&apos;.concat(escapeJsonStr(toStr(str)),&apos;&quot;&apos;)&#125;function escapeJsonStr(str)&#123;return escapeJsStr(str).replace(/\\\\&apos;/g,&quot;&apos;&quot;).replace(/\\t/g,&quot;\\\\t&quot;)&#125;exports=function(obj)&#123;var _ref=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:&#123;&#125;,self=_ref.self,_ref$startTime=_ref.startTime,_ref$startTime=void 0===_ref$startTime?now():_ref$startTime,_ref$timeout=_ref.timeout,_ref$timeout=void 0===_ref$timeout?0:_ref$timeout,_ref$depth=_ref.depth,_ref$depth=void 0===_ref$depth?0:_ref$depth,_ref$curDepth=_ref.curDepth,_ref$curDepth=void 0===_ref$curDepth?1:_ref$curDepth,_ref$visitor=_ref.visitor,_ref$visitor=void 0===_ref$visitor?new Visitor:_ref$visitor,_ref$unenumerable=_ref.unenumerable,_ref$unenumerable=void 0!==_ref$unenumerable&amp;&amp;_ref$unenumerable,_ref$symbol=_ref.symbol,_ref$symbol=void 0!==_ref$symbol&amp;&amp;_ref$symbol,_ref$accessGetter=_ref.accessGetter,_ref=_ref.ignore,_ref=void 0===_ref?[]:_ref,json=&quot;&quot;,_ref$accessGetter=&#123;visitor:_ref$visitor,unenumerable:_ref$unenumerable,symbol:_ref$symbol,accessGetter:void 0!==_ref$accessGetter&amp;&amp;_ref$accessGetter,depth:_ref$depth,curDepth:_ref$curDepth+1,timeout:_ref$timeout,startTime:_ref$startTime,ignore:_ref&#125;,t=type(obj,!1);if(&quot;String&quot;===t)json=wrapStr(obj);else if(&quot;Number&quot;===t)json=toStr(obj),endWith(json,&quot;Infinity&quot;)&amp;&amp;(json=&apos;&#123;&quot;value&quot;:&quot;&apos;.concat(json,&apos;&quot;,&quot;type&quot;:&quot;Number&quot;&#125;&apos;));else if(&quot;NaN&quot;===t)json=&apos;&#123;&quot;value&quot;:&quot;NaN&quot;,&quot;type&quot;:&quot;Number&quot;&#125;&apos;;else if(&quot;Boolean&quot;===t)json=obj?&quot;true&quot;:&quot;false&quot;;else if(&quot;Null&quot;===t)json=&quot;null&quot;;else if(&quot;Undefined&quot;===t)json=&apos;&#123;&quot;type&quot;:&quot;Undefined&quot;&#125;&apos;;else if(&quot;Symbol&quot;===t)&#123;var val=&quot;Symbol&quot;;try&#123;val=toStr(obj)&#125;catch(e)&#123;&#125;json=&apos;&#123;&quot;value&quot;:&apos;.concat(wrapStr(val),&apos;,&quot;type&quot;:&quot;Symbol&quot;&#125;&apos;)&#125;else&#123;if(_ref$timeout&amp;&amp;now()-_ref$startTime&gt;_ref$timeout)return wrapStr(&quot;Timeout&quot;);if(_ref$depth&amp;&amp;_ref$depth&lt;_ref$curDepth)return wrapStr(&quot;&#123;...&#125;&quot;);var id,json=&quot;&#123;&quot;,val=[],_ref$startTime=_ref$visitor.get(obj);_ref$startTime?(id=_ref$startTime.id,val.push(&apos;&quot;reference&quot;:&apos;.concat(id))):(id=_ref$visitor.set(obj),val.push(&apos;&quot;id&quot;:&apos;.concat(id))),val.push(&apos;&quot;type&quot;:&quot;&apos;.concat(t,&apos;&quot;&apos;)),endWith(t,&quot;Function&quot;)?val.push(&apos;&quot;value&quot;:&apos;.concat(wrapStr(toSrc(obj)))):&quot;RegExp&quot;===t&amp;&amp;val.push(&apos;&quot;value&quot;:&apos;.concat(wrapStr(obj))),_ref$startTime||((_ref$timeout=keys(obj)).length&amp;&amp;val.push(iterateObj(&quot;enumerable&quot;,_ref$timeout,self||obj,_ref$accessGetter)),!_ref$unenumerable||(_ref$depth=difference(allKeys(obj,&#123;prototype:!1,unenumerable:!0&#125;),_ref$timeout)).length&amp;&amp;val.push(iterateObj(&quot;unenumerable&quot;,_ref$depth,self||obj,_ref$accessGetter)),!_ref$symbol||(_ref$curDepth=filter(allKeys(obj,&#123;prototype:!1,symbol:!0&#125;),function(key)&#123;return&quot;symbol&quot;==typeof key&#125;)).length&amp;&amp;val.push(iterateObj(&quot;symbol&quot;,_ref$curDepth,self||obj,_ref$accessGetter)),(_ref$visitor=getProto(obj))&amp;&amp;!contain(_ref,_ref$visitor)&amp;&amp;(id=&apos;&quot;proto&quot;:&apos;.concat(exports(_ref$visitor,extend(_ref$accessGetter,&#123;self:self||obj&#125;))),val.push(id))),json+=val.join(&quot;,&quot;)+&quot;&#125;&quot;&#125;return json&#125;;var Visitor=Class(&#123;initialize:function()&#123;this.id=1,this.visited=[]&#125;,set:function(val)&#123;var visited=this.visited,id=this.id;return visited.push(&#123;id:id,val:val&#125;),this.id++,id&#125;,get:function(val)&#123;for(var visited=this.visited,i=0,len=visited.length;i&lt;len;i++)&#123;var obj=visited[i];if(val===obj.val)return obj&#125;return!1&#125;&#125;);function retTimeout()&#123;return&quot;Timeout&quot;&#125;function strToRegExp(str)&#123;var lastSlash=str.lastIndexOf(&quot;/&quot;);return new RegExp(str.slice(1,lastSlash),str.slice(lastSlash+1))&#125;exports.parse=function(str)&#123;var map=&#123;&#125;,str=function parse(obj,options)&#123;var map=options.map;if(!isObj(obj))return obj;var id=obj.id,type=obj.type,value=obj.value,proto=obj.proto,reference=obj.reference;var enumerable=obj.enumerable,unenumerable=obj.unenumerable;if(reference)return obj;&#123;if(&quot;Number&quot;===type)return&quot;Infinity&quot;===value?Number.POSITIVE_INFINITY:&quot;-Infinity&quot;===value?Number.NEGATIVE_INFINITY:NaN;if(&quot;Undefined&quot;===type)return&#125;var newObj;&quot;Function&quot;===type?((newObj=function()&#123;&#125;).toString=function()&#123;return value&#125;,proto&amp;&amp;Object.setPrototypeOf(newObj,parse(proto,options))):newObj=&quot;RegExp&quot;===type?strToRegExp(value):&quot;Object&quot;!==type?(reference=isMiniProgram?function()&#123;&#125;:new Function(type,&quot;&quot;),proto&amp;&amp;(reference.prototype=parse(proto,options)),new reference):create(proto?parse(proto,options):null);var defineProps=&#123;&#125;;&#123;var len;enumerable&amp;&amp;(isArrLike(enumerable)&amp;&amp;(len=enumerable.length,delete enumerable.length),enumerable=pick(enumerable,function(value,key)&#123;return!handleGetterSetter(enumerable,value,key)&#125;),each(enumerable,function(value,key)&#123;var defineProp=defineProps[key]||&#123;&#125;;defineProp.get||(newObj[key]=parse(value,options))&#125;),len&amp;&amp;(newObj.length=len))&#125;unenumerable&amp;&amp;(unenumerable=pick(unenumerable,function(value,key)&#123;return!handleGetterSetter(unenumerable,value,key)&#125;),each(unenumerable,function(value,key)&#123;var _reference,defineProp=defineProps[key]||&#123;&#125;;defineProp.get||(value=parse(value,options),isObj(value)&amp;&amp;value.reference?(_reference=value.reference,value=function()&#123;return map[_reference]&#125;,defineProp.get=value):defineProp.value=value),defineProp.enumerable=!1,defineProps[key]=defineProp&#125;));defineProp_1(newObj,defineProps);function handleGetterSetter(obj,val,key)&#123;key=toStr(key);var isGetterAndSetter=!1;return each([&quot;get&quot;,&quot;set&quot;],function(type)&#123;var realKey;startWith(key,type+&quot; &quot;)&amp;&amp;(realKey=key.replace(type+&quot; &quot;,&quot;&quot;),obj[realKey]&amp;&amp;(val=parse(val,options),safeSet(defineProps,[realKey,type],val=&quot;Timeout&quot;===val?retTimeout:val),isGetterAndSetter=!0))&#125;),isGetterAndSetter&#125;map[id]=newObj;return newObj&#125;(JSON.parse(str),&#123;map:map&#125;);return function(map)&#123;each(map,function(obj)&#123;for(var enumerableKeys=keys(obj),i=0,len=enumerableKeys.length;i&lt;len;i++)&#123;var reference,key=enumerableKeys[i];!isObj(obj[key])||(reference=obj[key].reference)&amp;&amp;map[reference]&amp;&amp;(obj[key]=map[reference])&#125;var proto=getProto(obj);proto&amp;&amp;proto.reference&amp;&amp;map[proto.reference]&amp;&amp;Object.setPrototypeOf(obj,map[proto.reference])&#125;)&#125;(map),str&#125;,module.exports=exports&#125;),stringifyAll_1=stringifyAll.parse,stripColor=createCommonjsModule(function(module,exports)&#123;var regColor=/\\x1B\\[([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?[m|K]/g;module.exports=function(str)&#123;return str.replace(regColor,&quot;&quot;)&#125;&#125;),stripHtmlTag=createCommonjsModule(function(module,exports)&#123;var regHtmlTag=/&lt;[^&gt;]*&gt;/g;module.exports=function(str)&#123;return str.replace(regHtmlTag,&quot;&quot;)&#125;&#125;),stripIndent=createCommonjsModule(function(module,exports)&#123;var regStartSpaces=/^(\\s+)\\S+/;module.exports=function(literals)&#123;isStr(literals)&amp;&amp;(literals=toArr(literals));for(var str=&quot;&quot;,_len=arguments.length,placeholders=new Array(1&lt;_len?_len-1:0),_key=1;_key&lt;_len;_key++)placeholders[_key-1]=arguments[_key];for(var i=0,len=literals.length;i&lt;len;i++)str+=literals[i],placeholders[i]&amp;&amp;(str+=placeholders[i]);for(var lines=str.split(&quot;\\n&quot;),indentLens=[],_i=0,_len2=lines.length;_i&lt;_len2;_i++)&#123;var _indent=lines[_i].match(regStartSpaces);_indent&amp;&amp;indentLens.push(_indent[1].length)&#125;var indent=0&lt;indentLens.length?min.apply(null,indentLens):0;return trim(map(lines,function(line)&#123;return&quot; &quot;===line[0]?line.slice(indent):line&#125;).join(&quot;\\n&quot;))&#125;&#125;),stripNum=createCommonjsModule(function(module,exports)&#123;module.exports=function(num)&#123;return parseFloat(num.toPrecision(1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:12))&#125;&#125;),sum=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;for(var arr=arguments,ret=0,i=0,len=arr.length;i&lt;len;i++)ret+=arr[i];return ret&#125;&#125;),throttle=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,wait)&#123;return debounce(fn,wait,!0)&#125;&#125;),timeAgo=createCommonjsModule(function(module,exports)&#123;exports=function(date,now)&#123;isDate(date)||(date=new Date(date)),now=now||new Date;for(var i=0,now=0&lt;(diff=((now=isDate(now)?now:new Date(now))-date)/1e3),diff=Math.abs(diff);diff&gt;=secArr[i]&amp;&amp;i&lt;secArrLen;)diff/=secArr[i],i++;return(0===(i*=2)?9:1)&lt;(diff=toInt(diff))&amp;&amp;(i+=1),function(diff,i,ago)&#123;return exports.i18n[i][ago?0:1].replace(&quot;%s&quot;,diff)&#125;(diff,i,now)&#125;;var secArr=[60,60,24,7,365/7/12,12],secArrLen=secArr.length;exports.i18n=[[&quot;just now&quot;,&quot;right now&quot;],[&quot;%s seconds ago&quot;,&quot;in %s seconds&quot;],[&quot;1 minute ago&quot;,&quot;in 1 minute&quot;],[&quot;%s minutes ago&quot;,&quot;in %s minutes&quot;],[&quot;1 hour ago&quot;,&quot;in 1 hour&quot;],[&quot;%s hours ago&quot;,&quot;in %s hours&quot;],[&quot;1 day ago&quot;,&quot;in 1 day&quot;],[&quot;%s days ago&quot;,&quot;in %s days&quot;],[&quot;1 week ago&quot;,&quot;in 1 week&quot;],[&quot;%s weeks ago&quot;,&quot;in %s weeks&quot;],[&quot;1 month ago&quot;,&quot;in 1 month&quot;],[&quot;%s months ago&quot;,&quot;in %s months&quot;],[&quot;1 year ago&quot;,&quot;in 1 year&quot;],[&quot;%s years ago&quot;,&quot;in %s years&quot;]],module.exports=exports&#125;),timeAgo_1=timeAgo.i18n,timeTaken=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn)&#123;var start=perfNow();return fn(),perfNow()-start&#125;&#125;),times=createCommonjsModule(function(module,exports)&#123;module.exports=function(n,fn,ctx)&#123;var ret=Array(Math.max(0,n));fn=optimizeCb(fn,ctx,1);for(var i=0;i&lt;n;i++)ret[i]=fn(i);return ret&#125;&#125;),toAsync=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn)&#123;if(!isGeneratorFn(fn))throw new TypeError(&quot;Expected a generator function&quot;);return function()&#123;var _this=this,args=toArr(arguments);return new Promise(function(resolve,reject)&#123;var generator=fn.apply(_this,args);function onFulfilled(res)&#123;var ret;try&#123;ret=generator.next(res)&#125;catch(e)&#123;return reject(e)&#125;next(ret)&#125;function onRejected(err)&#123;var ret;try&#123;ret=generator.throw(err)&#125;catch(e)&#123;return reject(e)&#125;next(ret)&#125;function next(ret)&#123;return ret.done?resolve(ret.value):isPromise(ret.value)?ret.value.then(onFulfilled,onRejected):onRejected(new TypeError(&quot;You may only yield a promise, &quot;.concat(toStr(ret.value),&quot; is passed&quot;)))&#125;onFulfilled()&#125;)&#125;&#125;&#125;),topoSort=createCommonjsModule(function(module,exports)&#123;module.exports=function(edges)&#123;return function(nodes,edges)&#123;var cursor=nodes.length,sorted=new Array(cursor),visited=&#123;&#125;,i=cursor;for(;i--;)visited[i]||!function visit(node,i,predecessors)&#123;if(0&lt;=predecessors.indexOf(node))throw new Error(&quot;Cyclic dependency: &quot;+JSON.stringify(node));if(visited[i])return;visited[i]=!0;var outgoing=edges.filter(function(edge)&#123;return edge[0]===node&#125;);if(i=outgoing.length)&#123;var preds=predecessors.concat(node);do&#123;var child=outgoing[--i][1];visit(child,nodes.indexOf(child),preds)&#125;while(i)&#125;sorted[--cursor]=node&#125;(nodes[i],i,[]);return sorted&#125;(function(arr)&#123;for(var ret=[],i=0,len=arr.length;i&lt;len;i++)&#123;var edge=arr[i];ret.indexOf(edge[0])&lt;0&amp;&amp;ret.push(edge[0]),ret.indexOf(edge[1])&lt;0&amp;&amp;ret.push(edge[1])&#125;return ret&#125;(edges),edges)&#125;&#125;),truncate=createCommonjsModule(function(module,exports)&#123;var defOptions=&#123;ellipsis:&quot;...&quot;&#125;;module.exports=function(txt,width)&#123;var options=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:&#123;&#125;,ellipsis=(defaults(options,defOptions),options.ellipsis),options=options.separator;if(txt.length&lt;width)return txt;var end=width-ellipsis.length;if(end&lt;1)return ellipsis;var ret=txt.slice(0,end);return isUndef(options)||txt.indexOf(options,end)===end||-1&lt;(end=ret.lastIndexOf(options))&amp;&amp;(ret=ret.slice(0,end)),ret+ellipsis&#125;&#125;),tryIt=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,cb)&#123;cb=cb||noop;try&#123;cb(null,fn())&#125;catch(e)&#123;return void cb(e)&#125;&#125;&#125;),types=createCommonjsModule(function(module,exports)&#123;module.exports=&#123;&#125;&#125;),uncaught=createCommonjsModule(function(module,exports)&#123;var isOn=!1;function callListeners(err)&#123;isOn&amp;&amp;exports.emit(err)&#125;exports=&#123;start:function()&#123;isOn=!0&#125;,stop:function()&#123;isOn=!1&#125;&#125;,SingleEmitter.mixin(exports),isBrowser?(window.addEventListener(&quot;error&quot;,function(event)&#123;callListeners(event.error)&#125;),window.addEventListener(&quot;unhandledrejection&quot;,function(e)&#123;callListeners(e.reason)&#125;)):(process.on(&quot;uncaughtException&quot;,callListeners),process.on(&quot;unhandledRejection&quot;,callListeners)),module.exports=exports&#125;),_unescape=createCommonjsModule(function(module,exports)&#123;exports=function(str)&#123;return regTest.test(str)?str.replace(regReplace,replaceFn):str&#125;;var map=invert(_escape.map),regSrc=&quot;(?:&quot;+keys(map).join(&quot;|&quot;)+&quot;)&quot;,regTest=new RegExp(regSrc),regReplace=new RegExp(regSrc,&quot;g&quot;);function replaceFn(match)&#123;return map[match]&#125;module.exports=exports&#125;),union=createCommonjsModule(function(module,exports)&#123;exports=restArgs(function(arrays)&#123;return unique(flatten(arrays))&#125;),module.exports=exports&#125;),universalify=createCommonjsModule(function(module,exports)&#123;module.exports=function(fn,type)&#123;var callbackFn,promiseFn;return&quot;callback&quot;===type?promiseFn=promisify(callbackFn=fn):callbackFn=callbackify(promiseFn=fn),function()&#123;for(var _len=arguments.length,args=new Array(_len),_key=0;_key&lt;_len;_key++)args[_key]=arguments[_key];if(!isFn(last(args)))return promiseFn.apply(this,args);callbackFn.apply(this,args)&#125;&#125;&#125;),unzip=createCommonjsModule(function(module,exports)&#123;module.exports=function(arr)&#123;for(var len=max.apply(null,map(arr,function(arr)&#123;return arr.length&#125;)),ret=Array(len),i=0;i&lt;len;i++)ret[i]=pluck(arr,i);return ret&#125;&#125;),use=createCommonjsModule(function(module,exports)&#123;var modules=define_1._modules,requireMarks=&#123;&#125;;module.exports=function(requires,method)&#123;null==method&amp;&amp;(method=requires,requires=[]),requires=map(toArr(requires),function req(name)&#123;if(has(requireMarks,name))return modules[name];var requires=modules[name].requires;var body=modules[name].body;var len=requires.length;for(var i=0;i&lt;len;i++)requires[i]=req(requires[i]);body=body.apply(null,requires);body&amp;&amp;(modules[name]=body);requireMarks[name]=!0;return modules[name]&#125;),method.apply(null,requires)&#125;&#125;),uuid=createCommonjsModule(function(module,exports)&#123;exports=function()&#123;var b=randomBytes(16);return b[6]=15&amp;b[6]|64,b[8]=63&amp;b[8]|128,hexBytes[b[0]]+hexBytes[b[1]]+hexBytes[b[2]]+hexBytes[b[3]]+&quot;-&quot;+hexBytes[b[4]]+hexBytes[b[5]]+&quot;-&quot;+hexBytes[b[6]]+hexBytes[b[7]]+&quot;-&quot;+hexBytes[b[8]]+hexBytes[b[9]]+&quot;-&quot;+hexBytes[b[10]]+hexBytes[b[11]]+hexBytes[b[12]]+hexBytes[b[13]]+hexBytes[b[14]]+hexBytes[b[15]]&#125;;for(var hexBytes=[],i=0;i&lt;256;i++)hexBytes[i]=(i+256).toString(16).substr(1);module.exports=exports&#125;),viewportScale=createCommonjsModule(function(module,exports)&#123;module.exports=function()&#123;if(!(viewport=meta(&quot;viewport&quot;)))return 1;var viewport=map(viewport.split(&quot;,&quot;),function(val)&#123;return trim(val)&#125;),minScale=.25,maxScale=5,initialScale=1,viewport=(each(viewport,function(val)&#123;var key=(val=val.split(&quot;=&quot;))[0];val=val[1],&quot;initial-scale&quot;===key&amp;&amp;(initialScale=+val),&quot;maximum-scale&quot;===key&amp;&amp;(maxScale=+val),&quot;minimum-scale&quot;===key&amp;&amp;(minScale=+val)&#125;),clamp(initialScale,minScale,maxScale));return _isNaN(viewport)?1:viewport&#125;&#125;),vlq=createCommonjsModule(function(module,exports)&#123;exports=&#123;encode:function(arr)&#123;for(var ret=&quot;&quot;,i=0,len=(arr=toArr(arr)).length;i&lt;len;i++)ret+=function(value)&#123;var ret=&quot;&quot;;value=function(value)&#123;return value&lt;0?1+(-value&lt;&lt;1):value&lt;&lt;1&#125;(value);do&#123;var digit=value&amp;VLQ_BASE_MASK&#125;while(0&lt;(value&gt;&gt;&gt;=VLQ_BASE_SHIFT)&amp;&amp;(digit|=VLQ_CONTINUATION_BIT),ret+=intToChar[digit],0&lt;value);return ret&#125;(arr[i]);return ret&#125;,decode:function(str)&#123;for(var ret=[],i=0,len=str.length;i&lt;len;)&#123;var value=0,shift=0;do&#123;var digit=charToInt[str[i++]],continuation=0!=(digit&amp;VLQ_CONTINUATION_BIT)&#125;while(value+=(digit&amp;=VLQ_BASE_MASK)&lt;&lt;shift,shift+=VLQ_BASE_SHIFT,continuation);ret.push(function(value)&#123;var negate=1==(1&amp;value);return value&gt;&gt;=1,negate?-value:value&#125;(value))&#125;return ret&#125;&#125;;for(var charToInt=&#123;&#125;,intToChar=&#123;&#125;,chars=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;,i=0,len=chars.length;i&lt;len;i++)charToInt[chars[i]]=i,intToChar[i]=chars[i];var VLQ_BASE_SHIFT=5,VLQ_BASE=1&lt;&lt;VLQ_BASE_SHIFT,VLQ_BASE_MASK=VLQ_BASE-1,VLQ_CONTINUATION_BIT=VLQ_BASE;module.exports=exports&#125;),waitUntil=createCommonjsModule(function(module,exports)&#123;module.exports=function(condition)&#123;var timeout=1&lt;arguments.length&amp;&amp;void 0!==arguments[1]?arguments[1]:0,interval=2&lt;arguments.length&amp;&amp;void 0!==arguments[2]?arguments[2]:250;return new Promise(function(resolve,reject)&#123;var startTime=now(),pollCondition=function()&#123;new Promise(function(resolve,reject)&#123;try&#123;resolve(condition())&#125;catch(e)&#123;reject(e)&#125;&#125;).then(function(val)&#123;var elapsed=now()-startTime;val?resolve(val):timeout&amp;&amp;timeout&lt;=elapsed?reject(Error(&quot;Wait timed out after &quot;.concat(timeout,&quot; ms&quot;))):setTimeout(pollCondition,interval)&#125;,reject)&#125;;pollCondition()&#125;)&#125;&#125;),waterfall=createCommonjsModule(function(module,exports)&#123;module.exports=function(tasks,cb)&#123;cb=cb||noop;var current=0,taskCb=restArgs(function(err,args)&#123;++current&gt;=tasks.length||err?(args.unshift(err),nextTick(function()&#123;cb.apply(null,args)&#125;)):(args.push(taskCb),tasks[current].apply(null,args))&#125;);tasks.length?tasks[0](taskCb):nextTick(function()&#123;cb()&#125;)&#125;&#125;),wordWrap=createCommonjsModule(function(module,exports)&#123;var regWordBoundary=/(\\S+\\s+)/;module.exports=function(txt,width)&#123;txt=txt.split(&quot;\\n&quot;);return map(txt,function(line)&#123;return function(txt,width)&#123;txt=reduce(txt.split(regWordBoundary),function(chunks,word)&#123;return&quot;&quot;===trim(word)||(word.length&gt;width?chunks=concat(chunks,word.match(new RegExp(&quot;.&#123;1,&quot;.concat(width,&quot;&#125;&quot;),&quot;g&quot;))):chunks.push(word)),chunks&#125;,[]);return reduce(txt,function(lines,chunk)&#123;var lastLine=last(lines);return lastLine.length+chunk.length&gt;width?(&quot;&quot;===trim(lastLine)&amp;&amp;lines.pop(),lines.push(chunk)):lines[lines.length-1]=lastLine+chunk,lines&#125;,[txt.shift()]).join(&quot;\\n&quot;)&#125;(line,width)&#125;).join(&quot;\\n&quot;)&#125;&#125;),workerize=createCommonjsModule(function(module,exports)&#123;function isPromise(val)&#123;return!!val&amp;&amp;(&quot;object&quot;==typeof val||&quot;function&quot;==typeof val)&amp;&amp;&quot;function&quot;==typeof val.then&amp;&amp;&quot;function&quot;==typeof val.catch&#125;module.exports=function(fn)&#123;var promises=&#123;&#125;,fn=[toSrc(isPromise),&quot;onmessage=(&quot;,toSrc(function(fn)&#123;return function(e)&#123;var value,data=e.data,id=data[0],data=data[1];try&#123;isPromise(value=fn.apply(fn,data))?value.then(function(value)&#123;postMessage([id,null,value])&#125;,function(err)&#123;postMessage([id,err.message])&#125;):postMessage([id,null,value])&#125;catch(e)&#123;postMessage([id,e.message])&#125;&#125;&#125;),&quot;)(&quot;+toSrc(fn)+&quot;)&quot;].join(&quot;\\n&quot;),worker=new Worker(createUrl(fn));return worker.onmessage=function(e)&#123;var e=e.data,id=e[0],err=e[1],e=e[2];isStr(err)&amp;&amp;(err=new Error(err)),promises[id](err,e),delete promises[id]&#125;,restArgs(function(args)&#123;var id=uniqId(&quot;workerize&quot;);return new root.Promise(function(resolve,reject)&#123;promises[id]=function(err,value)&#123;if(err)return reject(err);resolve(value)&#125;,worker.postMessage([id,args])&#125;)&#125;)&#125;&#125;),xpath=createCommonjsModule(function(module,exports)&#123;module.exports=function(xpath)&#123;for(var ret=[],nodesSnapshot=document.evaluate(xpath,document,null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null),i=0;i&lt;nodesSnapshot.snapshotLength;i++)ret.push(nodesSnapshot.snapshotItem(i));return ret&#125;&#125;),zip=createCommonjsModule(function(module,exports)&#123;exports=restArgs(unzip),module.exports=exports&#125;),$$1=$,$attr$1=$attr,$class$1=$class,$css$1=$css,$data$1=$data,$event$1=$event,$insert$1=$insert,$offset$1=$offset,$property$1=$property,$remove$1=$remove,$safeEls$1=$safeEls,$show$1=$show,Benchmark$1=Benchmark,Blob$2=Blob$1,BloomFilter$1=BloomFilter,Caseless$1=Caseless,Class$1=Class,Color$1=Color,Delegator$1=Delegator,Dispatcher$1=Dispatcher,Emitter$1=Emitter,Enum$1=Enum,HashTable$1=HashTable,Heap$1=Heap,HeapSnapshot$1=HeapSnapshot,I18n$1=I18n,JsonTransformer$1=JsonTransformer,LinkedList$1=LinkedList,LocalStore$1=LocalStore,Logger$1=Logger,Lru$1=Lru,MediaQuery$1=MediaQuery,MutationObserver$1=MutationObserver,PriorityQueue$1=PriorityQueue,Promise$1=_Promise,PseudoMap$1=PseudoMap,Queue$1=Queue,QuickLru$1=QuickLru,Readiness$1=Readiness,ReduceStore$1=ReduceStore,ResizeSensor$1=ResizeSensor,Select$1=Select,Semaphore$1=Semaphore,SessionStore$1=SessionStore,SingleEmitter$1=SingleEmitter,Socket$1=Socket,Stack$1=Stack,State$1=State,Store$1=Store,Trace$1=Trace,Tracing$1=Tracing,Trie$1=Trie,Tween$1=Tween,Url$1=Url,Validator$1=Validator,Wrr$1=Wrr,abbrev$1=abbrev,after$1=after,ajax$1=ajax,allKeys$1=allKeys,arrToMap$1=arrToMap,atob$1=atob,average$1=average,base64$1=base64,before$1=before,binarySearch$1=binarySearch,bind$1=bind,btoa$1=btoa,bubbleSort$1=bubbleSort,bytesToStr$1=bytesToStr,bytesToWords$1=bytesToWords,callbackify$1=callbackify,camelCase$1=camelCase,capitalize$1=capitalize,castPath$1=castPath,centerAlign$1=centerAlign,char_1$1=char_1,chunk$1=chunk,clamp$1=clamp,className$1=className,cliHelp$1=cliHelp,clone$1=clone,cloneDeep$1=cloneDeep,cmpVersion$1=cmpVersion,combine$1=combine,compact$1=compact,compose$1=compose,compressImg$1=compressImg,concat$1=concat,contain$1=contain,convertBase$1=convertBase,convertBin$1=convertBin,cookie$1=cookie,copy$1=copy,crc1$1=crc1,crc16$1=crc16,crc32$1=crc32,crc8$1=crc8,create$1=create,createAssigner$1=createAssigner,createUrl$1=createUrl,css$1=css,cssPriority$1=cssPriority,cssSupports$1=cssSupports,curry$1=curry,dateFormat$1=dateFormat,debounce$1=debounce,debug$1=debug,deburr$1=deburr,decodeUriComponent$1=decodeUriComponent,defaults$1=defaults,define=define_1,defineProp=defineProp_1,defined$1=defined,delay$1=delay,delegate$1=delegate,deprecate$1=deprecate,detectBrowser$1=detectBrowser,detectMocha$1=detectMocha,detectOs$1=detectOs,difference$1=difference,dotCase$1=dotCase,download$1=download,durationFormat$1=durationFormat,each$1=each,easing$1=easing,emulateTouch$1=emulateTouch,endWith$1=endWith,escape=_escape,escapeJsStr$1=escapeJsStr,escapeRegExp$1=escapeRegExp,evalCss$1=evalCss,evalJs$1=evalJs,every$1=every,extend$1=extend,extendDeep$1=extendDeep,extendOwn$1=extendOwn,extractBlockCmts$1=extractBlockCmts,extractUrls$1=extractUrls,fetch$1=fetch,fibonacci$1=fibonacci,fileSize$1=fileSize,fileType$1=fileType,fill$1=fill,filter$1=filter,find$1=find,findIdx$1=findIdx,findKey$1=findKey,findLastIdx$1=findLastIdx,flatten$1=flatten,fnArgs$1=fnArgs,fnParams$1=fnParams,fnv1a$1=fnv1a,format$1=format,fraction$1=fraction,freeze$1=freeze,freezeDeep$1=freezeDeep,fullscreen$1=fullscreen,fuzzySearch$1=fuzzySearch,gcd$1=gcd,getProto$1=getProto,getUrlParam$1=getUrlParam,golangify$1=golangify,h$1=h,has$1=has,heapSort$1=heapSort,hex$1=hex,highlight$1=highlight,hookFn$1=hookFn,hotkey$1=hotkey,hslToRgb$1=hslToRgb,html$1=html,identity$1=identity,idxOf$1=idxOf,indent$1=indent,inherits$1=inherits,ini$1=ini,insertionSort$1=insertionSort,intersect$1=intersect,intersectRange$1=intersectRange,invariant$1=invariant,invert$1=invert,isAbsoluteUrl$1=isAbsoluteUrl,isArgs$1=isArgs,isArr$1=isArr,isArrBuffer$1=isArrBuffer,isArrLike$1=isArrLike,isAsyncFn$1=isAsyncFn,isBlob$1=isBlob,isBool$1=isBool,isBrowser$1=isBrowser,isBuffer$1=isBuffer,isClose$1=isClose,isCyclic$1=isCyclic,isDarkMode$1=isDarkMode,isDataUrl$1=isDataUrl,isDate$1=isDate,isEl$1=isEl,isEmail$1=isEmail,isEmpty$1=isEmpty,isEqual$1=isEqual,isErr$1=isErr,isEven$1=isEven,isFile$1=isFile,isFinite=_isFinite,isFn$1=isFn,isFullWidth$1=isFullWidth,isGeneratorFn$1=isGeneratorFn,isHidden$1=isHidden,isInt$1=isInt,isIp$1=isIp,isJson$1=isJson,isLeapYear$1=isLeapYear,isMap$1=isMap,isMatch$1=isMatch,isMiniProgram$1=isMiniProgram,isMobile$1=isMobile,isNaN=_isNaN,isNative$1=isNative,isNil$1=isNil,isNode$1=isNode,isNull$1=isNull,isNum$1=isNum,isNumeric$1=isNumeric,isObj$1=isObj,isOdd$1=isOdd,isPlainObj$1=isPlainObj,isPrime$1=isPrime,isPrimitive$1=isPrimitive,isPromise$1=isPromise,isRegExp$1=isRegExp,isRelative$1=isRelative,isRetina$1=isRetina,isSet$1=isSet,isSorted$1=isSorted,isStr$1=isStr,isSymbol$1=isSymbol,isTypedArr$1=isTypedArr,isUndef$1=isUndef,isUrl$1=isUrl,isWeakMap$1=isWeakMap,isWeakSet$1=isWeakSet,jsonClone$1=jsonClone,jsonp$1=jsonp,kebabCase$1=kebabCase,keyCode$1=keyCode,keys$1=keys,last$1=last,levenshtein$1=levenshtein,linkify$1=linkify,loadCss$1=loadCss,loadImg$1=loadImg,loadJs$1=loadJs,longest$1=longest,lowerCase$1=lowerCase,lpad$1=lpad,ltrim$1=ltrim,map$1=map,mapObj$1=mapObj,matcher$1=matcher,max$1=max,md5$1=md5,memStorage$1=memStorage,memoize$1=memoize,mergeArr$1=mergeArr,mergeSort$1=mergeSort,meta$1=meta,methods$1=methods,mime$1=mime,min$1=min,moment$1=moment,morphDom$1=morphDom,morse$1=morse,ms$1=ms,naturalSort$1=naturalSort,negate$1=negate,nextTick$1=nextTick,noop$1=noop,normalizeHeader$1=normalizeHeader,normalizePath$1=normalizePath,normalizePhone$1=normalizePhone,notify$1=notify,now$1=now,objToStr$1=objToStr,omit$1=omit,once$1=once,openFile$1=openFile,optimizeCb$1=optimizeCb,ordinal$1=ordinal,orientation$1=orientation,pad$1=pad,pairs$1=pairs,parallel$1=parallel,parseArgs$1=parseArgs,parseHtml$1=parseHtml,partial$1=partial,pascalCase$1=pascalCase,perfNow$1=perfNow,pick$1=pick,pluck$1=pluck,precision$1=precision,prefetch$1=prefetch,prefix$1=prefix,promisify$1=promisify,property$1=property,query$1=query,quickSort=quickSort_1,raf=raf_1,random$1=random,randomBytes$1=randomBytes,randomColor$1=randomColor,randomId$1=randomId,randomItem$1=randomItem,range$1=range,rc4=rc4_1,ready$1=ready,reduce$1=reduce,reduceRight$1=reduceRight,reject$1=reject,remove$1=remove,repeat$1=repeat,replaceAll$1=replaceAll,restArgs$1=restArgs,reverse$1=reverse,rgbToHsl$1=rgbToHsl,ric$1=ric,rmCookie$1=rmCookie,root$1=root,rpad$1=rpad,rtrim$1=rtrim,safeCb$1=safeCb,safeDel$1=safeDel,safeGet$1=safeGet,safeSet$1=safeSet,safeStorage$1=safeStorage,sameOrigin$1=sameOrigin,sample$1=sample,scrollTo$1=scrollTo,seedRandom$1=seedRandom,selectionSort$1=selectionSort,selector$1=selector,shebang$1=shebang,shellSort$1=shellSort,shuffle$1=shuffle,size$1=size,sizeof=sizeof_1,sleep$1=sleep,slice$1=slice,slugify$1=slugify,snakeCase$1=snakeCase,some$1=some,sortBy$1=sortBy,sortKeys$1=sortKeys,spaceCase$1=spaceCase,splitCase$1=splitCase,splitPath$1=splitPath,stackTrace$1=stackTrace,startWith$1=startWith,strHash$1=strHash,strToBytes$1=strToBytes,strTpl$1=strTpl,strWidth$1=strWidth,stringify$1=stringify,stringifyAll$1=stringifyAll,stripAnsi$1=stripAnsi,stripCmt$1=stripCmt,stripColor$1=stripColor,stripHtmlTag$1=stripHtmlTag,stripIndent$1=stripIndent,stripNum$1=stripNum,sum$1=sum,swap$1=swap,table$1=table,template$1=template,throttle$1=throttle,timeAgo$1=timeAgo,timeTaken$1=timeTaken,times$1=times,toArr$1=toArr,toAsync$1=toAsync,toBool$1=toBool,toDate$1=toDate,toEl$1=toEl,toInt$1=toInt,toNum$1=toNum,toSrc$1=toSrc,toStr$1=toStr,topoSort$1=topoSort,trigger$1=trigger,trim$1=trim,truncate$1=truncate,tryIt$1=tryIt,type$1=type,types$1=types,ucs2$1=ucs2,uncaught$1=uncaught,unescape=_unescape,union$1=union,uniqId$1=uniqId,unique$1=unique,universalify$1=universalify,unzip$1=unzip,upperCase$1=upperCase,upperFirst$1=upperFirst,use$1=use,utf8$1=utf8,uuid$1=uuid,values$1=values,viewportScale$1=viewportScale,vlq$1=vlq,waitUntil$1=waitUntil,waterfall$1=waterfall,wordWrap$1=wordWrap,wordsToBytes$1=wordsToBytes,workerize$1=workerize,wrap$1=wrap,xpath$1=xpath,zip$1=zip,browser=&#123;$:$$1,$attr:$attr$1,$class:$class$1,$css:$css$1,$data:$data$1,$event:$event$1,$insert:$insert$1,$offset:$offset$1,$property:$property$1,$remove:$remove$1,$safeEls:$safeEls$1,$show:$show$1,Benchmark:Benchmark$1,Blob:Blob$2,BloomFilter:BloomFilter$1,Caseless:Caseless$1,Class:Class$1,Color:Color$1,Delegator:Delegator$1,Dispatcher:Dispatcher$1,Emitter:Emitter$1,Enum:Enum$1,HashTable:HashTable$1,Heap:Heap$1,HeapSnapshot:HeapSnapshot$1,I18n:I18n$1,JsonTransformer:JsonTransformer$1,LinkedList:LinkedList$1,LocalStore:LocalStore$1,Logger:Logger$1,Lru:Lru$1,MediaQuery:MediaQuery$1,MutationObserver:MutationObserver$1,PriorityQueue:PriorityQueue$1,Promise:Promise$1,PseudoMap:PseudoMap$1,Queue:Queue$1,QuickLru:QuickLru$1,Readiness:Readiness$1,ReduceStore:ReduceStore$1,ResizeSensor:ResizeSensor$1,Select:Select$1,Semaphore:Semaphore$1,SessionStore:SessionStore$1,SingleEmitter:SingleEmitter$1,Socket:Socket$1,Stack:Stack$1,State:State$1,Store:Store$1,Trace:Trace$1,Tracing:Tracing$1,Trie:Trie$1,Tween:Tween$1,Url:Url$1,Validator:Validator$1,Wrr:Wrr$1,abbrev:abbrev$1,after:after$1,ajax:ajax$1,allKeys:allKeys$1,arrToMap:arrToMap$1,atob:atob$1,average:average$1,base64:base64$1,before:before$1,binarySearch:binarySearch$1,bind:bind$1,btoa:btoa$1,bubbleSort:bubbleSort$1,bytesToStr:bytesToStr$1,bytesToWords:bytesToWords$1,callbackify:callbackify$1,camelCase:camelCase$1,capitalize:capitalize$1,castPath:castPath$1,centerAlign:centerAlign$1,char:char_1$1,chunk:chunk$1,clamp:clamp$1,className:className$1,cliHelp:cliHelp$1,clone:clone$1,cloneDeep:cloneDeep$1,cmpVersion:cmpVersion$1,combine:combine$1,compact:compact$1,compose:compose$1,compressImg:compressImg$1,concat:concat$1,contain:contain$1,convertBase:convertBase$1,convertBin:convertBin$1,cookie:cookie$1,copy:copy$1,crc1:crc1$1,crc16:crc16$1,crc32:crc32$1,crc8:crc8$1,create:create$1,createAssigner:createAssigner$1,createUrl:createUrl$1,css:css$1,cssPriority:cssPriority$1,cssSupports:cssSupports$1,curry:curry$1,dateFormat:dateFormat$1,debounce:debounce$1,debug:debug$1,deburr:deburr$1,decodeUriComponent:decodeUriComponent$1,defaults:defaults$1,define:define,defineProp:defineProp,defined:defined$1,delay:delay$1,delegate:delegate$1,deprecate:deprecate$1,detectBrowser:detectBrowser$1,detectMocha:detectMocha$1,detectOs:detectOs$1,difference:difference$1,dotCase:dotCase$1,download:download$1,durationFormat:durationFormat$1,each:each$1,easing:easing$1,emulateTouch:emulateTouch$1,endWith:endWith$1,escape:escape,escapeJsStr:escapeJsStr$1,escapeRegExp:escapeRegExp$1,evalCss:evalCss$1,evalJs:evalJs$1,every:every$1,extend:extend$1,extendDeep:extendDeep$1,extendOwn:extendOwn$1,extractBlockCmts:extractBlockCmts$1,extractUrls:extractUrls$1,fetch:fetch$1,fibonacci:fibonacci$1,fileSize:fileSize$1,fileType:fileType$1,fill:fill$1,filter:filter$1,find:find$1,findIdx:findIdx$1,findKey:findKey$1,findLastIdx:findLastIdx$1,flatten:flatten$1,fnArgs:fnArgs$1,fnParams:fnParams$1,fnv1a:fnv1a$1,format:format$1,fraction:fraction$1,freeze:freeze$1,freezeDeep:freezeDeep$1,fullscreen:fullscreen$1,fuzzySearch:fuzzySearch$1,gcd:gcd$1,getProto:getProto$1,getUrlParam:getUrlParam$1,golangify:golangify$1,h:h$1,has:has$1,heapSort:heapSort$1,hex:hex$1,highlight:highlight$1,hookFn:hookFn$1,hotkey:hotkey$1,hslToRgb:hslToRgb$1,html:html$1,identity:identity$1,idxOf:idxOf$1,indent:indent$1,inherits:inherits$1,ini:ini$1,insertionSort:insertionSort$1,intersect:intersect$1,intersectRange:intersectRange$1,invariant:invariant$1,invert:invert$1,isAbsoluteUrl:isAbsoluteUrl$1,isArgs:isArgs$1,isArr:isArr$1,isArrBuffer:isArrBuffer$1,isArrLike:isArrLike$1,isAsyncFn:isAsyncFn$1,isBlob:isBlob$1,isBool:isBool$1,isBrowser:isBrowser$1,isBuffer:isBuffer$1,isClose:isClose$1,isCyclic:isCyclic$1,isDarkMode:isDarkMode$1,isDataUrl:isDataUrl$1,isDate:isDate$1,isEl:isEl$1,isEmail:isEmail$1,isEmpty:isEmpty$1,isEqual:isEqual$1,isErr:isErr$1,isEven:isEven$1,isFile:isFile$1,isFinite:isFinite,isFn:isFn$1,isFullWidth:isFullWidth$1,isGeneratorFn:isGeneratorFn$1,isHidden:isHidden$1,isInt:isInt$1,isIp:isIp$1,isJson:isJson$1,isLeapYear:isLeapYear$1,isMap:isMap$1,isMatch:isMatch$1,isMiniProgram:isMiniProgram$1,isMobile:isMobile$1,isNaN:isNaN,isNative:isNative$1,isNil:isNil$1,isNode:isNode$1,isNull:isNull$1,isNum:isNum$1,isNumeric:isNumeric$1,isObj:isObj$1,isOdd:isOdd$1,isPlainObj:isPlainObj$1,isPrime:isPrime$1,isPrimitive:isPrimitive$1,isPromise:isPromise$1,isRegExp:isRegExp$1,isRelative:isRelative$1,isRetina:isRetina$1,isSet:isSet$1,isSorted:isSorted$1,isStr:isStr$1,isSymbol:isSymbol$1,isTypedArr:isTypedArr$1,isUndef:isUndef$1,isUrl:isUrl$1,isWeakMap:isWeakMap$1,isWeakSet:isWeakSet$1,jsonClone:jsonClone$1,jsonp:jsonp$1,kebabCase:kebabCase$1,keyCode:keyCode$1,keys:keys$1,last:last$1,levenshtein:levenshtein$1,linkify:linkify$1,loadCss:loadCss$1,loadImg:loadImg$1,loadJs:loadJs$1,longest:longest$1,lowerCase:lowerCase$1,lpad:lpad$1,ltrim:ltrim$1,map:map$1,mapObj:mapObj$1,matcher:matcher$1,max:max$1,md5:md5$1,memStorage:memStorage$1,memoize:memoize$1,mergeArr:mergeArr$1,mergeSort:mergeSort$1,meta:meta$1,methods:methods$1,mime:mime$1,min:min$1,moment:moment$1,morphDom:morphDom$1,morse:morse$1,ms:ms$1,naturalSort:naturalSort$1,negate:negate$1,nextTick:nextTick$1,noop:noop$1,normalizeHeader:normalizeHeader$1,normalizePath:normalizePath$1,normalizePhone:normalizePhone$1,notify:notify$1,now:now$1,objToStr:objToStr$1,omit:omit$1,once:once$1,openFile:openFile$1,optimizeCb:optimizeCb$1,ordinal:ordinal$1,orientation:orientation$1,pad:pad$1,pairs:pairs$1,parallel:parallel$1,parseArgs:parseArgs$1,parseHtml:parseHtml$1,partial:partial$1,pascalCase:pascalCase$1,perfNow:perfNow$1,pick:pick$1,pluck:pluck$1,precision:precision$1,prefetch:prefetch$1,prefix:prefix$1,promisify:promisify$1,property:property$1,query:query$1,quickSort:quickSort,raf:raf,random:random$1,randomBytes:randomBytes$1,randomColor:randomColor$1,randomId:randomId$1,randomItem:randomItem$1,range:range$1,rc4:rc4,ready:ready$1,reduce:reduce$1,reduceRight:reduceRight$1,reject:reject$1,remove:remove$1,repeat:repeat$1,replaceAll:replaceAll$1,restArgs:restArgs$1,reverse:reverse$1,rgbToHsl:rgbToHsl$1,ric:ric$1,rmCookie:rmCookie$1,root:root$1,rpad:rpad$1,rtrim:rtrim$1,safeCb:safeCb$1,safeDel:safeDel$1,safeGet:safeGet$1,safeSet:safeSet$1,safeStorage:safeStorage$1,sameOrigin:sameOrigin$1,sample:sample$1,scrollTo:scrollTo$1,seedRandom:seedRandom$1,selectionSort:selectionSort$1,selector:selector$1,shebang:shebang$1,shellSort:shellSort$1,shuffle:shuffle$1,size:size$1,sizeof:sizeof,sleep:sleep$1,slice:slice$1,slugify:slugify$1,snakeCase:snakeCase$1,some:some$1,sortBy:sortBy$1,sortKeys:sortKeys$1,spaceCase:spaceCase$1,splitCase:splitCase$1,splitPath:splitPath$1,stackTrace:stackTrace$1,startWith:startWith$1,strHash:strHash$1,strToBytes:strToBytes$1,strTpl:strTpl$1,strWidth:strWidth$1,stringify:stringify$1,stringifyAll:stringifyAll$1,stripAnsi:stripAnsi$1,stripCmt:stripCmt$1,stripColor:stripColor$1,stripHtmlTag:stripHtmlTag$1,stripIndent:stripIndent$1,stripNum:stripNum$1,sum:sum$1,swap:swap$1,table:table$1,template:template$1,throttle:throttle$1,timeAgo:timeAgo$1,timeTaken:timeTaken$1,times:times$1,toArr:toArr$1,toAsync:toAsync$1,toBool:toBool$1,toDate:toDate$1,toEl:toEl$1,toInt:toInt$1,toNum:toNum$1,toSrc:toSrc$1,toStr:toStr$1,topoSort:topoSort$1,trigger:trigger$1,trim:trim$1,truncate:truncate$1,tryIt:tryIt$1,type:type$1,types:types$1,ucs2:ucs2$1,uncaught:uncaught$1,unescape:unescape,union:union$1,uniqId:uniqId$1,unique:unique$1,universalify:universalify$1,unzip:unzip$1,upperCase:upperCase$1,upperFirst:upperFirst$1,use:use$1,utf8:utf8$1,uuid:uuid$1,values:values$1,viewportScale:viewportScale$1,vlq:vlq$1,waitUntil:waitUntil$1,waterfall:waterfall$1,wordWrap:wordWrap$1,wordsToBytes:wordsToBytes$1,workerize:workerize$1,wrap:wrap$1,xpath:xpath$1,zip:zip$1&#125;,$nux=Object.freeze(&#123;__proto__:null,default:browser,__moduleExports:browser,$:$$1,$attr:$attr$1,$class:$class$1,$css:$css$1,$data:$data$1,$event:$event$1,$insert:$insert$1,$offset:$offset$1,$property:$property$1,$remove:$remove$1,$safeEls:$safeEls$1,$show:$show$1,Benchmark:Benchmark$1,Blob:Blob$2,BloomFilter:BloomFilter$1,Caseless:Caseless$1,Class:Class$1,Color:Color$1,Delegator:Delegator$1,Dispatcher:Dispatcher$1,Emitter:Emitter$1,Enum:Enum$1,HashTable:HashTable$1,Heap:Heap$1,HeapSnapshot:HeapSnapshot$1,I18n:I18n$1,JsonTransformer:JsonTransformer$1,LinkedList:LinkedList$1,LocalStore:LocalStore$1,Logger:Logger$1,Lru:Lru$1,MediaQuery:MediaQuery$1,MutationObserver:MutationObserver$1,PriorityQueue:PriorityQueue$1,Promise:Promise$1,PseudoMap:PseudoMap$1,Queue:Queue$1,QuickLru:QuickLru$1,Readiness:Readiness$1,ReduceStore:ReduceStore$1,ResizeSensor:ResizeSensor$1,Select:Select$1,Semaphore:Semaphore$1,SessionStore:SessionStore$1,SingleEmitter:SingleEmitter$1,Socket:Socket$1,Stack:Stack$1,State:State$1,Store:Store$1,Trace:Trace$1,Tracing:Tracing$1,Trie:Trie$1,Tween:Tween$1,Url:Url$1,Validator:Validator$1,Wrr:Wrr$1,abbrev:abbrev$1,after:after$1,ajax:ajax$1,allKeys:allKeys$1,arrToMap:arrToMap$1,atob:atob$1,average:average$1,base64:base64$1,before:before$1,binarySearch:binarySearch$1,bind:bind$1,btoa:btoa$1,bubbleSort:bubbleSort$1,bytesToStr:bytesToStr$1,bytesToWords:bytesToWords$1,callbackify:callbackify$1,camelCase:camelCase$1,capitalize:capitalize$1,castPath:castPath$1,centerAlign:centerAlign$1,char:char_1$1,chunk:chunk$1,clamp:clamp$1,className:className$1,cliHelp:cliHelp$1,clone:clone$1,cloneDeep:cloneDeep$1,cmpVersion:cmpVersion$1,combine:combine$1,compact:compact$1,compose:compose$1,compressImg:compressImg$1,concat:concat$1,contain:contain$1,convertBase:convertBase$1,convertBin:convertBin$1,cookie:cookie$1,copy:copy$1,crc1:crc1$1,crc16:crc16$1,crc32:crc32$1,crc8:crc8$1,create:create$1,createAssigner:createAssigner$1,createUrl:createUrl$1,css:css$1,cssPriority:cssPriority$1,cssSupports:cssSupports$1,curry:curry$1,dateFormat:dateFormat$1,debounce:debounce$1,debug:debug$1,deburr:deburr$1,decodeUriComponent:decodeUriComponent$1,defaults:defaults$1,define:define,defineProp:defineProp,defined:defined$1,delay:delay$1,delegate:delegate$1,deprecate:deprecate$1,detectBrowser:detectBrowser$1,detectMocha:detectMocha$1,detectOs:detectOs$1,difference:difference$1,dotCase:dotCase$1,download:download$1,durationFormat:durationFormat$1,each:each$1,easing:easing$1,emulateTouch:emulateTouch$1,endWith:endWith$1,escape:escape,escapeJsStr:escapeJsStr$1,escapeRegExp:escapeRegExp$1,evalCss:evalCss$1,evalJs:evalJs$1,every:every$1,extend:extend$1,extendDeep:extendDeep$1,extendOwn:extendOwn$1,extractBlockCmts:extractBlockCmts$1,extractUrls:extractUrls$1,fetch:fetch$1,fibonacci:fibonacci$1,fileSize:fileSize$1,fileType:fileType$1,fill:fill$1,filter:filter$1,find:find$1,findIdx:findIdx$1,findKey:findKey$1,findLastIdx:findLastIdx$1,flatten:flatten$1,fnArgs:fnArgs$1,fnParams:fnParams$1,fnv1a:fnv1a$1,format:format$1,fraction:fraction$1,freeze:freeze$1,freezeDeep:freezeDeep$1,fullscreen:fullscreen$1,fuzzySearch:fuzzySearch$1,gcd:gcd$1,getProto:getProto$1,getUrlParam:getUrlParam$1,golangify:golangify$1,h:h$1,has:has$1,heapSort:heapSort$1,hex:hex$1,highlight:highlight$1,hookFn:hookFn$1,hotkey:hotkey$1,hslToRgb:hslToRgb$1,html:html$1,identity:identity$1,idxOf:idxOf$1,indent:indent$1,inherits:inherits$1,ini:ini$1,insertionSort:insertionSort$1,intersect:intersect$1,intersectRange:intersectRange$1,invariant:invariant$1,invert:invert$1,isAbsoluteUrl:isAbsoluteUrl$1,isArgs:isArgs$1,isArr:isArr$1,isArrBuffer:isArrBuffer$1,isArrLike:isArrLike$1,isAsyncFn:isAsyncFn$1,isBlob:isBlob$1,isBool:isBool$1,isBrowser:isBrowser$1,isBuffer:isBuffer$1,isClose:isClose$1,isCyclic:isCyclic$1,isDarkMode:isDarkMode$1,isDataUrl:isDataUrl$1,isDate:isDate$1,isEl:isEl$1,isEmail:isEmail$1,isEmpty:isEmpty$1,isEqual:isEqual$1,isErr:isErr$1,isEven:isEven$1,isFile:isFile$1,isFinite:isFinite,isFn:isFn$1,isFullWidth:isFullWidth$1,isGeneratorFn:isGeneratorFn$1,isHidden:isHidden$1,isInt:isInt$1,isIp:isIp$1,isJson:isJson$1,isLeapYear:isLeapYear$1,isMap:isMap$1,isMatch:isMatch$1,isMiniProgram:isMiniProgram$1,isMobile:isMobile$1,isNaN:isNaN,isNative:isNative$1,isNil:isNil$1,isNode:isNode$1,isNull:isNull$1,isNum:isNum$1,isNumeric:isNumeric$1,isObj:isObj$1,isOdd:isOdd$1,isPlainObj:isPlainObj$1,isPrime:isPrime$1,isPrimitive:isPrimitive$1,isPromise:isPromise$1,isRegExp:isRegExp$1,isRelative:isRelative$1,isRetina:isRetina$1,isSet:isSet$1,isSorted:isSorted$1,isStr:isStr$1,isSymbol:isSymbol$1,isTypedArr:isTypedArr$1,isUndef:isUndef$1,isUrl:isUrl$1,isWeakMap:isWeakMap$1,isWeakSet:isWeakSet$1,jsonClone:jsonClone$1,jsonp:jsonp$1,kebabCase:kebabCase$1,keyCode:keyCode$1,keys:keys$1,last:last$1,levenshtein:levenshtein$1,linkify:linkify$1,loadCss:loadCss$1,loadImg:loadImg$1,loadJs:loadJs$1,longest:longest$1,lowerCase:lowerCase$1,lpad:lpad$1,ltrim:ltrim$1,map:map$1,mapObj:mapObj$1,matcher:matcher$1,max:max$1,md5:md5$1,memStorage:memStorage$1,memoize:memoize$1,mergeArr:mergeArr$1,mergeSort:mergeSort$1,meta:meta$1,methods:methods$1,mime:mime$1,min:min$1,moment:moment$1,morphDom:morphDom$1,morse:morse$1,ms:ms$1,naturalSort:naturalSort$1,negate:negate$1,nextTick:nextTick$1,noop:noop$1,normalizeHeader:normalizeHeader$1,normalizePath:normalizePath$1,normalizePhone:normalizePhone$1,notify:notify$1,now:now$1,objToStr:objToStr$1,omit:omit$1,once:once$1,openFile:openFile$1,optimizeCb:optimizeCb$1,ordinal:ordinal$1,orientation:orientation$1,pad:pad$1,pairs:pairs$1,parallel:parallel$1,parseArgs:parseArgs$1,parseHtml:parseHtml$1,partial:partial$1,pascalCase:pascalCase$1,perfNow:perfNow$1,pick:pick$1,pluck:pluck$1,precision:precision$1,prefetch:prefetch$1,prefix:prefix$1,promisify:promisify$1,property:property$1,query:query$1,quickSort:quickSort,raf:raf,random:random$1,randomBytes:randomBytes$1,randomColor:randomColor$1,randomId:randomId$1,randomItem:randomItem$1,range:range$1,rc4:rc4,ready:ready$1,reduce:reduce$1,reduceRight:reduceRight$1,reject:reject$1,remove:remove$1,repeat:repeat$1,replaceAll:replaceAll$1,restArgs:restArgs$1,reverse:reverse$1,rgbToHsl:rgbToHsl$1,ric:ric$1,rmCookie:rmCookie$1,root:root$1,rpad:rpad$1,rtrim:rtrim$1,safeCb:safeCb$1,safeDel:safeDel$1,safeGet:safeGet$1,safeSet:safeSet$1,safeStorage:safeStorage$1,sameOrigin:sameOrigin$1,sample:sample$1,scrollTo:scrollTo$1,seedRandom:seedRandom$1,selectionSort:selectionSort$1,selector:selector$1,shebang:shebang$1,shellSort:shellSort$1,shuffle:shuffle$1,size:size$1,sizeof:sizeof,sleep:sleep$1,slice:slice$1,slugify:slugify$1,snakeCase:snakeCase$1,some:some$1,sortBy:sortBy$1,sortKeys:sortKeys$1,spaceCase:spaceCase$1,splitCase:splitCase$1,splitPath:splitPath$1,stackTrace:stackTrace$1,startWith:startWith$1,strHash:strHash$1,strToBytes:strToBytes$1,strTpl:strTpl$1,strWidth:strWidth$1,stringify:stringify$1,stringifyAll:stringifyAll$1,stripAnsi:stripAnsi$1,stripCmt:stripCmt$1,stripColor:stripColor$1,stripHtmlTag:stripHtmlTag$1,stripIndent:stripIndent$1,stripNum:stripNum$1,sum:sum$1,swap:swap$1,table:table$1,template:template$1,throttle:throttle$1,timeAgo:timeAgo$1,timeTaken:timeTaken$1,times:times$1,toArr:toArr$1,toAsync:toAsync$1,toBool:toBool$1,toDate:toDate$1,toEl:toEl$1,toInt:toInt$1,toNum:toNum$1,toSrc:toSrc$1,toStr:toStr$1,topoSort:topoSort$1,trigger:trigger$1,trim:trim$1,truncate:truncate$1,tryIt:tryIt$1,type:type$1,types:types$1,ucs2:ucs2$1,uncaught:uncaught$1,unescape:unescape,union:union$1,uniqId:uniqId$1,unique:unique$1,universalify:universalify$1,unzip:unzip$1,upperCase:upperCase$1,upperFirst:upperFirst$1,use:use$1,utf8:utf8$1,uuid:uuid$1,values:values$1,viewportScale:viewportScale$1,vlq:vlq$1,waitUntil:waitUntil$1,waterfall:waterfall$1,wordWrap:wordWrap$1,wordsToBytes:wordsToBytes$1,workerize:workerize$1,wrap:wrap$1,xpath:xpath$1,zip:zip$1&#125;);export default $nux;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"在浏览器控制台安装js库","slug":"在浏览器控制台安装js库","date":"2021-12-30T02:44:28.000Z","updated":"2024-02-20T07:11:25.725Z","comments":true,"path":"2021/12/30/在浏览器控制台安装js库/","link":"","permalink":"/2021/12/30/在浏览器控制台安装js库/","excerpt":"根据js库名，在浏览器控制台临时安装此js库","text":"根据js库名，在浏览器控制台临时安装此js库 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 存储原始传入的名称let pkg_name_origin = null;const npmInstall = (originName) =&gt; &#123; // Trim string const name = originName.trim(); pkg_name_origin = name; // 三种引入方式 // 如果是一个有效的URL，直接通过&lt;script /&gt;标签插入 if (/^https?:\\/\\//.test(name)) return injectScript(name); // 如果指定了版本，尝试使用unpkg加载 if (name.indexOf(&apos;@&apos;) !== -1) return unpkg(name); // 否则，尝试使用cdnjs搜索 return cdnjs(name);&#125;;// 在页面中插入&lt;script /&gt;标签const injectScript = (url) =&gt; &#123; const script = document.createElement(&apos;script&apos;); script.src = url; script.onload = () =&gt; &#123; console.log(pkg_name_origin, &apos; 安装成功。&apos;); &#125;; script.onerror = () =&gt; &#123; console.log(pkg_name_origin, &apos; 安装失败。&apos;); &#125;; document.body.appendChild(script); // document.body.removeChild(script);&#125;;const unpkg = (name) =&gt; &#123; injectScript(`https://unpkg.com/$&#123;name&#125;`);&#125;;const cdnjs = async (name) =&gt; &#123; const searchPromise = await fetch( `https://api.cdnjs.com/libraries?search=$&#123;name&#125;`, // 不显示referrer的任何信息在请求头中 &#123; referrerPolicy: &apos;no-referrer&apos; &#125; ); const &#123; results, total &#125; = await searchPromise.json(); if (total === 0) &#123; console.error(&apos;Sorry, &apos;, name, &apos; not found, please try another keyword.&apos;); return; &#125; // 取结果中最相关的一条 const &#123; name: exactName, latest: url &#125; = results[0]; if (name !== exactName) &#123; console.log(name, &apos; not found, import &apos;, exactName, &apos; instead.&apos;); &#125; // 通过&lt;script /&gt;标签插入 injectScript(url);&#125;; 使用1234npmInstall(&apos;jquery&apos;);npmInstall(&apos;axios&apos;);npmInstall(&apos;moment.js&apos;);npmInstall(&apos;loadsh.js&apos;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"js屏幕录制","slug":"js屏幕录制","date":"2021-12-13T02:51:36.000Z","updated":"2024-01-11T07:00:59.215Z","comments":true,"path":"2021/12/13/js屏幕录制/","link":"","permalink":"/2021/12/13/js屏幕录制/","excerpt":"javascript屏幕录制","text":"javascript屏幕录制新版本浏览器支持js的屏幕录制功能，用到了navigator.mediaDevices.getDisplayMedia方法和MediaRecorder类。demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;js屏幕录制&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;video class=&quot;video&quot; width=&quot;600px&quot; controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;div&gt; &lt;button class=&quot;record-btn&quot;&gt;record&lt;/button&gt; &lt;button class=&quot;stop-btn&quot; style=&quot;display: none;&quot;&gt;stop&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let mediaRecorder, stream; let btnRecord = document.querySelector(&quot;.record-btn&quot;) let btnStop = document.querySelector(&quot;.stop-btn&quot;) btnRecord.addEventListener(&quot;click&quot;, async function () &#123; btnStop.style.display = &apos;block&apos;; btnRecord.style.display = &apos;none&apos;; stream = await navigator.mediaDevices.getDisplayMedia(&#123; video: true &#125;) // 需要更好的浏览器支持 const mime = MediaRecorder.isTypeSupported(&quot;video/webm; codecs=vp9&quot;) ? &quot;video/webm; codecs=vp9&quot; : &quot;video/webm&quot; mediaRecorder = new MediaRecorder(stream, &#123; mimeType: mime &#125;) let chunks = [] mediaRecorder.addEventListener(&apos;dataavailable&apos;, function(e) &#123; chunks.push(e.data) &#125;) mediaRecorder.addEventListener(&apos;stop&apos;, function()&#123; let blob = new Blob(chunks, &#123; type: chunks[0].type &#125;) let url = URL.createObjectURL(blob) let video = document.querySelector(&quot;video&quot;) video.src = url let a = document.createElement(&apos;a&apos;) a.href = url a.download = &apos;video.webm&apos; a.click() &#125;) // 必须手动启动 mediaRecorder.start() &#125;) btnStop.addEventListener(&apos;click&apos;, function(evt) &#123; btnStop.style.display = &apos;none&apos;; btnRecord.style.display = &apos;block&apos;; // 隐藏记录的图标 stream.getTracks() // get all tracks from the MediaStream .forEach( track =&gt; track.stop() ); // stop each of them mediaRecorder.stop(); &#125;, false);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}]},{"title":"js正则几个知识点总结","slug":"js正则几个知识点总结","date":"2021-11-05T02:18:40.000Z","updated":"2024-01-11T07:00:59.219Z","comments":true,"path":"2021/11/05/js正则几个知识点总结/","link":"","permalink":"/2021/11/05/js正则几个知识点总结/","excerpt":"javascript几个容易忘记知识点总结","text":"javascript几个容易忘记知识点总结 js正则几个知识点总结正则中有几个知识点笔者经常忘记，记录下。 知识点模式匹配的用法(x) 模式匹配主要用来匹配某一类字符串并记住匹配项. 1234let str = &apos;xuxi is xuxi is&apos;let reg = /(xuxi) (is) \\1 \\2/greg.test(str) // true (1)str.replace(reg, &apos;$1 $2&apos;) // xuxi is (2) 解释: 其中括号被称为捕获括号, 模式中的 \\1 和 \\2 表示第一个和第二个被捕获括号匹配的子字符串，即 xuxi 和 is，匹配了原字符串中的后两个单词, 因此(1)中运行的结果为true. 当我们在字符串中使用replace时, 我们可以使用$1, $2这样的方式获取第n个匹配项,并用来替换字符串. 如(2)中的运行结果. 非捕获括号的模式匹配(?:x) 主要用来匹配某一类字符串但不记住匹配项. 123let str = &apos;xuxixuxi&apos;let reg = /(?:xuxi)&#123;1,2&#125;/greg.test(str) // true (1) 解释: 其中(?:)被称为非捕获括号, 我们可以使用它匹配一组字符但是并不记住该字符,一般用来判断某类字符是否存在于某字符串中. 先行断言x(?=y) 先行断言: 匹配’x’仅仅当’x’后面跟着’y’. 123let str = &apos;王者融化&apos;let reg = /王(?=者)/reg.test(str) // true (1) 解释: /王(?=者)/会匹配到”王”仅当它后面跟着”者”.但是”者”不属于匹配结果的一部分. 后行断言(?&lt;=y)x 后行断言: 匹配’x’仅当’x’前面是’y’. 123let str = &apos;xuxiA&apos;let reg = /(?&lt;=xuxi)A/reg.test(str) // true (1) 解释: /(?&lt;=xuxi)A/会匹配到A仅当它前面为xuxi.但是xuxi不属于匹配结果的一部分. 正向否定查找x(?!y) 正向否定查找: 仅仅当’x’后面不跟着’y’时匹配’x’. 123let str = &apos;3.1415&apos;let reg = /\\d+(?!\\.)/reg.exec(str) // [1415] (1) 解释: 其中/\\d+(?!.)/匹配一个或多个数字,当且仅当它后面没有小数点时, 所以(1)中执行后会匹配到1415而不是3.1415 反向否定查找(?&lt;!y)x 反向否定查找: 仅仅当’x’前面不是’y’时匹配’x’. 123let str = &apos;3.1415&apos;let reg = /(?&lt;!\\.)\\d+/reg.exec(str) // [3] (1) 解释: /(?&lt;!.)\\d+/匹配一个数字,当且仅当前面字符不是.时,此时将匹配3. 字符集合和反向字符集合的用法 xyz / ^xyz 12345let str = &apos;abcd&apos;let reg1 = /[a-c]+/let reg2 = /[^d]$/reg1.test(str) // true (1)reg2.test(str) // false (2) 解释: (1)中将返回true因为字符串中包含a-c中的字符, (2)中奖返回false, 因为字符串结尾为d, 但正则reg2需要匹配结尾不为d的字符串. 词边界和非单词边界匹配\\b\\B \\b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。\\B 匹配一个非单词边界。匹配如下几种情况：(1)字符串第一个字符为非“字”字符 (2)字符串最后一个字符为非“字”字符 (3)两个单词字符之间 (4)两个非单词字符之间 (5)空字符串 12345let str = &apos;xuxi&apos;let reg1 = /xi\\b/let reg2 = /xu\\B/reg1.exec(str) // [xi] (1)reg2.exec(str) // [xu] (2) 解释: (1)中匹配到了单词边界,即xi, 为该字符串的末尾.(2)中应为xu为非单词边界,所以会被其匹配到. 空白字符/非空白字符匹配\\s\\S \\s: 匹配一个空白字符，包括空格、制表符、换页符和换行符.\\S: 匹配一个非空白字符 12345let str = &apos;xuxi is&apos;let reg1 = /.*\\s/glet reg2 = /\\S\\w*/greg1.exec(str) // [xuxi ] (1)reg2.exec(str) // [xuxi] (2) 解释: (1)和(2)中执行之后都将匹配xuxi, 一个是空白字符之前的匹配, 一个是非空白字符的匹配. 单字字符/非单字字符匹配\\w/W \\w: 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。\\W: 匹配一个非单字字符。等价于 [^A-Za-z0-9_] 贪婪模式和非贪婪模式 贪婪模式：正则表达式趋向于匹配最大长度。非贪婪模式：正则表达式趋向于匹配最小长度，即一旦匹配到结果就结束。默认是贪婪模式。若 量词 后面添加 问号(?)，则是非贪婪模式。量词 包括以下4种：{m, n}：匹配 m 到 n 个，包含 m、n。{N} –&gt; 匹配N次{M, N} –&gt; 匹配M到N次{M,} –&gt; 匹配至少M次{,N} –&gt; 匹配至多N次*：匹配任意多个，包括0个。+：匹配1到多个。?：0或1个。 123String str = &quot;abcaxc&quot;;Pattern p1 = &quot;ab.*c&quot;; # 贪婪模式，匹配结果是：abcaxcPattern p2 = &quot;ab.*?c&quot;; # 量词*后面添加?，是非贪婪模式，匹配结果：abc 常用案例去除字符串内指定元素的标签1234function trimTag(tagName, htmlStr) &#123; let reg = new RegExp(`&lt;$&#123;tagName&#125;(\\\\s.*)*&gt;(\\\\n|.)*&lt;\\\\/$&#123;tagName&#125;&gt;`, &quot;g&quot;) return htmlStr.replace(reg, &apos;&apos;)&#125; 短横线命名转驼峰命名12345678// 短横线转驼峰命名, flag = 0为小驼峰, 1为大驼峰function toCamelCase(str, flag = 0) &#123; if(flag) &#123; return str[0].toUpperCase() + str.slice(1).replace(/-(\\w)/g, ($0, $1) =&gt; $1.toUpperCase()) &#125;else &#123; return str.replace(/-(\\w)/g, ($0, $1) =&gt; $1.toUpperCase()) &#125;&#125; 去除字符串中的空格符123function trimAll(str) &#123; return str.replace(/\\s*/g,&quot;&quot;)&#125; 判断指定格式的数据输入合法性1234567function numCheck(str, specialNum) &#123; if(str.indexOf(&apos;,&apos;) &gt; -1) &#123; return str.splite(&apos;,&apos;).every(item=&gt;this.numCheck(item)); &#125; else &#123; return str.split(specialNum).length === 2; &#125;&#125; 去除url参数字符串中值为空的字段1234// 去除url参数字符串中值为空的字段const trimParmas = (parmaStr:string = &apos;&apos;) =&gt; &#123; return parmaStr.replace(/((\\w*?)=&amp;|(&amp;\\w*?=)$)/g, &apos;&apos;)&#125; 将浏览器参数字符串转化为参数对象1234567function unParams(params = &apos;?a=1&amp;b=2&amp;c=3&apos;) &#123; let obj = &#123;&#125; params &amp;&amp; params.replace(/((\\w*)=([\\.a-z0-9A-Z]*)?)?/g, (m,a,b,c) =&gt; &#123; if(b || c) obj[b] = c &#125;) return obj&#125; 计算字符串字节数123456789101112131415161718/** * 计算字符串字节数 * @param str * @desc 一个中文占2个字节, 一个英文占一个字节 */function computeStringByte(str) &#123; let size = 0, strArr = str.split(&apos;&apos;), reg = /[\\u4e00-\\u9fa5]/ // 判断是否为中文 for(let i = strArr.length; i--; i&gt;=0) &#123; if(reg.test(strArr[i])) &#123; size+= 2 &#125;else &#123; size += 1 &#125; &#125; return size&#125; 匹配是否包含中文字符1234function hasCn(str) &#123; let reg = /[\\u4e00-\\u9fa5]/g return reg.test(str)&#125; 实现搜索联想功能123456function searchLink(keyword) &#123; // 模拟后端返回数据 let list = [&apos;abc&apos;, &apos;ab&apos;, &apos;a&apos;, &apos;bcd&apos;, &apos;edf&apos;, &apos;abd&apos;]; let reg = new RegExp(keyword, &apos;i&apos;); return list.filter(item =&gt; reg.test(item))&#125; 总结这里内容都比较简单，系统学习请点击这里学习","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"正则","slug":"正则","permalink":"/tags/正则/"}]},{"title":"js加减乘除精度处理","slug":"js加减乘除精度处理","date":"2021-11-02T03:18:38.000Z","updated":"2024-01-11T07:00:59.197Z","comments":true,"path":"2021/11/02/js加减乘除精度处理/","link":"","permalink":"/2021/11/02/js加减乘除精度处理/","excerpt":"js对加减乘除精度不准确的处理函数","text":"js对加减乘除精度不准确的处理函数 js加减乘除精度处理javascript在处理加减乘除的时候是有精度不准确问题的，详情这里查看。日常开发中，如果为了保持精度准确，需要自己封装些方法。 简单的封装加法123456789101112131415161718192021/** ** 加法函数，用来得到精确的加法结果 ** 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 ** 调用：accAdd(arg1,arg2) ** 返回值：arg1加上arg2的精确结果 **/function accAdd(arg1, arg2) &#123; let r1, r2, m try &#123; r1 = arg1.toString().split(&apos;.&apos;)[1].length &#125; catch (e) &#123; r1 = 0 &#125; try &#123; r2 = arg2.toString().split(&apos;.&apos;)[1].length &#125; catch (e) &#123; r2 = 0 &#125; m = Math.pow(10, Math.max(r1, r2)) return (arg1 * m + arg2 * m) / m&#125; 减法12345678910111213141516171819202122/** ** 减法函数，用来得到精确的减法结果 ** 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。 ** 调用：accSub(arg1,arg2) ** 返回值：arg1加上arg2的精确结果 **/function accSub(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(&quot;.&quot;)[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = r1 &gt;= r2 ? r1 : r2; return ((arg1 * m - arg2 * m) / m).toFixed(n);&#125; 乘法12345678910111213141516171819/** ** 乘法函数，用来得到精确的乘法结果 ** 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 ** 调用：accMul(arg1,arg2) ** 返回值：arg1乘以 arg2的精确结果 **/ function accMul(arg1, arg2) &#123; let m = 0 let s1 = arg1.toString() let s2 = arg2.toString() try &#123; m += s1.split(&apos;.&apos;)[1] ? s1.split(&apos;.&apos;)[1].length : &apos;&apos; &#125; catch (e) &#123;&#125; try &#123; m += s2.split(&apos;.&apos;)[1] ? s2.split(&apos;.&apos;)[1].length : &apos;&apos; &#125; catch (e) &#123;&#125; return (Number(s1.replace(&apos;.&apos;, &apos;&apos;)) * Number(s2.replace(&apos;.&apos;, &apos;&apos;))) / Math.pow(10, m)&#125; 除法123456789101112131415161718192021/** ** 除法函数，用来得到精确的除法结果 ** 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 ** 调用：accDiv(arg1,arg2) ** 返回值：arg1除以arg2的精确结果 **/function accDiv(arg1, arg2) &#123; let t1 = 0 let t2 = 0 let r1 let r2 try &#123; t1 = arg1.toString().split(&apos;.&apos;)[1].length &#125; catch (e) &#123;&#125; try &#123; t2 = arg2.toString().split(&apos;.&apos;)[1].length &#125; catch (e) &#123;&#125; r1 = Number(arg1.toString().replace(&apos;.&apos;, &apos;&apos;)) r2 = Number(arg2.toString().replace(&apos;.&apos;, &apos;&apos;)) return (r1 / r2) * Math.pow(10, t2 - t1)&#125; 以上就是加减乘除的精度处理方法，下面列举几个有关数字处理的js库，除了精度以外，还有很多方便的方法。 js中number处理库big.js文档 bignumber.js文档 decimal.js文档 Math.js文档","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"JavaScript实现AOP（面向切面编程）","slug":"JavaScript实现AOP（面向切面编程）","date":"2021-09-23T08:02:55.000Z","updated":"2024-01-11T07:00:59.129Z","comments":true,"path":"2021/09/23/JavaScript实现AOP（面向切面编程）/","link":"","permalink":"/2021/09/23/JavaScript实现AOP（面向切面编程）/","excerpt":"javascript实现切面编程","text":"javascript实现切面编程 JavaScript实现AOP（面向切面编程）什么是AOPAOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。 AOP能给我们带来什么好处AOP的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 JavaScript实现AOP在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，下面我用扩展 Function.prototype 来做到这一点。请看下面代码：1234567891011121314151617181920212223242526272829Function.prototype.before = function (beforefn) &#123; var _self = this; //保存原函数引用 return function () &#123; //返回包含了原函数和新函数的&quot;代理函数&quot; beforefn.apply(this, arguments); //执行新函数，修正this return _self.apply(this, arguments); //执行原函数 &#125;&#125;;Function.prototype.after = function (afterfn) &#123; var _self = this; return function () &#123; var ret = _self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;var func = function () &#123; console.log(&quot;2&quot;)&#125;func = func.before(function () &#123; console.log(&quot;1&quot;);&#125;).after(function () &#123; console.log(&quot;3&quot;);&#125;)func(); 总结实现切面编程的方式很多，这种方式简洁易懂，容易理解。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"webpack-threejs-FontLoader","slug":"webpack-threejs-FontLoader","date":"2021-09-13T03:05:56.000Z","updated":"2024-06-06T06:02:13.862Z","comments":true,"path":"2021/09/13/webpack-threejs-FontLoader/","link":"","permalink":"/2021/09/13/webpack-threejs-FontLoader/","excerpt":"webpack和threejs配合使用的一些小问题","text":"webpack和threejs配合使用的一些小问题 webpack-threejs-FontLoader在webpack的项目中使用threejs，new THREE.FontLoader()这个threejs的字体类，有一个方法load，正常的写法是：1234loader.load( &apos;font/&apos; + fontName + &apos;_&apos; + fontWeight + &apos;.typeface.json&apos;, function ( response ) &#123; font = response; refreshText();&#125;); 可以看出，load这个方法是在js运行时执行的，这时候要载入的json文件的路径就是一个问题。目前有2种方法可以解决。 方法一配置public文件夹，可以使用copy-webpack-plugin这个插件，之后的字体加载路径就是public下font字体的路径了。 方法二利用import将json文件加载，加载后的是一个json对象，再将这个json对象转换成blob对象，再利用URL.createObjectURL(blob)生成一个url的内存。123456789import ziti from &apos;./assets/font/optimer_bold.typeface.json&apos;;const loader = new THREE.FontLoader(); const blob = new Blob([JSON.stringify(ziti)], &#123; type: &apos;application/json&apos; &#125;) loader.load(URL.createObjectURL(blob), function ( response ) &#123; font = response; refreshText(); &#125; );","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"},{"name":"Threejs","slug":"Threejs","permalink":"/tags/Threejs/"}]},{"title":"nodejs-require-cache","slug":"nodejs-require-cache","date":"2021-09-08T02:43:18.000Z","updated":"2024-01-11T07:00:59.225Z","comments":true,"path":"2021/09/08/nodejs-require-cache/","link":"","permalink":"/2021/09/08/nodejs-require-cache/","excerpt":"nodejs中require缓存处理","text":"nodejs中require缓存处理 nodejs-require-cache简述在使用nodejs的require一个模块的时候，这个模块已经被缓存了起来，如果再次require这个模块，是从缓存中取出的。这个有点像设计模式里的单例模式，只有这么一个实例，无论new多少个实例出来，返回的都是第一次的实例。如果有这样的一个需求：引入一个模块后，对这个模块里的内容进行了更改，正常来说再次引入这个模块，里边的内容是已经更改过的，但不想要改过的，想要一个新的，该如何处理呢？这里需要了解下require的cache。 实例demo12345// a.jsmodule.exports = &#123; name: &apos;a&apos;, count: 1&#125; 12345// b.jsmodule.exports = &#123; name: &apos;b&apos;, count: 10&#125; 123456789101112131415161718192021222324252627// index.jsvar a = require(&apos;./a&apos;);var b = require(&apos;./b&apos;);console.log(&apos;a moule---&gt;&apos;, a.count);console.log(&apos;b moule---&gt;&apos;, b.count);a.count = 5;b.count = 20;console.log(&apos;a plus 5 moule---&gt;&apos;, a.count);console.log(&apos;b plus 20 moule---&gt;&apos;, b.count);var newA = require(&apos;./a&apos;);var NewB = require(&apos;./b&apos;);console.log(&apos;new a moudle---&gt;&apos;, newA.count);console.log(&apos;new b moudle---&gt;&apos;, NewB.count);// 进行cache处理console.log(Object.prototype.toString.call(require.cache)); // require.cache是一个对象Object.keys(require.cache).forEach(key=&gt; &#123; console.log(require.resolve(key)); // require.resolve(key)可以把相对路径转成绝对路径，使用更安全 // require.resolve(&apos;./a.js&apos;); if(key.includes(&apos;a.js&apos;)) &#123; delete require.cache[require.resolve(key)]; &#125;&#125;);console.log(require.cache);var cacheA = require(&apos;./a&apos;);var cacheB = require(&apos;./b&apos;);console.log(&apos;new a moudle cache---&gt;&apos;, cacheA.count);console.log(&apos;new b moudle cache---&gt;&apos;, cacheB.count); 总结require.cache包含了当前所有的缓存模块，是一个对象{},key是文件路径require.resolve(‘./a.js’),可以将相对路径转成绝对路径，key就是一个绝对路径delete require.cache[key],清除掉了对应路径的缓存模块","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"svg-icon原理解析","slug":"svg-icon原理解析","date":"2021-09-07T08:21:28.000Z","updated":"2024-01-11T07:00:59.230Z","comments":true,"path":"2021/09/07/svg-icon原理解析/","link":"","permalink":"/2021/09/07/svg-icon原理解析/","excerpt":"svg-icon在html中使用原理","text":"svg-icon在html中使用原理 svg-icon原理解析最近发现svg-icon在vue中使用频率很高，一些管理系统的模板都已经把它集成进去了。svg-icon在vue中是如何工作的呢？1) 首先，需要一些svg的图形文件2) 在代码中把这些svg文件require进去3) 使用svg-sprite-loader这个webpack插件，它可以把svg文件以标签形式插入到html中4) 创建一个vue的svg-icon组件，用来显示svg图形，其实不创建组件直接写svg标签代码也可以5) 使用vue的svg-icon组件来展示图形以上就是使用步骤，下面贴出一套svg的原生demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;svg-icon&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; style=&quot;position: absolute; width: 0; height: 0&quot; id=&quot;__SVG_SPRITE_NODE__&quot;&gt; &lt;symbol xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 128 128&quot; id=&quot;icon-tree-table&quot;&gt;&lt;path d=&quot;M44.8 0h79.543C126.78 0 128 1.422 128 4.267v23.466c0 2.845-1.219 4.267-3.657 4.267H44.8c-2.438 0-3.657-1.422-3.657-4.267V4.267C41.143 1.422 42.362 0 44.8 0zm22.857 48h56.686c2.438 0 3.657 1.422 3.657 4.267v23.466c0 2.845-1.219 4.267-3.657 4.267H67.657C65.22 80 64 78.578 64 75.733V52.267C64 49.422 65.219 48 67.657 48zm0 48h56.686c2.438 0 3.657 1.422 3.657 4.267v23.466c0 2.845-1.219 4.267-3.657 4.267H67.657C65.22 128 64 126.578 64 123.733v-23.466C64 97.422 65.219 96 67.657 96zM50.286 68.267c2.02 0 3.657-1.91 3.657-4.267 0-2.356-1.638-4.267-3.657-4.267H17.37V32h6.4c2.02 0 3.658-1.91 3.658-4.267V4.267C27.429 1.91 25.79 0 23.77 0H3.657C1.637 0 0 1.91 0 4.267v23.466C0 30.09 1.637 32 3.657 32h6.4v80c0 2.356 1.638 4.267 3.657 4.267h36.572c2.02 0 3.657-1.91 3.657-4.267 0-2.356-1.638-4.267-3.657-4.267H17.37V68.267h32.915z&quot;&gt;&lt;/path&gt;&lt;/symbol&gt; &lt;symbol xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 128 128&quot; id=&quot;icon-tree&quot;&gt;&lt;path d=&quot;M126.713 90.023c.858.985 1.287 2.134 1.287 3.447v29.553c0 1.423-.429 2.6-1.287 3.53-.858.93-1.907 1.395-3.146 1.395H97.824c-1.145 0-2.146-.465-3.004-1.395-.858-.93-1.287-2.107-1.287-3.53V93.47c0-.875.19-1.696.572-2.462.382-.766.906-1.368 1.573-1.806a3.84 3.84 0 0 1 2.146-.657h9.725V69.007a3.84 3.84 0 0 0-.43-1.806 3.569 3.569 0 0 0-1.143-1.313 2.714 2.714 0 0 0-1.573-.492h-36.47v23.149h9.725c1.144 0 2.145.492 3.004 1.478.858.985 1.287 2.134 1.287 3.447v29.553c0 .876-.191 1.696-.573 2.463-.38.766-.905 1.368-1.573 1.806a3.84 3.84 0 0 1-2.145.656H51.915a3.84 3.84 0 0 1-2.145-.656c-.668-.438-1.216-1.04-1.645-1.806a4.96 4.96 0 0 1-.644-2.463V93.47c0-1.313.43-2.462 1.288-3.447.858-.986 1.907-1.478 3.146-1.478h9.582v-23.15h-37.9c-.953 0-1.74.356-2.359 1.068-.62.711-.93 1.56-.93 2.544v19.538h9.726c1.239 0 2.264.492 3.074 1.478.81.985 1.216 2.134 1.216 3.447v29.553c0 1.423-.405 2.6-1.216 3.53-.81.93-1.835 1.395-3.074 1.395H4.29c-.476 0-.93-.082-1.358-.246a4.1 4.1 0 0 1-1.144-.657 4.658 4.658 0 0 1-.93-1.067 5.186 5.186 0 0 1-.643-1.395 5.566 5.566 0 0 1-.215-1.56V93.47c0-.437.048-.875.143-1.313a3.95 3.95 0 0 1 .429-1.15c.19-.328.429-.656.715-.984.286-.329.572-.602.858-.821.286-.22.62-.383 1.001-.493.382-.11.763-.164 1.144-.164h9.726V61.619c0-.985.31-1.833.93-2.544.619-.712 1.358-1.068 2.216-1.068h44.335V39.62h-9.582c-1.24 0-2.288-.492-3.146-1.477a5.09 5.09 0 0 1-1.287-3.448V5.14c0-1.423.429-2.627 1.287-3.612.858-.985 1.907-1.477 3.146-1.477h25.743c.763 0 1.478.246 2.145.739a5.17 5.17 0 0 1 1.573 1.888c.382.766.573 1.587.573 2.462v29.553c0 1.313-.43 2.463-1.287 3.448-.859.985-1.86 1.477-3.004 1.477h-9.725v18.389h42.762c.954 0 1.74.355 2.36 1.067.62.711.93 1.56.93 2.545v26.925h9.582c1.239 0 2.288.492 3.146 1.478z&quot;&gt;&lt;/path&gt;&lt;/symbol&gt; &lt;symbol xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 130 130&quot; id=&quot;icon-user&quot;&gt;&lt;path d=&quot;M63.444 64.996c20.633 0 37.359-14.308 37.359-31.953 0-17.649-16.726-31.952-37.359-31.952-20.631 0-37.36 14.303-37.358 31.952 0 17.645 16.727 31.953 37.359 31.953zM80.57 75.65H49.434c-26.652 0-48.26 18.477-48.26 41.27v2.664c0 9.316 21.608 9.325 48.26 9.325H80.57c26.649 0 48.256-.344 48.256-9.325v-2.663c0-22.794-21.605-41.271-48.256-41.271z&quot; stroke=&quot;#979797&quot;&gt;&lt;/path&gt;&lt;/symbol&gt; &lt;symbol xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 128 110&quot; id=&quot;icon-wechat&quot;&gt;&lt;path d=&quot;M86.635 33.334c1.467 0 2.917.113 4.358.283C87.078 14.392 67.58.111 45.321.111 20.44.111.055 17.987.055 40.687c0 13.104 6.781 23.863 18.115 32.209l-4.527 14.352 15.82-8.364c5.666 1.182 10.207 2.395 15.858 2.395 1.42 0 2.829-.073 4.227-.189-.886-3.19-1.398-6.53-1.398-9.996 0-20.845 16.98-37.76 38.485-37.76zm-24.34-12.936c3.407 0 5.665 2.363 5.665 5.954 0 3.576-2.258 5.97-5.666 5.97-3.392 0-6.795-2.395-6.795-5.97 0-3.591 3.403-5.954 6.795-5.954zM30.616 32.323c-3.393 0-6.818-2.395-6.818-5.971 0-3.591 3.425-5.954 6.818-5.954 3.392 0 5.65 2.363 5.65 5.954 0 3.576-2.258 5.97-5.65 5.97z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M127.945 70.52c0-19.075-18.108-34.623-38.448-34.623-21.537 0-38.5 15.548-38.5 34.623 0 19.108 16.963 34.622 38.5 34.622 4.508 0 9.058-1.2 13.584-2.395l12.414 7.167-3.404-11.923c9.087-7.184 15.854-16.712 15.854-27.471zm-50.928-5.97c-2.254 0-4.53-2.362-4.53-4.773 0-2.378 2.276-4.771 4.53-4.771 3.422 0 5.665 2.393 5.665 4.771 0 2.41-2.243 4.773-5.665 4.773zm24.897 0c-2.24 0-4.498-2.362-4.498-4.773 0-2.378 2.258-4.771 4.498-4.771 3.392 0 5.665 2.393 5.665 4.771 0 2.41-2.273 4.773-5.665 4.773z&quot;&gt;&lt;/path&gt;&lt;/symbol&gt; &lt;symbol xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 128 128&quot; id=&quot;icon-zip&quot;&gt;&lt;path d=&quot;M78.527 116.793c.178.008.348.024.527.024h40.233c4.711-.005 8.53-3.677 8.534-8.21V18.895c-.004-4.532-3.823-8.204-8.534-8.209H79.054c-.179 0-.353.016-.527.024V0L0 10.082v107.406l78.527 10.342v-11.037zm0-101.362c.174-.024.348-.052.527-.052h40.233c2.018 0 3.659 1.578 3.659 3.52v89.713c-.003 1.942-1.64 3.517-3.659 3.519H79.054c-.179 0-.353-.028-.527-.052V15.431zM30.262 75.757l-18.721-.46V72.37l11.3-16.673v-.148l-10.266.164v-4.51l17.504-.44v3.264L18.696 70.76v.144l11.566.176v4.678zm9.419.231l-5.823-.144V50.671l5.823-.144v25.461zm22.255-11.632c-2.168 1.922-5.353 2.76-9.02 2.736-.702.004-1.402-.04-2.097-.131v9.303l-5.997-.148V50.743c1.852-.352 4.473-.647 8.218-.743 3.838-.096 6.608.539 8.48 1.913 1.807 1.306 3.032 3.5 3.032 6.112s-.926 4.833-2.612 6.331h-.004zM53.36 54.45c-.856-.01-1.71.083-2.541.275v7.682c.523.116 1.167.152 2.06.152 3.301-.004 5.36-1.614 5.36-4.314 0-2.425-1.772-3.843-4.875-3.791l-.004-.004zm39.847-37.066h9.564v3.795h-9.564v-3.795zm-9.568 5.68h9.564v3.8h-9.564v-3.8zm9.568 6.216h9.564v3.799h-9.564V29.28zm0 12h9.564v3.794h-9.564V41.28zm-9.568-6.096h9.564v3.795h-9.564v-3.795zm9.472 47.064c2.512 0 4.921-.96 6.697-2.67 1.776-1.708 2.773-4.026 2.772-6.442l-1.748-15.263c0-5.033-2.492-9.112-7.725-9.112-5.232 0-7.72 4.079-7.72 9.112l-1.752 15.263c-.001 2.417.996 4.735 2.773 6.444 1.777 1.71 4.187 2.669 6.7 2.668h.003zm-3.135-16.75h6.27v12.743h-6.27V65.5z&quot;&gt;&lt;/path&gt;&lt;/symbol&gt; &lt;/svg&gt; &lt;div&gt; &lt;p&gt; &lt;svg&gt; &lt;use xlink:href=&quot;#icon-tree-table&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/p&gt; &lt;p&gt; &lt;svg&gt; &lt;use xlink:href=&quot;#icon-tree&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/p&gt; &lt;p&gt; &lt;svg&gt; &lt;use xlink:href=&quot;#icon-user&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/p&gt; &lt;p&gt; &lt;svg&gt; &lt;use xlink:href=&quot;#icon-wechat&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/p&gt; &lt;p&gt; &lt;svg&gt; &lt;use xlink:href=&quot;#icon-zip&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"}]},{"title":"MutationObserver、IntersectionObserver、ResizeObserver","slug":"MutationObserver、IntersectionObserver、ResizeObserver","date":"2021-08-19T03:03:55.000Z","updated":"2024-01-11T07:00:59.145Z","comments":true,"path":"2021/08/19/MutationObserver、IntersectionObserver、ResizeObserver/","link":"","permalink":"/2021/08/19/MutationObserver、IntersectionObserver、ResizeObserver/","excerpt":"MutationObserver、IntersectionObserver、ResizeObserver简单使用","text":"MutationObserver、IntersectionObserver、ResizeObserver简单使用 MutationObserver、IntersectionObserver、ResizeObserverMutationObserver用于监控DOM节点的变化，如 属性变化、子节点增删改、子树的变化等123456789101112131415161718192021// 1、选择需要观察变动的节点const targetNode = document.getElementById(&apos;some-id&apos;);// 2、观察器的配置（需要观察什么变动）const config = &#123; attributes: true, childList: true, subtree: true &#125;;// 3、当观察到变动时执行的回调函数const callback = function(mutationsList, observer) &#123; for(let mutation of mutationsList) &#123; if (mutation.type === &apos;childList&apos;) &#123; console.log(&apos;A child node has been added or removed.&apos;); &#125; else if (mutation.type === &apos;attributes&apos;) &#123; console.log(&apos;The &apos; + mutation.attributeName + &apos; attribute was modified.&apos;); &#125; &#125;&#125;;// 4、创建一个观察器实例并传入回调函数const observer = new MutationObserver(callback);// 5、以上述配置开始观察目标节点observer.observe(targetNode, config);// 6、之后，可停止观察observer.disconnect(); 详细解释 IntersectionObserver目标元素是否进入视口区域(交叉观察器)12345678910// 图片懒加载的例子function callback(entry) &#123; if(entry[0].isIntersecting) &#123; // 出现在可视区内(默认 viewport) entry[0].target.src = entry[0].target.dataset.src; observer.unobserve(entry[0].target); &#125;&#125;var observer = new IntersectionObserver(callback); // 这里可以指定第二个参数做些定制化配置var img = document.getElementById(&apos;img&apos;);observer.observe(img); 详细解释 ResizeObserver专门用来观察DOM元素的尺寸是否发生了变化，不光是窗体resize12345678910var ro = new ResizeObserver( entries =&gt; &#123; for (let entry of entries) &#123; const cr = entry.contentRect; console.log(&apos;Element:&apos;, entry.target); console.log(`Element size: $&#123;cr.width&#125;px x $&#123;cr.height&#125;px`); console.log(`Element padding: $&#123;cr.top&#125;px ; $&#123;cr.left&#125;px`); &#125;&#125;);// 观察一个或多个元素ro.observe(eleZxx); 注意：观测的是 contentRect，只有 content 改变（margin,padding不行）才会触发回调用途：1、原生resize行为的检测，如 textarea 的拉升2、 感知交互行为的发生（无埋点方案？）3、感知元素是否显示或隐藏（MutationObserver 有时做不到）详细解释","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"javascript错误类型","slug":"javascript错误类型","date":"2021-07-23T08:56:17.000Z","updated":"2024-01-11T07:00:59.196Z","comments":true,"path":"2021/07/23/javascript错误类型/","link":"","permalink":"/2021/07/23/javascript错误类型/","excerpt":"javascript错误类型","text":"javascript错误类型 ECMA-262规范定义的七种错误类型： Error EvalError RangeError ReferenceError SyntaxError TypeError URIError ErrorError是所有错误的基类，其他错误都继承自该类型 EvalErrorEvalError对象表示全局函数eval()中发生的错误。如果eval()中没有错误，则不会抛出该错误。可以通过构造函数创建这个对象的实例12345678try &#123; throw new EvalError(&apos;make EvalError&apos;);&#125;catch(err) &#123; console.log(err instanceof EvalError); console.log(err.message); console.log(err.name); console.log(err.stack);&#125; RangeErrorRangeError对象表示当一个值不在允许值的集合或范围内时出现错误。12var arr = [];arr.length = -1; ReferenceError当引用不存在的变量时，该对象表示错误1var str = abc; SyntaxError当JavaScript引擎在解析代码时遇到不符合该语言语法的标记或标记顺序时，将引发该异常1var str = &apos;abc&apos;； // 这里的分号是中文分号 TypeError传递给函数的操作数或实参与该操作符或函数期望的类型不兼容1234function fn(arr) &#123; arr.map(item=&gt; item);&#125;fn(123); URIError当全局URI处理函数以错误的方式使用时1window.decodeURIComponent(&apos;%&apos;); 总结以上只是简单的介绍了js中的7种错误类型，还有更详细的错误处理请看前端异常处理。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"工作中常用代码片段","slug":"工作中常用代码片段","date":"2021-07-12T01:26:32.000Z","updated":"2024-02-27T07:58:03.027Z","comments":true,"path":"2021/07/12/工作中常用代码片段/","link":"","permalink":"/2021/07/12/工作中常用代码片段/","excerpt":"工作中常用代码片段","text":"工作中常用代码片段记录些工作中常用到的代码片段，便于CV使用，提高效率 根据日期对象获取格式化日期字符串1234567const getYrarMonthDay = date=&gt; &#123; let year = date.getFullYear(); let month = date.getMonth() + 1; month = month&gt;9?month:&apos;0&apos;+month; let day = date.getDate(); return year + &apos;-&apos; + month + &apos;-&apos; + day;&#125; 解析url中的参数1234567891011121314151617const urlQuery2Object = url=&gt; &#123; url = !url ? window.location.href : url; if(url.indexOf(&apos;?&apos;) === -1) &#123; return &#123;&#125;; &#125; var search = url[0] === &apos;?&apos; ? url.substr(1) : url.substring(url.lastIndexOf(&apos;?&apos;) + 1); if (search === &apos;&apos;) &#123; return &#123;&#125;; &#125; search = search.split(&apos;&amp;&apos;); var query = &#123;&#125;; for (var i = 0; i &lt; search.length; i++) &#123; var pair = search[i].split(&apos;=&apos;); query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || &apos;&apos;); &#125; return query; &#125; 触发input的选择获取文件123456789101112131415161718192021const triggerInputFile = function(callBack) &#123; return new Promise((resolve, reject)=&gt; &#123; try &#123; let nInput = document.createElement(&apos;input&apos;); nInput.setAttribute(&apos;type&apos;, &apos;file&apos;); nInput.setAttribute(&apos;accept&apos;, &apos;image/png,image/jpg,image/jpeg&apos;); document.body.appendChild(nInput); nInput.addEventListener(&apos;change&apos;, (ev)=&gt; &#123; if(ev.target.files[0].size &gt; 1024*1024*2) &#123; alert(&apos;图片大小不得超过2M&apos;); return void 0; &#125; resolve(ev); document.body.removeChild(nInput); &#125;, false); nInput.click(); &#125;catch(err) &#123; reject(err); &#125; &#125;);&#125; 获取宿主浏览器环境详细内容可异步这里12345678910111213141516171819202122232425const getPlatformOs = ()=&gt; &#123; return new Promise((resolve, reject)=&gt; &#123; try &#123; var u = navigator.userAgent; var ua = navigator.userAgent.toLowerCase(); // 判断是否在微信内置浏览器打开 if(ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123; resolve(&apos;weixin&apos;) return void 0; &#125; // 判断安卓 if(u.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1) &#123; resolve(&apos;android&apos;) return void 0; &#125; // 判断iOS if(!!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)) &#123; resolve(&apos;ios&apos;); return void 0; &#125; &#125;catch(err) &#123; reject(err); &#125; &#125;);&#125; 判断宿主环境是否是微信小程序详细内容可异步这里1234567891011121314151617181920const isWeiApp = ()=&gt; &#123; return new Promise(function(resolve, reject) &#123; try&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) &#123; wx.miniProgram.getEnv((res)=&gt;&#123; if (res.miniprogram) &#123; resolve(true); &#125;else &#123; resolve(false); &#125; &#125;) &#125;else&#123; resolve(false); &#125; &#125;catch(err) &#123; reject(err); &#125; &#125;);&#125; 复制内容到剪贴板12345678910111213function copyToBoard(value) &#123; const element = document.createElement(&apos;textarea&apos;) document.body.appendChild(element) element.value = value element.select() if (document.execCommand(&apos;copy&apos;)) &#123; document.execCommand(&apos;copy&apos;) document.body.removeChild(element) return true &#125; document.body.removeChild(element) return false&#125; 对象转化为FormData对象1234567891011121314function getFormData(object) &#123; const formData = new FormData() Object.keys(object).forEach(key =&gt; &#123; const value = object[key] if (Array.isArray(value)) &#123; value.forEach((subValue, i) =&gt; formData.append(key + `[$&#123;i&#125;]`, subValue) ) &#125; else &#123; formData.append(key, object[key]) &#125; &#125;) return formData&#125; 睡眠sleep方法1123456789101112131415161718sleep(time) &#123; return new Promise((resolve, reject)=&gt; &#123; setTimeout(()=&gt; &#123; resolve(); &#125;, time); &#125;);&#125;// demo 发送验证码async onSendCode() &#123; let num = 60; while(num&gt;0) &#123; num--; this.form.codeBtnStr = num; await sleep(1000); &#125; this.form.codeBtnStr = &apos;发送验证码&apos;;&#125; 方法212345678910111213141516171819202122232425const sleep = (timeOut, oneCb)=&gt; &#123; return new Promise((resolve, reject)=&gt; &#123; const innerSleep = (timeOut, oneCb)=&gt; &#123; oneCb(timeOut); setTimeout(()=&gt; &#123; if(timeOut&lt;=1) &#123; resolve(); return ; &#125; timeOut-=1; oneCb(timeOut); innerSleep(timeOut, oneCb); &#125;, 1000); &#125; innerSleep(timeOut, oneCb); &#125;);&#125;// demo 发送验证码onSendCode() &#123; sleep(60, (val)=&gt; &#123; this.form.codeBtnStr = val; &#125;).then(()=&gt; &#123; this.form.codeBtnStr = &apos;发送验证码&apos;; &#125;); &#125;, 倒计时 时分秒未支付订单的倒计时效果中会使用到123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function countDown(originDate, rangeMinute) &#123; // originDate 倒计时的起始时间，如2023-12-12 8:09:15 // rangeMinute 倒计时范围，1个小时倒计时还是30分钟倒计时 // requestAnimationFrame兼容性处理 var requestAnimationFrame =window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (cb) &#123; window.setTimeout(cb, 1000 / 60) &#125;; var preTime = Date.now(); // 计算1秒前置时间 var countTime = Date.now(); // 倒计时的时间 var innerFn = function(callback) &#123; requestAnimationFrame(function() &#123; var laterTime = Date.now(); // 计算1秒的后置时间 innerFn.timer&amp;&amp;innerFn(callback); // 当timer为false时，不执行递归循环 if((laterTime-preTime&gt;=1000)) &#123; // 每隔1秒钟触发 countTime += 1000; // 倒计时时间减1秒 preTime = laterTime; // 计算1秒前置时间更改 var originDateTime = new Date(originDate).getTime(); // 倒计时的原始时间 if(laterTime - originDateTime &gt; rangeMinute*1000) &#123; console.error(&apos;倒计时时间超出范围&apos;); innerFn.timer = false; return void 0; &#125; var str = format(originDateTime, countTime); // 格式化成hh:mm:ss callback(str); // 执行回调, rangeMinute &#125; &#125;); &#125; innerFn.timer = true; // 是否执行递归的flag // 结束倒计时函数 innerFn.clear= function() &#123; innerFn.timer = false; &#125; // 工具函数，时间戳转成hh:mm:ss格式 // 将时间戳格式化最主要的思路是%操作 function format(originDateTime, currentDateTime) &#123; var time = rangeMinute - (currentDateTime - originDateTime)/1000; if(time&lt;=0) innerFn.timer = false; var hh = parseInt(time/3600); var mm = parseInt(time%3600/60); var ss = parseInt(time%3600%60); hh = hh&lt;10?(&apos;0&apos;+hh):hh; mm = mm&lt;10?(&apos;0&apos;+mm):mm; ss = ss&lt;10?(&apos;0&apos;+ss):ss; return hh + &apos;:&apos; + mm + &apos;:&apos; + ss; &#125; return innerFn;&#125;// 使用var showCoutn = countDown(&apos;2023-12-20 8:09:08&apos;, 1800);showCoutn((val)=&gt; &#123; console.log(val);&#125;);// 10秒后倒计时结束setTimeout(()=&gt; &#123; showCoutn.clear();&#125;, 10000); 下载文件12345678910111213141516171819202122232425262728// 方法1：// fileBlob必须是Blob格式文件，axios请求中设置responseType: &apos;blob&apos;// fileName文件名downloadFile(fileBlob, fileName) &#123; let reader = new FileReader(); reader.readAsDataURL(fileBlob); reader.onload = evt=&gt; &#123; let body = document.body; let a = document.createElement(&apos;a&apos;); a.download = fileName; a.href = evt.target.result; body.append(a); a.click(); body.removeChild(a); &#125;&#125;// 方法2：downloadFile(fileBlob, fileName) &#123; let url = window.URL.createObjectURL(fileBlob); let body = document.body; let a = document.createElement(&apos;a&apos;); a.download = fileName; a.href = url; body.append(a); a.click(); body.removeChild(a); window.URL.revokeObjectURL(url); //释放掉blob对象&#125; retry当接口请求失败后，每间隔几秒，再重发几次123456789101112131415161718192021222324/* * @param &#123;function&#125; fn - 方法名* @param &#123;number&#125; delay - 延迟的时间* @param &#123;number&#125; times - 重发的次数*/function retry(fn, delay, times) &#123; return new Promise((resolve, reject) =&gt; &#123; function func() &#123; Promise.resolve(fn()).then(res =&gt; &#123; resolve(res); &#125;) .catch(err =&gt; &#123; // 接口失败后，判断剩余次数不为0时，继续重发 if (times !== 0) &#123; setTimeout(func, delay); times--; &#125; else &#123; reject(err); &#125; &#125;); &#125; func(); &#125;);&#125; 控制请求最大并发数12345678910111213141516171819202122/* * 控制并发数 * @param &#123;array&#125; list - 请求列表 * @param &#123;number&#125; num - 最大并发数 */function control(list, num) &#123; function fn() &#123; if (!list.length) return; // 从任务数 和 num 中 取最小值，兼容并发数num &gt; list.length的情况 let max = Math.min(list.length, num); for (let i = 0; i &lt; max; i++) &#123; let f = list.shift(); num--; // 请求完成后，num++ f.finally(() =&gt; &#123; num++; fn(); &#125;); &#125; &#125; fn();&#125; 根据value取出label使用场景，在table表格中，数据只有下拉选项的value，需要获取label123456789function value2label(list, value) &#123; var obj = list.filter(item=&gt; &#123; return +item.value === +value; &#125;)[0] || &#123;&#125;; return obj.label;&#125;// 使用var list = [&#123; label: &apos;沈阳&apos;, value: 1&#125;, &#123; label: &apos;大连&apos;, value: 2&#125; ];value2label(list, 1); // &apos;沈阳&apos; 获取元素样式1234const getStyle = function(el, name) &#123; let style = el.currentStyle ? el.currentStyle:document.defaultView.getComputedStyle(el, null); return style[name]; &#125; 彩色log123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Print colored text with `console.log`. * * Usage: * colorLog(&apos;fgCyan&apos;)(&apos;some text&apos;); // cyan text. */function colorLog() &#123; var COLOR_RESET = &apos;\\x1b[0m&apos;; var COLOR_MAP = &#123; bright: &apos;\\x1b[1m&apos;, dim: &apos;\\x1b[2m&apos;, underscore: &apos;\\x1b[4m&apos;, blink: &apos;\\x1b[5m&apos;, reverse: &apos;\\x1b[7m&apos;, hidden: &apos;\\x1b[8m&apos;, fgBlack: &apos;\\x1b[30m&apos;, fgRed: &apos;\\x1b[31m&apos;, fgGreen: &apos;\\x1b[32m&apos;, fgYellow: &apos;\\x1b[33m&apos;, fgBlue: &apos;\\x1b[34m&apos;, fgMagenta: &apos;\\x1b[35m&apos;, fgCyan: &apos;\\x1b[36m&apos;, fgWhite: &apos;\\x1b[37m&apos;, bgBlack: &apos;\\x1b[40m&apos;, bgRed: &apos;\\x1b[41m&apos;, bgGreen: &apos;\\x1b[42m&apos;, bgYellow: &apos;\\x1b[43m&apos;, bgBlue: &apos;\\x1b[44m&apos;, bgMagenta: &apos;\\x1b[45m&apos;, bgCyan: &apos;\\x1b[46m&apos;, bgWhite: &apos;\\x1b[47m&apos; &#125;; let prefix = []; for (let i = 0; i &lt; arguments.length; i++) &#123; let color = COLOR_MAP[arguments[i]]; color &amp;&amp; prefix.push(color); &#125; prefix = prefix.join(&apos;&apos;); return function (text) &#123; console.log(prefix + text + COLOR_RESET); &#125;;&#125;;colorLog(&apos;bgCyan&apos;, &apos;fgWhite&apos;)(&apos;some text&apos;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"express中间件","slug":"express中间件","date":"2021-06-25T02:38:47.000Z","updated":"2024-01-11T07:00:59.180Z","comments":true,"path":"2021/06/25/express中间件/","link":"","permalink":"/2021/06/25/express中间件/","excerpt":"express的中间件简单实现","text":"express的中间件简单实现在使用express时，中间件是必须使用的，有时候需要自己写一个中间件，express是如何实现中间件的呢，下面一个简单的实现demo。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var http = require(&apos;http&apos;);function express() &#123; var funcs = []; // 待执行的中间件数组 var app = function (req, res) &#123; var i = 0; function next() &#123; var task = funcs[i++]; // 取出中间件数组里的下一个函数 if (!task) &#123; // 如果函数不存在,return return void 0; &#125; task(req, res, next); // 否则,执行下一个函数 &#125; next(); &#125; // 使用中间件函数 app.use = function (task) &#123; funcs.push(task); &#125; return app; // 返回实例&#125;// 下面是测试casevar app = express();http.createServer(app).listen(&apos;3000&apos;, function () &#123; console.log(&apos;listening 3000....&apos;);&#125;);function middlewareA(req, res, next) &#123; console.log(&apos;middlewareA before next()&apos;); next(); console.log(&apos;middlewareA after next()&apos;);&#125;function middlewareB(req, res, next) &#123; console.log(&apos;middlewareB before next()&apos;); next(); console.log(&apos;middlewareB after next()&apos;);&#125;function middlewareC(req, res, next) &#123; console.log(&apos;middlewareC before next()&apos;); next(); console.log(&apos;middlewareC after next()&apos;);&#125;app.use(middlewareA);app.use(middlewareB);app.use(middlewareC);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"前端音视频，多媒体领域主流框架","slug":"前端音视频，多媒体领域主流框架","date":"2021-06-22T01:48:46.000Z","updated":"2024-01-11T07:00:59.263Z","comments":true,"path":"2021/06/22/前端音视频，多媒体领域主流框架/","link":"","permalink":"/2021/06/22/前端音视频，多媒体领域主流框架/","excerpt":"前端音视频，多媒体领域主流框架介绍","text":"前端音视频，多媒体领域主流框架介绍 flv.js 基于http的flv的流媒体协议，通过纯js实现了flv的封装，使flv格式能够在web浏览器上播放 hls.js hls是http live stream协议开发，利用media source extension 用于实现hls，在web浏览器上播放的一款js播放库 苹果提出，被移动端设备广泛支持，广泛应用在直播场景中 video.js 基于html5播放器，同时支持h5和flash播放，拥有超过100个插件可以使用 可以满足hls代时格式的播放， 支持定制主题，字符扩展等不同需求，在世界范围拥有大量应用场景 ffmpeg 是一套领先的多媒体框架，是一套开源且跨平台的多媒体解决方案 提供了音视频的编码解码转码封装解封装流媒体滤镜等功能 可以基于ffmpeg和web—实现浏览器的js播放器，并且扩展浏览器端的其他音视频能力 在node模块也是非常实用的模块，这模块简化了ffmpeg复杂的命令操作，配合文件的上传和视频中的处理变得非常方便 obs 用于录制和网络直播的自由开源软件包 使用C和C++编辑,t提供实时语言和设备捕获，场景组成，编码录制和广播 数据传输主要通过实时的消息协议rtmp完成可以发送到任何支持rtmp的目的地,包括网易，youtube，facebook等主流媒体网站 mlt 用于多种app非线性的视频编辑以及且不限于桌面领域，他同样适用于Andriod，iOS的平台​","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"h5移动端判断宿主平台","slug":"h5移动端判断宿主平台","date":"2021-06-08T02:34:16.000Z","updated":"2024-01-11T07:00:59.189Z","comments":true,"path":"2021/06/08/h5移动端判断宿主平台/","link":"","permalink":"/2021/06/08/h5移动端判断宿主平台/","excerpt":"h5移动端判断宿主平台","text":"h5移动端判断宿主平台笔者在h5页面开发中，需要适配android,ios的webview，微信内置浏览器和微信小程序，在不同的平台下做不同逻辑操作。笔者总结了一个简单的判别这四种平台的方法，见下方代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;h5移动端判断宿主平台&lt;/title&gt; &lt;!--判断是否是微信小程序的话，需要引入--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h5移动端判断宿主平台&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; /** * @desc 获取当前移动端的宿主平台 * @return &#123; String &#125; weiapp weixin android ios pc */ function getOs() &#123; return new Promise(function(resolve, reject) &#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) &#123; wx.miniProgram.getEnv((res)=&gt;&#123; if(res.miniprogram) &#123; resolve(&apos;weiapp&apos;); &#125;else &#123; resolve(&apos;weixin&apos;); &#125; &#125;) &#125;else if(ua.indexOf(&quot;android&quot;) &gt; -1 || ua.indexOf(&quot;linux&quot;) &gt; -1) &#123; resolve(&apos;android&apos;); &#125;else if(!!ua.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/i)) &#123; resolve(&apos;ios&apos;); &#125;else &#123; resolve(&apos;pc&apos;); &#125; &#125;); &#125; // 使用 async function getCurrentPlatform() &#123; var os = await getOs(); alert(os); &#125; getCurrentPlatform();&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"html页面可见性监测","slug":"html页面可见性监测","date":"2021-05-28T06:08:25.000Z","updated":"2024-01-11T07:00:59.192Z","comments":true,"path":"2021/05/28/html页面可见性监测/","link":"","permalink":"/2021/05/28/html页面可见性监测/","excerpt":"html页面可见性监测处理","text":"html页面可见性监测处理项目开发中会有这样的需求，当前页面最小化，或被其它应用挡住，或者tab切换时，为了更好的用户体验（特别是游戏场景），页面的性能考虑，需要做相关处理。 Page Visibility API阮一峰教程，这篇文章写的很详细，可以参考。demo focus blur利用focus和blur来模拟页面的隐藏和显示，虽说不够严谨，但是有些简单的需求还是可以应付的。demo 项目应用一个app的h5项目，需求：进入首页浏览内容，当点击下一步按钮时，如果发现当前状态是未登录，则跳转至app的登陆页面，登陆后再切回到首页。这里使用了页面可见性，当从app的登陆页回到h5的首页时，利用可见性事件完成一系列动作。1234567document.addEventListener(&apos;visibilitychange&apos;, (evt) =&gt; &#123; if (document.visibilityState === &apos;visible&apos;) &#123; if(this.isFromLogin) &#123; // 从h5页面跳转到app的登陆页面之前，把它设置成true，回到这个页面时知道要去操作哪个功能 location.reload(); &#125; &#125;&#125;, false)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}]},{"title":"无所不能的Array reduce","slug":"无所不能的Array-reduce","date":"2021-05-25T01:59:29.000Z","updated":"2024-01-11T07:00:59.272Z","comments":true,"path":"2021/05/25/无所不能的Array-reduce/","link":"","permalink":"/2021/05/25/无所不能的Array-reduce/","excerpt":"Array的reduce方法分析","text":"Array的reduce方法分析Array有很多实例方法，reduce,map,filter,find,some,every…这里，基础是reduce，可以利用它去实现其它所有方法。我们先来看看reduce如何使用： reducereduce的使用1234567891011121314151617// apiArray.prototype.reduce = function(callback, initialValue) &#123;&#125;// Accumulator (acc) (累计器) 如果传入了initialValue,Accumulator的初始值就是initialValue,没传入就是数组的第一个值// Current Value (cur) (当前值)// Current Index (idx) (当前索引)如果传入了initialValue,索引从0开始,没传入从1开始// Source Array (src) (源数组)const callback = function(acc, cur, idx, src) &#123; return someVal;&#125;// demolet arr = [1,2,3,4,5,6,7,8,9,10];let sum = arr.reduce(function(acc, cur, idx, src) &#123; return acc + cur;&#125;, 0);console.log(sum); // 55 reduce方法的实现12345678910111213141516Array.prototype.myReduce = function (callback, initVal) &#123; for (let i = 0; i &lt; this.length; i++) &#123; initVal = callback(initVal, this[i], i, this) &#125; return initVal &#125;// initVal不传的时候，改进版Array.prototype.myReduce = function(callback, initVal) &#123; let arr = this; let i = initVal?0:1; initVal = initVal || arr[0]; for(;i&lt;arr.length; i++) &#123; initVal = callback(initVal, arr[i], i, arr); &#125; return initVal;&#125; 利用reduce实现其它方法map123456789101112131415Array.prototype.myMap = function(callback) &#123; let tempArr = []; this.reduce(function(pre, cur, index) &#123; tempArr.push(callback(cur, index)); &#125;, this[0]); return tempArr;&#125;let arr = [1,2,3,4,5];let newArr = arr.myMap((item, index)=&gt; &#123; return &#123; val: item, num: index + 1 &#125;&#125;);console.log(newArr); filter123456789101112Array.prototype.myFilter = function(callback) &#123; let tempArr = []; this.reduce(function(pre, cur, index) &#123; if(callback(cur, index)) tempArr.push(cur); &#125;, this[0]); return tempArr;&#125;let arr = [1,2,3,4,5,6,7,8,9,10,11,12];let newArr = arr.filter((item, index)=&gt; &#123; return item%2===0&amp;&amp;item%3===0;&#125;);console.log(newArr); find123456789101112Array.prototype.myFind = function(callback) &#123; let target = null; this.reduce(function(pre, cur, index) &#123; if(callback(cur, index)&amp;&amp;!target) target = cur; &#125;, this[0]); return target;&#125;let arr = [1,2,3,4,5,6,7,8,9,10,11,12];let newArr = arr.myFind((item, index)=&gt; &#123; return item &gt; 3;&#125;);console.log(newArr); some123456789101112Array.prototype.mySome = function(callback) &#123; let bResult = false; this.reduce(function(pre, cur, index) &#123; callback(cur, index)&amp;&amp;(bResult=true); &#125;, this[0]); return bResult;&#125;let arr = [1,2,3,4,5,6,7,8,9,10,11,12];let result = arr.mySome((item, index)=&gt; &#123; return item &gt; 11;&#125;);console.log(result); every123456789101112Array.prototype.myEvery = function(callback) &#123; let bResult = false; this.reduce(function(pre, cur, index) &#123; !callback(cur, index)&amp;&amp;(bResult=true); &#125;, this[0]); return !bResult;&#125;let arr = [1,2,3,4,5,6,7,8,9,10,11,12];let result = arr.myEvery((item, index)=&gt; &#123; return item &gt; 1;&#125;);console.log(result); 总结其实不用reduce也可以实现，但是利用reduce来实现，侧面反映了reduce功能的强大，在实际项目中灵活运用reduce，会事半功倍哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"js-animate","slug":"js-animate","date":"2021-05-08T06:28:03.000Z","updated":"2024-02-20T07:11:25.730Z","comments":true,"path":"2021/05/08/js-animate/","link":"","permalink":"/2021/05/08/js-animate/","excerpt":"js控制css animate动画","text":"js控制css animate动画Animate.css这个动画库很好，使用也很方便，点击进入。今天笔者用另外一种方式来使用，写一段js代码来控制一个元素来执行多个动画效果。demo","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"判断上传图片格式类型","slug":"判断上传图片格式类型","date":"2021-04-08T07:00:21.000Z","updated":"2024-02-20T07:11:25.726Z","comments":true,"path":"2021/04/08/判断上传图片格式类型/","link":"","permalink":"/2021/04/08/判断上传图片格式类型/","excerpt":"判断图片的具体格式类型","text":"判断图片的具体格式类型日常开发中，对上传图片或文件的格式判断，来处理是否符合要求。本例是利用FileReader的readAsArrayBuffer方法，来处理文件格式的。无论是本地上传的文件或者是网络请求获取的文件，只要类型是Blob or File格式，都可以进行判断。代码如下：1234567891011121314151617181920212223242526function getFileMimeType(file) &#123; const map = &#123; &apos;FFD8FFE0&apos;: &apos;jpg&apos;, &apos;89504E47&apos;: &apos;png&apos;, &apos;47494638&apos;: &apos;gif&apos;, &quot;52494646&quot;: &apos;webp&apos; &#125; const reader = new FileReader(); reader.readAsArrayBuffer(file); return new Promise((resolve, reject)=&gt; &#123; reader.onload = (event)=&gt; &#123; try &#123; let array = new Uint8Array(event.target.result); array = array.slice(0, 4); let arr = [...array] let key = arr.map(item=&gt; item.toString(16) .toUpperCase() .padStart(2, &apos;0&apos;)) .join(&apos;&apos;) resolve(map[key]) &#125; catch(e) &#123; reject(e); &#125; &#125;; &#125;);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"浏览器F12调试工具监测","slug":"浏览器F12调试工具监测","date":"2021-04-01T02:15:13.000Z","updated":"2024-01-11T07:00:59.273Z","comments":true,"path":"2021/04/01/浏览器F12调试工具监测/","link":"","permalink":"/2021/04/01/浏览器F12调试工具监测/","excerpt":"浏览器F12调试工具弹出时的监测","text":"浏览器F12调试工具弹出时的监测最近笔者在浏览别人的网站时，发现一个酷炫的效果，于是职业习惯的驱使，F12,元素检查，不过，这时候页面弹出debug，什么情况？原来，作者不想让别人剽窃他的代码。这个功能是怎么做到的呢？笔者上网查了下，都是一些大神搞得hack方式，具体代码啥意思，大家也不清楚，贴一个比较简单而且自测兼容性比较好的代码。123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;F12监测&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; setInterval(function() &#123; check() &#125;, 2000); var check = function() &#123; function doCheck(a) &#123; if ((&quot;&quot; + a/a)[&quot;length&quot;] !== 1 || a % 20 === 0) &#123; (function() &#123;&#125; [&quot;constructor&quot;](&quot;debugger&quot;)()) &#125; else &#123; (function() &#123;&#125; [&quot;constructor&quot;](&quot;debugger&quot;)()) &#125; doCheck(++a) &#125; try &#123; doCheck(0) &#125; catch (err) &#123;&#125; &#125;;check();&lt;/script&gt;&lt;/html&gt; 再贴两个专门监测的插件库： devtools-detect1 devtools-detect2","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}]},{"title":"vue ssr","slug":"vue-ssr","date":"2021-03-31T07:39:39.000Z","updated":"2025-02-13T05:34:39.890Z","comments":true,"path":"2021/03/31/vue-ssr/","link":"","permalink":"/2021/03/31/vue-ssr/","excerpt":"vue服务端渲染ssr","text":"vue服务端渲染ssr 简介SSR 是 Server-Side Rendering，【Vue SSR 指南】,vue ssr的官网。 SSR的原理：首先在服务器端要准备好客户端渲染代码（spa）和服务器端代码（ssr），浏览器发起页面的请求（比如首页，也可以是其它页），服务端直接返回带有内容的页面，这样在浏览器可以马上看到渲染后的内容，而且体积还小。在页面的尾部，请求客户端的js等文件，当客户端的js文件加载完成后，会偷偷的执行，等用户再想浏览其它页面的时候，客户端的spa代码已经接管完成，不会再向服务器端发起请求，这时已经是一个spa应用了。 vue2 ssr此项目是参考开课吧的一个教程，使用了vue2版本。源码 vue3 ssr此项目使用vue3+webpack开发的ssr框架。源码 总结上边两个项目实现的ssr框架可以学习其原理性知识，但是在实际的项目开发中最好使用成熟的ssr框架.Nuxt英文Nuxt中文","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"}]},{"title":"理解BFC,IFC,GFC和FFC","slug":"理解BFC-IFC-GFC和FFC","date":"2021-03-29T06:31:48.000Z","updated":"2024-01-11T07:00:59.275Z","comments":true,"path":"2021/03/29/理解BFC-IFC-GFC和FFC/","link":"","permalink":"/2021/03/29/理解BFC-IFC-GFC和FFC/","excerpt":"BFC,IFC,IFC,FFF是什么","text":"BFC,IFC,IFC,FFF是什么 理解BFC,IFC,GFC和FFC概要BFC,IFC,GFC,FFC是什么，主要解决的什么问题，哪些元素会生成BFC？本文主要针对这几个问题来了解。在解释之前，需要先介绍 Box、Formatting Context的概念Box: CSS布局的基本单位 Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box:display 属性为flex,grid,如果 run-in box 包含 block box，那么这个 run-in box 也成为 block box如果紧跟在 run-in box 之后的兄弟节点是 block box，那么这个 run-in box 就会做为此 block box 里的 inline box，run-in box 不能进入已经一个已经以 run-in box 开头的块内，也不能进入本身就是 display:run-in; 的块内,否则，run-in box 成为 block box Formatting contextFormatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC的作用及原理 自适应两栏布局我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。123.main &#123; overflow: hidden;&#125; 清除内部浮动为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。123.par &#123; overflow: hidden;&#125; 防止垂直 margin 重叠我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 IFCIFC(Inline-Formatting-Contexts)即内联格式化上下文布局。一般都是行内元素比如：input a img span 以及display 属性值为inline-block的元素。行内元素有哪些特点呢？如下列举： 水平方向根据direction依次布局。 不会在元素前后换行。 受white-space属性的影响。 margin/padding 在竖直方向无效，水平方向有效的。 width/height 对非替换行内元素无效，宽度由元素内容决定。 非替换行内元素的行框高由line-height决定而替换行内元素的行框高则是由height，padding，border，margin决定 浮动或者绝对定位会转化为block vertical-align属性生效 IFC的布局规则如下： 框会从包含块的顶部开始，然后一个接一个的排列。 在放置这些框的时候，他们在水平方向上的外边距，边框和内边距所占的空间都会被考虑在内（这样就得到了一个一个的框）。然而在垂直方向上，这些框可能会以不同的方式来对齐，比如他们可以顶部对齐，或者底部对齐也有可能按照文本的基线对齐。而把这一行上的框都包含进去的一个大框我们称之为改行的行框。水平的padding,border,margin有效，竖直方向则无效。不能指定框高。 行宽的宽度由包含块和存在的浮动决定的。行框的高度至少会高到足以包含他内部的所有框。 当一行上的行级总宽度（某一个小框的宽度或者若干个小框的总宽度）小于行宽的时候，他们在行宽内的水平方向上的排布由text-align决定。 当一个行内框的宽度超过了该行的行宽的时候，就会被分成几个框。(ex.文字换行的时候 字都不在同一行了，那换行的时候自然就会多一份框，自然也就多了一份行宽)但是如果设置这个框就不能被分割的话（比如，文字强制不给换行white-space设置为nowrap）那么这时候该行内框就会溢出该行的行宽。 一般情况下行宽的左边紧贴在他的包含块的左边，同样他的右边也是紧贴在其包含块的右边。但是也不一定，比如出现浮动的话，浮动元素可能会插在包含块和行框之间。所以一般在同一个IFC中行框通常有相同的宽度（包含快的宽度）但是某一行的行宽的宽度也可能受浮动元素影响，减少了水平可用的宽度了。在同一个IFC中，行框的高度通常是变化的，不一定的，比如某一行的某个框是个很高的图片，而改行框中其他框只是文字。 计算行框内各个框的高度，对于非替换元素就是起line-height,而对于替换元素就是边界框的高度了。 行框的高是最顶端框的顶边到最底端框的底边的距离。 补充：包含块的概念：简单说就是定位参考框或者定位坐标参考系，元素一旦定义了定位显示（相对、绝对、固定）都具有包含块性质，它所包含的定位元素都将以该包含块为坐标系进行定位和调整。是视觉格式化模型的一个重要概念，它与框模型类似，也可以理解为一个矩形，而这个矩形的作用是为它里面包含的元素提供一个参考，元素的尺寸和位置的计算往往是由该元素所在的包含块决定的。 FFC弹性布局(FFC-Flex Formattig-Contexts 自适应格式化上下文)申明 display:flex; 或者display:inline-flex(行内弹性布局) 这个布局是我最爱的布局之一了，因为他可以非常轻松的实现元素的上下居中，左右居中；只需要justify-content:center（左右居中）align-items:center;(上下居中)就ok了.申明flex之后这个元素就会成为一个flex容器，而他的子元素就会自动成为这个容器的成员，简称为项目。而其中又会有两个轴线（类似于笛卡尔坐标系的两个轴吧）横的称之为主轴，竖着的称之为交叉轴，容器是一个相对独立的渲染区域，他对自己内部的项目有着自己的一套渲染规则，不受容器外部的影响，同样的，容器内部的规则也不会影响外面。 容器属性：六个属性分别为：flex-direction,flex-wrap,flex-flow,justify-content,align-items,align-content 项目属性：六个属性分别为：order，flex-grow，flex-shrink，flex-basis，flex，align-self GFCGFC（Grid Formatting Contexts）栅格格式化上下文 当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。 那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"canvas事件处理","slug":"canvas事件处理","date":"2021-02-20T05:13:11.000Z","updated":"2024-01-11T07:00:59.177Z","comments":true,"path":"2021/02/20/canvas事件处理/","link":"","permalink":"/2021/02/20/canvas事件处理/","excerpt":"canvas中的图形添加事件","text":"canvas中的图形添加事件 canvas事件处理canvas是一块画布，假设这块画布中有3个方块，给这3个方块添加事件该如何操作呢？因为canvas是一个元素节点，所以添加事件只能添加到这个canvas上，canvas里边的图形要响应事件稍微复杂些。这里用到了canvas提供的api isPointInPath,这个api可能会有兼容性问题，但本次还是基于这个api实现。笔者这次只实现了mousedown事件的基础功能，而且图形是固定的，先看看实现的这个事件监听类：1234567891011121314151617181920212223242526272829303132333435363738394041/** * @desc canvas事件处理类 * @params canvas 要监听的图形所在canvas * @method pushPath 监听图形 * @method iteratorRegsions 便利所要监听的所有图形 */ function RegsionEvt(canvas) &#123; this.canvas = document.createElement(&apos;canvas&apos;); this.canvas.width = canvas.width; this.canvas.height = canvas.height; this.ctx = this.canvas.getContext(&quot;2d&quot;); this.arr = []; /** * option.shapType 类型 * option.x * option.y * option.width * option.height * option.evtName * option.CallBack */ this.pushPath = function(option) &#123; this.arr.push(option); &#125; /** * evtName 事件名 * evt 事件对象 */ this.iteratorRegsions = function(evtName, evt) &#123; this.arr.forEach(function(item) &#123; this.ctx.beginPath(); if(item.shapType===&apos;rect&apos; &amp;&amp; item.evtName===evtName) &#123; this.ctx.rect(item.x, item.y, item.width, item.height); if(this.ctx.isPointInPath(evt.layerX, evt.layerY)) &#123; item.CallBack(evt); &#125; &#125; this.ctx.closePath(); &#125;); &#125; &#125; 使用的时候，new一个实例，构造函数参数是要监听的图形所在的canvas，添加图形事件需要调用pushPath方法，触发事件的时候需要循环遍历添加了事件的图形，方法是iteratorRegsions。最后，附上一个demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;canvas-event&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;300&quot; style=&quot;display: block; border: 1px solid #cccccc; margin: 50px auto;&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var nCanvas = document.getElementById(&apos;canvas&apos;); var ctx = nCanvas.getContext(&quot;2d&quot;); var regsion = new RegsionEvt(nCanvas); ctx.beginPath(); ctx.rect(50, 50, 100, 100); ctx.fillStyle = &apos;red&apos;; ctx.fill(); regsion.pushPath(&#123; shapType: &apos;rect&apos;, evtName: &apos;mousedown&apos;, x: 50, y: 50, width: 100, height: 100, CallBack: function(evt) &#123; console.log(&apos;红色box被点击了&apos;); &#125; &#125;); ctx.beginPath(); ctx.rect(250, 150, 100, 100); ctx.fillStyle = &apos;yellow&apos;; ctx.fill(); regsion.pushPath(&#123; shapType: &apos;rect&apos;, evtName: &apos;mousedown&apos;, x: 250, y: 150, width: 100, height: 100, CallBack: function(evt) &#123; console.log(&apos;黄色box被点击了&apos;); &#125; &#125;); ctx.beginPath(); ctx.rect(350, 50, 50, 50); ctx.fillStyle = &apos;green&apos;; ctx.fill(); regsion.pushPath(&#123; shapType: &apos;rect&apos;, evtName: &apos;mousedown&apos;, x: 350, y: 50, width: 50, height: 50, CallBack: function(evt) &#123; console.log(&apos;绿色box被点击了&apos;); &#125; &#125;); nCanvas.onmousedown = function(evt) &#123; regsion.iteratorRegsions(&apos;mousedown&apos;, evt); &#125; /** * @desc canvas事件处理类 * @params canvas 要监听的图形所在canvas * @method pushPath 监听图形 * @method iteratorRegsions 便利所要监听的所有图形 */ function RegsionEvt(canvas) &#123; this.canvas = document.createElement(&apos;canvas&apos;); this.canvas.width = canvas.width; this.canvas.height = canvas.height; this.ctx = this.canvas.getContext(&quot;2d&quot;); this.arr = []; /** * option.shapType 类型 * option.x * option.y * option.width * option.height * option.evtName * option.CallBack */ this.pushPath = function(option) &#123; this.arr.push(option); &#125; /** * evtName 事件名 * evt 事件对象 */ this.iteratorRegsions = function(evtName, evt) &#123; this.arr.forEach(function(item) &#123; this.ctx.beginPath(); if(item.shapType===&apos;rect&apos; &amp;&amp; item.evtName===evtName) &#123; this.ctx.rect(item.x, item.y, item.width, item.height); if(this.ctx.isPointInPath(evt.layerX, evt.layerY)) &#123; item.CallBack(evt); &#125; &#125; this.ctx.closePath(); &#125;); &#125; &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"碰撞检测","slug":"碰撞检测","date":"2021-02-19T07:18:03.000Z","updated":"2024-06-28T02:20:01.342Z","comments":true,"path":"2021/02/19/碰撞检测/","link":"","permalink":"/2021/02/19/碰撞检测/","excerpt":"图形或dom元素碰撞检测","text":"图形或dom元素碰撞检测 碰撞检测碰撞检测在游戏开发中是肯定会用到的，检测两个物体是否碰撞，其实非常简单,用一个方法就可以搞定：12345678function haveIntersection(r1, r2) &#123; return !( r2.x &gt; r1.x + r1.width || r2.x + r2.width &lt; r1.x || r2.y &gt; r1.y + r1.height || r2.y + r2.height &lt; r1.y ); &#125; 这个方法传入两个对象，返回true就是碰撞了，反之就没碰撞。再来一个demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;collision&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .wrap &#123; position: relative; width: 700px; height: 300px; border: 1px solid #cccccc; &#125; .box1, .box2 &#123; position: absolute; width: 100px; height: 100px; &#125; .box1 &#123; top: 0; left: 0; background-color: green; z-index: 2; &#125; .box2 &#123; top: 100px; right: 300px; background-color: brown; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 工具函数 // 获取style function getStyle(element, attr) &#123; var computed; if(element.currentStyle) &#123; computed = element.currentStyle; &#125; else &#123; computed = window.getComputedStyle(element, false); &#125; return computed.getPropertyValue( attr ) || computed[ attr ]; &#125; // 判断两个物体是否碰撞 function haveIntersection(r1, r2) &#123; return !( r2.x &gt; r1.x + r1.width || r2.x + r2.width &lt; r1.x || r2.y &gt; r1.y + r1.height || r2.y + r2.height &lt; r1.y ); &#125;&lt;/script&gt;&lt;script&gt; // 获取节点对象 var box1 = document.querySelector(&apos;.box1&apos;); var box2 = document.querySelector(&apos;.box2&apos;); // box1和box2的信息 box1Obj = &#123; x: parseInt(getStyle(box1, &apos;left&apos;)), y: parseInt(getStyle(box1, &apos;top&apos;)), width: parseInt(getStyle(box1, &apos;width&apos;)), height: parseInt(getStyle(box1, &apos;height&apos;)), &#125; box2Obj = &#123; x: parseInt(getStyle(box2, &apos;left&apos;)), y: parseInt(getStyle(box2, &apos;top&apos;)), width: parseInt(getStyle(box2, &apos;width&apos;)), height: parseInt(getStyle(box2, &apos;height&apos;)), &#125; // 鼠标按下对象 mouseDownObj = &#123; x: 0, y: 0 &#125; // 给box1添加拖拽事件 box1.onmousedown = function(evt) &#123; mouseDownObj.x = evt.pageX; mouseDownObj.y = evt.pageY; box1.onmousemove = function(evt) &#123; box1.style.left = box1Obj.x + evt.pageX - mouseDownObj.x + &apos;px&apos;; box1.style.top = box1Obj.y + evt.pageY - mouseDownObj.y + &apos;px&apos;; var currentBox1Obj = &#123; x: parseInt(getStyle(box1, &apos;left&apos;)), y: parseInt(getStyle(box1, &apos;top&apos;)), width: box1Obj.width, height: box1Obj.height &#125; var bCollision = haveIntersection(currentBox1Obj, box2Obj); console.log(bCollision); &#125; &#125; document.onmouseup = function(evt) &#123; box1.onmousemove = Function.prototype; box1Obj.x = parseInt(getStyle(box1, &apos;left&apos;)); box1Obj.y = parseInt(getStyle(box1, &apos;top&apos;)); &#125;&lt;/script&gt;&lt;/html&gt; 以下内容2024.2.6添加 判断点是否在长方形内需求不复杂可使用123456789101112const queryPtInPolygon_ = function(point, polygon) &#123; let flag = true; if( point.x &lt; polygon[0].x || point.x &gt; polygon[1].x || point.y &lt; polygon[0].y || point.y &gt; polygon[2].y ) &#123; flag = false; &#125; return flag;&#125; 判断点是否在不规则图形内12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const queryPtInPolygon = function(point, polygon) &#123; //下述代码来源：http://paulbourke.net，进行了部分修改 //基本思想是利用射线法，计算射线与多边形各边的交点，如果是偶数，则点在多边形外，否则 //在多边形内。还会考虑一些特殊情况，如点在多边形顶点上，点在多边形边上等特殊情况。 var N = polygon.length; var boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true var intersectCount = 0; //cross points count of x var precision = 2e-10; //浮点类型计算时候与0比较时候的容差 var p1, p2; //neighbour bound vertices var p = point; //测试点 p1 = polygon[0]; //left vertex for (var i = 1; i &lt;= N; ++i) &#123; //check all rays if (p.x == p1.x &amp;&amp; p.y == p1.y) &#123; return boundOrVertex; //p is an vertex &#125; p2 = polygon[i % N]; //right vertex if (p.y &lt; Math.min(p1.y, p2.y) || p.y &gt; Math.max(p1.y, p2.y)) &#123; //ray is outside of our interests p1 = p2; continue; //next ray left point &#125; if (p.y &gt; Math.min(p1.y, p2.y) &amp;&amp; p.y &lt; Math.max(p1.y, p2.y)) &#123; //ray is crossing over by the algorithm (common part of) if (p.x &lt;= Math.max(p1.x, p2.x)) &#123; //x is before of ray if (p1.y == p2.y &amp;&amp; p.x &gt;= Math.min(p1.x, p2.x)) &#123; //overlies on a horizontal ray return boundOrVertex; &#125; if (p1.x == p2.x) &#123; //ray is vertical if (p1.x == p.x) &#123; //overlies on a vertical ray return boundOrVertex; &#125; else &#123; //before ray ++intersectCount; &#125; &#125; else &#123; //cross point on the left side var xinters = (p.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x; //cross point of x if (Math.abs(p.x - xinters) &lt; precision) &#123; //overlies on a ray return boundOrVertex; &#125; if (p.x &lt; xinters) &#123; //before ray ++intersectCount; &#125; &#125; &#125; &#125; else &#123; //special case when ray is crossing through the vertex if (p.y == p2.y &amp;&amp; p.x &lt;= p2.x) &#123; //p crossing over p2 var p3 = polygon[(i + 1) % N]; //next vertex if (p.y &gt;= Math.min(p1.y, p3.y) &amp;&amp; p.y &lt;= Math.max(p1.y, p3.y)) &#123; //p.y lies between p1.y &amp; p3.y ++intersectCount; &#125; else &#123; intersectCount += 2; &#125; &#125; &#125; p1 = p2; //next ray left point &#125; if (intersectCount % 2 == 0) &#123; //偶数在多边形外 return false; &#125; else &#123; //奇数在多边形内 return true; &#125;&#125; 判断一个多边形是否完全在另一个多边形内部12345678910111213141516export const queryPlgInPlg = function(inPlg, outPlg) &#123; let flag = true; for(let i=0, len=inPlg.length; i&lt;len; i++) &#123; if(!queryPtInPolygon(inPlg[i], outPlg)) &#123; flag = false; break ; &#125; &#125; for(let i=0, len=outPlg.length; i&lt;len; i++) &#123; if(queryPtInPolygon(outPlg[i], inPlg)) &#123; flag = false; break ; &#125; &#125; return flag;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"vue-cli多页面项目","slug":"vue-cli多页面项目","date":"2021-02-10T01:13:26.000Z","updated":"2024-01-11T07:00:59.232Z","comments":true,"path":"2021/02/10/vue-cli多页面项目/","link":"","permalink":"/2021/02/10/vue-cli多页面项目/","excerpt":"vue-cli多页面项目配置","text":"vue-cli多页面项目配置 vue-cli多页面项目vue-cli创建vue项目非常方便，在vue-cli基础上创建多页面应用，官网也给出了配置（多页面配置）。笔者按照这个配置，又加入了一些常用的工具，完成了一个demo项目，在实际的工作中可以直接下载下来进行开发。demo地址","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"文字跑马灯","slug":"文字跑马灯","date":"2021-02-07T01:10:25.000Z","updated":"2024-01-11T07:00:59.272Z","comments":true,"path":"2021/02/07/文字跑马灯/","link":"","permalink":"/2021/02/07/文字跑马灯/","excerpt":"文字跑马灯效果","text":"文字跑马灯效果 文字跑马灯笔者在开发移动端，因为移动端的屏幕较小，在展示文字的时候，比如说一个区域有5个文字，效果图展示没有问题，但是实际的数据可能是10个或者更多文字，如果折行就不美观，不折行又显示不下。加上省略号看起来美观些，但是还是看不全文字，所以跑马灯效果是一个很好的解决方案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;跑马灯效果&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;div-wrap&quot; style=&quot;width:100px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; /** * @desc 文字跑马灯 * @param &#123;domNode&#125; [Element] ele 文字外容器dom * @param &#123;offSetLeft&#125; [Number] offSetLeft 文字跑动距离左侧容器距离 * @param &#123;text&#125; [String] 文字 */ function RunChar(ele, offSetLeft, text) &#123; this.ele = ele; this.text = text; this.init = function() &#123; let nSpan = document.createElement(&apos;span&apos;); let nText = document.createTextNode(text); nSpan.appendChild(nText); this.ele.appendChild(nSpan); // css this.ele.style[&apos;white-space&apos;] = &apos;nowrap&apos;; this.ele.style[&apos;overflow&apos;] = &apos;hidden&apos;; nSpan.style[&apos;display&apos;] = &apos;inline-block&apos;; let wrapWidth = Math.ceil(parseFloat(this.getStyle(this.ele, &apos;width&apos;))); let spanWidth = Math.ceil(parseFloat(this.getStyle(nSpan, &apos;width&apos;))); if(spanWidth &gt; wrapWidth) &#123; let w = spanWidth - wrapWidth; let moveVal = 0; setInterval(function() &#123; nSpan.style.transform = `translateX($&#123;moveVal--&#125;px)`; if(moveVal &lt;= -(w+offSetLeft)) moveVal = offSetLeft; &#125;, 100); &#125; &#125; this.getStyle = function(element, attr) &#123; var computed; if(element.currentStyle) &#123; computed = element.currentStyle; &#125; else &#123; computed = window.getComputedStyle(element, false); &#125; return computed.getPropertyValue( attr ) || computed[ attr ]; &#125; this.init(); &#125; new RunChar(document.querySelector(&apos;.div-wrap&apos;), 100, &apos;文字跑马灯效果&apos;);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"图片压缩","slug":"图片压缩","date":"2021-02-03T05:55:03.000Z","updated":"2024-01-11T07:00:59.263Z","comments":true,"path":"2021/02/03/图片压缩/","link":"","permalink":"/2021/02/03/图片压缩/","excerpt":"前端图片压缩处理","text":"前端图片压缩处理 图片压缩笔者在日常开发中，有时候会遇到上传图片接口限制大小，所以需要对图片进行压缩。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;image-compress&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;input&quot; type=&quot;file&quot; accept=&quot;image/*&quot; /&gt;&lt;/body&gt;&lt;script&gt; let nInput = document.querySelector(&apos;#input&apos;); nInput.onchange = function(ev) &#123; let file = this.files[0]; imgCompress(&#123; file: file, maxWidth: 300, maxHeight: 300, callback: function(dataURL) &#123; console.log(dataURL); &#125; &#125;); &#125; /** * @desc 将图片ev.target.files[0]格式直接压缩转换成base64格式 * @param option.file 原图片文件 * @param option.maxWidth 图片需要压缩的最大宽度 * @param option.maxHeight 图片需要压缩的最大高度 * @param option.callback 回调函数，参数是dataURL */ function imgCompress(option) &#123; var file = option.file; // 图片file var maxWidth = option.maxWidth; // 图片需要压缩的最大宽度 var maxHeight = option.maxHeight; // 图片需要压缩的最大高度 var originWidth, originHeight; // 原图片宽高 var targetWidth, targetHeight; // 目标图片宽高 var dataURL; // 最后转化成的base64图片 var img = new Image(); var reader = new FileReader(); reader.readAsDataURL(file) reader.onload = function(e)&#123; img.src = e.target.result; &#125; img.onload = function() &#123; targetWidth = originWidth = img.width; targetHeight = originHeight = img.height; // 等比例计算超过最大限制时缩放后的图片尺寸 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123; if (originWidth / originHeight &gt; 1) &#123; // 宽图片 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); &#125; else &#123; // 高图片 targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); &#125; &#125; // 创建画布 var canvas = document.createElement(&apos;canvas&apos;); var context = canvas.getContext(&apos;2d&apos;); // 设置宽高度为等同于要压缩图片的尺寸 canvas.width = targetWidth; canvas.height = targetHeight; context.clearRect(0, 0, targetWidth, targetHeight); //将img绘制到画布上 context.drawImage(img, 0, 0, targetWidth, targetHeight); dataURL = canvas.toDataURL(&apos;image/jpeg&apos;); option.callback&amp;&amp;option.callback(dataURL); &#125; &#125; &lt;/script&gt;&lt;/html&gt; 总结这个压缩工具是传入file格式图片数据，返回base64格式数据，如果需要其他格式，可以配合格式转换进行处理。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"h5移动端常见开发总结","slug":"h5移动端常见开发总结","date":"2021-01-28T01:57:04.000Z","updated":"2024-01-11T07:00:59.189Z","comments":true,"path":"2021/01/28/h5移动端常见开发总结/","link":"","permalink":"/2021/01/28/h5移动端常见开发总结/","excerpt":"移动端开发的常见问题汇总","text":"移动端开发的常见问题汇总 h5移动端常见开发总结html调用系统功能使用&lt;a&gt;能快速调用移动设备的电话/短信/邮件三大通讯功能，使用&lt;input&gt;能快速调用移动设备的的图库/文件。这些功能方便了页面与系统的交互，关键在于调用格式一定要准确，否则会被移动端浏览器忽略。1234567891011121314151617&lt;!-- 拨打电话 --&gt;&lt;a href=&quot;tel:10086&quot;&gt;拨打电话给10086小姐姐&lt;/a&gt;&lt;!-- 发送短信 --&gt;&lt;a href=&quot;sms:10086&quot;&gt;发送短信给10086小姐姐&lt;/a&gt;&lt;!-- 发送邮件 --&gt;&lt;a href=&quot;mailto:young.joway@aliyun.com&quot;&gt;发送邮件给JowayYoung&lt;/a&gt;&lt;!-- 选择照片或拍摄照片 --&gt;&lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt;&lt;!-- 选择视频或拍摄视频 --&gt;&lt;input type=&quot;file&quot; accept=&quot;video/*&quot;&gt;&lt;!-- 多选文件 --&gt;&lt;input type=&quot;file&quot; multiple&gt; 忽略自动识别有些移动端浏览器会自动将数字字母符号识别为电话/邮箱并将其渲染成上述「调用系统功能」里的&lt;a&gt;。虽然很方便却有可能违背需求。12345678&lt;!-- 忽略自动识别电话 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;!-- 忽略自动识别邮箱 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;&lt;!-- 忽略自动识别电话和邮箱 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot;&gt; 弹出数字键盘使用&lt;input type=&quot;tel&quot;&gt;弹起数字键盘会带上#和*，适合输入电话。推荐使用1&lt;input type=&quot;number&quot; pattern=&quot;\\d*&quot;&gt; 弹起数字键盘，适合输入验证码等纯数字格式。12345&lt;!-- 纯数字带#和* --&gt;&lt;input type=&quot;tel&quot;&gt;&lt;!-- 纯数字 --&gt;&lt;input type=&quot;number&quot; pattern=&quot;\\d*&quot;&gt; 唤醒原生应用通过location.href与原生应用建立通讯渠道，这种页面与客户端的通讯方式称为「URL Scheme」，其基本格式为scheme://[path][?query]。123「scheme」：应用标识，表示应用在系统里的唯一标识「path」：应用行为，表示应用某个页面或功能「query」：应用参数，表示应用页面或应用功能所需的条件参数 URL Scheme一般由前端与客户端共同协商。唤醒原生应用的前提是必须在移动设备里安装了该应用，有些移动端浏览器即使安装了该应用也无法唤醒原生应用，因为它认为URL Scheme是一种潜在的危险行为而禁用它，像Safari和微信浏览器。还好微信浏览器可开启白名单让URL Scheme有效。若在页面引用第三方原生应用的URL Schema，可通过抓包第三方原生应用获取其URL。1234567891011&lt;!-- 打开微信 --&gt;&lt;a href=&quot;weixin://&quot;&gt;打开微信&lt;/a&gt;&lt;!-- 打开支付宝 --&gt;&lt;a href=&quot;alipays://&quot;&gt;打开支付宝&lt;/a&gt;&lt;!-- 打开支付宝的扫一扫 --&gt;&lt;a href=&quot;alipays://platformapi/startapp?saId=10000007&quot;&gt;打开支付宝的扫一扫&lt;/a&gt;&lt;!-- 打开支付宝的蚂蚁森林 --&gt;&lt;a href=&quot;alipays://platformapi/startapp?appId=60000002&quot;&gt;打开支付宝的蚂蚁森林&lt;/a&gt; 禁止页面缩放在智能手机的普及下，很多网站都具备桌面端和移动端两种浏览版本，因此无需双击缩放查看页面。禁止页面缩放可保障移动端浏览器能无遗漏地展现页面所有布局。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt; 禁止页面缓存「Cache-Control」指定请求和响应遵循的缓存机制，不想使用浏览器缓存就禁止呗！1&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot;&gt; 禁止字母大写有时在输入框里输入文本会默认开启首字母大写纠正，就是输入首字母小写会被自动纠正成大写，特么的烦。直接声明autocapitalize=off关闭首字母大写功能和autocorrect=off关闭纠正功能。1&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot;&gt; 针对Safari配置一些Safari较零散且少用的配置1234567891011121314&lt;!-- 设置Safari全屏，在iOS7+无效 --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;!-- 改变Safari状态栏样式，可选default/black/black-translucent，需在上述全屏模式下才有效 --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;!-- 添加页面启动占位图 --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;pig.jpg&quot; media=&quot;(device-width: 375px)&quot;&gt;&lt;!-- 保存网站到桌面时添加图标 --&gt;&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;76x76&quot; href=&quot;pig.jpg&quot;&gt;&lt;!-- 保存网站到桌面时添加图标且清除默认光泽 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;pig.jpg&quot;&gt; 针对其他浏览器配置贴一些其他浏览器较零散且少用的配置，主要是常用的QQ浏览器、UC浏览器和360浏览器。从网易MTL的测试数据得知，新版的QQ浏览器和UC浏览器已不支持以下&lt;meta&gt;声明了。1234567891011121314151617181920&lt;!-- 强制QQ浏览器竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制QQ浏览器全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- 开启QQ浏览器应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- 强制UC浏览器竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- 强制UC浏览器全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- 开启UC浏览器应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- 开启360浏览器极速模式 --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 让:active有效，让:hover无效有些元素的:active可能会无效，而元素的:hover在点击后会一直处于点击状态，需点击其他位置才能解除点击状态。给&lt;body&gt;注册一个空的touchstart事件可将两种状态反转。1&lt;body ontouchstart&gt;&lt;/body&gt; CSS方向自动适应布局针对移动端，笔者通常会结合JS依据屏幕宽度与设计图宽度的比例动态声明的font-size，以rem为长度单位声明所有节点的几何属性，这样就能做到大部分移动设备的页面兼容，兼容出入较大的地方再通过媒体查询做特别处理。笔者通常将rem布局比例设置成1rem=100px，即在设计图上100px长度在CSS代码上使用1rem表示。12345678910function AutoResponse(width = 750) &#123; const target = document.documentElement; if (target.clientWidth &gt;= 600) &#123; target.style.fontSize = &quot;80px&quot;; &#125; else &#123; target.style.fontSize = target.clientWidth / width * 100 + &quot;px&quot;; &#125;&#125;AutoResponse();window.addEventListener(&quot;resize&quot;, () =&gt; AutoResponse()); 当然还可依据屏幕宽度与设计图宽度的比例使用calc()动态声明的font-size，这样就能节省上述代码。不对，是完全代替上述代码。123html &#123; font-size: calc(100vw / 7.5);&#125; 若以iPad Pro分辨率1024px为移动端和桌面端的断点，还可结合媒体查询做断点处理。1024px以下使用rem布局，否则不使用rem布局。12345@media screen and (max-width: 1024px) &#123; html &#123; font-size: calc(100vw / 7.5); &#125;&#125; 自动适应背景使用rem布局声明一个元素背景，多数情况会将background-size声明为cover。可能在设计图对应分辨率的移动设备下，背景会完美贴合显示，但换到其他分辨率的移动设备下就会出现左右空出1px到npx的空隙。此时将background-size声明为100% 100%，跟随width和height的变化而变化。反正width和height都是量好的实际尺寸。12345.elem &#123; width: 1rem; height: 1rem; background: url(&quot;pig.jpg&quot;) no-repeat center/100% 100%;&#125; 监听屏幕旋转你还在使用JS判断横屏竖屏调整样式吗？那就真的Out了。12345678/* 竖屏 */@media all and (orientation: portrait) &#123; /* 自定义样式 */&#125;/* 横屏 */@media all and (orientation: landscape) &#123; /* 自定义样式 */&#125; 支持弹性滚动在苹果系统上非&lt;body&gt;元素的滚动操作可能会存在卡顿，但安卓系统不会出现该情况。通过声明overflow-scrolling:touch调用系统原生滚动事件优化弹性滚动，增加页面滚动的流畅度。123456body &#123; -webkit-overflow-scrolling: touch;&#125;.elem &#123; overflow: auto;&#125; 禁止滚动传播与桌面端浏览器不一样，移动端浏览器有一个奇怪行为。当页面包含多个滚动区域时，滚完一个区域后若还存在滚动动量则会将这些剩余动量传播到下一个滚动区域，造成该区域也滚动起来。这种行为称为「滚动传播」。若不想产生这种奇怪行为可直接禁止。123.elem &#123; overscroll-behavior: contain;&#125; 禁止屏幕抖动对于一些突然出现滚动条的页面，可能会产生左右抖动的不良影响。在一个滚动容器里，打开弹窗就隐藏滚动条，关闭弹窗就显示滚动条，来回操作会让屏幕抖动起来。提前声明滚动容器的padding-right为滚动条宽度，就能有效消除这个不良影响。每个移动端浏览器的滚动条宽度都有可能不一致，甚至不一定占位置，通过以下方式能间接计算出滚动条的宽度。100vw为视窗宽度，100%为滚动容器内容宽度，相减就是滚动条宽度，妥妥的动态计算。123body &#123; padding-right: calc(100vw - 100%);&#125; 禁止长按操作有时不想用户长按元素呼出菜单进行点链接、打电话、发邮件、保存图片或扫描二维码等操作，声明touch-callout:none禁止用户长按操作。有时不想用户复制粘贴盗文案，声明user-select:none禁止用户长按操作和选择复制。12345* &#123; /* pointer-events: none; */ /* 微信浏览器还需附加该属性才有效 */ user-select: none; /* 禁止长按选择文字 */ -webkit-touch-callout: none;&#125; 但声明user-select:none会让&lt;input&gt;和&lt;textarea&gt;无法输入文本，可对其声明user-select:auto排除在外。1234input,textarea &#123; user-select: auto;&#125; 禁止字体调整旋转屏幕可能会改变字体大小，声明text-size-adjust:100%让字体大小保持不变。123* &#123; text-size-adjust: 100%;&#125; 禁止高亮显示触摸元素会出现半透明灰色遮罩，不想要！123* &#123; -webkit-tap-highlight-color: transparent;&#125; 禁止动画闪屏在移动设备上添加动画，多数情况会出现闪屏，给动画元素的父元素构造一个3D环境就能让动画稳定运行了。12345.elem &#123; perspective: 1000; backface-visibility: hidden; transform-style: preserve-3d;&#125; 美化表单外观表单元素样式太丑希望自定义，appearance:none来帮你。1234567button,input,select,textarea &#123; appearance: none; /* 自定义样式 */&#125; 美化滚动占位滚动条样式太丑希望自定义，::-webkit-scrollbar-*来帮你。记住以下三个关键词就能随机应变了。[x] 「::-webkit-scrollbar」：滚动条整体部分[x] 「::-webkit-scrollbar-track」：滚动条轨道部分[x] 「::-webkit-scrollbar-thumb」：滚动条滑块部分123456789101112::-webkit-scrollbar &#123; width: 6px; height: 6px; background-color: transparent;&#125;::-webkit-scrollbar-track &#123; background-color: transparent;&#125;::-webkit-scrollbar-thumb &#123; border-radius: 3px; background-image: linear-gradient(135deg, #09f, #3c9);&#125; 美化输入占位输入框占位文本太丑，::-webkit-input-placeholder来帮你。123input::-webkit-input-placeholder &#123; color: #66f;&#125; 对齐输入占位有强迫症的同学总会觉得输入框文本位置整体偏上，感觉未居中心里就痒痒的。桌面端浏览器里声明line-height等于height就能解决，但移动端浏览器里还是未能解决，需将line-height声明为normal才行。123input &#123; line-height: normal;&#125; 对齐下拉选项下拉框选项默认向左对齐，是时候改改向右对齐了。123select option &#123; direction: rtl;&#125; 修复点击无效在苹果系统上有些情况下非可点击元素监听click事件可能会无效，针对该情况只需对不触发click事件的元素声明cursor:pointer就能解决。123.elem &#123; cursor: pointer;&#125; 识别文本换行多数情况会使用JS换行文本，那就真的Out了。若接口返回字段包含\\n或&lt;br&gt;，千万别替换掉，可声明white-space:pre-line交由浏览器做断行处理。123* &#123; white-space: pre-line;&#125; 开启硬件加速想动画更流畅吗，开启GPU硬件加速呗！1234.elem &#123; transform: translate3d(0, 0, 0); /* transform: translateZ(0); */&#125; 描绘像素边框万年话题，如何描绘一像素边框？12345678910111213141516.elem &#123; position: relative; width: 200px; height: 80px; &amp;::after &#123; position: absolute; left: 0; top: 0; border: 1px solid #f66; width: 200%; height: 200%; content: &quot;&quot;; transform: scale(.5); transform-origin: left top; &#125;&#125; 控制溢出文本万年话题，如何控制文本做单行溢出和多行溢出？1234567891011121314151617.elem &#123; width: 400px; line-height: 30px; font-size: 20px; &amp;.sl-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; &amp;.ml-ellipsis &#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 3; -webkit-box-orient: vertical; &#125;&#125; JS方向禁止点击穿透移动端浏览器里点击操作会存在300ms延迟，往往会造成点击延迟甚至点击无效，这个是众所周知的事情。2007年苹果发布首款iPhone搭载的Safari为了将桌面端网站能较好地展示在移动端浏览器上而使用了双击缩放。该方案就是上述300ms延迟的主要原因，当用户执行第一次单击后会预留300ms检测用户是否继续执行单击，若是则执行缩放操作，若否则执行点击操作。鉴于该方案的成功，其他移动端浏览器也复制了该方案，现在几乎所有移动端浏览器都配备该功能。而该方案引发的点击延迟被称为「点击穿透」。在前端领域里最早解决点击穿透是jQuery时代的zepto，估计现在大部分同学都未使用过zepto，其实它就是移动端版本的jquery。zepto封装tap事件能有效地解决点击穿透，通过监听document上的touch事件完成tap事件的模拟，并将tap事件冒泡到document上触发。在移动端浏览器上不使用click事件而使用touch事件是因为click事件有着明显的延迟，后续又出现fastclick。该解决方案监听用户是否做了双击操作，可正常使用click事件，而点击穿透就交给fastclick自动判断。更多fastclick原理可自行百度，在此不作过多介绍。fastclick有现成的NPM包，可直接安装到项目里。引入fastclick可使用click事件代替tap事件，接入方式极其简单。123import Fastclick from &quot;fastclick&quot;;FastClick.attach(document.body); 禁止滑动穿透移动端浏览器里出现弹窗时，若在屏幕上滑动能触发弹窗底下的内容跟着滚动，这个是众所周知的事情。首先明确解决滑动穿透需保持哪些交互行为，那就是除了弹窗内容能点击或滚动，其他内容都不能点击或滚动。目前很多解决方案都无法做到这一点，全部解决方案都能禁止&lt;body&gt;的滚动行为却引发其他问题。 弹窗打开后内部内容无法滚动 弹窗关闭后页面滚动位置丢失 Webview上下滑动露出底色 当打开弹窗时给&lt;body&gt;声明position:fixed;left:0;width:100%并动态声明top。声明position:fixed会导致&lt;body&gt;滚动条消失，此时会发现虽然无滑动穿透，但页面滚动位置早已丢失。通过scrollingElement获取页面当前滚动条偏移量并将其赋值给top，那么在视觉上就无任何变化。当关闭弹窗时移除position:fixed;left:0;width:100%和动态top。scrollingElement可兼容地获取scrollTop和scrollHeight等属性，在移动端浏览器里屡试不爽。document.scrollingElement.scrollHeight可完美代替曾经的document.documentElement.scrollHeight || document.body.scrollHeight，一眼看上去就是代码减少了。该解决方案在视觉上无任何变化，完爆其他解决方案，其实就是一种反向思维和障眼法。该解决方案完美解决固定弹窗和滚动弹窗对&lt;body&gt;全局滚动的影响，当然也可用于局部滚动容器里，因此很值得推广。12345body.static &#123; position: fixed; left: 0; width: 100%;&#125; 1234567891011121314const body = document.body;const openBtn = document.getElementById(&quot;open-btn&quot;);const closeBtn = document.getElementById(&quot;close-btn&quot;);openBtn.addEventListener(&quot;click&quot;, e =&gt; &#123; e.stopPropagation(); const scrollTop = document.scrollingElement.scrollTop; body.classList.add(&quot;static&quot;); body.style.top = `-$&#123;scrollTop&#125;px`;&#125;);closeBtn.addEventListener(&quot;click&quot;, e =&gt; &#123; e.stopPropagation(); body.classList.remove(&quot;static&quot;); body.style.top = &quot;&quot;;&#125;); 支持往返刷新点击移动端浏览器的前进按钮或后退按钮，有时不会自动执行旧页面的JS代码，这与往返缓存有关。这种情况在Safari上特别明显，简单概括就是往返页面无法刷新。「往返缓存」指浏览器为了在页面间执行前进后退操作时能拥有更流畅体验的一种策略，以下简称BFCache。该策略具体表现为：当用户前往新页面前将旧页面的DOM状态保存在BFCache里，当用户返回旧页面前将旧页面的DOM状态从BFCache里取出并加载。大部分移动端浏览器都会部署BFCache，可大大节省接口请求的时间和带宽。pageshow事件在每次页面加载时都会触发，无论是首次加载还是再次加载都会触发。pageshow事件暴露的persisted可判断页面是否从BFCache里取出。1window.addEventListener(&quot;pageshow&quot;, e =&gt; e.persisted &amp;&amp; location.reload()); 解析有效日期在苹果系统上解析YYYY-MM-DD HH:mm:ss这种日期格式会报错Invalid Date，但在安卓系统上解析这种日期格式完全无问题。1new Date(&quot;2019-03-31 21:30:00&quot;); // Invalid Date 查看Safari相关开发手册发现可用YYYY/MM/DD HH:mm:ss这种日期格式，简单概括就是年月日必须使用/衔接而不能使用-衔接。当然安卓系统也支持该格式，然而接口返回字段的日期格式通常是YYYY-MM-DD HH:mm:ss，那么需替换其中的-为/。 const date = “2019-03-31 21:30:00”;new Date(date.replace(/-/g, “/“)); 修复高度坍塌当页面同时出现以下三个条件时，键盘占位会把页面高度压缩一部分。当输入完成键盘占位消失后，页面高度有可能回不到原来高度，产生坍塌导致Webview底色露脸，简单概括就是输入框失焦后页面未回弹。 页面高度过小 输入框在页面底部或视窗中下方 输入框聚焦输入文本 只要保持前后滚动条偏移量一致就不会出现上述问题。在输入框聚焦时获取页面当前滚动条偏移量，在输入框失焦时赋值页面之前获取的滚动条偏移量，这样就能间接还原页面滚动条偏移量解决页面高度坍塌。12345678const input = document.getElementById(&quot;input&quot;);let scrollTop = 0;input.addEventListener(&quot;focus&quot;, () =&gt; &#123; scrollTop = document.scrollingElement.scrollTop;&#125;);input.addEventListener(&quot;blur&quot;, () =&gt; &#123; document.scrollingElement.scrollTo(0, scrollTop);&#125;); 修复输入监听在苹果系统上的输入框输入文本，keyup/keydown/keypress事件可能会无效。当输入框监听keyup事件时，逐个输入英文和数字会有效，但逐个输入中文不会有效，需按回车键才会有效。此时可用input事件代替输入框的keyup/keydown/keypress事件。 简化回到顶部曾几何时编写一个返回顶部函数麻烦得要死，需scrollTop、定时器和条件判断三者配合才能完成。其实DOM对象里隐藏了一个很好用的函数可完成上述功能，一行核心代码就能搞定。该函数就是scrollIntoView，它会滚动目标元素的父容器使之对用户可见，简单概括就是相对视窗让容器滚动到目标元素位置。它有三个可选参数能让scrollIntoView滚动起来更优雅。「behavior」：动画过渡效果，默认auto无，可选smooth平滑「inline」：水平方向对齐方式，默认nearest就近对齐，可选start顶部对齐、center中间对齐和end底部对齐「block」：垂直方向对齐方式，默认start顶部对齐，可选center中间对齐、end底部对齐和nearest就近对齐12const gotopBtn = document.getElementById(&quot;gotop-btn&quot;);openBtn.addEventListener(&quot;click&quot;, () =&gt; document.body.scrollIntoView(&#123; behavior: &quot;smooth&quot; &#125;)); 当然还可滚动到目标元素位置，只需将document.body修改成目标元素的DOM对象。一行核心代码就能搞掂的事情为何还编写那么多代码去完成，不累吗？ 简化懒性加载与上述「简化回到顶部」一样，编写一个懒性加载函数也同样需scrollTop、定时器和条件判断三者配合才能完成。其实DOM对象里隐藏了一个很好用的函数可完成上述功能，该函数无需监听容器的scroll事件，通过浏览器自身机制完成滚动监听。该函数就是IntersectionObserver，它提供一种异步观察目标元素及其祖先元素或顶级文档视窗交叉状态的方法。详情可参照MDN文档，在此不作过多介绍。懒性加载的第一种使用场景：「图片懒加载」。只需确认图片进入可视区域就赋值加载图片，赋值完成还需对图片停止监听。12&lt;img data-src=&quot;pig.jpg&quot;&gt;&lt;!-- 很多&lt;img&gt; --&gt; 12345678910const imgs = document.querySelectorAll(&quot;img.lazyload&quot;);const observer = new IntersectionObserver(nodes =&gt; &#123; nodes.forEach(v =&gt; &#123; if (v.isIntersecting) &#123; // 判断是否进入可视区域 v.target.src = v.target.dataset.src; // 赋值加载图片 observer.unobserve(v.target); // 停止监听已加载的图片 &#125; &#125;);&#125;);imgs.forEach(v =&gt; observer.observe(v)); 懒性加载的第二种使用场景：「下拉加载」。在列表最底部部署一个占位元素且该元素无任何高度或实体外观，只需确认占位元素进入可视区域就请求接口加载数据。123456&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;!-- 很多&lt;li&gt; --&gt;&lt;/ul&gt;&lt;!-- 也可将#bottom以&lt;li&gt;的形式插入到&lt;ul&gt;内部的最后位置 --&gt;&lt;div id=&quot;bottom&quot;&gt;&lt;/div&gt; 123456789const bottom = document.getElementById(&quot;bottom&quot;);const observer = new IntersectionObserver(nodes =&gt; &#123; const tgt = nodes[0]; // 反正只有一个 if (tgt.isIntersecting) &#123; console.log(&quot;已到底部，请求接口&quot;); // 执行接口请求代码 &#125;&#125;)bottom.observe(bottom); 优化扫码识别通常移动端浏览器都会配备长按二维码图片识别链接的功能，但长按二维码可能无法识别或错误识别。二维码表面看上去是一张图片，可二维码生成方式却五花八门，二维码生成方式有以下三种。[x] 使用&lt;img&gt;渲染[x] 使用&lt;svg&gt;渲染[x] 使用&lt;canvas&gt;渲染从网易MTL的测试数据得知，大部分移动端浏览器只能识别渲染的二维码，为了让全部移动端浏览器都能识别二维码，那只能使用&lt;img&gt;渲染二维码了。若使用SVG和Canvas的方式生成二维码，那就想方设法把二维码数据转换成Base64再赋值到&lt;img&gt;的src上。一个页面可能存在多个二维码，若长按二维码只能识别最后一个，那只能控制每个页面只存在一个二维码。 自动播放媒体常见媒体元素包括音频&lt;audio&gt;和视频&lt;video&gt;，为了让用户得到更好的媒体播放体验与不盲目浪费用户流量，大部分移动端浏览器都明确规定不能自动播放媒体或默认屏蔽autoplay。为了能让媒体在页面加载完成后自动播放，只能显式声明播放。1234const audio = document.getElementById(&quot;audio&quot;);const video = document.getElementById(&quot;video&quot;);audio.play();video.play(); 对于像微信浏览器这样的内置浏览器，还需监听其应用SDK加载完成才能触发上述代码，以保障WebView正常渲染。其他内置浏览器同理，在此不作过多介绍。123document.addEventListener(&quot;WeixinJSBridgeReady&quot;, () =&gt; &#123; // 执行上述媒体自动播放代码&#125;); 在苹果系统上明确规定用户交互操作开始后才能播放媒体，未得到用户响应会被Safari自动拦截，因此需监听用户首次触摸操作并触发媒体自动播放，而该监听仅此一次。123document.body.addEventListener(&quot;touchstart&quot;, () =&gt; &#123; // 执行上述媒体自动播放代码&#125;, &#123; once: true &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"android ios 键盘弹出","slug":"android-ios-键盘弹出","date":"2021-01-14T08:27:24.000Z","updated":"2024-01-11T07:00:59.176Z","comments":true,"path":"2021/01/14/android-ios-键盘弹出/","link":"","permalink":"/2021/01/14/android-ios-键盘弹出/","excerpt":"android ios 键盘弹出","text":"android ios 键盘弹出 android ios 键盘弹出有时在页面的特殊布局情况下，需要对输入键盘的弹出和收起做判断。android可以用clientHeight高度来判断键盘的弹出和收起，但是ios却不行，ios可以利用focusin和focusout这两个事件冒泡到body元素上，来判断键盘的弹出和收起，focus和blur可不行，因为他们不会冒泡到body上。 android专用方法1234567891011121314151617var isAndroid = navigator.userAgent.indexOf('Android') &gt; -1 || navigator.userAgent.indexOf('Adr') &gt; -1; var isiOS = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); if(isAndroid) &#123; //获取原窗口的高度 var originalHeight=document.documentElement.clientHeight ||document.body.clientHeight; window.onresize=function()&#123; //键盘弹起与隐藏都会引起窗口的高度发生变化 var resizeHeight=document.documentElement.clientHeight || document.body.clientHeight; if(resizeHeight-0&lt;originalHeight-0)&#123; //当软键盘弹起，在此处操作 alert('键盘弹起'); &#125;else&#123; //当软键盘收起，在此处操作 alert('键盘收起'); &#125; &#125; &#125; android和ios通用方法123456789101112131415161718document.body.addEventListener('focusin', () =&gt; &#123; //软键盘弹出的事件处理 if(isiOS) &#123; alert('ios键盘弹起'); &#125; if(isAndroid) &#123; alert('android键盘弹起'); &#125;&#125;)document.body.addEventListener('focusout', () =&gt; &#123; //软键盘收起的事件处理 if(isiOS) &#123; alert('ios键盘收起'); &#125; if(isAndroid) &#123; alert('android键盘收起'); &#125;&#125;)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"兼容性","slug":"兼容性","permalink":"/tags/兼容性/"}]},{"title":"toString与valueOf浅析","slug":"toString与valueOf浅析","date":"2020-12-25T08:17:48.000Z","updated":"2024-01-11T07:00:59.231Z","comments":true,"path":"2020/12/25/toString与valueOf浅析/","link":"","permalink":"/2020/12/25/toString与valueOf浅析/","excerpt":"分析toString与valueOf","text":"分析toString与valueOf toString与valueOf浅析基本上，所有JS数据类型都拥有这两个方法，null除外。它们俩是位于原型链上的方法，也是为了解决javascript值运算与显示的问题。valueOf 和 toString 几乎都是在出现操作符(+-*/==&gt;&lt;)时被调用（隐式转换）。 toString返回一个表示该对象的字符串，当对象表示为文本值或以期望的字符串方式被引用时，toString方法被自动调用。 1. 手动调用看看什么效果嗯，跟介绍的一样，没骗人，全部都转成了字符串。比较特殊的地方就是，表示对象的时候，变成[object Object]，表示数组的时候，就变成数组内容以逗号连接的字符串，相当于Array.join(‘,’)。12345678let a = &#123;&#125;let b = [1, 2, 3]let c = '123'let d = function()&#123; console.log('fn') &#125;console.log(a.toString()) // '[object Object]'console.log(b.toString()) // '1,2,3'console.log(c.toString()) // '123'console.log(d.toString()) // 'function()&#123; console.log('fn') &#125;' 2. 最精准的类型判断这种属于更精确的判断方式，在某种场合会比使用 typeof &amp; instanceof 来的更高效和准确些。12345678910toString.call(()=&gt;&#123;&#125;) // [object Function]toString.call(&#123;&#125;) // [object Object]toString.call([]) // [object Array]toString.call('') // [object String]toString.call(22) // [object Number]toString.call(undefined) // [object undefined]toString.call(null) // [object null]toString.call(new Date) // [object Date]toString.call(Math) // [object Math]toString.call(window) // [object Window] 3. 什么时候会自动调用呢使用操作符的时候，如果其中一边为对象，则会先调用toSting方法，也就是隐式转换，然后再进行操作。123456789101112131415161718192021let c = [1, 2, 3]let d = &#123;a:2&#125;Object.prototype.toString = function()&#123; console.log('Object')&#125;Array.prototype.toString = function()&#123; console.log('Array') return this.join(',') // 返回toString的默认值（下面测试）&#125;Number.prototype.toString = function()&#123; console.log('Number')&#125;String.prototype.toString = function()&#123; console.log('String')&#125;console.log(2 + 1) // 3console.log('s') // 's'console.log('s'+2) // 's2'console.log(c &lt; 2) // false (一次 =&gt; 'Array')console.log(c + c) // \"1,2,31,2,3\" (两次 =&gt; 'Array')console.log(d &gt; d) // false (两次 =&gt; 'Object') 4. 重写toString方法既然知道了有 toString 这个默认方法，那我们也可以来重写这个方法123456789101112class A &#123; constructor(count) &#123; this.count = count &#125; toString() &#123; return '我有这么多钱：' + this.count &#125;&#125;let a = new A(100)console.log(a) // A &#123;count: 100&#125;console.log(a.toString()) // 我有这么多钱：100console.log(a + 1) // 我有这么多钱：1001 valueOf返回当前对象的原始值。具体功能与toString大同小异，同样具有以上的自动调用和重写方法。这里就没什么好说的了，主要为两者间的区别，有请继续往下看1234let c = [1, 2, 3]let d = &#123;a:2&#125;console.log(c.valueOf()) // [1, 2, 3]console.log(d.valueOf()) // &#123;a:2&#125; 两者区别共同点：在输出对象时会自动调用。不同点：默认返回值不同，且存在优先级关系。二者并存的情况下，在数值运算中，优先调用了valueOf，字符串运算中，优先调用了toString。看代码:123456789101112131415class A &#123; valueOf() &#123; return 2 &#125; toString() &#123; return '哈哈哈' &#125;&#125;let a = new A()console.log(String(a)) // '哈哈哈' =&gt; (toString)console.log(Number(a)) // 2 =&gt; (valueOf)console.log(a + '22') // '222' =&gt; (valueOf)console.log(a == 2) // true =&gt; (valueOf)console.log(a === 2) // false =&gt; (严格等于不会触发隐式转换) 结果给人的感觉是，如果转换为字符串时调用toString方法，如果是转换为数值时则调用valueOf方法。但其中的 a + ‘22’ 很不和谐，字符串合拼应该是调用toString方法。为了追究真相，我们需要更严谨的实验。暂且先把 valueOf 方法去掉12345678910class A &#123; toString() &#123; return '哈哈哈' &#125;&#125;let a = new A()console.log(String(a)) // '哈哈哈' =&gt; (toString)console.log(Number(a)) // NaN =&gt; (toString)console.log(a + '22') // '哈哈哈22' =&gt; (toString)console.log(a == 2) // false =&gt; (toString) 去掉 toString 方法看看1234567891011class A &#123; valueOf() &#123; return 2 &#125;&#125;let a = new A()console.log(String(a)) // '[object Object]' =&gt; (toString)console.log(Number(a)) // 2 =&gt; (valueOf)console.log(a + '22') // '222' =&gt; (valueOf)console.log(a == 2) // true =&gt; (valueOf) 发现有点不同吧？！它没有像上面 toString 那样统一规整。对于那个 [object Object]，我估计是从 Object 那里继承过来的，我们再去掉它看看。1234567891011class A &#123; valueOf() &#123; return 2 &#125;&#125;let a = new A()Object.prototype.toString = null; console.log(String(a)) // 2 =&gt; (valueOf)console.log(Number(a)) // 2 =&gt; (valueOf)console.log(a + '22') // '222' =&gt; (valueOf)console.log(a == 2) // true =&gt; (valueOf) 总结：valueOf偏向于运算，toString偏向于显示。 在进行对象转换时，将优先调用toString方法，如若没有重写 toString，将调用 valueOf 方法；如果两个方法都没有重写，则按Object的toString输出。 在进行强转字符串类型时，将优先调用 toString 方法，强转为数字时优先调用 valueOf。 使用运算操作符的情况下，valueOf的优先级高于toString。 [Symbol.toPrimitive]MDN：Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。是不是有点懵？？？把它当做一个函数就行了~~作用：同valueOf()和toString()一样，但是优先级要高于这两者；该函数被调用时，会被传递一个字符串参数1hint 表示当前运算的模式，一共有三种模式： string：字符串类型 number：数字类型 default：默认 下面来看看实现吧：123456789101112131415161718192021222324252627282930class A &#123; constructor(count) &#123; this.count = count &#125; valueOf() &#123; return 2 &#125; toString() &#123; return &apos;哈哈哈&apos; &#125; // 我在这里 [Symbol.toPrimitive](hint) &#123; if (hint == &quot;number&quot;) &#123; return 10; &#125; if (hint == &quot;string&quot;) &#123; return &quot;Hello Libai&quot;; &#125; return true; &#125;&#125;const a = new A(10)console.log(`$&#123;a&#125;`) // &apos;Hello Libai&apos; =&gt; (hint == &quot;string&quot;)console.log(String(a)) // &apos;Hello Libai&apos; =&gt; (hint == &quot;string&quot;)console.log(+a) // 10 =&gt; (hint == &quot;number&quot;)console.log(a * 20) // 200 =&gt; (hint == &quot;number&quot;)console.log(a / 20) // 0.5 =&gt; (hint == &quot;number&quot;)console.log(Number(a)) // 10 =&gt; (hint == &quot;number&quot;)console.log(a + &apos;22&apos;) // &apos;true22&apos; =&gt; (hint == &quot;default&quot;)console.log(a == 10) // false =&gt; (hint == &quot;default&quot;) 比较特殊的是(+)拼接符，这个属于default的模式。划重点：此方法不兼容IE，尴尬到我不想写出来了~~ 面试题分析以下几道大厂必考的面试题，完美呈现出 toString 与 valueOf 的作用。 1. a==1&amp;&amp;a==2&amp;&amp;a==3 为 true双等号(==)：会触发隐式类型转换，所以可以使用 valueOf 或者 toString 来实现。每次判断都会触发valueOf方法，同时让value+1，才能使得下次判断成立。123456789101112class A &#123; constructor(value) &#123; this.value = value; &#125; valueOf() &#123; return this.value++; &#125;&#125;const a = new A(1);if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(&quot;Hi Libai!&quot;);&#125; 2. a===1&amp;&amp;a===2&amp;&amp;a===3 为 true全等(===)：严格等于不会进行隐式转换，这里使用 Object.defineProperty 数据劫持的方法来实现123456789let value = 1;Object.defineProperty(window, &apos;a&apos;, &#123; get() &#123; return value++ &#125;&#125;)if (a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3) &#123; console.log(&quot;Hi Libai!&quot;)&#125; 上面我们就是劫持全局window上面的a，当a每一次做判断的时候都会触发get属性获取值，并且每一次获取值都会触发一次函数实行一次自增，判断三次就自增三次，所以最后会让公式成立。 3. 实现一个无限累加函数问题：用 JS 实现一个无限累加的函数 add，示例如下：1234567891011121314151617181920add(1); // 1add(1)(2); // 3add(1)(2)(3)； // 6add(1)(2)(3)(4)； // 10 // 以此类推function add(a) &#123; function sum(b) &#123; // 使用闭包 a = b ? a + b : a; // 累加 return sum; &#125; sum.toString = function() &#123; // 只在最后一次调用 return a; &#125; return sum; // 返回一个函数&#125;add(1) // 1add(1)(2) // 3add(1)(2)(3) // 6add(1)(2)(3)(4) // 10 add函数内部定义sum函数并返回，实现连续调用sum函数形成了一个闭包，每次调用进行累加值，再返回当前函数sumadd()每次都会返回一个函数sum，直到最后一个没被调用，默认会触发toString方法，所以我们这里重写toString方法，并返回累计的最终值a这样说才能理解:add(10): 执行函数add(10)，返回了sum函数，注意这一次没有调用sum，默认执行sum.toString方法。所以输出10；add(10)(20): 执行函数add(10)，返回sum(此时a为10)，再执行sum(20)，此时a为30，返回sum，最后调用sum.toString()输出30。add(10)(20)…(n)依次类推。 4. 柯里化实现多参累加这里是上面累加的升级版，实现多参数传递累加。123456789101112131415161718192021222324252627add(1)(3,4)(3,5) // 16add(2)(2)(3,5) // 12function add()&#123; // 1 把所有参数转换成数组 let args = Array.prototype.slice.call(arguments) // 2 再次调用add函数，传递合并当前与之前的参数 let fn = function() &#123; let arg_fn = Array.prototype.slice.call(arguments) return add.apply(null, args.concat(arg_fn)) &#125; // 3 最后默认调用，返回合并的值 fn.toString = function() &#123; return args.reduce(function(a, b) &#123; return a + b &#125;) &#125; return fn&#125;// ES6写法function add () &#123; let args = [...arguments]; let fn = function()&#123; return add.apply(null, args.concat([...arguments])) &#125; fn.toString = () =&gt; args.reduce((a, b) =&gt; a + b) return fn;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"海量数据页面渲染优化","slug":"海量数据页面渲染优化","date":"2020-12-16T01:38:49.000Z","updated":"2024-01-11T07:00:59.273Z","comments":true,"path":"2020/12/16/海量数据页面渲染优化/","link":"","permalink":"/2020/12/16/海量数据页面渲染优化/","excerpt":"页面有大量数据渲染的优化处理","text":"页面有大量数据渲染的优化处理 海量数据页面渲染优化平时在工作中需要在页面中渲染的数据量并不多，不过在极端情况下可能会渲染成千上万条，如果直接把数据生成dom节点往页面中插入的话，可能会使浏览器挂掉，下面列举3个优化方式： 一 使用requestAnimationFrame使用requestAnimationFrame函数，可以根据浏览器刷新频率进行渲染。123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul id=\"ul\"&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const maxNum = 50000; const num = 20; let count = 0; let ul = document.querySelector('#ul'); function add() &#123; let frag = document.createDocumentFragment(); for(let j=0; j&lt;num; j++) &#123; let li = document.createElement('li'); li.innerHTML = num*count + j; frag.appendChild(li); &#125; ul.appendChild(frag); loop(); &#125; function loop() &#123; count++; if(count &lt; maxNum/num) &#123; requestAnimationFrame(add); &#125;else &#123; console.log('总用时-&gt;'+Math.ceil((performance.now() - startTime))+'ms'); &#125; &#125; let startTime = performance.now(); add();&lt;/script&gt;&lt;/html&gt; 二 使用setTimeout使用setTimeout函数，完成一段工作后将线程让出去，让浏览器其它任务执行123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul id=\"ul\"&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const maxNum = 50000; const num = 20; let count = 0; let ul = document.querySelector('#ul'); function add() &#123; let frag = document.createDocumentFragment(); for(let j=0; j&lt;num; j++) &#123; let li = document.createElement('li'); li.innerHTML = num*count + j; frag.appendChild(li); &#125; ul.appendChild(frag); loop(); &#125; function loop() &#123; count++; if(count &lt; maxNum/num) &#123; setTimeout(add); &#125;else &#123; console.log('总用时-&gt;'+Math.ceil((performance.now() - startTime))+'ms'); &#125; &#125; let startTime = performance.now(); add();&lt;/script&gt;&lt;/html&gt; 上述两种方式，一个是使用requestAnimationFrame，一个是使用setTimeout，前者是根据浏览器刷新频率，60HZ就是1000/60毫秒执行一次，但这里有个问题我没有实验，就是单词任务如果超过一次刷新的时间会如何处理呢？（所以尽可能把单次任务执行时间控制在浏览器一次刷新时间范围内）。而setTimeout就没有刷新时间，任务执行完成之后，任务队列中没有其它任务的话，直接执行setTimeout里的任务。所以在都是50000条数据，单次向dom中插入20条数据的任务，两者所耗费的时间是不一样的。方法一用时：总用时-&gt;168309ms方法二用时: 总用时-&gt;94812ms根据用时可以看出来，方法二不需要等待浏览器的刷新时间（在理想状态，没有其它任务情况下），所需时间是比方法一少的。 三 时间切片什么是时间切片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul id=\"ul\"&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const maxNum = 50000; const num = 20; let count = 0; let ul = document.querySelector('#ul'); function *gen() &#123; while(count &lt; maxNum/num) &#123; yield (function() &#123; let frag = document.createDocumentFragment(); for(let j=0; j&lt;num; j++) &#123; let li = document.createElement('li'); li.innerHTML = num*count + j; frag.appendChild(li); &#125; ul.appendChild(frag); &#125;)(); &#125; &#125; function ts(gen) &#123; if (typeof gen === 'function') gen = gen() if (!gen || typeof gen.next !== 'function') return return function next() &#123; const start = performance.now() let res = null do &#123; res = gen.next(); count++; &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 30) if (res.done) &#123; console.log('总用时-&gt;'+Math.ceil((performance.now() - startTime))+'ms'); return &#125; setTimeout(next) &#125; &#125; let startTime = performance.now(); ts(gen)();&lt;/script&gt;&lt;/html&gt; 方法三用时: 总用时-&gt;1703ms可以看出速度明显高于前两种方法，因为方法三可以设置切片时间，根据浏览器的性能或者页面的实际交互情况来设置具体的切片时间。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"前端常见的设计模式","slug":"前端常见的设计模式","date":"2020-11-19T01:21:24.000Z","updated":"2024-01-11T07:00:59.259Z","comments":true,"path":"2020/11/19/前端常见的设计模式/","link":"","permalink":"/2020/11/19/前端常见的设计模式/","excerpt":"前端常见的9种设计模式","text":"前端常见的9种设计模式 前端常见的设计模式之前写过一篇比较全的设计模式点击查阅。这篇文章主要写几个前端平时常用的设计模式案例。 设计模式类型通过图片的结构展示，可以快速的理解和记忆。 demo案例创建型工厂模式工厂模式根据抽象程度可分为三种，分别为简单工厂、工厂方法和抽象工厂。其核心在于将创建对象的过程封装其他，然后通过同一个接口创建新的对象。简单工厂模式又叫静态工厂方法，用来创建某一种产品对象的实例，用来创建单一对象。1234567891011121314// 简单工厂class Factory &#123; constructor (username, pwd, role) &#123; this.username = username; this.pwd = pwd; this.role = role; &#125;&#125;class CreateRoleFactory &#123; static create (username, pwd, role) &#123; return new Factory(username, pwd, role); &#125;&#125;const admin = CreateRoleFactory.create('张三', '222', 'admin'); 在实际工作中，各用户角色所具备的能力是不同的，因此简单工厂是无法满足的，这时候就可以考虑使用工厂方法来代替。工厂方法的本意是将实际创建对象的工作推迟到子类中。1234567891011121314151617181920212223class User &#123; constructor (name, menuAuth) &#123; if (new.target === User) throw new Error('User 不能被实例化'); this.name = name; this.menuAuth = menuAuth; &#125;&#125;class UserFactory extends User &#123; constructor (...props) &#123; super(...props); &#125; static create (role) &#123; const roleCollection = new Map([ ['admin', () =&gt; new UserFactory('管理员', ['首页', '个人中心'])], ['user', () =&gt; new UserFactory('普通用户', ['首页'])] ]) return roleCollection.get(role)(); &#125;&#125;const admin = UserFactory.create('admin');console.log(admin); // &#123;name: \"管理员\", menuAuth: Array(2)&#125;const user = UserFactory.create('user');console.log(user); // &#123;name: \"普通用户\", menuAuth: Array(1)&#125; 随着业务形态的变化，一个用户可能在多个平台上同时存在，显然工厂方法也不再满足了，这时候就要用到抽象工厂。抽象工厂模式是对类的工厂抽象用来创建产品类簇，不负责创建某一类产品的实例。1234567891011121314151617181920212223242526272829303132333435363738class User &#123; constructor (hospital) &#123; if (new.target === User) throw new Error('抽象类不能实例化!'); this.hospital = hospital; &#125;&#125;// 浙一class ZheYiUser extends User &#123; constructor(name, departmentsAuth) &#123; super('zheyi_hospital'); this.name = name; this.departmentsAuth = departmentsAuth; &#125;&#125;// 萧山医院class XiaoShanUser extends User &#123; constructor(name, departmentsAuth) &#123; super('xiaoshan_hospital'); this.name = name; this.departmentsAuth = departmentsAuth; &#125;&#125;const getAbstractUserFactory = (hospital) =&gt; &#123; switch (hospital) &#123; case 'zheyi_hospital': return ZheYiUser; break; case 'xiaoshan_hospital': return XiaoShanUser; break; &#125;&#125;const ZheYiUserClass = getAbstractUserFactory('zheyi_hospital');const XiaoShanUserClass = getAbstractUserFactory('xiaoshan_hospital');const user1 = new ZheYiUserClass('王医生', ['外科', '骨科', '神经外科']);console.log(user1);const user2 = newXiaoShanUserClass('王医生', ['外科', '骨科']);console.log(user2); 小结： 构造函数和创建对象分离，符合开放封闭原则。使用场景： 比如根据权限生成不同用户。 单例模式单例模式理解起来比较简单，就是保证一个类只能存在一个实例，并提供一个访问它的全局接口。单例模式又分懒汉式和饿汉式两种，其区别在于懒汉式在调用的时候创建实例，而饿汉式则是在初始化就创建好实例，具体实现如下：12345678910111213141516171819202122// 懒汉式class Single &#123; static getInstance () &#123; if (!Single.instance) &#123; Single.instance = new Single(); &#125; return Single.instance; &#125;&#125;const test1 = Single.getInstance();const test2 = Single.getInstance();console.log(test1 === test2); // true// 饿汉式class Single &#123; static instance = new Single(); static getInstance () &#123; return Single.instance; &#125;&#125;const test1 = Single.getInstance();const test2 = Single.getInstance();console.log(test1 === test2); // true 小结： 实例如果存在，直接返回已创建的，符合开放封闭原则。使用场景： Redux、Vuex 等状态管理工具，还有我们常用的 window 对象、全局缓存等。 原型模式对于前端来说，原型模式在常见不过了。当新创建的对象和已有对象存在较大共性时，可以通过对象的复制来达到创建新的对象，这就是原型模式。123456789101112131415161718192021222324252627// Object.create()实现原型模式const user = &#123; name: 'zhangsan', age: 18&#125;;let userOne = Object.create(user);console.log(userOne.__proto__); // &#123;name: \"zhangsan\", age: 18&#125;// 原型链继承实现原型模式class User &#123; constructor (name) &#123; this.name = name; &#125; getName () &#123; return this.name; &#125;&#125;class Admin extends User &#123; constructor (name) &#123; super(name); &#125; setName (_name) &#123; return this.name = _name; &#125;&#125;const admin = new Admin('zhangsan');console.log(admin.getName());console.log(admin.setName('lisi')); 小结： 原型模式最简单的实现方式—Object.create()。使用场景： 新创建对象和已有对象无较大差别时，可以使用原型模式来减少创建新对象的成本。 结构型装饰器模式讲装饰器模式之前，先聊聊高阶函数。高阶函数就是一个函数就可以接收另一个函数作为参数。12345const add = (x, y, f) =&gt; &#123; return f(x) + f(y);&#125;const num = add(2, -2, Math.abs);console.log(num); // 4 函数 add 就是一个简单的高阶函数，而 add 相对于 Math.abs 来说相当于一个装饰器，因此这个例子也可以理解为一个简单的装饰器模式。在 react 中，高阶组件(HOC)也是装饰器模式的一种体现，通常用来不改变原来组件的情况下添加一些属性，达到组件复用的功能。12345678910import React from 'react';const BgHOC = WrappedComponent =&gt; class extends React.Component &#123; render () &#123; return ( &lt;div style=&#123;&#123; background: 'blue' &#125;&#125;&gt; &lt;WrappedComponent /&gt; &lt;/div&gt; ); &#125;&#125; 小结： 装饰器模式将现有对象和装饰器进行分离，两者独立存在，符合开放封闭原则和单一职责模式。使用场景： es7 装饰器、vue mixins、core-decorators 等。 适配器模式适配器别名包装器，其作用是解决两个软件实体间的接口不兼容的问题。以 axios 源码为例：123456789101112131415161718192021222324function getDefaultAdapter() &#123; var adapter; // 判断当前是否是 node 环境 if (typeof process !== 'undefined' &amp;&amp; Object.prototype.toString.call(process) === '[object process]') &#123; // 如果是 node 环境，调用 node 专属的 http 适配器 adapter = require('./adapters/http'); &#125; else if (typeof XMLHttpRequest !== 'undefined') &#123; // 如果是浏览器环境，调用基于 xhr 的适配器 adapter = require('./adapters/xhr'); &#125; return adapter;&#125;// http adaptermodule.exports = function httpAdapter(config) &#123; return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) &#123; ... &#125;&#125;// xhr adaptermodule.exports = function xhrAdapter(config) &#123; return new Promise(function dispatchXhrRequest(resolve, reject) &#123; ... &#125;&#125; 其目的就是保证 node 和浏览器环境的入参 config 一致，出参 Promise 都是同一个。小结： 不改变原有接口的情况下，统一接口、统一入参、统一出参、统一规则，符合开发封闭原则。使用场景 ：拥抱变化，兼容代码。 代理模式代理模式就是为对象提供一个代理，用来控制对这个对象的访问。在我们业务开发中最常见的有四种代理类型：事件代理，虚拟代理、缓存代理和保护代理。本文主要介绍虚拟代理和缓存代理两类。提到虚拟代理，其最具代表性的例子就是图片预加载。预加载主要是为了避免网络延迟、或者图片太大引起页面长时间留白的问题。通常的解决方案是先给 img 标签展示一个占位图，然后创建一个 Image 实例，让这个实例的 src 指向真实的目标图片地址，当其真实图片加载完成之后，再将 DOM 上的 img 标签的 src 属性指向真实图片地址。123456789101112131415class ProxyImg &#123; constructor (imgELe) &#123; this.imgELe = imgELe; this.DEFAULT_URL = 'xxx'; &#125; setUrl (targetUrl) &#123; this.imgEle.src = this.DEFAULT_URL; const image = new Image(); image.onload = () =&gt; &#123; this.imgEle.src = targetUrl; &#125; image.src = targetUrl; &#125;&#125; 缓存代理常用于一些计算量较大的场景。当计算的值已经被出现过的时候，不需要进行第二次重复计算。以传参求和为例：12345678910111213141516const countSum = (...arg) =&gt; &#123; console.log('count...'); let result = 0; arg.forEach(v =&gt; result += v); return result;&#125;const proxyCountSum = (() =&gt; &#123; const cache = &#123;&#125;; return (...arg) =&gt; &#123; const args = arg.join(','); if (args in cache) return cache[args]; return cache[args] = countSum(...arg); &#125;;&#125;)()proxyCountSum(1,2,3,4); // count... 10proxyCountSum(1,2,3,4); // 10 小结： 通过修改代理类来增加功能，符合开放封闭模式。使用场景： 图片预加载、缓存服务器、处理跨域以及拦截器等。 行为型策略模式介绍策略模式之前，简单实现一个常见的促销活动规则： 预售活动，全场 9.5 折 大促活动，全场 9 折 返场优惠，全场 8.5 折 限时优惠，全场 8 折 人人喊打的 if-else1234567891011const activity = (type, price) =&gt; &#123; if (type === 'pre') &#123; return price * 0.95; &#125; else if (type === 'onSale') &#123; return price * 0.9; &#125; else if (type === 'back') &#123; return price * 0.85; &#125; else if (type === 'limit') &#123; return price * 0.8; &#125;&#125; 以上代码存在肉眼可见的问题：大量 if-else、可扩展性差、违背开放封闭原则等。我们再使用策略模式优化：123456789const activity = new Map([ ['pre', (price) =&gt; price * 0.95], ['onSale', (price) =&gt; price * 0.9], ['back', (price) =&gt; price * 0.85], ['limit', (price) =&gt; price * 0.8]]);const getActivityPrice = (type, price) =&gt; activity.get(type)(price);// 新增新手活动activity.set('newcomer', (price) =&gt; price * 0.7); 小结： 定义一系列算法，将其一一封装起来，并且使它们可相互替换。符合开放封闭原则。使用场景： 表单验证、存在大量 if-else 场景、各种重构等。 观察者模式观察者模式又叫发布-订阅模式，其用来定义对象之间的一对多依赖关系，以便当一个对象更改状态时，将通知其所有依赖关系。通过“别名”可以知道，观察者模式具备两个角色，即“发布者”和“订阅者”。正如我们工作中的产品经理就是一个“发布者”，而前后端、测试可以理解为“订阅者”。以产品经理建需求沟通群为例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 定义发布者类class Publisher &#123; constructor () &#123; this.observers = []; this.prdState = null; &#125; // 增加订阅者 add (observer) &#123; this.observers.push(observer); &#125; // 通知所有订阅者 notify () &#123; this.observers.forEach((observer) =&gt; &#123; observer.update(this); &#125;) &#125; // 该方法用于获取当前的 prdState getState () &#123; return this.prdState; &#125; // 该方法用于改变 prdState 的值 setState (state) &#123; // prd 的值发生改变 this.prdState = state; // 需求文档变更，立刻通知所有开发者 this.notify(); &#125;&#125;// 定义订阅者类class Observer &#123; constructor () &#123; this.prdState = &#123;&#125;; &#125; update (publisher) &#123; // 更新需求文档 this.prdState = publisher.getState(); // 调用工作函数 this.work(); &#125; // work 方法，一个专门搬砖的方法 work () &#123; // 获取需求文档 const prd = this.prdState; console.log(prd); &#125;&#125;// 创建订阅者：前端开发小王const wang = new Observer();// 创建订阅者：后端开发小张const zhang = new Observer();// 创建发布者：产品经理小曾const zeng = new Publisher();// 需求文档const prd = &#123; url: 'xxxxxxx'&#125;;// 小曾开始拉人入群zeng.add(wang);zeng.add(zhang);// 小曾发布需求文档并通知所有人zeng.setState(prd); 经常使用 Event Bus(Vue) 和 Event Emitter(node)会发现，发布-订阅模式和观察者模式还是存在着细微差别，即所有事件的发布/订阅都不能由发布者和订阅者“私下联系”，需要委托事件中心处理。以 Vue Event Bus 为例：1234567import Vue from 'vue';const EventBus = new Vue();Vue.prototype.$bus = EventBus;// 订阅事件this.$bus.$on('testEvent', func);// 发布/触发事件this.$bus.$emit('testEvent', params); 整个过程都是 this.$bus 这个“事件中心”在处理。小结： 为解耦而生，为事件而生，符合开放封闭原则。使用场景： 跨层级通信、事件绑定等。 迭代器模式迭代器模式号称“遍历专家”，它提供一种方法顺序访问一个聚合对象中的各个元素，且不暴露该对象的内部表示。迭代器又分内部迭代器（jquery.each/for…of）和外部迭代器（es6 yield）。在 es6 之前，直接通过 forEach 遍历 DOM NodeList 和函数的 arguments 对象，都会直接报错，其原因都是因为他们都是类数组对象。对此 jquery 很好的兼容了这一点。在 es6 中，它约定只要数据类型具备 Symbol.iterator 属性，就可以被 for…of 循环和迭代器的 next 方法遍历。12345678(function (a, b, c) &#123; const arg = arguments; const iterator = arg[Symbol.iterator](); console.log(iterator.next()); // &#123;value: 1, done: false&#125; console.log(iterator.next()); // &#123;value: 2, done: false&#125; console.log(iterator.next()); // &#123;value: 3, done: false&#125; console.log(iterator.next()); // &#123;value: undefined, done: true&#125;&#125;)(1, 2, 3) 通过 es6 内置生成器 Generator 实现迭代器并没什么难度，这里重点通 es5 实现迭代器：123456789101112131415161718192021222324function iteratorGenerator (list) &#123; var index = 0; // len 记录传入集合的长度 var len = list.length; return &#123; // 自定义 next 方法 next: funciton () &#123; // 如果索引还没有超出集合长度，done 为 false var done = index &gt;= len; // 如果 done 为 false，则可以继续取值 var value = !done ? list[index++] : undefined; // 将当前值与遍历是否完毕（done）返回 return &#123; done: done, value: value &#125;; &#125; &#125;&#125;var iterator = iteratorGenerator([1, 2, 3]);console.log(iterator.next()); // &#123;value: 1, done: false&#125;console.log(iterator.next()); // &#123;value: 2, done: false&#125;console.log(iterator.next()); // &#123;value: 3, done: false&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125; 小结： 实现统一遍历接口，符合单一功能和开放封闭原则。使用场景： 有遍历的地方就有迭代器。 总结设计模式的难，在于它的抽象和分散。抽象在于每一设计模式看例子都很好理解，真正使用起来却不知所措；分散则是出现一个场景发现好几种设计模式都能实现。而解决抽象的最好办法就是动手实践，在业务开发中探索使用它们的可能性。本文大致介绍了前端领域常见的 9 种设计模式，相信大家在理解的同时也不难发现，设计模式始终围绕着“封装变化”来提供代码的可读性、扩展性、易维护性。所以当我们工作生活中，始终保持“封装变化”的思想的时候，就已经开始体会到设计模式精髓了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"web安全之外链target=_blank","slug":"web安全之外链target-blank","date":"2020-08-28T06:52:27.000Z","updated":"2024-01-11T07:00:59.237Z","comments":true,"path":"2020/08/28/web安全之外链target-blank/","link":"","permalink":"/2020/08/28/web安全之外链target-blank/","excerpt":"web安全之外链target=”_blank”","text":"web安全之外链target=”_blank” web安全之外链target=_blank网页里的a标签默认在当前窗口跳转链接地址，如果需要在新窗口打开，需要给 a 标签添加一个target=”_blank”属性。1&lt;a href=\"http://baidu.com/\" target=\"_blank\"&gt;百度&lt;/a&gt; 安全隐患如果只是加上target=”_blank”，打开新窗口后，新页面能通过window.opener获取到来源页面的window对象，即使跨域也一样。虽然跨域的页面对于这个对象的属性访问有所限制，但还是有漏网之鱼。 可以看到window.opener的一些属性，某些属性的访问被拦截，是因为跨域安全策略的限制。 即便如此，还是给一些操作留下可乘之机。比如修改window.opener.location的值，指向另外一个地址。你想想看，刚刚还是在某个网站浏览，随后打开了新窗口，结果这个新窗口神不知鬼不觉地把原来的网页地址改了。这个可以用来做什么？钓鱼啊！等你回到那个钓鱼页面，已经伪装成登录页，你可能就稀里糊涂把账号密码输进去了。 还有一种玩法，如果你处于登录状态，有些操作可能只是发送一个GET请求就完事了。通过修改地址，就执行了非你本意的操作，其实就是 CSRF 攻击。 性能问题除了安全隐患外，还有可能造成性能问题。通过target=”_blank”打开的新窗口，跟原来的页面窗口共用一个进程。如果这个新页面执行了一大堆性能不好的 JavaScript 代码，占用了大量系统资源，那你原来的页面也会受到池鱼之殃。 解决方案尽量不使用target=”_blank”，如果一定要用，需要加上rel=”noopener”或者rel=”noreferrer”。这样新窗口的window.openner就是null了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。 我特意用自己的博客网站 http://www.kaysonli.com/ 试了一下，点击里面的外链打开新页面，window.openner都是null。查看页面元素发现，a标签都加上了 rel=”noreferrer”。博客是用 Hexo 生成的，看来这种设置已经成了基本常识了。 另外，对于通过window.open的方式打开的新页面，可以这样做：1234var yourWindow = window.open();yourWindow.opener = null;yourWindow.location = \"http://someurl.here\";yourWindow.target = \"_blank\";","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"js操作伪元素","slug":"js操作伪元素","date":"2020-08-06T05:27:39.000Z","updated":"2024-01-11T07:00:59.219Z","comments":true,"path":"2020/08/06/js操作伪元素/","link":"","permalink":"/2020/08/06/js操作伪元素/","excerpt":"javascript操作伪元素","text":"javascript操作伪元素 js操作伪元素日常开发中，伪元素使用频率很高，今天说一说如何使用js动态的改变伪元素样式。对于普通的元素，要改变其样式，获取它的节点，再使用style[属性名]便可以改变其样式，但是伪元素使用这种方式是不行的。只能使用css设置的模式，也就是改变css的样式，如果用js来改变css的样式相对复杂，所以改用添加新的css样式，再更换伪元素className方式来做。细节见demo代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0; &#125;&lt;/style&gt;&lt;style&gt; .wrap &#123; width: 300px; margin: 20px auto; &#125; .content-style1::before &#123; content: attr(data-content); font-size: 32px; color: red; &#125; .btns &#123; margin: 20px 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;h1&gt;js操作伪类&lt;/h1&gt; &lt;div class=\"content-style1\" data-content=\"伪类内容\"&gt;&lt;/div&gt; &lt;div class=\"btns\"&gt; &lt;button id=\"btn1\" onclick=\"onBtn1()\"&gt;方式一&lt;/button&gt; &lt;button id=\"btn1\" onclick=\"onBtn2()\"&gt;方式二&lt;/button&gt; &lt;button id=\"btn1\" onclick=\"onBtn3()\"&gt;改变伪类的内容&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var nDiv = document.querySelector('.content-style1'); function onBtn1() &#123; // 创建一个style节点 var nStyle = document.createElement('style'); // 创建一个文本节点 var nStyleText = document.createTextNode('.content-style2::before&#123;content: attr(data-content);color:blue;&#125;'); nStyle.appendChild(nStyleText); document.head.appendChild(nStyle); // 删除添加类名 removeClass(nDiv, 'content-style1'); addClass(nDiv, 'content-style2'); &#125; function onBtn2() &#123; var styleSheets = document.styleSheets[1]; // 获取样式表引用 var index = styleSheets.rules.length; // 获取样式表中包含样式的个数 if(styleSheets.insertRule)&#123; // 判断浏览器是否支持insertRule()方法 styleSheets.insertRule('.content-style3::before&#123;content: attr(data-content);color:green;&#125;', index); &#125;else&#123; // 如果哦浏览器不支持insertRule()方法 styleSheets.addRule('.content-style3::before', 'content: attr(data-content);color:green;', index); &#125; // 删除添加类名 removeClass(nDiv, 'content-style1'); addClass(nDiv, 'content-style3'); &#125; // 不处理样式，只改变伪类content的内容 function onBtn3() &#123; nDiv.setAttribute('data-content', 'js改变内容'); &#125;&lt;/script&gt;&lt;script&gt; // 工具函数 function addClass(ele, className) &#123; ele.classList.add(className); &#125; function removeClass(ele, className) &#123; ele.classList.remove(className); &#125;&lt;/script&gt;&lt;/html&gt; 以上只是简单的列举。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"h5长按图片自定义菜单","slug":"h5长按图片自定义菜单","date":"2020-07-28T06:26:47.000Z","updated":"2024-01-11T07:00:59.189Z","comments":true,"path":"2020/07/28/h5长按图片自定义菜单/","link":"","permalink":"/2020/07/28/h5长按图片自定义菜单/","excerpt":"移动端页面，长按图片，弹出自定义菜单","text":"移动端页面，长按图片，弹出自定义菜单 h5长按图片自定义菜单我们平时在使用浏览器访问网页时，有图片的场景，长按图片：浏览器：微信:自定义： 阻止浏览器默认图片长按事件css方法给指定的图片加上css样式后，可以阻止浏览器的图片默认长按事件123img &#123; pointer-events:none;&#125; 蒙层方法在图片上加一个蒙层，给这个蒙层加长按事件。之后就可以根据需求，给指定图片加上长按事件，自己制作一个菜单，弹出显示。这里使用了alloy-finger.js库添加长按事件 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; &#125; #div_1 &#123; width: 100%; height: 100px; background: #cccccc; &#125; #img_1 img &#123; width: 100%; pointer-events:none; &#125; #img_2 &#123; text-align: center; &#125; #img_2 img &#123; width: 50%; &#125; #img_3 &#123; position: relative; &#125; #img_3 img, #img_3 .mask &#123; width: 150px; height: 150px; &#125; #img_3 .mask &#123; position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, .3); color: red; font-size: 30px; text-align: center; &#125; #modal &#123; display: none; position: absolute; box-shadow: 1px 1px 2px 1px rgba(0, 0, 0, .3); width: 150px; background: #ffffff; &#125; #modal p &#123; padding-left: 20px; line-height: 30px; border-bottom: 1px solid #cccccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;img_1&quot;&gt; &lt;img src=&quot;./img.jpg&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt; &lt;/div&gt; &lt;div id=&quot;div_1&quot;&gt; &lt;/div&gt; &lt;div id=&quot;img_2&quot;&gt; &lt;img src=&quot;./code.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div id=&quot;img_3&quot;&gt; &lt;img src=&quot;./code.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;modal&quot;&gt; &lt;p&gt;菜单项1&lt;/p&gt; &lt;p&gt;菜单项2&lt;/p&gt; &lt;p&gt;菜单项3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./alloy-finger.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var nModal = document.querySelector(&apos;#modal&apos;); var vConsole = new VConsole(); new AlloyFinger(&apos;#img_1&apos;, &#123; longTap: function (ev) &#123; showModal(ev); &#125; &#125;); new AlloyFinger(&apos;#img_2 img&apos;, &#123; longTap: function (ev) &#123; showModal(ev); &#125; &#125;); new AlloyFinger(&apos;#img_3&apos;, &#123; longTap: function (ev) &#123; showModal(ev); &#125; &#125;); // 显示长按modal function showModal(ev) &#123; var pointer = ev.touches[0]; nModal.style.display = &apos;block&apos;; nModal.style.top = pointer.pageY + &apos;px&apos;; nModal.style.left = pointer.pageX + &apos;px&apos;; &#125; // 隐藏modal function hideModal() &#123; nModal.style.display = &apos;none&apos;; &#125; // modal菜单加事件 document.querySelector(&apos;#modal&apos;).addEventListener(&apos;click&apos;, function(ev) &#123; hideModal(); alert(&apos;点击了&apos; + ev.target.innerText); &#125;, false);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"the-super-tiny-compiler","slug":"the-super-tiny-compiler","date":"2020-07-20T05:54:45.000Z","updated":"2024-01-11T07:00:59.231Z","comments":true,"path":"2020/07/20/the-super-tiny-compiler/","link":"","permalink":"/2020/07/20/the-super-tiny-compiler/","excerpt":"一个极简编译器","text":"一个极简编译器 the-super-tiny-compiler现在我们在开发中一定会使用到babel这个编译器，它可以把JavaScript代码解析成ast语法树，进而处理代码。the-super-tiny-compiler 是一个非常简单的代码解析器，通过它可以了解babel的工作原理。the-super-tiny-compilerthe-super-tiny-compiler-CN中文注释代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859'use strict';/** * 今天我们会一起编写一个编译器。一个非常非常简化的微型编译器！这个编译器非常小，如果你移除这个 * 文件里的注释，那么这个文件只剩下大概200行代码。 * * 我们会将类似于LISP的函数调用编译成类似于C的函数调用。 * * 如果你对这两个语言中的一个或者两个不熟悉。下面是一个快速的介绍。 * * 如果我有两个函数`add`和`subtract`，它们会像下面这样被写出来： * * LISP C * * 2 + 2 (add 2 2) add(2, 2) * 4 - 2 (subtract 4 2) subtract(4, 2) * 2 + (4 - 2) (add 2 (subtract 4 2)) add(2, subtract(4, 2)) * * 非常简单直观不是吗？ * * 非常好，因为这就是我们要编译的代码。尽管这并不是一个完整的LISP或者C的编译器，但是它足够展示 * 现代编译器的很多大部分组成部件。 *//** * 大部分编译器的工作可以被分解为三个主要阶段：解析（Parsing），转化（Transformation）以及 * 代码生成（Code Generation）。 * * 1. *解析* 将源代码转换为一个更抽象的形式。 * * 2. *转换* 接受解析产生的抽象形式并且操纵这些抽象形式做任何编译器想让它们做的事。 * * 3. *代码生成* 基于转换后的代码表现形式（code representation）生成目标代码。 *//** * 解析 * ------- * * 解析一般被分为两个部分：词法分析和语法分析。 * * 1. *词法分析* 通过一个叫做tokenizer（词素生成器，也叫lexer）的工具将源代码分解成一个个词素。 * * 词素是描述编程语言语法的对象。它可以描述数字，标识符，标点符号，运算符等等。 * * 2. *语法分析* 接收词素并将它们组合成一个描述了源代码各部分之间关系的中间表达形式：抽象语法树。 * * 抽象语法树是一个深度嵌套的对象，这个对象以一种既能够简单地操作又提供很多关于源代码信息的形式 * 来展现代码。 * * 看下面的代码: * * (add 2 (subtract 4 2)) * * 上面代码产生的词素会像下面这样： * * [ * &#123; type: 'paren', value: '(' &#125;, * &#123; type: 'name', value: 'add' &#125;, * &#123; type: 'number', value: '2' &#125;, * &#123; type: 'paren', value: '(' &#125;, * &#123; type: 'name', value: 'subtract' &#125;, * &#123; type: 'number', value: '4' &#125;, * &#123; type: 'number', value: '2' &#125;, * &#123; type: 'paren', value: ')' &#125;, * &#123; type: 'paren', value: ')' &#125;, * ] * * 而产生的抽象语法树会像下面这样： * * &#123; * type: 'Program', * body: [&#123; * type: 'CallExpression', * name: 'add', * params: [&#123; * type: 'NumberLiteral', * value: '2', * &#125;, &#123; * type: 'CallExpression', * name: 'subtract', * params: [&#123; * type: 'NumberLiteral', * value: '4', * &#125;, &#123; * type: 'NumberLiteral', * value: '2', * &#125;] * &#125;] * &#125;] * &#125; *//** * 转换 * -------------- * * 编译器的下一个阶段是转换阶段。再回顾一遍，这个过程接收解析生成的抽象语法树并对它做出改动。 * 转换阶段可以改变抽象语法树使代码保持在同一个语言（例如Babel，Babel接收的是JS代码生成的也是 * JS代码），或者编译成另外一门语言。 * * 让我们一起来看如何转换一个抽象语法树。 * * 你可能会注意到我们的抽象语法树包含了长得非常相似的元素。观察那些含有type属性的元素。这些元素 * 被称为抽象语法树的节点。每一个节点都描述了源代码中的一部分。 * * 针对NumberLiteral我们有一个节点： * * &#123; * type: 'NumberLiteral', * value: '2', * &#125; * * 针对CallExpression我们也有一个节点： * * &#123; * type: 'CallExpression', * name: 'subtract', * params: [...nested nodes go here...], * &#125; * * 在转换抽象语法树的时候，我们可以通过添加/删除/替换节点属性来操纵节点。我们也可以添加节点， * 删除节点，或者基于现有的抽象语法树创建一个全新的抽象语法树。 * * 由于我们的编译目标是另外一门语言，所以我们集中注意力新建一个针对目标语言的全新抽象语法树。 * * 遍历 * --------- * * 为了处理节点，我们需要遍历它们。这个遍历的过程按照深度优先规则遍历每一个节点。 * * &#123; * type: 'Program', * body: [&#123; * type: 'CallExpression', * name: 'add', * params: [&#123; * type: 'NumberLiteral', * value: '2' * &#125;, &#123; * type: 'CallExpression', * name: 'subtract', * params: [&#123; * type: 'NumberLiteral', * value: '4' * &#125;, &#123; * type: 'NumberLiteral', * value: '2' * &#125;] * &#125;] * &#125;] * &#125; * * 所以针对上面这个抽象语法树我们会按照下面步骤遍历节点： * * 1. Program - 从抽象语法树的最顶端开始 * 2. CallExpression (add) - 移动到Program的body属性中的第一个元素 * 3. NumberLiteral (2) - 移动到CallExpression的params中的第一个元素 * 4. CallExpression (subtract) - 移动到CallExpression的params中的第二个元素 * 5. NumberLiteral (4) - 移动到CallExpression的params中的第一个元素 * 6. NumberLiteral (2) - 移动到CallExpression的params中的第二个元素 * * 如果我们直接操纵这个抽象语法树，而不是创建一个新的抽象语法树，那么我们就需要在这个步骤使用到 * 很多不同的抽象概念。然而为了满足我们的需求，在这一步我们仅仅需要访问抽象语法树中的每一个节点 * 即可。 * * The reason I use the word \"visiting\" is because there is this pattern of how * to represent operations on elements of an object structure. * 在这里我使用“访问”这个词的与原因是因为存在着下面这个用来表示一个对象结构中元素行为的模式。 * * 访问者 * -------- * * 基本的思想是我们会创建一个“访问者”对象，这个访问者对象有不同的方法来接受不同的节点类型。 * * var visitor = &#123; * NumberLiteral() &#123;&#125;, * CallExpression() &#123;&#125;, * &#125;; * * 当我们遍历抽象语法树的时候，我们会根据现在“进入”的节点的类型调用访问者对象相对应的方法。 * * 为了使这个对象能够正常工作，我们需要传入当前节点以及当前节点的父节点的引用。 * * var visitor = &#123; * NumberLiteral(node, parent) &#123;&#125;, * CallExpression(node, parent) &#123;&#125;, * &#125;; * * 然而，也存在着在“离开”节点的时候调用方法的可能性。假设我们有以下的抽象语法树结构： * * - Program * - CallExpression * - NumberLiteral * - CallExpression * - NumberLiteral * - NumberLiteral * * 当我们向下遍历语法树的时候，我们会碰到所谓的叶子节点。我们在处理完一个节点后会“离开”这个节点。 * 所以向下遍历树的时候我们“进入”节点，而向上返回的时候我们“离开”节点。 * * -&gt; Program (enter) * -&gt; CallExpression (enter) * -&gt; Number Literal (enter) * &lt;- Number Literal (exit) * -&gt; Call Expression (enter) * -&gt; Number Literal (enter) * &lt;- Number Literal (exit) * -&gt; Number Literal (enter) * &lt;- Number Literal (exit) * &lt;- CallExpression (exit) * &lt;- CallExpression (exit) * &lt;- Program (exit) * * 为了支持上面所讲的功能，我们的访问者对象的最终形态如下： * * var visitor = &#123; * NumberLiteral: &#123; * enter(node, parent) &#123;&#125;, * exit(node, parent) &#123;&#125;, * &#125; * &#125;; *//** * 代码生成 * --------------- * * 编译器的最后步骤是代码生成。有时候编译器在这个步骤也会执行转换阶段的一些行为，但是大体而言代 * 码生成阶段的工作就是基于转换步骤产生的抽象语法树生成目标代码。 * * 代码生成器的工作方式多种多样，一些编译器会重新利用更早阶段产生的词素，还有一些编译器会创建一 * 个独立的代码表达形式从而能够线性地打印节点，但是基于我的经验大部分编译器会使用我们刚刚创造的 * 那个抽象语法树，这也是我们接下来讲的方法。 * * 一个有效的代码生成器知道如何“打印”抽象语法树不同类型的节点，并且会递归地调用自己来打印嵌套的 * 节点直到整个语法树被打印成一长串完整的代码字符串。 *//** * 上面所讲到的就是编译器的所有不同部分了。 * * 这并不表明所有编译器都像我上面描述的那样工作。不同的编译器有各种各样不同的目的，它们可能需要 * 一些我没有讲到的步骤。 * * 但是现在你应该已经有了一个编译器如何工作的大体概念了。 * * 既然现在我已经解释了所有东西，你就可以立马动手写一个你自己的编译器了不是吗？ * * 开个玩笑，我会帮助你理解如何写一个编译器 :P。 * * 那么我们开始吧…… *//** * ============================================================================ * (/^▽^)/ * THE TOKENIZER! * ============================================================================ *//** * 我们从解析步骤的第一个部分开始，词法分析。也就是tokenizer词素生成器的工作。 * * 我们将源代码分解成一个词素数组。 * * (add 2 (subtract 4 2)) =&gt; [&#123; type: 'paren', value: '(' &#125;, ...] */// 我们首先需要接收一个代码字符串，并且我们需要设置两个变量……function tokenizer(input) &#123; // `current`变量跟踪我们现在在源代码中的什么地方，就像一个光标一样。 let current = 0; // `tokens`变量，顾名思义，用来储存词素的数组。 let tokens = []; // 我们从创建一个`while`循环开始，在这个循环里我们会根据需求增加`current`变量的值。 // // 注意由于词素的长度不同的，我们可能需要在一次循环中多次增加`current`的值。 while (current &lt; input.length) &#123; // 我们将input中的当前字符存到char变量中。 let char = input[current]; // 我们需要检测的第一个情况就是开括号，这在之后会被函数调用`CallExpression`所用到。但是 // 现在我们只需要关心字符即可。 // // 我们检测我们是否有一个开括号： if (char === '(') &#123; // 如果我们有一个开括号，我们创建一个类型为`paren`的词素并将value设置为开括号。 tokens.push(&#123; type: 'paren', value: '(', &#125;); // 之后我们增加`current` current++; // 然后我们继续进行下一个循环 continue; &#125; // 接下来我们需要检测的是闭括号。这里的行为和开括号的一模一样：检查是否是一个闭括号，如果是 // 的话，创建一个新词素，增加`current`然后执行下一个循环。 if (char === ')') &#123; tokens.push(&#123; type: 'paren', value: ')', &#125;); current++; continue; &#125; // 接下来我们需要检测得是空格。这非常有趣，因为空格只是为了易读性而被添加的，所以我们并不需 // 要将其储存为一个词素。我们简单地不管它就好。 // // 所以这里我们仅仅检测当前字符是否是一个空格，如果是的话我们直接继续下一个循环。 let WHITESPACE = /\\s/; if (WHITESPACE.test(char)) &#123; current++; continue; &#125; // 下一个词素类型是数字。这和我们之前碰到的情况都不一样，因为一个数字可能包含任意数量的字符。 // 我们需要捕获数字的所有字符来创建一个词素。 // // (add 123 456) // ^^^ ^^^ // 上面代码中数字只构成了两个词素 // // 所以我们在碰到一个序列中的第一个数字的时候开始下面的步骤。 let NUMBERS = /[0-9]/; if (NUMBERS.test(char)) &#123; // 我们会创造一个`value`字符串，这个字符串用来存储字符。 let value = ''; // 之后我们遍历序列中的每一个字符直到遇到一个不是数字的字符，把每一个字符添加到`value` // 字符串中并且增加`current`的值。 while (NUMBERS.test(char)) &#123; value += char; char = input[++current]; &#125; // 之后我们将我们的数字词素添加到`tokens`数组。 tokens.push(&#123; type: 'number', value &#125;); // 然后我们继续下一个循环。 continue; &#125; // 我们同样支持字符串，字符串是由双引号\"包裹的文字内容。 // // (concat \"foo\" \"bar\") // ^^^ ^^^ string tokens // // 我们引号开始检测。 if (char === '\"') &#123; // 创造一个`value`变量保存我们的字符串。 let value = ''; // 跳过意味着字符串开始的那个引号。 char = input[++current]; // 之后我们遍历每一个字符直到我们到达了另一个引号。 while (char !== '\"') &#123; value += char; char = input[++current]; &#125; // 跳过意味着字符串结尾的引号。 char = input[++current]; // 然后创造字符串词素并添加到`tokens`数组。 tokens.push(&#123; type: 'string', value &#125;); continue; &#125; // 最后一种词素是`name`词素。这是一个字母序列，在我们lisp语法中是函数的名称。 // // (add 2 4) // ^^^ // Name token // let LETTERS = /[a-z]/i; if (LETTERS.test(char)) &#123; let value = ''; // 和其他情况一样，我们遍历字母并将它们添加到`value`变量。 while (LETTERS.test(char)) &#123; value += char; char = input[++current]; &#125; // 之后创建词素并添加到`tokens`变量。 tokens.push(&#123; type: 'name', value &#125;); continue; &#125; // 最后如果我们并不能匹配到任何情况的话，我们就抛出一个错误并退出。 throw new TypeError('I dont know what this character is: ' + char); &#125; // 最后我们返回词素数组tokens。 return tokens;&#125;/** * ============================================================================ * ヽ/❀o ل͜ o\\ﾉ * THE PARSER!!! * ============================================================================ *//** * 我们的语法分析器接受我们的词素数组并创造出一个抽象语法树。 * * [&#123; type: 'paren', value: '(' &#125;, ...] =&gt; &#123; type: 'Program', body: [...] &#125; */// 好的，那么我们定义一个`parser`函数，这个函数接收词素数组tokens。function parser(tokens) &#123; // 我们还是创建一个`current`变量跟踪我们所处的位置。 let current = 0; // 但是这一次我们使用的是递归而不是一个`while`循环。所以我们定义一个`walk`函数。 function walk() &#123; // 在walk函数中我们首先获取当前词素。 let token = tokens[current]; // 针对不同类型的词素，我们的处理方式也不同，从数字词素开始。 // // 我们检测当前词素是否为一个数字词素。 if (token.type === 'number') &#123; // 如果是一个数字词素，我们增加`current`变量的值。 current++; // 之后我们返回一个类型为`NumberLiteral`类型的抽象语法树节点，并且设置这个节点的value。 return &#123; type: 'NumberLiteral', value: token.value, &#125;; &#125; // 如果我们有一个字符串词素，那么和数字词素的情况类似，只不过这里我们返回一个`StringLiteral` // 类型的词素。 if (token.type === 'string') &#123; current++; return &#123; type: 'StringLiteral', value: token.value, &#125;; &#125; // 接下来我们检测是否是一个函数调用。我们在碰到一个开括号的时候处理这种情况。 if (token.type === 'paren' &amp;&amp; token.value === '(') &#123; // 我们会增加`current`变量的值来跳过开括号以选取下一个词素，这是因为在我们的抽象语法树 // 中开括号本身并没有意义。 token = tokens[++current]; // 我们创建一个类型为`CallExpression`的基础词素，之后我们将它的名字设置为当前词素的value。 // 这是因为开括号之后的词素的value就是函数的名字。 let node = &#123; type: 'CallExpression', name: token.value, params: [], &#125;; // 我们再一次增加`current`变量来跳过包含了函数名的词素。 token = tokens[++current]; // 现在我们遍历每一个会成为我们`CallExpression`词素的`params`的词素直到我们遇到一个 // 闭括号为止。 // // 这就是需要递归的时候。我们使用递归而不是试图直接分析可能有无限多层嵌套节点的参数。 // // 为了解释这个概念，以我们的lisp代码为例。你可以观察到`add`的参数是一个数字和一个嵌套 // 的`CallExpression`，而这个`CallExpression`又拥有自己的参数。 // // (add 2 (subtract 4 2)) // // 你也可以观察到在我们的词素数组中我们有多个闭括号。 // // [ // &#123; type: 'paren', value: '(' &#125;, // &#123; type: 'name', value: 'add' &#125;, // &#123; type: 'number', value: '2' &#125;, // &#123; type: 'paren', value: '(' &#125;, // &#123; type: 'name', value: 'subtract' &#125;, // &#123; type: 'number', value: '4' &#125;, // &#123; type: 'number', value: '2' &#125;, // &#123; type: 'paren', value: ')' &#125;, &lt;&lt;&lt; 闭括号 // &#123; type: 'paren', value: ')' &#125;, &lt;&lt;&lt; 闭括号 // ] // // 我们依赖嵌套的`walk`函数在处理每一个嵌套的CallExpression`的时候增加我们的`current`变量。 // 所以我们创建一个`while`循环直到我们碰到一个类型为`paren`并且`value`是闭括号的词素。 while ( token.type !== 'paren' || (token.type === 'paren' &amp;&amp; token.value !== ')') ) &#123; // 我们调用`walk`函数，`walk`函数会返回一个节点然后我们将这个节点添加到我们的`node.params`。 node.params.push(walk()); token = tokens[current]; &#125; // 最后我们还需要增加`current`变量来跳过闭括号。 current++; // 返回这个节点。 return node; &#125; // 同样，如果我们没有匹配到以上任何类型，我们抛出一个错误。 throw new TypeError(token.type); &#125; // 现在，我们来创建我们的抽象语法树。抽象语法树的根节点是一个`Program`节点。 let ast = &#123; type: 'Program', body: [], &#125;; // 然后我们调用我们的`walk`函数，将返回的节点都添加到`ast.body`数组中。 // // 我们在一个循环中这样做的原因是因为我们可能有多个单独的函数调用，而不是相互嵌套。 // // (add 2 2) // (subtract 4 2) // while (current &lt; tokens.length) &#123; ast.body.push(walk()); &#125; // 最后，语法分析器会返回抽象语法树。 return ast;&#125;/** * ============================================================================ * ⌒(❀&gt;◞౪◟&lt;❀)⌒ * THE TRAVERSER!!! * ============================================================================ *//** * 现在我们有了抽象语法树，而我们希望可以使用一个访问者对象来访问各个节点。我们需要能够在碰到一 * 个节点的时候调用访问者对象相应的方法。 * * traverse(ast, &#123; * Program: &#123; * enter(node, parent) &#123; * // ... * &#125;, * exit(node, parent) &#123; * // ... * &#125;, * &#125;, * * CallExpression: &#123; * enter(node, parent) &#123; * // ... * &#125;, * exit(node, parent) &#123; * // ... * &#125;, * &#125;, * * NumberLiteral: &#123; * enter(node, parent) &#123; * // ... * &#125;, * exit(node, parent) &#123; * // ... * &#125;, * &#125;, * &#125;); */// 所以我们定义一个traverser函数，这个函数接收抽象语法树以及一个访问者对象。在这个函数内部我们// 还会定义两个函数……function traverser(ast, visitor) &#123; // `traverseArray`函数，这个函数允许我们遍历一个数组并且调用我们接下来定义的函数：\"traverseNode`。 function traverseArray(array, parent) &#123; array.forEach(child =&gt; &#123; traverseNode(child, parent); &#125;); &#125; // `traverseNode`函数会接收一个节点以及这个节点的父节点。这样它就可以将这两个参数传递给我们 // 的访问者对象的方法。 function traverseNode(node, parent) &#123; //我们首先检测访问者对象是否含有一个匹配当前类型节点的方法。 let methods = visitor[node.type]; // 如果当前类型节点有相匹配的`enter`方法，我们调用这个方法`enter`方法并传入节点以及父节点。 if (methods &amp;&amp; methods.enter) &#123; methods.enter(node, parent); &#125; // 接下来我们根据当前节点类型分情况处理。 switch (node.type) &#123; // 我们从最顶层的`Program`开始。由于Program节点的body属性是一个节点数组，我们调用 // `traverseArray`函数来向下遍历它们。 // // （请注意'traverseArray`会调用`traverseNode`所以我们会递归地遍历抽象语法树。） case 'Program': traverseArray(node.body, node); break; // 对于`CallExpression`节点，我们遍历它的`params`属性。 case 'CallExpression': traverseArray(node.params, node); break; // 对于`NumberLiteral`和`StringLiteral`的情况，我们并没有任何子节点去访问，所以我们 // 直接break。 case 'NumberLiteral': case 'StringLiteral': break; // 同样的，如果出现没有匹配的情况，我们抛出一个错误。 default: throw new TypeError(node.type); &#125; // 如果访问者对象针对当前类型节点存在着一个`exit`方法的话，我们在这里调用它并传入节点和父节点。 if (methods &amp;&amp; methods.exit) &#123; methods.exit(node, parent); &#125; &#125; // 最后，我们通过调用`traverseNode`并传入ast和null来开始遍历。这里传入null作为父节点的原 // 因是因为抽象语法树的根节点并没有父节点。 traverseNode(ast, null);&#125;/** * ============================================================================ * ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽ * THE TRANSFORMER!!! * ============================================================================ *//** * 接下来就是转换器。我们的转换器会接收我们创造的抽象语法树并将它和一个访问者对象传给traverser * 函数。然后创造一个新的抽象语法树。 * * ---------------------------------------------------------------------------- * Original AST | Transformed AST * ---------------------------------------------------------------------------- * &#123; | &#123; * type: 'Program', | type: 'Program', * body: [&#123; | body: [&#123; * type: 'CallExpression', | type: 'ExpressionStatement', * name: 'add', | expression: &#123; * params: [&#123; | type: 'CallExpression', * type: 'NumberLiteral', | callee: &#123; * value: '2' | type: 'Identifier', * &#125;, &#123; | name: 'add' * type: 'CallExpression', | &#125;, * name: 'subtract', | arguments: [&#123; * params: [&#123; | type: 'NumberLiteral', * type: 'NumberLiteral', | value: '2' * value: '4' | &#125;, &#123; * &#125;, &#123; | type: 'CallExpression', * type: 'NumberLiteral', | callee: &#123; * value: '2' | type: 'Identifier', * &#125;] | name: 'subtract' * &#125;] | &#125;, * &#125;] | arguments: [&#123; * &#125; | type: 'NumberLiteral', * | value: '4' * ---------------------------------- | &#125;, &#123; * | type: 'NumberLiteral', * | value: '2' * | &#125;] * (sorry the other one is longer.) | &#125; * | &#125; * | &#125;] * | &#125; * ---------------------------------------------------------------------------- */// 所以我们定义一个transformer函数，这个函数接收一个lisp抽象语法树对象。function transformer(ast) &#123; // 我们会创建一个`newAst`，这个新抽象语法树和之前的抽象语法树一样有一个Program节点。 let newAst = &#123; type: 'Program', body: [], &#125;; // 接下来我会小小地作弊一下并使用一个小小的hack。我们会给父节点添加一个`context`属性，我们 // 会将子节点添加到它们的父节点的`context`属性中。通常情况下你会有一个比这个更好的抽象， // 但是针对我们的目的这样做更简洁。 // // 只要记住`context`是一个从旧的抽象语法树到新的抽象语法树的引用即可。 ast._context = newAst.body; // 我们从调用traverser函数并传入抽象语法树和访问者对象开始。 traverser(ast, &#123; // 访问者对象处理的第一种情况是`NumberLiteral`节点。 NumberLiteral: &#123; // 我们会在进入节点的时候访问节点。 enter(node, parent) &#123; //我们创建一个`NumberLiteral`类型的新节点并添加到父节点的`context`。 parent._context.push(&#123; type: 'NumberLiteral', value: node.value, &#125;); &#125;, &#125;, // 接下来是`StringLiteral`类型节点。 StringLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'StringLiteral', value: node.value, &#125;); &#125;, &#125;, // 接着是`CallExpression`类型节点。 CallExpression: &#123; enter(node, parent) &#123; // 我们创建一个新的`CallExpression`类型节点，这个新节点还有一个嵌套的`Identifier`对象。 let expression = &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: node.name, &#125;, arguments: [], &#125;; // 接下来我们给原始的`CallExpression`节点定义一个`context`属性。这个属性指向 // `expression`的arguments属性，这样我们就可以添加参数了。 node._context = expression.arguments; // 接下来我们检测父节点是否是一个`CallExpression`，如果不是的话…… if (parent.type !== 'CallExpression') &#123; // 我们将我们的`CallExpression`节点包裹在`ExpressionStatement`节点中。 // 我们这样做的原因是因为JS中顶层的`CallExpression`实际上是语句。 expression = &#123; type: 'ExpressionStatement', expression: expression, &#125;; &#125; // 最后，我们将我们的`CallExpression`（可能被包裹）添加到父节点的`context`属性。 parent._context.push(expression); &#125;, &#125;, &#125;); // 最后，转换器会返回我们刚刚创造的全新抽象语法树。 return newAst;&#125;/** * ============================================================================ * ヾ（〃＾∇＾）ﾉ♪ * THE CODE GENERATOR!!!! * ============================================================================ *//** * 现在我们进入最后的阶段：代码生成器。 * * 我们的代码生成器会递归地调用自身将树中的每一个节点打印出来，最终形成一个巨大的字符串。 */function codeGenerator(node) &#123; // 我们根据节点类型分情况处理。 switch (node.type) &#123; // 如果我们有一个`Program`节点。我们会使用代码生成器遍历`body`属性中的所有节点然后使用 // 换行符\\n连接起来。 case 'Program': return node.body.map(codeGenerator).join('\\n'); // 针对`ExpressionStatement`我们会对节点的expression属性调用代码生成器，并加上一个分号…… case 'ExpressionStatement': return ( codeGenerator(node.expression) + ';' // &lt;&lt; (...because we like to code the *correct* way) ); // 针对`CallExpression`我们会打印出`callee`，也就是函数名，加上一个开括号，我们会对 // `arguments`数组中的每一个节点调用代码生成器，使用逗号连接它们，然后我们添加一个闭括号。 case 'CallExpression': return ( codeGenerator(node.callee) + '(' + node.arguments.map(codeGenerator).join(', ') + ')' ); // 针对`Identifier`，我们简单地返回节点的name属性。 case 'Identifier': return node.name; // 针对`NumberLiteral`，我们简单地返回节点的值。 case 'NumberLiteral': return node.value; // 针对StringLiteral`，我们在节点value周围加上引号。 case 'StringLiteral': return '\"' + node.value + '\"'; // 如果没有匹配，我们抛出一个错误。 default: throw new TypeError(node.type); &#125;&#125;/** * ============================================================================ * (۶* ‘ヮ’)۶” * !!!!!!!!THE COMPILER!!!!!!!! * ============================================================================ *//** * 终于到了！我们定义我们的`compiler`函数。这个函数会将所有部分连接起来。 * * 1. input =&gt; tokenizer =&gt; tokens * 2. tokens =&gt; parser =&gt; ast * 3. ast =&gt; transformer =&gt; newAst * 4. newAst =&gt; generator =&gt; output */function compiler(input) &#123; let tokens = tokenizer(input); let ast = parser(tokens); let newAst = transformer(ast); let output = codeGenerator(newAst); // 返回输出！ return output;&#125;/** * ============================================================================ * (๑˃̵ᴗ˂̵)و * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!YOU MADE IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! * ============================================================================ */// 这里我只是在导出函数……module.exports = &#123; tokenizer, parser, traverser, transformer, codeGenerator, compiler,&#125;;","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"},{"name":"编译","slug":"编译","permalink":"/tags/编译/"}]},{"title":"nodejs多进程cluster","slug":"nodejs多进程cluster","date":"2020-07-20T03:12:24.000Z","updated":"2024-01-11T07:00:59.226Z","comments":true,"path":"2020/07/20/nodejs多进程cluster/","link":"","permalink":"/2020/07/20/nodejs多进程cluster/","excerpt":"使用cluster开启nodejs多进程","text":"使用cluster开启nodejs多进程 nodejs多进程clusternodejs是单线程语言，如果一台电脑cpu是8核的，nodejs只能使用其中的一个，另外7个都没有使用到，cpu的资源都浪费了。cluster这个包可以开启多个进程，可以完全利用电脑的cpu资源。pm2这个工具内部也是用cluster开启的nodejs多进程笔者写了一个小例子： cluster.js这个文件开启多进程，并且可以守护进程12345678910111213141516171819202122232425262728293031323334353637var cluster = require('cluster');var os = require('os'); // 获取CPU 的数量var numCPUs = os.cpus().length;// numCPUs = 2var process = require('process')var workers = &#123;&#125;;if (cluster.isMaster) &#123; // 主进程分支 cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log('工作进程 %d 关闭 (%s). 重启中...', worker.process.pid, signal || code); delete workers[worker.process.pid] worker = cluster.fork() workers[worker.process.pid] = worker console.log('新的工作进程', worker.process.pid) console.log(Object.keys(workers)) &#125;); console.log('numCPUs:', numCPUs) for (var i = 0; i &lt; numCPUs; i++) &#123; var worker = cluster.fork(); console.log('init ... pid', worker.process.pid) workers[worker.process.pid] = worker; &#125;&#125; else &#123; var app = require('./app'); app.listen(3000);&#125;// 当主进程被终止时，关闭所有工作进程process.on('SIGTERM', function () &#123; for (var pid in workers) &#123; process.kill(pid); &#125; process.exit(0);&#125;); app.js这里就是一个普通http服务程序，有10%的几率抛出错误，检测cluster的守护进程功能123456789101112const http = require('http')const server = http.createServer((request, response) =&gt; &#123; Math.random() &gt; 0.9 ? fn() : '' response.end('Hello jinux')&#125;)if (!module.parent) &#123; server.listen(3000); console.log('app started at port 3000...');&#125; else &#123; module.exports = server&#125; test.js这里用来测试端口123456var request = require('request');setInterval(() =&gt; &#123; request('http://localhost:3000', function (error, response, body) &#123; console.log('body:', body); // Print the HTML for the Google homepage. &#125;)&#125;, 2000); 最后附上demo的代码source","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端","slug":"后端","permalink":"/tags/后端/"}]},{"title":"h5横屏适配","slug":"h5横屏适配","date":"2020-07-16T06:38:59.000Z","updated":"2024-01-11T07:00:59.188Z","comments":true,"path":"2020/07/16/h5横屏适配/","link":"","permalink":"/2020/07/16/h5横屏适配/","excerpt":"h5移动端横屏适配","text":"h5移动端横屏适配 h5横屏适配我们平时在移动端开发时，特别是一些互动小游戏，需要只能在竖屏或者横屏的状态下展示。比如，我们现在有一个需求，要求只能横屏展示，无论用户的手机处于竖屏还是横屏状态，都展示横屏效果。最常用的方式是利用css3的transform rotate,将页面旋转90度。1234567891011121314151617181920212223242526// 利用 CSS3 旋转 对根容器逆时针旋转 90 度var detectOrient = function() &#123; var width = document.documentElement.clientWidth, height = document.documentElement.clientHeight, $wrapper = document.getElementById(\"J_wrapper\"), style = \"\"; if( width &gt;= height )&#123; // 横屏 style += \"width:\" + width + \"px;\"; // 注意旋转后的宽高切换 style += \"height:\" + height + \"px;\"; style += \"-webkit-transform: rotate(0); transform: rotate(0);\"; style += \"-webkit-transform-origin: 0 0;\"; style += \"transform-origin: 0 0;\"; &#125; else&#123; // 竖屏 style += \"width:\" + height + \"px;\"; style += \"height:\" + width + \"px;\"; style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\"; // 注意旋转中点的处理 style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\"; style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\"; &#125; $wrapper.style.cssText = style;&#125;window.onresize = detectOrient;detectOrient(); 以上这段代码可以解决一些常见场景，如果场景更复杂，详见此文。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"常见的web攻击方式","slug":"常见的web攻击方式","date":"2020-06-24T01:38:08.000Z","updated":"2024-01-11T07:00:59.266Z","comments":true,"path":"2020/06/24/常见的web攻击方式/","link":"","permalink":"/2020/06/24/常见的web攻击方式/","excerpt":"常见的web攻击方式","text":"常见的web攻击方式 常见的web攻击方式简要的介绍下web常见的几种攻击方式 XSS详请见本站文章web安全之XSS CSRF详请见本站文章web安全之CSRF 点击劫持比如你访问黑客网站A，A网站iframe引入了一个博客网站B，A网站将iframe透明化，并且在iframe下面放一张美女图片，图片上有一个更新美女信息的按钮，这个按钮正好跟B网站发布信息按钮重合，当你不在意的点击了图片上的按钮，实际你点击的是透明化的B网站的发布信息按钮。 SQL注入SQL注入是对后端数据库的攻击前端页面输入12用户名：admin密码：1'or'1'='1 这里的密码是一段SQL语句，后台在利用前端传来的红户名和密码拼装好一段SQL语句，并查询就会返回true。拼接后的SQL语句：1SELECT * FROM test WHERE username = 'admin' AND password = '1'or'1'='1'; OS注入OS注入式针对操作系统的以nodejs为例，假如在接口中需要从github下载用户指定的repo，代码如下：123const exec = require('mz/child_process').exec;let params = // 用户输入的参数exec(`git clone $&#123;params.repo&#125;`); 如果传入的参数是这样：1https://github.com/xx/xx.git &amp;&amp; rm -rf /* 执行完拉取库的命令后继续执行一个删除当前路径下所有文件的操作。 请求劫持DNS劫持DNS服务器（DNS解析的各个步骤）被纂改，修改了域名解析的结果，使得访问到的不是预期的ip。 HTTP劫持运营商劫持，此时大概只能升级HTTPS了。 DDOS可以看一下阮老师的这篇文章","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"chrome调试之overrides","slug":"chrome调试之overrides","date":"2020-06-22T03:19:42.000Z","updated":"2024-01-11T07:00:59.178Z","comments":true,"path":"2020/06/22/chrome调试之overrides/","link":"","permalink":"/2020/06/22/chrome调试之overrides/","excerpt":"浏览器调试之overrides","text":"浏览器调试之overrides chrome调试之overrides平时我们用浏览器调试代码很普遍，今天我介绍一个浏览器的小技能，可以覆盖网站的代码，在本地生成一个一样的文件，刷新网站的时候浏览器会加载本地生成的文件，这样，可以实时的修改代码并且观察修改后的效果。启用步骤：1.在浏览器的调试面板进入sources.2.点击overrides,会看到一个+ Select folder for overrides,点击加号选择一个存放文件的文件夹。（注意浏览器上方会有一个权限提示，点击允许）3.这时还是在sources面板下，点击Page，切换到此网站的源代码展示目录，选择一个要调试的文件（html,js,css均可），单击右键，选择Save for overrides, 之后可以在刚才选择的文件夹下看到这个保存到本地的文件，修改这个文件后再刷新页面，就可以看到修改后的变化了。4.在overrides面板下可以看到Enable Local Overrides,切换这个选项可以控制本地代码是否参与执行。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"调试","slug":"调试","permalink":"/tags/调试/"},{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}]},{"title":"jwt、session、oauth简单介绍","slug":"jwt、session、oauth简单介绍","date":"2020-06-19T03:04:57.000Z","updated":"2024-01-11T07:00:59.224Z","comments":true,"path":"2020/06/19/jwt、session、oauth简单介绍/","link":"","permalink":"/2020/06/19/jwt、session、oauth简单介绍/","excerpt":"jwt、session、oauth的鉴权简单说明","text":"jwt、session、oauth的鉴权简单说明 jwt、session、oauth简单介绍jwtjwt是json web token的缩写，jwt的鉴权流程如下：123451、用户向服务器发送用户名和密码。2、服务器验证通过后，生成jwt，可以有选择的在其中 保存用户信息及数据。也可以加密。 3、服务器向用户返回jwt。4、用户随后的每一次请求，都会在 cookie 或者 header或参数里，将 jwt 传回服务器鉴权。5、服务器收到jwt，找到前期保存的数据，由此得知用户的身份。 jwt内容：12345678分为 头部（header),载荷（payload)，签证（signature). 用 “.” 分隔。eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NDM0ODg3NjgsImp0aSI6ImFjYzhmZjIzLWM1MjgtNDk3OS04NTYwLWY0NGFmYWNhNDY4MiIsImlzcyI6ImJpenN2YyIsIm5iZiI6NTQzNDgxNTY4LCJzdWIiOiJ0b2tlbi14ajZqOTo3emg1Ymd2OGI1cWZrN2JoNnJxZ3o3djV0OGJ2amhiNHNoazQ5aGh6OGtjcWN6NmpnNWI3ejIifQ.dRKURNOUFOlgO7zBxMajF7-8Wn0zYs8x2t0UU6SYtP4 优缺点：123没有跨域问题、集群下登录信息同步的问题。一旦签发，到期前无法简单废止，最好用https。server无状态，性能高。 sessionsession是利用cookie做健全的，流程如下：123451、用户向服务器发送用户名和密码。2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。3、服务器向用户返回一个 session_id，写入用户的 Cookie。4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 优缺点：12扩展性不好，存在跨域 和 集群session同步的问题。面对csrf 攻击，不如jwt。 oauth 用于第三方认证目的在于让客户端安全可控地获取”用户”的授权。比如说，登录微博（客户端）的时候，懒得新建账号了就用qq账号登录，选择qq登录。1234567oauth场景，客户端不必保存登录用户（qq）的登录密码。 更精细的控制权限，即权限的到期时间，提升安全性。有四种模式： 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 这里我做了一个github的第三方登录鉴权，详情点这里查看。在做鉴权之前，需要登录github，之后在setting-&gt;Developer settings开启github鉴权功能。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"HTTP1,HTTP2,http3的区别","slug":"HTTP1和HTTP2的区别","date":"2020-06-18T06:51:59.000Z","updated":"2024-01-11T07:00:59.122Z","comments":true,"path":"2020/06/18/HTTP1和HTTP2的区别/","link":"","permalink":"/2020/06/18/HTTP1和HTTP2的区别/","excerpt":"简单的说一下HTTP1,HTTP2,http3的区别","text":"简单的说一下HTTP1,HTTP2,http3的区别 HTTP1HTTP/1.0和HTTP/1.1的区别长连接HTTP1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，并且默认使用长连接，如果加入”Connection: close “，才关闭。 短连接是指SOCKET连接后,发送接收完数据后马上断开连接。 因为连接后接收了数据就断开了,所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。 Host域HTTP1.1在Request消息头里头多了一个Host（主机名）域，而且是必传的，HTTP1.0则没有这个域。 消息传递HTTP1.1增加了OPTIONS,PUT, DELETE, TRACE, CONNECT这些Request方法。 HTTP1的缺陷HTTP1主要有以下几个缺陷： 高延迟–带来页面加载速度的降低虽然近几年来网络带宽增长非常快，然而我们却并没有看到网络延迟有对应程度的降低。网络延迟问题主要由于队头阻塞(Head-Of-Line Blocking),导致带宽无法被充分利用。队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。 明文传输–带来的不安全性HTTP/1.1在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。 HTTP2HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，HTTP方法/状态码/语义都与HTTP/1.x一样。HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection），该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。 SPDY协议HTTP/1.1有两个主要的缺点：安全不足和性能不高，由于背负着 HTTP/1.x 庞大的历史包袱,所以协议的修改,兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产。谷歌公开了自行研发的 SPDY 协议，主要解决HTTP/1.1效率不高的问题。谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。│ ┌──────────┴────────────┐│ │ HTTP│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ SPDY│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ SSL│ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ TCP│ └──────────┬────────────┘如上图所示,SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。SPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 HTTP/2 新特性（即HTTP/2.0和HTTP/1.x的区别）二进制传输HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。 Header 压缩HTTP/2 在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，可以达到50%~90%的高压缩率。 用户和网站间只用一个连接HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection），该连接可以承载任意数量的双向数据流。实现细节：每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。 服务器推送服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。 HTTP/2 的缺点TCP的队头阻塞并没有彻底解决：在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的丢包重传机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。 HTTP3QUIC协议Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。 HTTP/3 新特性（HTTP/3与HTTP/2、HTTP/1的区别）QUIC基于UDP，而UDP是无连接的，根本就不需要握手和挥手，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了多路复用机制，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点： 实现了类似TCP的流量控制、传输可靠性的功能虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。 实现了快速握手功能由于QUIC是基于UDP的，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。 集成了TLS加密功能类似于HTTPS。 多路复用，彻底解决TCP中队头阻塞的问题和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。 基于QUIC的0RTT是如何实现的QUIC协议依赖于合并加密和数据传输过程中的握手来创建一个安全的连接。 在连接建立成功后， 客户端会缓存起来原始的连接信息等。 在接下来与相同的服务器建立连接的过程中， 客户端能够在不增加额外RTT的情况下建立一个加密的连接，数据要发送的数据可以在握手的包中捎带着发送过去，而不用等待服务器的回复，从而实现0RTT。所以，所谓QUIC的0RTT是指在建立连接之后，后续发送数据都不需要增加额外的RTT时间，最开始的握手还是需要1RTT的时间消耗的。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"Nodejs常驻后台运行","slug":"Nodejs常驻后台运行","date":"2020-06-05T09:05:27.000Z","updated":"2024-01-11T07:00:59.145Z","comments":true,"path":"2020/06/05/Nodejs常驻后台运行/","link":"","permalink":"/2020/06/05/Nodejs常驻后台运行/","excerpt":"nodejs程序在后台运行","text":"nodejs程序在后台运行 Nodejs常驻后台运行nodejs是通过命令行方式执行，当用户的xshell断开时Nodejs也就停止运行了。下面介绍几种办法让Nodejs常驻在后台运行 pm2(推荐)官网地址12345678npm install -g pm2pm2 start app.js // 启动pm2 start app.js -i max //启动 使用所有CPU核心的集群pm2 stop app.js // 停止pm2 stop all // 停止所有pm2 restart app.js // 重启pm2 restart all // 重启所有pm2 delete app.js // 关闭 nohup1nohup node app.js &amp; forevergithub地址123456npm install forever -gforever start app.js //启动forever stop app.js //关闭forever stopall //关闭全部forever restart app.js //重启forever restartall //重启全部","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}]},{"title":"前端埋点","slug":"前端埋点","date":"2020-05-29T03:13:42.000Z","updated":"2024-01-11T07:00:59.259Z","comments":true,"path":"2020/05/29/前端埋点/","link":"","permalink":"/2020/05/29/前端埋点/","excerpt":"全面的介绍前端埋点知识","text":"全面的介绍前端埋点知识 前端埋点所谓「埋点」，就是在正常的功能逻辑中添加统计逻辑。拿统计微信右上角「+」的点击次数为例，上报的数据可以采用KEY-VALUE形式，我们定义KEY为「CLICK_ADD_BTN」，VALUE的值为点击的次数。当用户点击「+」时，展示菜单的代码会通过按钮的「回调」来触发执行，程序猿在业务代码执行完后，又加上了统计代码，把「CLICK_ADD_BTN」对应的VALUE加1，「+」被统计到了一次使用。目前常见的前端埋点技术有3类：代码埋点、可视化埋点、无埋点（无埋点属于埋点的一个子集）。 代码埋点：控件操作发生时通过预先写好的代码来发送数据。优点： 控制发送数据时间，事件自定义属性详细记录 缺点： 时间、人力成本大，数据传输的时效性。 可视化埋点：利用可视化交互手段，通过可视化界面配置控件操作与事件操作发生关系。通过后台截屏的方式采集数据。优点： 成本低，速度快 缺点： 行为记录信息少，支持的分析方式少 无埋点：Growing IO和Heap analytics，这2家是国内与国外的无埋点技术公司代表。用户展现界面元素时，通过控件绑定触发事件，事件被触发的时候系统会有相应的接口让开发者处理这些行为。现在市面上主流无埋点做法有两种，一种是预先跟踪所有的渲染信息，一种是滞后跟踪的渲染信息。优点： 无需埋点，方便快捷 缺点： 行为记录信息少，传输压力大 总结最后，关于埋点有无问题，可视化埋点和代码优劣问题，不管选择哪个都要从自身情况去考虑，自身分析场景来体验和对比，选择最适合自己的。适合自己的才是最好的。这里推荐两篇介绍比较详细的前端埋点博文:第一篇第二篇","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"微前端","slug":"微前端","date":"2020-05-25T07:11:09.000Z","updated":"2024-01-11T07:00:59.270Z","comments":true,"path":"2020/05/25/微前端/","link":"","permalink":"/2020/05/25/微前端/","excerpt":"初探微前端","text":"初探微前端 微前端微前端最近火了起来，作为紧跟技术潮流的笔者来说，当然要了解一下。贴出一篇笔者觉得不错的文章，Single-Spa + Vue Cli 微前端落地指南。这篇文章写得很不错，笔者就是按照他的思路一步一步的完成了一个微前端的demo。但是，笔者的demo只包含vue，父项目和子项目都是用的vue搭建的，相对来说比较简单些，而且，在实际开发的项目中都是一样的框架也是最好的选择。最后，自己用vue写的一个demo，完成了主框架引入了两个子框架。demo","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"hash&history单页面路由框架","slug":"hash-history单页面路由框架","date":"2020-05-18T03:30:17.000Z","updated":"2024-01-11T07:00:59.191Z","comments":true,"path":"2020/05/18/hash-history单页面路由框架/","link":"","permalink":"/2020/05/18/hash-history单页面路由框架/","excerpt":"hash和history路由形式的单页面框架","text":"hash和history路由形式的单页面框架 hash&amp;history单页面路由框架现在vue,react,angular三大框架已经垄断了前端的单页面应用，用起来很方便，今天笔者写两个hash和history路由的小框架，有时候小项目可能也能用到，相比其它框架可能会配置灵活些。在使用vue等框架之前的单页面应用都是这样做的。细节不写了，附上demo代码：点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"手写vue","slug":"手写vue","date":"2020-04-27T05:54:30.000Z","updated":"2024-01-11T07:00:59.271Z","comments":true,"path":"2020/04/27/手写vue/","link":"","permalink":"/2020/04/27/手写vue/","excerpt":"实现一个基础功能的vue","text":"实现一个基础功能的vue 手写vue实现一个非常简化版vue，暂时实现了v-text,v-html,v-model,@eventName指令，还有插值表达式｛｛｝｝,一共写了4个类去实现，Vue是主类，Dep依赖收集类，Watcher是观察者类，Dep依赖收集去触发Watcher观察者定义的的方法，Compile类是用来解析html的dom元素的，解析的时候向对应的数据添加依赖，这样数据改变视图跟着改变。下面是代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151class Vue &#123; constructor(option) &#123; this.el = option.el &amp;&amp; document.querySelector(option.el); this.$data = option.data; this.$methods = option.methods; this.init(); &#125; init() &#123; this.observer(this.$data); new Compile(this.el, this); &#125; // 给data值设置get，set的数据劫持 observer(daObj) &#123; if(typeof daObj === 'object') &#123; for(let key in daObj) &#123; let value = daObj[key]; if(value &amp;&amp; typeof value === 'object') &#123; this.observer(value); &#125;else &#123; let dep = new Dep(); Object.defineProperty(daObj, key, &#123; get() &#123; Dep.target &amp;&amp; dep.push(Dep.target); return value; &#125;, set(val) &#123; value = val; // 这里注意。依赖触发要在value=val的下边 dep.dispatch(); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;// 依赖类class Dep &#123; constructor() &#123; this.watchers = []; &#125; push(watcher) &#123; this.watchers.push(watcher); &#125; dispatch() &#123; this.watchers.forEach(watcher=&gt; &#123; watcher &amp;&amp; watcher.callback &amp;&amp; watcher.callback(); &#125;); &#125;&#125;// 观察者类class Watcher &#123; constructor(callback) &#123; Dep.target = this; this.callback = callback; &#125;&#125;// 编译模板字符串类class Compile &#123; constructor(el, vm) &#123; this.parseHtml(el, vm); &#125; parseHtml(el, vm) &#123; Array.from(el.childNodes).forEach(item=&gt; &#123; // 处理带有指令的节点元素 this.updateDirect(item, vm); if(item.nodeType === 1 &amp;&amp; item.childNodes.length&gt;0) &#123; // 递归解析 this.parseHtml(item, vm); &#125;else if(item.nodeType === 3 &amp;&amp; /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(item.textContent)) &#123; let epx = RegExp.$1; this.updateText(item, vm, epx); new Watcher(()=&gt; &#123; this.updateText(item, vm, epx); &#125;); eval('vm.$data.' + epx); Dep.target = null; &#125; &#125;); &#125; // 判断是否是指令节点 updateDirect(node, vm) &#123; // 如果元素节点的属性是一个json对象 if(typeof node.attributes === 'object') &#123; // 转换成数组 let attrs = Array.from(node.attributes); if(attrs.length &gt; 0) &#123; for(let i=0; i&lt;attrs.length; i++) &#123; // v-xxx指令 if(/^v\\-.+/.test(attrs[i].name)) &#123; let handleStr = attrs[i].name.substring(2); let epx = attrs[i].value; this['dir'+handleStr](node, vm, epx); &#125; // @事件 if(/^\\@.+/.test(attrs[i].name))&#123; let eventName = attrs[i].name.substring(1); let callbackName = attrs[i].value; this['eventHandler'](node, vm, eventName, callbackName); &#125; &#125; &#125; &#125; &#125; // 处理指令节点数据响应 dirtext(node, vm, epx) &#123; this.updateText(node, vm, epx); new Watcher(()=&gt; &#123; this.updateText(node, vm, epx); &#125;); eval('vm.$data.' + epx); Dep.target = null; &#125; dirhtml(node, vm, epx) &#123; this.updateHtml(node, vm, epx); new Watcher(()=&gt; &#123; this.updateHtml(node, vm, epx); &#125;); eval('vm.$data.' + epx); Dep.target = null; &#125; dirmodel(node, vm, epx) &#123; this.updateValue(node, vm, epx); new Watcher(()=&gt; &#123; this.updateValue(node, vm, epx); &#125;); eval('vm.$data.' + epx); Dep.target = null; // 添加input事件 node.addEventListener('input', (ev)=&gt; &#123; eval('vm.$data.' + epx + '=\"' + ev.target.value + '\"'); &#125;, false); &#125; // 处理指令事件 eventHandler(node, vm, eventName, callbackName) &#123; node.addEventListener(eventName, vm.$methods[callbackName]||loop, false); &#125; // 更改元素节点的textContent updateText(node, vm, epx) &#123; node.textContent = eval('vm.$data.'+epx); &#125; // 更改元素节点的innerHTML updateHtml(node, vm, epx) &#123; node.innerHTML = eval('vm.$data.'+epx); &#125; // 更改input元素的value updateValue(node, vm, epx) &#123; node.value = eval('vm.$data.'+epx); &#125;&#125;var loop = function() &#123;&#125; 代码不多，但是基本功能已经实现。代码点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"手写vuex","slug":"手写vuex","date":"2020-04-21T06:52:06.000Z","updated":"2024-01-11T07:00:59.271Z","comments":true,"path":"2020/04/21/手写vuex/","link":"","permalink":"/2020/04/21/手写vuex/","excerpt":"简单的实现vuex的功能","text":"简单的实现vuex的功能 手写vuexvuex是vue的一个状态管理插件，现在使用的场景非常多，今天，自己简单的实现一下vuex的几个小功能，如state,getter,commit,mutations,dispatch,actions,暂时先实现这么多，有精力的话再补充module,map等。 vuex在vue中的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// store.js文件，也就是配置store的文件import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, getter: &#123; getterCount(state) &#123; return state.count + 5; &#125; &#125;, mutations: &#123; add(state, num) &#123; state.count += num; &#125; &#125;, actions: &#123; addAction(state, num) &#123; setTimeout(()=&gt; &#123; state.commit(&apos;add&apos;, num); &#125;, 2000); &#125; &#125;&#125;)// vue的main.js文件中引入storeimport store from &apos;./store&apos;new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;)// vue具体页面使用&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h2&gt;state-&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;h2&gt;getter-&gt;&#123;&#123;$store.getter.getterCount&#125;&#125;&lt;/h2&gt; &lt;h2&gt;computed-&gt;&#123;&#123;mill&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;onAdd&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;onAddDispatch&quot;&gt;addDispatch&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125; &#125;, computed: &#123; mill() &#123; return this.$store.state.count + 2; &#125; &#125;, methods: &#123; onAdd() &#123; this.$store.commit(&apos;add&apos;, 15); &#125;, onAddDispatch() &#123; this.$store.dispatch(&apos;addAction&apos;, 10); &#125; &#125;&#125;&lt;/script&gt; vuex的实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960let Vue;class Store &#123; constructor(options = &#123;&#125;) &#123; this.options = options; this.vueState = new Vue(&#123; data() &#123; return &#123; state: options.state &#125; &#125; &#125;); // 处理getter操作 this.getter = &#123;&#125;; Object.keys(this.options.getter).forEach(item=&gt; &#123; Object.defineProperty(this.getter, item, &#123; get: ()=&gt; &#123; return this.options.getter[item](this.options.state); &#125; &#125;); &#125;); &#125; // commit方法和mutations commit(type, val) &#123; Object.keys(this.options.mutations).forEach(item=&gt; &#123; if(item === type) &#123; this.options.mutations[item](this.options.state, val); &#125; &#125;) &#125; // dispatch方法和actions dispatch(type, val) &#123; Object.keys(this.options.actions).forEach(item=&gt; &#123; if(item === type) &#123; this.options.actions[item](this, val); &#125; &#125;) &#125; // 获取Store的state，来源于this.vueState，是Vue的一个实例，可以实现了store.state的数据绑定更新页面 get state () &#123; return this.vueState.state; &#125;&#125;// 供Vue.use()调用 function install(_Vue) &#123; Vue = _Vue; Vue.mixin(&#123; beforeCreate: function () &#123; const options = this.$options; if (options.store) &#123; this.$store = options.store; &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; this.$store = options.parent.$store; &#125; &#125; &#125;)&#125;export default &#123; Store, install&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"WebAssembly入门","slug":"WebAssembly入门","date":"2020-04-15T03:15:30.000Z","updated":"2025-03-28T08:13:30.203Z","comments":true,"path":"2020/04/15/WebAssembly入门/","link":"","permalink":"/2020/04/15/WebAssembly入门/","excerpt":"WebAssembly简单实例","text":"WebAssembly简单实例 WebAssembly入门本文章代码运行环境window11 什么是 WebAssembly？WebAssembly（简称 WASM）是一种可以在现代 Web 浏览器中运行的二进制格式。它是一种与平台无关的低级语言，旨在提供接近原生性能的执行速度，主要用于提升 Web 应用的性能，支持多种编程语言（如 C、C++、Rust 等）编译成 WebAssembly 代码，运行在浏览器中。 WebAssembly 的特点 高性能：接近原生速度的执行性能，适合计算密集型任务。 多语言支持：支持 C、C++、Rust、Go 等语言编译为 WASM。 跨平台：同一份代码可以在不同的操作系统和浏览器中运行。 安全性：通过浏览器沙箱环境隔离，增强了执行代码的安全性。 模块化：支持模块化加载，便于代码拆分和复用。 WebAssembly 的应用场景 性能要求高的应用：如游戏、图像处理、音视频编码、3D 渲染等。 现有代码复用：将已有的 C、C++ 库移植到 Web 环境。 多语言支持：结合 JavaScript 进行复杂应用开发。 WebAssembly实践环境准备安装Emscripten工具链（C/C++ 编译为 WebAssembly 的工具）123456# 安装 Emscriptengit clone https://github.com/emscripten-core/emsdk.gitcd emsdkemsdk install latestemsdk activate latestemsdk_env.bat 之后运行emcc -v可以看到版本信息。 编写第一个 WebAssembly 程序编写 C 语言代码创建一个 hello.c 文件，代码如下：123456#include &lt;stdio.h&gt;int main() &#123; printf(\"Hello, WebAssembly!\\n\"); return 0;&#125; 编译为 WebAssembly使用 Emscripten 工具链将 C 代码编译为 WASM 文件1emcc hello.c -o hello.html 该命令会生成以下文件： hello.html：用于测试 WebAssembly 的 HTML 页面。 hello.js：WebAssembly 模块的加载器。 hello.wasm：编译后的 WebAssembly 文件。 运行WebAssembly可以使用http-server启动服务 使用WebAssembly与JavaScript交互创建一个C语言文件创建一个 hello.c 文件，代码如下：123456#include &lt;emscripten/emscripten.h&gt;EMSCRIPTEN_KEEPALIVEint add(int a, int b) &#123; return a + b;&#125; 编译并生成WebAssembly1emcc hello.c -o hello.js -sEXPORTED_FUNCTIONS=&quot;[\\&quot;_add\\&quot;]&quot; -sEXPORTED_RUNTIME_METHODS=&quot;[\\&quot;ccall\\&quot;, \\&quot;cwrap\\&quot;]&quot; 在HTML文件中加载并调用WebAssembly12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;WebAssembly Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;WebAssembly 加法示例&lt;/h1&gt; &lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Module.onRuntimeInitialized = () =&gt; &#123; const add = Module.cwrap(&apos;add&apos;, &apos;number&apos;, [&apos;number&apos;, &apos;number&apos;]); console.log(&apos;1 + 2 =&apos;, add(1, 2)); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript调用C++编写C++代码创建math.cpp文件，代码如下：12345678#include &lt;emscripten/emscripten.h&gt;extern &quot;C&quot; &#123; EMSCRIPTEN_KEEPALIVE int multiply(int a, int b) &#123; return a * b; &#125;&#125; 编译为WebAssembly1emcc math.cpp -o math.js -sEXPORTED_FUNCTIONS=&quot;[\\&quot;_multiply\\&quot;]&quot; -sEXPORTED_RUNTIME_METHODS=&quot;[\\&quot;cwrap\\&quot;]&quot; 调用C++函数html文件中添加以下代码1234567&lt;script src=&quot;math.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Module.onRuntimeInitialized = () =&gt; &#123; const multiply = Module.cwrap(&apos;multiply&apos;, &apos;number&apos;, [&apos;number&apos;, &apos;number&apos;]); console.log(&apos;3 * 4 =&apos;, multiply(3, 4)); &#125;;&lt;/script&gt; C++调用JavaScript编写C++代码创建math.cpp文件，代码如下：123456789#include &lt;emscripten/emscripten.h&gt;#include &lt;emscripten/bind.h&gt;extern &quot;C&quot; &#123; EMSCRIPTEN_KEEPALIVE void call_js() &#123; emscripten_run_script(&quot;console.log(&apos;Hello from C++!&apos;)&quot;); &#125;&#125; 编译为WebAssembly1emcc math.cpp -o math.js -sEXPORTED_FUNCTIONS=&quot;[\\&quot;_call_js\\&quot;]&quot; -sEXPORTED_RUNTIME_METHODS=&quot;[\\&quot;ccall\\&quot;]&quot; 在JavaScript中执行123456&lt;script src=&quot;math.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Module.onRuntimeInitialized = () =&gt; &#123; Module.ccall(&apos;call_js&apos;); &#125;;&lt;/script&gt; WebAssembly生态工具 Emscripten：C/C++ 到 WebAssembly 的编译工具。 wasm-pack：用于将 Rust 代码编译为 WebAssembly。 AssemblyScript：使用 TypeScript 编写 WebAssembly。 Binaryen：WebAssembly 优化和工具链。 总结以上简单的介绍了WebAssembly，上述例子源码","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"点击或触摸事件中的相关X,Y介绍","slug":"点击或触摸事件中的相关X-Y介绍","date":"2020-04-13T01:30:07.000Z","updated":"2024-01-11T07:00:59.273Z","comments":true,"path":"2020/04/13/点击或触摸事件中的相关X-Y介绍/","link":"","permalink":"/2020/04/13/点击或触摸事件中的相关X-Y介绍/","excerpt":"点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍","text":"点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍 点击或触摸事件中的相关X,Y介绍位置属性我们在使用点击事件时，想获取当前鼠标在页面中的位置，可以把事件对象打印出来，看到了下图中的一些相关于x，y的属性。 属性介绍clientX、clientY点击位置距离当前body可视区域的x，y坐标 pageX、pageY对于整个页面来说，包括了被卷去的body部分的长度 screenX、screenY点击位置距离当前电脑屏幕的x，y坐标 offsetX、offsetY相对于带有定位的父盒子的x，y坐标 x、y和screenX、screenY一样 总结","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"web全景图之pannellum","slug":"web全景图之pannellum","date":"2020-04-09T06:32:37.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2020/04/09/web全景图之pannellum/","link":"","permalink":"/2020/04/09/web全景图之pannellum/","excerpt":"开发web全景图的工具库pannellum","text":"开发web全景图的工具库pannellum web全景图之pannellum最近需要开发一个室内全景图的项目，类似于贝壳的VR看房，直接用three.js开发成本太高，于是在网上找到了pannellum这个工具库，不依赖其它的库，而且还小，使用简单。 pannellum官网地址pannellum官网地址 自己做了一个小demodemo地址","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"/tags/3D/"}]},{"title":"AlloyFinger手势库分析","slug":"AlloyFinger手势库分析","date":"2020-03-26T09:13:31.000Z","updated":"2024-01-11T07:00:59.116Z","comments":true,"path":"2020/03/26/AlloyFinger手势库分析/","link":"","permalink":"/2020/03/26/AlloyFinger手势库分析/","excerpt":"移动端手势库AlloyFinger分析","text":"移动端手势库AlloyFinger分析 AlloyFinger手势库分析AlloyFinger这个移动端手势库是腾讯的AlloyTeam团队开发的，体积小，功能强大，简单易用，具体的使用方法见AlloyFinger github这两天闲暇的时候好好的读了几遍这个库的代码，写好了注释，理解了作者的思路，受益匪浅。注释代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354/** * @desc 移动端手势库 * @desc 分析 */;(function(window) &#123; // 获取两点间距离工具函数 function getLen(v) &#123; return Math.sqrt(v.x * v.x + v.y * v.y); &#125; // dot和getAngle函数用来算两次手势状态之间的夹角, cross函数用来算方向的, getRotateAngle函数算手势真正的角度的 function dot(v1, v2) &#123; return v1.x * v2.x + v1.y * v2.y; &#125; // 求两次手势状态之间的夹角 function getAngle(v1, v2) &#123; var mr = getLen(v1) * getLen(v2); if (mr === 0) return 0; var r = dot(v1, v2) / mr; if (r &gt; 1) r = 1; return Math.acos(r); &#125; // 利用cross结果的正负来判断旋转的方向(大于0为逆时针, 小于0为顺时针) function cross(v1, v2) &#123; return v1.x * v2.y - v2.x * v1.y; &#125; // 如果cross大于0那就是逆时针对于屏幕是正角,对于第一象限是负角,所以 角度 * -1, 然后角度单位换算 function getRotateAngle(v1, v2) &#123; var angle = getAngle(v1, v2); if (cross(v1, v2) &gt; 0) &#123; angle *= -1; &#125; return angle * 180 / Math.PI; &#125; var HandlerAdmin = function(el) &#123; this.handlers = []; this.el = el; &#125;; // 函数管理构造函数 function HandlerAdmin(el) &#123; this.handlers = []; this.el = el; &#125; // 添加需要触发的函数 HandlerAdmin.prototype.add = function(handler) &#123; this.handlers.push(handler); &#125; // 删除需要触发的函数 HandlerAdmin.prototype.del = function(handler) &#123; // 如果什么也不传，清空函数数组 if(!handler) &#123; this.handlers = []; &#125; // 比对数组中的函数，并且删除它 for(var i=this.handlers.length; i&gt;=0; i--) &#123; if(this.handlers[i] === handler) &#123; this.handlers.splice(i, 1); &#125; &#125; &#125; // 运行需要触发的函数 HandlerAdmin.prototype.dispatch = function() &#123; for(var i=0,len=this.handlers.length; i&lt;len; i++) &#123; var handler = this.handlers[i]; // 运行这些函数的时候，是作为元素的事件触发的，所以，这些函数的this要指向这个元素 if(typeof handler === &apos;function&apos;) handler.apply(this.el, arguments); &#125; &#125; // 初始化函数管理对象 function wrapFunc(el, handler) &#123; var handlerAdmin = new HandlerAdmin(el); handlerAdmin.add(handler); return handlerAdmin; &#125; // 手势库构造函数 function AlloyFinger(el, option) &#123; // 获取添加事件的元素 this.element = typeof el === &apos;string&apos; ? document.querySelector(el) : el; // 因为添加事件后这些方法的执行上下文是this.element，所以给方法bind JinuxFinger这个执行上下文 this.start = this.start.bind(this); this.move = this.move.bind(this); this.end = this.end.bind(this); this.cancel = this.cancel.bind(this); // 给这个元素添加事件 this.element.addEventListener(&quot;touchstart&quot;, this.start, false); this.element.addEventListener(&quot;touchmove&quot;, this.move, false); this.element.addEventListener(&quot;touchend&quot;, this.end, false); this.element.addEventListener(&quot;touchcancel&quot;, this.cancel, false); // 定义一些实例属性 this.preV = &#123; x: null, y: null &#125;; // 两个手指间的x距离和y距离 this.pinchStartLen = null; // 捏拽的长度 this.zoom = 1; // 缩放比例 this.isDoubleTap = false; // 是否是双击 var noop = function() &#123;&#125; // 空函数 // 实例化JinuxFinger时，设置的手势回调函数 this.rotate = wrapFunc(this.element, option.rotate || noop); // 旋转 this.touchStart = wrapFunc(this.element, option.touchStart || noop); // 触摸开始 this.multipointStart = wrapFunc(this.element, option.multipointStart || noop); // 多个手指触摸开始 this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop); // 多个手指触摸结束，如4个手指触摸，屏幕上剩下1个或不剩都会触发 this.pinch = wrapFunc(this.element, option.pinch || noop); // 两个手指捏拽 this.swipe = wrapFunc(this.element, option.swipe || noop); // 上下左右滑动，手指离开时触发 this.tap = wrapFunc(this.element, option.tap || noop); // 无论是单击还是双击都会触发 this.doubleTap = wrapFunc(this.element, option.doubleTap || noop); // 双击触发 this.longTap = wrapFunc(this.element, option.longTap || noop); // 单手指长按触发，750ms this.singleTap = wrapFunc(this.element, option.singleTap || noop); // 单击触发，250ms this.pressMove = wrapFunc(this.element, option.pressMove || noop); // 1个手指屏幕上移动触发 this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop); // 2个以上手指屏幕上移动触发 this.touchMove = wrapFunc(this.element, option.touchMove || noop); // 无论几个手指在屏幕上移动都会触发 this.touchEnd = wrapFunc(this.element, option.touchEnd || noop); // 触摸结束都会触发 this.touchCancel = wrapFunc(this.element, option.touchCancel || noop); // 事件简单的说是在移动端发生了触摸中断，一般情况下就是优先级比当前活动更高的事件时，才会触发的。比如正在看新闻，手指滑动屏幕的时候，突然来电话，直接中断了触摸事件，跳转到了通话，页面此时就触发了touchcancel事件。这个事件不容易在浏览器的模拟器中模拟，之前我在用电脑的任务栏切换的时候，受到启发，可以试试在浏览器模拟器触摸的同时，按下键盘上的Alt+Tab键，果然触发了touchcancel事件，有兴趣的小伙伴可以试一下。 this._cancelAllHandler = this.cancelAll.bind(this); // 触发window的scroll事件时，清除现有touch事件的回调函数执行 window.addEventListener(&apos;scroll&apos;, this._cancelAllHandler); this.delta = null; // 双击的间隔时间 this.last = null; // 相对于下一次点击，前一次点击的时间 this.now = null; // 当前点击保存用的时间，也可以理解为相对于上一次点击，这个是当前点击的时间 this.tapTimeout = null; this.singleTapTimeout = null; this.longTapTimeout = null; this.swipeTimeout = null; this.x1 = this.x2 = this.y1 = this.y2 = null; this.preTapPosition = &#123; x: null, y: null &#125;; // 相对于下次点击，前一次点击手指x,y坐标的保存对象 &#125; AlloyFinger.prototype = &#123; start: function (evt) &#123; if (!evt.touches) return; // 屏幕上没有手指则返回 this.now = Date.now(); // 设置touch开始时的时间 this.x1 = evt.touches[0].pageX; // 第一个手指触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动 this.y1 = evt.touches[0].pageY; // 第一个手指触点相对于HTML文档左边沿的的Y坐标 this.delta = this.now - (this.last || this.now); // 双击的间隔时间 this.touchStart.dispatch(evt, this.element); // 触发了touchStart回调函数 if (this.preTapPosition.x !== null) &#123; // 如果不为null，说明之前已经有点击了 // 判断是否满足手指双击条件 this.isDoubleTap = (this.delta &gt; 0 &amp;&amp; this.delta &lt;= 250 &amp;&amp; Math.abs(this.preTapPosition.x - this.x1) &lt; 30 &amp;&amp; Math.abs(this.preTapPosition.y - this.y1) &lt; 30); if (this.isDoubleTap) clearTimeout(this.singleTapTimeout); &#125; this.preTapPosition.x = this.x1; // 保存当前手指x坐标 this.preTapPosition.y = this.y1;// 保存当前手指y坐标 this.last = this.now; // 保存当前时间 var preV = this.preV, len = evt.touches.length; // 现在屏幕上有多少个手指 if (len &gt; 1) &#123; // 两个手指以上触摸情况 this._cancelLongTap(); // 清除长按回调函数的执行 this._cancelSingleTap(); // 清除点击函数的执行 // 计算两个手指x,y的距离 var v = &#123; x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 &#125;; // 赋值给preV preV.x = v.x; preV.y = v.y; this.pinchStartLen = getLen(preV); // 计算出两个手指间的距离 this.multipointStart.dispatch(evt, this.element); // 触发多点触碰函数回调 &#125; this._preventTap = false; // 长按是否回调执行，否 this.longTapTimeout = setTimeout(function () &#123; // 长按触发回调函数的定时器 this.longTap.dispatch(evt, this.element); // 触发长按回调函数 this._preventTap = true; // 长按是否回调执行，是 &#125;.bind(this), 750); // 长按是手指按下750ms后触发 &#125;, move: function (evt) &#123; if (!evt.touches) return; // 没有touches属性则返回 var preV = this.preV, // 两个手指间距离暂存preV里 len = evt.touches.length, // 屏幕上的手指数 currentX = evt.touches[0].pageX, // 屏幕上第一个手指的pageX暂存 currentY = evt.touches[0].pageY; // 屏幕上第一个手指的pageY暂存 this.isDoubleTap = false; // 手指移动了，就不是双击了 if (len &gt; 1) &#123; // 手指大于2个情况 var sCurrentX = evt.touches[1].pageX, // 屏幕上第2个手指的pageX暂存 sCurrentY = evt.touches[1].pageY; // 屏幕上第2个手指的pageY暂存 // 两个手指间距离 var v = &#123; x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY &#125;; if (preV.x !== null) &#123; if (this.pinchStartLen &gt; 0) &#123; // move之前两指间的距离如果大于0情况 evt.zoom = getLen(v) / this.pinchStartLen; // move后的距离/move前的，就是捏拽的比例 this.pinch.dispatch(evt, this.element); // 触发捏拽回调，并将zoom属性传递到事件对象里 &#125; // 获取手指移动的角度 evt.angle = getRotateAngle(v, preV); this.rotate.dispatch(evt, this.element); // 触发旋转回调函数 &#125; preV.x = v.x; // move时将现在两指间的距离x赋值给preV preV.y = v.y; // move时将现在两指间的距离y赋值给preV if (this.x2 !== null &amp;&amp; this.sx2 !== null) &#123; // 因为是两个手指，所以取的是两个手指中间的值，两次move之间的偏移量,参考下变一个手指情况 evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2; evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2; &#125; else &#123; // 第一次移动都为0 evt.deltaX = 0; evt.deltaY = 0; &#125; this.twoFingerPressMove.dispatch(evt, this.element); // 两个以上手指移动的事件回调 this.sx2 = sCurrentX; // 第二个手指坐标x暂存 this.sy2 = sCurrentY; // 第二个手指坐标y暂存 &#125; else &#123; // 单指move情况下 if (this.x2 !== null) &#123; // 第一次移动this.x2=null的,第二次之后才为true evt.deltaX = currentX - this.x2; // x方向两次move事件的差值 evt.deltaY = currentY - this.y2; // y方向两次move事件的差值 //move事件中添加对当前触摸点到初始触摸点的判断， //如果曾经大于过某个距离(比如10),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。 var movedX = Math.abs(this.x1 - this.x2), movedY = Math.abs(this.y1 - this.y2); if(movedX &gt; 10 || movedY &gt; 10)&#123; this._preventTap = true; &#125; &#125; else &#123; // 第一次移动都为0 evt.deltaX = 0; evt.deltaY = 0; &#125; this.pressMove.dispatch(evt, this.element); // 一个手指移动的触发回调 &#125; this.touchMove.dispatch(evt, this.element); // 有移动就触发touchMove事件回调 this._cancelLongTap(); // 有移动事件了，清除长按的事件回调 this.x2 = currentX; // 将当前第一个手指的坐标x复制给this.x2 this.y2 = currentY; // 将当前第一个手指的坐标y复制给this.y2 if (len &gt; 1) &#123; // 两个以上手指，阻止浏览器默认事件 evt.preventDefault(); &#125; &#125;, end: function (evt) &#123; if (!evt.changedTouches) return; // end事件触发时，changedTouches为空，则返回 this._cancelLongTap(); // 取消长按的回调函数 var self = this; // this暂存在bianliangself if (evt.touches.length &lt; 2) &#123; // 目前屏幕上留下的手指0或者1个 this.multipointEnd.dispatch(evt, this.element); // 调用多指触摸的结束回调 this.sx2 = this.sy2 = null; &#125; //swipe // this.x2或this.y2有值说明有在屏幕上移动，并且计算移动后离开屏幕时的坐标与this.x1手指刚触摸屏幕时的坐标差值大于30，可以出发swipe事件回调 if ((this.x2 &amp;&amp; Math.abs(this.x1 - this.x2) &gt; 30) || (this.y2 &amp;&amp; Math.abs(this.y1 - this.y2) &gt; 30)) &#123; // 获取滑动的方向 evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2); this.swipeTimeout = setTimeout(function () &#123; // 触发swipe回调函数，加入宏任务队列 self.swipe.dispatch(evt, self.element); &#125;, 0) &#125; else &#123; // 这里说明不是swipe事件，只是点击事件 this.tapTimeout = setTimeout(function () &#123; // 点击定时器 if(!self._preventTap)&#123; // 长按事件函数没有执行 self.tap.dispatch(evt, self.element); // 执行tap回调 &#125; // trigger double tap immediately if (self.isDoubleTap) &#123; // 如果是双击的话 self.doubleTap.dispatch(evt, self.element); // 执行双击事件回调 self.isDoubleTap = false; // 执行之后设置双击标识为假 &#125; &#125;, 0) if (!self.isDoubleTap) &#123; // 如果不是双击操作 self.singleTapTimeout = setTimeout(function () &#123; // 250ms后执行singleTap事件回调 self.singleTap.dispatch(evt, self.element); &#125;, 250); &#125; &#125; this.touchEnd.dispatch(evt, this.element); // 手指离开都会触发touchEnd事件回调 // 手指离开后将一些属性重置 this.preV.x = 0; this.preV.y = 0; this.zoom = 1; this.pinchStartLen = null; this.x1 = this.x2 = this.y1 = this.y2 = null; &#125;, cancelAll: function () &#123; this._preventTap = true; // 阻止tap事件 clearTimeout(this.singleTapTimeout); // 清除singleTapTimeout定时器 clearTimeout(this.tapTimeout); // 清除tapTimeout定时器 clearTimeout(this.longTapTimeout); // 清除longTapTimeout定时器 clearTimeout(this.swipeTimeout); // 清除swipeTimeout定时器 &#125;, cancel: function (evt) &#123; // cancel事件 this.cancelAll() this.touchCancel.dispatch(evt, this.element); // 触发touchCancel回调 &#125;, _cancelLongTap: function () &#123; // 清除longTapTimeout定时器函数 clearTimeout(this.longTapTimeout); &#125;, _cancelSingleTap: function () &#123; // 清除singleTapTimeout定时器函数 clearTimeout(this.singleTapTimeout); &#125;, // 计算swipe的方向函数 _swipeDirection: function (x1, x2, y1, y2) &#123; return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? &apos;Left&apos; : &apos;Right&apos;) : (y1 - y2 &gt; 0 ? &apos;Up&apos; : &apos;Down&apos;) &#125;, // 使用实例给事件添加回调函数 on: function(evt, handler) &#123; if(this[evt]) &#123; this[evt].add(handler); &#125; &#125;, // 使用实例给事件删除回调函数 off: function(evt, handler) &#123; if(this[evt]) &#123; this[evt].del(handler); &#125; &#125;, // 实例销毁函数 destroy: function() &#123; if(this.singleTapTimeout) clearTimeout(this.singleTapTimeout); if(this.tapTimeout) clearTimeout(this.tapTimeout); if(this.longTapTimeout) clearTimeout(this.longTapTimeout); if(this.swipeTimeout) clearTimeout(this.swipeTimeout); this.element.removeEventListener(&quot;touchstart&quot;, this.start); this.element.removeEventListener(&quot;touchmove&quot;, this.move); this.element.removeEventListener(&quot;touchend&quot;, this.end); this.element.removeEventListener(&quot;touchcancel&quot;, this.cancel); this.rotate.del(); this.touchStart.del(); this.multipointStart.del(); this.multipointEnd.del(); this.pinch.del(); this.swipe.del(); this.tap.del(); this.doubleTap.del(); this.longTap.del(); this.singleTap.del(); this.pressMove.del(); this.twoFingerPressMove.del() this.touchMove.del(); this.touchEnd.del(); this.touchCancel.del(); this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null; window.removeEventListener(&apos;scroll&apos;, this._cancelAllHandler); return null; &#125; &#125; // 暴露给外部使用 if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof exports === &apos;object&apos;) &#123; module.exports = AlloyFinger; &#125; else &#123; window.AlloyFinger = AlloyFinger; &#125;&#125;)(window)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"手写call,apply,bind函数","slug":"手写call-apply-bind函数","date":"2020-03-25T06:17:43.000Z","updated":"2024-01-11T07:00:59.270Z","comments":true,"path":"2020/03/25/手写call-apply-bind函数/","link":"","permalink":"/2020/03/25/手写call-apply-bind函数/","excerpt":"手写call,apply,bind函数","text":"手写call,apply,bind函数 手写call,apply,bind函数call12345678Function.prototype.myCall = function(context) &#123; context = context || window; var arg = Array.prototype.slice.call(arguments, 1); context.fn = this; var result = context.fn(...arg); delete context.fn; return result;&#125; 测试12345678var testObj = &#123; name: 123&#125;function testFn(a,b,c) &#123; console.log(this, a, b, c); return 555;&#125;testFn.myCall(testObj, 1, 2, 3); apply12345678Function.prototype.myApply = function(context) &#123; context = context || window; var arg = arguments[1]; context.fn = this; var result = context.fn(...arg); delete context.fn; return result;&#125; 测试12345678var testObj = &#123; name: 123&#125;function testFn(a,b,c) &#123; console.log(this, a, b, c); return 555;&#125;testFn.myApply(testObj, [1, 2, 3]); bind1234567891011121314Function.prototype.myBind = function(context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; let _this = this let args = [...arguments].slice(1) return function F() &#123; // 判断是否被当做构造函数使用 if (this instanceof F) &#123; return _this.apply(this, args.concat([...arguments])) &#125; return _this.apply(context, args.concat([...arguments])) &#125;&#125; 测试12345678var testObj = &#123; name: 123&#125;function testFn(a,b,c) &#123; console.log(this, a, b, c); return 555;&#125;testFn.myBind(testObj, 1)(2, 3); 以上就是我们常用的call，apply，bind函数的手写实现，但是，用到了es6的[…arg]结构语法，下面只写一个call实现的es5版本。 call es5版123456789101112131415161718Function.prototype.myCall = function(context) &#123; context = context || window; var arg = Array.prototype.slice.call(arguments, 1); context.fn = this; var fnStr = `context.fn(`; for(var i=0, len=arg.length; i&lt;len; i++) &#123; if(i === (len-1)) &#123; fnStr += arg[i]; &#125;else &#123; fnStr += arg[i] + &apos;,&apos;; &#125; &#125; fnStr += &apos;)&apos;; console.log(fnStr); var result = eval(fnStr); delete context.fn; return result;&#125; 测试12345678var testObj = &#123; name: 123&#125;function testFn(a,b,c) &#123; console.log(this, a, b, c); return 555;&#125;testFn.myCall(testObj, 1, 2, 3);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"手写Promise","slug":"手写Promise","date":"2020-03-20T05:30:12.000Z","updated":"2024-01-11T07:00:59.270Z","comments":true,"path":"2020/03/20/手写Promise/","link":"","permalink":"/2020/03/20/手写Promise/","excerpt":"模拟一个Promise功能","text":"模拟一个Promise功能 手写Promise现在的异步基本上都是用Promise来实现的，用起来很方便，但是，Promise是怎么实现的呢，它的then回调是怎么工作的，带着这些疑问，决定自己实现一个Promise。早在2年前，其实我就实现过一个Promise，不过那个原理比较笨，还用到了定时器循环，后来陆续看了些其他人的写法，还是有点没绕明白，这两天又看了向军老师的实现方式，觉得很好，自己也实现一下。主要的难以理解的地方是then函数的写法，这个地方明白了整个Promise也就理解了。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149class MyPromise &#123; // 等待状态 static PENDING = &quot;pending&quot;; // 成功状态 static FULFILLED = &quot;fulfilled&quot;; // 拒绝状态 static REJECTED = &quot;rejected&quot;; constructor(executor) &#123; // 默认状态是等待 this.status = MyPromise.PENDING; // 成功值 this.value = null; // 拒绝值 this.reason = null; // then的回调数组 this.callbacks = []; try &#123; executor(this.resolve.bind(this), this.reject.bind(this)); &#125; catch (error) &#123; this.reject(error); &#125; &#125; // 成功调用函数 resolve(value) &#123; if(this.status === MyPromise.PENDING) &#123; this.value = value; this.status = MyPromise.FULFILLED; setTimeout(()=&gt; &#123; this.callbacks.forEach(item=&gt; &#123; item.onFulfilled(this.value); &#125;); &#125;); &#125; &#125; // 拒绝调用函数 reject(reason) &#123; if(this.status === MyPromise.PENDING) &#123; this.reason = reason; this.status = MyPromise.REJECTED; setTimeout(()=&gt; &#123; this.callbacks.forEach(item=&gt; &#123; item.onRejected(this.reason); &#125;); &#125;); &#125; &#125; // then函数 then(onFulfilled, onRejected) &#123; if (typeof onFulfilled != &quot;function&quot;) &#123; onFulfilled = () =&gt; this.value; &#125; if (typeof onRejected != &quot;function&quot;) &#123; onRejected = () =&gt; this.reason; &#125; // 链式调用，返回一个MyPromise const p = new MyPromise((resolve, reject)=&gt; &#123; if(this.status === MyPromise.PENDING) &#123; this.callbacks.push(&#123; onFulfilled: (value)=&gt; &#123; let result = onFulfilled(value); if(result instanceof MyPromise) &#123; result.then(resolve, reject); &#125;else &#123; resolve(result); &#125; &#125;, onRejected: (value)=&gt; &#123; let result = onRejected(value); if(result instanceof MyPromise) &#123; result.then(resolve, reject); &#125;else &#123; resolve(result); &#125; &#125; &#125;); &#125; if(this.status === MyPromise.FULFILLED) &#123; setTimeout(()=&gt; &#123; let result = onFulfilled(this.value); if(result instanceof MyPromise) &#123; result.then(resolve, reject); &#125;else &#123; resolve(result); &#125; &#125;); &#125; if(this.status === MyPromise.REJECTED) &#123; setTimeout(()=&gt; &#123; let result = onRejected(this.reason); if(result instanceof MyPromise) &#123; result.then(resolve, reject); &#125;else &#123; resolve(result); &#125; &#125;); &#125; &#125;); return p; &#125; // MyPromise.resolve方法 static resolve(value) &#123; return new MyPromise((resolve, reject)=&gt; &#123; if(value instanceof MyPromise) &#123; value.then(resolve, reject); &#125; resolve(value); &#125;); &#125; // MyPromise.reject方法 static reject(reason) &#123; return new MyPromise((resolve, reject)=&gt; &#123; reject(reason); &#125;); &#125; // MyPromise.all方法 static all(promises) &#123; return new MyPromise((resolve, reject)=&gt; &#123; let values = []; promises.forEach(item =&gt; &#123; item.then( value=&gt; &#123; values.push(value); if(values.length === promises.length) &#123; resolve(values); &#125; &#125;, reason=&gt; &#123; reject(reason); &#125; ); &#125;); &#125;); &#125; // MyPromise.race方法 static race(promises) &#123; return new MyPromise((resolve, reject)=&gt; &#123; promises.forEach(item =&gt; &#123; item.then( value=&gt; &#123; resolve(value); &#125;, reason=&gt; &#123; reject(reason); &#125; ); &#125;); &#125;); &#125;&#125; demo代码点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"nodejs环境变量NODE_ENV","slug":"nodejs环境变量NODE-ENV","date":"2020-03-17T07:20:52.000Z","updated":"2024-01-11T07:00:59.227Z","comments":true,"path":"2020/03/17/nodejs环境变量NODE-ENV/","link":"","permalink":"/2020/03/17/nodejs环境变量NODE-ENV/","excerpt":"nodejs环境变量NODE_ENV的设置和获取","text":"nodejs环境变量NODE_ENV的设置和获取 nodejs环境变量NODE_ENV我们在使用webpack打包的时候，会根据环境变量的不同做各种操作，那么，环境变量是如何设置和获取的呢？首先说一下，在命令行中设置的环境变量是临时的，当命令行关闭后就没有了，要想持久化的设置环境变量，只能到我的电脑，属性，高级，环境变量里设置。 首先，创建一个app.js的文件，内容1console.log(process.env.NODE_ENV); 我们把环境变量打印出来看看。在命令行下(window系统的cmd可以，powershell和git bash不行)，输入1set NODE_ENV=pro &amp;&amp; node app.js 打印出pro如果想在powershell和git bash都可以使用，那就得利用npm，在package.json中的scripts里：123&quot;scripts&quot;: &#123; &quot;pro&quot;: &quot;set NODE_ENV=pro &amp;&amp; node app.js&quot; &#125;, 利用npm可以获取NODE_ENV的值。这种方法的不足是，set NODE_ENV=pro是window的方式，而linux和ios是export NODE_ENV=&#39;pro&#39;,为了一套命令的兼容性，我们可以使用cross-env这个nodejs模块，使用方法是：1234&quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=dev node app.js&quot; &#125;, 好了，我们已经可以获取NODE_ENV环境变量了。再介绍一个可以获取命令行参数的方便方法，process.env.npm_config_argv看名字就知道，只能在npm命令下使用，我们来看看具体使用方法：1console.log(process.env.npm_config_argv); 当我们执行npm run dev打印出1&#123;&quot;remain&quot;:[],&quot;cooked&quot;:[&quot;run&quot;,&quot;dev&quot;],&quot;original&quot;:[&quot;run&quot;,&quot;dev&quot;]&#125; 我们可以分析是dev还是pro来处理不同操作。其实，我们想做的莫非就是利用命令行中不同的参数做不同的操作而已，nodejs有一个process.argv属性，可以获取命令行下的参数，来看一个例子：1console.log(process.argv); 我们在命令行下执行：node app.js dev pro。打印出1234[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;C:\\\\Jinux\\\\test\\\\nodejs-env\\\\app.js&apos;, &apos;dev&apos;, &apos;pro&apos; ] 我们还是可以根据命令行下的参数做不同的操作。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"iPhoneX适配","slug":"iPhoneX适配","date":"2020-03-13T06:24:28.000Z","updated":"2024-01-11T07:00:59.192Z","comments":true,"path":"2020/03/13/iPhoneX适配/","link":"","permalink":"/2020/03/13/iPhoneX适配/","excerpt":"h5在iPhoneX中的页面兼容处理","text":"h5在iPhoneX中的页面兼容处理 iPhoneX适配基础设备信息首先在了解iPhoneX适配之前，需要了解关于iPhone设备的一些基础 关于iPhone的一些基础参数 iPhoneX设备信息iPhoneX屏幕组成：上部齐刘海sensor housing（44pt） + 安全区域safe area + 底部手势区域Home Indicator（34pt）safe area（安全区域）安全区域以外的是上部“齐刘海” 和 下部“手势区域”，一般情况下，我们都会在安全区域（safe area）中进行页面的编写； iPhoneX适配适配方案viewport-fit1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt; viewport-fit有两个值，contain和 cover默认是contain，页面内容显示在safe area中（不包括上部的齐刘海和下部的手势区域）cover值：页面内容充满屏幕 适配方案css constant()css constant()有四个值：safe-area-inset-top , safe-area-inset-left , safe-area-inset-right , safe-area-inset-bottom1)当viewport-fit:contain，上面这个四个值无效2)当viewport-fit:cover，这四个值需要设置，页面才会显示在安全区域中，设置如下：123456body &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px &#125; 适配方案媒体查询123@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123; // iphoneX css部分&#125; 总结viewport-fit:contain1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=contain&quot;&gt; viewpoer-fit: cover + css canstant()1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt; 123456body &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px &#125; css的媒体查询123@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123; // iphoneX css部分&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"/tags/兼容性/"}]},{"title":"generator自动运行器","slug":"generator自动运行器","date":"2020-03-12T07:08:06.000Z","updated":"2024-01-11T07:00:59.180Z","comments":true,"path":"2020/03/12/generator自动运行器/","link":"","permalink":"/2020/03/12/generator自动运行器/","excerpt":"手写一个generator自动运行器","text":"手写一个generator自动运行器 generator自动运行器generator函数是es6新出的功能，之后又推出了async函数，操作异步真的是超级简单。我觉得我们在实际项目中使用generator的机会非常少，即使使用，一般也会依赖co这样的库来方便的使用generator。但是我却想研究一下generator，所以写了一个generator不用手动的调用next函数，而是自动的调用。 generator手动next代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var p1 = function() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(1); &#125;, 2000); &#125;); &#125; var p2 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+2); &#125;, 2000); &#125;); &#125; var p3 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+3); &#125;, 1500); &#125;); &#125; var p1callback = function(res) &#123; console.log(&apos;第1个yield的callback啊-&gt;&apos;, res); &#125; var p2callback = function(res) &#123; console.log(&apos;第2个yield的callback啊-&gt;&apos;, res); &#125; var p3callback = function(res) &#123; console.log(&apos;第3个yield的callback啊-&gt;&apos;, res); &#125; function *gen() &#123; var val_1 = yield p1(); var val_2 = yield p2(val_1); var val_3 = yield p3(val_2); &#125; var g = gen(); window.gObj = null; window.gObj_index = 0; gObj = g.next(); gObj.value.then(function(res) &#123; console.log(&apos;第1个yield的callback啊-&gt;&apos;, res); gObj = g.next(res); gObj.value.then(function(res) &#123; console.log(&apos;第2个yield的callback啊-&gt;&apos;, res); gObj = g.next(res); gObj.value.then(function(res) &#123; console.log(&apos;第3个yield的callback啊-&gt;&apos;, res); &#125;); &#125;); &#125;); 上面的代码，需要在generator函数里手动定义yield的表达式，之后在执行的时候需要手动的调用next函数，但是可以看出来，还是有嵌套的情况。 generator自动运行代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// p1,p2,p3是3个Promise的执行函数 var p1 = function() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(1); &#125;, 2000); &#125;); &#125; var p2 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+2); &#125;, 2000); &#125;); &#125; var p3 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+3); &#125;, 1500); &#125;); &#125; // p1callback,p2callback,p3callback对应着p1,p2,p3的回调 var p1callback = function(res) &#123; console.log(&apos;第1个yield的callback啊-&gt;&apos;, res); &#125; var p2callback = function(res) &#123; console.log(&apos;第2个yield的callback啊-&gt;&apos;, res); &#125; var p3callback = function(res) &#123; console.log(&apos;第3个yield的callback啊-&gt;&apos;, res); &#125; /** * @desc generator的生成函数 * @param &#123; Array &#125; Promise的函数数组 * @retuen &#123; Function &#125; generator函数 */ function gen(arr) &#123; var valArr = []; return function *() &#123; for(var i=0; i&lt;arr.length; i++) &#123; valArr[i] = yield arr[i](valArr[i-1]); &#125; &#125; &#125; /** * @desc 自动执行generator的next()的函数 * @param &#123; Function &#125; gen函数 * @param &#123; Array &#125; Promise函数对应的回调函数数组 * @param &#123; Any &#125; 向generator的next中传入的值 */ function co(gen, arr, res) &#123; var g = gen(); var gObj = null; var gObj_index = 0; function innerCo(g, arr, res) &#123; gObj = g.next(res); if(gObj.done) return void 0; gObj.value.then(function(res) &#123; arr[gObj_index++](res); if(!gObj.done) &#123; innerCo(g, arr, res); &#125; &#125;); &#125; innerCo(g, arr, 0); &#125; // 执行co函数 co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0); 可以看出来，最后只需要co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);这样一行代码，省去了定义yield，省去了调用next。 总结 首先，我并没有去参考co这样的库的使用方法，如何使用都是自己想出来的。 目前代码只是超级简化版，我也是想验证一下我的想法而已，只有resolve的回调，并没写reject的回调。 最后，代码在这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"前端性能优化之时间切片","slug":"前端性能优化之时间切片","date":"2020-03-12T06:12:08.000Z","updated":"2024-01-11T07:00:59.261Z","comments":true,"path":"2020/03/12/前端性能优化之时间切片/","link":"","permalink":"/2020/03/12/前端性能优化之时间切片/","excerpt":"前端性能优化之时间切片","text":"前端性能优化之时间切片 前端性能优化之时间切片从用户的输入，再到显示器在视觉上给用户的输出，这一过程如果超过 100ms，那么用户会察觉到网页的卡顿，所以为了解决这个问题，每个任务不能超过 50ms，W3C 性能工作组在 LongTask 规范中也将超过 50ms 的任务定义为长任务。所以为了避免长任务，一种方案是使用 Web Worker，将长任务放在 Worker 线程中执行，缺点是无法访问 DOM，而另一种方案是使用时间切片。 什么是时间切片时间切片的核心思想是：如果任务不能在 50 毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过 50ms 的小任务分散在宏任务队列中执行。上图可以看到主线程中有一个长任务，这个任务会阻塞主线程。使用时间切片将它切割成很多个小任务后，如下图所示。可以看到现在的主线程有很多密密麻麻的小任务，我们将它放大后如下图所示。可以看到每个小任务中间是有空隙的，代表着任务执行了一小段时间后，将让出主线程的控制权，让浏览器执行其他的任务。 使用时间切片的缺点是，任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。但是为了避免卡死浏览器，这种取舍是很有必要的。 如何使用时间切片时间切片是一种概念，也可以理解为一种技术方案，它不是某个 API 的名字，也不是某个工具的名字。事实上，时间切片充分利用了“异步”，在早期，可以使用定时器来实现，例如：123456btn.onclick = function() &#123; someThing() // 执行了50毫秒 setTimeout(function() &#123; otherThing() // 执行了50毫秒 &#125;)&#125; 上面代码当按钮被点击时，本应执行 100 毫秒的任务现在被拆分成了两个 50 毫秒的任务。在实际应用中，我们可以进行一些封装，封装后的使用效果类似下面这样：123btn.onclick = ts([someThing, otherThing], function() &#123; console.log(&apos;done~&apos;)&#125;) 当然，关于ts这个函数的 API 的设计并不是本文的重点，这里想说明的是，在早期可以利用定时器来实现“时间切片”。ES6 带来了迭代器的概念，并提供了生成器 Generator 函数用来生成迭代器对象，虽然 Generator 函数最正统的用法是生成迭代器对象，但这不妨我们利用它的特性做一些其他的事情。Generator 函数提供了yield关键字，这个关键字可以让函数暂停执行。然后通过迭代器对象的next方法让函数继续执行。 对 Generator 函数不熟悉的同学，需要先学习 Generator 函数的用法。利用这个特性，我们可以设计出更方便使用的时间切片，例如：12345btn.onclick = ts(function*() &#123; someThing() // 执行了50毫秒 yield otherThing() // 执行了50毫秒&#125;) 可以看到，我们只需要使用yield这个关键字就可以将本应执行 100 毫秒的任务拆分成了两个 50 毫秒的任务。我们甚至可以将 yield 关键字放在循环里：123456btn.onclick = ts(function*() &#123; while (true) &#123; someThing() // 执行了50毫秒 yield &#125;&#125;) 上面代码我们写了一个死循环，但依然不会阻塞主线程，浏览器也不会卡死。 基于生成器的 ts 实现原理通过前面的例子，我们会发现基于 Generator 的时间切片非常好用，但其实 ts 函数的实现原理非常简单，一个最简单的 ts 函数只需要九行代码。123456789function ts(gen) &#123; if (typeof gen === &apos;function&apos;) gen = gen() if (!gen || typeof gen.next !== &apos;function&apos;) return return function next() &#123; const res = gen.next() if (res.done) return setTimeout(next) &#125;&#125; 代码虽然全部只有 9 行，关键代码只有 3、4 行，但这几行代码充分利用了事件循环机制以及 Generator 函数的特性。 创造出这样的代码我还是很开心的。 上面代码核心思想是：通过yield关键字可以将任务暂停执行，从而让出主线程的控制权；通过定时器可以将“未完成的任务”重新放在任务队列中继续执行。 避免把任务分解的过于零碎使用yield来切割任务非常方便，但如果切割的粒度特别细，反而效率不高。假设我们的任务执行100ms，最好的方式是切割成两个执行50ms的任务，而不是切割成 100 个执行1ms的任务。假设被切割的任务之间的间隔为4ms，那么切割成 100 个执行1ms的任务的总执行时间为：1(1 + 4) * 100 = 500ms 如果切割成两个执行时间为50ms的任务，那么总执行时间为：1(50 + 4) * 2 = 108ms 可以看到，在不影响用户体验的情况下，下面的总执行时间要比前面的少了 4.6 倍。保证切割的任务刚好接近50ms，可以在用户使用yield时自行评估，也可以在ts函数中根据任务的执行时间判断是否应该一次性执行多个任务。我们将ts函数稍微改进一下：1234567891011121314function ts(gen) &#123; if (typeof gen === &apos;function&apos;) gen = gen() if (!gen || typeof gen.next !== &apos;function&apos;) return return function next() &#123; const start = performance.now() let res = null do &#123; res = gen.next() &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 25) if (res.done) return setTimeout(next) &#125;&#125; 现在我们测试下：12345678ts(function*() &#123; const start = performance.now() while (performance.now() - start &lt; 1000) &#123; console.log(11) yield &#125; console.log(&apos;done!&apos;)&#125;)() 这段代码在之前的版本中，在我的电脑上可以打印出 215 次 11，在后面的版本中可以打印出 6300 次 11，说明在总时间相同的情况下，可以执行更多的任务。再看另一个例子：1234567ts(function*() &#123; for (let i = 0; i &lt; 10000; i++) &#123; console.log(11) yield &#125; console.log(&apos;done!&apos;)&#125;)() 在我的电脑上，这段代码在之前的版本中，被切割成一万个小任务，总执行时间为 46秒，在之后的版本中，被切割成 52 个小任务，总执行时间为 1.5秒。 总结以上代码出自于网络，这里感谢作者的付出，同时贴出作者的原创地址:《让你的网页更丝滑》","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"手写mockjs","slug":"手写mockjs","date":"2020-03-10T03:32:31.000Z","updated":"2024-02-20T07:11:25.726Z","comments":true,"path":"2020/03/10/手写mockjs/","link":"","permalink":"/2020/03/10/手写mockjs/","excerpt":"简单的写一个mockjs","text":"简单的写一个mockjs 手写mockjs在我们前端的开发中，mock数据是必须走的一环，我们可以完全脱离后端接口，等我们前端开发好了之后，再跟后台接口的无缝对接。其实mock数据的方式有很多，比如写一些静态text文档，用nodejs写一个后台服务，都可以满足mock数据的需求。但是，最方便的莫过于使用mock工具库了，他可以自动的拦截ajax请求，返回配置好的mock数据。我第一次这个库大概是2016年，感觉很方便，后来也想过它的实现原理是什么，不过当时没有想出来。最近在使用vue的ant pro时候，里面就使用了mockjs，于是准备自己写一个mockjs。我并没有看mockjs的源码，不知道它是怎么实现的，我的想法是既然它可以拦截ajax的请求，那么肯定对原生的XMLHttpRequest做了什么处理，于是乎，我准备覆盖掉原生的XMLHttpRequest对象，这样使用ajax的时候new出来的对象是我自己写的构造函数，不就可以满足拦截ajax请求的目的了吗。我只是实现了拦截ajax的初级功能，并没有深入，点到为止。mockjs代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849;// 将原生的XMLHttpRequest缓存起来window.XMLHttpRequestMock = window.XMLHttpRequest;// mock对象，用来存储ajax的path和返回的数据window.mock = &#123; urlData: &#123;&#125;, setPath: function(path, data) &#123; this.urlData[path] = data; &#125; &#125;// 覆盖原生XMLHttpRequest的构造函数function XmlMock() &#123; this.type = null; this.url = null; this.onreadystatechange = null;&#125;// open方法XmlMock.prototype.open = function(type, url) &#123; this.type = type; this.url = url; this.readyState = 4; this.status = 200&#125;// send方法，这里会判断，如果请求的path在mock.urlData中则返回设置好据的数，// 如果不在，则利用原生的XMLHttpRequest来进行ajax网络请求XmlMock.prototype.send = function(params) &#123; var path = &apos;&apos;; var _this = this; for(var key in mock.urlData) &#123; if((this.url).indexOf(key)&gt;-1) &#123; path = key; &#125; &#125; if(path) &#123; this.responseText = mock.urlData[path]; this.onreadystatechange(this); &#125;else &#123; var xhr = new XMLHttpRequestMock(); xhr.open(&apos;get&apos;, this.url, false); xhr.onreadystatechange = function() &#123; if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123; _this.responseText = xhr.responseText; _this.onreadystatechange(_this); &#125; &#125; xhr.send(); &#125;&#125;window.XMLHttpRequest = XmlMock; html使用代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script src=&quot;./mock.js&quot;&gt;&lt;/script&gt;&lt;script&gt; mock.setPath(&apos;get/小明&apos;, &#123;name: &apos;小明&apos;&#125;); mock.setPath(&apos;get/小红&apos;, &#123;name: &apos;小红&apos;&#125;); fetchData(&apos;http://jinux.top/get/小明&apos;, function(res) &#123; console.log(&apos;小明mock数据-&gt;&apos;, res); &#125;); fetchData(&apos;http://jinux.top/get/小红&apos;, function(res) &#123; console.log(&apos;小红mock数据-&gt;&apos;, res); &#125;); // 测试真实的ajax数据，用的实际百度的一个链接 var testUrl = &apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/home/js/nu_instant_search_baaa58d.js&apos;; fetchData(testUrl, function(res) &#123; console.log(&apos;百度的真是数据-&gt;&apos;, res); &#125;); // 封装的ajax请求方法 function fetchData(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, url, false); xhr.onreadystatechange = function() &#123; if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123; callback(xhr.responseText); &#125; &#125; xhr.send(); &#125;&lt;/script&gt;&lt;/html&gt; 最后，附上代码，点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"wireshark抓包工具","slug":"wireshark抓包工具","date":"2020-03-09T07:18:21.000Z","updated":"2024-01-11T07:00:59.239Z","comments":true,"path":"2020/03/09/wireshark抓包工具/","link":"","permalink":"/2020/03/09/wireshark抓包工具/","excerpt":"wireshark是一款非常厉害的网络抓包工具","text":"wireshark是一款非常厉害的网络抓包工具 wireshark抓包工具作为一个前端开发，讨论网络抓包有点不务正业，但是知道点还是有好处的。我平时用到的抓包工具有wireshark和charles，charles使用起来简单些，抓取http请求比较直观，wireshark的功能就强大得多，各种网络协议都可以解析，具体的使用细节就不说了，简单的说一下tcp协议的三次握手和四次挥手在wireshark中被抓取的数据。首先看一下tcp的三次握手和四次挥手图解过程1.三次握手：2.四次挥手：3.最后，wireshark抓取的数据：可以看到，前3个tcp是握手过程，最后4个tcp是挥手过程，中间的TLS协议是加密协议，因为我抓取的是https协议，所以会有加密协议。本想再贴一个http协议的抓取截屏，抓了几次太乱了，还有好多失败的包，不贴了，大同小异，大概了解过程就行了，有精力的话，继续深入研究。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"javascript严格模式","slug":"javascript严格模式","date":"2020-02-28T07:05:50.000Z","updated":"2024-01-11T07:00:59.193Z","comments":true,"path":"2020/02/28/javascript严格模式/","link":"","permalink":"/2020/02/28/javascript严格模式/","excerpt":"js的严格模式和普通模式的区别","text":"js的严格模式和普通模式的区别 javascript严格模式随着javascript的不断发展，严格模式在开发中是必须使用的，他有什么好处呢？严格模式消除了一些不确定的行为，并且对某些不安全的操作抛出异常。它有助于解析引擎，优化代码，提高执行速度，也为以后新标准的制定留出余地。下面将对严格模式做一个详细的介绍。 1.启用严格模式要使一个javascript文件运行于严格模式，只需要在文件顶部添加如下代码：1&quot;use strict&quot;; 或者1&apos;use strict&apos;; 这行代码是一个编译指示，用以告知解析引擎以严格模式解析脚本。严格模式可以用于整个脚本或单个函数。在用于脚本文件时，”use strict”需放在所有其它语句前面。123// whole-script strict mode syntax&quot;use strict&quot;;var v = &quot;Hi! I&apos;m a strict mode script!&quot;; 而用于函数时，需方在函数内第一行。1234567891011function strict() &#123; // Function-level strict mode syntax &apos;use strict&apos;; function nested() &#123; return &quot;And so am I!&quot;; &#125; return &quot;Hi! I&apos;m a strict mode function@ &quot; + nested();&#125;function notStrict() &#123; return &quot;I&apos;m not strict.&quot;;&#125; 2.严格模式带来的变化在语法和行为这两方面，严格模式都做了一些改变。这些变化主要分为以下几类。 对错误抛出异常，而不是静默地忽略； 简化变量的使用，去掉引擎难以优化的语法功能； 简化eval和arguments的使用； 增加安全特性； 为javascript迎接新标准做准备； 1)对错误抛出异常，而不是静默的忽略。严格模式将过去那些能够被静默忽略的错误变成异常抛出，因为这类错误代表着代码目的的矛盾。不一致的代码也许在当时不会产生什么不良后果，但未来可能会引起严重问题。严格模式不会容忍这些错误，使得开发者能够立即发现并且解决。 (1)在正常模式下，对一个没有声明的变量赋值，会自动作用到全局对象上（node的global对象，浏览器的window对象）。严格模式禁止这种做法，以避免意外地修改全局对象。12&quot;use strict&quot;mistypedVaraible = 17; // ReferenceError 上面的代码将会抛出类型为ReferenceError的异常 (2)在正常模式下，引擎会默认忽略对NaN赋值的语句，但在严格模式下，引擎会以抛异常的方式，立即向开发者反馈错误。类似的还有给一个指定为不可写的属性赋值，对只有取值函数getter的属性赋值，给一个不可扩展的对象增加属性。123456789101112131415161718192021&quot;use strict&quot;// Assignment to NaNNaN = &apos;a&apos;; // TypeError: Cannot assign to read noly property &apos;NaN&apos; of #&lt;Object&gt;// Assignment to a non-writable propertyvar obj1 = &#123;&#125;;Object.defineProperty(obj1, &quot;x&quot;, &#123; value: 42, writable: false&#125;);obj1.x = 9; // throws a TypeError// Assignment to a getter-only propertyvar obj2 = &#123; get x() &#123; return 18; &#125;&#125;;obj2.x = 5; // throws a TypeError// Assignment to a new property on a non-extensible objectvar fixed = &#123;&#125;;Object.preventExtensions(fixed);fixed.newProp = &quot;ohai&quot;; // throws a TypeError (3)严格模式禁止删除一个声明为不可删除的属性。12&quot;use strict&quot;;delete Object.prototype; // throws a TypeError (4)严格模式禁止声明重名属性。12345&quot;use strict&quot;;var o = &#123; p: 1, p: 2&#125;; // !!! syntax error (5)严格模式规定，函数的参数名必须唯一，否则抛出语法错误。在正常模式下，相同名称的参数，位置最靠后的会把前面的隐藏，但所有参数仍然可以借由arguments[i]访问，因此这种隐藏的意义不大，很可能写错了。1234function sum(a, a, c) &#123; // syntax error &quot;use strict&quot;; return a + b + c; // wrong if this code ran&#125; (6)八进制数的写法。ECMAScript 5 标准下的严格模式禁止八进制数，但在ECMAScript 6标准下，八进制数前面需要加0o。Node支持前面加0o的八进制数，例如：123456789&quot;use strict&quot;;// Rightvar a = 0o10; // ES6: Octalconsole.log(a);// 以下代码异常// SyntaxErrorvar sum = 015 + // syntax error 197 + 142; (7)严格模式禁止为基本数据类型添加属性，以下操作非法。123456(function() &#123; &quot;use strict&quot;; false.true = &quot;&quot;; // TypeError (14).sailing = &quot;home&quot;; // TypeError &quot;with&quot;.you = &quot;far away&quot;; // TypeError&#125;)(); 2)简化变量的使用，去掉引擎难以优化的语法功能。 (1)严格模式禁止使用with。with的问题在于，其语句内部的变量名只有在运行的时候才能够被决定，这使得引擎在编译阶段难以生成高效的代码。因为with代码块中的名称即有可能代表语句内部的变量，也有可能是with表达式中的对象属性，还有可能位于代码块外，甚至是全局对象的属性。12345&quot;use strict&quot;;var x = 18;with(obj) &#123; // syntax error x;&#125; (2)严格模式下，eval有单独的作用域，不能够使用eval语句在它之外创建变量。正常模式下，语句x;\")```会为它所在的运行环境声明一个变量x，在严格模式下，x只在eval语句的内部有效。12345```var x = 18;var evalX = eval(&quot;&apos;use strict&apos;; var x = 42; x&quot;);console.assert(x === 18);console.assert(evalX === 42); (3)严格模式禁止删除变量。1234&quot;use strict&quot;;var x;delete x; // syntax erroreval(&quot;var y; delete y;&quot;); // syntax error 3)简化eval和arguments的使用。严格模式将eval和arguments的一些怪异和奇特的用法做了限制，并倾向于将eval和arguments当作关键字处理。 (1)严格模式不允许对eval和arguments赋值。以下语句运行都会报错。1234567891011&quot;use strict&quot;;eval = 18;arguments++;++eval;var obj = &#123; set p(arguments) &#123; &#125; &#125;;var eval;try &#123; &#125; catch(arguments) &#123; &#125;function x(eval) &#123; &#125;function arguments() &#123; &#125;var y = function eval() &#123; &#125;;var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 18;&quot;); (2)在严格模式下，修改函数参数不会影响arguments，下面的示例代码能够正常运行。12345678function f(a) &#123; &quot;use strict&quot;; a = 42; return [a, arguments[0]];&#125;var pair = f(18);console.assert(pair[0] === 42);console.assert(pair[1] === 18); (3)arguments.callee不能再使用了。正常模式下，arguments.callee返回正在执行的函数本身的引用。在严格模式下，这种用法被禁止。12345&quot;use strict&quot;var f = function() &#123; return arguments.callee;&#125;f(); // throws a TypeError; 4)增加安全特性。在严格模式下，写出安全的代码变得更容易，引擎不会越俎代庖，除非使用者有意地这样做。 (1)在严格模式下，函数的上下文对象this可以是简单的值，并且避免了对全局对象的引用。在正常模式下，this只是一个对象，例如下面的代码：1234function() &#123; console.log(this);&#125;f.call(true); 运行结果为[Boolean: true]，引擎会自动地将简单类型打包为对应的对象。单严格模式不会做这样的转换。12345&quot;use strict&quot;;function f(a) &#123; console.log(this);&#125;f.call(true); 运行结果为true。正常模式下，如果不指定this对象，或者指定为undefined或null，则this引用的是全局对象。1234function f(a) &#123; console.log(this);&#125;f.call(null); 上面的代码打印出全局的global对象。但在严格模式下，除非使用call或apply明确指定this为global对象，否则this为null或者undefined。123456&quot;use strict&quot;;function f(a) &#123; console.log(this);&#125;f.call(null);f(); 结果为：12nullundefined (2)严格模式禁止访问函数对象属性caller和arguments，这意味着不再可能遍历调用堆栈了。123456789101112&quot;use strict&quot;;function outer() &#123; inner();&#125;function inner() &#123; console.log(arguments.callee.caller); // TypeError: &apos;caller&apos;, &apos;callee&apos;, and // &apos;arguments&apos; properties may not be accessed // on strict mode functions or the arguments // objects for calls to them&#125;outer(); 5)保留关键字。严格模式将implements,interface,let,package,private,protected,public,static和yield作为保留字，用户代码不能以这些名称命名变量。123456789101112function package(protected) &#123; // SyntaxError &quot;use strict&quot;; var implements; // SyntaxError interface; // SyntaxError while(true) &#123; break interface; // SyntaxError &#125; function private() &#123; &#125; // SyntaxError&#125;function fun(static) &#123; // SyntaxError &quot;use strict&quot;;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"前端异常处理","slug":"前端异常处理","date":"2020-02-27T06:23:25.000Z","updated":"2024-01-11T07:00:59.260Z","comments":true,"path":"2020/02/27/前端异常处理/","link":"","permalink":"/2020/02/27/前端异常处理/","excerpt":"异常在前端的处理","text":"异常在前端的处理 前端异常处理简介异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。 增强用户体验； 远程定位问题； 未雨绸缪，及早发现问题； 无法复线问题，尤其是移动端，机型，系统都是问题； 完善的前端方案，前端监控系统； 对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。 对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下： JS 语法错误、代码异常 AJAX 请求异常 静态资源加载异常 Promise 异常 Iframe 异常 跨域 Script error 崩溃和卡顿 下面我会针对每种具体情况来说明如何处理这些异常。 异常分类try-catchtry-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。1.同步运行时错误123456try &#123; let name = &apos;jartto&apos;; console.log(nam);&#125; catch(e) &#123; console.log(&apos;捕获到异常：&apos;,e);&#125; 控制台输出12捕获到异常： ReferenceError: nam is not defined at index.html:16 2.不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：123456try &#123; let name = &apos;jartto; console.log(nam);&#125; catch(e) &#123; console.log(&apos;捕获到异常：&apos;,e);&#125; 控制台输出12Uncaught SyntaxError: Invalid or unexpected token不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。 3.异步错误1234567try &#123; setTimeout(() =&gt; &#123; console.log(nam); &#125;, 1000)&#125; catch(e) &#123; console.log(&apos;捕获到异常：&apos;,e);&#125; 控制台输出12Uncaught ReferenceError: nam is not defined at index.html:31 可以看出，try-catch是捕获不到异步错误的，下面会介绍异步的错误如何捕获。 window.onerror当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。1.同步错误和异步错误都可以捕获到123456789// message：错误信息（字符串）。// source：发生错误的脚本URL（字符串）// lineno：发生错误的行号（数字）// colno：发生错误的列号（数字）// error：Error对象（对象）window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;); return true; // 这里返回true，控制台就不会输出被捕获的那个错误自己抛出的异常提示，见下面截图。&#125; 2.再试试语法错误1234window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);&#125;let name = &apos;Jartto 控制台输出1Uncaught SyntaxError: Invalid or unexpected token 语法错误还是不能捕获3.我们试试网络请求异常的情况1234567&lt;script&gt;window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;); return true;&#125;&lt;/script&gt;&lt;img src=&quot;./jartto.png&quot;&gt; 不论是静态资源异常，或者接口异常，错误都无法捕获到。补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx，上面已经有提到过。需要注意： onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误； onerror 无法捕获语法错误；到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。window.addEventListener当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window，所以我们需要在每一个元素节点上监听error事件123456var nImgs = document.querySelectorAll(&apos;img&apos;); nImgs.forEach(item=&gt; &#123; item.addEventListener(&apos;error&apos;, function(ev) &#123; console.log(&apos;捕获到异常：&apos;, ev); &#125;, false); &#125;); 上面是来捕获页面中所有的img元素标签出现的错误。控制台输出1捕获到异常： Event &#123;isTrusted: true, type: &quot;error&quot;, target: img#img, currentTarget: img#img, eventPhase: 2, …&#125; 由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。需要注意： 不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。 需要注意避免 addEventListener 重复监听。 Promise Catch在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：1234567891011window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123; e.preventDefault() console.log(&apos;捕获到异常：&apos;, e); return true;&#125;);var pro = new Promise(function(resolve, reject) &#123; reject(&apos;错误&apos;);&#125;);// pro.catch(err=&gt; &#123;// console.log(&apos;promise catch 捕获：&apos; + err);// &#125;); 可以看到，如果忘记了catch的话，全局也可以捕获到Promise的错误。控制台输出1捕获到异常： PromiseRejectionEvent &#123;isTrusted: true, promise: Promise, reason: &quot;错误&quot;, type: &quot;unhandledrejection&quot;, target: Window, …&#125; 所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。补充一点：如果去掉控制台的异常显示，需要加上：1event.preventDefault(); iframe 异常对于 iframe 的异常捕获，我们还得借力 window.onerror1234567&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;script&gt; window.frames[0].onerror = function (message, source, lineno, colno, error) &#123; console.log(&apos;捕获到 iframe 异常：&apos;,&#123;message, source, lineno, colno, error&#125;); return true; &#125;;&lt;/script&gt; Script error一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。1&lt;script src=&quot;http://jartto.wang/main.js&quot; crossorigin&gt;&lt;/script&gt; 或者动态去添加 js 脚本：1234const script = document.createElement(&apos;script&apos;);script.crossOrigin = &apos;anonymous&apos;;script.src = url;document.body.appendChild(script); 特别注意，服务器端需要设置：Access-Control-Allow-Origin此外，我们也可以试试这个-解决 Script Error 的另类思路：123456789101112const originAddEventListener = EventTarget.prototype.addEventListener;EventTarget.prototype.addEventListener = function (type, listener, options) &#123; const wrappedListener = function (...args) &#123; try &#123; return listener.apply(this, args); &#125; catch (err) &#123; throw err; &#125; &#125; return originAddEventListener.call(this, type, wrappedListener, options);&#125; 简单解释一下：改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：123456789101112131415161718(() =&gt; &#123; const originAddEventListener = EventTarget.prototype.addEventListener; EventTarget.prototype.addEventListener = function (type, listener, options) &#123;+ // 捕获添加事件时的堆栈+ const addStack = new Error(`Event ($&#123;type&#125;)`).stack; const wrappedListener = function (...args) &#123; try &#123; return listener.apply(this, args); &#125; catch (err) &#123;+ // 异常发生时，扩展堆栈+ err.stack += &apos;\\n&apos; + addStack; throw err; &#125; &#125; return originAddEventListener.call(this, type, wrappedListener, options); &#125; &#125;)(); 崩溃和卡顿卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。123456789101112131415161718window.addEventListener(&apos;load&apos;, function () &#123; sessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;); setInterval(function () &#123; sessionStorage.setItem(&apos;time_before_crash&apos;, new Date().toString()); &#125;, 1000);&#125;);window.addEventListener(&apos;beforeunload&apos;, function () &#123; sessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;);&#125;);if(sessionStorage.getItem(&apos;good_exit&apos;) &amp;&amp; sessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) &#123; /* insert crash logging code here */ alert(&apos;Hey, welcome back from your crash, looks like you crashed on: &apos; + sessionStorage.getItem(&apos;time_before_crash&apos;));&#125; 2.基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。 VUE errorHandler123456Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error(&apos;通过vue errorHandler捕获的错误&apos;); console.error(err); console.error(vm); console.error(info);&#125; React 异常捕获React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息123componentDidCatch(error, info) &#123; console.log(error, info);&#125; 除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。需要注意的是：error boundaries 并不会捕捉下面这些错误。 事件处理器 异步代码 服务端的渲染代码 在 error boundaries 区域内的错误我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 然后我们像使用普通组件那样使用它123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！ 错误上报通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。动态创建 img 标签的形式1234function report(error) &#123; let reportUrl = &apos;http://jartto.wang/report&apos;; new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;&#125; 收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力123456Reporter.send = function(data) &#123; // 只采集 30% if(Math.random() &lt; 0.3) &#123; send(data) // 上报错误信息 &#125;&#125; 采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。 总结回到我们开头提出的那个问题，如何优雅的处理异常呢？ 可疑区域增加 Try-Catch 全局监控 JS 异常 window.onerror 全局监控静态资源异常 window.addEventListener 捕获没有 Catch 的 Promise 异常：unhandledrejection VUE errorHandler 和 React componentDidCatch 监控网页崩溃：window 对象的 load 和 beforeunload 跨域 crossOrigin 解决 其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。 这篇文章部分代码点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"html元素节点的attribute&property","slug":"html元素节点的attribute-property","date":"2020-02-24T03:06:49.000Z","updated":"2024-01-11T07:00:59.191Z","comments":true,"path":"2020/02/24/html元素节点的attribute-property/","link":"","permalink":"/2020/02/24/html元素节点的attribute-property/","excerpt":"元素节点attr和prop区别","text":"元素节点attr和prop区别 html元素节点的attribute&amp;property元素节点的attrbute和property大家可能都是用过，但是也是容易被大家忽略它俩到底区别在哪里。想当初在使用jquery时,$(‘ele’).attr(),$(‘’ele).prop(),这两个方法我也是没有深入研究，再后来使用angular的时候有看到attribute和property的区别，今天我好好总结一下。 attribute和property如何使用123456789// 这样一个input节点&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;// 首先，使用attribute来操作var nEle = document.getElementById(&apos;inp&apos;);nEle.setAttribute(&apos;class&apos;, &apos;wrap&apos;);nEle.getAttribute(&apos;class&apos;);// 使用property来操作nEle.index = 1;nEle.type = &apos;text&apos;; 其实，attribute是在这个元素节点上设置属性，而property是在这个元素节点的dom对象上设置属性。12345// 想看看元素节点的attribute属性nEle.attributes// 想看看元素节点的property属性console.dir(nEle);// 打印出来的内容可以看到attributes也在其中 attribute和property实际区别1234567&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;// 还是这个元素节点// 页面加载时如果使用getAttribute(&apos;value&apos;)是可以获取&apos;val&apos;值的，当然，nEle.value也可以获取到 &apos;val&apos;。// 但是，如果现在你在input框中，把&apos;val&apos;改成&apos;val123&apos;// 你再使用getAttribute(&apos;value&apos;)方式获取到的还是&apos;val&apos;,而使用nEle.value可以获取到最新值&apos;val123&apos;// 从这样一个简单的操作，可以理解为，attribute时html元素上的，而property是html元素对象上的。 其实，两者区别还有很多，这里不一一列举，一个小例子知道其区别就可以了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"http请求头的安全策略","slug":"http请求头的安全策略","date":"2020-02-18T07:51:36.000Z","updated":"2024-01-11T07:00:59.192Z","comments":true,"path":"2020/02/18/http请求头的安全策略/","link":"","permalink":"/2020/02/18/http请求头的安全策略/","excerpt":"http请求头中相关安全的头字段","text":"http请求头中相关安全的头字段 http请求头的安全策略我们的项目在经过开发，测试之后，还得经过安全小组的安全漏斗扫描，经常会暴漏一些返回头缺少安全字段的漏洞，今天我稍加整理常用的几个。如果想了解更多的请求头和响应头的字段信息，可以看本站另一篇文章，这里 1.X-Frame-Options如果网站可以嵌入到IFRAME元素中，则攻击者可以在社交场合设计一种情况，即受害者被指向攻击者控制的网站，该网站构成目标网站的框架。然后攻击者可以操纵受害者在目标网站上不知不觉地执行操作。即使有跨站点请求伪造保护，这种攻击也是可能的，并且被称为“clickjacking”，有关更多信息，请参阅。为了避免这种情况，创建了“X-Frame-Options”标题。此标题允许网站所有者决定允许哪些网站构建其网站。通常的建议是将此标头设置为“SAMEORIGIN”，它只允许属于同源策略的资源构成受保护资源的框架，或者设置为“DENY”，它拒绝任何资源（本地或远程）尝试框架也提供“X-Frame-Options”标头的资源。如下所示：X-Frame-Options：SAMEORIGIN请注意，“X-Frame-Options”标题已被弃用，将由内容安全策略中的Frame-Options指令替换，该指令仍处于活动开发阶段。但是，“X-Frame-Options”标题目前具有更广泛的支持，因此仍应实施安全措施。说白了呢，就是让你的网站禁止被嵌套。demo:12345&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt; &lt;/customHeaders&gt;&lt;/httpProtocol&gt; 2.Content-Security-Policy内容安全策略（CSP）旨在允许Web应用程序的所有者通知客户端浏览器有关应用程序的预期行为（包括内容源，脚本源，插件类型和其他远程资源），这允许浏览器更多智能地执行安全约束。虽然CSP本质上是复杂的，如果没有适当部署它可能会变得混乱，一个应用良好的CSP可以大大降低利用大多数形式的跨站点脚本攻击的机会。需要整个帖子来深入了解CSP允许的功能和不同设置，因此建议进一步阅读。以下是Mozilla开发者网络对CSP的精彩介绍性帖子下面的简要示例显示了如何使用CSP指定您的网站希望从任何URI加载图像，从受信任的媒体提供商（包括内容分发网络）列表中插入插件内容，以及仅从您控制的服务器加载脚本：1Content-Security-Policy：default-src&apos;self&apos;; img-src *; object-src media1.example.com media2.example.com * .cdn.example.com; script-src trustedscripts.example.com 请注意，使用CSP的主要问题涉及策略错误配置（即使用“不安全内联”），或使用过于宽松的策略，因此在实施CSP时应特别注意。这个呢，是将你引入的一切，加一个限制，这样如果别人想通过一些手段在你的网站加一些不好的东西，我们就可以有效地防止了。demo:12345&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=&quot;Content-Security-Policy&quot; value=&quot;script-src &apos;unsafe-inline&apos; http://localhost:56504; object-src &apos;none&apos;; style-src &apos;unsafe-inline&apos; http://localhost:56504;&quot; /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt; 其中预设值有以下这些： none 不匹配任何东西。 self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。 unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。 unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。 3.X-Content-Type-Options互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：”text/html”代表html文档，”image/png”是PNG图片，”text/css”是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。例如，我们即使给一个html文档指定Content-Type为”text/plain”，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：1X-Content-Type-Options: nosniff demo:12// phpheader(&quot;X-Content-Type-Options:nosniff&quot;); 4.X-XSS-Protection顾名思义，这个响应头是用来防范XSS的。最早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置： 0：禁用XSS保护； 1：启用XSS保护； 1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。demo:12// phpheader(&quot;X-XSS-Protection: 1&quot;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"图片裁剪插件","slug":"图片裁剪插件","date":"2020-02-16T07:51:13.000Z","updated":"2024-01-11T07:00:59.264Z","comments":true,"path":"2020/02/16/图片裁剪插件/","link":"","permalink":"/2020/02/16/图片裁剪插件/","excerpt":"一个图片裁剪插件，并穿给后端","text":"一个图片裁剪插件，并穿给后端 图片裁剪插件我们在日常开发中，裁剪图片并上传，是经常出现的需求。前几天，就有一个这样的需求，但是要求比较特殊，于是自己写了一个图片裁剪插件，因为自己写的改起来比较灵活。 其实裁剪图片无非就是: 文件选择图片，利用FileReader将文件格式的图片转成base64格式。 把这个base64格式显示在页面上，作为原图。 可以在原图的上面弄一个剪裁的方框，可以用鼠标来控制大小并移动，我觉得这里是最难的，需要很强的逻辑能力。 再利用canvas，以原图为基准，进行画图的裁剪，最后通过canvas方法得到裁剪后的base64格式图片。 最后把base64格式的图片转成Blob对象，利用ajax传送给后端。 关键方法选择图片文件转base6412345678function file2base64(imgFile, callBack) &#123; var fr = new FileReader(); fr.onload = function() &#123; // fr.result就是base64格式数据 callBack(fr.result); &#125; fr.readAsDataURL(imgFile);&#125; 将base64图片转化blob123456789101112function base64url2blob(base64url) &#123; var binaryString = atob(base64url.split(&apos;,&apos;)[1]), mimeType = base64url.split(&apos;,&apos;)[0].match(/:(.*?);/)[1], length = binaryString.length, u8arr = new Uint8Array(length), blob; while(length--) &#123; u8arr[length] = binaryString.charCodeAt(length); &#125; blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;); return blob;&#125; 将图片转化为blob1234567891011121314function img2blob(nImg, compressVal) &#123; // 获取图片原始宽高 var cloneImg = nImg.cloneNode(true); var nCanvas = document.createElement(&apos;canvas&apos;); nCanvas.style.display = &apos;none&apos;; document.body.appendChild(nCanvas); nCanvas.width = cloneImg.width; nCanvas.height = cloneImg.height; var ctx = nCanvas.getContext(&quot;2d&quot;); ctx.drawImage(nImg,0,0,cloneImg.width,cloneImg.height); var base64Data = nCanvas.toDataURL(&quot;image/jpeg&quot;, compressVal); var blob = this.base64url2blob(base64Data); return blob;&#125; 以上就是几个重要的格式转换方法。最后，贴出源码demo，里边包含后端接收的nodejs代码。点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"手写一个自己的webpack","slug":"手写一个自己的webpack","date":"2020-01-31T07:51:30.000Z","updated":"2024-01-11T07:00:59.271Z","comments":true,"path":"2020/01/31/手写一个自己的webpack/","link":"","permalink":"/2020/01/31/手写一个自己的webpack/","excerpt":"一个超级简化版的webpack打包工具","text":"一个超级简化版的webpack打包工具 手写一个自己的webpackwebpack现在用的人非常多，我们在开发vue，react，angular的时候默认的打包工具就是webpack，作为一名前端开发者来说，webpack是现在必须掌握的技能之一。随着webpack版本的不断增加，功能和复杂度越来越高，会配置的话都得学一阵子，但是，抛开使用来说，想没想过它的原理是什么？如果自己写一个该从哪里入手呢，今天我就写一个简化版的webpack。 功能简化版的webpack，实现了它的最基础的功能，也就是模块化的引用处理，比如，main.js文件依赖了a.js文件，使用es6的语法import语法，浏览器是不支持的，需要用工具打包成浏览器支持的语法，我就实现这个最基础的功能。 babel打包文件，首先需要分析代码，比如，入口文件main.js，分析出import语句，都依赖哪些文件，再去读取这些依赖的文件，而分析js代码就需要babel这个工具库，babel工具库可以将es6代码转换成es5，es3代码，功能特别强大。 打包流程这里，依赖babel的3个工具，分别是123&quot;@babel/core&quot;: &quot;^7.8.3&quot;,&quot;@babel/parser&quot;: &quot;^7.8.3&quot;,&quot;@babel/traverse&quot;: &quot;^7.8.3&quot; parser是用来将js代码解析成ast语法书。traverse可以将ast语法书进行遍历，对相应的ast语法书节点做单独的获取或者处理。babel-core是babel的核心，可以将es6的js代码或ast语法书转化成es5代码。 步骤1用paser将es6的代码先转成ast语法树 步骤2用traverse处理ast语法书中的import节点，获取依赖文件路径，并获取依赖文件的代码，重复做步骤1，步骤2的处理。 步骤3用babel-core将获取到的文件全部转成es5语法。 步骤4最后把这些文件拼接成一个可执行的js代码，保存起来，html直接引用就可以执行了。 源码上面步骤都说了，但是还是有点抽象，下面贴出代码，一目了然。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const parser = require(&apos;@babel/parser&apos;);const traverse = require(&apos;@babel/traverse&apos;).default;const babel = require(&apos;@babel/core&apos;);let ID = 0;function createAsset(fileName) &#123; // 这个文件里所依赖的其它文件路径 let dependencies = []; const content = fs.readFileSync(fileName, &apos;utf8&apos;); // 用babel的parser来解析读取的的文件内容content,获取ast抽象语法书 const ast = parser.parse(content, &#123; sourceType: &apos;module&apos; &#125;); // 用babel的traverse功能来观察ast语法树的相应节点，进行相应的处理 traverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; // console.log(node.source.value); dependencies.push(node.source.value); &#125; &#125;); // 用babel来讲es6语法转成es5语法 const &#123; code &#125; = babel.transformFromAstSync(ast, null, &#123; presets: [&apos;@babel/preset-env&apos;] &#125;) let id = ID++; return &#123; id, fileName, dependencies, code, &#125;;&#125;function createGraph() &#123; const mainAsset = createAsset(&apos;./src/main.js&apos;); // 队列存放单个文件资源,这里利用循环队列去搜寻依赖文件，而没有使用递归方法 const queue = [ mainAsset ]; for(const asset of queue) &#123; const dirname = path.dirname(asset.fileName); asset.mapping = &#123;&#125;; asset.dependencies.forEach(relativePath =&gt; &#123; const absolutePath = path.join(dirname, relativePath); const child = createAsset(absolutePath); asset.mapping[relativePath] = child.id; queue.push(child); &#125;); &#125; return queue;&#125;// 打包生成处理后的js文件function bundle() &#123; const graph = createGraph(&apos;./src/main.js&apos;); let modules = ``; graph.forEach(mod=&gt; &#123; modules += ` $&#123;mod.id&#125;: [ function(require, module, exports) &#123; $&#123;mod.code&#125; &#125;, $&#123;JSON.stringify(mod.mapping)&#125; ], `; &#125;); const result = `(function(modules) &#123; function require(id) &#123; const fn = modules[id][0], mapping = modules[id][1]; function localRequire(relativePath) &#123; return require(mapping[relativePath]); &#125; const module = &#123; exports: &#123;&#125; &#125;; fn(localRequire, module, module.exports); return module.exports; &#125; require(0); &#125;)(&#123;$&#123;modules&#125;&#125;)`; return result;&#125;const result = bundle();fs.writeFileSync(&apos;./dist/bundle.js&apos;, result); demo地址截这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"简单的聊聊iframe","slug":"简单的聊聊iframe","date":"2020-01-19T06:11:04.000Z","updated":"2024-01-11T07:00:59.276Z","comments":true,"path":"2020/01/19/简单的聊聊iframe/","link":"","permalink":"/2020/01/19/简单的聊聊iframe/","excerpt":"iframe在html中的简单使用","text":"iframe在html中的简单使用 简单的聊聊iframe我们在前端开发中，iframe的使用场景很多，即便是vue，react时代，我还是乐此不疲的在项目中使用iframe，因为它会隔离页面彼此的环境，避免造成一些不必要的干扰。 在同域下使用iframe在同域下使用iframe,父级页面可以获取iframe页面里的信息，还可以操作iframe页面中的内容。案例在同域下没什么好说的，父页面可以随意控制子页面。 跨域下使用iframe跨域下使用iframe,父页面是不能操作子页面的，但是子页面可以操作父页面。而且，后台返回的头信息，还能够更加严格的控制iframe123res.setHeader(&apos;X-Frame-Options&apos;, &apos;DENY&apos;); // 不允许此页面被iframe加载res.setHeader(&apos;X-Frame-Options&apos;, &apos;SAMEORIGIN&apos;); // 只可以在相同域名下加载res.setHeader(&apos;X-Frame-Options&apos;, &apos;allow-from http://baidu.com/&apos;); // 允许指定的url加载iframe,但是这个属性在chrome,firefox,opera并不好使,只在edge中兼容 案例目前为止，没有找到跨域控制iframe页面内容的方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"常用数据结构的JavaScript实现","slug":"常用数据结构的JavaScript实现","date":"2019-11-28T08:12:54.000Z","updated":"2024-01-11T07:00:59.266Z","comments":true,"path":"2019/11/28/常用数据结构的JavaScript实现/","link":"","permalink":"/2019/11/28/常用数据结构的JavaScript实现/","excerpt":"一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现","text":"一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现 常用数据结构的JavaScript实现觉得这篇文章很不错，收藏下来，感谢作者。这里是连接哦","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"linux的常用操作","slug":"linux的常用操作","date":"2019-11-28T01:46:55.000Z","updated":"2024-01-11T07:00:59.224Z","comments":true,"path":"2019/11/28/linux的常用操作/","link":"","permalink":"/2019/11/28/linux的常用操作/","excerpt":"linux的一些基础常用操作","text":"linux的一些基础常用操作 linux的常用操作安装应用在linux下安装应用的方法有很多，我也尝试了好几种，最后感觉还是用yum安装方便。在使用yum安装应用的时候需要配置一下yum源，这里写出两条命令，常用的应用软件都已经有了。12curl -O http://mirrors.aliyun.com/repo/Centos-7.repocurl -O http://mirrors.aliyun.com/repo/epel-7.repo 命令新建文件夹1mkdir &lt;filename&gt; 文件的移动12// 将repo结尾的文件移动到当前目录的back文件夹下mv *.repo ./back 删除123456789101、删除文件命令rm -f 文件名将会强行删除文件，且无提示需要注意：使用rm -rf要格外注意，linux中没有回收站，慎重删除2、删除文件夹以及文件夹中的所有文件命令：rm -rf 目录名字其中：-r：向下递归删除-f：直接强行删除，且没有任何提示 查看进程1ps -ef | grep node 杀死进程1kill -9 &lt;pid&gt; 搜索一个程序所在位置12345678910whereis &lt;程序名称&gt;查找软件的安装路径-b 只查找二进制文件-m 只查找帮助文件-s 只查找源代码-u 排除指定类型文件-f 只显示文件名-B &lt;目录&gt; 在指定目录下查找二进制文件-M &lt;目录&gt; 在指定目录下查找帮助文件-S &lt;目录&gt; 在指定目录下查找源代码 查找一个文件夹所在目录1find / -name &lt;文件名&gt; 文件的上传和下载使用之前确保安装了lrzsz1yum install lrzsz 上传文件1rz 下载文件1sz &lt;filename&gt; nginx安装nginx1yum install nginx 开启nginx服务12nginx -c /etc/nginx/nginx.conf.default// 以我的nginx安装目录为例，nginx.conf.default这个文件就是nginx的主默认配置文件 重启nginx服务1nginx -s reload 压缩和解压zip安装1234// 安装zipyum install zip// 安装unzipyum install unzip 使用zip1234// 将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：zip -q -r html.zip /home/html// 如果在我们在 /home/html 目录下，可以执行以下命令：zip -q -r html.zip * 使用unzip1234// 它会默认将文件解压到当前目录 # unzip test.zip // 如果要解压到指定目录，可以加上 -d 选项# unzip test.zip -d /root/","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}]},{"title":"chrome浏览器设置可跨域","slug":"chrome浏览器设置可跨域","date":"2019-11-20T07:39:35.000Z","updated":"2024-01-11T07:00:59.178Z","comments":true,"path":"2019/11/20/chrome浏览器设置可跨域/","link":"","permalink":"/2019/11/20/chrome浏览器设置可跨域/","excerpt":"chrome浏览器设置可跨域","text":"chrome浏览器设置可跨域 chrome浏览器设置可跨域跨域方法很多种，我比较喜欢简单粗暴的修改chrome配置1.先chrome鼠标右键打开下，点击打开属性，出现下面这幅图2.将下面的这段粘贴在目标的字符串的后面，注意要隔着一个空格chrome版本49之前：–disable-web-securitychrome版本49之后：open -a Google\\ Chrome –args –disable-web-security –user-data-dir","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"css初始化","slug":"css初始化","date":"2019-10-30T08:16:54.000Z","updated":"2024-01-11T07:00:59.179Z","comments":true,"path":"2019/10/30/css初始化/","link":"","permalink":"/2019/10/30/css初始化/","excerpt":"css的初始化设计","text":"css的初始化设计 css初始化123456789101112131415161718192021222324252627282930313233343536373839404142@charset \"utf-8\";html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,\"Hiragino Sans GB\",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,\"Hiragino Sans GB\",\"微软雅黑\",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:\"\\0020\"&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, \"Microsoft Yahei\", \"Helvetica Neue\", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125;a,input&#123; -webkit-appearance: none;/*屏蔽阴影*/ -webkit-tap-highlight-color:rgba(0,0,0,0); /*ios android去除自带阴影的样式*/&#125;a, img &#123; /* 禁止长按链接与图片弹出菜单 */ -webkit-touch-callout: none;&#125;html, body &#123; /* 禁止选中文本(如无文本选中需求,此为必选项) */ -webkit-user-select: none; user-select: none;&#125;* &#123; -webkit-overflow-scrolling: touch; // ios滑动不卡顿&#125;","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"VUE自定义组件v-model使用","slug":"VUE自定义组件v-model使用","date":"2019-10-22T05:55:13.000Z","updated":"2024-01-11T07:00:59.175Z","comments":true,"path":"2019/10/22/VUE自定义组件v-model使用/","link":"","permalink":"/2019/10/22/VUE自定义组件v-model使用/","excerpt":"vue中自定义组件v-model双向数据绑定的使用","text":"vue中自定义组件v-model双向数据绑定的使用 VUE自定义组件v-model使用我们在写vue组建的时候，可以往组件里传prop，但是普通的属性都是单向数据流，要想在子组件里修改父组件里值，必须在父组件中定义一个事件，在子组件里this.$emit(&#39;事件名&#39;,&#39;...参数&#39;),但是我觉得好麻烦，要想实现数据的双向绑定还得定义子组件调用的事件方法，我们可以直接使用v-model,可以简单些。父组件代码：123456789101112131415&lt;template&gt; &lt;div&gt; &lt;Child v-model=\"val\" /&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; val: 123 &#125; &#125;, components: &#123; Child &#125;&#125; 子组件代码：123456789101112131415161718&lt;template&gt; &lt;div&gt; &#123;&#123;value&#125;&#125; &lt;div @click=\"changeVal\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, props: ['value'], methods: &#123; changeVal () &#123; this.$emit('input', 456); // 注意这里默认是input事件哦 &#125; &#125;&#125; 是不是双向数据绑定写着会简单些。最后，看一下vue中v-model的语法糖：12&lt;input v-model=\"price\"&gt;&lt;input type=\"text\" :value=\"price\" @input=\"price=$event.target.value\"&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"前端优化之Pre技术简介","slug":"前端优化之Pre技术简介","date":"2019-10-14T05:06:31.000Z","updated":"2024-01-11T07:00:59.259Z","comments":true,"path":"2019/10/14/前端优化之Pre技术简介/","link":"","permalink":"/2019/10/14/前端优化之Pre技术简介/","excerpt":"link标签中pre技术的介绍","text":"link标签中pre技术的介绍 前端优化之Pre技术简介Pre技术：预加载技术。提供在不影响当前页面情况下，浏览器预加载资源的性能优化方案。 DNS Prefetch就是上述提到的，用于告知浏览器，尽可能预先解析指定域名的DNS。使用方式：1&lt;link rel=\"dns-prefetch\" href=\"//the-domain-to-be-prefetched.com\" /&gt; 至于兼容性，可以说是目前为止所有的Pre技术里最好的了，兼容性查看IE是从IE9开始支持DNS Prefetch的，但是，是从IE10开始支持dns-prefetch。IE9里，并不是使用dns-prefetch来定义一个DNS的预解析，而是使用prefetch。挺尴尬的，因为prefetch在w3规范里又被用到了另一个Pre技术，下面会讲到。 Preconnect预连接。和DNS Prefetch类似，但是，更进一步。它不仅要求浏览器预解析指定域名的DNS，还需要预先与服务器握手以及TLS协商（如果使用了HTTPS）。使用方式：1&lt;link rel=\"preconnect\" href=\"//the-domain-to-be-preconnect.com\" crossorigin=\"anonymous\" /&gt; 兼容性查看由于会与服务器握手，因此，就需要确定“是否跨域”。和script类似，带crossorigin属性，以告知浏览器如何处理跨域和cookie。 Prefetch上述DNS Prefetch里提到过，IE9里使用的DNS Prefetch类型名是prefetch，但是，这个类型名在规范里又被用于另外一个意图。Prefetch：预获取，在Preconnect基础上更进一步，它要求浏览器获取整个的指定资源，link[href]值指定的是某个具体资源，而不是简单的一个域名了。除了和Preconnect一样拥有rel、href和crossorigin外，还有as，可用于告知浏览器资源类型，这个类型和MIME不一样，是一个统称类型，比如：所有的图片都是as=”image”，JS的是as=”script”，HTML的是 as=”html”等，具体可以参考。使用方式：1&lt;link rel=\"prefetch\" href=\"//the-domain.com/prefetch.js\" crossorigin as=\"script\" /&gt; as属性并不是必须的，但是建议加上，以便浏览器能更好的添加请求Header来优化资源的获取。使用Prefetch，整个资源都会被加载，但是，浏览器不允许对资源预处理或执行，资源只是被提前加载，并缓存起来，以便将来使用。兼容性查看 Prerender预渲染。与Prefetch类似，浏览器会下载整个资源，但是，Prefetch不允许浏览器对资源做预处理和执行，而Prerender则会告知浏览器，下载资源（HTML）并解析/执行它，包括被解析资源的子资源，这意味着会下载该HTML中的图片、样式、脚本等等。Prerender没有as属性，它下载的是HTML，使用方式1&lt;link rel=\"preconnect\" href=\"//the-domain-to-be-preconnect.com\" /&gt; 由于不允许对当前页面产生影响，浏览器设置预渲染的页面visibilityState属性为hidden。兼容性查看建议少用这个，太耗资源。而且，查看上述兼容性，你会看到Chrome 58里又把这个功能干掉了。 Preload预加载。这是一个和Prefetch几乎一模一样的功能，但是，其加载的资源适用的场景又完全不一样。使用方式只是将上述Prefetch中的prefetch改成preload。其他的完全一样：1&lt;link rel=\"preload\" href=\"//the-domain.com/prefetch.png\" crossorigin as=\"image\" /&gt; 与Prefetch*不同之处在于： Prefetch的优先级很低，低到浏览器可以不加载 Preload的优先级很高，浏览器一定要加载 Prefetch加载的资源用于将来某个页面中（这意味着它可能压根不会被用到） Preload加载的资源用于当前页面中 所以，在使用prefetch还是preload时候，需要考虑上述的不同点，而不应该盲目使用。[Preload以前叫Subresource]兼容性查看最后，上述Pre技术，除了Preload，其他的Pre都可能“不被浏览器执行”，这不是兼容性的问题，而是，这些Pre都不是浏览器必须行为，浏览器会根据一定的策略决定是否Pre相应的资源或操作，这些策略包括：CPU、内存等的占用率。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"<script>标签的defer,async,module","slug":"script-标签的defer-async-module","date":"2019-10-14T03:15:11.000Z","updated":"2024-01-11T07:00:59.230Z","comments":true,"path":"2019/10/14/script-标签的defer-async-module/","link":"","permalink":"/2019/10/14/script-标签的defer-async-module/","excerpt":"&lt;script&gt;标签中defer,async,module的使用","text":"&lt;script&gt;标签中defer,async,module的使用 &lt;script>标签的defer,async,moduledefer&amp;async传统方法HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。12345678&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=\"application/javascript\"&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\"&gt;&lt;/script&gt; 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=”application/javascript”可以省略。默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。12&lt;script src=\"path/to/myModule.js\" defer&gt;&lt;/script&gt;&lt;script src=\"path/to/myModule.js\" async&gt;&lt;/script&gt; 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 module加载规则浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=”module”属性。1&lt;script type=\"module\" src=\"./foo.js\"&gt;&lt;/script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。浏览器对于带有type=”module”的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。123&lt;script type=\"module\" src=\"./foo.js\"&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=\"module\" src=\"./foo.js\" defer&gt;&lt;/script&gt; 如果网页有多个&lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。&lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。1&lt;script type=\"module\" src=\"./foo.js\" async&gt;&lt;/script&gt; 一旦使用了async属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。12345&lt;script type=\"module\"&gt; import utils from \"./utils.js\"; // other code&lt;/script&gt; 对于外部的模块脚本（上例是foo.js），有几点需要注意。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。下面是一个示例模块。123456import utils from 'https://example.com/js/utils.js';const x = 1;console.log(x === window.x); //falseconsole.log(this === undefined); // true 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。1const isNotModuleScript = this !== undefined;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"测试相关术语整理","slug":"测试相关术语整理","date":"2019-10-12T07:38:38.000Z","updated":"2024-01-11T07:00:59.273Z","comments":true,"path":"2019/10/12/测试相关术语整理/","link":"","permalink":"/2019/10/12/测试相关术语整理/","excerpt":"介绍一些测试的相关术语","text":"介绍一些测试的相关术语 测试相关术语整理作为一名前端开发工程师，工作中肯定会和测试同事打交道，为了不丢面子，一些测试用语还是应该知道滴。 Unit testing（单元测试），指一段代码的基本测试，其实际大小是未定的，通常是一个函数或子程序，一般由开发者执行。 Integration testing（集成测试），被测试系统的所有组件都集成在一起，找出被测试系统组件之间关系和接口中的错误。该测试一般在单元测试之后进行。 Acceptance testing（验收测试），系统开发生命周期方法论的一个阶段，这时相关的用户和／或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。这是管理性和防御性控制。 Alpha testing (α测试),是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。 Beta testing(β测试),测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。 Black box testing（黑盒测试），指测试人员不关心程序具体如何实现的一种测试方法。根据软件的规格对软件进行各种输入和观察软件的各种输出结果来发现软件的缺陷的测试，这类测试不考虑软件内部的运作原理，因此软件对用户来说就像一个黑盒子。 White box testing（白盒测试），根据软件内部的工作原理分析来进行测试,基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。 Automated Testing（自动化测试），使用自动化测试工具来进行测试，这类测试一般不需要人干预，通常在GUI、性能等测试中用得较多。 Bug (错误)，有时称作defect（缺陷）或error（错误），软件程序中存在的编程错误，可能会带来不必要的副作用，软件的功能和特性与设计规格说明书或用户需求不一致的方面。软件缺陷表现特征为：软件未达到产品说明书标明的功能；软件出现产品说明书指明不会出现的错误；软件功能超出产品说明书指明的范围；虽然产品说明书未指出但是软件应达到的目标；软件测试人员或用户认为软件难以理解，不易使用，运行速度缓慢等问题。 Bug report（错误报告），也称为“Bug record（错误记录）”，记录发现的软件错误信息的文档，通常包括错误描述、复现步骤、抓取的错误图像和注释等。 Bug tracking system（错误跟踪系统，BTS），也称为“Defect tracking system，DTS”，管理软件测试缺陷的专用数据库系统，可以高效率地完成软件缺陷的报告、验证、修改、查询、统计、存储等任务。尤其适用于大型多语言软件的测试管理。 “抓虫大扫除”（Bug Bash）：在某一个版本的发行里程碑到达之后，在发行之前项目经理向全体开发组织发出通知，告诉大家哪一天的某个时间是Bug Bash的时间，到时候全体成员，包括开发、测试、文档等团队、甚至市场部门的员工，全都放下手中的工作，在规定的那一个或几个小时的时间里，每个人把自己当作是用户一样来使用这个未成品的软件，并且进行竞赛，看谁能找到最多的Bug。这样做的目的是，不是按照测试方案的顺序来检查软件，而是通过像真正的用户那样来使用软件，即完全是任意性的、无规则的顺序，看看在这样的使用条件下，还有没有仍旧没有被发现的严重的Bug。我们往往采用谁找到最严重的Bug 就得奖的方法来鼓励大家尽力找出Bug。抓虫大扫除一结束，项目经理马上进行新呈交的Bug数量的统计，然后向开发组织中的全体员工公布。得奖的小有免费的咖啡、午餐、电影票等，大有各种礼物。所以每次Bug Bash 大家都踊跃参加，找到很多测试案例执行时没找到的问题。 Exception（异常/例外），一个引起正常程序执行挂起的事件。 Crash（崩溃），计算机系统或组件突然并完全的丧失功能，例如软件或系统突然退出或没有任何反应（死机）。 Build（工作版本），软件开发过程中用于内部测试的功能和性能等不完善的软件版本。工作版本既可以是系统的可操作版本，也可以是展示要在最终产品中提供的部分功能的部分系统。 Functional testing (功能测试)，也称为behavioral testing（行为测试），根据产品特征、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化软件的功能测试，用于验证应用程序或网站对目标用户能正确工作。使用适当的平台、浏览器和测试脚本，以保证目标用户的体验将足够好，就像应用程序是专门为该市场开发的一样。 Load testing（负载测试），通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。在这种测试中，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力。负载测试的目标是确定并确保系统在超出最大预期工作量的情况下仍能正常运行。此外，负载测试还要评估性能特征，例如，响应时间、事务处理速率和其他与时间相关的方面。 Performance testing（性能测试），评价一个产品或组件与性能需求是否符合的测试。包括负载测试、强度测试、数据库容量测试、基准测试等类型。 Pilot testing（引导测试），软件开发中，验证系统在真实硬件和客户基础上处理典型操作的能力。在软件外包测试中，引导测试通常是客户检查软件测试公司测试能力的一种形式，只有通过了客户特定的引导测试，软件测试公司才能接受客户真实软件项目的软件测试。 Portability testing（可移植性测试），测试软件是否可以被成功移植到指定的硬件或软件平台上。 Compatibility Testing（兼容性测试），也称“Configuration testing（配置测试）”，测试软件是否和系统的其它与之交互的元素之间兼容，如：浏览器、操作系统、硬件等。验证测试对象在不同的软件和硬件配置中的运行情况。 Installing testing（安装测试），确保该软件在正常情况和异常情况的不同条件下，例如，进行首次安装、升级、完整的或自定义的安装都能进行安装。异常情况包括磁盘空间不足、缺少目录创建权限等。核实软件在安装后可立即正常运行。安装测试包括测试安装代码以及安装手册。安装手册提供如何进行安装，安装代码提供安装一些程序能够运行的基础数据。 International testing（国际化测试），国际化测试的目的是测试软件的国际化支持能力，发现软件的国际化的潜在问题，保证软件在世界不同区域中都能正常运行。国际化测试使用每种可能的国际输入类型，针对任何区域性或区域设置检查产品的功能是否正常，软件国际化测试的重点在于执行国际字符串的输入/输出功能。国际化测试数据必须包含东亚语言、德语、复杂脚本字符和英语（可选）的混合字符。 Localizability testing(本地化能力测试)，本地化能力是指不需要重新设计或修改代码，将程序的用户界面翻译成任何目标语言的能力。为了降低本地化能力测试的成本，提高测试效率，本地化能力侧是通常在软件的伪本地化版本上进行。本地化能力测试中发现的典型错误包括：字符的硬编码（即软件中需要本地化的字符写在了代码内部），对需要本地化的字符长度设置了国定值，在软件运行时以控件位置定位，图标和位图中包含了需要本地化的文本，软件的用户界面与文档术语不一致等。 Localization testing（本地化测试），本地化测试的对象是软件的本地化版本。本地化测试的目的是测试特定目标区域设置的软件本地化质量。本地化测试的环境是在本地化的操作系统上安装本地化的软件。从测试方法上可以分为基本功能测试，安装/卸载测试，当地区域的软硬件兼容性测试。测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和联机帮助等部分。 Ad hoc testing (随机测试)，没有书面测试用例、记录期望结果、检查列表、脚本或指令的测试。主要是根据测试者的经验对软件进行功能和性能抽查。随机测试是根据测试说明书执行用例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。 Smoke testing（冒烟测试），冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作。冒烟测试的执行者是版本编译人员。参考“Sanity testing（健全测试）”。 Sanity testing（健全测试），软件主要功能成分的简单测试以保证它是否能进行基本的测试。 User interface（用户界面，UI），广义是指使用户可以和计算机进行交互的硬件和/或软件。狭义是指软件中的可见外观及其底层与用户交互的部分（菜单、对话框、窗口和其它控件）。 User interface testing (用户界面测试)，指测试用户界面的风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等等。UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。 Static testing（静态测试），不通过执行来测试一个系统。如代码检查，文档检查和评审等。 Regression testing（回归测试），在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，对软件的任何新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再现。 Capture/Replay Tool (捕获/回放工具)，一种测试工具，能够捕获在测试过程中传递给软件的输入，并且能够在以后的时间中，重复这个执行的过程。这类工具一般在GUI测试中用的较多。 Debug（调试），开发人员确定引起错误的根本原因和确定可能的修复措施的过程。一般发生在子系统或单元模块编码完成时，或者根据测试错误报告指出错误以后，开发人员需要执行调试过程来解决已存在的错误。 Deployment（部署），也称为shipment(发布)，对内部IT系统而言，指它的第一个版本通过彻底的测试、形成产品、交付给付款客户的阶段。 Dynamic testing（动态测试），通过执行软件的手段来测试软件。 Garbage characters（乱码字符），程序界面中显示的无意义的字符，例如，程序对双字节字符集的字符不支持时，这些字符不能正确显示。 GB 18030 testing（GB 18030测试），软件支持GB 18030字符集标准能力的测试，包括GB 18030字符的输入、输出、显示、存储的支持程度。 Priority（优先权），从商业角度出发是指错误的重要性，尤其是从客户和用户的角度出发，是指错误对于系统的可行性和可接受性的影响。与“Severity（严重性）”相对照。 Severity（严重性），错误对被测系统的影响程度，在终端用户条件下发生的可能性，软件错误妨碍系统使用的程度。 Quality assurance（质量保证QA），采取相关活动，以保证一个开发组织交付的产品满足性能需求和已确立的标准和过程。 Review（评审），在产品开发过程中，把产品提交给项目成员、用户、管理者或其它相关人员评价或批准的过程。 Screen shot（抓屏、截图），软件测试中，将软件界面中的错误（窗口、菜单、对话框等）的全部或一部分，使用专用工具存储成图像文件，以便于后续处理。 Software life cycle（软件生命周期），开始于一个软件产品的构思，结束于该产品不再被使用的这段期间。 Structured query language（结构化查询语句，SQL），在一个关系数据库中查询和处理数据的一种语言。 TBD(To be determined，待定)，在测试文档中标是一项进行中的尚未最终确定的工作。 Test（测试），执行软件以验证其满足指定的需求并检测错误的过程。检测已有条件之间的不同，并评价软件项的特性软件项的分析过程。软件工程过程的一个活动，它将软件在预定的条件下运行以判断软件是否符合预期结果。 Test case（测试用例），为特定目标而开发的一组测试输入、执行条件和预期结果，其目标可以是测试某个程序路径或核实是否满足某个特定的需求。 Testing coverage（测试覆盖），指测试系统覆盖被测试系统的程度，一项给定测试或一组测试对某个给定系统或构件的所有指定测试用例进行处理所达到的程度。 Testing environment（测试环境），进行测试的环境，包括测试平台、测试基础设施、测试实验室和其他设施。 Testing item（测试项），作为测试对象的工作版本。 Testing plan（测试计划），描述了要进行的测试活动的范围、方法、资源和进度的文档。它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。 Testing procedure（测试过程），指设置、执行给定测试用例并对测试结果进行评估的一系列详细步骤。 Testing script（测试脚本），一般指的是一个特定测试的一系列指令，这些指令可以被自动化测试工具执行。 Testing suite（测试包），一组测试用里的执行框架；一种组织测试用例的方法。在测试包里，测试用例可以组合起来创造出独特的测试条件。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"带标签的模板字符串","slug":"带标签的模板字符串","date":"2019-10-12T07:01:55.000Z","updated":"2024-01-11T07:00:59.265Z","comments":true,"path":"2019/10/12/带标签的模板字符串/","link":"","permalink":"/2019/10/12/带标签的模板字符串/","excerpt":"模板字符串的特殊用法","text":"模板字符串的特殊用法 带标签的模板字符串模板字符串中我们使用 ${exporession} 作为占位符，而作为字符串连接的语法糖是其最基本的用法，而带标签的模板字符串则是一种函数调用，这能够让模板字符串更加强大，拥有真正模板引擎的功能。123456789var a = function (strs, ...args) &#123; console.log(strs) console.log(args)&#125;var name ='jinux'var age = 20a `name: $&#123;name&#125;, age: $&#123;age&#125;` 在浏览器的console面板打印一下。可以看到，标签模板字符串的标签函数的第一个参数是由原始的字符串由占位字符串分割而成的字符串组成的数组，剩下的参数则是对应占位符的值。利用这个特性常被提到的是避免XSS攻击：12345678function htmlEscape(literals, ...placeholders) &#123; return placeholders.reduce((pre, val, i) =&gt; pre + literals[i] + val .replace(/&amp;/g, '&amp;amp;') .replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;#39') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;'), '') + literals[literals.length - 1]&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"SPA应用前端预渲染之VUE","slug":"SPA应用前端预渲染之VUE","date":"2019-10-11T07:22:53.000Z","updated":"2024-01-11T07:00:59.146Z","comments":true,"path":"2019/10/11/SPA应用前端预渲染之VUE/","link":"","permalink":"/2019/10/11/SPA应用前端预渲染之VUE/","excerpt":"vue中如何实现预渲染","text":"vue中如何实现预渲染 SPA应用前端预渲染之VUESPA应用的缺点是第一次打开缓慢，再有就是SEO不友好，优化有两种方式，一种是前端预渲染，另一种是后端渲染ssr,今天我们只说前端预渲染。前端预渲染必须在webpack的基础上来做，用到的插件是prerender-spa-plugin。我们在创建vue项目的时候现在都是用vue-cli，这里我只举例3.0版本。 prerender-spa-plugin的使用安装1cnpm install prerender-spa-plugin --save vue-config.js中增加1234567891011121314151617181920212223242526272829const PrerenderSPAPlugin = require('prerender-spa-plugin');const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;const path = require('path');module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV !== 'production') return; return &#123; plugins: [ new PrerenderSPAPlugin(&#123; // 生成文件的路径，也可以与webpakc打包的一致。 // 下面这句话非常重要！！！ // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。 staticDir: path.join(__dirname,'dist'), // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。 routes: ['/', '/product','/about'], // 这个很重要，如果没有配置这段，也不会进行预编译 renderer: new Renderer(&#123; inject: &#123; foo: 'bar' &#125;, headless: false, // 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;), ], &#125;; &#125;&#125; 在main.js中增加12345678new Vue(&#123; router, store, render: h =&gt; h(App), mounted () &#123; document.dispatchEvent(new Event('render-event')) &#125;&#125;).$mount('#app') 路由设置router.js 中设置mode: “history” 打包运行npm run build，之后在dist文件夹下可以看到跟预渲染路由名字一样文件夹，里边有一个index.html的文件，这就是预渲染页面。 总结在现实中，这种需求还是很多的，我现在做的项目领导对首页加载一直不满意，首页是一个登录页面，现在的做法我把登录页的内容直接写死到dom里了，当js文件加载好了之后再覆盖掉，这种方式也可以，我看掘金的首页就是这么干的。我来说一下我理解的预渲染，比如想把about页面预渲染出来，打包之后发现有两个html文件，正常的首页index.html页和about文件夹下的index.html页，仔细观察about预渲染页面，引入的js，css文件是一样的，只是显示的dom内容已经写死在dom里了，当然，也可以把首页的html文件预渲染，其实也是静态化，这样SEO就可以抓到里边的内容。预渲染的页面刚访问的时候里边内容是写死的，当点击路由后又切回到vue自己的路由模式来加载页面，当然，我猜在vue的路由里边已经删除了预渲染页面的路由，访问这些页面的时候只能去服务器端去下载静态的预渲染页面了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"flex简单教程","slug":"flex简单教程","date":"2019-10-10T05:27:39.000Z","updated":"2024-01-11T07:00:59.180Z","comments":true,"path":"2019/10/10/flex简单教程/","link":"","permalink":"/2019/10/10/flex简单教程/","excerpt":"flex语法的简单记录","text":"flex语法的简单记录 flex简单教程flex在项目中经常使用，但是语法还是经常忘，这里简单的记录下基本语法，以便方便查看，如果想系统学习，请阅读阮一峰老师的两篇文章Flex 布局教程：语法篇 和 Flex 布局教程：实例篇 容器指定为flex容器1234.box &#123; display: flex; // 块元素flex布局 display: inline-flex; // 行间元素flex布局&#125; flex容器的属性12345678910111213141516171819.box &#123; // 属性决定主轴的方向（即项目的排列方向）。 flex-direction: row | row-reverse | column | column-reverse; // flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-wrap: nowrap | wrap | wrap-reverse; // flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; // justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; // align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex容器里项目的属性12345678910111213141516171819.item &#123; // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 order: &lt;integer&gt;; // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-grow: &lt;number&gt;; /* default 0 */ // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-shrink: &lt;number&gt;; /* default 1 */ // flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex-basis: &lt;length&gt; | auto; /* default auto */ // flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] // 例：auto (1 1 auto) 和 none (0 0 auto) // align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"简单快速理解web缓存","slug":"简单快速理解web缓存","date":"2019-10-09T05:39:13.000Z","updated":"2024-01-11T07:00:59.276Z","comments":true,"path":"2019/10/09/简单快速理解web缓存/","link":"","permalink":"/2019/10/09/简单快速理解web缓存/","excerpt":"简单快速,5分钟你就能理解web缓存","text":"简单快速,5分钟你就能理解web缓存 简单快速理解web缓存之前我已经写过了一篇关于web缓存的文章，阅读点这里，不过，这篇文章比较长，今天再写个短小易懂的，便于快速查看。 服务器的缓存协商缓存有两种，一种是需要服务器验证，另外一种是不用发送请求验证。 ETag/Last-Modified这两种方式做法类似，都要向服务器发送一次请求进行验证。简直，缓存就缓存呗，为什么还要验证呢？ 其实，这是该协议的一种特有方式，发送一次验证主要是检查文件是否发生变化。 ETagETag是用来计算文件的内容是否发生变化，比如，你在文件中删除一个空格，这样都算文件内容发生变化。 通常做法是用md5或者SHA1算法，计算出文件的唯一值。 在前端其实都可以完成， 找到一个文件文件解析的md5算法，然后将文件传入，就可以得到ETag的值。 不过这里，我们着重点并不是让你生成Etag，而是看看ETag在缓存中的重要作用。 ETag是HTTP/1.1A的一种办法，由Web服务器生成，并写入响应头中。12//response HeadersETag:\"751F63A30AB5F98F855D1D90D217B356\" 接着，到了浏览器之后，便缓存在本地。 当下次打开同样的文章时，会在请求头中发送If-None-Match, 给服务器检查文件是否发生变化。如果没有，则告诉浏览器使用本地的，否则返回新文件12//request HeadersIf-None-Match: \"751F63A30AB5F98F855D1D90D217B356\" 通常情况下，服务器默认是打开Etag的，但是为了防止你的同事，或者后台哥哥的后台配置文件不正确，关闭了Etag，这时候，就需要你对对配置文件做一些设置。 这里我以Nginx为例: 打开ngnix.conf文件，检查是否有以下语句:123etag off;more_set_headers -s 404 -t 'ETag';more_clear_headers 'Etag'; 如果有则将其删除掉。然后重启nginx就可以了。他们将Etag关闭的原因其实也很简单，就是因为，Etag打开之后会增加服务器的负载，造成性能的局限性，所以，关闭或者打开Etag都要经过权衡的。 Last-Modified这和文档内容信息验证不同，这里采用的是日期验证办法。 即，服务器上会对文件打上一个文件改动的日期，然后客户端接受该日期，下次请求时，返回该日期，服务器验证，如果日期未变，则告诉浏览器使用本地缓存即可。 即，在服务器的相应头中，可以设置Last-Modified，来启用这一缓存协议.12//Response HeaderLast-Modified:Tue, 03 Mar 2015 01:38:18 GMT 接受到这一响应头之后，浏览器会对该文件做一个缓存，并保存该日期。当下次请求的时候，会通过If-Modified-Since将日期传入并验证:1If-Modified-Since:Tue, 03 Mar 2015 01:38:18 GMT 如果日期未变，则告诉浏览器使用缓存。 那我们通常应该怎样启用服务器这一功能呢？ 默认情况下，服务器会对静态资源发送Last-modified的tag。 但是，需要注意，Last-Modified的更新时间只能以秒来计，如果你文件改动过于频繁，Last-Modified是无效的(不过，谁牛逼到1s内能多次更新文件嘞~) 实际上.Last-Modified的这个标签的我们通常并不会单独使用它，通常与expires结合，形成一个可降级的缓存. Expires/Cache-ControlExpires/Cache协议与上述验证协议最大的不同在于，他可以省略发送验证请求环节，不需要服务器的验证，而直接使用本地缓存。 通常这种方式，适用于，项目稳定，版本迭代不多的时候。 Expires在服务器端可以设置Expires的一个绝对时间。12//Response HeadersExpires:Tue, 03 May 2016 09:33:34 GMT 这告诉浏览器,在2016.5.3号之前,可以直接使用该文本的缓存副本。但是，可能会因为服务器和客户端的GMT时间不同，会有一定的bug。 所以，这里只提议在长时间缓存的情况下使用。否则，应该选择Cache-Control. 那在服务器端该怎么设置呢？ 这里以nginx为例:12345location ~* \\.(?:css|js)$ &#123; expires 1d; access_log off; add_header Cache-Control \"public\";&#125; 通过expires设置过期时间为一天，此时，服务器会根据当前的时间，加上一天.同时添加Expires和Cache-Control头部标签。 即,得到的Response Header为:12Expires: Fri, 28 Feb 2014 10:42:09 GMTCache-Control: max-age=86400 //24*60*60 (HTTP规定，如果出现max-age和expires，则max-age默认覆盖掉expires) 当expires为负数表示no-cache，正数或零表示max-age=time。 如果你不想缓存，可以直接设置:1expires -1; //永远过期，Cache-Control: no-cache Cache-Control这应该是HTTP1.1为了解决HTTP1.0中expires的时间差的bug，而新添加的一个tag. 他的配置项很多，其实完全都可以取代expires(现在大多数服务器都支持). 引用一段原话: Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。 不过，目前大部分服务器都会将两者添加上，因为HTTP规定，如果Cache-Control和expires同时出现的话，expires会默认被覆盖掉。 此时，返回的响应码不再是304(文件未改动),而是200(资源成功访问). 当前每次发送请求之前浏览器会检查缓存系统里，是否有相应文件的备份，如果有的话，则直接从本地模仿一个Response头 理论知识铺垫完毕，我们来take a look. 看看cache-control 有哪些可以配置的属性(以下属性都跟在cache-control后)12345678public: 共有缓存，可被缓存代理服务器缓存,比如CDNprivate: 私有缓存，不能被共有缓存代理服务器缓存，可被用户的代理缓存如浏览器。max-age=[秒]：表示在这个时间范围内缓存是新鲜的无需更新。类似Expires时间，不过这个时间是相对的，而不是绝对的。也就是某次请求成功后多少秒内缓存是新鲜的。s-maxage=[秒]：类似max-age, 除了仅应用于共享缓存（如代理）。no-cache：这里不是不缓存的意思，只是每次在使用缓存之前都强制发送请求给源服务器进行验证，检查文件该没改变(其实这里和ETag/Last区别不大)no-store：就是禁止缓存，不让浏览器保留缓存副本must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是200而是304了。proxy-revalidate：类似must-revalidate，除了只能应用于代理缓存。 比如，这里我可以设置Cache-Control为:12//Response HeadersCache-Control:private, max-age=0, must-revalidate 该文件是一个私有文件,只能被浏览器缓存，而不能被代理缓存。max-age标识该缓存立即过期，其实和no-cache实际上区别不大. 然后must-revalidate告诉浏览器，你必须给我再验证文件过没过期，比如接下来可能会验证Last-Modified或者ETag.如果没有过期则使用本地缓存. 其实上面可以直接等同于:12//Response HeadersCache-Control:private,no-cache 使用no-store的结果12//Response HeadersCache-Control:no-store; 这样表明，不管一不一样都需要重新下载. 强烈表示，不让你使用缓存文件。后续的就不会去验证ETag了。 当然，如果你将IE6那种古老的浏览器考虑进来的话，那你干脆就做的不要脸一点，直接用下面的tag就行:123Cache-Control: no-cache, no-store, must-revalidate //HTTP1.1Pragma: no-cache //HTTP1.0Expires: 0 //Proxy 不过现在基本上也没有不支持Cache-Control的浏览器了。所以，正常情况下，可以直接使用.如下的策略来进行设置:(From google developer) 我们通常在nginx怎么配置对应的cache-control头呢？12345678910111213141516##设置no-cache//Nginxexpires -1;//cache-controlCache-Control:no-cache##设置max-age=0//Nginxexpires 0;//cache-controlCache-Control:max-age=0##设置其他头部//nginxadd_header Cache-Control \"no-cache\";add_header Pragma no-cache; 上面说的基本上是服务器的响应头，那在浏览器的Request headers里存在cache-control代表什么呢？ 当请求头中有:Cache-Control: max-age=0,表示缓存需要进行验证(ETag||Last-Modified)，如果缓存未过期,则可以使用。 当请求头中有:Cache-Control: no-cache,表示浏览器只能获取最新的文件。 和Response Header中的no-store相对应。 组合缓存策略上面介绍的last/ETag/Expires/Cache都是HTTP协议的缓存策略。当然，缓存不止这一种，比如在HTML 4.0中定义的某些meta也可以实现自定义缓存的123&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\" /&gt;&lt;meta http-equiv=\"Pragma\" content=\"no-cache\" /&gt;&lt;meta http-equiv=\"Expires\" content=\"0\" /&gt; 但，实际情况是，这些meta只能在file:// 本地文件中使用，如果是服务器则默认被覆盖。现在目前主流的就是使用HTTP1.1协议缓存 不过我们一般都不会单独使用某一项。 但是，组合之后他们的效果是怎样的呢？ 如果你的网页不是什么特别定制化的(私密)的，使用缓存能给你网站的性能带来极大的提升。所以很推荐使用。 一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件(视频就呵呵了). 我们可以针对这几类文件做一些缓存层级. 文件 缓存层级 HTML Cache-Control: no-cache,must-revalidate JS Cache-Control:private,max-age=86400 CSS Cache-Control:max-age=2629000 img\\fonts Cache-Control:max-age=2629000 上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"PWA应用","slug":"PWA应用","date":"2019-10-09T05:21:24.000Z","updated":"2024-01-11T07:00:59.146Z","comments":true,"path":"2019/10/09/PWA应用/","link":"","permalink":"/2019/10/09/PWA应用/","excerpt":"PWA应用教程","text":"PWA应用教程 PWA应用PWA是Progressive Web App的英文缩写， 翻译过来就是渐进式增强WEB应用， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。我也是正要准备学习，点这里学习在这里要感谢PWA学习手册的作者。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"SVG动画介绍","slug":"SVG动画介绍","date":"2019-09-30T03:19:26.000Z","updated":"2024-01-11T07:00:59.151Z","comments":true,"path":"2019/09/30/SVG动画介绍/","link":"","permalink":"/2019/09/30/SVG动画介绍/","excerpt":"SVG动画效果简单入门介绍","text":"SVG动画效果简单入门介绍 SVG动画介绍本文主要是讲解关于 SVG 的一些高级动画特效，比如 SVG 动画标签，图形渐变，路径动画，线条动画，SVG 裁剪等。例如：路径动画图形渐变：线条动画：以及，相关的动画的矩阵知识，这个也是现在 CSS 动画里面最重要，同时也是最为欠缺的知识点：文章会先从基本语法入手，然后，慢慢深入。介绍一些动画基本原理和对应的数学原理知识点。并且文章后面，还附有相关语法的介绍，当你在遇到不熟悉语法的时候可以参考参考。前面一篇文章，主要介绍了一些 SVG 的基本概念和基本图形。接下来我们需要了解一下，SVG 处理矢量这个特性之外，还有啥内容吸引我们，能让 SVG 现在普及度这么高？ SVG Animation在 SVG 中，如果我们想实现一个动画效果，可以使用 CSS，JS，或者直接使用 SVG 中自带的 animate 元素添加动画。使用 CSS 的话，有两种选择一种是通过 style 直接内联在里面，另外是直接使用相关的动画属性– transform。123&lt;use id=\"star\" class=\"starStyle\" xlink:href=\"#starDef\" transform=\"translate(100, 100)\" style=\"fill: #008000; stroke: #008000\"/&gt; 而使用 SVG 中自定的 animate 主要还是 SVG 自己的东西，比较好用。如果想用 CSS 的动画，这都无所谓。先看一个 SVG animate DEMO:12345678&lt;rect x=\"10\" y=\"10\" width=\"200\" height=\"20\" stroke=\"black\" fill=\"none\"&gt; &lt;animate attributeName=\"width\" attributeType=\"XML\" from=\"200\" to=\"20\" begin=\"0s\" dur=\"5s\" fill=\"freeze\" /&gt;&lt;/rect&gt; 通过将 animate 标签嵌套在指定的图形里面，即可实现变换的效果。另外，还有 animateTransform，它主要是用来做变形动画的。1234567&lt;rect x=\"-10\" y=\"-10\" width=\"20\" height=\"20\" style=\"fill: #ff9; stroke: black;\"&gt; &lt;animateTransform attributeType=\"XML\" attributeName=\"transform\" type=\"scale\" from=\"1\" to=\"4 2\" begin=\"0s\" dur=\"4s\" fill=\"freeze\"/&gt;&lt;/rect&gt; 简单来说： animate: 相当于 CSS 中的 transition animateTransform: 相当于 CSS 中的 transform 里面一些技术细节我们这里就不过多讲解了。这里，主要想介绍一下 animate 中的 morph 的效果。 animate morph该效果主要做的就是图形内部的渐变。如图：这种动画是怎么实现呢？直接看代码吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;path fill=\"#1EB287\"&gt; &lt;animate attributeName=\"d\" dur=\"1440ms\" repeatCount=\"indefinite\" keyTimes=\"0; .0625; .208333333; .3125; .395833333; .645833333; .833333333; 1\" calcMode=\"spline\" keySplines=\"0,0,1,1; .42,0,.58,1; .42,0,1,1; 0,0,.58,1; .42,0,.58,1; .42,0,.58,1; .42,0,.58,1\" values=\"M 0,0 C 50,0 50,0 100,0 100,50 100,50 100,100 50,100 50,100 0,100 0,50 0,50 0,0 Z; M 0,0 C 50,0 50,0 100,0 100,50 100,50 100,100 50,100 50,100 0,100 0,50 0,50 0,0 Z; M 50,0 C 75,25 75,25 100,50 75,75 75,75 50,100 25,75 25,75 0,50 25,25 25,25 50,0 Z; M 25,50 C 37.5,25 37.5,25 50,0 75,50 75,50 100,100 50,100 50,100 0,100 12.5,75 12.5,75 25,50 Z; M 25,50 C 37.5,25 37.5,25 50,0 75,50 75,50 100,100 50,100 50,100 0,100 12.5,75 12.5,75 25,50 Z; M 50,0 C 77.6,0 100,22.4 100,50 100,77.6 77.6,100 50,100 22.4,100, 0,77.6, 0,50 0,22.4, 22.4,0, 50,0 Z; M 50,0 C 77.6,0 100,22.4 100,50 100,77.6 77.6,100 50,100 22.4,100, 0,77.6, 0,50 0,22.4, 22.4,0, 50,0 Z; M 100,0 C 100,50 100,50 100,100 50,100 50,100 0,100 0,50 0,50 0,0 50,0 50,0 100,0 Z;\"/&gt; &lt;/path&gt; 这么多，是不是感觉有点懵逼。不过，我们细分来看一下其实很简单。里面主要是利用 animate 中的 keyTimes，calcMode，keySplines，以及 values 这几个属性。不急，我们一个一个来解释一下。 keyTimes: 这其实和 CSS 中定义的 @keyframes 一样。通过 0-1 之间的值，定义每段动画完成的时间。格式为：value;value…。例如 0;.0625;.208333333;.3125;.395833333;.645833333;.833333333;1。从第一个动画，到第二个动画经历的时间比例为 6.25%。并且，keyTimes 需要和 values 里面定义的帧数一致。 calcMode: 用来定义动画具体的插值模型。取值有: discrete | linear[default] | paced | spline。具体可以参考 MDN。这里我们主要介绍一下 spline。该值表示每个动画间使用自定的贝塞尔变换曲线。如果没有特殊要求，使用 linear 其实已经足够了，这样就不用麻烦去定义下面的 keySplines 属性。 keySplines：该值用来具体定义动画执行时的 贝塞尔曲线。使用格式是通过 ; 来分隔每一个值。即，cubic-bezier(.31,.57,.93,.46) 为一组。使用 keySplines 表达，则为：keySplines = “.31,.57,.93,.46;”。当然，里面的贝塞尔曲线组数为 整个动画帧数 - 1。 而 values 就很简单了。它是直接结合 attributeName 属性，来设置具体的值，每个值之间使用 ; 进行分隔。像上面那样，可以在指定元素里面嵌套多个 animate，既实现了形状的改变，又实现了颜色的改变。Morph 比较常用于数字的更迭，比如，倒数 10s 的相关动画。到这里，Morpah 相关的知识点就结束了。 接着，让我们来看一下 SVG 中，另外一非常重要的标签 – animateMotion。该标签可以让指定的元素，绕着指定的路径进行运动。所以这对于复杂的路径来说非常有用，因为我们很难使用 transform 去模拟复杂的变换路径。看一个 DEMO animateMotionanimateMotion 大致的属性和 animate 差不多，不过，它还拥有自己特有的属性，比如 keyPoints、rotate、path 等。不过，calcMode 在 AM(animateMotion) 中的默认属性由，linear 变为 paced。这些属性，我们慢慢介绍，先从最简单的开始吧。首先，我们来看一个 DEMO：12345&lt;g&gt; &lt;rect x=\"0\" y=\"0\" width=\"30\" height=\"30\" style=\"fill: #ccc;\"/&gt; &lt;circle cx=\"30\" cy=\"30\" r=\"15\" style=\"fill: #cfc; stroke: green;\"/&gt; &lt;animateMotion from=\"0,0\" to=\"60,30\" dur=\"4s\" fill=\"freeze\"/&gt;&lt;/g&gt; from，to：指定两点的位置，位置参数是以元素的坐标为原点的。 dur：执行渲染时间 fill：指定动画结束后停留的装填。有 freeze 和 remove 效果。remove 表示回到动画开始的位置，freeze 表示停留在动画结束的位置。 如果，你想要更复杂的路径，可以直接使用 path 属性来指定路径。用法和 path 标签中 d 属性是一样的。12345&lt;rect x=\"0\" y=\"0\" width=\"30\" height=\"30\" style=\"fill: #ccc;\"&gt; &lt;animateMotion path=\"M50,125 C 100,25 150,225, 200, 125\" dur=\"6s\" fill=\"freeze\"/&gt;&lt;/rect&gt; 或者使用 mpath 标签，引用外部的 path。1234567891011121314&lt;path d=\"M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110\" stroke=\"lightgrey\" stroke-width=\"2\" fill=\"none\" id=\"theMotionPath\"/&gt; &lt;circle cx=\"10\" cy=\"110\" r=\"3\" fill=\"lightgrey\" /&gt; &lt;circle cx=\"110\" cy=\"10\" r=\"3\" fill=\"lightgrey\" /&gt; &lt;!-- Red circle which will be moved along the motion path. --&gt; &lt;circle cx=\"\" cy=\"\" r=\"5\" fill=\"red\"&gt; &lt;!-- Define the motion path animation --&gt; &lt;animateMotion dur=\"6s\" repeatCount=\"indefinite\"&gt; &lt;mpath xlink:href=\"#theMotionPath\"/&gt; &lt;/animateMotion&gt; &lt;/circle&gt; 动画效果为：所以，一般而言我们在定义 AM 的路径的时候，只用一种方式定义即可，否则会发生相应的覆盖：mpath&gt;path&gt;values&gt;from/to。在 AM 运动中，还有一个很重要的概念就是旋转角。默认情况下，运动物体的角度是按照它和坐标轴的初始角度确定的。例如：这样看起来确实有些别扭，那能不能让物体垂直于路径进行运动呢？有的，根据 rotate 属性值，一共有 3 个值可供选择。 auto：让物体垂直于路径的切线方向运动。不过，如果你的路径是闭合曲线的话，需要注意起始点的位置。 例如： auto-reverse：让物体垂直于路径的切线方向并 + 180°。也就是和 auto 运动关于切线对称。 Number：让物体以固定的旋转角度运动。这个就相当于使用 transform:rotate(deg) 进行控制。 set该标签也是用来模拟 transition 效果的。它和 animate 的主要区别是，它仅仅需要 to 的指定属性，而不需要其他的参考属性，比如 from，by 等。那它有啥特别的存在意义吗？有的，因为 set 针对于所有属性，甚至包括 style 里面的相关 CSS 属性。所以，可以靠它来很好描述一些非 number 的属性值。12345&lt;text text-anchor=\"middle\" x=\"60\" y=\"60\" style=\"visibility: hidden;\"&gt; &lt;set attributeName=\"visibility\" attributeType=\"CSS\" to=\"visible\" begin=\"4.5s\" dur=\"1s\" fill=\"freeze\"/&gt; All gone!&lt;/text&gt; 矩阵动画上面差不多简单阐述了关于 SVG 一些比较有特点的动画。当然，还有比较重要的线条动画，这个我们放到后面进行讲解。这里先来看一下所有动画中，非常重要的矩阵原理。线性代数应该是大学里面来说，最容易学的一门科目，MD。。。还记得，大学线代期末考试的时候，100 分的同学应该说是如韭菜地般，一抓一大片（对不起，我没能和他们同流合污。）那矩阵是如何在动画中使用的呢？简单的说，矩阵中的每个元素其实可以等价代换为每个因式里面的系数：上面也叫作 三维矩阵。即，它涉及到 x,y,z 轴的计算。那对于我们平面 2D 变换来说，那么此时矩阵又是哪种形式呢？很简单，只要将 z 轴永远置为一个常数就 OK。这里，惯例上是直接取 0 0 1 来设置。不信的话，大家只要代进去乘以乘，应该就可以得到结果了。所以，在二维中，具体变换方式为：后面，我们也会依据这个公式进行相关的变形操作。那矩阵变换是怎么运用到 CSS/SVG 当中呢？在 CSS 中，是直接使用 transform 中的属性：1transform: matrix(a,b,c,d,e,f); 当然，在 SVG 中也是一样的：123&lt;g transform=\"matrix(1,2,3,4,5,6)\"&gt; &lt;line x1=\"10\" y1=\"20\" x2=\"30\" y2=\"40\" style=\"stroke-width: 10px; stroke: blue;\"/&gt; &lt;/g&gt; 所以，我们主要的重点就是讲解一下 matrix 这个属性。它的格式为：1matrix(a,b,c,d,e,f); 对应于我们上面的公式有：在接触 transform 的时候，大家应该了解到 transform 里面有很多固定的动画属性： translate() rotate() scale() skew()实际上，在底层还是使用 matrix 实现的变换。就拿 translate 举个例子吧。translate 的格式为：1translate(dx,dy) 相当于参考当前原点，在 x/y 轴上移动 dx/dy 的距离。那么映射到矩阵，应该如何表示呢？很简单，它等同于：1matrix(1 0 0 1 dx dy); 使用代数证明一下：假设有 matrix(1 0 0 1 20 30)变为矩阵为：根据，上面的表达式有：12X = x'*1 + y'*0 + 20 = x' + 20Y = x'*0 + y'*1 + 30 = y' + 30 所以，就是 X 在原有 X 轴坐标上向右移动 20 的距离，Y 相对于原有移动 30 的距离。那么其他几个属性呢？也是怎么变化的吗？恩，类似。只是里面取值不一样： scale(x,y): 放大 X/Y 轴，矩阵的表达为 matrix(x 0 0 y 0 0)。 rotate(θ): 坐标旋转，矩阵的表达为 matrix(cosθ sinθ -sinθ cosθ 0 0)。 skew(θx,θy): X/Y 轴拉伸，矩阵的表达为 matrix(1 tanθx tanθy 1 0 0)。 注意，上面三个都会改变原有物体的坐标系！！！ 这点很重要，换句话说，后面每次变换都是基于前面一个的变换结果的。详情看图：详情可以参考：MDN matrix不过，这并不是我们使用 matrix 的重点，也不是它的优势。它的优势在于可计算，即，能够将复杂的动画集合到一个表达式中，并且，后续的变换可以直接基于当前的 matrix。我们先来了解一下，如果多个变换动画一起使用，matrix 应该如何表达呢？只需要找到我们变换动画对应的矩阵，然后相乘即可。例如，先旋转 45°，然后放大 1.5 倍，则有变换动画为：1transform: rotate(45deg) scale(1.5,1.5); 注意，虽然，你定义动画是分开的，但此时的动画是同时进行的。为啥？因为，这两个动画实际上可以整合成为一个变换矩阵：并且，位置是不可以调换的。比如，transform: scale(2,2) translate(20px,30px)。即，你先放大两倍，然后移动 20,30 的距离。注意，这里移动的 20,30 相对的是已经放大过后的坐标，相对于原坐标而言就是 40,60 了。 如果，你调换位置，即 transform: translate(20px,30px) scale(2,2)。就变成现在原坐标移动 20,30，然后再放大两倍。而上面强调的顺序关系，实际上就可以理解为矩阵不满足交换律的原则。因为一旦交换，结果很可能不一样。 矩阵高级用法上面的内容只是简单的描述了关于矩阵的概念。在实际中，矩阵可以说是真正利器。假设现在有一个动画，要求你将一个物体从一个点通过抛物线的方式移动到另外一个点，那么此时要求 JS/CSS 随你挑。此时，你会不会感觉，呼吸急促，头脑发热呢？恩，matrix 可以治，而且包治百病。不过，matrix 有一个限制点，它只能用于一次线性动画表达式。即，针对于抛物线，椭圆曲线这类复杂曲线来说，不太合适。那么有什么办法吗？有的，微分思想。每一段动画其实都可以通过一定范围内的直线拼接而成，那么这样，我们就可以将一段抛物线拆分为由几段线段构成的曲线。当然，如果你分的越细，拟合度就越高。这里我们不打算过度你和，我们简单的将一段抛物线分为 5段。如图：那么接下来就是抠细节。这里，依次取倾角为 45°，30°，0°，-45°，-30° 这 5 段直线。每段分配的时间比例为 20%、25%、10%、25%、20% 这主要是用于 keyframe 的设定。现在，用数学来分析一下，这个动画到底该怎么弄。现在，已知两点之间的距离为 100px。那么我们同样根据上述比例分，则有 20px, 25px, 10px, 25px, 20px。这里我们以 45° 倾角为参考点，则终点坐标为 (20,20); 。那么，该段的矩阵为：12345// 注意 Y 轴需要取负值！ 1 0 20 0 1 -20 0 0 1 CSS 中的变形动画为：1transform: matrix(1,0,0,1,20,-20); 然后，第二段就为：1231 0 250 1 -14.40 0 1 使用矩阵的乘法法，则有：1231 0 45 0 1 -34.4 0 0 1 变形动画为： 1transform: matrix(1,0,0,1,45,-34.4); 剩余几段也是这样的做法。最终，整个 keyframe 就应该表示为：123456789@keyframe Parabola&#123; 20%&#123; transform: matrix(1,0,0,1,20,-20); &#125; 45%&#123; transform: matrix(1,0,0,1,45,-34.4); &#125; ...&#125; 整个动画过程差不多都是这样。当然，矩阵也不仅仅局限于这几个动画，凭借着高度定制化和灵活性的特点，这它还常常用于进行回弹，弹跳等动画中。如果大家有兴趣，后期也可以对这类动画进行简单的讲解。后面，我们最后来了解一下 SVG 中很重要的线条动画。 线条动画SVG 中的线条动画常常用作过渡屏（splash screen）中。例如： 或者，一些比较炫酷的 LOGO 中，比如 AllowTeam 的： 看到这些炫酷的效果，大家有没有动心想学一学，看看自己到底能否做的这么好呢？OK，我们现在来正式介绍一下线条动画。在 SVG 中，最长用到的线条标签就是 Path。这里我前面一篇文章已经做了介绍，我这里就不赘述了。而在具体变化当中用到的是关于 stroke 的相关属性：（下面的属性都可以直接用在 CSS 当中！） stroke：定义笔触的颜色。例如：stroke=”green” stroke-dasharray：定义 dash 和 gap 的长度。它主要是通过使用 , 来分隔 实线 和 间隔 的值。例如：stroke-dasharray=”5, 5” 表示，按照 实线为 5，间隔为 5 的排布重复下去。如下图：放大看有：另外，stroke-dasharray 并不局限于只能设置两个值，要知道，它本身的含义是设置最小重复单元，即，dash,gap,dash,gap…。比如，我定义 stroke-dasharray=”15, 10, 5” 则相当于，[15,10,5] 为一段。则有：放大看则有： stroke-dashoffset: 用来设置 dasharray 定义其实 dash 线条开始的位置。值可以为 number || percentage。百分数是相对于 SVG 的 viewport。通常结合 dasharray 可以实现线条的运动。 stroke-linecap: 线条的端点样式。 stroke-linejoin: 线条连接的样式 stroke-miterlimit: 一个比较复杂的概念，如果我们只是画一些一般的线段，使用上面 linejoin 即可。如果涉及对边角要求比较高的，则可以使用该属性进行定义。它的值，其实就是角长度比上线宽：而实际理解的话，就是假设当 width 为 1。此时比例为 2。那么 miter = 2。那么超过 2 的 miter 部分则会被 cut 掉。可以参照：他主要是配合 linejoin 一起使用。因为 linejoin 默认取值就是 miter。所以，默认情况下就可以使用该标签属性。它默认值为 4。其余的大家下去实践一下即可。详细可以参考: miter stroke-opacity：线段的透明度 stroke-width：线的粗细。 OK，介绍完关于 path 的所有 stroke 属性之后，我们就要开始动手写一下让线条动起来的代码。简单来说，就是通过 stroke-dashoffset 和 stroke-dasharray 来做。整个动画可以分为两个过程： 通过 dasharray 将实线部分隐藏，空余为全线段长。然后，将实线部分增加至全长。比如：dasharray: 0,1000 变为 dasharray: 1000,1000。 同时，通过 dashoffset 来移动新增的实线部分，造成线段移动的效果。有: dashoffset:0，变为 dashoffset:1000。 不过，这里我们不打算使用 Path 来做啥复杂的动画，这主要考虑到手头没有一些 SVG 生成工具。所以，这里我们就以 Text 来做吧（因为做起来真的简单）。这里，先以 IV-WEB 这段文字来做动画。先给大家看一下最终结果：那么这种动画是怎么做的呢？这里，我主要介绍一下关于 CSS 相关，SVG 就一个 Text 我直接贴代码了：123456789101112131415161718&lt;svg viewBox=\"0 0 1320 300\"&gt; &lt;!-- Symbol --&gt; &lt;symbol id=\"s-text\"&gt; &lt;text text-anchor=\"middle\" x=\"50%\" y=\"50%\" dy=\".35em\"&gt; IV-WEB &lt;/text&gt; &lt;/symbol&gt; &lt;!-- Duplicate symbols --&gt; &lt;use xlink:href=\"#s-text\" class=\"text\" &gt;&lt;/use&gt; &lt;use xlink:href=\"#s-text\" class=\"text\" &gt;&lt;/use&gt; &lt;use xlink:href=\"#s-text\" class=\"text\" &gt;&lt;/use&gt;&lt;/svg&gt; 上面是通过创建一个居中定位的字体，然后使用 3 个 text 重叠。具体 CSS 我们下面来说一下。首先，我们营造的效果是从无到有，就需要使用 dasharray 将 gap 设置的足够大。这里我取 300 即可。1stroke-dasharray: 0 300; 然后，通过 nth-child 选择器，给每一个文字使用不同的颜色值：12345678910.text:nth-child(3n + 1) &#123; stroke: #F60A0A;&#125;.text:nth-child(3n + 2) &#123; stroke: #F2FF14;&#125;.text:nth-child(3n + 3) &#123; stroke: #FB9505;&#125; 下面才是重点内容。此时，这 3 个 text 的起始点重合。我现在既要他们在运行时不完全重合，又要他们的线条能进行滚动。不啰嗦了，直接看代码吧：123456789101112131415161718192021@keyframes stroke &#123; 100% &#123; stroke-dashoffset: 1000; stroke-dasharray: 80 160; &#125;&#125;@keyframes stroke1 &#123; 100% &#123; stroke-dashoffset: 1080; stroke-dasharray: 80 160; &#125;&#125;@keyframes stroke2 &#123; 100% &#123; stroke-dashoffset: 1160; stroke-dasharray: 80 160; &#125;&#125; 这就是上面 3 个不同的 text 运用的动画。dashoffet 由 0 到 1000。这完成了滚动的目的。同时，为了让字体不重合，我还需要在对应字体的 dashoffset 上，加上不同的间隔距离。比如，第一个字体 offset 为 1000。那么第二个字体，我需要加上前一个字体 dash 的长度，即，80。所以，第二个字体就变为 1080。那么第三个就是加上前两个的 dash 长度，即 1160。大致过程就是这样，详情可以查看： IVWEB 线条动画。 SVG 中使用 transition在 SVG 中，本来就存在相关的动画 Tag，不过里面用起来比较复杂，最常用的还是直接利用 CSS 里面相关的属性标签来做。其中，transition 是最常用的。比如，想做一下颜色的渐变等等。这里可以直接利用 transition 修饰指定的 SVG 属性即可。1234# fill 是 SVG 中，专有属性path &#123; transition: fill .4s ease; &#125;#europe path &#123; fill: red; &#125;#europe:hover path &#123; fill: white; &#125; SVG 文字在 SVG 中定义文字直接使用 text 标签即可。关于文字来说，一般而言需要注意的点就那么即可，文字的排列，间距等等。这些都可以直接使用 CSS 进行控制。不过，有几个属性比较特殊，这里需要额外提一下。 text-anchor用来定义参考点和实际字符之间的定位关系。格式为： text-anchor: start | middle | end | inherit直接看代码解释吧：123456789&lt;!-- Anchors in action --&gt; &lt;text text-anchor=\"start\" x=\"60\" y=\"40\"&gt;A&lt;/text&gt; &lt;text text-anchor=\"middle\" x=\"60\" y=\"75\"&gt;A&lt;/text&gt; &lt;text text-anchor=\"end\" x=\"60\" y=\"110\"&gt;A&lt;/text&gt; 第一个 A，参考的是 (60,40) 的点，定义为 start ，那么参考点应该在字符的前面。而剩下两个也是同样的道理： tspan现在，假如我们想在 text 里面添加一些特殊的字符效果，比如斜体，加粗等。由于，text 标签不能实现嵌套，所以，为了解决这个痛点，提出了 tspan 的标签。它其实就是一个可以嵌套的 text 标签。12345&lt;text x=\"10\" y=\"30\" style=\"font-size:12pt;\"&gt; Switch among &lt;tspan style=\"font-style:italic\"&gt;italic&lt;/tspan&gt;, normal, and &lt;tspan style=\"font-weight:bold\"&gt;bold&lt;/tspan&gt; text.&lt;/text&gt; tspan 里面同样可以自定义相关的自身属性。详细的可以参考 tspan 我这里就不详述了。 在 Path 展示 textText 一般可以横放，竖放。那有没有啥办法让文字可以按照一定的路径任意排放呢？有的，这里可以使用 textPath 标签，来定义具体参考路径。123456789&lt;path id=\"sharp-corner\" d=\"M 30 110 100 110 100 160\" style=\"stroke: gray; fill: none;\"/&gt;&lt;text&gt; &lt;textPath xlink:href=\"#sharp-corner\"&gt; Making a quick turn &lt;/textPath&gt;&lt;/text&gt; 如图： Clip在 DOM 中如果想展示一个图片的部分，或者以某种形状展示图片的部分，一般是通过一个 cover div 来实现的。不过，如果涉及到不规则图形的话，那么 DOM 就有天生缺陷了（当然使用 CSS 里的 clip-path 可以完成，不过兼容性不太好）。而在 SVG 中，提供了 clipPath 标签，能够让我们自定义裁剪图片的范围和形状。clipPath 里面可以接任何图形，比如，path,rect 甚至是 text。使用的时候，直接在 style 中，指定 clip-path 即可，或者直接使用 clip-path 属性指定。123456789101112131415&lt;defs&gt; &lt;clipPath id=\"textClip\"&gt; &lt;text id=\"text1\" x=\"20\" y=\"20\" transform=\"rotate(60)\" style=\"font-family: 'Liberation Sans'; font-size: 48pt; stroke: black; fill: none;\"&gt;CLIP &lt;/text&gt; &lt;/clipPath&gt; &lt;/defs&gt; &lt;use transform=\"translate(100, 0)\" xlink:href=\"#shapes\" style=\"clip-path: url(#textClip);\"/&gt; &lt;use transform=\"translate(100, 0)\" xlink:href=\"#shapes\" clip-path=\"url(#textClip);\"/&gt; 或者说，如果我们想画一个圆的裁剪区域的话：1234567&lt;defs&gt; &lt;clipPath id=\"circularPath\" clipPathUnits=\"objectBoundingBox\"&gt; &lt;circle cx=\"0.5\" cy=\"0.5\" r=\"0.5\"/&gt; &lt;/clipPath&gt;&lt;/defs&gt;&lt;use xlink:href=\"#shapes\" style=\"clip-path: url(#circularPath);\" /&gt; Appendix 参考标签g分组标签应该毫无意外排第一，因为其实作为绘制图形中最常和最基本的标签。前面一篇文章也主要介绍过了，这里做点补充。每一个分组标签都带有 id 属性，唯一标识该分组，为什么呢？因为，后面我们可以使用该 id 标签添加动画，重用该分组等。123456&lt;g id=\"demo\" stroke=\"green\" fill=\"white\" stroke-width=\"5\"&gt; &lt;circle cx=\"25\" cy=\"25\" r=\"15\"/&gt; &lt;circle cx=\"40\" cy=\"25\" r=\"15\"/&gt; &lt;circle cx=\"55\" cy=\"25\" r=\"15\"/&gt; &lt;circle cx=\"70\" cy=\"25\" r=\"15\"/&gt;&lt;/g&gt; 每个分组里面可以含有一些描述标签，比如 desc。 这些描述内容是不会被渲染的。1234&lt;g id=\"demo\" stroke=\"green\" fill=\"white\" stroke-width=\"5\"&gt; &lt;desc&gt;Just Demo&lt;/desc&gt; &lt;circle cx=\"25\" cy=\"25\" r=\"15\"/&gt;&lt;/g&gt; use该标签就是结合 g 标签一起使用，作用是可以复用 g 分组的样式。1234&lt;g id=\"Port\"&gt; &lt;circle style=\"fill: inherit;\" r=\"10\"/&gt;&lt;/g&gt;&lt;use x=\"50\" y=\"30\" xlink:href=\"#Port\" class=\"classA\"/&gt; 里面使用 xlink:href 加上指定 group 的 id，然后通过 x，y 属性指定副本放置的位置。不过，有一个限制，use 标签的 style 属性，并不能覆盖点原始的 group style 样式。而且，有时候，我们只是想使用一些模板，即，图形并未被解析，只有代码存在。这时候，就需要使用 defs 来包裹了。 defs用来保存一些代码，使其不会被浏览器解析。并且里面的分组可以被 use 属性的 style 样式所覆盖。1234567 &lt;defs&gt; &lt;g id=\"Port\"&gt; &lt;circle style=\"fill: inherit;\" r=\"10\"/&gt; &lt;/g&gt; &lt;/defs&gt;&lt;use x=\"50\" y=\"50\" xlink:href=\"#Port\" style=\"fill: blue;\"/&gt; symbol该标签和 g 标签类似，也是用来进行分组。不过，它有个特点，即，不会被浏览器所渲染。那它不和 defs 差不多吗？恩，确实。不过，defs 是官方推荐，用来包裹一些模板 svg 代码而创造出来，用来增加可读性的标签。而 symbol 是存粹的作为一个模板。它可以独立于 svg 的 viewbox 来自定义子 viewbox 和 preserveAspectRatio。123456789&lt;symbol id=\"sym01\" viewBox=\"0 0 150 110\"&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"40\" stroke-width=\"8\" stroke=\"red\" fill=\"red\"/&gt; &lt;circle cx=\"90\" cy=\"60\" r=\"40\" stroke-width=\"8\" stroke=\"green\" fill=\"white\"/&gt;&lt;/symbol&gt;&lt;use href=\"#sym01\" x=\"0\" y=\"0\" width=\"100\" height=\"50\"/&gt; 同样使用该模板，也是使用 use 标签来完成。 image既然 use 可以重用 SVG 代码，那么 SVG 里面能不能重用已经画好的 png/jpg 的图片呢？这时候，就需要用到 image 标签。其可以用来加载外部的 PNG, JPEG 图片，注意，官方规定是前两种，其它图片支持不支持官方没做答复。即，如果你使用 GIF 图片，并不能保证所有的浏览器都能正常显示。1234&lt;image xlink:href=\"kwanghwamun.jpg\" x=\"72\" y=\"92\" width=\"160\" height=\"120\"/&gt;&lt;/svg&gt; 同样，该 image 标签也具有自定义 preserveAspectRatio 的效果。 x: 定义水平位置 y: 定义垂直位置 width: 图片渲染的宽度，必须有。 height: 图片渲染的高度，必须有。 preserveAspectRatio: 控制图片的缩放 markermarker 一般是用来画箭头或者线段始末的标识图形。123456789&lt;defs&gt; &lt;marker id=\"Triangle\" viewBox=\"0 0 10 10\" refX=\"1\" refY=\"5\" markerWidth=\"6\" markerHeight=\"6\" orient=\"auto\"&gt; &lt;path d=\"M 0 0 L 10 5 L 0 10 z\" /&gt; &lt;/marker&gt; &lt;/defs&gt; &lt;polyline points=\"10,90 50,80 90,20\" fill=\"none\" stroke=\"black\" stroke-width=\"2\" marker-end=\"url(#Triangle)\" /&gt; 如图:这里我们只需要里了解即可，因为在实际画的时候，直接使用相关工具生成更加方便。 a这里的 a 标签和我们直接在 HTML 使用的超链接 a 标签类似。也是用来定义一个外链的。123456&lt;a xlink:href=\"https://developer.mozilla.org/en-US/docs/SVG\" target=\"_blank\"&gt; &lt;rect height=\"30\" width=\"120\" y=\"0\" x=\"0\" rx=\"15\"/&gt; &lt;text fill=\"white\" text-anchor=\"middle\" y=\"21\" x=\"60\"&gt;SVG on MDN&lt;/text&gt;&lt;/a&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"}]},{"title":"SVG入门教程","slug":"SVG入门教程","date":"2019-09-29T02:04:14.000Z","updated":"2024-01-11T07:00:59.146Z","comments":true,"path":"2019/09/29/SVG入门教程/","link":"","permalink":"/2019/09/29/SVG入门教程/","excerpt":"SVG基础入门教程","text":"SVG基础入门教程 SVG入门教程svg和canvas是web页面画图的两个方式，我们在开发中常用的图形是折线图，柱形图，扇形图等，大多都用现有的库来做，如echarts，highcherts,d3等。但是有些特殊的图形用库是实现不了的，这时候就需要我们自己去完成，canvas性能好，但是难度大，所以，这次我来介绍下svg的基础写法，方便使用。SVG 全称是 Scalable Vector Graphics，即，矢量图。在 Web 中使用 SVG 可以解决位图放大失真的问题。首先，不要把 SVG 和 CSS，Canvas，HTML 搞混。他们之间并没有你中有我，我中有你的关系。SVG 是通过 XML 的形式写在 HTML 文档中的。 如何书写开篇说过，SVG 就是一个 XML。看一下代码吧：12345678&lt;svg x=\"0px\" y=\"0px\" width=\"450px\" height=\"100px\" viewBox=\"0 0 450 100\"&gt; &lt;rect x=\"10\" y=\"5\" fill=\"white\" stroke=\"black\" width=\"90\" height=\"90\"/&gt; &lt;circle fill=\"white\" stroke=\"black\" cx=\"170\" cy=\"50\" r=\"45\"/&gt; &lt;polygon fill=\"white\" stroke=\"black\" points=\"279,5 294,35 328,40 303,62 309,94 279,79 258,94 254,62 230,39 263,35\"/&gt; &lt;line fill=\"none\" stroke=\"black\" x1=\"410\" y1=\"95\" x2=\"440\" y2=\"6\"/&gt; &lt;line fill=\"none\" stroke=\"black\" x1=\"360\" y1=\"6\" x2=\"360\" y2=\"95\"/&gt;&lt;/svg&gt; 大家看 svg 标签中带有一个 viewBox 的属性。这其实是 SVG 中一个很重要的概念，后面的缩放都会与它有关。说到这里，我们就需要了解一下关于 SVG 的几个基本概念。 基本概念简单来说有 3 个基本概念： viewport: 物理窗口 viewbox: 实物窗口（算了，下面解释） preserveAspectRatio: 保留横纵比 我们接下来，一个一个的进行讲解吧。 viewport参照上面的 demo，这实际上就是你用 x,y,width,height。这 4 个属性，在页面上固定的矩形区域。 viewbox定义 SVG 元素在 viewport 中的具体尺寸比例。假设有如下内容：123&lt;svg width=\"500\" height=\"200\" viewBox=\"0 0 50 20\" &gt; &lt;rect x=\"20\" y=\"10\" width=\"10\" height=\"5\" style=\"stroke: #000000; fill:none;\"/&gt;&lt;/svg&gt; viewport 为 [0,0] 到 [500,200] viewbox 为 [0,0] 到 [50,20] 默认情况下 SVG 是自动填充满 viewport 的。注意，在 SVG 中，子标签的所有尺寸都是不能带单位的，因为初始单位就是根据上面两个概念确定。当为以上情况，SVG 中基本的尺寸则不是 1px，而是 500/50 = 10px。所以，如下的图形大小为：1&lt;rect x=\"20\" y=\"10\" width=\"10\" height=\"5\" style=\"stroke: #000000; fill:none;\"/&gt; 也就是在 SVG 里面定义的 rect 图形，它的实际尺寸为 [200,100] 到 [100,50]。 preserveAspectRatio该属性就是用来定义上面 viewport 和 viewbox 相互对齐的方式。换句话就是说，它的属性可以改变 viewbox 的具体位置。基本格式为：1&lt;align&gt; [&lt;meetOrSlice&gt;] align: 定义 viewport 和 viewbox 的对齐方式，分为 x,y 轴两个方向。X 轴方向有三种方式：左边重合（xMin），x 轴中点重合（xMid），右边重合（xMax）。同理，Y 轴也有 顶边重合（YMin），y 轴中点重合（YMid），底边边重合（YMax） meetOrSlice: 主要就是定义该 SVG 是内嵌，还是裁剪或是 none（听天有命）。 其中，align 需要着重理解一下。首先，它的默认值为 xMidYMid，即为中点重合。可以从图中看出，viewbox 是通过中心进行延展的。注意，它的原点坐标还是在 viewbox 的左上角。如果你是动态增加尺寸的话，此时并不是从左到右增加，而是从中心向两端扩张。同理，如果你使用的是 xMinYMin 的话，那么如果存在尺寸变化，那么相对点则是从左上角开始的。简单来说，align 相对点其实一共有 9 个。然后就是 meet || slice || none 这三个属性具体干的事情。在这之前，我们需要了解一个公式–缩放比计算公式：1vb_h * rat_y = vp_h; 或者 vb_w * rat_x = vp_w; 其中，vb_ 为 viewbox 简写，vp_ 为 viewport 的简写。vb_h 代表就是 viewbox height。vb_w 代表就是 viewbox width。rat_x/y 代表的是 x,y 轴的缩放比例。假设有下列情况：123&lt;svg width=\"400\" height=\"200\" viewBox=\"0 0 200 200\" preserveAspectRatio=\"xMinYMin slice\" style=\"border:1px solid #cd0000;\"&gt; &lt;rect x=\"10\" y=\"10\" width=\"150\" height=\"150\" fill=\"#cd0000\"/&gt;&lt;/svg&gt; 那么，rat_x 和 rat_y 分别为： rat_x = 400/200 = 2 rat_y = 200/200 = 1 现在，针对上面 meet/slice 不同的取值，实际应用到 svg 里面的缩放比例是不同的。 meet(默认值): 本意是让 svg 尽可能的显示在 viewport 里，即，会在 rat_x 和 rat_y 中选择最小的值作为缩放标准。 slice: 本意是让 svg 完全铺满 viewport，即，会在 rat_x 和 rat_y 中选择最大的值作为缩放标准。 所以针对不同的取值，基准比例也不同。当为 meet 的情况，那么实际缩放比例为 1。则里面实际矩形的大小就为 (10,10) 到 (150,150)。当为 slice 的情况，那么实际缩放比例为 2。则里面实际矩形的大小就为 (20,20) 到 (300,300)。如果你的值为 none 的话，他会直接铺满整个 viewport，即，实际矩形大小为：(20,10) 到 (300,150)。 响应式 SVG虽然讲起响应式，一些童鞋会想这 TM 又是啥奇技淫巧？对不起，并不是。。。就是一个 viewbox 并且不带 width/height 而已。看个实际的例子吧：123456789&lt;svg viewBox=\"0 0 218.8 87.1\"&gt; &lt;g fill=\"none\" stroke=\"#000\"&gt; &lt;path d=\"M7.3 75L25.9 6.8s58.4-6.4 33.5 13-41.1 32.8-11.2 30.8h15.9v5.5s42.6 18.8 0 20.6\" /&gt; &lt;path d=\"M133.1 58.2s12.7-69.2 24.4-47.5c0 0 4.1 8.6 9.5.9 0 0 5-10 10.4.9 0 0 12.2 32.6 13.6 43 0 0 39.8 5.4 15.8 15.4-13.2 5.5-53.8 13.1-77.4 5.9.1 0-51.9-15.4 3.7-18.6z\" /&gt; &lt;/g&gt; &lt;/svg&gt; 可以看到，上面的 svg 标签并没有带上啥 width/height 属性，只是简单描述了 viewBox 的范围而已。当然，里面的尺寸标准都是在这 viewBox 的范围内进行设置的。另外，在这里声明一下，本文章并不是新手教程，也就是说，不会教你一步一步的画直线啊，圆啊，矩形啊等等这些基本图形。这些直接 google 一下，一搜一大把。所以，这里假设大家的水平是处于，能对 SVG 基本的图形属性熟悉即可，对一些高级属性还不是很清楚和熟练。OK，继续~在 SVG 中，能够直接使用的图形有: rect circle ellipse line polyline polygon 上面没有啥说的，后面我详细说一下两个比较重要的概念，分组和 Path。 分组和 Path通常 Path 和 分组通常是一起使用的，如上：1234567&lt;g fill=\"none\" stroke=\"#000\"&gt; &lt;path d=\"M7.3 75L25.9 6.8s58.4-6.4 33.5 13-41.1 32.8-11.2 30.8h15.9v5.5s42.6 18.8 0 20.6\" /&gt; &lt;path d=\"M133.1 58.2s12.7-69.2 24.4-47.5c0 0 4.1 8.6 9.5.9 0 0 5-10 10.4.9 0 0 12.2 32.6 13.6 43 0 0 39.8 5.4 15.8 15.4-13.2 5.5-53.8 13.1-77.4 5.9.1 0-51.9-15.4 3.7-18.6z\" /&gt;&lt;/g&gt; 分组我们放到后面进行讲解，这里先看一下 Path。 PathPath 在 SVG 中的地位应该是比较高的，实际上，利用 Path 这个一个标签可以画出任意的图形。path 中 d(data) 属性是用来定义相关线条数据，通常是以 M/m 为起始，代表的就是 move to 的意思。在 path 中，一共可以定义 10 种不同的图形。例如 M/m，L/l。 大家可以注意，每种标识符有两种书写方式，即，大小写。 大写: 参照的是绝对坐标，即，SVG 的右上角 小写: 参照的相对坐标，即，前一个点的坐标。 而在 10 中不同表示符中，又可以分为直线和曲线两种不同的标识符。这里，我们分类来讲解一下。 线型M/m该使用定义起始点的，没啥特殊的作用。1&lt;path d=\"M10 10\"/&gt; 表示，以 (10,10) 为起始点。 L/l原意是 Line to，用来画线段的。格式和 M/m 差不多：1L x y (or l dx dy) H/h用来画水平线，即，Horizontal。既然方向已经定了，剩下的就是距离，格式很简单：1H x (or h dx) V/v用来画竖直线，即，vertical。同上，方向也定了，格式为：1V y (or v dy) 看个例子吧：1&lt;path d=&quot;M10 10 H 90 V 90 H 10 L 10 10&quot;/&gt; 该 path 实际上就是画了一个正方形，宽 = 高 = 90。 Z/z该标识符用来表示 path 的结束，并且将最后一点和 M/m 标识开头的一点连接起来。所以，它不存在什么表示点之类的，格式为：1Z (or z) 而上面也可以进行相关的优化，最终的结果为：123&lt;path d=\"M10 10 H 90 V 90 H 10 L 10 10\"/&gt;// 使用 Z&lt;path d=\"M10 10 H 90 V 90 H 10 Z\" fill=\"transparent\" stroke=\"black\"/&gt; 曲线曲线就是 Web 画图中常见的 Bezier Curves（贝塞尔），Arcs，several Bezier curves（很多贝塞尔 - .-）等。我们简单看一下： C/c这是正统的贝塞尔曲线，需要 4 个参考点，下图应该说比较确切表示了二次贝塞尔所需要的点。所以，C/c 需要定义三个点。基本格式为：1C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy) 例如：1&lt;path d=\"M10 10 C 20 20, 40 20, 50 10\" stroke=\"black\" fill=\"transparent\"/&gt; S/s该标识符实际上使用来表示一个反射贝塞尔，即，在原有贝塞尔上再加一段贝塞尔曲线，所以，S/s 一般和 C/c 一起使用。基本格式为：1S x2 y2, x y (or s dx2 dy2, dx dy) 实际样式图为：相当于原有的贝塞尔曲线的最后一段进行反向延长并对称。然后加上新定义的一段限制曲线。具体实例为：1&lt;path d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" stroke=\"black\" fill=\"transparent\"/&gt; Q/q该标识符是用来定义二次(quadratic)贝塞尔曲线，该曲线相当于上面传统的贝塞尔来说，更加简单，它只需要定义三个点，即可完整一个贝塞尔曲线，具体作图过程如下：基本格式为：1Q x1 y1, x y (or q dx1 dy1, dx dy) 即为图上点， P1(x1,y1)，P2(x,y)起始点为 M 定义的点，例如：1&lt;path d=\"M10 80 Q 95 10 180 80\" stroke=\"black\" fill=\"transparent\"/&gt; T/t该标识符和 S 差不多，也是一个贝塞尔曲线的延长。相当于原曲线的控制点 P1 相当于 end point P2 做对称，然后，只需要定义一个终点即可，即，T/t 只需要定义贝塞尔曲线里面的终点即可：1T x y (or t dx dy) 如图：所以，简单来说，C/S，Q/T 是两两搭配一起使用的。在使用的时候，千万不要搞混即可。 弧线A/a该曲线是用来画弧线(Arcs)，而，弧线通常是圆/椭圆的一部分。当，椭圆的两个轴径长相等则为圆，所以，A/a 是按照椭圆作为基准格式：12A rx ry x-axis-rotation large-arc-flag sweep-flag x ya rx ry x-axis-rotation large-arc-flag sweep-flag dx dy 说实在的，这个比较复杂。因为，他画椭圆的方式和我们平常不一样，一般情况下，椭圆只要确定一个中心，然后是长短轴，然后是弧度范围即可。但是，它这里是通过椭圆上的两点来确定的，在加上旋转角度，俩轴径等因素来确定的。另外，需要注意，它的起始点是从上一个命令的结束点位置开始计算的。OK，我们首先简单了解一下格式里面的参数： rx,ry: 代表的就是长轴短轴，没得说。 x,y: 代表的是弧长的结束点。开始点就是上一个命令的终点。 x-axis-rotation: x 轴的旋转角度。顺时针为正 large-arc-flag[0,1]: 表示取大弧还是小弧。因为两点之间的弧长有两部分。 sweep-flag[0,1]: 取顺时针的弧，还是逆时针的弧长。参考点是以起始点开始的。 上面几个属性中，比较难理解的就是 large-arc-flag 和 sweep-flag。这么说吧，前面几个属性充其量只能确定椭圆的位置，和经过椭圆的两个点，不过，一般能通过指定两点的椭圆有两个，而通过这两点划分又会出现 4 段弧长。为了确定 4 个弧长中，是哪一个，需要两个值来确定。即，4 抽 2，2 抽 1。简单说一种，例如当，laf 和 sf 都为 0的情况。首先，laf 为 0 选择的是小弧长。所以，里面两段比较小的弧长被抽出来。然后，sf 为 0 选择的是逆时针。即，以起始点为参考，选择通过逆时针方向到达终点的那段弧。即，2 抽 1。最终得出我们需要的弧。说实在的，这个是真 TM 复杂。。。给一个参考codepen。一般情况下，我们并不需要手动来确定 path，有工具为啥不用工具呢！比如，Illustrator, Sketch 等，都可以自动生成 SVG。不过，生成之后，需要对代码做相关的压缩优化，这些都可以直接在编译器里面找到。你也可以用一下可视化工具SVGOMG来简单看一下。 分组SVG 中的分组你可以理解为 PS 中的图层，一块图层里面通常只会放一下高内聚的图形，这样既方便移动又方便做动画。SVG 中的分组标签就是 g，使用 g 标签包裹的所有子元素都认同为一组。例如：12345678 &lt;g&gt; &lt;circle cx=\"20\" cy=\"20\" r=\"20\" fill=\"green\" /&gt; &lt;circle cx=\"70\" cy=\"70\" r=\"20\" fill=\"purple\" /&gt;&lt;/g&gt;&lt;g&gt; &lt;rect x=\"110\" y=\"110\" height=\"30\" width=\"30\" fill=\"blue\" /&gt; &lt;rect x=\"160\" y=\"160\" height=\"30\" width=\"30\" fill=\"red\" /&gt;&lt;/g&gt; 需要注意的是，使用 g 进行分组，并不会改变原有元素的在屏幕上展示的效果。不过，g 标签除了分组，还有另外一个很重要的功能–动画 分组动画在分组重定义动画是直接写在 transform 属性当中的。实际上，每个子标签都可以使用 transform 的相关属性。123&lt;g transform=\"translate(...) scale(...) rotate(...) translate(...) rotate(...)\"&gt; ...&lt;/g&gt; 每种变换动画之间是通过 空格或逗号 连接的。它的执行顺序是从右到左。为啥呢？实际上可以理解为，这就是几个嵌套的 g 叠在一起。12345678910111213141516 &lt;g transform=\"translate(...) scale(...) rotate(...) translate(...) rotate(...)\"&gt; ... &lt;/g&gt; // Being Equivalent to this: &lt;g transform=\"translate(...)\"&gt; &lt;g transform=\"scale(...)\"&gt; &lt;g transform=\"rotate(...)\"&gt; &lt;g transform=\"translate(...)\"&gt; &lt;g transform=\"rotate(...)\"&gt; ... &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt;&lt;/g&gt; 具体可以使用的动画形式和 CSS 动画一模一样，详情可以参考: SVG动画 以上就是SVG的简单入门介绍，原文请点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"}]},{"title":"puppeteer爬取简书文章","slug":"puppeteer爬取简书文章","date":"2019-09-26T03:05:46.000Z","updated":"2024-01-11T07:00:59.229Z","comments":true,"path":"2019/09/26/puppeteer爬取简书文章/","link":"","permalink":"/2019/09/26/puppeteer爬取简书文章/","excerpt":"puppeteer爬取简书文章的小例子","text":"puppeteer爬取简书文章的小例子 puppeteer爬取简书文章puppeteer这个工具库我已经了解有些时候了，自己在之前的文章中也有简单的介绍，也列出了几个学习站点，不过，第一个爬虫的例子，还是缓缓的到来了。这个小例子很简单，只有几十行代码，大概的流程是，首先打开简书的首页，之后下拉到底部，加载数据，下拉几次之后就没有了下拉加载的功能，取而代之的是“阅读更多”按钮，点击后会加载新内容。就这样往复的加载文章的列表，当符合自己设定的上限值后，停止加载，拿到了文章列表后循环的打开相对应的页面，读取文章详细内容，并写到本地磁盘里。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const puppeteer = require('puppeteer');const fs = require('fs');// 简书网址const baseUrl = 'https://www.jianshu.com'; (async () =&gt; &#123; const browser = await puppeteer.launch(&#123; headless:false, slowMo:250, defaultViewport: &#123; width: 1200, height: 600 &#125; &#125;); const page = await browser.newPage(); // page.setDefaultNavigationTimeout(timeout); await page.goto(baseUrl); // await page.waitFor(1000); // 获取简书首页中的列表数据 const hrefList = await page.evaluate((baseUrl) =&gt; &#123; let arr = [], list; return new Promise((resolve, reject)=&gt; &#123; function loadPage() &#123; var btn = document.querySelector('.load-more'); if(btn) &#123; btn.click(); &#125;else &#123; var pageHeight = document.querySelector('#list-container').offsetHeight; for(let i=0; i&lt;pageHeight; i++) &#123; document.documentElement.scrollTo(0, i); &#125; &#125; setTimeout(() =&gt; &#123; list = document.querySelectorAll('#list-container .note-list li'); if(list.length &lt; 50) &#123; loadPage(); &#125;else &#123; for(let item of list) &#123; let href = item.querySelector('a').getAttribute('href'); arr.push(baseUrl + href); &#125; resolve(arr); &#125; &#125;, 2000); &#125; loadPage(); &#125;); &#125;, baseUrl); // 通过hrefList来获取单个的文章内容，并写入文章文件 for(let item of hrefList) &#123; try &#123; await page.goto(item); &#125; catch(err) &#123; continue; &#125; await page.waitFor(5000); var article = await page.evaluate(() =&gt; &#123; var mainText; try &#123; mainText = document.querySelector('._gp-ck').innerHTML; &#125; catch(err) &#123; mainText = '此页面有问题。'; &#125; return mainText; &#125;); fs.writeFileSync('./download-articles/'+item.replace(/\\/|\\:|\\./g, '')+'.txt', article, &#123; flag: 'a' &#125;); &#125; // 关闭浏览器 await browser.close();&#125;)(); 以后还会更新些更复杂的爬虫案例哦。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"/tags/爬虫/"}]},{"title":"文本文件和二进制文件的差异和区别","slug":"文本文件和二进制文件的差异和区别","date":"2019-09-24T01:46:35.000Z","updated":"2024-01-11T07:00:59.272Z","comments":true,"path":"2019/09/24/文本文件和二进制文件的差异和区别/","link":"","permalink":"/2019/09/24/文本文件和二进制文件的差异和区别/","excerpt":"文本文件和二进制文件的差异和区别","text":"文本文件和二进制文件的差异和区别 文本文件和二进制文件的差异和区别一：广义上的二进制文件包括文本文件，这里讨论的是狭义上的二进制文件与文本文件的比较： 1.能存储的数据类型不同文本文件只能存储char型字符变量。二进制文件可以存储char/int/short/long/float/……各种变量值。 2.每条数据的长度文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。二进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节…… 3.读取的软件不同文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器…… 4.操作系统对换行符(‘\\n’)的处理不同（不重要）文本文件，操作系统会对’\\n’进行一些隐式变换，因此文本文件直接跨平台使用会出问题。在Windows下，写入’\\n’时，操作系统会隐式的将’\\n’转换为”\\r\\n”，再写入到文件中；读的时候，会把“\\r\\n”隐式转化为’\\n’，再读到变量中。在Linux下，写入’\\n’时，操作系统不做隐式变换。二进制文件，操作系统不会对’\\n’进行隐式变换，很多二进制文件（如电影、图片等）可以跨平台使用。 从存储方式来说，文件在磁盘上的存储方式都是二进制形式，所以，文本文件其实也应该算二进制文件。先从他们的区别来说，虽然都是二进制文件，但是二进制代表的意思不一样。打个比方，一个人，我们可以叫他的大名，可以叫他的小名，但其实都是代表这个人。二进制读写是将内存里面的数据直接读写入文本中，而文本呢，则是将数据先转换成了字符串，再写入到文本中。要弄明白二者的区别，需要知道文件的读写过程。以读文件为例， 实际上是磁盘 》》 文件缓冲区》》应用程序内存空间这两个转化过程。我们说“文本文件和二进制文件没有区别”，实际上针对的是第一个过程；既然没有区别，那么打开方式不同，为何显示内容就不同呢？这个区别实际上是第二个过程造成的。 文件实际上包括两部分，控制信息和内容信息。纯文本文件仅仅是没有控制格式信息罢了； 实际上也是一种特殊的二进制文件。所以，我们很难区分二者的不同，因为他们的概念上不是完全互斥的。我们说文本文件是特殊的二进制文件，是因为文本文件实际上的解释格式已经确定了：ASCII或者unicode编码。文本文件的一个缺点是，它的熵往往较低，也就是说，其实本可以用更小的存储空间记录这些信息。比如，文本文件中的一个数字65536，需要用5个字节来存储；但是用二进制格式，采用int存储，仅仅需要2个字节。而二进制文件elf和bmp等，都往往有一个head，告诉你文件信息和解释方式。 记事本支持文本文件而不支持二进制文件，所以如果你用记事本打开文本文件那么一切正常，如果打开的是二进制文件就会出现乱码。但也有不乱码的地方，你会注意到那些地方都是字符编码的，而对于int、double等类型所对应的值都是乱码的，这是由于记事本只能够识别字符类型，而无法识别其他类型。 1.二进制文件是把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放，也就是说存放的是数据的原形式。 2.文本文件是把数据的终端形式的二进制数据输出到磁盘上存放，也就是说存放的是数据的终端形式。 字符数据本身在内存中就经过了编码，所以无论是二进制还是文本形式都是一样的，而对于非字符数据来说，例如inti=10；如果用二进制来进行存储的话为1010，但是如果需要用文本形式来进行存储的话就必须进行格式化编码（对1和0分别编码，即形式为‘1’和‘0’分别对应的码值）。 二：1.文本文件与二进制文件的定义大家都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（这样一个过程，可以看作是自定义编码。 从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。 2.文本文件与二进制文件的存取文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。一般来说，你选取的解码方式会是ASCII码形式（ASCII码的一个字符是8个比特），接下来，它8个比特8个比特地来解释这个文件流。例如对于这么一个文件流”01000000_01000001_01000010_01000011”(下划线”_”，为了增强可读性手动添加的)，第一个8比特”01000000”按ASCII码来解码的话，所对应的字符是字符”A”，同理其它3个8比特可分别解码为”BCD”，即这个文件流可解释成“ABCD”，然后记事本就将这个“ABCD”显示在屏幕上。 事实上，世界上任何东西要与其他东西通信会话，都存在一个既定的协议，既定的编码。人与人之间通过文字联络，汉字“妈”代表生你的那个人，这就是一种既定的编码。但注意到这样一种情况，汉字“妈”在日本文字里有可能是你生下的那个人，所以当一个中国人A与日本B之间用“妈”这个字进行交流，出现误解就很正常的。用记事本打开二进制文件与上面的情况类似。记事本无论打开什么文件都按既定的字符编码工作（如ASCII码），所以当他打开二进制文件时，出现乱码也是很必然的一件事情了，解码和译码不对应嘛。例如文件流”00000000_00000000_00000000_00000001”可能在二进制文件中对应的是一个四字节的整数int 1，在记事本里解释就变成了”NULL_NULL_NULL_SOH”这四个控制符。 文本文件的存储与其读取基本上是个逆过程。而二进制文件的存取显然与文本文件的存取差不多，只是编／解码方式不同而已。 3.文本文件与二进制文件的优缺点因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点，这个找本编码的书来看看就比较清楚了。一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。 在windows下,文本文件不一定是一ASCII来存贮的,因为ASCII码只能表示128的标识,你打开一个txt文档,然后另存为,有个选项是编码,可以选择存贮格式,一般来说UTF-8编码格式兼容性要好一些.而二进制用的计算机原始语言,不存贮兼容性. 很多书上还认为，文本文件的可读性要好些，存储要花费转换时间(读写要编译码)，而二进制文件可读性差，存储不存在转换时间（读写不要编解码，直接写值）．这里的可读性是从软件使用者角度来说的，因为我们用通用的记事本工具就几乎可以浏览所有文本文件，所以说文本文件可读性好；而读写一个具体的二进制文件需要一个具体的文件解码器，所以说二进制文件可读性差，比如读BMP文件，必须用读图软件。 而这里的存储转换时间应该是从编程的角度来说的，因为有些操作系统如windows需要对回车换行符进行转换(将”\\n”，换成”\\r\\n”，所以文件读写时，操作系统需要一个一个字符的检查当前字符是不是”\\n”或”\\r\\n”).这个在存储转换在Linux操作系统中并不需要，当然，当在两个不同的操作系统上共享文件时，这种存储转换又可能出来。 三：文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。 特别的是，文本文件是指以ASCII码方式(也称文本方式)存储的文件，更确切地说，英文、数字等字符存储的是ASCII码，而汉字存储的是机内码。文本文件中除了存储文件有效字符信息（包括能用ASCII码字符表示的回车、换行等信息）外，不能存储其他任何信息。 文本文件是一种由若干行字符构成的计算机文件。文本文件存在于计算机文件系统中。通常，通过在文本文件最后一行后放置文件结束标志来指明文件的结束。文本文件是指一种容器，而纯文本是指一种内容。文本文件可以包含纯文本。一般来说，计算机文件可以分为两类：文本文件和二进制文件。 只含有ASCII字符的文本文件可以在Unix、Macintosh、Microsoft Windows、DOS和其它操作系统之间自由交互，而其它格式的文件是很难做到这一点的。但是，在这些操作系统中，换行符并不相同，处理非ASCII字符的方式也不一致。 .txt是包含极少格式信息的文字文件的扩展名。.txt格式并没有明确的定义，它通常是指那些能够被系统终端或者简单的文本编辑器接受的格式。任何能读取文字的程序都能读取带有.txt扩展名的文件，因此，通常认为这种文件是通用的、跨平台的。 在英文文本文件中，ASCII字符集是最为常见的格式，而且在许多场合，它也是默认的格式。对于带重音符号的和其它的非ASCII字符，必须选择一种字符编码。在很多系统中，字符编码是由计算机的区域设置决定的。常见的字符编码包括支持许多欧洲语言的ISO 8859-1。 由于许多编码只能表达有限的字符，通常它们只能用于表达几种语言。Unicode制定了一种试图能够表达所有已知语言的标准，Unicode字符集非常大，它囊括了大多数已知的字符集。Unicode有多种字符编码，其中最常见的是UTF-8，这种编码能够向后兼容ASCII，相同内容的的ASCII文本文件和UTF-8文本文件完全一致。 微软的MS-DOS和Windows采用了相同的文本文件格式，它们都使用CR和LF两个字符作为换行符，这两个字符对应的ASCII码分别为13和10。通常，最后一行文本并不以换行符(CR-LF标志)结尾，包括记事本在内的很多文本编辑器也不在文件的最后添加换行符。 大多数Windows文本文件使用ANSI、OEM或者Unicode编码。Windows所指的ANSI编码通常是1字节的ISO-8859编码，不过对于像中文、日文、朝鲜文这样的环境，需要使用2字节字符集。在过渡至Unicode前，Windows一直用ANSI作为系统默认的编码。而OEM编码，也是通常所说的MS-DOS代码页，是IBM为早期IBM个人电脑的文本模式显示系统定义的。在全屏的MS-DOS程序中同时使用了图形的和按行绘制的字符。新版本的Windows可以使用UTF-16LE和UTF-8之类的Unicode编码。 由于结构简单，文本文件被广泛用于记录信息。它能够避免其它文件格式遇到的一些问题。此外，当文本文件中的部分信息出现错误时，往往能够比较容易的从错误中恢复出来，并继续处理其余的内容。文本文件的一个缺点是，它的熵往往较低，也就是说，可以用较小的存储空间记录这些信息。 文本文件基本上是定长编码的(也有非定长的编码如UTF-8)，基于字符，每个字符在具体编码中是固定的，ASCII码是8个比特的编码，UNICODE一般占16个比特。而二进制文件可看成是变长编码的，因为是值编码，多少个比特代表一个值，完全由自己决定。 广义的二进制文件即指文件，由文件在外部设备的存放形式为二进制而得名。狭义的二进制文件即除文本文件以外的文件。 每个字符由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件。文本文件只是二进制文件中的一种特例，为了与文本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件。 为什么要使用二进制文件。原因大概有三个： 第一是二进制文件比较节约空间，这两者储存字符型数据时并没有差别。但是在储存数字，特别是实型数字时，二进制更节省空间；第二个原因是，内存中参加计算的数据都是用二进制无格式储存起来的，因此，使用二进制储存到文件就更快捷。如果储存为文本文件，则需要一个转换的过程。在数据量很大的时候，两者就会有明显的速度差别了。第三，就是一些比较精确的数据，使用二进制储存不会造成有效位的丢失。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"WebGL是啥？","slug":"WebGL是啥？","date":"2019-09-23T01:48:45.000Z","updated":"2024-01-11T07:00:59.176Z","comments":true,"path":"2019/09/23/WebGL是啥？/","link":"","permalink":"/2019/09/23/WebGL是啥？/","excerpt":"简单的介绍一下WebGL是什么","text":"简单的介绍一下WebGL是什么 WebGL是啥？为了让大家快速认识WebGL，先不讲解具体的知识点，我相信很多程序员希望通过一个麻雀虽小，但是五脏俱全的demo来认识一个新的技术领域。所以这里通过一个简单的案例来给大家展示WebGL技术，下面的代码完成的效果就是在canvas画布上绘制一个点。 使用WebGL绘制一个点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;使用WebGL绘制一个点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--canvas标签创建一个宽高均为500像素，背景为蓝色的矩形画布--&gt;&lt;canvas id=\"webgl\" width=\"500\" height=\"500\" style=\"background-color: blue\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;!-- 顶点着色器源码 --&gt;&lt;script id=\"vertexShader\" type=\"x-shader/x-vertex\"&gt; void main() &#123; //给内置变量gl_PointSize赋值像素大小 gl_PointSize=20.0; //顶点位置，位于坐标原点 gl_Position =vec4(0.0,0.0,0.0,1.0); &#125;&lt;/script&gt;&lt;!-- 片元着色器源码 --&gt;&lt;script id=\"fragmentShader\" type=\"x-shader/x-fragment\"&gt; void main() &#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125;&lt;/script&gt;&lt;script&gt; //通过getElementById()方法获取canvas画布 var canvas=document.getElementById('webgl'); //通过方法getContext()获取WebGL上下文 var gl=canvas.getContext('webgl'); //顶点着色器源码 var vertexShaderSource = document.getElementById( 'vertexShader' ).innerText; //片元着色器源码 var fragShaderSource = document.getElementById( 'fragmentShader' ).innerText; //初始化着色器 var program = initShader(gl,vertexShaderSource,fragShaderSource); //开始绘制，显示器显示结果 gl.drawArrays(gl.POINTS,0,1); //声明初始化着色器函数 function initShader(gl,vertexShaderSource,fragmentShaderSource)&#123; //创建顶点着色器对象 var vertexShader = gl.createShader(gl.VERTEX_SHADER); //创建片元着色器对象 var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //引入顶点、片元着色器源代码 gl.shaderSource(vertexShader,vertexShaderSource); gl.shaderSource(fragmentShader,fragmentShaderSource); //编译顶点、片元着色器 gl.compileShader(vertexShader); gl.compileShader(fragmentShader); //创建程序对象program var program = gl.createProgram(); //附着顶点着色器和片元着色器到program gl.attachShader(program,vertexShader); gl.attachShader(program,fragmentShader); //链接program gl.linkProgram(program); //使用program gl.useProgram(program); //返回程序program对象 return program; &#125;&lt;/script&gt;&lt;/html&gt; 代码结构整个代码是一个.html文件，里面包含JavaScript代码和着色器语言代码，通过JavaScript调用WebGL API来完成绘制操作。 HMTL和JavaScript如果原来接触的是OpenGL，不了解WebGL，对浏览器的生态环境不了解，不了解前端知识，那么在学习WebGL之前，你应该先了解一下什么是HTML，什么是JavaScript语言。 canvascanvas和div一样也是HTML的一个元素，只不过通过这个元素可实现三维场景的回执和渲染。通过canvas对象的getContext方法可以返回一个2D或3D环境 canvas元素12&lt;!--canvas标签创建一个宽高均为500像素，背景为蓝色的矩形画布--&gt;&lt;canvas id=\"webgl\" width=\"500\" height=\"500\" style=\"background-color: blue\"&gt;&lt;/canvas&gt; 返回3D绘图环境通过返回的gl对象可以调用WebGL API，所有的WebGL API就是gl对象的方法。比如gl.linkProgram()1234//通过getElementById()方法获取canvas画布var canvas=document.getElementById('webgl');//通过方法getContext()获取WebGL上下文var gl=canvas.getContext('webgl'); 返回2D环境返回2D环境，就是大家平常说的canvas，通过canvas对象可以返回webgl绘图环境，也可以返回2D绘环境，不过大家在表达的时候，2D绘图环境通常表达为canvas，而canvas返回的3D环境，使用WebGL去表述。1var c=canvas.getContext('2d'); 着色器语言 GLSL顶点、片元着色器代码要通过着色器语言来编写，着色器语言在GPU中执行，而平时大家说的JavaScript、Python等语言都是在CPU中执行。在GPU中执行的着色器代码，需要先通过WebGL进行一定的处理然后传递到GPU才能执行，所以编写的着色器语言就是一段符合一定的规则的字符串。如果你现在还不能理解着色器语言的语法规则，也没有关系，作为初学者你现在只需要有一个印象，然后慢慢去学习。 顶点着色器内置变量gl_PointSize设置了顶点渲染后的显示大小，内置变量gl_Position决定了渲染的位置，你可以去修改位置变量的值，比如vec4(0.0,0.0,0.0,1.0)变成vec4(0.5,0.0,0.0,1.0)，你会发现渲染的点位置发生了变化。123456789&lt;!-- 顶点着色器源码 --&gt;&lt;script id=\"vertexShader\" type=\"x-shader/x-vertex\"&gt; void main() &#123; //给内置变量gl_PointSize赋值像素大小 gl_PointSize=20.0; //顶点位置，位于坐标原点 gl_Position =vec4(0.0,0.0,0.0,1.0); &#125;&lt;/script&gt; 片元着色器内置变量gl_FragColor设置渲染结果的颜色值，vec4(1.0,0.0,0.0,1.0)表示红色，如果改成vec4(0.0,1.0,0.0,1.0)，你会发现渲染结果是绿色，vec4的四个分量分别表示RGBA。1234567&lt;!-- 片元着色器源码 --&gt;&lt;script id=\"fragmentShader\" type=\"x-shader/x-fragment\"&gt; void main() &#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125; &lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"iscroll移动端卡顿解决办法","slug":"iscroll移动端卡顿解决办法","date":"2019-09-19T05:36:02.000Z","updated":"2024-01-11T07:00:59.193Z","comments":true,"path":"2019/09/19/iscroll移动端卡顿解决办法/","link":"","permalink":"/2019/09/19/iscroll移动端卡顿解决办法/","excerpt":"解决iscroll在移动端卡顿","text":"解决iscroll在移动端卡顿 iscroll移动端卡顿解决办法iscroll是模拟区域滚动的一个库，很有名的，类似的还有一个库叫better-scroll，作者是中国人，好像是阿里的吧，是在iscroll的基础上开发的，很灵活，支持es6等语法导入，不过本篇博文不做介绍，我们来讨论iscroll。有一个需求是页面拒不缩放并且可以滚动，正好用到了iscroll-zoom.js,但是引入后发现在pc端嗷嗷流畅，但是移动端就卡顿，后来在网上查到解决办法，但是感觉并不是好的解决办法，应该还有更好的，暂时贴出现在的解决办法，以后在陆续跟进。 解决方法一1.123&lt;style type=\"text/css\"&gt; * &#123; touch-action: pan-y; &#125;&lt;/style&gt; 2.123456&lt;script&gt; window.PointerEvent = undefined; document.addEventListener('touchmove', function (e) &#123; e.preventDefault(); &#125;, false);&lt;/script&gt; 3.1234567891011&lt;script&gt; tabContentScroll = new IScroll(\"#tabContentWrapper\", &#123; tap: true, probeType: 2, deceleration: 0.001, vScrollbar: false &#125;); // 初始化IScroll的时候，加上vScrollbar: false，最关键这句，不加这句，完成其他几点只可以改好Chorme的问题，安卓的问题解决不了！！！&lt;/script&gt; 4.我觉得是最主要的，比如iscroll-zoom.js文件，我是用的是v5.2.0版本，大约在290行1234567 disablePointer : !utils.hasPointer,disableTouch : utils.hasPointer || !utils.hasTouch, disableMouse : utils.hasPointer || utils.hasTouch, // 修改成 disablePointer : true,disableTouch : false,disableMouse : true, 官网issus的解释这个是在网络上找到的参考答案连接 解决方法二既然v5.2.0有bug，那我们不用这个版本的，可以用以前的老版本啊。1npm info iscroll 可以查看历史版本等信息，我下载了v5.0.8这个版本，经过测试可用了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"Puppeteer","slug":"Puppeteer","date":"2019-09-10T06:50:51.000Z","updated":"2024-01-11T07:00:59.146Z","comments":true,"path":"2019/09/10/Puppeteer/","link":"","permalink":"/2019/09/10/Puppeteer/","excerpt":"Puppeteer工具","text":"Puppeteer工具 PuppeteerPuppeteer是谷歌官方出品的一个通过DevTools协议控制headless Chrome的Node库。可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。这里不做太多的介绍，贴出官方网址链接自行查看 npm-puppeteer findbestopensource Puppeteer 中文文档","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"JS中的offset、scroll、client","slug":"JS中的offset、scroll、client","date":"2019-09-09T07:44:40.000Z","updated":"2024-01-11T07:00:59.127Z","comments":true,"path":"2019/09/09/JS中的offset、scroll、client/","link":"","permalink":"/2019/09/09/JS中的offset、scroll、client/","excerpt":"JS中的offset、scroll、client简单整理","text":"JS中的offset、scroll、client简单整理 JS中的offset、scroll、client在下开发中经常碰到 offset、scroll、client 这几个关键字，比如 offsetLeft、offsetHeight、scrollHeight、clientTop 什么的，每次都要各种实验，这里总结一下，一劳永逸。来两张图先： 1. offsetoffset 指偏移，包括这个元素在文档中占用的所有显示宽度，包括滚动条、 padding、 border，不包括 overflow隐藏的部分。 offsetParent属性返回一个对象的引用，这个对象是距离调用 offsetParent的父级元素中最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。如果这个容器元素未进行CSS定位, 则 offsetParent属性的取值为根元素的引用。如果当前元素的父级元素中没有进行CSS定位（position为 absolute/relative）， offsetParent 为 body如果当前元素的父级元素中有CSS定位（ position 为 absolute/relative）， offsetParent 取父级中最近的元素 obj.offsetWidth 指 obj 控件自身的绝对宽度，不包括因 overflow 而未显示的部分，也就是其实际占据的宽度，整型，单位：像素。offsetWidth = border-width*2+ padding-left+ width+ padding-right obj.offsetHeight 指 obj 控件自身的绝对高度，不包括因 overflow 而未显示的部分，也就是其实际占据的高度，整型，单位：像素。offsetHeight = border-width*2+ padding-top+ height+ padding-bottom obj.offsetTop 指 obj 相对于版面或由 offsetParent 属性指定的父坐标的计算上侧位置，整型，单位：像素。offsetTop= offsetParent的padding-top + 中间元素的offsetHeight + 当前元素的margin-top obj.offsetLeft 指 obj 相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置，整型，单位：像素。offsetLeft= offsetParent的padding-left + 中间元素的offsetWidth + 当前元素的margin-left 2. scrollscroll指滚动，包括这个元素没显示出来的实际宽度，包括 padding，不包括滚动条、 border scrollHeight 获取对象的滚动高度，对象的实际高度； scrollLeft 设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 scrollTop 设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 scrollWidth 获取对象的滚动宽度 3. clientclient指元素本身的可视内容，不包括 overflow被折叠起来的部分，不包括滚动条、 border，包括 padding clientWidth 对象可见的宽度，不包括滚动条等边线，会随窗口的显示大小改变 clientHeight 对象可见的高度 clientTop、clientLeft 这两个返回的是元素周围边框的厚度，一般它的值就是0。因为滚动条不会出现在顶部或者左侧 最后，奉上一个demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #parent &#123; position: relative; margin: 20px auto; width: 300px; height: 400px; border: 1px solid blue; overflow: auto; &#125; #child &#123; width: 500px; height: 600px; margin: 10px; padding: 5px; background-color: blanchedalmond; box-sizing: border-box; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var nParent = document.querySelector('#parent'), nChild = document.querySelector('#child'); document.addEventListener('click', function() &#123; // offset偏移 console.log('父元素-&gt;', nChild.offsetParent); console.log('offsetWidth-&gt;', nChild.offsetWidth); console.log('offsetHeight-&gt;', nChild.offsetHeight); console.log('offsetTop-&gt;', nChild.offsetTop); console.log('offsetLeft-&gt;', nChild.offsetLeft); console.log('&lt;-------------------------&gt;'); // scroll滚动 console.log('scrollHeight-&gt;', nParent.scrollHeight); console.log('scrollLeft-&gt;', nParent.scrollLeft); console.log('scrollTop-&gt;', nParent.scrollTop); console.log('scrollWidth-&gt;', nParent.scrollWidth); console.log('&lt;-------------------------&gt;'); // client console.log('clientWidth-&gt;', nChild.clientWidth); console.log('clientHeight-&gt;', nChild.clientHeight); console.log('clientTop-&gt;', nChild.clientTop); console.log('clientLeft-&gt;', nChild.clientLeft); &#125;, false);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"一个页面loading小插件2","slug":"一个页面loading小插件2","date":"2019-09-04T06:53:02.000Z","updated":"2024-01-11T07:00:59.241Z","comments":true,"path":"2019/09/04/一个页面loading小插件2/","link":"","permalink":"/2019/09/04/一个页面loading小插件2/","excerpt":"有多种选择的loading插件","text":"有多种选择的loading插件 一个页面loading小插件2前些天写了一个loading的插件，点击查看,今天又写了一个，优点是可以进行loading样式的选择，有12种样式。先贴出loading插件代码:123456789101112131415161718192021222324252627282930313233343536373839/** * @description 移动端的loading效果小插件，内置了12种loading效果 * @description 使用demo：var mask = new JLoading(); * mask.init('loader-03'); * mask.show(); 显示 * mask.hide(); 隐藏 */function JLoading() &#123; this.loaderStr = 'loader-01,loader-02,loader-03,loader-04,loader-05,loader-06,loader-07,loader-08,loader-09,loader-10,loader-11,loader-12' this.type = '';&#125;JLoading.prototype.init = function(type) &#123; if(this.loaderStr.split(',').indexOf(type) &lt; 0) &#123; this.type = 'loader-01'; &#125; else &#123; this.type = type; &#125; this.loadIndex = this.type.slice(-2); var nBody = document.body, nHead = document.head; var nStyle = document.createElement('style'), nMask = document.createElement('div'), nLoader = document.createElement('div'); nMask.setAttribute('id', 'JLoading-mask-'+this.loadIndex); nLoader.setAttribute('class', this.type); nMask.appendChild(nLoader); nBody.appendChild(nMask); nStyle.innerHTML = `[id*=\"JLoading-mask\"]&#123;display:none;width:100%;height:100%;height:100vh;background-color:rgba(0,0,0,.8)&#125;[class*=\"loader-\"]&#123;position:absolute;display:inline-block;width:10%;padding-top:10%;color:#fff;vertical-align:middle;pointer-events:none;left:45%;top:45%&#125;.loader-01&#123;border:5px dotted currentcolor;border-radius:50%;-webkit-animation:1s loader-01 linear infinite;animation:1s loader-01 linear infinite&#125;@-webkit-keyframes loader-01&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-01&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-02&#123;border:5px solid transparent;border-left-color:currentcolor;border-right-color:currentcolor;border-radius:50%;-webkit-animation:1s loader-02 linear infinite;animation:1s loader-02 linear infinite&#125;@-webkit-keyframes loader-02&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-02&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-03&#123;border:2px solid currentcolor;border-bottom-color:transparent;border-radius:50%;-webkit-animation:1s loader-03 linear infinite;animation:1s loader-03 linear infinite;position:relative&#125;@-webkit-keyframes loader-03&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-03&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-04&#123;border:1px solid currentcolor;border-radius:50%;-webkit-animation:1s loader-04 linear infinite;animation:1s loader-04 linear infinite;position:relative&#125;.loader-04:before&#123;content:'';display:block;width:0;height:0;position:absolute;top:-3px;left:50%;border:3px solid currentcolor;border-radius:50%&#125;@-webkit-keyframes loader-04&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-04&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-05&#123;border:5px solid transparent;border-top-color:currentcolor;border-radius:50%;-webkit-animation:1s loader-05 linear infinite;animation:1s loader-05 linear infinite;position:relative&#125;.loader-05:before&#123;content:'';display:block;width:inherit;height:inherit;position:absolute;top:-5px;left:-5px;border:5px solid currentcolor;border-radius:50%;opacity:.5;width:100%;padding-top:100%&#125;@-webkit-keyframes loader-05&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-05&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-06&#123;border:5px solid currentcolor;border-radius:50%;-webkit-animation:loader-06 1s ease-out infinite;animation:loader-06 1s ease-out infinite&#125;@-webkit-keyframes loader-06&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;@keyframes loader-06&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;.loader-07&#123;border:0 solid transparent;border-radius:50%;position:relative&#125;.loader-07:before,.loader-07:after&#123;content:'';border:5px solid currentcolor;border-radius:50%;width:inherit;height:inherit;position:absolute;top:0;left:0;-webkit-animation:loader-07 1s linear infinite;animation:loader-07 1s linear infinite;opacity:0;width:100%;height:100%&#125;.loader-07:before&#123;-webkit-animation-delay:1s;animation-delay:1s&#125;.loader-07:after&#123;-webkit-animation-delay:.5s;animation-delay:.5s&#125;@-webkit-keyframes loader-07&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;@keyframes loader-07&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;.loader-08&#123;position:relative&#125;.loader-08:before,.loader-08:after&#123;content:'';width:inherit;height:inherit;border-radius:50%;background-color:currentcolor;opacity:.6;position:absolute;top:0;left:0;-webkit-animation:loader-08 2.0s infinite ease-in-out;animation:loader-08 2.0s infinite ease-in-out;width:100%;height:100%&#125;.loader-08:after&#123;-webkit-animation-delay:-1.0s;animation-delay:-1.0s&#125;@-webkit-keyframes loader-08&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes loader-08&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125; &#125;.loader-09&#123;background-color:currentcolor;border-radius:50%;-webkit-animation:loader-09 1.0s infinite ease-in-out;animation:loader-09 1.0s infinite ease-in-out&#125;@-webkit-keyframes loader-09&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;@keyframes loader-09&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;.loader-10&#123;position:relative;-webkit-animation:loader-10-1 2.0s infinite linear;animation:loader-10-1 2.0s infinite linear&#125;.loader-10:before,.loader-10:after&#123;content:'';width:0!important;height:0!important;border:15px solid currentcolor;display:block;position:absolute;border-radius:100%;-webkit-animation:loader-10-2 2s infinite ease-in-out;animation:loader-10-2 2s infinite ease-in-out&#125;.loader-10:before&#123;top:0;left:50%&#125;.loader-10:after&#123;bottom:0;right:50%;-webkit-animation-delay:-1s;animation-delay:-1s&#125;@-webkit-keyframes loader-10-1&#123;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-10-1&#123;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@-webkit-keyframes loader-10-2&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes loader-10-2&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125;&#125;.loader-11&#123;background-color:currentcolor;-webkit-animation:loader-11 1.2s infinite ease-in-out;animation:loader-11 1.2s infinite ease-in-out&#125;@-webkit-keyframes loader-11&#123;0%&#123;-webkit-transform:perspective(120px) rotateX(0deg) rotateY(0deg);transform:perspective(120px) rotateX(0deg) rotateY(0deg)&#125;50%&#123;-webkit-transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg);transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg)&#125;100%&#123;-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg);transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)&#125;&#125;@keyframes loader-11&#123;0%&#123;-webkit-transform:perspective(120px) rotateX(0deg) rotateY(0deg);transform:perspective(120px) rotateX(0deg) rotateY(0deg)&#125;50%&#123;-webkit-transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg);transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg)&#125;100%&#123;-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg);transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)&#125;&#125;.loader-12&#123;position:relative&#125;.loader-12:before,.loader-12:after&#123;content:'';display:block;position:absolute;background-color:currentcolor;left:50%;right:0;top:0;bottom:50%;box-shadow:-.5em 0 0 currentcolor;-webkit-animation:loader-12 1s linear infinite;animation:loader-12 1s linear infinite&#125;.loader-12:after&#123;top:50%;bottom:0;-webkit-animation-delay:.25s;animation-delay:.25s&#125;@-webkit-keyframes loader-12&#123;0%,100%&#123;box-shadow:-20px 0 0 transparent;background-color:currentcolor&#125;50%&#123;box-shadow:-20px 0 0 currentcolor;background-color:transparent&#125;&#125;@keyframes loader-12&#123;0%,100%&#123;box-shadow:-20px 0 0 transparent;background-color:currentcolor&#125;50%&#123;box-shadow:-20px 0 0 currentcolor;background-color:transparent&#125;&#125;`; nHead.appendChild(nStyle); &#125;JLoading.prototype.show = function() &#123; var nMask = document.getElementById('JLoading-mask-'+this.loadIndex); nMask.style.display = 'block';&#125;JLoading.prototype.hide = function() &#123; var nMask = document.getElementById('JLoading-mask-'+this.loadIndex); nMask.style.display = 'none';&#125; 使用见下面代码:12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;&lt;loading-test&gt;&lt;/loading-test&gt;&lt;/title&gt; &lt;script src=\"./loading-plug.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var mask1 = new JLoading(); mask1.init('loader-12'); setTimeout(() =&gt; &#123; mask1.show(); &#125;, 1000); setTimeout(() =&gt; &#123; mask1.hide(); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用不同的样式，需要在mask1.init(‘loader-12’)方法中传入名字，比如’loader-02’,具体的样式名字见下图:","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"window下flutter环境搭建","slug":"window下flutter环境搭建","date":"2019-08-26T01:26:38.000Z","updated":"2025-05-29T07:59:22.298Z","comments":true,"path":"2019/08/26/window下flutter环境搭建/","link":"","permalink":"/2019/08/26/window下flutter环境搭建/","excerpt":"flutter在window 10下的环境搭建","text":"flutter在window 10下的环境搭建 window下flutter环境搭建flutter是google出的一个跨平台移动端app开发框架，据说性能已经超过了原生开发，作为一名前端，即使不深入研究，也得浅浅的看一下这是个什么东西吧，所以今天记录一下flutter在win10下的安装步骤。 1.安装flutter去flutter官网下载flutter的压缩包，flutter官网地址,将压缩包解压到一个目录下，之后配置一下环境变量（这里不细说了，就是把bin目录配到系统的环境变量下），之后开启终端，运行flutter，第一次运行flutter需要去网络拉取资源，所以电脑必须得安装好了git，再有一点，由于防火墙的原因，拉取国外资源有时候不成功，所以在运行flutter之前最好配一下资源镜像路径：12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 这两句话最好在git bash下执行哦，之后就可以运行flutter初始化了。 这里注意一下，最好选择flutter的最新版本安装，因为下一步会安装android sdk，android会自动下载最新版本的，所以为了兼容，我在有的电脑中安装的flutter不是最新版本，andriod是最新的，出现了无法run的问题。 2.安装JDK由于是android开发，所以java的sdk是必不可少的，去java sdk下载，注意，一定要下载java SE 8u***版本的，其他版本不兼容，下载之后安装即可。 3.安装vs code以及flutter插件。4.安装android studio下载链接,下载好之后，一路下一步就可以，第一次安装需要下载android sdk，会下载很长时间，不过虽然有墙的存在，但是依然可以安装成功,如果不成功就多试几次。安装好了sdk后，软件就会自动打开，来到首页，也就是新建项目的地方，这时候可以安装android studio的flutter插件，第一次打开安装插件面板的时候会一直loading，最开始我还以为是墙的原因呢，不要着急，慢慢的等待即可。安装好了flutter插件后重启ide，重启后新建一个flutter项目，建好之后我们创建android虚拟机，点击tools-&gt;avd manager,创建一个虚拟机。创建虚拟机需要安装android的系统，非常的慢，慢慢等待吧。 有的电脑安装模拟器的时候会报HAXM的安装不上错误，这是因为win10默认开启了Hyer-V微软的虚拟机，只需到服务里把它关掉即可。 5.以上完成之后，打开命令行，运行flutter doctor,会有一段12Android toolchain - develop for Android devices (Android SDK version 29.0.2) X Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses 的提示，直接运行flutter doctor –android-licenses，一路y就可以。 如果顺利的话，现在就可以运行你的flutter项目了，我在自己的电脑上安装的很顺利，但是在公司的电脑上安装的很是肯可啊。 还需要注意下，有的电脑会让你升级android sdk，命令行会提示你具体的路径，里边是一个.bat的文件，不用担心，.bat和.exe一样的，在cmd下一样可以在后边传参数。如果你运行的是powerShell，注意一下，执行命令需要这样./manager.bat。再有，升级可能会删除tools文件夹再下载，不过win10不允许程序随意删除文件，这时候需要手动删除一下（改个名字更好）。 总结以上就是我在搭建flutter环境的时候遇到的一些状况。 2025-05-29更新 使用flutter开发Web，所以不需要安装Android和Desktop的sdk。 1.flutter_windows_3.32.0-stable.zip 2.下载后解压到任意目录下，然后配置环境变量。3.使用git bash打开，运行flutter doctor，检查。4.创建项目1flutter create projectName 5.运行项目123456// 运行项目之前，配置一下flutter config --enable-web// 运行项目flutter run -d chrome // 自动打开cheome浏览器// 代码编辑后可以刷新浏览器在当前的命令行下输入r后回车即可。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"nw.js入门小结","slug":"nw-js入门小结","date":"2019-08-22T08:17:18.000Z","updated":"2024-01-11T07:00:59.227Z","comments":true,"path":"2019/08/22/nw-js入门小结/","link":"","permalink":"/2019/08/22/nw-js入门小结/","excerpt":"nw.js方便简单的pc端app开发工具","text":"nw.js方便简单的pc端app开发工具 nw.js入门小结nw.js和electron都是利用html来开发pc端应用的工具，今天我写一写nw.js的入门知识。 安装首先，去官网下载nw，官网地址,首页就可以看到下载地址，有两个下载，一个是normal,一个是sdk，见下图：sdk是有调试功能的，生成的应用，在上面点击右键可以看到类似浏览器F12的调试面板。normal就是没有调试功能的包，用于生产发布的时候用。下载后不需要安装，直接解压后就可以使用。 使用在nw的sdk包解压后的文件中，新建一个app文件夹，在app文件夹中放一个index.html的页面，再建一个package.json的文件，内容是：123456789101112131415161718192021222324252627282930&#123; \"fullscreen\": true, \"main\": \"index.html\", \"name\": \"layout\", \"description\": \"nw学习\", \"version\": \"0.1.0\", \"keywords\": [ \"指令学习\", \"在线\"], \"window\": &#123; \"title\": \"指令学习\", \"icon\": \"icon.png\", \"toolbar\": true, \"frame\": false, \"width\": 375, \"height\": 750, \"position\": \"center\", \"min_width\": 375, \"min_height\": 750, \"max_width\": 1920, \"max_height\": 1080, \"resizable\": true &#125;, \"webkit\": &#123; \"plugin\": false, \"java\": false, \"page-cache\": false &#125;, \"user-agent\": \"%name %ver %nwver %webkit_ver %osinfo\", \"chromium-args\": \"--allow-file-access-from-files\"&#125;// main属性是关键，指的是入口文件的位置 准备工作完毕，目录结构见下图：将app文件夹拖拽到nw.exe上即可打开应用进行开发调试。 打包发布如果开发完了之后，给别人用，就需要进行打包了。首先将app文件夹压缩，比如压缩成app.zip文件，之后改名为app.nw文件。打包需要在命令行下进行，打开cmd命令行（注意，这里只能用cmd，gitBash和powerShell都不好使哦），切换到当前目录，执行下面的命令:1copy /b nw.exe+app.nw app.exe 可以看到，app.exe就是打包出来的可执行文件，这时候直接点击它就可以运行程序了。 把这个app.exe文件复制到normal的运行文件夹下，也可以点击运行，这时其实就是一个绿色版的应用程序了，完全可以交付给客户使用了。 如果感觉一堆文件看起来不舒服，还可以使用enigmavirtualbox工具进行打包成一个.exe的文件，不过这个文件一般都比较大哦。 最后一种方法，innosetup工具，可以制作成安装版本，这样体积就小了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"前端静态资源服务器都用到了啥？","slug":"前端静态资源服务器都用到了啥？","date":"2019-08-22T06:45:46.000Z","updated":"2024-01-11T07:00:59.263Z","comments":true,"path":"2019/08/22/前端静态资源服务器都用到了啥？/","link":"","permalink":"/2019/08/22/前端静态资源服务器都用到了啥？/","excerpt":"前端都用到了哪些技术实现静态资源服务器","text":"前端都用到了哪些技术实现静态资源服务器 前端静态资源服务器都用到了啥？平时我们在开发的时候，肯定会自己架一个服务，把网页放进去，再跑，那么，我们平时都用到了哪些手段来实现呢？ http-server官网,使用起来很方便。 browser-sync官网,功能非常之强大。 nginx官网下载,nginx可是现在静态资源服务器中响应速度最快的了，如果在生产环境下，还是使用nginx吧。 apachenginx出来之前大家都用，现在基本上没人用了，淘汰掉。 webpack-dev这个其实是webpack的一个插件，我们在开发react，vue，angular的时候会用到它。 express&amp;koaexpress和koa中都有静态资源的中间件，用起来就是麻烦些。 nodejs最后就是可以利用nodejs的http模块手写一个静态资源服务器。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"移动端适配rem&scale","slug":"移动端适配rem&scale","date":"2019-08-18T05:16:50.000Z","updated":"2024-01-11T07:00:59.276Z","comments":true,"path":"2019/08/18/移动端适配rem&scale/","link":"","permalink":"/2019/08/18/移动端适配rem&scale/","excerpt":"移动端设置html元素的font-size代码，scale代码","text":"移动端设置html元素的font-size代码，scale代码 移动端适配rem&amp;scalerem方式123456789101112(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth/20 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); scale方式123456var curWidth = window.screen.width; //iphone 6plus为414pxvar targetWidth = 750; // 设计稿宽度var scale = curWidth/targetWidth;var meta = document.createElement(\"meta\");meta.name = \"viewport\";meta.content = 'initial-scale='+scale+',minimum-scale='+scale+',maximum-scale='+scale+''; // 注意，没有width=device-width scale方式就是把你按照设计稿宽度做的页面缩放到当前手机屏幕宽度。scale = 屏幕视口宽度/设计稿宽度(实际制作的页面宽度)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"一个页面loading小插件","slug":"一个页面loading小插件","date":"2019-08-18T04:44:28.000Z","updated":"2024-01-11T07:00:59.241Z","comments":true,"path":"2019/08/18/一个页面loading小插件/","link":"","permalink":"/2019/08/18/一个页面loading小插件/","excerpt":"移动端的loading小插件","text":"移动端的loading小插件 一个页面loading小插件这是一个移动端的loading蒙版，细节不说了，为了以后备用，直接上代码了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * @description 一个页面加载的loading小插件 * @description 注意，引用的时候一定要放到html文档的最后，因为需要向body插入内容，这里没有使用document的DOMContentLoaded，和window的loaded也是为了loading效果能够最快速的显示。 * @description 这里css用到了rem，需要注意。 * @method window.showLoadingEarth() 显示 * @method window.hideLoadingEarth() 隐藏 */(function(win) &#123; window.showLoadingEarth = function() &#123; nDiv.style.display = 'block'; &#125; window.hideLoadingEarth = function() &#123; nDiv.style.display = 'none'; &#125; var templateStr = `&lt;div class=\"loading-inner\"&gt; &lt;span class=\"dong\"&gt;&lt;/span&gt; &lt;strong class=\"dong\"&gt;&lt;/strong&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt;`; var cssStr = `#loading-earth &#123; display: none; position: absolute; width: 100%; height: 100%; top: 0; left: 0; background-color: rgba(0,0,0,.8); z-index: 999; &#125; #loading-earth .loading-inner &#123; width: 4rem; height: 4rem; /* background-color: #ffffff; */ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; #loading-earth .loading-inner span &#123; display: inline-block; width: 3.6rem; height: 3.6rem; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAAC4CAYAAABO+hZ0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAItFJREFUeNrsXQmUZFV5/l9V9TLdszPDMoCMICMom4gg6HGJStwXcDlREuPJvhjjyZ6TxeScmF2jxpx4jprkuCQxqNGoRNTIjiIIgoAwMgPMwDB790zvtdzc793v1rt1+1V3dXVV93tV95/zT22vqqve+97/vn+90Z98pSJB2pLIu027bx8r3i9orfE5e18529W8W/verolq8hf8p5Rq8rqav739TNXkb6gVODilgM+WAeyDNe31ZkB3nys4zxVTtq85z1Wd16opzwUJwG4LyAtZ5I4aTX628k6eAWe7QcfCKwIctxXnvUECsGN5mtYXaH1Q6z0tgjBawknRCdC7dKbo3HeBXiPAa8Gi9y+wL9H6Oq1Xa302n7uH4H6v1v3LAKgPfNXiZ0VL+Hz/sy2lGSS4IWUH7AHYPSprtZ6v9UVaX6v1CofnWrlI67MIhl/TOr4A2NQSgNjOCdIu9VHO8RxwrHfZseYB2DkXHNhtWp+v9ZVaL9N6qtbRFFC7HPYNWj+j9bo2gZwGUrUAd1ct0I+lgtvl6oPcF3g8R6DPBWDnU4a0vlXrm7ReSkAvBYhntQmkNCBWF4isVCUJAVZ5W/Aohg/UpVp196Raw7+D/TPL+9UA7Oz/jgu0vkXrNVpPc17zL8GFBT4HB/rHKWBJA7A4EYrlRiRcIBecv1+UJPxX4v1Cm9TIfnaR4J4jRZl1nNAA7AzJhbTQAPXZnqWUBUCaJge03tYEFKoFh2450Q+V8t0rzsk4y+NlncWiEylRi1hy//cCyIPK0JQh/eqs/oQy+XgA9irLKVp/XutVWs+lFWrH8lQJDljqd2g9lsHfaq86c95VZ4DgH5D0ZNBCZ2BNP2Hpzyg/BzrZC45mHoF9Fq3zu+kginNQFjqw7iUcIb2HtR7lQb1f66e13pWTfWCBN+sAvkBnseAc10g1IjtqgnUbUbFhwynH2QzAXgF5tdZfZZRjIy+di/FLSz1mCejvar2eIMbjJ3vgyluTJG5dVOb3Dse/W9WjImm83r215SA4MdZxfwHcM3nk33kBNqIbv6P1zQ5YKymev/vY/W2PaP2s1m9ovVvrhPSuWCs7ofdEkfth0OHnafVLUco+HBLLwQ09KQdgd05wYN5FLn2eNMZgoyZWyKad92q9mYD+ivSn2JDeHI/1kDIgbzVcWKDlHyA9mc4L/84ysF+o9c+1vpSPyy1cEouMbHxd66dIO45JEMX9V3as8IBjBFKjKOQmln+vpeWfyIP1ziKw4cy9jc7hMx0HqZllGXB45ue1/quYkN2RgOdUsSn2Iq3xEC1zpIGsmvBwGz8foh7PuvXOGrBPopX+Rc/r97mgy6Xh/H1T6z9q/V7AbcsWvELrO6sBPUIDsVDyyu012MjtJ/k5KgA7XWAFrtT6R1ovJiespVhqmz2zVvqHWv+B1OPJgNe2Lfgx7tM1PBYxv1bN61wUty3pV6b0o+msgTsrwP4pWmqkwmdk4dJPPH5A6ye0flBCgX2nLHi9SEo/GJEkta9SqIk5Jirm3EOkNZlK7Kw2sDdr/TOtv86dMtNkO1upBrmegL45gLrzURRljgGs+AitcqG+n9P7HnGziVjKjGO5msDervVPxZSKTrfwPe/T+jdiMoRBus+/j7F+pM6/F6AmNTr9RTqWs/0K7DO0flJMKM+WUKY5hpZLg0P/tdbbA+5WVGBwKspY7jWSVBimUhOVRE0OrTa4VwPYL9P6ETGFS1MpYLY7aw0vbe/X+pcBY6vqXFZ4u56YSZ/aoOrlt1u0jpF39wWwf0Lr39FiTza5rNlL251a/0rrVwO2MkFP4ri1MnUkpthKpVKTOKGj/9vgUBPVy8B+sZhs4DbvTHajHrauAY7he8TUdQTJjhjaqGI+vbbBsTR33IROiRZeVgPchRX6O6iZ/jdeoiaaWAR8F4Sc/paWPYA6m1IhUMdowaNmXRjKOJyImKyTxvR97i02wHoloxlbJCli8i9h2A6d4f+s9UPSx2MDciKwyJOMkqynkx8pP+eg6scYmUqU0x7tFWA/T+vHtJ5OS53GpxFOQuwUWcePB8zkSuD8I9W+Nj6O882228e5jifEeN6BjdQ4RhmcyEtXWrc1fvAurb+l9UsBJ7mU6Thiouqd8H69t70LKrLZWnvpcpayW8A+m1z5ZGne5YK/jZrp39P65YCP3PNuxK63MpadVu+tlOmx3GRAHo3V+9JUPoCNS87fi5m4NOf9OHv24sejrBRNBLcEXPQG7yaHXk8MqPmAjazl3kBsTOUlKoLP+7CY2XhlD8z2ZwLUu8UUPgVQ95YArMc0oI+reuOwzdlEkWdQt0pS/5N5YL9P6xuFoSDvNcuvD2r9A603Bhz0Krijw1pnaKHrY5EZGoyjJ6QsmyQpk80ksPE5r9L6CzJ/kr84lhpn9G9q/aKEyrxeFkXOPa1MmC/tYFc1uke1bu6Cge3YB6KF60OWW0n6uFtY8N/Vem047n0hZWVCe1PijG1TxlxHKolxj5JzdxTcnXAeEcP8CCMhY022QSr2o1r/PRzvvhK0ncFyb5PGJUrciAl0kzKp+mOduox34ixBYuU5Mr951lpunJFfE1N2OhWOdV86lEd4W0wBCIx3iXx7OAsWG2ca6ql/RrxiGOd1ZBVvFVPQNB2OcQ+htbqkkeG2CGpY+TkNVU/cYebJCWJ6V5dtuJdjsZF8+SCpSM2z0nEaVf/3uDId52MBCn3vTE4o4EA1osSbw7yOfHvZa/mUlnFCIGN4gU9BnFPtqH7wPv0VHw7HNUgMDSVjnES1VlL7FGJAb2DE5PiyLLZ3Ai2qlNeIGbl7SDVyJfP1lazX+h8S+hODNEqFV+9Zyxac2DYEDuSQ1hOW6/+1Y7G3KcOZzWxmNe+SA16N5Mtf2GeWQ5iiKKAhCzJd7tiBQGz7MCMlUUrnuw0BIjU/3i7fXiqwEWz/Df2nUI7qp8xt6Ab1AlhWLszMC9KMb0+KoRprVfpqx2akg+mSn2wH2QVZGhd5rtZrPGbi3qIQ5gNiRiV0Zi+oRIP0DrhRMKVM+Lc0L0qi4tUWwMVPaPewL5XH/D4914ZOGKIca5rcK6YLJsAwyGIyw6t7zTGckWNHcX89Hc2om8DGYBs0D5TdPjeVUBrwIQzAmQjHLEiLgrl/4w6QxaG0sernNtJoLolctMqxN8Tc2vSuzUljN4yNYX9OTHd5kB6Q4zMr5rUjSmJDgDXvUm874meVqQpt3XlskTNgXvWFjsPo8mpER7Di1ofFe7EbxKx+qQnRkl4AdUxJlMmFrK8bSWcRKGXS8CeQtrTc5N0KFUEf27u4bVqfWk0DDuPKHguQCNJmlGQijpLM59mWmtja7ZbPuNJi0YYoikG9XRoXM7LT73GZwPTTz6501KLq/L1iIaCjF6IkpMbDjgGNnImu6+m/tVRztBjHPpFOI5Iu004NrXL40b9IqAXJvYxNrzq3m6RlHpmX01Mx0AH4jTXVGrAXs3Wv0GC+VOuUY5HtVQIUBWslXrfae6RaC8DsAakwtl11w38ONSkw/LdmucCGl/pmSR+fgD9yXBlrHaY2BemUlFkoZYEsXggwttqudW0a7mtGjfWnXCJmhEJNkvnHNsSHSAg6zL+elUxMxbHapcC5W5LDk5kMLY3Tdxu2uFaN6ymg+m+/LDJwp7AA9/45MYXhyimdtXKU3Do0DwRQd1qAqWPsi4zU/PXf13CUcdQOsJ+mwK85m22+MY9De5ld7RbWuxJ4d14Ftdiw2jYR2FDaqpIhl6WFgZ1ecP3T0rgSrnnV/D+q9Z8k1IME6aLVVqbjpqRS1rvh2IYRt0DO1zTUYxHRS8WE+GYJZ/vhKFu9P46E5ADW5Wpyf6AY0HJgIlfpWtDdrfaBQ0lsthtc+3gzrl1KoRkX67debvmzEyC3TiNqQkKhU85k//Hc1SBMEmfzwntMs9sFn1LXufFbwwb0f69TJqaYZpQxI+JbeTywrvUOkgtRjJBUiFPLsyOCdVDr2lapyKgya8VUHCttb3F2fEs/+FFe99ScBvdgn1GSp47nulpsgo7ikLOQE5lJfWrrgTQbXPLWE75akjFldSZCAg8+gznWM8GY5ADQ4z1R/gg6jMjciJOoSQIfyerBUwtxbAD6WWIKu8fF/SAVLzCKs+cbed9Tc8yTDpYC+HMgqM+eoGUelPmrJVgnckFgo2DutTGvaawLgSC9/gVJWsKkFwDeq+DeN95Txeqw2tNcHbjqIbNGQ7xvPrATEL9IksXhledg4qy5Iwqz9zItT4z3ZPdFmZGPzd6iNpHDNEri1SyVnFsMljyNnmjkLQiPstSv9lpGZpa7YijQkiwLqv1gteea5F2KdDAPpTmPsNIvlyQmqLy4yz3RKi/63m2A5x3ce8d6uldumkGLDXU60piw0XQkOpRmsU/Reqo4YT6nkg/xwltUj0dDZvQFb3ggADqzVtsM2dkkTqaR2K5IMqJB+cC+XDVmeGzUsEgT/x0JtSHZA/XRvulo5krAkV/7b3cARhCPOIxDO4bGNJ8To95M4FEehFHJ92A/7D1YbatBMiUoFQFjsMMs7cyRpHZPaZriPAGLvUXfOV8aa6uVUyOyM+qhMF+vyJ6jfddNgXD0NGlHJYVnr1Mex4aZf7o0Nn5bQY/ZTf3IQaa11V6TQc79+NG+bQ+qxMbXqTb1cIlGYByxso2KXCZJX2PN4S5FbbZ3Skrwu19kSl+nRgYlSFZ4toonQpVpkN1y6oKYUSJr6sAWs3D7mVoPejWvGuQR3nBbP+/NKZKwkcHVv249dqTvmznnCFyYm5o3OSEu1FMcXw3n8SKtR8xGSWWg1iKdxg3BWADgUQB1BoCtcVrxxkrbA1Piar8RLXZ0Fk25W7FsV3jC+jFHw/40MqnBPbrClvvRwwHQnsWukDL7PLtES47bsn0A61x20ujYmzDpeyXEr4NkiWeb1LordZ6trXjd3Yf53iEmPqi8D4DJvy/sy0aZmI1k7dDKnOu7DgVrncYKo6gezXMpCR6vsTgueNEQd61rWPLJsB/TwR1AvXq7X2Oz6PBsOyUqXtgL7Y2K5rvGjZRS9dwNSDiW3Tgc9mNzcHcL4AHUCwrYxYw1yl7PLij1WmuxN6fw6Cqt+L6wH1dWAqgXFfQHTCkzCsS12IXYT1QybJt5Zxxg26o+xAoPR8axDOn0FmhJJ3j3IwHUrUgkycoakcOzlRMdiUqel2kLoNCVsIumPUgLguUt1g2rAOruC0ag1cgq3CkKNhiCHVksxeWqqj4Ax06QhxUHqMPQySXIMQ3u9cMhOtptYHtgjpRrzU3Ir4qex2pjK1n8BgB9v3jF20E6D+6dB4OlbkNgeAfrlKQx5BeviFBSCce2ZwBa3uFQPhGA3Z6Ma3BvaAHcAdTLiIyoeaMY7F3Q6wH8B++y5jqQ+t6c/n+tLDJcO0j7svNAAPVyHEhlghpFj2lgp2I832ApdhBVMouYbzrA54K0KXaxoo1r5lvuhwKolytY5rM+go8Oo30cr8VesAB25vmBnKPB4HFpYw3rIOkAD6DuLBVRps8xmS9iFmLCP5DASkk1VvVZwz6iNxsO/LqzEkDdMZnzkakSf7DOsQe5od0UnHt/3BwZpCNydCqSA8fDxa+DgnoQpNaHPOMLzj0Vc2w+rTzPEvQkFEB1UMKlr6NSIojrUTtvSY+5kkomPNl9D2qyTZmxwUGWSz/2N9KPjSMB4p2gIij3UE7DgSRp9Xh4pUV+ZV7xtorXogkSOHUmL4BcwbcgjTMmoeiwGYLFHowfqIYikqcUV0AN0uEoiebbaSHAIEsSO1K46FE9ABsJx1qJQ92V82JVLNjNG8PqLZ0G93QkGwK4lyNRZHpyay7PpnGOK1ZL3rBJu7e3Kq+zJsjSJGQWuwdqMcOdIvE61fmwGKG6T8ya1f7Sd/h/W8Nbg3QU0ONM3ATLvXR+LRyMo5LWxnqoGrsWoLezGKYdU44NMXLhdBX2ecvy4zYLmgDwUOq6ZBmiNpSwOiG/GaTUZ5iKVExR2lu8cV3Yh0EyJgWPftTXWXcmBccWe4x0RDnoHxXT6Atgh3j2IrLc7hfUcEPWDQXL3RIViRomrtZ5NqkJBsTHHLs+gsHpHcObEO4Lk6K7DGpXjnewf7KXga0RbPMvNS9jbuPaFUyo3Crzx5ghG3lW2L0LS+goXx1+rZJ0ukhj3yMMcVytWiLVsPFA26UOUo41aU7XejDsy5UF9EpOm8qh2KWmax64hfQ5nrZa4troz5LGMWfYcFpv9Gx9+/2wL1deAribih1vFmcdvchdfeUObLRb60XCRI2z4bFARxplpSefBnCnygalGtZ7dNvCjisusosNDmHm8DzP07yGQqgQGVllyw3JwuD5LEhk6kQGJFm6saAcS20NNJzHI3Qeh2mw7QZDcWQEGUiRh/reWofB61mQgdhiJ/VLLsfGAZpw+cpTNN+jsVfZuPwBVmLa2u/AzsJqAnZFhT633Eijr3MA7S8UNl7n2Pr/XazwcxGt6Exu0XqyhPkiQbIhJ0hjfQhn98U30+Isi46y1d1ckGaTNLbX4I2b9X+n0ZpP9OOefDxjFKTPLTfLPKI5byGwiBb7iGu+AdhdYtZ6FI9n4x7WqFnfb8DO+nqKAPiagb4D9haZnw23qfTxyMFtgSOg7lJmKTED6mSSNsz7M/TdTd6A7Z7WPl4kNOMBkZhf24HvSfFTsmbSjGuxIbeJcpbrSJCP9OSptOY7JczKzpRM03YN94flXkfm4ALd0hD0P477nmTs+CszhBKmvua9eVRMBvKmXgf2nrF8WuoZDfDhUs/b602S1GDbFhgLbjCNI+7mJSfTeLvWtwvKWFVDBGRG83QAeyPNfc/J3rEwzCYHNGQLWYWd12elSP+vYZZ7wSGX3xKsFKZsY29kFW+AA7lDwiy/7FrtSk//PAxO3aySxZTcxAyAfdB3KktJ1ETu1HrICaGIEyVB/PAcrd8TEwQPkmFwD/UeLTlF64gDZpeGIHZ9xMNsQzHJJOnIC8Rf/dRcAkBHTlI9BOx946FbORfW2vh+bn2Ia32txW6QghfquokLQNqRrLaLDIP+ztT6jEBHsi+zvUVLIlrsiqUhTo8jqPOTkjImpOAFcW/RetBp7LWKXYWaked4IZdcW+teBze0B/IKYAmDNLZWYydQGbCPS0oLY8m7FGPB0nu0Po+m312KukQ6soNcO5fy1PEoVL3kR2B4T3doiDvKTPjcnrQxIb6bASDfAgDrjeEwunFr3D8RoK/lENj9Op96Th/6gfyu1rme/Npd09Hl3k9Kk4bzgnLW6KDeowxvidwrgjIlgxiC+2Ixxd5BciLl/E5fPNnDWuSqMgyjmm7q58tu0pEpJ25orwLY/hx973l5IWgHtaU+GFYTyKOATZzhgdk6jwVmGg82O/RpwMbAvzuYYh+sW2xjzTF7BHznlU3eGyTDVttqTgRtiSi+qzUkZsydmtbDssDK0aUmftTDsNoaxOfL/GmsSKtfokxn+w+zulcOTQQrvRg1KWXZNEUxvqqSeIxu0VMhZhYLBAHSODb0qEKK3ZwRLs/GHVh0OJFXioQFmIJ0iVuruPjOLXayt3Aan5JFGsybJV8RRkGN9oNiUukzjsU2dEXJpfr2dmWylZkRrNAVpsTmWgBcJALRXJ42FAeHd1e0yOz2hS5GAPfX+eEFh2dDZ+mxvlJCJjK3UqklmjFufbJLSlyOrRXc+tBicYPCQi9q+T8N4ke0grK4L8Xrf+g7L9e3ZwZHsjdAnoVAlphK0iHa0Ei5rNtYc6wYPbvY71kMkHu1fpMOo38SqHiRUyVXCQZbrvIeAQWBBsk3t9aH8hRvtejIATVCfE+08kGl2uJ89EatF2u9QlRjo4EyBd5Ivz+k7395JVPVdqa0S/yD5FoG6M/Zhb0STm0OMMC+J4rMCLPFLfbi1vBRrTdwTb3Iu2zgkoAIyRvEjGgIkmOp1hJtEi3rmmrZLqaKL06fY7wCX7PhPQQwdrb6ea1wY6TS/0cZq9wAeYcHIULyUnHW3QsSZAmCtPkO+nJuVMuNiPxYlrAQQatOH+LZ/wWOwxLCZGFIU7GNdWxer1A8xTBKtzVId6WmEl0BOVeDeZM4052cWxjLMQK7ZSm0AiIC+RaFWdkmcK6S3sj4BIsbEfTDtwa+G2SJgjr/s8UrcHLADSuNfMqSJiQUlhB52K/1SwoD4ROubXEM/KPz5mWxk2kcgSBBFhNY4+eKGavgj/0AuIpc/Gv3Uj94KW2fIPU/0Hq91svpvVYdcGNoCb7g1Von9ZM/6GQGcLrsREHCZWHFaUkdcR2KqPJjnimmUbwmSczaXYwU0ZF72zncS0qskJZcq+CdciSaF11HOBDFK2/lWRgkSDMBp76AVjlyOmMSGqLiQqf97eQ1Cm04bA/qN37R9p15H1mhc/kSff9FtOpBgsxjChojz1fJSAULZDvQpsCy1PukzTRFOxMoQOJv1norrLMyn6GcL2frvK8RM1D+1laoQ7nWeI2rj3xVIQGTJVkODYwSDoI1jzCeetYrSRUnMgKHcbLdv9VujQccyM8o1G0rWe+E/Wxpq42SvJkcKkgQK2dqgOzQOscrfuQ5jGuUGWu9ezl/pKCQZVqqGvTegygJ6UfBayEDc0Gm6EL94J3SeMkJ0r8CI3gJ/S8LZHGibDZm/QNZ5oV6OVV5iC9+U5koSdW9UjmZTVCT14spbw0NwP0tA/S7NjpOmW+xgaPvSAcWGVhuuSm+3yf1fw9oHXUmSNlvPsfJUshKvkpJks2qUiuaW1dqoSqvxwU4u0If7lNVkhZPO+iPaN3TqT+4XHlU6+c1iPfFI6eSs9H6GTj7UDwOSnJOOMZ9J0U6i0/nVT7y/UlSEyzJeJdrMZejhapjPdvRmkHwd/TNp1U8Szv+Icqz6vgBm7W+V+sF4Vj3mbNoRuOV0oIkkqzPeIu00ECwkhZb+IW+JmbVgylJQoBuO9mkVoAayZtnhuPdF7KdvLrkgDlycIf7yC7eTostWQO2MAryKa03o1LLKz+0VwisE3KR1vdI6HDvB1C/hFSkmsKrLTp+JCa0p7IKbMhjGsyf1bf30guOvEhJjT8UFvu3xVR1Bek9QcPA5eTOaYAFLhACRv/ind3yVjste/Uv+YAyt5GaP0ywRicCl6i3iZneGqR3BB1VrxCp11e7FMTtXwSob5Quldd3q7scFvs/xUzDXOtffpSKKlo1545wVv+yJEsJB8m/o/iTPOYVmV9fbUF+QExZRrlbX6Tgdkp0Qh3TfIPWj2sd0wAuaVVY85rrXlvLrci5/5i0JLSW5VcQzruCoK5Jepy6wEADkjBj3fwy3bSSLICKPk6Pd0gaeyVtnRPazjBQ/lf0oxeKCvXWORTkJ6706Id4DuMQjzWGMO3r9hfq9vpS+JH/LWau9pvErBU55/34Ch9hUMq7uAOuD1jJheBYXUgtOvTD7V2091Gr/22t+1fii60Ur/0SaYkpaU1SRMpZSwRM5kStv6RfuUpCVWDWBUBGQRNauwabWGmLMVhqlDnvWakvt1IrAk7GZ6tpHXuLMin2mRTrDmuO5RmwQjDWcP+KLLN8MUhXBFnkl5JXzzqRDd9KlwjqGxgFkV4DNgQFUV/l34TnfK6kZ5uOK1MJ+BKtWFjnc9KlWGeQtvCyXcwcmc00Tm5IT3lW+wijH4+vxhddSUEG6gvkWaAcaL0vq+SMN2e6meaKHXOeMovrXKv1tm570kEWFRQzYaQdDE/Zscw+oIs0WresBqhXA9hWblUmlvmHYorPh8WZG+HsJVzG0EL0TjqX18kSB6cE6Ygftk3rZVqfVnf4GwHt1lQj47yXAYDx1fzSqyU79W55v9a7xUT4Br1ZJVbGaSGwWtm7tb4mxUEJ0j3ZQT59hswfxOUnX3BFfkDr/8oqL02+4hZbNfrOj+gnPsGFnK6RJBPVsPNUEiLcrv//WTG1JteS0swG7HUFF6cx6nE2LXR5ke1hJNHShUq9qSz8gNUUABjB+k9rPaT1HWI6bmxFmOLZYM8HAByhpRdwhyPYf4eY1H2QzkhELo2FtTZKY/SqGZ+29dQPZunMzILAGnyNa/e9WhDwV/W5bb7Bn+HOhFP5dmUaF77NyMl0wGXbYMYYaNR6PJecuuI4iNKEUwsN03dXy0nMOrANP1NxDQEcDzT/Xk2rXfNYTKQSax7xQMCxREEVVjr7YaAnSxbkFS4WE8obkSQ2HaUwSBufxi0G2iDxcjyLXEoyBW6Rx7R+UkxjJ3j3MOPaM9K4DLbd4VO0Ns/Xeo72Qu/gzt4tHeh27mHBPkUS7DwxOYUSLXQlxSq7aXIAHhGt74tpEqhk1UnIotjRDgDnVeR7iHkfS3VIVT1UuE5MYuc8nhg38QCEsqpEBgjoZ9NCr6NBqSxCVQaIF4RbkVPYk+UfWcryl9N7c5dG5EfFhPownwSdGRUN5KpnucVxLm3j8In06sG9QXF20kHtZ9lBQCOju16SFeB8q6xSnPwnGfW4Ny9hnSyLpRrXaTDjsvdGHpyTJQkBKo8HWk4Onojhh4igYALsfjo5PyLI+0GGuK+eTrpxGoE8QwutFrDQESNQVe6z7+Up+lTK0UECLYH1vox8+nLn8lnxzwbn+TL5JC67Z+sXMRcOyQMs84coDB4XpHdWAMFv3cDIxpkE9lr+xskUR1A1sdYwDI9qvVtymO0t5ez72kmvD4kZrgL+vUEZ53EmJYJiI+BVxzk9g9texksrHCE4nAfFJIoqOTyGQ+TKW8ift5GOrZVkdFhNmtd2KId/D5Ky3cn9fDSPZ3cpp1YJYLxBmaTAW0g1dtDKDLCIKo3W4L9ZWq8xXp5R/3ARIyj386DewYP8eEZ//wh1PX2JrfQ/NhPg1gjUmvgivrW2LVvYrw/zhJ+UHEspx9+9xoP3GVKMcxkR2UTLNeaAOe2yq5yDV+T7Xk5gX8XL75N8fJ8TEajx/kpa9kECeDNpxibqZt4O0SrPSRLDV4tEORR/d5G/8QFy6f29EEWK3vCx7lJL27xbb3ZMsaN13qCamNlFXuODYVqxFynj+V/Ky6hd6dWlKf4INtcBLRAkw7yPzwDVQeLoMMFzPwHxFK36CQTHFC//E54TVnMu9WWPD087jt5mSaZoraUVBrXYyN9haccov9ucuKUH6b/NGgH7PYr8HlV+Z/yWB2WFWrYCsJcObPfuKYwAXElQbJckm1ZtAuhmtxYQdgDQFC/30+TlAOM+OqKjvJwfoWUdI3g2ElDH+PdP4mfNEqzbeCLNcbsNvOrg/nEHkOKdpGlgrqXsFUs3yvy8J8mfH8yhT9HzVGQh2UdFiAoDEZ+h9YUE3noCaE7SY7bNwoc2CWSHKBZIDwCW0xlSm+TtCEFcJkjnJCm/HeX7Z2iViwT4nCTLCJZ5AjU2PS9OLXzKZb9/hX9zD+nUXgK82qtxzl4Ftit3kyPfSIBfyNutTihwepFwX9pIAdf6zznAL0tSi1ySpI5iDbc/5tCSGc/izrUAWGlyQrpSlKTf8AmCeTfpRrkPjnlfANtauwPU2xhB2cKQ3yijIzMEWy3FmkdNuOtC4Fcp3DdKOYH8BtjFHLe0CjtFKjPEE+kRgnknf3PfSUn6UxDS2kWQbyfIz2PoD5b1TDqKIwTirONULgboZiE11QS8C50kabXP9kStOrz/EGnGw9Qp6XMp9fFvt5z1Ueo9fO58RiCeQ2BvoXM3Sb4cka/a6EXFoyfLcuYlabKwYcVB3p8gYOdIJw6RZuwiZw4SgL0g0O/j7V0Emm2NOocRkGE+N8v7J9G6lxgtmeL2owTgLMFZcCIzw5I0TUR0Ii03t7x/iMDdx+jKDF8/QnoxGQ5ZAHa7onhpF1pGIbinGF05g5zWteob6ZiOE9Anc5sJvgegPkjHbg3/xgFuX6WOk1pM8DOiQC+WJv8vwAC3plLl62w9wwAAAABJRU5ErkJggg=='); background-size: 100% 100%; position: absolute; top: 0.2rem; left: 0.2rem; &#125; #loading-earth .loading-inner strong &#123; display: inline-block; width: 4.4rem; height: 4.4rem; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOwAAADsCAYAAAB300oUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MUIwQTYzQUE3QzY1MTFFOUI2MTBCNUY1MUM1NkE0N0IiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MUIwQTYzQTk3QzY1MTFFOUI2MTBCNUY1MUM1NkE0N0IiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTNDMUY2RDY2OTc3MTFFOUExOEY4RENGRjlFNzIwMzEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTNDMUY2RDc2OTc3MTFFOUExOEY4RENGRjlFNzIwMzEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz51xfIrAAAF60lEQVR42uzdSWjcZRjA4X8ad6stqFhFakGwntxRDLhdVEypWq0ogqi4IS1oDx6stVq3HvRgUQQ9CFJBQVFMcxEX0IitDTaC9CBaEKQIIq11K5JhfD/mkybTmUlmMpNMkueBl2QmM2n40l//yyztKZfLBTA7LLAEIFhAsCBYQLCAYEGwgGABwYJgga53hCWY3zYOlsZePDZma8yNMdtjVsfsbXT/p/p7LaItLDNkbcyq/PeiL+Z5SyJYutfSqsu3xpxkWQRLd/q26vIxMXdaFsHSnXbWuO7+mB5LI1i6z3cxf1ddd07M5ZZGsHSf0ZiRGtc/YGkESwdtHCydH9PXpt3im2NOtqqCpTOxnhYfdsQMxeeXtiHYowsnnwRLx6St4VFF5WTRuibv+3Wd6518EiwdMvYZbKtiK7u0ifv+ELOvxvXLY660tIKl/Y6vindtE/dNb6M53GAri2DpsHtjK7twisexiZNPgmUaLI65u4nb19vCpuPiuyynYOm8dbGVXTTJ2+5o8LX7CiefZoyX181ND9a4blnMvoh2T3zcVVSeIDGSP69+Cd3ePKfX+D5nx1wd86llFixTFEGmXdY76nw5bRnPynPLmOt/qQp4JO8Wr2ywlRWsYGmDNS3cZ0nMdXkmI71m9pSYXy339Orxn2HNLU8Mlg7EhxOm4Y/aHfNJPt79alN/7x6rL1iaizW9xcvvMUfWuclfxfjHaNspbW23/x9wzM6I+A+/FcFSL9htpXRs+VqdL6c3b7oqH6+mXd9risrJo4Ud+nFKeSv8UcwHm1b0DvkNCZZDsS7IgSyv8eW0m/xQRPNW1X3S46p9Od4U8XlF5x7qSyey1sTP8KXflmAFu610Q9qSjbnqnZi3Y/6NGYpQDtS539iL6UTStTEvxyzqwI+Z/rDV8bO87zfWGmeJ54jy+GcyvRTzyNMresuTuF/1ceiSDsWapPdEfXXDttJA/GyjfmuCnc+G8tbx2YjhmRa/Rzqm3TzBbdIreUbz1rgVp+Z/EH7zK7NLTJM2HNolPiPmmwlC/Ckf735fVJ58cVnMJfk4+Nyi/tnpccey8Q/KBVbeFpbWpZNP704Q6+68Bf85X/4xTcS3NYefHlK6eEzAF8WcWbX3/XnMPZZbsEzNlphGbyWT3oXi+ka7sRHuP/Hhizwv5ogX52Pi49LWOW5jN1iwTEUcEaWTVY3eFfHjmJti/mz2e0eg++PDfqvcPl5eN489PlC6MD680uAmaTe5v5VYESztjTX9nznvFZX/sa6W12NuKyqP4yJYZjDW9HhoetbTsjo32Zx3k0tWyzEsM33cWhRPFpUzvjW+VDwa84JVEixdYP1AKb0ofX2NL6WtaXrxwBtWSbB0R6xpF/jN4vD3ZDoYc3sx/rnICJYZ9nBx+POE02tW0wsHPrM8gqW7Dl4PVl2TnuyfnhAxbHFmB2eJ51WvxZaYXeXK5yMxV8QM58stDdPLk//nocc+LJ343MrK62Pj8yl9r/g+FlSwgF1iECwgWECwIFhAsIBgQbCAYAHBgmABwQKCBcECggUEC4IFBAsIFgQLCBYEawlAsIBgQbCAYAHBgmABwQKCBcECggUEC4IFBAsIFgQLCBYQLAgWECwgWBAsIFhAsCBYQLCAYEGwgGABwYJgAcECggXBAoIFBAuCBQQLCBYECwgWECwIFhAsIFgQLCBYQLAgWECwgGBBsIBgAcGCYAHBAoIFwQKCBQQLggUECwgWBAsIFhAsCBYQLCBYECwgWECwIFhAsIBgQbCAYAHBgmABwQKCBcECggUEC4IFBAuCtQQgWECwIFhAsIBgQbCAYAHBgmABwQKCBcECggUEC4IFBAsIFgQLCBYQLAgWECwgWBAsIFhAsCBYQLCAYEGwgGABwYJgAcECggXBAoIFBAuCBQQLCBYECwgWECwIFhAsIFgQLCBYQLAgWECwgGBBsIBgAcGCYAHBAoIFwQKCBQQLggUECwgWBAsIFhAsCBYQLCBYECwgWECwIFhAsIBgYRb6T4ABADPjFV4w9RfGAAAAAElFTkSuQmCC'); background-size: 100% 100%; position: absolute; top: -0.2rem; left: -0.2rem; /* transform: rotateZ(10deg); */ &#125; #loading-earth .loading-inner em &#123; display: inline-block; width: 2.4rem; height: 2.4rem; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABxCAYAAADifkzQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDEzMkZFRjg3QzY1MTFFOUExOTVEOEFCMTlCNUY3NjUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDEzMkZFRjc3QzY1MTFFOUExOTVEOEFCMTlCNUY3NjUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNCNTcyQTZGRjc1MTFFODhDMkFBOUYyRUM3RDc4QTYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNCNTcyQTdGRjc1MTFFODhDMkFBOUYyRUM3RDc4QTYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6mADWiAAAVBklEQVR42uxdC7xVY9p/z6UT1dE9FZEuKmRGNalIQjGjOwYpiiKEMJMyJpNGM5/cPmEwPo5BSkwXJZQMFU0zocjUJLmk0v1yQtfzPX/7v7N6z7PWXnuftfdeqzy/3/9X51lrr8v7rPd9n9v7vDkjpu0xEaXaguaCJoL6xJGC6kQ5QaEgX7BbUCzAy24VrBOsEXxOLBN8JFgbtUYYeX7eDy8YBcJzthWcITiVqJXE7yHQqvx/TUEjl/PWCxYI5gjmCeZT8KFvnLBSFUE34hxB5QzcEwI+nzDstbME0wSTBVvC2FC5IXse9JgeglcE3wieEVyQIQFqVJn3f5rPg+e6iM/5U0+0qK7gesGAJIdJm3YINhJbraEQDX8E58saggpJXrtA0IVYR8E+JFh9qAvxeMHvBJewkfzSWs5XUEY+FiwXfCHYlMQ1MEc2EDQUnEwlqRU/qESED+02wc2CFwR/Fiw91IR4jGCUoLfPZ9ggeEMwUzBb8GUAz7BZsJB40cGHUNsLzhN0ElRL0DuvEPQRjIOyKFhxsAsRKv8wfsGHJzgXvWq84GXB24K9GXrGFUQR2wca8aWCXh4CzRP0FVwsGCu4S7DtYFRsoCD8R3B7AgG+Jfi1Y56cnUEB2rSH9x/I5+lN88OrZ97KofXig0mItaievyQ4yqOxnhP8THCWYKJgZ8g0552c/9AzTxFM8Pi46nAUmUqnRKSF2J3KR3eX4/sEzwqacjhaHBHnw4dUxppRmCUu53XlO3WOohChzt8vmORhMvyD2uDl2VAGAqLlFGZLj2EWDoQZnCfzoiJECO1NKi85LubBZYKOgg/MwUF4jw4cTda5tPPvOd8fFXYhNqf91t7l+GSeM84cfFTCef0kDrEatWf7nBCoEEt49wBwpmCu4Djl2A7B1YKegg0B3tMLlXjPiYJ5gkcFDTNw3/WCSwR9BNuU40cL5gjaBnG/WE8M5sm7C2YIjlCOfShoIfiryZD0BL8SLBU8LrhQ0E5wreATwQhBuQw8w/OCVoJFyrFqglmCLkFIMYjhtBc9Hocpx17hEPLfDA5rPThsH+Vix43knF0zQ4rPaTSvbKpAxa9PtofTroIXBAXKsQc4fBZnrgOauoKnBeUSnNeeQ2zNDDwTppJfC0Yrx/IFRYKLyjacpk4daNDajuu99LTckgVPC5zpVXye21jwvIsGnQ6lB892I21j22UHhahL6j1RLp8CmgumCCpY/L2CKwWPpnjdsuBwQR+Fj+dpIVisHOskGJjBZxwrGMB2cvILBBMEJyd7zVR7IuaSv5vSgVpc8krB37Kk4p9uYvFCJ00xsbgf7Li2nCttGm1iMcZMEZ5njMscOV1wdLrnxDzBeEEj5dhgwd8yOP/ZaKHwnM/zraCv4FPrnOqC32fg+Y5gG/1bMMzlHJgfL7roGIHNiaPooLYJQdFHs2xsN1N471t/F3O+tmlQKj3AJx1HF+RXJhamapngfIwYDyZzg/ySEt/nwok7TOEj4nB7CDwmtRTn+lfKeW/Q9Onq4JUXDBH8JsDnOYb+0j4p+EyvNbEQ2EtBut2qcSy3Nbklgn4eXvxMUqH193YP7fgORUvsb4JJgEL+zn20ja9IIEC0279oT9r0uF8/q9858SHaYE7edsEFnGtMxLBY8LrFq1ZGV1iOoJ9gmeAWQXmPc1cIRtBF2VrQTbGn8Tx/CcrtBhfWZQr/RsGyEElmu/V3hQTnj1d4J6d479qCVwVP06WmnbNPMFXQUdBYMErwBY/BRXid8puugosTut0SPN9hgrEK/2V6GsLUu6pZf8NrU8Pj/EUKr0kK9+3Ann2ey/E9gid47e6Cf8RNPAvPCiYp/Aep2br3xAQP+FtBA4u3SXBdyAR4peBUhb/X4zdfKrwjk7zvVYKZHu47CKW54BrFtNEwSIny1PYygRINp0cKfqvwwVsXIgkWCu5V+FMEmz1+V6zwDkvivjczMqNFRJYI2gt6caj0e02063CFf4OgYSrDKaRfaPEW0MEcpl54raCqxVsp6J/gd00V3sYk7nk/lRknH8PkPYKWjK2m8j7/J5hv8aAk3enWE93sRKi2AxR1eEhIzAkn9VN4g00sOdiLeiu8RT7udy6Ndpu28ZrTA3CWI3jwrvK8fzKxtE/bTswxCoYKylu8qYL3XM7PFmoKmlm8DwWvJvid2JQ5Ay0eOtYUH/crEuRZ/LWCDoLpAb0X2nmSxcM9h5U+Vx9OqwgGWrx9tGvCZu8dq/Be9/G72+gzdfLe4TDs9buHqWg4eVsFnQUfBvxuIxQtFmkfR/kZTjGM2hnaSLkLY05oocJLNIzC9zvUxf/rRa1NbFmbHTvF+smP0vBuH9M92M3KTEBM8jYvt1uui4N4rAknfaPwWnic34UNY7vXsNbjtQT3Gqq4He8RvJPG9/uTiw5Q4OUAP9PE1r476RM6jcNIy+gjdfbIHoxoOBUALA+4lc5oWxC7+HUn8od2s3ibXBo5SJrPSEwLy9HfnYEHCvHAH12hXOgvIdRIncMZAr19rSFnChsAaxBPSeBIvsnHVNFR6b2P8ANKNyHE96QpLaeJ2nCKcExP62SsvC0y4aYxSkSiMQXbJYEA/yB4zMc9TlN4kzP0fhMoByd1Mj8Wkjggx6azoNDK4ZgqKM5Cvkwy+EhwX5K/+Z65NSN9nn+i9Tfa5IMMvV8x85nsnJyeJYrHpoei5k6ISGhpuGCqj/P20nkPf+aTSVzf9qmudnFipwvjFd75molhL78qDrFCo82NWNT5v5wvyjuObeWch3fBMrovArhfpquOoAzLd5bpdzbn6d3xh8ECDzvH5C3+MCr0veAaQUUTy0Q4klor8lCxMPSPZRCgXSEDxYyOy+C7QQ6zLR6yDds458QOylg8K+RzoRuQ07lZsC7A+fxNhXd5ht4HMhosaK8cO905J7ZWxtw5EUy7SBdeVubAwUqUJ2jUojtwrEtg+DSnENsq+TOLfhLefnwmeMPi1XBZXxEUalKAp3mc0zIeFD6cOR/Oox8wJ+QnCf6IexTe9YIBabhXnmCCoEmi3J7rJ+yrnMvgqB3N+OAnmZXCbMFkJcPtCQaIawYc6O7oM92kCSbNE5QJc2mGlZGKguFUIOYKHuEimLApTYOpMDl5OYKbBWsF/xUsEIwS5JdhYdAdCv9dwTCF3wS+U62WWSYXhaK+2uvmwBqkmLCRWv+wiWVl7w6JGfM1w1EzTeklfbl094F+Ifg2RQd5P5pHTlpFB7y2VKEpemJtRbqfZXA52gxBIxfV+ka6/gpC1BvfEXQVbEtw3jkpXl9bnnebYKNgpXKsMb4ebdnzmgx92ciFOT7BOSiU91TIHAvw/qAy4zSPc9ancN1acQPe6oXjHXKxR6U6GLfrWEyEV+rQu5HOEFSBHaEm7VPcWqh7M49hsTihhHQ7EyvX9bmJJRZlsjIw2qcrI/43mNJr7z9N4ZrtlHef6IjS7OPH4ZwCa2JOtFcTwVW1kuGPpQy8IgsMCzX/FWBDIUxkL+6EoK5imKepEnLaTLfaAOWL3cnf3cVAdqYINcP/rggxlXKeWlbCW9bfGywhVkNPrO9yQTRWSyKe3ldCwc6jL29WisMGJv4nFP69/Gg68YOpbT3PCx7XLE8neE8KcnQGg9k1FF4qpTIbKrxFCa5bkOxKYdhFzQQDBOMEa+ieG6wk8Lp5If7MyhV2ttkWh1dklaA3s+yStbGwyvaPXCuSkyEbMl/hbU/hOnWUdRxfWbzvrb8r5v9QQCh1wtq704n/4ZyFVIJNDJsU0oRozvH+bCtM5KQRVMudw8hIIhVC4b/ljF6km/IC6ol25Y9NymhilxDNly8oZ7c5MH8E2tAczkmwSw7z+QAoHHArkSxhObSWUYdh8TMTSye00yzWMbViEWOh/RXbbQTnq3TPkdpi1sIUrpOvhNc0hdBJezAMfGsOrISxzjEH5tOAbcF5DJpYKxPclgL4gG6ytE6bnqOKfQYdAns5L//T/FhtH4JC4tKrVly0HHtirzQLcWtAQrQ/Bm2UtHOCd0Cx2WUxKzmlbGKpf8Dzjoug1Bc2APmVcd/tJRG9xl7rp5fEyzjP9jjnIyo1/7TUdKT3HWOCKf7uN2gMOjaF62xWRrcca0i1hbgrl+sNnRNl5QST73dUQG4SNBa08pnfYjhJP8JyJb8UfBKwgoHyIs9ZvNyylN3yic8V3okpXKe6oqRVTHDOJvRE2B1NnMYjh1G/eyQt5Nd+Ln2etdgT9tKm3MR5bVGKBnCy9CiVGifBKJ9Bn2Se46v/zCRO+/dr+OM9ndX6Oyq9yItOpxfISTC3ihWvzgGeoXxlKMjly36d5Iu8TmSbFvDZnYoQ6tAt8RgKX6OjYLopncPqhyCouebALPF6JrbH1Uyf2u29Cr/I+ruqKb2zzho4mZcrTtX6Ec2vAUoEC5M4vy7rv01lDuu5Kd53ssK7x6fzfqjgVIu3Q/CkD7ksx3yx1Ocq2igh1bn2BMEMOiSSdRRMpMPCyfs5r9fI43dDBHcr/PuV9fvadZZiTlymxahMtAkrlYal+NscOuah3l+XxO+K6d+92+KfxbntTZpCS2haHU/b9kzlWnHb2KaTFN4y2ImaEE+JuBBn0IN0Iz0cC9l4q2nTleO8fxK9SJWUa6A0FxblJFM1EvPahUr75dIf3MnHNWDyXWJ5r+J0sibEnEuf+mEeX2M5m7dyEi0xBz/B7hpE71AlJWLQyMWYd6OjqcykMppBgMgcmOpyfJWlsK0d1z+nTq7DvrJtxaaHSALUdyx13UaZ02ooS98TYRVTQIuSdOB/zWXjbjZ3fXupd0lshNmf5TZP+dFZh1g22xJGZ7SCQ8leawtLsDRlSZTVHuduYNQFzoG3E9Qtt3nzfvCNckHNPKXrnkN/5KFEUDywD9TPLSUP6y5WpnC95VSShnP+bcHhFnPyejpA5ht/iWDnKby5Tq/5fI77Tkd4PGy08xASIj7pSZYQQS1TFGKcoHgsNqkXr8hVhLiVctvfE3dTBe5leeER4nnlEBJiQ1O6QoZbSCiTdIYpvQHn7HgPdq7Zn66EbC44yIUIbbQBe9r5dJvZYbbvXKabTJK2oeb+TDvnIlMMI4jrFVhCHKw4YaNoRgygY7wBDfpyLvahTQ8E5CRPlQpoe9qmyCTnWGscXv2Zypd6YcQFeB4NfWyn3orDUlWfAkR+6YgsPz8iRHYi1kznh2UnSj2jqLHXRNRkyGFprekuO8l5YR9LZndNUDM1E7ha4T3jVRYM9V+QnuGMWbUh5kesB8IFdkuSv9lIMwNbGnwSgnc4kVaCk9ZRTvspXxlri0zp2me/idiweoOHAOFcRhB3O4HSYlhA9G/abXtC9B5aKbIiymk/5fR4fJ/m+1thKTgltJ2isHEznMQLTOnUSKQQIinrmYj4hOFgWGZpy7toBq3ar41enaOWylyl1E3JCWmpTA1jlO0M1tA3WpTh+jNlwZ3KFoLjKR9f2wwhlmWnz8GGbBfyr7e1KV2PBx4nrPv4T4SmA7joLrN4e41LOU9RbNTtA/HCWPfgXCSCE5Hk2zbEw9EAhYc1Ge9HTCl7QNFXxrl9iF5rMf4g2GnxTuX2BWEdguy9KXbSVIiSaYRdf85R3mNkKlsqrBA8rPDHcLuFsL19TUE9i/e2YEuEJFhF8JDCf5jySGmHmrsEay1eVT97GGUBDRTewoj1wvuUPbm+oRxS3qFmG7OxbH7PFIOl6UQlhbc5QgLs6TJVDaEcyrThF4riTFP4DwqahagVdii8ihGRYD3udmPzp7lsTHaAFPN9qpmD6M2objnHXzaxtfPbQ6DRbVR4dSOgiZZnO1ZX3meQnwv4rduJtPiBCh/rF7H0LC8EjVHPpYHCTkiB+YXCH2h8LqVIZov2SYLHFH43weiQVHuyeXNDvuQAFaKuUviPsb3TskX7TS7RDDhqh2Txa4ZHxi5Cj4j8pBD3wMvpiLBpPtvZN+Un6XqJJ7e+Z0pXKoY3B2VT/prhxmjDId0o3v4NIRUgIkJPKRGKVWzfXclcLJVa1vE6Y3aaOR4Ia+ivzqCXH0u5UaChsnUMUe87QyzA5xU94lu266pkL5jMFu1OQmEirBd4yQpZ5VKQWIyC9RDxalXxPRwq85xC+gYr8vco7nA4/1+Rxwp5bmXrGjininFPr8AboRb4+hAK8HL2wDxlhLuE7Zo05ZfhgZAF15eO2TyrR44hskGjjGP3lhDR7Rw5cpToRF9ThqzC/DKGI16kGv9UGT+IIAiNgWzr+0JoB2J06qccQxbBlWzHlCmIhn+WcxC2w6mQpYaCooXUyrCFnOrRkNfsQMyByCedVtab5AcUGcSDdOK/VQNqAOSNbHUoKoZ/73N4NBZyGHovhMMnguhPKJ6Y+PvALHo3iBvlBxjdxQMh3RxFDNw22cIiz+H893vacjv5VSIlvZjD4jYTXapCc6u/h/cLubAfB3XDoLfLwYPBlzrH5Th8mfdSa53LnoTfIAPtK36hURYgzIclHgKcw/b5OMibpmPPI3xpWKd+t9HLiaBODpZQo8xm1JeVxwnbNL1Jrbiuy9RwN9vl66Bvnq6Nq6B13SH4pYe9djZ7Iuq2NYqo8BrQM7SIAtJoPdvhDpOmnNZ07z6GtQzIV3Xbez6HGhoSgJAPelJEhNecwkOhwCs8tPzpfP+07n6XiS3kVlMTu9TEUtDdTB14MxZzWLrIhC+MVMDnmsWeB+G5VZv8hu/bxejF+yInxDhh2GxCY3yXR888i8YvXh6xtg4me/FKtM+ZJlYvbhWf62zF6xKnXXy/pubHCvppp5xOY7OSQoo5EA7q3j4/pE3soRiWsKzrizQ+27E0lVBwsLPRt5zQFBc4tVFG5dNMNuQbg7MnxDghM+B2zovJFMJda2IFEt7nvxDql+T7JTgl6pvY2obmRGvjvZG0TbBt4akabbKUYR4GIcYJ7qkbOM/UKsN1dlKQm6kJbrGGxir0oACVynCfdVTExtK+zRpBiPkmHISGGEo1vDuVnM6mdL3rRFSew+GxaXjGXRzOYeNOMUkGbtNJYRGis6EmEhjuephYQQTU1KmchefZSm0UpsJkk921+5ERopPQYE8TeM42VDjace6qmYZ7wjDH2kb4gVGpcb4J16LTyAnR9gDNJeJUh8oISk4eR9TmnFqZZkk8kyAeEYmXtF7PuXMlgcWc8GeuMRGk/xdgANdUyy2mhZGIAAAAAElFTkSuQmCC'); background-size: 100% 100%; position: absolute; top: 0.8rem; left: 0.8rem; &#125; #loading-earth .dong&#123; -webkit-animation:animations 2s linear infinite ; -moz-animation:animations 2s linear infinite ; -o-animation:animations 2s linear infinite ; -ms-animation:animations 2s linear infinite ; animation:animations 2s linear infinite ; &#125; @-webkit-keyframes animations&#123; 0%&#123;-webkit-transform:rotateZ(0deg)&#125; 10%&#123;-webkit-transform:rotateZ(36deg)&#125; 20%&#123;-webkit-transform:rotateZ(72deg)&#125; 30%&#123;-webkit-transform:rotateZ(108deg)&#125; 40%&#123;-webkit-transform:rotateZ(144eg)&#125; 50%&#123;-webkit-transform:rotateZ(180deg)&#125; 60%&#123;-webkit-transform:rotateZ(216deg)&#125; 70%&#123;-webkit-transform:rotateZ(252deg)&#125; 80%&#123;-webkit-transform:rotateZ(288deg)&#125; 90%&#123;-webkit-transform:rotateZ(324deg)&#125; 100%&#123;-webkit-transform:rotateZ(360deg)&#125; &#125;` // 创建div和style节点 var nDiv = document.createElement('div'), nStyle = document.createElement('style'); // 给div和style添加模板内容 nDiv.setAttribute('id', 'loading-earth'); nDiv.innerHTML = templateStr; nStyle.setAttribute('type', 'text/css'); nStyle.innerHTML = cssStr; // 获取head， body节点元素 var nBody = document.body, nHead = document.head; // 添加这两个节点元素 nHead.appendChild(nStyle); nBody.appendChild(nDiv);&#125;)(window)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"js中的valueOf和toString","slug":"js中的valueOf和toString","date":"2019-08-02T01:52:26.000Z","updated":"2024-01-11T07:00:59.196Z","comments":true,"path":"2019/08/02/js中的valueOf和toString/","link":"","permalink":"/2019/08/02/js中的valueOf和toString/","excerpt":"js中的valueOf和toString","text":"js中的valueOf和toString js中的valueOf和toStringvalueOf和toSring两个函数是除null和undefined两种数据类型以外其他五种数据类型（number/string/bool/object/symbol）原型链上共有的函数，那么这两个函数主要是用来干什么的呢？司徒正美大神给出的答案是：值运算和显示问题，一般在隐式类型转换时会自动调用(经典面试题见备注3)。 例1：如果同时重写了valueOf和toString方法：123456789101112131415161718var aaa = &#123; i: 10, valueOf: function() &#123; console.log('valueOf') return this.i+30; &#125;, toString: function() &#123; console.log('toString') return this.i+10; &#125;&#125; console.log(aaa &gt; 20); // valueOf true console.log('' + aaa); // valueOf 40 console.log(++aaa); // valueOf 41 console.log(+aaa); // valueOf 40 alert(aaa); // toString 20 console.log(aaa == 40) //valueOf true console.log(String(aaa)) // toString 20 总结：涉及到操作符的问题，valueOf的优先级比toString的优先级高，涉及到显示问题，toString方法优先级比valueOf方法高。 例2：如果只是重写了toString方法：1234567891011121314var aaa = &#123; i: 10, toString: function() &#123; console.log('toString') return this.i+10; &#125;&#125; console.log(aaa &gt; 20); // toString false console.log('' + aaa); // toString 20 console.log(++aaa); // toString 21 console.log(+aaa); // toSring 20 alert(aaa); // toString 20 console.log(aaa == 20) //toString true console.log(String(aaa)) // toString 20 总结：只重写了toString方法的话，toString方法比原型链上的valueOf方法优先级高。 例3如果只重写了valueOf方法：1234567891011121314var aaa = &#123; i: 10, valueOf: function() &#123; console.log('valueOf') return this.i+30; &#125;&#125; console.log(aaa &gt; 20); // valueOf true console.log('' + aaa); // valueOf 40 console.log(++aaa); // valueOf 41 console.log(+aaa); // valueOf 40 alert(aaa); // [object Object] console.log(aaa == 20) //valueOf false console.log(String(aaa)) // [object Object] 总结：只重写了valueOf方法的话，涉及到值运算优先调用valueOf方法，涉及到显示问题还是优先调用原型链上的toString方法。 备注针对一般没有对valueOf和toString方法进行重写的情况：1.对除null和undefined(这两种类型的原型上没有valueOf方法)以外的数据类型调用valueOf方法，得到的都是数据本身。12345678910111213141516171819var a = 1var aa = a.valueOf()aa === a //truevar b = 'a'var bb = b.valueOf()bb ===b //truevar c = truevar cc = c.valueOf()cc === c //truevar obj = &#123;name: 'age'&#125;var objobj = obj.valueOf()obj === objobj //truevar s = Symbol()var ss = s.valueOf()ss === s //true 2.对number/string/bool/symbol类型数据调用toString方法得到的是对应的字符串，对object类型数据调用toString的方法得到的是”[object Object]”，null和undefined两种数据类型的原型链上没有toString方法。12345var aaa = a.toString() // \"1\"var bbb = b.toString() // \"a\"var ccc = c.toString() // \"true\"var objobjobj = obj.toString() //\"[object Object]\"var sss = s.toString() //\"Symbol()\" 3.也可以得到一个经典前端面试题的一种解法,如何能够使得下列的表达式返回true1a==1 &amp;&amp; a==2 &amp;&amp; a==3 解法如下：1234567var a = &#123; i: 1, valueOf: function() &#123; return a.i++ &#125;&#125;a==1 &amp;&amp; a==2 &amp;&amp; a==3 //返回true 以上重写了valueOf函数，比较运算时会优先调用该函数。当然，如果重写toString方法的话，比较运算也会优先调用该toString函数，因此可以到达同样的效果。还有其他一种常见的解法：1234567var val = 1Object.defineProperty(window, 'a', &#123; get() &#123; return val++ &#125;&#125;)a==1 &amp;&amp; a==2 &amp;&amp; a==3 //同样返回true","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js读取和导出excel文件","slug":"js读取和导出excel文件","date":"2019-07-31T08:29:45.000Z","updated":"2024-01-11T07:00:59.221Z","comments":true,"path":"2019/07/31/js读取和导出excel文件/","link":"","permalink":"/2019/07/31/js读取和导出excel文件/","excerpt":"javascript对excel文件进行导入导出的处理","text":"javascript对excel文件进行导入导出的处理 js读取和导出excel文件js-xlsx 介绍由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。 官方github：https://github.com/SheetJS/js-xlsx 本文配套demo：点这里兼容性见下图：如何使用dist目录下有很多个JS文件，一般情况下用xlsx.core.min.js就够了，xlsx.full.min.js则是包含了所有功能模块。直接script标签引入即可：1&lt;script type=\"text/javascript\" src=\"./js/xlsx.core.min.js\"&gt;&lt;/script&gt; 读取excel读取excel主要是通过XLSX.read(data, {type: type});方法来实现，返回一个叫WorkBook的对象，type主要取值如下： base64: 以base64方式读取； binary: BinaryString格式(byte n is data.charCodeAt(n)) string: UTF8编码的字符串； buffer: nodejs Buffer； array: Uint8Array，8位无符号数组； file: 文件的路径（仅nodejs下支持）； 获取workbook对象读取本地文件12345678910// 读取本地excel文件function readWorkbookFromLocalFile(file, callback) &#123; var reader = new FileReader(); reader.onload = function(e) &#123; var data = e.target.result; var workbook = XLSX.read(data, &#123;type: 'binary'&#125;); if(callback) callback(workbook); &#125;; reader.readAsBinaryString(file);&#125; 读取网络文件1234567891011121314// 从网络上读取某个excel文件，url必须同域，否则报错function readWorkbookFromRemoteFile(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = function(e) &#123; if(xhr.status == 200) &#123; var data = new Uint8Array(xhr.response) var workbook = XLSX.read(data, &#123;type: 'array'&#125;); if(callback) callback(workbook); &#125; &#125;; xhr.send();&#125; 详解 workbookWorkbook Objectworkbook里面有什么东西呢，我们打印出来看一下：可以看到，SheetNames里面保存了所有的sheet名字，然后Sheets则保存了每个sheet的具体内容（我们称之为Sheet Object）。每一个sheet是通过类似A1这样的键值保存每个单元格的内容，我们称之为单元格对象（Cell Object）： Sheet Object每一个Sheet Object表示一张表格，只要不是!开头的都表示普通cell，否则，表示一些特殊含义，具体如下： sheet[‘!ref’]：表示所有单元格的范围，例如从A1到F8则记录为A1:F8； sheet[!merges]：存放一些单元格合并信息，是一个数组，每个数组由包含s和e构成的对象组成，s表示开始，e表示结束，r表示行，c表示列； 等等； 关于单元格合并，看懂下面这张图基本上就没问题了：结果如下： 单元格对象每一个单元格是一个对象（Cell Object），主要有t、v、r、h、w等字段（详见这里）： t：表示内容类型，s表示string类型，n表示number类型，b表示boolean类型，d表示date类型，等等 v：表示原始值； f：表示公式，如B2+B3； h：HTML内容 w：格式化后的内容 r：富文本内容rich text 等等 读取workbook普通方法：1234567891011// 读取 excel文件function outputWorkbook(workbook) &#123; var sheetNames = workbook.SheetNames; // 工作表名称集合 sheetNames.forEach(name =&gt; &#123; var worksheet = workbook.Sheets[name]; // 只能通过工作表名称来获取指定工作表 for(var key in worksheet) &#123; // v是读取单元格的原始值 console.log(key, key[0] === '!' ? worksheet[key] : worksheet[key].v); &#125; &#125;);&#125; 根据!ref确定excel的范围，再根据!merges确定单元格合并（如果有），最后输出整个table，比较麻烦，幸运的是，插件自身已经写好工具类XLSX.utils给我们直接使用，无需我们自己遍历，工具类输出主要包括如下：有些不常用，常用的主要是： XLSX.utils.sheet_to_csv：生成CSV格式 XLSX.utils.sheet_to_txt：生成纯文本格式 XLSX.utils.sheet_to_html：生成HTML格式 XLSX.utils.sheet_to_json：输出JSON格式 常用的主要是sheet_to_csv或者sheet_to_html，转csv的话会忽略格式、单元格合并等信息，所以复杂表格可能不适用。转html的话会保留单元格合并，但是生成的是12345678910111213141516171819202122232425262728293031323334``` javascriptfunction readWorkbook(workbook)&#123; var sheetNames = workbook.SheetNames; // 工作表名称集合 var worksheet = workbook.Sheets[sheetNames[0]]; // 这里我们只读取第一张sheet var csv = XLSX.utils.sheet_to_csv(worksheet); document.getElementById(&apos;result&apos;).innerHTML = csv2table(csv);&#125;// 将csv转换成简单的表格，会忽略单元格合并，在第一行和第一列追加类似excel的索引function csv2table(csv)&#123; var html = &apos;&lt;table&gt;&apos;; var rows = csv.split(&apos;\\n&apos;); rows.pop(); // 最后一行没用的 rows.forEach(function(row, idx) &#123; var columns = row.split(&apos;,&apos;); columns.unshift(idx+1); // 添加行索引 if(idx == 0) &#123; // 添加列索引 html += &apos;&lt;tr&gt;&apos;; for(var i=0; i&lt;columns.length; i++) &#123; html += &apos;&lt;th&gt;&apos; + (i==0?&apos;&apos;:String.fromCharCode(65+i-1)) + &apos;&lt;/th&gt;&apos;; &#125; html += &apos;&lt;/tr&gt;&apos;; &#125; html += &apos;&lt;tr&gt;&apos;; columns.forEach(function(column) &#123; html += &apos;&lt;td&gt;&apos;+column+&apos;&lt;/td&gt;&apos;; &#125;); html += &apos;&lt;/tr&gt;&apos;; &#125;); html += &apos;&lt;/table&gt;&apos;; return html;&#125; 导出excel导出分为2种，一种是基于现有excel修改，一种是全新生成，前者比较简单，我们这里着重讲后者。 自己手写代码生成导出excel文件，主要是如何生成一个sheet，我们这里写一个最简单的csv转excel示例：123456789101112131415161718192021222324252627282930313233343536373839// csv转sheet对象function csv2sheet(csv) &#123; var sheet = &#123;&#125;; // 将要生成的sheet csv = csv.split('\\n'); csv.forEach(function(row, i) &#123; row = row.split(','); if(i == 0) sheet['!ref'] = 'A1:'+String.fromCharCode(65+row.length-1)+(csv.length-1); row.forEach(function(col, j) &#123; sheet[String.fromCharCode(65+j)+(i+1)] = &#123;v: col&#125;; &#125;); &#125;); return sheet;&#125;// 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载function sheet2blob(sheet, sheetName) &#123; sheetName = sheetName || 'sheet1'; var workbook = &#123; SheetNames: [sheetName], Sheets: &#123;&#125; &#125;; workbook.Sheets[sheetName] = sheet; // 生成excel的配置项 var wopts = &#123; bookType: 'xlsx', // 要生成的文件类型 bookSST: false, // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: 'binary' &#125;; var wbout = XLSX.write(workbook, wopts); var blob = new Blob([s2ab(wbout)], &#123;type:\"application/octet-stream\"&#125;); // 字符串转ArrayBuffer function s2ab(s) &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF; return buf; &#125; return blob;&#125; 拿到上面的blob对象就可以直接下载了，参考我之前在JS弹出下载对话框里面封装好的openDownloadDialog方法：1234567891011121314151617181920212223/** * 通用的打开下载对话框方法，没有测试过具体兼容性 * @param url 下载地址，也可以是一个blob对象，必选 * @param saveName 保存文件名，可选 */function openDownloadDialog(url, saveName)&#123; if(typeof url == 'object' &amp;&amp; url instanceof Blob) &#123; url = URL.createObjectURL(url); // 创建blob地址 &#125; var aLink = document.createElement('a'); aLink.href = url; aLink.download = saveName || ''; // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效 var event; if(window.MouseEvent) event = new MouseEvent('click'); else &#123; event = document.createEvent('MouseEvents'); event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); &#125; aLink.dispatchEvent(event);&#125; 所以，最终下载实现如下：123456// 传入csv，执行后就会弹出下载框function exportExcel(csv) &#123; var sheet = csv2sheet(csv); var blob = sheet2blob(sheet); openDownloadDialog(blob, '导出.xlsx')；&#125; 利用官方工具类生成其实上面这些代码都不需要我们手写，官方已经提供好了现成的工具类给我们使用，主要包括： aoa_to_sheet: 这个工具类最强大也最实用了，将一个二维数组转成sheet，会自动处理number、string、boolean、date等类型数据； table_to_sheet: 将一个table dom直接转成sheet，会自动识别colspan和rowspan并将其转成对应的单元格合并； json_to_sheet: 将一个由对象组成的数组转成sheet； aoa_to_sheet示例：1234567var aoa = [ ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()]];var sheet = XLSX.utils.aoa_to_sheet(aoa);openDownloadDialog(sheet2blob(sheet), '导出.xlsx'); table_to_sheet就更简单了，直接XLSX.utils.table_to_sheet($(‘table’)[0])即可； 处理单元格合并一般来说，前端生成excel而不是csv最主要目的都是为了解决csv不能实现单元格合并的问题，要不然直接导出csv文件就好了，何必引入几百kb的插件。假设我们要生成如下格式的excel文件，其中A1-C1进行单元格合并：代码如下：123456789101112var aoa = [ ['主要信息', null, null, '其它信息'], // 特别注意合并的地方后面预留2个null ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()]];var sheet = XLSX.utils.aoa_to_sheet(aoa);sheet['!merges'] = [ // 设置A1-C1的单元格合并 &#123;s: &#123;r: 0, c: 0&#125;, e: &#123;r: 0, c: 2&#125;&#125;];openDownloadDialog(sheet2blob(sheet), '单元格合并示例.xlsx'); 需要注意的地方就是被合并的单元格要用null预留出位置，否则后面的内容（本例中是第四列其它信息）会被覆盖。 自定义样式普通版本不支持定义字体、颜色、背景色等，有这个功能需要的可以使用pro版，好像是要收费的，因为官网没看到下载地址。 总结上面的代码在上传本地excel文件转换时候没什么问题，但是在用ajax请求的excel文件在转换时，chrome浏览器报错，firefox和opera正常。我觉得问题出在我是用的excel的版本上，我在网上下载的excel文件就可以正常解析，这里要注意哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"ES6-Symbol.iterator 迭代器","slug":"ES6-Symbol-iterator-迭代器","date":"2019-07-30T08:51:28.000Z","updated":"2024-01-11T07:00:59.117Z","comments":true,"path":"2019/07/30/ES6-Symbol-iterator-迭代器/","link":"","permalink":"/2019/07/30/ES6-Symbol-iterator-迭代器/","excerpt":"ES6-Symbol.iterator 迭代器原理剖析","text":"ES6-Symbol.iterator 迭代器原理剖析 ES6-Symbol.iterator 迭代器一个数据结构只要部署了Symbol.iterator属性就能使用 for…of遍历 与 …运算符 操作Object身上没有Symbol.iterator，当直接使用时会报错123456789let obj = &#123; 0: 'a', 1: 'b', 2: 'c',&#125;console.log([...obj])//报错obj is not iterable &lt;br&gt; 在没有Symbol.iterator方法下运行for(let p of obj)&#123; console.log(p);//TypeError: obj is not iterable&#125; Array身上天生具备Symbol.iterator123let arr = [1,2,3,4];// 数组，天生具备Symbol.iterator方法所以可以使用console.log([...arr]);//(4) [1, 2, 3, 4] 而我们Object需要用到…运算符 与 for of遍历怎么办呢如果我们要使用它的话，Object身上需要有一个Symbol.iterator属性代码如下：123456789101112131415161718192021222324let obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: function () &#123; // index用来记遍历圈数 let index = 0; let next = () =&gt; &#123; return &#123; value: this[index], done: this.length == ++index &#125; &#125; return &#123; next &#125; &#125;&#125;// console.log(obj.length)console.log([...obj]);//(2) [\"a\", \"b\"]for(let p of obj)&#123; console.log(p) //\"a\" \"b\"&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端touch事件简介","slug":"移动端touch事件简介","date":"2019-07-30T06:11:43.000Z","updated":"2024-01-11T07:00:59.275Z","comments":true,"path":"2019/07/30/移动端touch事件简介/","link":"","permalink":"/2019/07/30/移动端touch事件简介/","excerpt":"移动端的touch事件的简单入门介绍","text":"移动端的touch事件的简单入门介绍 移动端touch事件简介touch事件首先 touch 包含三类事件，它们分别是：touchstart、touchmove、touchend 。 touchstart：手指触摸到一个 DOM 元素时触发。 touchmove：手指在一个 DOM 元素上滑动时触发。 touchend：手指从一个 DOM 元素上移开时触发。 这三个事件又分别对应三个相同的触摸列表： touches：正在触摸屏幕的所有手指的一个列表。 targetTouches：正在触摸当前 DOM 元素上的手指的一个列表。 changedTouches：涉及当前事件的手指的一个列表。 touch事件属性事件对应的三个列表虽然名字不一样，但是它们里面装的东西都是差不多的，包含了当前事件的一些相关信息，比如：一些坐标信息。1234567891011clientX:65 // 触摸点在浏览器窗口中的横坐标clientY:18 // 触摸点在浏览器窗口中的纵坐标force:1 // 触摸点压力大小identifier:0 // 触摸点唯一标识（ID）pageX:65 // 触摸点在页面中的横坐标pageY:18 // 触摸点在页面中的纵坐标radiusX:11.5 // 触摸点椭圆的水平半径radiusY:11.5 // 触摸点椭圆的垂直半径rotationAngle:0 // 旋转角度screenX:560 // 触摸点在屏幕中的横坐标screenY:175 // 触摸点在屏幕中的纵坐标 上面就是一个 TouchList 列表。它对应的就是前面提到的三种事件（touchstart、touchmove、touchend）中的一种，在触发时生成的一个对象列表。列表里最有用的就是 Touch 对象了，Touch 对象里存放着对应事件的一些相关的信息，我们就是通过这种个事件里这些属性的有机结合来实现各种效果。通过上面的 radiusX，radiusY，rotationAngle 这三个属性就可以计算出你的手指触摸手机屏幕时的一个接触面，只不过这个接触面是用一个近似的椭圆来表示，也就是说它不是一个真正意义上的接触面，而是一个大概的接触面。相信心细的朋友应该会看到 TouchList 对象里有一个 length 属性，并且它的值为 1 ，这说明当前只有一个手指触发了事件（比如：touchstart 事件），换句话说，此时你只有一个手指放到了手机屏幕上，这个手指对应的一些信息存放在 Touch 对象里。因为只有一个手指放在了屏幕上，所以这个 TouchList 里只有一个 Touch 对象，并且是第一个下标为 0 。TouchList 列表里还有一个 target 属性，这个应该很好理解，就是触摸的目标。为了让你能更加立体地理解上面的这些属性，我专门从网上找了一段话来作为补充： 来自 mozilla 1.Touch.identifier：此 Touch 对象的唯一标识符。 一次触摸动作(我们指的是手指的触摸)在平面上移动的整个过程中，该标识符不变。 可以根据它来判断跟踪的是否是同一次触摸过程，此值为只读属性。 2.Touch.screenX：触点相对于屏幕左边沿的X坐标。只读属性。 3.Touch.screenY：触点相对于屏幕上边沿的Y坐标。只读属性。 4.Touch.clientX：触点相对于可见视区(visual viewport)左边沿的X坐标。不包括任何滚动偏移。只读属性。 5.Touch.clientY：触点相对于可见视区(visual viewport)上边沿的Y坐标。不包括任何滚动偏移。只读属性。 6.Touch.pageX：触点相对于HTML文档左边沿的X坐标。当存在水平滚动的偏移时，这个值包含了水平滚动的偏移。只读属性。 7.Touch.pageY：触点相对于HTML文档上边沿的Y坐标。当存在水平滚动的偏移时，这个值包含了垂直滚动的偏移。只读属性。 8.Touch.radiusX：能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴)半径。这个值的单位和 screenX 相同。只读属性。 9.Touch.radiusY：能够包围用户和触摸平面的接触面的最小椭圆的垂直轴(Y轴)半径。这个值的单位和 screenY 相同。只读属性。 10.Touch.rotationAngle：它是这样一个角度值：由radiusX 和 radiusY描述的正方向的椭圆，需要通过顺时针旋转这个角度值，才能最精确地覆盖住用户和触摸平面的接触面。只读属性。 11.Touch.force：手指挤压触摸平面的压力大小，从0.0(没有压力)到1.0(最大压力)的浮点数。只读属性。 12.Touch.target：当这个触点最开始被跟踪时(在 touchstart 事件中)，触点位于的HTML元素。哪怕在触点移动过程中，触点的位置已经离开了这个元素的有效交互区域，或者这个元素已经被从文档中移除。需要注意的是，如果这个元素在触摸过程中被移除，这个事件仍然会指向它，但是不会再冒泡这个事件到 window 或 document 对象。因此，如果有元素在触摸过程中可能被移除，最佳实践是将触摸事件的监听器绑定到这个元素本身，防止元素被移除后，无法再从它的上一级元素上侦测到从该元素冒泡的事件。只读属性。 总结这里只是简单地介绍了一下移动端的touch事件，主要还是记住touchstart，touchmove，touchend这三个事件，还有事件里的touches，targetTouches，changedTouches这三个属性，我们尝试用的还是targetTouches,touches的兼容性不好，一般我们不使用。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"你真的了解回流和重绘吗?","slug":"你真的了解回流和重绘吗","date":"2019-07-29T08:03:47.000Z","updated":"2024-01-11T07:00:59.254Z","comments":true,"path":"2019/07/29/你真的了解回流和重绘吗/","link":"","permalink":"/2019/07/29/你真的了解回流和重绘吗/","excerpt":"你真的了解回流和重绘吗","text":"你真的了解回流和重绘吗 你真的了解回流和重绘吗回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是我之前一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合一些例子，写了这篇文章，希望可以帮助到大家。 浏览器的渲染过程本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自MDN） 从上面这个图上，我们可以看到，浏览器渲染过程如下： 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客） 渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。 生成渲染树 为了构建渲染树，浏览器主要完成了以下工作： 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 注意：渲染树只包含可见的节点 回流前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"width: 50%\"&gt; &lt;div style=\"width: 50%\"&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图） 重绘最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。 既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。 何时发生回流重绘我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 注意：回流一定会触发重绘，而重绘不一定会回流 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 浏览器的优化机制现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 减少回流和重绘好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。 最小化重绘和重排由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子 1234const el = document.getElementById('test');el.style.padding = '5px';el.style.borderLeft = '1px';el.style.borderRight = '2px'; 例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。 因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式： 使用cssText 12const el = document.getElementById('test');el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; 修改CSS的class 12const el = document.getElementById('test');el.className += ' active'; 批量修改DOM当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。 有三种方式可以让DOM脱离文档流： 隐藏元素，应用修改，重新显示 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 考虑我们要执行一段批量插入节点的代码： 1234567891011function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');appendDataToElement(ul, data); 如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。 我们可以使用这三种方式进行优化: 隐藏元素，应用修改，重新显示 这个会在展示和隐藏节点的时候，产生两次重绘 123456789101112function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档 1234const ul = document.getElementById('list');const fragment = document.createDocumentFragment();appendDataToElement(fragment, data);ul.appendChild(fragment); 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 1234const ul = document.getElementById('list');const clone = ul.cloneNode(true);appendDataToElement(clone, data);ul.parentNode.replaceChild(clone, ul); 对于上述那种情况，我写了一个demo来测试修改前和修改后的性能。然而实验结果不是很理想。 原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。 避免触发同步布局事件上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码： 12345function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px'; &#125;&#125; 这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为: 123456const width = box.offsetWidth;function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px'; &#125;&#125; 同样，我也写了个demo来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比差距就比较明显。 对于复杂动画效果,使用绝对定位让其脱离文档流对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个例子。 打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。 从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。 css3硬件加速（GPU加速）比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！ 划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。 如何使用常见的触发硬件加速的css属性： transform opacity filters Will-change 效果我们可以先看个例子。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图： 从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。 重点 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 css3硬件加速的坑 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 总结本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。 参考文献 渲染树构建、布局及绘制 高性能Javascript 文章出处-&gt;博客地址, 欢迎给个 start 或 follow","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"模块化CommonJS与AMD的手写实现","slug":"模块化CommonJS与AMD的手写实现","date":"2019-07-24T08:34:06.000Z","updated":"2024-01-11T07:00:59.272Z","comments":true,"path":"2019/07/24/模块化CommonJS与AMD的手写实现/","link":"","permalink":"/2019/07/24/模块化CommonJS与AMD的手写实现/","excerpt":"javascript模块化CommonJS与AMD是如何实现的","text":"javascript模块化CommonJS与AMD是如何实现的 模块化CommonJS与AMD的手写实现现在的前端开发都采用的模块化思想，之前都是使用全局变量，但是弊端这里就不过多描述了。模块化有CommonJS,AMD,CMD,ES6的模块新规范这4种，今天我们来实现以下CommonJS和AMD的规范。 CommonJS首先，CommonJS一般都用在nodejs里，写法如下:12345// 导入const someFun= require('./moduleA');someFun();// 导出module.exports = someFunc; 我们来看一下简单的实现方法123456789101112131415161718// a.jslet fs = require('fs');let path = require('path');let b = req('./b.js');function req(mod) &#123; let filename = path.join(__dirname, mod); let content = fs.readFileSync(filename, 'utf8'); let fn = new Function('exports', 'require', 'module', '__filename', '__dirname', content + '\\n return module.exports;'); let module = &#123; exports: &#123;&#125; &#125;; return fn(module.exports, req, module, __filename, __dirname);&#125;// b.jsconsole.log('bbb');exports.name = 'zfpx'; AMD我们再来看看AMD规范，AMD规范的实现库是大名鼎鼎requirejs1234567891011// 定义一个模块define('a', [], function () &#123; return 'a';&#125;);define('b', ['a'], function (a) &#123; return a + 'b';&#125;);// 导入和使用require(['b'], function (b) &#123; console.log(b);&#125;); 简单的实现1234567891011121314151617let factories = &#123;&#125;;function define(modName, dependencies, factory) &#123; factory.dependencies = dependencies; factories[modName] = factory;&#125;function require(modNames, callback) &#123; let loadedModNames = modNames.map(function (modName) &#123; let factory = factories[modName]; let dependencies = factory.dependencies; let exports; require(dependencies, function (...dependencyMods) &#123; exports = factory.apply(null, dependencyMods); &#125;); return exports; &#125;) callback.apply(null, loadedModNames);&#125; ES6 模块化ES6 模块化是ECMA提出的JavaScript模块化规范，它在语言的层面上实现了模块化。浏览器厂商和Node.js 都宣布要原生支持该规范。它将逐渐取代CommonJS和AMD`规范，成为浏览器和服务器通用的模块解决方案。 采用 ES6 模块化导入及导出时的代码如下1234// 导入import &#123; name &#125; from './person.js';// 导出export const name = 'zfpx'; ES6模块虽然是终极模块化方案，但它的缺点在于目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"javascript的FileReader类","slug":"javascript的FileReader类","date":"2019-07-24T06:23:49.000Z","updated":"2024-01-11T07:00:59.195Z","comments":true,"path":"2019/07/24/javascript的FileReader类/","link":"","permalink":"/2019/07/24/javascript的FileReader类/","excerpt":"javascript的FileReader类","text":"javascript的FileReader类 javascript的FileReader类2019-07-24内容现在，我们在前端对文件处理的需求已经慢慢增加了，比如，前端上传图片的回显，还有excel文件的解析等，都需要FileReader这个类来实现，这个类有4个方法: FileReader.readAsBinaryString(Blob|File) FileReader.readAsText(Blob|File, opt_encoding) FileReader.readAsDataURL(Blob|File) FileReader.readAsArrayBuffer(Blob|File) 这里，具体的使用方法不过多介绍，详情点击这里 2019-10-29追加内容readAsArrayBuffer=&gt;ArrayBuffer二进制数据的存储器,可通过ArrayBufferView以8位、16位、32位、64位数字为元素对ArrayBuffer内的二进制数据进行展现。可用于生成Blob,然后添加到FormData去上传。 readAsBinaryString =&gt;BinaryString是二进制数据直接以byte的形式展现的字符串,ArrayBuffer对应的Uint8Array的字符形式的表现 readAsDataURL =&gt;DataURL包括mimeType和base64编码后的binaryString,可以直接给使用：data:[mimeType];base64,[base64(binaryString)]可借此获取mimeType和binaryStringvar binaryString = atob(dataUrl.split(‘,’)[1]),mimeType = dataUrl.split(‘,’)[0].match(/:(.*?);/)[1]; 说一个截图上传的小例子 canvas截图并使用toDataURL,获取DataURL 通过binaryString = atob(dataUrl.split(‘,’)[1])获取BinaryString 通过Uint8Array和charCodeAt把binaryString转化为ArrayBuffer ArrayBuffer存入Blob并添加到FormData上传,服务器最终收到BinaryString 注意,formdata在send时必须使用ArrayBuffer,因为BinaryString为字符串,当send发送时会对字符串进行utf8编码导致数据被破坏。demo:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name='test'&gt; &lt;input type=\"file\" name='file'&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;img src=\"\" alt=\"\"&gt; &lt;script&gt; var img = document.querySelector('img'), preview; document.test.file.addEventListener('change', function() &#123; var fr = new FileReader(); fr.onload = function() &#123; preview = this.result; img.src = preview; &#125;; fr.readAsDataURL(this.files[0]); &#125;) document.test.addEventListener('submit', function(e) &#123; e.preventDefault(); var binaryString = atob(preview.split(',')[1]), mimeType = preview.split(',')[0].match(/:(.*?);/)[1], length = binaryString.length, u8arr = new Uint8Array(length), blob, fd = new FormData(), xhr = new XMLHttpRequest(); while(length--) &#123; u8arr[length] = binaryString.charCodeAt(length); &#125; blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;); fd.append('file', blob); xhr.open('post', '/upload'); xhr.send(fd); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端利用hammer制作移动缩放旋转功能","slug":"移动端利用hammer制作移动缩放旋转功能","date":"2019-07-16T01:43:08.000Z","updated":"2024-01-11T07:00:59.276Z","comments":true,"path":"2019/07/16/移动端利用hammer制作移动缩放旋转功能/","link":"","permalink":"/2019/07/16/移动端利用hammer制作移动缩放旋转功能/","excerpt":"移动端利用hammer制作移动缩放旋转功能","text":"移动端利用hammer制作移动缩放旋转功能 移动端利用hammer制作移动缩放旋转功能最近在项目中，有个需求是页面放大，我二话不说，直接把viewport的user-scalable属性设为yes，这倒是勉强的完成了需求的要求，但是这只是整个页面的缩放，而且初始上来的页面只能放大，并不能缩小，如果再加点需求，局部放大，这就挂了。。。。。。于是乎，这几天有空闲的时候补了补关于移动端手势事件的一些知识，为了完成这几项功能，最终选了hammer这个插件，其实这类插件很多，大同小异，选一个稳定点，普及广的，还在维护的就行。当然了，不用插件，自己用原生的touchstart,touchmove,touchend事件也可以完成，但是各种算法还是很复杂的。下面是几个例子： 元素的缩放123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./hammer.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"./vconsole.min.js\"&gt;&lt;/script&gt; --&gt; &lt;style&gt; #myElement &#123; background: silver; height: 300px; text-align: center; font: 30px/300px Helvetica, Arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myElement\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // var vConsole = new VConsole(); var scale = 1, old_scale; var myElement = document.getElementById('myElement'); var mc = new Hammer.Manager(myElement); // pinch var pinch = new Hammer.Pinch(); // add to the Manager mc.add([pinch]); // pinch事件 mc.on(\"pinchstart\", function(ev) &#123; // 注意这里1 old_scale = scale; &#125;); mc.on(\"pinchmove\", function(ev) &#123; // 注意这里2 scale =ev.scale + old_scale-1; // myElement.style.transform = `scale($&#123;scale&#125;)`; updateTransform(); &#125;); // 更新样式函数 function updateTransform() &#123; var val = [ `scale($&#123;scale&#125;)` // `rotate(`+deg+`deg)` ]; myElement.style.transform = val.join(' '); &#125;&lt;/script&gt;&lt;/html&gt; 元素的旋转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./hammer.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"./vconsole.min.js\"&gt;&lt;/script&gt; --&gt; &lt;style&gt; #myElement &#123; background: silver; height: 300px; text-align: center; font: 30px/300px Helvetica, Arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myElement\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // var vConsole = new VConsole(); var deg = 0, init_deg=0, rotate_deg, start_deg, pre_deg, flag_deg; var myElement = document.getElementById('myElement'); var mc = new Hammer.Manager(myElement); // rotate var rotate = new Hammer.Rotate(); // add to the Manager mc.add([rotate]); // rotate事件 mc.on(\"rotatestart\", function(ev) &#123; // 注意这里1 start_deg = ev.rotation; // 开始旋转时记录下当前rotation的角度 flag_deg = 0; &#125;); mc.on(\"rotatemove\", function(ev) &#123; // 注意这里2 rotate_deg = ev.rotation - start_deg; // rotation的角度减去开始旋转的角度就是转过了多少角度 deg = init_deg + rotate_deg; // 元素旋转之前的角度 + 旋转了多少角度是当前元素的状态 // myElement.style.transform = `rotate(`+deg+`deg)`; updateTransform(); &#125;); mc.on(\"rotateend\", function(ev) &#123; // 注意这里3 init_deg = deg; // 旋转结束时别忘了把当前角度状态赋值给初始化角度，以便下次旋转时接着上次的角度转 &#125;); // 更新样式函数 function updateTransform() &#123; var val = [ // `scale($&#123;scale&#125;)` `rotate(`+deg+`deg)` ]; myElement.style.transform = val.join(' '); &#125;&lt;/script&gt;&lt;/html&gt; 最后，附上一个拖拽，缩放，旋转的 拖拽，缩放，旋转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./hammer.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"./vconsole.min.js\"&gt;&lt;/script&gt; --&gt; &lt;style&gt; #myElement &#123; background: silver; width: 250px; height: 250px; text-align: center; font: 30px/300px Helvetica, Arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myElement\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var reqAnimationFrame = (function () &#123; return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;; &#125;)(); var el = document.querySelector(\"#myElement\"); var START_X = Math.round((window.innerWidth - el.offsetWidth) / 2); var START_Y = Math.round((window.innerHeight - el.offsetHeight) / 2); var ticking = false; var transform; //图像效果 var timer; var initAngle = 0; //旋转角度 var initScale = 1; //放大倍数 var mc = new Hammer.Manager(el); //用管理器 可以同时触发旋转 拖拽 移动 //var mc = new Hammer(el); //旋转和移动互斥 /** ev.srcEvent.type touchstart touchend touchmove ev.deltaX 手势移动位移变量 */ mc.add(new Hammer.Pan(&#123; threshold: 0, pointers: 0 &#125;)); mc.add(new Hammer.Rotate(&#123; threshold: 0 &#125;)).recognizeWith(mc.get('pan')); mc.add(new Hammer.Pinch(&#123; threshold: 0 &#125;)).recognizeWith([mc.get('pan'), mc.get('rotate')]); //结束时做一些处理 mc.on(\"hammer.input\", function(ev) &#123; if(ev.isFinal) &#123; console.log(START_X+\" \"+transform.translate.x +\" \"+ev.deltaX); START_X = transform.translate.x ; START_Y = transform.translate.y ; &#125; &#125;); mc.on(\"panstart panmove\", onPan); mc.on(\"rotatestart rotatemove rotateend\", onRotate); mc.on(\"pinchstart pinchmove\", onPinch); /** 第二次进入拖拽时 delta位移重置 移动时 初始位置startxy不动。delta增加 */ function onPan(ev)&#123; if(!ev.isFinal) &#123; el.className = ''; console.log(START_X +\" \"+ START_Y +\" | \"+ev.deltaX +\" \"+ ev.deltaY); transform.translate = &#123; x: START_X + ev.deltaX, y: START_Y + ev.deltaY &#125;; requestElementUpdate(); &#125; &#125; function onPinch(ev)&#123; if(ev.type == 'pinchstart') &#123; initScale = transform.scale || 1; &#125; el.className = ''; transform.scale = initScale * ev.scale; requestElementUpdate(); &#125; //旋转相关 var preAngle =0 ; var tempAngleFlag=0; var deltaAngle = 0; var startRotateAngle = 0; function onRotate(ev) &#123; //点下第二个触控点时触发 if(ev.type == 'rotatestart') &#123; startRotateAngle = ev.rotation ; tempAngleFlag = 0 ; &#125; if(ev.type == 'rotatemove')&#123; if(tempAngleFlag == 0)&#123; preAngle = startRotateAngle; tempAngleFlag ++; &#125;else&#123; deltaAngle = ev.rotation - preAngle; el.className = ''; transform.rz = 1; //非0 垂直xy轴 transform.angle =initAngle + deltaAngle; requestElementUpdate(); &#125; &#125; //旋转结束 记录当前图片角度 if(ev.type =='rotateend')&#123; initAngle = transform.angle; &#125; &#125; function updateElementTransform() &#123; var value = [ 'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)', 'scale(' + transform.scale + ', ' + transform.scale + ')', 'rotate3d('+ transform.rx +','+ transform.ry +','+ transform.rz +','+ transform.angle + 'deg)' ]; value = value.join(\" \"); el.style.webkitTransform = value; /*为Chrome/Safari*/ el.style.mozTransform = value; /*为Firefox*/ el.style.transform = value; /*IE Opera?*/ ticking = false; &#125; function requestElementUpdate() &#123; if(!ticking) &#123; reqAnimationFrame(updateElementTransform); ticking = true; &#125; &#125; /** 初始化设置 */ function resetElement() &#123; el.className = 'animate'; transform = &#123; translate: &#123; x: START_X, y: START_Y &#125;, scale: 1, angle: 0, rx: 0, ry: 0, rz: 0 &#125;; requestElementUpdate(); &#125; resetElement();&lt;/script&gt;&lt;/html&gt; 最后，附上github源码地址，点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"实现一个串行异步执行类","slug":"实现一个串行异步执行类","date":"2019-07-08T05:56:34.000Z","updated":"2024-01-11T07:00:59.265Z","comments":true,"path":"2019/07/08/实现一个串行异步执行类/","link":"","permalink":"/2019/07/08/实现一个串行异步执行类/","excerpt":"写一个按顺序执行操作的类工具","text":"写一个按顺序执行操作的类工具 实现一个串行异步执行类今天在学习webpack源码时，看到了webpack的核心模块tapable，里边有很多方法，其中之一就是串行异步执行方法，于是，自己准备实现一个简单的，其实很简单，见下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 声明类SerialAsyncfunction SerialAsync() &#123; this.arrFns = [];&#125;// 原型链上添加addFn方法SerialAsync.prototype.addFn = function(fn) &#123; this.arrFns.push(fn);&#125;// 原型链上添加emitFn方法SerialAsync.prototype.emitFn = function(callback) &#123; let self = this; let index = 0; // next是核心代码 function next(par) &#123; let fn = self.arrFns[index++]; fn?fn(next):callback(par); &#125; next();&#125;// SerialAsync结束// 是不是超级的简单，就15行代码，记住，核心代码是next方法// 下面是具体的使用var s = new SerialAsync();s.addFn(function(done)&#123; setTimeout(function()&#123; console.log(1); done(1); &#125;, 1000)&#125;);s.addFn(function(done)&#123; setTimeout(function()&#123; console.log(2); done(2); &#125;, 2000);&#125;);s.addFn(function(done)&#123; setTimeout(function()&#123; console.log(5); done(2); &#125;, 5000);&#125;);console.time();s.emitFn((par)=&gt;&#123; console.log('over-&gt;', par); console.timeEnd();&#125;); 可以看到，最关键部分就是next函数，有个递归的过程，据说，nodejs中很多类似的串行方法都是这么实现的，一定要记住哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"js中小数精度问题","slug":"js中小数精度问题","date":"2019-07-04T03:13:00.000Z","updated":"2024-01-11T07:00:59.196Z","comments":true,"path":"2019/07/04/js中小数精度问题/","link":"","permalink":"/2019/07/04/js中小数精度问题/","excerpt":"js中的小数精度问题分析","text":"js中的小数精度问题分析 js中小数精度问题我们在日常开发中，是否遇到过0.1+0.2，一看马上答案就出来了，0.3啊，多么简单的加法，但是，如果你在代码里运行一下，结果出乎意料哦，是0.30000000000000004，哈哈，有意思吧，不仅在js中这样，java，python等语言都是这个德行。奇怪了，这是为什么呢？这就需要了解一下小数在计算机中的存储方式了。我在这里只说小数部分的保存方式。先来说一下小数如何存储，如0.6： 将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，直到小数部分为0。 特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因再具体的分步骤看一下：1234560.6 * 2 = 1.2 —————— 1 0.2 * 2 = 0.4 —————— 0 0.4 * 2 = 0.8 —————— 0 0.8 * 2 = 1.6 —————— 1 0.6 * 2 = 1.2 —————— 1 ………… 我们可以发现在该计算中已经出现了循环，0.6用二进制表示为 1001 1001 1001 1001 ……如果是10.6，那个10.6的完整二进制表示为 1010.100110011001……通过上边的解释，就知道为什么有的小数在js里会出现精度不准的问题了吧，接下来，我们再看看二进制小数如何还原成十进制。我们还拿0.6这个小数来举例子,1001 1001 1001 1001 : 从左到右，v[i] * 2^( - i ), i 为从左到右的index，v[i]为该位的值，直接看例子，很直接的10.6 = 1 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 + 1 * 2^-4 + …… 好了，通过上面大概的了解了小数为什么精度有时候不准的问题，这也只是粗略的理解一下而已，具体在各种语言中运行时可能情况会很复杂，我就点到而止了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"递归浅析","slug":"js中的递归总结","date":"2019-07-02T01:54:14.000Z","updated":"2024-01-11T07:00:59.197Z","comments":true,"path":"2019/07/02/js中的递归总结/","link":"","permalink":"/2019/07/02/js中的递归总结/","excerpt":"js中一些递归的demo","text":"js中一些递归的demo 递归的简单入门数字递归(最简单)12345678910111213141516171819// 加法的递归function sum(num)&#123; if (num === 0) &#123; return 0; &#125; else &#123; return num + sum(--num) &#125;&#125;sum(4); // 10// 再来一个阶乘的递归function fn(num) &#123; if(num === 1) &#123; return 1; &#125;else &#123; return num*fn(num-1) &#125;&#125;fn(5) // 120 数组递归12345678910// 数组中的各个元素相加之和function fn(arr) &#123; if(arr.length === 1) &#123; return arr[0]; &#125;else &#123; var val = arr.shift(); return val + fn(arr); &#125;&#125;fn([1,2,3,4,6,5,7,8,9,10]) // 55 123456789101112131415161718// 将嵌套的多维数组转成一维数组var arr = [1,2,3,[4,5,6,[7,[8,[9,10]]]],11,[12]];function transformArr(arr) &#123; var newArr = []; recursiveArr(arr, newArr); return newArr;&#125;function recursiveArr(arr, newArr) &#123; arr.forEach(function(item) &#123; if(item instanceof Array) &#123; recursiveArr(item, newArr); &#125;else &#123; newArr.push(item); &#125; &#125;);&#125;console.log(transformArr(arr), '@_@');// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 一维数组，元素都是对象，互相有父子关系，将这些数组转换成父子结构的对象格式// 数据，parentId是其父节点的id var data = [ &#123; name: '数据1', id: 11, parentId: 1 &#125;, &#123; name: '数据2', id: 12, parentId: 11 &#125;, &#123; name: '数据3', id: 13, parentId: 11 &#125;, &#123; name: '数据4', id: 14, parentId: 12 &#125;, &#123; name: '数据5', id: 15, parentId: 13 &#125;, &#123; name: '数据6', id: 16, parentId: 15 &#125;, &#123; name: '数据7', id: 17, parentId: 16 &#125;, &#123; name: '数据8', id: 18, parentId: 16 &#125;,];// transformData这个函数是辅助生成对象的函数function transformData(data, parentId) &#123; var obj = &#123; children: [] &#125;; generaterTree(data, obj, 1); return obj;&#125;// generaterTree这个函数是递归调用的核心函数function generaterTree(data, obj, parentId) &#123; data.forEach(item=&gt; &#123; item.children = item.children?item.children:[]; if(item.parentId === parentId) &#123; obj.children.push(item); generaterTree(data, item, item.id); // 继续递归回调 &#125; &#125;);&#125; console.log(transformData(data)); 对象的递归 对象的递归里边也包含了数组等的一些基础型数据，常用的就是对象的深拷贝 1234567891011121314151617181920212223242526var data = &#123; \"name\": \"jinux\", \"like\": [\"football\",\"basketball\",\"voliball\"], \"work\": &#123; \"company\": \"technology\", \"address\": \"hunnan\", \"tongshi\": [\"lining\",\"lvnan\"], \"isLeader\": false &#125;&#125;function deepClone(data) &#123; if(typeof data !== 'object') &#123; return data; &#125; if(data === null) &#123; return data; &#125; var obj = Object.prototype.toString.call(data)==='[object Array]'? []:&#123;&#125;; for(var key in data) &#123; obj[key] = arguments.callee(data[key]); // obj[key] = deepClone(data[key]); 与上边的一个意思 &#125; return obj;&#125;console.log(deepClone(data), \"&lt;-&gt;\"); 常用递归demo demo所使用数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445const data = [ &#123; id: 1, name: &apos;A&apos;, type: &apos;admin&apos;, children: [ &#123; id: 2, name: &apos;A_1&apos;, type: &apos;admin&apos;, children: [ &#123; id: 3, name: &apos;A_1_1&apos;, type: &apos;user&apos;, &#125; ] &#125;, &#123; id: 4, name: &apos;A_2&apos;, type: &apos;user&apos;, &#125;, ] &#125;, &#123; id: 5, name: &apos;B&apos;, type: &apos;admin&apos;, children: [ &#123; id: 6, name: &apos;B_1&apos;, type: &apos;user&apos;, children: [ &#123; id: 7, name: &apos;B_1_1&apos;, type: &apos;admin&apos;, &#125; ] &#125; ] &#125;] 深度优先遍历 通过id查节点 1234567891011const tree = (root, id) =&gt; &#123; if (!root || !root.length) return; for (const item of root) &#123; if (id === item.id)&#123; return item; &#125; const find = tree(item.children, id) if (find) return find; &#125;&#125; 广度优先遍历 通过id查节点 123456789101112131415const tree = (root, id) =&gt; &#123; if (!root || !root.length) return for (const item of root) &#123; if (id === item.id)&#123; return item &#125; &#125; const childrens = root.reduce((total, current) =&gt; &#123; return total.concat(current.children || []) &#125;,[]) return tree(childrens, id)&#125; 打平树形结构123456789101112131415161718192021// 方法一const flatten = (tree) =&gt; &#123; let list = [] tree.forEach(node =&gt; &#123; const &#123;children, ...obj&#125; = node list.push(obj) if (children &amp;&amp; children.length)&#123; const tempList = flatten(children) list.push(...tempList) &#125; &#125;) return list&#125;// 方法二const flatten = (tree) =&gt; &#123; return (tree|| [ ]).reduce((total, current) =&gt; &#123; const &#123;children, ...obj&#125; = current return total.concat(obj, flatten(children)) &#125;, [])&#125; 根据id获取父节点123456789101112function findParentByChildId(data, id, list, parent) &#123; for(let i=0; i&lt;data.length; i++) &#123; let item = data[i]; if(item.id==id&amp;&amp;parent) list.push(parent); if(item.children&amp;&amp;item.children.length) &#123; findParentByChildId(item.children, id, list, item); &#125; &#125; return list[0] || null;&#125;findParentByChildId(data, 3, [], null); 深度过滤12345678910const formatTree = (root) =&gt; &#123; return (root || []).filter(node =&gt; node.type === 'admin').map(node =&gt; &#123; const &#123; children &#125; = node return &#123; ...node, children: formatTree(children) &#125; &#125;)&#125;// 只保留type是admin的节点","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}]},{"title":"快速创建含有多个元素的数组","slug":"快速创建含有多个元素的数组","date":"2019-07-01T02:17:23.000Z","updated":"2024-01-11T07:00:59.270Z","comments":true,"path":"2019/07/01/快速创建含有多个元素的数组/","link":"","permalink":"/2019/07/01/快速创建含有多个元素的数组/","excerpt":"快速并且简单的创建数组","text":"快速并且简单的创建数组 快速创建含有多个元素的数组我们平时在开发时，有时候可能会创建一个包含20个元素的数组，之后对这个数组进行加工操作，来制作一个符合业务要求的数组。12345// 比如我要创建一个包含20个元素的数组var arr = [];for(var 1=0; i&lt;20; i++) &#123; arr.push(undefined);&#125; 上面虽然创建了数组，但是感觉麻烦了点。123456var arr = new Array(20);// 这样创建的数组，只是有长度，但是数组里并没有元素arr.length // 200 in arr // false// arr 这个数组使用map， forEach等方法是便利不了的// 创建一个长度为20的数组，注意该数组的元素并没有被初始化 好了，有几种方便的创建方式，见下面123456789// 首先，看一下vue官网里出现的创建方式Array.apply(null, &#123;length: 20&#125;); // ES5开始apply函数的第二个参数除了可以是数组外，还可以是类数组对象（即包含length属性，且length属性值是个数字的对象）// 这里顺便说一下&#123;length: 20&#125;这个参数的作用function fn() &#123; console.log(arguments)&#125;fn(undefined,undefined,undefined);fn.apply(null, &#123;length: 3&#125;);// 通过上面的代码，就可以看出来&#123;length: 3&#125;这个参数的含义了吧 最后，总结一下可以快速创建有初始值得数组方法123456// 1Array.apply(null, &#123;length: 20&#125;);// 2Array.from(&#123;length: 20&#125;)// 3Array(20).fill(undefined)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"手写前端自动化构建工具","slug":"手写前端自动化构建工具","date":"2019-06-26T03:13:33.000Z","updated":"2024-01-11T07:00:59.271Z","comments":true,"path":"2019/06/26/手写前端自动化构建工具/","link":"","permalink":"/2019/06/26/手写前端自动化构建工具/","excerpt":"写一个自己的前端自动化构建工具","text":"写一个自己的前端自动化构建工具 手写前端自动化构建工具现在我们使用vue，react等框架来开发已经很普遍了，当我们初始化一个项目的时候，是不是在命令行下按照提示一步一步的操作，最后在本地生成了一个现成的项目，是不是感觉很快捷，很方便，用来生成这个项目的工具就叫做构建工具（有的也称之为脚手架工具）。我现在需要在命令行下进行各种操作，交互，npm上已经有人写好了这类工具，常用的就是commander和inquirer,使用它们来开发脚手架，真的是好简单。我写了两个小demo，一个是围绕着commander，另一个则是围绕inquirer。这两个小例子都很简单，可以根据具体的要求组合到一起。点这里看源码select-list.js这个文件的功能是，可以根据列表的上下选择，下载github上对应的项目模板。init-commander.js这个文件的功能是，命令行里传入的文件夹名和文件名来生成新项目文件。题外话，这里还可以制作成系统命令，在package.json里的bin字段下。如果，都配置好了，就可以使用1npm link 这个命令，把bin字段下的内容生成系统命令，这是一种方式来生成系统命令，另一种应该是把这个项目发布到npm上，安装的时候直接全局安装就可以喽。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"javascript设计模式","slug":"javascript设计模式","date":"2019-06-24T02:16:13.000Z","updated":"2024-01-11T07:00:59.196Z","comments":true,"path":"2019/06/24/javascript设计模式/","link":"","permalink":"/2019/06/24/javascript设计模式/","excerpt":"基本上所有的设计模式都在这里了","text":"基本上所有的设计模式都在这里了 javascript设计模式其实，设计模式在前端，平时很少会遇到，这只是作为我们这些菜鸟前端来说，但是，对于那些高级的，写插件，库之类的前端童鞋来说，设计模式还是不可或缺的，这可是实实在在的会带入到项目中的哦。我只知道常见的几种，也都是为了应付面试的时候被问到，不过，今天我要终结一下，代码部分来源于网络，我只是整理一下，以备被问到时能够快速的回答出来。 1.灵活模式 2.面向对象编程 3.简单工厂模式 4.工厂方法模式 5.抽象工厂模式 6.建造者模式 7.原型模式 8.单例模式 9.外观模式 10.适配器模式 11.代理模式 12.装饰者模式 13.桥接模式 14.组合模式 15.享元模式 16.模板方法模式 17.观察者模式 18.状态模式 19.策略模式 20.职责链模式 21.命令模式 22.访问者模式 23.中介者模式 24.备忘录模式 25.迭代器模式 26.解释器模式 27.链式模式 28.委托模式 29.数据访问对象模式 30.节流模式 31.简单模板模式 32.惰性模式 33.参与者模式 34.等待者模式 35.同步模块模式 36.异步模块模式 37.widget模式 38.MVC模式 39.MVVM模式","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"写一个自己的富文本编辑器","slug":"写一个自己的富文本编辑器","date":"2019-06-22T08:42:09.000Z","updated":"2024-01-11T07:00:59.258Z","comments":true,"path":"2019/06/22/写一个自己的富文本编辑器/","link":"","permalink":"/2019/06/22/写一个自己的富文本编辑器/","excerpt":"写一个稍微复杂点的富文本编辑器","text":"写一个稍微复杂点的富文本编辑器 写一个自己的富文本编辑器前几天写了一个《简单的富文本编辑器》这篇博文，没想到刚过两天，项目中就需要自己写一个富文本编辑器。具体的需求是，在富文本编辑器中编辑好内容，存到数据库，之后app端拿到这些数据以webview的形式展示出来，当然，webview这块也是我来做，但是，在pc端编辑的内容直接放到移动端显示是有问题的，比如像图片大小问题，而且编辑的样式和展示出来的样式完全不一样。所以，我就想自己写一个，不用第三方的库，这样自己可以灵活的按照需求来修改。暂时写这个小插件只用了一天多，还不是很完善，有些地方还有待修改，如果有时间的话，以后会陆续更新。废话不多说，直接贴源码地址喽:jinux-editor这里有些注意的地方，比如把文字变成粗体，用到了1document.execCommand(\"bold\",false,null); 而取消粗体还是用到了这个命令，执行同一个命令，会切换字体的粗体和非粗体的状态。但是，这里注意，还有一个方法可以获取现在文本是否是粗体状态1document.queryCommandState('bold'); 可以用上面这个命令判断现在的状态，进而修改点击按钮的样式。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"base64加密原理","slug":"base64加密原理","date":"2019-06-20T00:30:09.000Z","updated":"2024-01-11T07:00:59.176Z","comments":true,"path":"2019/06/20/base64加密原理/","link":"","permalink":"/2019/06/20/base64加密原理/","excerpt":"你知道我们常用的base64是什么吗？","text":"你知道我们常用的base64是什么吗？ base64加密原理开发者对Base64编码肯定很熟悉，是否对它有很清晰的认识就不一定了。实际 上Base64已经简单到不能再简单了，如果对它的理解还是模棱两可实在不应该。大概介绍一下Base64的相关内容，花几分钟时间就可以彻底理解它。文 章下边贴了一个Base64的编解码器，方便阅读文章的同时来实验。 一. Base64编码由来 为什么会有Base64编码呢？因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就 不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情 况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。Base64编码应运而生，Base64就是一种 基于64个可打印字符来表示二进制数据的表示方法。 二. Base64编码原理 看一下Base64的索引表，字符选用了”A-Z、a-z、0-9、+、/“ 64个可打印字符。数值代表字符的索引，这个是标准Base64协议规定的，不能更改。64个字符用6个bit位就可以全部表示，一个字节有8个bit 位，剩下两个bit就浪费掉了，这样就不得不牺牲一部分空间了。这里需要弄明白的就是一个Base64字符是8个bit，但是有效部分只有右边的6个 bit，左边两个永远是0。那么怎么用6个有效bit来表示传统字符的8个bit呢？8和6的最小公倍数 是24，也就是说3个传统字节可以由4个Base64字符来表示，保证有效位数是一样的，这样就多了1/3的字节数来弥补Base64只有6个有效bit 的不足。你也可以说用两个Base64字符也能表示一个传统字符，但是采用最小公倍数的方案其实是最减少浪费的。结合下边的图比较容易理解。Man是三个 字符，一共24个有效bit，只好用4个Base64字符来凑齐24个有效位。红框表示的是对应的Base64，6个有效位转化成相应的索引值再对应 Base64字符表，查出”Man”对应的Base64字符是”TWFU”。说到这里有个原则不知道你发现了没有，要转换成Base64的最小单位就是三个字节，对一个字符串来说每次都是三个字节三个字节的转换，对应的是Base64的四个字节。这个搞清楚了其实就差不多了。 但是转换到最后你发现不够三个字节了怎么办呢？愿望终于实现了，我们可以用两 个Base64来表示一个字符或用三个Base64表示两个字符，像下图的A对应的第二个Base64的二进制位只有两个，把后边的四个补0就是了。所以 A对应的Base64字符就是QQ。上边已经说过了，原则是Base64字符的最小单位是四个字符一组，那这才两个字 符，后边补两个”=”吧。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。由此可见 Base64字符串只可能最后出现一个或两个”=”，中间是不可能出现”=”的。下图中字符”BC”的编码过程也是一样的。 三. 总结 说起Base64编码可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而Base64的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。 Base64编码主要用在传输、存储、表示二进制等领域，还可以用来加密，但是这种加密比较简单，只是一眼看上去不知道什么内容罢了，当然也可以对Base64的字符序列进行定制来进行加密。 Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二 进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"测试及爬虫工具nightmare","slug":"测试及爬虫工具nightmare","date":"2019-06-18T06:21:24.000Z","updated":"2024-01-11T07:00:59.272Z","comments":true,"path":"2019/06/18/测试及爬虫工具nightmare/","link":"","permalink":"/2019/06/18/测试及爬虫工具nightmare/","excerpt":"nightmare工具的使用","text":"nightmare工具的使用 测试及爬虫工具nightmarenightmare是一个可视化的页面操作工具，官网点这里如何安装就不说了，npm就可以搞定，但是，安装的时候会很慢，因为它依赖electron具体的使用方法可以直接看官网的api，下面是一个小demo，是对本博客网站的简单操作，可以看一下它强大的效果1234567891011121314151617181920212223var Nightmare = require('nightmare'); var nightmare = Nightmare(&#123; show: true, gotoTimeout: 100000 // goto页面的等待时长，不写的话默认30000ms，访问慢的网页会报错 &#125;);nightmare .goto('https://jinux7.github.io') // 打开的网页 .type('.m_search .u-search-input', 'javascript') // 向input中写入javascript .type('.m_search .u-search-input', '\\u000d') // 触发input的点击回车事件 .wait('.icon.icon-close') // 等待弹出层的.icon.icon-close元素节点出现 .click('.icon.icon-close') // 出现后点击它 .evaluate(function () &#123; // 注入到页面里执行的js代码 // do something return document.querySelector('.avatar.waves-image').src; &#125;) // .end() // 关闭nightmare .then(function (result) &#123; console.log(result); &#125;) .catch(function (error) &#123; console.error('Search failed:', error); &#125;); 如需要更丰富的功能，按照api一点点添加就可以喽.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"简单的富文本编辑器","slug":"简单的富文本编辑器","date":"2019-06-17T05:30:10.000Z","updated":"2024-01-11T07:00:59.276Z","comments":true,"path":"2019/06/17/简单的富文本编辑器/","link":"","permalink":"/2019/06/17/简单的富文本编辑器/","excerpt":"超级简单的富文本编辑器","text":"超级简单的富文本编辑器 简单的富文本编辑器这是一个超级简单富文本编辑器，功能很简单，但是富文本编辑器的写法基础是有的，可以在这个基础上进行增加改进。主要用到了div的contentEditable属性，还有document.execCommand方法，具体代码见下面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;简易富文本编辑器.html&lt;/title&gt; &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt; &lt;meta http-equiv=\"description\" content=\"this is my page\"&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"&gt; &lt;style type=\"text/css\"&gt; #editor &#123;width:600px;height:200px;border:1px solid #ccc; &#125; button &#123;margin:1px;border:1px solid #aaa;background:#ffe;cursor:pointer;overflow:hidden;&#125; button:hover &#123;background:#ccc;border:1px solid #00f;&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn1\"&gt;&lt;/button&gt; &lt;button id=\"btn2\"&gt;&lt;/button&gt; &lt;button id=\"btn3\"&gt;&lt;/button&gt; &lt;button id=\"btn4\"&gt;&lt;/button&gt; &lt;div id=\"editor\"&gt; Click to Editor... &lt;/div&gt; &lt;input id=\"printContent\" type=\"button\" value=\"打印编辑器内容\"&gt; &lt;script type=\"text/javascript\"&gt; initEditor(); //初始化 function initEditor() &#123; openOrCloseEditor(\"editor\", \"true\");//开启元素编辑 bindBtnCommand();//给样式按钮绑定命令 &#125; /** * * 功能： 开启元素编辑功能 * 输入： el：编辑器ID; operate：Boolean值，表示启动还是关闭 */ function openOrCloseEditor(el, operate) &#123; var editor = document.getElementById(el); editor.contentEditable = operate; &#125; //按钮绑定命令 function bindBtnCommand() &#123; var btns = document.getElementsByTagName(\"button\"), btnConfigs = \"backcolor|#f00|设置背景色 bold|null|字体加粗 indent|null|缩进 fontName|微软雅黑|转换字体\".split(\" \"), len = btnConfigs.length; for(var i = 0, btnConfig; btnConfig = btnConfigs[i]; i++) &#123; (function(btnConfig, btn) &#123; var msg = btnConfig.split(\"|\"), lab = msg[0], value = msg[1], title = msg[2]; btn.innerHTML = lab; btn.title = title; btn.onclick = function(e) &#123; document.execCommand(lab, false, value); &#125; &#125;)(btnConfig, btns[i]); &#125; &#125; //获取编辑器内嵌内容 function getContent(el) &#123; var editor = document.getElementById(el); return editor.innerHTML; &#125; //打印按钮绑定触发事件 document.getElementById(\"printContent\").onclick = function(e) &#123; var content = getContent(\"editor\"); document.write(content); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码直接粘贴就可以跑起来哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"vue,react中百度地图的使用","slug":"vue-react中百度地图的使用","date":"2019-06-13T05:13:09.000Z","updated":"2024-01-11T07:00:59.233Z","comments":true,"path":"2019/06/13/vue-react中百度地图的使用/","link":"","permalink":"/2019/06/13/vue-react中百度地图的使用/","excerpt":"vue,react等框架，百度地图的最优使用方式","text":"vue,react等框架，百度地图的最优使用方式 vue,react中百度地图的使用现在vue，react框架大行其道，很多项目都是用它们开发的，我的项目也都在用，之前，在使用百度地图的时候，我都是把百度地图封了一个组件，直接插入到dom中，但是，有些功能莫名其妙的不好使，我猜可能是跟vue有兼容性问题，还有一个页面中引入多个地图的情况下，像城市切换插件就不好使了，相互冲突了，所以，最终的解决方案是用iframe来引入百度地图。这个好处就是完全隔离开项目框架与百度地图之间的冲突。首先，建一个百度地图的html页面，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=yes\" /&gt; &lt;link href=\"https://api.map.baidu.com/library/IndoorMap/1.0/src/indoor.min.css?v=1.0.1 \" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;style type=\"text/css\"&gt; body, html,#map &#123;width: 100%;height: 100%;overflow: hidden;margin:0;font-family:\"微软雅黑\";&#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"https://api.map.baidu.com/api?v=3.0&amp;ak=PaxZEfdK60GDxScXccj81kBW\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://api.map.baidu.com/library/IndoorMap/1.0/src/indoor.min.js?v=1.0.1 \"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"map\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\"&gt; var obj = &#123; lng:'', lat:'' &#125;; var tab = getQueryString('tab'); // 获取url信息 function getQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var reg_rewrite = new RegExp(\"(^|/)\" + name + \"/([^/]*)(/|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); var q = window.location.pathname.substr(1).match(reg_rewrite); if(r != null)&#123; return unescape(r[2]); &#125;else if(q != null)&#123; return unescape(q[2]); &#125;else&#123; return null; &#125; &#125; // 百度地图API功能 var map = new BMap.Map(\"map\"); map.centerAndZoom(new BMap.Point(123.436, 41.816), 11); var topLeftControl = new BMap.ScaleControl(&#123; anchor: BMAP_ANCHOR_BOTTOM_LEFT &#125;); // 城市选择控件 var cityListControl = new BMap.CityListControl(&#123; anchor: BMAP_ANCHOR_TOP_RIGHT &#125;); // 比例尺控件 var topLeftNavigation = new BMap.NavigationControl(); map.addControl(topLeftControl); map.addControl(topLeftNavigation); map.addControl(cityListControl); map.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放 // 创建室内图实例 var indoorManager = new BMapLib.IndoorManager(map); // 点击获取经纬度 map.addEventListener(\"click\", function(e) &#123; obj.lng = parseFloat(e.point.lng) + ''; obj.lat = parseFloat(e.point.lat) + ''; drawLocation() selectLocation(); &#125;); function selectLocation() &#123; window.parent.postMessage(&#123; refresh:obj, tab &#125;,'*'); &#125; function drawLocation() &#123; if (obj.lng !== \"\" &amp;&amp; obj.lat !== \"\") &#123; map.clearOverlays(); var new_point = new BMap.Point(obj.lng, obj.lat); var marker = new BMap.Marker(new_point); map.addOverlay(marker); map.panTo(new_point); &#125; &#125;&lt;/script&gt; 之后就是在项目中用iframe标签引入。重要的地方来了，就是父子页面通信，在子页面点击选好地点后，肯定需要把选好点的坐标给父页面，这里有一个简单的方法，在子页面中点击选点时，给父页面发信息代码如下：1234window.parent.postMessage(&#123; val: '信息' &#125;,'*');// 具体使用方法自行百度 子页面消息发出去了，父页面如何接收呢？见下面代码12345window.addEventListener('message',function(event)&#123; console.log(event);&#125;);// 可以打印出很多需要的信息喽// 据说，IE8+都支持哦 好了，总结一下，vue中最好还是以这种方式使用哈。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"web页面性能测试demo","slug":"web页面性能测试demo","date":"2019-06-06T07:30:17.000Z","updated":"2024-01-11T07:00:59.237Z","comments":true,"path":"2019/06/06/web页面性能测试demo/","link":"","permalink":"/2019/06/06/web页面性能测试demo/","excerpt":"web页面性能测试demo","text":"web页面性能测试demo web页面性能测试demo写这篇文章的起因，有时候有人问，css会不会阻塞页面渲染了，js如何触发页面渲染了等等，所以，最好的方式就是自己写一个小demo，自己试一下不就一目了然了吗，目前这个demo的内容很简单，以后会慢慢增加。下面是github的链接地址:点我进入仓库","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"windows下git命令批处理执行","slug":"windows下git命令批处理执行","date":"2019-05-24T06:04:09.000Z","updated":"2024-01-11T07:00:59.237Z","comments":true,"path":"2019/05/24/windows下git命令批处理执行/","link":"","permalink":"/2019/05/24/windows下git命令批处理执行/","excerpt":"win10操作系统下利用批处理程序来运行git操作。","text":"win10操作系统下利用批处理程序来运行git操作。 windows下git命令批处理执行首先，我说一下我要这样做的起因，也许大家都会有感。目前，我在做的项目是一个，但是下面分了5个子项目，这5个子项目，每一个自己拥有一个git仓库，所以，我在上传代码的操作就是，commit-&gt;pull-&gt;push,这样反复5回，因为有5个仓库嘛。有时候一天要好多次，效率太低了，于是我就想起了利用windows系统的批处理来做。在使用批处理来操作git命令，首先需要把git的操作仓库方式改为ssh，使用ssh的话，还需要ssh key，ssh key的生成方法是，打开git的命令行工具，输入1234567891011// 首先检查一下现在电脑里是否已经有生成的ssh keycd ~/.ssh// ~这个符号我在git命令行下才能打出来，cmd没打出来。// ~/ 这个路径就是C:\\Users\\userName这个，看看现在是否已经有现成的ssh key// 如果有，就不用再生成了// 接下来是生成ssh key命令ssh-keygen -t rsa -C &quot;88888***@qq.com&quot;// 需要自己在电脑中注册的git邮箱,如果不知道，可以查一下 git config --global user.email// 生成的ssh key自动保存在C:\\Users\\userName这个目录下（这个是我的用户名）// 生成过程中一路回车就好，不用设置密码等 有了ssh key，添加到github或自己公司的gitlab上就好了。比如要添加到github上，登录账号进入自己的github库，步骤见下图点进去之后，按照页面提示填写就可以了。以上就是配置好了ssh key，之后就是用git拉取，推送代码了，这里有一个地方需要注意，那就是Git对仓库的操作方式，既然已经添加了ssh key，就需要用git的ssh提交方式。查看.git文件夹下的config文件，找到下面的内容12345678[remote &quot;origin&quot;] // 这个是ssh提交方式 url = git@172.12.122.123:root/demo.git // 这个是http提交方式 url = http://172.12.122.123/root/demo fetch = +refs/heads/*:refs/remotes/origin/* 按照上面的写法，只留下ssh提交方式即可。接下来，我们来写windows的批处理命令,先写一个处理一个仓库的git操作批处理。123456789101112chcp 65001cd C:\\WORK\\git-ku\\demo1@echo offecho git批处理开始执行git statusgit add .git commit -m &quot;update&quot;git pullgit pushecho ----------echo git commit pull push都已完成，点击任意键退出pause 再写一个调用多个批处理文件的操作123456chcp 65001pausestart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\git&quot; call demo1.batstart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\git&quot; call demo2.batstart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\git&quot; call demo3.batstart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\git&quot; call demo4.bat 这里，需要注意一下，因为批处理是在cmd命令行下执行的，所以要把git的环境变量配好哦。好了，通过这样的方法，以后麻烦的git操作，点击一下就可以搞定喽。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"多个ajax请求,页面渲染顺序问题","slug":"多个ajax请求-页面渲染顺序问题","date":"2019-05-20T07:04:15.000Z","updated":"2024-01-11T07:00:59.264Z","comments":true,"path":"2019/05/20/多个ajax请求-页面渲染顺序问题/","link":"","permalink":"/2019/05/20/多个ajax请求-页面渲染顺序问题/","excerpt":"在一个页面中,多个ajax请求,页面渲染顺序问题。","text":"在一个页面中,多个ajax请求,页面渲染顺序问题。 多个ajax请求,页面渲染顺序问题如题，比如说在一个页面中有两个按钮或者多个，按照先后顺序点击，都发出了ajax请求，但是他们返回的顺序就不会按照点击按钮的顺序返回，如果，它们操作的是页面的同一个显示区域，比如列表，那就ajax访问最慢的接口最后被渲染出来，有可能这个接口是用户最开始点击的按钮渲染出来的，这样就会产生错误信息，用户本想最后点击那个按钮返回的数据才是他想要的。其实，这个问题我并没有遇到过，这个是大约一年前我再一次面试中被问到的，当时由于没有做好准备，我也只能诚实的回答没有遇到过此场景，今天我又来了兴致，把它的解决方法记录下来（我的拖延症是不是很严重），这个解决方式是我自己定的，其实也是实现起来比较简单的。为了加快写作，直接把代码贴出来，在代码中写注释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;script src=\"./jquery.js\"&gt;&lt;/script&gt; &lt;title&gt;多个ajax请求,页面渲染顺序问题&lt;/title&gt; &lt;style&gt; .content &#123; width: 500px; height: 100px; background-color: #eeeeee; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; 原始内容 &lt;/div&gt; &lt;button id=\"btn1\"&gt;按钮2s&lt;/button&gt; &lt;button id=\"btn2\"&gt;按钮5s&lt;/button&gt; &lt;button id=\"btn3\"&gt;按钮3s&lt;/button&gt;&lt;/body&gt;&lt;script&gt; // 后端地址 var baseUrl = \"http://localhost:3000/\"; // 存放ajax标志的数组，用来区分是哪个ajax var orderArr = []; // 按钮1加点击事件 $('#btn1').on('click', function() &#123; // 将btn1按钮的标志传入数组 ajaxOrder('btn1'); $.post(baseUrl+'delay2s', (res)=&gt; &#123; // 渲染页面 render('btn1', res.data); &#125;); &#125;); // 按钮2加点击事件 $('#btn2').on('click', function() &#123; ajaxOrder('btn2'); $.post(baseUrl+'delay5s', (res)=&gt; &#123; render('btn2', res.data); &#125;); &#125;); // 按钮3加点击事件 $('#btn3').on('click', function() &#123; ajaxOrder('btn3'); $.post(baseUrl+'delay3s', (res)=&gt; &#123; render('btn3', res.data); &#125;); &#125;); // 向存放ajax标志位数组中push ajax标志 function ajaxOrder(flag) &#123; orderArr.push(flag); &#125; // 根据ajax的标志来渲染页面 function render(flag, val) &#123; // 如果数组中只有一个标志的情况，直接渲染并清空数组 if(orderArr.length === 1) &#123; orderArr = []; $('.content').html(val); return void 0; &#125; // 如果标志数组中多余一个标志 if(orderArr.length &gt; 1) &#123; // 如果这个标志是第一个请求的标志，则渲染页面 if(orderArr.indexOf(flag) === 0) &#123; orderArr.shift(); $('.content').html(val); return void 0; &#125;else &#123; // 如果不是第一个，则不渲染页面，并把这个标志剔除 let index = orderArr.indexOf(flag); orderArr.splice(index,1); &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 大概的流程就是，按照按钮点击的顺序来显示请求的结果。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"webpack打包多页面项目","slug":"webpack打包多页面项目","date":"2019-05-20T02:26:35.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2019/05/20/webpack打包多页面项目/","link":"","permalink":"/2019/05/20/webpack打包多页面项目/","excerpt":"webpack打包多页面项目","text":"webpack打包多页面项目 webpack打包多页面项目平时我们在工作中，使用webpack来打包单页面应用的项目很多，多页面应用之前我都是使用gulp来做，今天我在github发现一个不错的demo，我就不写具体的分析步骤了，代码里边写的很清楚，直接贴地址喽。点击这里看项目","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"import和require的本质区别","slug":"import和require的本质区别","date":"2019-05-09T08:00:05.000Z","updated":"2024-01-11T07:00:59.193Z","comments":true,"path":"2019/05/09/import和require的本质区别/","link":"","permalink":"/2019/05/09/import和require的本质区别/","excerpt":"简单的说一下import和require的本质区别","text":"简单的说一下import和require的本质区别 import和require的本质区别import是ES6的模块规范，require是commonjs的模块规范，详细的用法我不介绍，我只想说一下他们最基本的区别，import是静态加载模块，require是动态加载，那么静态加载和动态加载的区别是什么呢？静态加载时代码在编译的时候已经执行了，动态加载是编译后在代码运行的时候再执行，那么具体点是什么呢？先说说import，如下代码123456// main.js文件import &#123; name &#125; from 'name.js'// name.js文件export let name = 'jinux'export let age = 20 上面的代码表示main.js文件里引入了name.js文件导出的变量，在代码编译阶段执行后的代码如下：12// main.js文件let name = 'jinux' 这个是我自己理解的，其实就是直接把name.js里的代码放到了main.js文件里，好比是在main.js文件中声明一样。再来看看require123456789// main.js文件var obj = require('obj.js');// obj.js文件var obj = &#123; name: 'jinux', age: 20&#125;module.export obj; require是在运行阶段，需要把obj对象整个加载进内存，之后用到哪个变量就用哪个，这里再对比一下import，import是静态加载，如果只引入了name，age是不会引入的，所以是按需引入，性能更高。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"http常用状态码","slug":"http常用状态码","date":"2019-05-06T02:52:37.000Z","updated":"2024-01-11T07:00:59.192Z","comments":true,"path":"2019/05/06/http常用状态码/","link":"","permalink":"/2019/05/06/http常用状态码/","excerpt":"列出了一些常用的http请求状态码","text":"列出了一些常用的http请求状态码 http常用状态码我们在日常开发中，经常会使用ajax，会看到请求返回的状态码，也就是Status Code。常见的3个是: 200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务器超时 但是，作为一个合格的前端，还需要掌握的详细点，下面列出常用的状态码，也不是最全的哦。 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 100（继续）: 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议）: 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示成功处理了请求的状态码。 200（成功）: 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。 201（已创建）: 请求成功并且服务器创建了新的资源。 202（已接受）: 服务器已接受请求，但尚未处理。 203（非授权信息）: 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）: 服务器成功处理了请求，但没有返回任何内容。 205（重置内容）: 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容）: 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。通常，这些状态码用来重定向。 300（多种选择）: 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）: 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置）: 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改）: 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305（使用代理）: 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301&lt;/a&gt; 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）: 服务器不理解请求的语法。 401（未授权）: 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）: 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）: 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 405（方法禁用）: 禁用请求中指定的方法。 406（不接受）: 无法使用请求的内容特性响应请求的网页。 407（需要代理授权）: 此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）&lt;/a&gt;类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时）: 服务器等候请求时发生超时。 409（冲突）: 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除）: 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度）: 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）: 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）: 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长）: 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）: 请求的格式不受请求页面的支持。 416（请求范围不符合要求）: 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值）: 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 以上就是一些常用的http状态吗，如果想了解更多，点击这里喽","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"nodejs将vue的dist目录文件copy到目标目录","slug":"nodejs将vue的dist目录文件copy到目标目录","date":"2019-04-23T05:32:30.000Z","updated":"2024-01-11T07:00:59.226Z","comments":true,"path":"2019/04/23/nodejs将vue的dist目录文件copy到目标目录/","link":"","permalink":"/2019/04/23/nodejs将vue的dist目录文件copy到目标目录/","excerpt":"利用nodejs拷贝转移文件","text":"利用nodejs拷贝转移文件 nodejs将vue的dist目录文件copy到目标目录上篇文章写了《window批处理执行webpack打包》，这篇文章主要写打包好的文件自动转移到git目录下。其实就是用的nodejs的读写文件API而已，代码不多，见下面：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let fs = require('fs');let fse = require('fs-extra') // 文件的正删改查模块，比原生方便let path = require('path');// 复制文件var copy=function(src,dst)&#123; let paths = fs.readdirSync(src); //同步读取当前目录 paths.forEach(function(path)&#123; var _src=src+'/'+path; var _dst=dst+'/'+path; fs.stat(_src,function(err,stats)&#123; //stats 该对象 包含文件属性 if(err)throw err; if(stats.isFile())&#123; //如果是个文件则拷贝 let _dst = dst+'/' + path; let readable=fs.createReadStream(_src);//创建读取流 let writable=fs.createWriteStream(_dst);//创建写入流 readable.pipe(writable); &#125;else if(stats.isDirectory())&#123; //是目录则 递归 checkDirectory(_src,_dst,copy); &#125; &#125;); &#125;);&#125;// 检查文件夹是否存在，新建文件夹并copyvar checkDirectory=function(src,dst,callback)&#123; fs.access(dst, fs.constants.F_OK, (err) =&gt; &#123; if(err)&#123; fs.mkdirSync(dst); callback(src,dst); &#125;else&#123; callback(src,dst); &#125; &#125;);&#125;;// 删除旧文件var cleanOld = function(dest) &#123; let dest_static = path.join(dest, 'static'); let dest_index = path.join(dest, 'index.html'); fs.exists(dest_static,function(exists)&#123; if(exists) fse.removeSync(dest_static); &#125;); fs.exists(dest_index,function(exists)&#123; if(exists) fse.removeSync(dest_index); &#125;);&#125;// 文件路径let url_src_ehome = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\ejashop\\\\dist\\\\'), url_dest_ehome = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\ehome'), url_src_airport = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\airport\\\\dist\\\\'), url_dest_airport = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\airport'), url_src_operation = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\eHomeOperation\\\\dist\\\\'), url_dest_operation = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\operation'), url_src_openShop = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\kaidian\\\\dist\\\\'), url_dest_openShop = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\openShop');// copy之前先清空旧文件cleanOld(url_dest_ehome);cleanOld(url_dest_airport);cleanOld(url_dest_operation);cleanOld(url_dest_openShop);// 4个项目的copy转移checkDirectory(url_src_ehome, url_dest_ehome,copy);checkDirectory(url_src_airport, url_dest_airport,copy);checkDirectory(url_src_operation, url_dest_operation,copy);checkDirectory(url_src_openShop, url_dest_openShop,copy); 这里需要注意一点，path.relative(__dirname, ‘C:\\WORK\\new-airport\\6 编码\\5 Web\\ejashop\\dist\\‘);利用path模块将两个绝对路径变成相对路径。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"window批处理执行webpack打包","slug":"window批处理执行webpack打包","date":"2019-04-19T01:14:31.000Z","updated":"2024-01-11T07:00:59.239Z","comments":true,"path":"2019/04/19/window批处理执行webpack打包/","link":"","permalink":"/2019/04/19/window批处理执行webpack打包/","excerpt":"利用window的批处理文件bat来批量执行debpack打包命令。","text":"利用window的批处理文件bat来批量执行debpack打包命令。 window批处理执行webpack打包现在的前端开发，使用vue，react，angular等框架的项目非常多，部署的时候需要打包后进行部署，比如运行npm run build命令，但是比如我现在的项目，有4个子平台，每个平台是独立的一套vue，每次打包的时候需要进入到4个不同的平台目录进行打包命令操作，还有一点，我们项目分为测试环境，生产环境，这样就会出现更多次打包操作，每次都很烦，进入一个文件夹，打开命令提示符，输入npm run build，有没有方便点的方式呢，有，可以利用window系统的批处理文件来操作。首先，下面的是执行一个打包命令的.bat文件1234chcp 65001cd C:\\WORK\\new-airport\\6 编码\\5 Web\\ejashopnpm run buildpause chcp 65001 //是用来可以在文件路径中使用中文 cd C:\\WORK\\new-airport\\6 编码\\5 Web\\ejashop //进入到项目的目录 npm run build //执行打包命令 pause // 命令行暂停，等待下一步操作 上面的是执行一个打包命令的，多个打包操作需要创建多个.bat文件，每执行一个点击一下也很麻烦，我们可以在创建一个.bat文件，用来执行这些批处理文件操作，向下面这样:123456chcp 65001pausestart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\build&quot; call demo1.batstart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\build&quot; call demo2.batstart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\build&quot; call demo3.batstart /D &quot;C:\\Users\\userName\\Desktop\\批处理node\\build&quot; call demo4.bat chcp 65001 //是用来可以在文件路径中使用中文 start /D “C:\\Users\\userName\\Desktop\\批处理node\\build” call demo1.bat //执行具体的.bat文件","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"http请求头响应头字段详解","slug":"http请求头响应头字段详解","date":"2019-04-15T09:04:24.000Z","updated":"2024-01-11T07:00:59.192Z","comments":true,"path":"2019/04/15/http请求头响应头字段详解/","link":"","permalink":"/2019/04/15/http请求头响应头字段详解/","excerpt":"http请求头和返回头字段的解释","text":"http请求头和返回头字段的解释 http请求头响应头字段详解作为一名前端开发人员，肯定少不了要和网络打交道，因为要从服务器端拉取数据，从服务端获取数据最常用的方式还是通过HTTP请求。给服务器发请求的时候有请求头，接受服务器响应的时候有响应头，客户端和服务器端互相沟通需要的信息都是通过这些“头”来传送，这些信息是一些类似key:value的键值对。了解这些“头”中字段的含义对于理解整个请求过程有很大的帮助。这里列举了常用的“头”字段的解释以及例子，本文可以作为工具文收藏，以备需要时查看。 常用标准请求头字段 Accept 设置接受的内容类型Accept: text/plain Accept-Charset 设置接受的字符编码Accept-Charset: utf-8 Accept-Encoding 设置接受的编码格式Accept-Encoding: gzip, deflate Accept-Datetime 设置接受的版本时间Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT Accept-Language 设置接受的语言Accept-Language: en-US Authorization 设置HTTP身份验证的凭证Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令Cache-Control: no-cache Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项Connection: keep-aliveConnection: Upgrade Content-Length 设置请求体的字节长度Content-Length: 348 Content-MD5 设置基于MD5算法对请求体内容进行Base64二进制编码Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Type 设置请求体的MIME类型（适用POST和PUT请求）Content-Type: application/x-www-form-urlencoded Cookie 设置服务器使用Set-Cookie发送的http cookieCookie: $Version=1; Skin=new; Date 设置消息发送的日期和时间Date: Tue, 15 Nov 1994 08:12:31 GMT Expect 标识客户端需要的特殊浏览器行为Expect: 100-continue Forwarded 披露客户端通过http代理连接web服务的源信息Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43Forwarded: for=192.0.2.43, for=198.51.100.17 From 设置发送请求的用户的email地址From: user@example.com Host 设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略Host: en.wikipedia.org:8080Host: en.wikipedia.org If-Match 设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源If-Match: “737060cd8c284d8af7ad3082f209582d If-Modified-Since 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not ModifiedIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT If-None-Match 设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not ModifiedIf-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT Max-Forwards 限制代理或网关转发消息的次数Max-Forwards: 10 Origin 标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）Origin: http://www.example-social-network.com Pragma 设置特殊实现字段，可能会对请求响应链有多种影响Pragma: no-cache Proxy-Authorization 为连接代理授权认证信息Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte servingRange: bytes=500-999 Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址（轶事：这个单词正确的拼法应该是”referrer”,但是在很多规范中都拼成了”referer”，所以这个单词也就成为标准用法）Referer: http://en.wikipedia.org/wiki/Main_Page TE 设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样TE: trailers, deflate Upgrade 请求服务端升级协议Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket User-Agent 用户代理的字符串值User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 Via 通知服务器代理请求Via: 1.0 fred, 1.1 example.com (Apache/1.1) Warning 实体可能会发生的问题的通用警告Warning: 199 Miscellaneous warning 常用非标准请求头字段 X-Requested-With 标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequestX-Requested-With: XMLHttpRequest DNT 请求web应用禁用用户追踪DNT: 1 (Do Not Track Enabled)DNT: 0 (Do Not Track Disabled) X-Forwarded-For 一个事实标准，用来标识客户端通过HTTP代理或者负载均衡器连接的web服务器的原始IP地址X-Forwarded-For: client1, proxy1, proxy2X-Forwarded-For: 129.78.138.66, 129.78.64.103 X-Forwarded-Host 一个事实标准，用来标识客户端在HTTP请求头中请求的原始host,因为主机名或者反向代理的端口可能与处理请求的原始服务器不同X-Forwarded-Host: en.wikipedia.org:8080X-Forwarded-Host: en.wikipedia.org X-Forwarded-Proto 一个事实标准，用来标识HTTP原始协议，因为反向代理或者负载均衡器和web服务器可能使用http,但是请求到反向代理使用的是httpsX-Forwarded-Proto: https Front-End-Https 微软应用程序和负载均衡器使用的非标准header字段Front-End-Https: on X-Http-Method-Override 请求web应用时，使用header字段中给定的方法（通常是put或者delete）覆盖请求中指定的方法（通常是post）,如果用户代理或者防火墙不支持直接使用put或者delete方法发送请求时，可以使用这个字段X-HTTP-Method-Override: DELETE X-ATT-DeviceId 允许更简单的解析用户代理在AT&amp;T设备上的MakeModel/FirmwareX-Att-Deviceid: GT-P7320/P7320XXLPG X-Wap-Profile 设置描述当前连接设备的详细信息的xml文件在网络中的位置x-wap-profile: http://wap.samsungmobile.com/uaprof/SGH-I777.xml Proxy-Connection 早起HTTP版本中的一个误称，现在使用标准的connection字段Proxy-Connection: keep-alive X-UIDH 服务端深度包检测插入的一个唯一ID标识Verizon Wireless的客户X-UIDH: … X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN 防止跨站请求伪造X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql X-Request-ID,X-Correlation-ID 标识客户端和服务端的HTTP请求X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5 常用标准响应头字段 Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享Access-Control-Allow-Origin: * Accept-Patch 指定服务器支持的补丁文档格式，适用于http的patch方法Accept-Patch: text/example;charset=utf-8 Accept-Ranges 服务器通过byte serving支持的部分内容范围类型Accept-Ranges: bytes Age 对象在代理缓存中暂存的秒数Age: 12 Allow 设置特定资源的有效行为，适用方法不被允许的http 405错误Allow: GET, HEAD Alt-Svc 服务器使用”Alt-Svc”（Alternative Servicesde的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取Alt-Svc: h2=”http2.example.com:443”; ma=7200 Cache-Control 告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒Cache-Control: max-age=3600 Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项Connection: close Content-Disposition 告诉客户端弹出一个文件下载框，并且可以指定下载文件名Content-Disposition: attachment; filename=”fname.ext” Content-Encoding 设置数据使用的编码类型Content-Encoding: gzip Content-Language 为封闭内容设置自然语言或者目标用户语言Content-Language: en Content-Length 响应体的字节长度Content-Length: 348 Content-Location 设置返回数据的另一个位置Content-Location: /index.htm Content-MD5 设置基于MD5算法对响应体内容进行Base64二进制编码Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 标识响应体内容属于完整消息体中的那一部分Content-Range: bytes 21010-47021/47022 Content-Type 设置响应体的MIME类型Content-Type: text/html; charset=utf-8 Date 设置消息发送的日期和时间Date: Tue, 15 Nov 1994 08:12:31 GMT ETag 特定版本资源的标识符，通常是消息摘要ETag: “737060cd8c284d8af7ad3082f209582d” Expires 设置响应体的过期时间Expires: Thu, 01 Dec 1994 16:00:00 GMT Last-Modified 设置请求对象最后一次的修改日期Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT Link 设置与其他资源的类型关系Link: ; rel=”alternate” Location 在重定向中或者创建新资源时使用Location: http://www.w3.org/pub/WWW/People.html P3P 以P3P:CP=”your_compact_policy”的格式设置支持P3P(Platform for Privacy Preferences Project)策略，大部分浏览器没有完全支持P3P策略，许多站点设置假的策略内容欺骗支持P3P策略的浏览器以获取第三方cookie的授权P3P: CP=”This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657 for more info.” Pragma 设置特殊实现字段，可能会对请求响应链有多种影响Pragma: no-cache Proxy-Authenticate 设置访问代理的请求权限Proxy-Authenticate: Basic Public-Key-Pins 设置站点的授权TLS证书Public-Key-Pins: max-age=2592000; pin-sha256=”E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=”; Refresh “重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持 12&lt;meta http-equiv=\"refresh\" content=\"5; url=http://example.com/\"&gt;Refresh: 5; url=http://www.w3.org/pub/WWW/People.html Retry-After 如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者HTTP时间Example 1: Retry-After: 120Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT Server 服务器名称Server: Apache/2.4.1 (Unix) Set-Cookie 设置HTTP CookieSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Status 设置HTTP响应状态Status: 200 OK Strict-Transport-Security 一种HSTS策略通知HTTP客户端缓存HTTPS策略多长时间以及是否应用到子域Strict-Transport-Security: max-age=16070400; includeSubDomains Trailer 标识给定的header字段将展示在后续的chunked编码的消息中Trailer: Max-Forwards Transfer-Encoding 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identityTransfer-Encoding: chunked TSV Tracking Status Value，在响应中设置给DNT(do-not-track),可能的取值 “!” — under construction “?” — dynamic “G” — gateway to multiple parties “N” — not tracking “T” — tracking “C” — tracking with consent “P” — tracking only if consented “D” — disregarding DNT “U” — updatedTSV: ? Upgrade 请求客户端升级协议Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket Vary 通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的Example 1: Vary: *Example 2: Vary: Accept-Language Via 通知客户端代理，通过其要发送什么响应Via: 1.0 fred, 1.1 example.com (Apache/1.1) Warning 实体可能会发生的问题的通用警告Warning: 199 Miscellaneous warning WWW-Authenticate 标识访问请求实体的身份验证方案WWW-Authenticate: Basic X-Frame-Options 点击劫持保护： deny frame中不渲染 sameorigin 如果源不匹配不渲染 allow-from 允许指定位置访问 allowall 不标准，允许任意位置访问X-Frame-Options: deny 常用非标准响应头字段 X-XSS-Protection 过滤跨站脚本X-XSS-Protection: 1; mode=block Content-Security-Policy, X-Content-Security-Policy,X-WebKit-CSP 定义内容安全策略X-WebKit-CSP: default-src ‘self’ X-Content-Type-Options 唯一的取值是””,阻止IE在响应中嗅探定义的内容格式以外的其他MIME格式X-Content-Type-Options: nosniff X-Powered-By 指定支持web应用的技术X-Powered-By: PHP/5.4.0 X-UA-Compatible 推荐首选的渲染引擎来展示内容，通常向后兼容，也用于激活IE中内嵌chrome框架插件X-UA-Compatible: IE=EmulateIE7X-UA-Compatible: IE=edgeX-UA-Compatible: Chrome=1 X-Content-Duration 提供音视频的持续时间，单位是秒，只有Gecko内核浏览器支持X-Content-Duration: 42.666 Upgrade-Insecure-Requests 标识服务器是否可以处理HTTPS协议Upgrade-Insecure-Requests: 1 X-Request-ID,X-Correlation-ID 标识一个客户端和服务端的请求X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"ajax携带cookie","slug":"ajax携带cookie","date":"2019-04-15T08:39:46.000Z","updated":"2024-01-11T07:00:59.176Z","comments":true,"path":"2019/04/15/ajax携带cookie/","link":"","permalink":"/2019/04/15/ajax携带cookie/","excerpt":"ajax同域和跨域情况下携带cookie问题","text":"ajax同域和跨域情况下携带cookie问题 ajax携带cookie这是一个老生常谈的问题，但是时间长了总容易忘掉，今天记录下来，以便下次方便记起来。 首先，今天我遇到了一个坑，chrome浏览无论是同域还是跨域状态下，浏览器request headers里居然都不显示，刚开始我还以为是设置错了，后来发现其他浏览器都显示，我想有可能是chrome浏览器安全考虑吧，但是，这并不影响后台接收，只是不显示而已。 同域下无可厚非，什么都不用做就会带上cookie。 跨域下的设置：浏览器端，需要设置withCredentials为true1234567891011121314151617181920212223// 原生方式var xhr = new XMLHttpRequest();xhr.open('GET', 'http://example.com/', true);xhr.withCredentials = true;// jquery方式$.ajax(&#123; url: \"http://192.168.252.12:3006/post_form\", type: 'POST', xhrFields: &#123; withCredentials: true // 这里设置了withCredentials &#125;, success: function(data) &#123; console.log(data) &#125;, error: function(err) &#123; console.error(err) &#125; &#125;);// axios方式import axios from 'axios';axios.defaults.withCredentials = true; 再来说说后端的设置，以nodejs的express为例：123// 返回头设置res.header(\"Access-Control-Allow-Origin\", \"http://localhost:9000\"); // 注意，这里不能写*,应该是具体的地址res.header(\"Access-Control-Allow-Credentials\", \"true\"); 最后附上demo代码：前端12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; ajax cookie demo&lt;/body&gt;&lt;script&gt; $.ajax(&#123; url: \"http://192.168.252.12:3006/post_form\", type: 'POST', xhrFields: &#123; withCredentials: true // 这里设置了withCredentials &#125;, success: function(data) &#123; console.log(data) &#125;, error: function(err) &#123; console.error(err) &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 后端123456789101112131415161718192021222324252627282930313233343536373839var express = require('express');var app = express();var multiparty = require('multiparty');var bodyParser = require('body-parser');var cookieParser = require('cookie-parser'); app.set('port',process.env.PORT || 3006); //设置端口app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"http://localhost:9000\"); res.header(\"Access-Control-Allow-Credentials\", \"true\"); res.header(\"Access-Control-Allow-Headers\", \"client-token,Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1'); if(req.method==\"OPTIONS\") res.send(200); //让options请求快速返回 else next();&#125;);//使用static中间件 制定public目录为静态资源目录,其中资源不会经过任何处理app.use(express.static(__dirname + '/public'));app.use(bodyParser.json()); // for parsing application/jsonapp.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // for parsing application/x-www-form-urlencodedapp.use(cookieParser()); // cookie解析app.post('/post_form',function(req,res)&#123; var data = &#123; name: req.body.name, info: req.body.info, hostName: req.hostname &#125;; res.cookie(\"add\", 'test456', &#123;maxAge: 900000, httpOnly: true&#125;); // 设置cookie console.log('cookie-&gt;' + req.cookies.add); // 读取cookie res.send(data); &#125;);app.listen(app.get('port'), function () &#123; console.log( '服务器启动完成，端口为： '+app.get('port') );&#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"let存在变量提升吗?","slug":"let存在变量提升吗","date":"2019-04-10T07:20:08.000Z","updated":"2024-01-11T07:00:59.224Z","comments":true,"path":"2019/04/10/let存在变量提升吗/","link":"","permalink":"/2019/04/10/let存在变量提升吗/","excerpt":"javascript中关于let的一些小知识","text":"javascript中关于let的一些小知识 let存在变量提升吗?let是ES6推出的新语法，平时简单的用大家都明白，但是里边的原理还是很深的。在MDN的文档中对于let的特性是这样说的： let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时死区，不会被提升。我们来看一个小demo123456789&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;);&lt;/script&gt;&lt;script&gt; let b = 12 console.log(b)&lt;/script&gt; 代码执行报错：Uncaught SyntaxError: Identifier ‘b’ has already been declared 先给window创建b的属性，然后再去声明b，这个时候，b是个全局变量可以直接通过b访问，let 又不可以重复声明。此处可以解释的通。那么请看下面的代码123456789&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;); let b = 12&lt;/script&gt;&lt;script&gt; console.log(b)&lt;/script&gt; 如果把let b 提升到上面的script块就可以声明成功。如果说从上往下执行的话，b是已经存在的了，那么let b是不可以声明的成功的。 到这里就有些解释不通了。为什么window已经声明了b的属性，会成为一个单独的b变量。let 的时候却没有报错呢。这里就需要对let 是不是会变量提升划一个问号了。 先把这个问题放在这里，我们继续看下面这段代码。12345678&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;); console.log(window.b) let b = 12 console.log(b)&lt;/script&gt; window下已经声明了b的属性，而且let 一个b 打印出来分别是22和12。这里我们假设存在变量提升的话，那么js引擎在预解析的时候会先声明b对象。然后实际执行的时候，再给window创建b属性。到这里我们就可以解释的通了。既然存在变量提升的话，我是不是可以在声明之前打印一下b的值呢？1234567&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;); console.log(b) let b = 12&lt;/script&gt; 报错 Uncaught ReferenceError: b is not defined纳尼？难道let 真的不存在变量提升？因为鄙人有强迫症，本着不达目的不罢休的目的，问了度娘，找到了如下的参考资料。要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」。我们来看看 var 声明的「创建、初始化和赋值」过程1234567&lt;script&gt;function fn()&#123; var x = 1 var y = 2&#125;fn()&lt;/script&gt; 在执行 fn 时，会有以下过程（不完全）： 1.进入 fn，为 fn 创建一个环境。2.找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。3.将这些变量「初始化」为 undefined。4.开始执行代码5.x = 1 将 x 变量「赋值」为 16.y = 2 将 y 变量「赋值」为 2也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。接下来来看 function 声明的「创建、初始化和赋值」过程假设代码如下：1234567&lt;script&gt;fn2() function fn2()&#123; console.log(2)&#125;&lt;/script&gt; JS 引擎会有一下过程：1.找到所有用 function 声明的变量，在环境中「创建」这些变量。2.将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。3.开始执行代码 fn2()也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。接下来看 let 声明的「创建、初始化和赋值」过程假设代码如下123456&lt;script&gt;&#123; let x = 1 x = 2&#125;&lt;/script&gt; 我们只看 {} 里面的过程：1.找到所有用 let 声明的变量，在环境中「创建」这些变量2.开始执行代码（注意现在还没有初始化）3.执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）4.执行 x = 2，对 x 进行「赋值」这就解释了为什么在 let x 之前使用 x 会报错：1234567&lt;script&gt;let x = 'global'&#123; console.log(x) // Uncaught ReferenceError: x is not defined let x = 1&#125;&lt;/script&gt; 原因有两个1.console.log(x) 中的 x 指的是下面的 x，而不是全局的 x2.执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）看到这里，你应该明白了 let 到底有没有提升：1.let 的「创建」过程被提升了，但是初始化没有提升。2.var 的「创建」和「初始化」都被提升了。function 的「创建」「初始化」和「赋值」都被提升了。 至此 我们也可以解释 为什么跨script标签提示重复声明：因为浏览器是从上往下执行js代码的，也就是说在第一段js执行完成之后，再去预解析第二段js代码，执行第二段代码。 为什么在同一个script标签中可以定义b： 因为在js引擎预解析script的时候先创建了b。然后再执行Object.defineProperty为window增加b属性。所以此处的b和window.b不是一个变量。 为什么在同一个script标签中可以定义b，但是在b声明之前会报错b没有定义：因为只是创建了b变量，并没有初始化。没有初始化，变量是不可以使用的","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"封装ajax工具插件","slug":"封装ajax工具插件","date":"2019-04-03T06:47:46.000Z","updated":"2024-01-11T07:00:59.265Z","comments":true,"path":"2019/04/03/封装ajax工具插件/","link":"","permalink":"/2019/04/03/封装ajax工具插件/","excerpt":"封装一个自己的ajax工具插件","text":"封装一个自己的ajax工具插件 封装ajax工具插件我们在平时开发的时候，ajax请求都会用到现有库，用的比较多的如jquery，axios等，偶尔自己写个原生ajax请求的情况也有，这些库是怎么写的呢，我们自己封装一个库，来学习学习ajax的一些基础知识。在写这篇文章的时候，是因为头两天同事问我一个ajax问题，关于请求参数的，我突然回答不出来，忘记了，于是翻出来2年前自己封的ajax工具看了一眼，知道了怎么回事，决定把代码写到博客里，忘了的时候方便看一下。下面我只贴出了核心代码，其他部分我会提供github的地址：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184;(function(window,undefined)&#123; // jinuxAjax挂载到window上 window.jinuxAjax = function(opt)&#123; ieAjaxInit(); //默认参数配置 var defaultOpt = &#123; url:'', type: 'GET', data: null, contentType: 'application/x-www-form-urlencoded',//'text/plain;charset=UTF-8','application/json','multipart/form-data' timeOut: 5000, files:[], progress: null, before: fn, success: fn, error: fn, complete: fn &#125;; //参数对象继承获取新参数对象 if(Object.assign)&#123; var opt = Object.assign(&#123;&#125;, defaultOpt, opt); &#125;else &#123; for(var name in defaultOpt)&#123; defaultOpt[name] = opt[name] || defaultOpt[name]; &#125; var opt = defaultOpt; &#125; requestData(opt); &#125; //将json格式数据转成application/x-www-form-urlencoded格式数据 function encodeFormData(data)&#123; if(!data) return ''; var pairs = []; for(var name in data)&#123; if(!data.hasOwnProperty(name)) continue; if(typeof data[name] === 'function') continue; var value = data[name].toString(); name = encodeURIComponent(name.replace('%20','+')); value = encodeURIComponent(value.replace('%20','+')); pairs.push(name + '=' + value); &#125; return pairs.join('&amp;'); &#125; //ajax的get请求函数 function getData(opt)&#123; var request = new XMLHttpRequest(); var timeoutFlag = false; //是否超时 //启动计时器，做超时处理 var timer = setTimeout(function()&#123; timeoutFlag = true; request.abort(); &#125;,opt.timeOut); request.open('GET',opt.url +'?'+ encodeFormData(opt.data)); opt.before(); //请求之前执行before函数 request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(timeoutFlag) return; clearTimeout(timer); if(request.status === 200)&#123; var type = request.getResponseHeader('Content-Type'); //检查type类型做相应的解析处理 if(type.indexOf('xml') !== -1 &amp;&amp; request.responseXML)&#123; //xml相应 opt.success(request.responseXML); &#125;else if(type.indexOf('application/json') !== -1) &#123; //json相应 opt.success(JSON.parse(request.responseText)); &#125;else &#123; opt.success(request.responseText); &#125; &#125;else &#123; opt.error(request); &#125; opt.complete(); &#125; &#125; request.send(null); &#125; //ajax的post请求函数 function postData(opt)&#123; var request = new XMLHttpRequest(), sendData=null; var timeoutFlag = false; //是否超时 //启动计时器，做超时处理 var timer = setTimeout(function()&#123; timeoutFlag = true; request.abort(); &#125;,opt.timeOut); request.open('POST',opt.url); request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(timeoutFlag) return; clearTimeout(timer); if(request.status === 200)&#123; var type = request.getResponseHeader('Content-Type'); //检查type类型做相应的解析处理 if(type.indexOf('xml') !== -1 &amp;&amp; request.responseXML)&#123; //xml相应 opt.success(request.responseXML); &#125;else if(type.indexOf('application/json') !== -1) &#123; //json相应 opt.success(JSON.parse(request.responseText)); &#125;else &#123; opt.success(request.responseText); &#125; &#125;else &#123; opt.error(request); &#125; opt.complete(); &#125; &#125; //处理接收进度事件 if(opt.progress.enable &amp;&amp; request.upload)&#123; request.upload.onprogress = function(ev)&#123; if(ev.lengthComputable)&#123; opt.progress.receiveHandle(ev); &#125; &#125; request.upload.onload = function(ev)&#123; opt.progress.successHandle(ev); &#125; &#125; if(opt.contentType === 'application/x-www-form-urlencoded')&#123; request.setRequestHeader('Content-Type','application/x-www-form-urlencoded; charset=UTF-8'); sendData = encodeFormData(opt.data); &#125;else if(opt.contentType === 'application/json') &#123; request.setRequestHeader('Content-Type','application/json; charset=utf-8'); sendData = JSON.stringify(opt.data); &#125;else if(opt.contentType === 'multipart/form-data') &#123; var fd = new FormData(); for(var name in opt.data)&#123; if( !opt.data.hasOwnProperty(name) ) continue; if( typeof opt.data[name] === 'function' ) continue; fd.append(name,opt.data[name]); &#125; for(var i=0; i&lt;opt.files.length; i++)&#123; fd.append('file'+i,opt.files[i]); &#125; sendData = fd; &#125; request.send(sendData); &#125; //ajax请求函数，在函数内再调用get或者post function requestData(opt)&#123; if(opt.type === 'GET')&#123; getData(opt); &#125; else &#123; postData(opt); &#125; &#125; // 定义一个空函数 function fn()&#123;&#125; // 如果是ie6，创建XMLHttpRequest对象 function ieAjaxInit()&#123; if(window.XMLHttpRequest === undefined)&#123; window.XMLHttpRequest = function()&#123; try &#123; return new ActiveXObject('Msxml2.XMLHTTP.6.0'); &#125; catch (e1) &#123; try &#123; return new ActiveXObject('Msxml2.XMLHTTP.3.0'); &#125; catch (e2) &#123; throw new Error('不支持XMLHttpRequest'); &#125; &#125; &#125; &#125; &#125; //&#125;)(window); 详细代码请点击这里看源码","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2019-04-03T05:45:23.000Z","updated":"2024-01-11T07:00:59.287Z","comments":true,"path":"2019/04/03/防抖与节流/","link":"","permalink":"/2019/04/03/防抖与节流/","excerpt":"简单的介绍一下防抖与节流","text":"简单的介绍一下防抖与节流作为一名前端开发者，我们经常会处理各种事件，比如常见的click、scroll、 resize等等。仔细一想，会发现像scroll、scroll、onchange这类事件会频繁触发，如果我们在回调中计算元素位置、做一些跟DOM相关的操作，引起浏览器回流和重绘，频繁触发回调，很可能会造成浏览器掉帧，甚至会使浏览器崩溃，影响用户体验。针对这种现象，目前有两种常用的解决方案：防抖和节流。 防抖（debounce）所谓防抖，就是指触发事件后，就是把触发非常频繁的事件合并成一次去执行。即在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算。 以我们生活中乘车刷卡的情景举例，只要乘客不断地在刷卡，司机师傅就不能开车，乘客刷卡完毕之后，司机会等待几分钟，确定乘客坐稳再开车。如果司机在最后等待的时间内又有新的乘客上车，那么司机等乘客刷卡完毕之后，还要再等待一会，等待所有乘客坐稳再开车。具体应该怎么去实现这样的功能呢？第一时间肯定会想到使用setTimeout方法，那我们就尝试写一个简单的函数来实现这个功能吧~12345678910var debounce = function(fn, delayTime) &#123; var timeId; return function() &#123; var context = this, args = arguments; timeId &amp;&amp; clearTimeout(timeout); timeId = setTimeout(function &#123; fn.apply(context, args); &#125;, delayTime) &#125;&#125; 思路解析：执行debounce函数之后会返回一个新的函数，通过闭包的形式，维护一个变量timeId，每次执行该函数的时候会结束之前的延迟操作，重新执行setTimeout方法，也就实现了上面所说的指定的时间内多次触发同一个事件，会合并执行一次。温馨提示：1、上述代码中arguments只会保存事件回调函数中的参数，譬如：事件对象等，并不会保存fn、delayTime2、使用apply改变传入的fn方法中的this指向，指向绑定事件的DOM元素。 节流（throttle）所谓节流，是指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。 类比到生活中的水龙头，拧紧水龙头到某种程度会发现，每隔一段时间，就会有水滴流出。说到时间间隔，大家肯定会想到使用setTimeout来实现，在这里，我们使用两种方法来简单实现这种功能：时间戳和setTimeout定时器。 时间戳123456789101112var throttle = (fn, delayTime) = &gt;&#123; var _start = Date.now(); return function() &#123; var _now = Date.now(), context = this, args = arguments; if (_now - _start &gt;= delayTime) &#123; fn.apply(context, args); _start = Date.now(); &#125; &#125;&#125; 通过比较两次时间戳的间隔是否大于等于我们事先指定的时间来决定是否执行事件回调。 定时器12345678910111213var throttle = function(fn, delayTime) &#123; var flag; return function() &#123; var context = this, args = arguments; if (!flag) &#123; flag = setTimeout(function() &#123; fn.apply(context, args); flag = false; &#125;,delayTime); &#125; &#125;&#125; 在上述实现过程中，我们设置了一个标志变量flag，当delayTime之后执行事件回调，便会把这个变量重置，表示一次回调已经执行结束。 对比上述两种实现，我们会发现一个有趣的现象：1、使用时间戳方式，页面加载的时候就会开始计时，如果页面加载时间大于我们设定的delayTime，第一次触发事件回调的时候便会立即fn，并不会延迟。如果最后一次触发回调与前一次触发回调的时间差小于delayTime，则最后一次触发事件并不会执行fn；2、使用定时器方式，我们第一次触发回调的时候才会开始计时，如果最后一次触发回调事件与前一次时间间隔小于delayTime，delayTime之后仍会执行fn。这两种方式有点优势互补的意思，哈哈~我们考虑把这两种方式结合起来，便会在第一次触发事件时执行fn，最后一次与前一次间隔比较短，delayTime之后再次执行fn。想法简单实现如下：12345678910111213141516var throttle = function(fn, delayTime) &#123; var flag, _start = Date.now(); return function() &#123; var context = this, args = arguments, _now = Date.now(), remainTime = delayTime - (_now - _start); if (remainTime &lt;= 0) &#123; fn.apply(this, args); &#125; else &#123; setTimeout(function() &#123; fn.apply(this, args); &#125;,remainTime) &#125; &#125;&#125; 通过上面的分析，可以很明显的看出函数防抖和函数节流的区别：频繁触发事件时，函数防抖只会在最后一次触发事件只会才会执行回调内容，其他情况下会重新计算延迟事件，而函数节流便会很有规律的每隔一定时间执行一次回调函数。 requestAnimationFrame之前，我们使用setTimeout简单实现了防抖和节流功能，如果我们不考虑兼容性，追求精度比较高的页面效果，可以考虑试试html5提供的API–requestAnimationFrame。与setTimeout相比，requestAnimationFrame的时间间隔是有系统来决定，保证屏幕刷新一次，回调函数只会执行一次，比如屏幕的刷新频率是60HZ，即间隔1000ms/60会执行一次回调。1234567891011var throttle = function(fn, delayTime) &#123; var flag; return function() &#123; if (!flag) &#123; requestAnimationFrame(function() &#123; fn(); flag = false; &#125;); flag = true; &#125; &#125; 上述代码的基本功能就是保证在屏幕刷新的时候（对于大多数的屏幕来说，大约16.67ms），可以执行一次回调函数fn。使用这种方式也存在一种比较明显的缺点，时间间隔只能跟随系统变化，我们无法修改，但是准确性会比setTimeout高一些。注意： 防抖和节流只是减少了事件回调函数的执行次数，并不会减少事件的触发频率。 防抖和节流并没有从本质上解决性能问题，我们还应该注意优化我们事件回调函数的逻辑功能，避免在回调中执行比较复杂的DOM操作，减少浏览器reflow和repaint。上面的示例代码比较简单，只是说明了基本的思路。目前已经有工具库实现了这些功能，比如underscore，考虑的情况也会比较多，大家可以去查看源码，学习作者的思路，加深理解。underscore的debounce方法源码：1234567891011121314151617181920212223_.debounce = function(func, wait, immediate) &#123; var timeout, result; var later = function(context, args) &#123; timeout = null; if (args) result = func.apply(context, args); &#125;; var debounced = restArguments(function(args) &#123; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); &#125; else &#123; timeout = _.delay(later, wait, this, args); &#125; return result; &#125;); debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125;; underscore的throttle源码：1234567891011121314151617181920212223242526272829303132333435363738_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled;&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"HTML5中Video标签无法播放mp4的解决办法","slug":"HTML5中Video标签无法播放mp4的解决办法","date":"2019-03-21T01:13:22.000Z","updated":"2024-01-11T07:00:59.119Z","comments":true,"path":"2019/03/21/HTML5中Video标签无法播放mp4的解决办法/","link":"","permalink":"/2019/03/21/HTML5中Video标签无法播放mp4的解决办法/","excerpt":"解决其它格式视频转mp4格式文件，video标签无法播放问题","text":"解决其它格式视频转mp4格式文件，video标签无法播放问题 HTML5中Video标签无法播放mp4的解决办法首先，浏览器使用环境chrome在使用video标签播放视频的时候，我一般都选择mp4格式的文件，在网上下载的demo视频或者是手机拍摄的mp4文件都可以播放，但是，我用格式工厂把avi格式的文件转换成mp4文件就无法播放，为什么呢？带着疑问，上网找答案，找到了原因，如下：使用格式工厂的mp4转换功能转出来的mp4文件并不能使用，于是把能播放的视频文件和不能播放的视频文件的编码格式对比了一下可以播放的：不可以播放的：所以，在格式工厂转换的时候需要转成AVC编码格式的mp4文件好了，按照这种方式就可以正常播放了。*补充更新：上边的方式在pc端chrome浏览器上可以，但是在移动端上还是无法播放，最后没有办法，我采用了WebM格式。格式工厂可以转换，见下图","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端兼容性","slug":"移动端兼容性","date":"2019-03-05T01:43:57.000Z","updated":"2024-01-11T07:00:59.275Z","comments":true,"path":"2019/03/05/移动端兼容性/","link":"","permalink":"/2019/03/05/移动端兼容性/","excerpt":"移动端有关html标签节点的兼容性问题","text":"移动端有关html标签节点的兼容性问题 移动端兼容性meta标签1234567891011121314151617// viewport就啥也不说了，必须得加&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;// 启动或禁用自动识别页面中的电话号码&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;// 启动或禁用自动识别邮箱地址&lt;meta name=\"format-detection\" content=\"email=no\" /&gt; // 设置 Web 应用是否以全屏模式运行。&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;// ios 的 safari 顶端状态条的样式，可选的参数有：default、black、black-translucent&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;// winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; body,img等标签123456789// 禁止 ios 长按时不触发系统的菜单，禁止 ios&amp;android 长按时下载图片.css &#123; -webkit-touch-callout: none&#125;// 禁止ios和android用户选中文字.css &#123; -webkit-user-select:none&#125; 图片不清晰12345678910111213// 比如，iphone6，设备款375，物理像素750，正常一张占1/3屏幕的图片，125px，如果准备一张125的// 肯定会模糊，必须准备250px的。如果像iphone6 plus，像素比3， 占1/3的图片138px，实际需要414px。// 解决方案：@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .css &#123; background-image: url('2x.png'); &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .css &#123; background-image: url('3x.png'); &#125;&#125; 表单的标签123456789101112131415161718192021222324252627282930313233343536373839404142// input 输入框不可编辑&lt;input type=\"text\" name=\"name\" value=\"xxx\" disabled=\"true\"/&gt;&lt;input type=\"text\" name=\"name\" value=\"xxx\" readonly=\"true\"/&gt;/* disabled 文本框变灰，通过request.getParameter(\"name\")得不到文本框中的内容readonly 只是使文本框不能输入，样式没有变化，通过request.getParameter(\"name\")可以得到内容 */// ios 输入的时候英文首字母的默认大写&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt;// android 上去掉语音输入按钮input::-webkit-input-speech-button &#123; display: none&#125;// ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only;&#125; /* -webkit-user-modify 这个属性使用需谨慎，副作用就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类，不使用a或者input标签，直接用div标签 */// 表单元素的默认外观重置 -webkit-appearance:none;// 修改表单输入框 placeholder 的颜色值 input::-webkit-input-placeholder&#123;color:#ccc;&#125; input:focus::-webkit-input-placeholder&#123;color:#eee;&#125; // 注意 placeholder, ios 可以换行，android 不可以// Input 的placeholder会出现文本位置偏上的情况input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal// 禁用 select 默认下拉箭头select::-ms-expand &#123;display: none;&#125; // 禁用 radio 和 checkbox 默认样式input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display: none; &#125; a标签12部分安卓手机 a 标签用作按钮的时候，页面显示空白解决办法：用 button 标签替换 a 标签 button12345678910// 去除button在ios上的默认样式.css &#123; -webkit-appearance: none; border-radius: 0 &#125;// 不想让按钮touch时有蓝色的边框 .css &#123; -webkit-tap-highlight-color:rgba(0,0,0,0);&#125; audio和video12345678910111213// 在ios和andriod中,audio元素和video元素在无法自动播放// 应对方案：触屏即播$('html').one('touchstart',function()&#123; audio.play()&#125;)// ios 视频默认全屏播放，如何阻止全屏播放－ webkit-playsinline&lt;video id=\"video\" src=\"\" webkit-playsinline poster=\"\" &gt;&lt;/video&gt;// 视频，音频获取播放结束后的回调函数－ended$('#video').on('ended',function()&#123; alert(0);&#125;); click点击事件300毫秒延迟1234// 300毫秒延迟解决方案1.fastclick可以解决在手机上点击事件的300ms延迟2.zepto的touch模块，tap事件也是为了解决在click的延迟问题3.触摸事件的响应顺序为 touchstart --&gt; touchmove --&gt; touchend --&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题 ios(label,span)监听click事件,不触发1234// 所监听元素加上.css &#123; cursor:pointer&#125; css部分@-webkit-keyframes 注意12以0%开始100%结束，0%的百分号不能去掉after和before伪类无法使用动画 border-radius 注意123不支持%单位三星 Galaxy S4中自带浏览器不支持 border-radius 缩写同时写入 border-radius 和背景色的时候，背景色会溢出到圆角以外部分 解决 transition 闪屏123456.css&#123; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; &#125; 阻止用户调整微信浏览器字体大小1234// ios 管事，android 暂无解决方案body&#123; -webkit-text-size-adjust: 100%!important;&#125; 屏幕旋转的事件和样式12345678910111213141516171819202122232425// 1. 事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；// 代码判断window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125; &#125;// 2. 样式/*竖屏时使用的样式*/ @media all and (orientation:portrait) &#123; .css&#123;&#125; &#125;/*横屏时使用的样式*/ @media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; fixed元素无法点击1234567场景：父元素设置position: fixed;子元素设置position: absolute;此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。测试平台： 小米1S，Android4.0的Chrome18解决办法： 把父元素和子元素的overflow: hidden去掉。 overflow1234body如果设置height:100%;overflow:hidden是依然可以滑动的，如果需禁止，要再加一层div设置 height:100%加overflow：hidden（html,body加height:100%） ，这样元素超出body的高度也不能滑动了。或者同时给html，body加height:100%;overflow:hidden ios阻止旋转屏幕时自动调整字体大小123html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust:none;&#125; 通过transform进行skew变形，rotate旋转会造成出现锯齿现象123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0);transform: rotate(-4deg) skew(10deg) translateZ(0);outline: 1px solid rgba(255,255,255,0) iOS6下伪类:hover12345除了&lt;a&gt;之外的元素无效；在Android下则有效。类似div#topFloatBar_l:hover #topFloatBar_menu &#123; display:block; &#125;这样的导航显示在iOS6点击没有点击效果，只能通过增加点击侦听器给元素增减class来控制子元素。 点击按钮时背景变黑色的解决12345678910// 点击按钮时背景变黑色的解决-webkit-tap-highlight-color: transparent;// 当我们去掉默认的大黑块儿后，要添加自己想要的点击时按住按钮的效果，用以下代码：span:active&#123; box-shadow: inset 0 5px 10px #B41313,inset 0 -5px 10px #B41313;&#125;// 添加完上述代码后，在安卓上，都可以看到想要的效果，但是iphone上依旧不行，// :active 需要一个触发事件才可以，于是乎，用以下代码：document.body.addEventListener('touchstart', function () &#123;&#125;); retina屏下border的1px会变粗123456789101112131415161718192021222324252627282930313233343536373839404142434445// 因为像素比，比如，iphone6的像素比是2，window.devicePixelRatio可以查看，// iphone6的设备宽是375,而物理像素是750，在css中的1px，实际控制的是2px的像素，// 所以看起来会变粗了// 解决一：IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125;// 解决二：background渐变// 背景渐变, 渐变在透明色和边框色中间分割, frozenUI用的就是这种方法, 借用它的上边框写法:@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .ui-border-t &#123; background-position: left top; background-image: -webkit-gradient(linear,left bottom,left top,color-stop(0.5,transparent),color-stop(0.5,#e0e0e0),to(#e0e0e0)); &#125;&#125;// 解决三：// :before, :after与transform.radius-border&#123; position: relative;&#125;@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .radius-border:before&#123; content: \"\"; pointer-events: none; /* 防止点击触发 */ box-sizing: border-box; position: absolute; width: 200%; height: 200%; left: 0; top: 0; border-radius: 8px; border:1px solid #999; -webkit-transform(scale(0.5)); -webkit-transform-origin: 0 0; transform(scale(0.5)); transform-origin: 0 0; &#125;&#125; iphoneX兼容补充iphoneX适配 微信浏览器&amp;&amp;安卓&amp;&amp;ios禁止页面下拉刷新123456789// cssbody &#123; touch-action: none;&#125; // jsdocument.body.addEventListener(&apos;touchmove&apos;, (e) =&gt; &#123; e.preventDefault(); e.stopPropagation();&#125;, &#123; passive: false &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"/tags/兼容性/"}]},{"title":"vue自定义指令之输入框限制字数","slug":"vue自定义指令之输入框限制字数","date":"2019-03-01T06:36:24.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2019/03/01/vue自定义指令之输入框限制字数/","link":"","permalink":"/2019/03/01/vue自定义指令之输入框限制字数/","excerpt":"input输入框限制字数的指令制作","text":"input输入框限制字数的指令制作 vue自定义指令之输入框限制字数vue自定义指令没啥说的，说明见官网,具体代码见下面:12345678910111213141516171819Vue.directive('inputvalidatecounter', &#123; inserted: function (el, binding) &#123; var nSpan = document.createElement('span'), nInput = el.querySelector('input'), count = +binding.expression || 50; el.appendChild(nSpan); nSpan.innerHTML = '还可以填写'+count+'字'; nInput.addEventListener('input', function(ev) &#123; var num = count - this.value.length; if(num&lt;=0) &#123; setTimeout(() =&gt; &#123; var substr = this.value.substring(0,count-1); this.value = substr; &#125;, 10); &#125; nSpan.innerHTML = '还可以填写'+(num&lt;0?0:num)+'字'; &#125;, false); &#125;&#125;); 需要注意的地方： 这个指令只适用于iview的Input组件，看里边操作dom元素就可以看出来，想改成其它的也是简单。 在更改input的value的时候，最开始改不过来，后来我做了下延迟才解决这个问题，我想应该是在直接给input的value赋值后由于vue还在做监控，所以又给改回去了，所以来个延迟，在它监控触发结束后再改正。 2019年3月4日更改 123456789101112131415161718192021222324252627Vue.directive('inputvalidatecounter', &#123; inserted: function (el, binding, vnode) &#123; var nSpan = document.createElement('span'), nInput = el.querySelector('input') || el.querySelector('textarea'), count = +binding.expression || 50; el.appendChild(nSpan); nSpan.innerHTML = '还可以填写'+count+'字'; nInput.addEventListener('input', function(ev) &#123; var num = count - this.value.length; if(num&lt;=0) &#123; setTimeout(() =&gt; &#123; var substr = this.value.substring(0,count); this.value = substr; // 新添加开始 var keyArr = vnode.data.model.expression.split('.'); var evalStr = 'vnode.context._data'; keyArr.forEach((item, index)=&gt; &#123; evalStr += '[\"'+item+'\"]'; &#125;); eval(evalStr+'=\"'+this.value+'\"') // 新添加结束 &#125;, 10); &#125; nSpan.innerHTML = '还可以填写'+(num&lt;0?0:num)+'字'; &#125;, false); &#125;&#125;); 新添加的内容只有几行，其实是为了修改第一版的bug，当在input里输入内容的时候，超过一定字数后，进入延迟函数，这里把input的value值更改了，但是并没有更改这个指令所在组件里v-model的值，所以，这里需要修正。1234567891011// vnode是这个指令所在的组建的虚拟dom// vnode.data.model.expression 这就可以直接找到v-model里的变量名var keyArr = vnode.data.model.expression.split('.');// vnode知道了，vnode.context很显然就是组件所在的父级组件，可以通过 _data 这个数据去改变v-model里变量的值。var evalStr = 'vnode.context._data';keyArr.forEach((item, index)=&gt; &#123; evalStr += '[\"'+item+'\"]';&#125;);// 经过上边的循环是因为这种情况, v-model=\"formitem.name\"，像这种的值，而不是v-model=\"name\"这种。// 最后需要eval来执行这些字符串组成的代码。eval(evalStr+'=\"'+this.value+'\"')","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"js图片下载之后端部分","slug":"js图片下载之后端部分","date":"2019-02-27T05:31:24.000Z","updated":"2024-01-11T07:00:59.197Z","comments":true,"path":"2019/02/27/js图片下载之后端部分/","link":"","permalink":"/2019/02/27/js图片下载之后端部分/","excerpt":"nodejs服务返回图片二进制数据","text":"nodejs服务返回图片二进制数据 js图片下载之后端部分本站《js图片下载之前端部分》,写了如何利用js来下载图片，第二种方式需要后端返回图片的二进制数据，这篇文章我来写一下如何使用nodejs向前端返图片的二进制数据，我总结了三种方法。 方法一12345app.post('/downimg', function (req, res, next) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.createReadStream('./img/1.jpg') .pipe(res);&#125;); 这种方法利用了stream和pipe，一行代码就解决了，利用fs去读取图片的流只有，用pipe方法把流转给res，res自动就把数据返回给前端。 方法二1234567891011121314151617app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); var data = ''; var readerStream = fs.createReadStream(process.cwd() + '/img/1.jpg'); // 设置编码为 binary 必须 readerStream.setEncoding('binary'); readerStream.on('data', function(chunk) &#123; data += chunk; &#125;); readerStream.on('end',function()&#123; // 必须加上binary，返回的是二进制 res.end(data, 'binary'); &#125;); readerStream.on('error', function(err)&#123; console.log(err.stack); &#125;);&#125;); 这个方法其实跟第一个差不多，都是使用了fs的流来读取图片，但是没有使用pipe直接把数据流转给res，需要自己监听数据来处理，这里我试验了好多方式，终于成功了，注意readerStream.setEncoding(‘binary’)和res.end(data, ‘binary’)，都需要加上binary格式。 方法三123456789app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.readFile('./img/1.jpg', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; res.end(data); &#125;);&#125;); 这种方法时最简单的，但是遇到大文件会影响计算机的性能。 总结最后整体代码贴一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var express = require('express');var fs = require('fs');var app = express(); app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;);// stream+pipe方式一app.post('/downimg', function (req, res, next) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.createReadStream('./img/1.jpg') .pipe(res);&#125;); // stream方式二app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); var data = ''; var readerStream = fs.createReadStream(process.cwd() + '/img/1.jpg'); // 设置编码为 binary 必须 readerStream.setEncoding('binary'); readerStream.on('data', function(chunk) &#123; data += chunk; &#125;); readerStream.on('end',function()&#123; // 必须加上binary，返回的是二进制 res.end(data, 'binary'); &#125;); readerStream.on('error', function(err)&#123; console.log(err.stack); &#125;);&#125;);// 直接读取整个文件方式三app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.readFile('./img/1.jpg', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; res.end(data); &#125;);&#125;);var server = app.listen(3000, function () &#123; console.log(\"应用实例，访问地址为 http://%s:%s\", '127.0.0.1', '3000')&#125;)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"js图片下载之前端部分","slug":"js图片下载之前端部分","date":"2019-02-27T02:31:41.000Z","updated":"2024-01-11T07:00:59.197Z","comments":true,"path":"2019/02/27/js图片下载之前端部分/","link":"","permalink":"/2019/02/27/js图片下载之前端部分/","excerpt":"js控制图片下载","text":"js控制图片下载 js图片下载之前端部分这两天有一个小需求，就是点击页面中的下载按钮，下载指定的图片。经过一番的小研究，发现想实现这个功能，基本上都用到a标签的download属性，也就a标签的href指向图片地址，加上download属性后，点a标签就可以下载图片了。但是，有个问题，这需要在同域名下才好用，跨域貌似都不行，所以，在跨域的情况下就得另想办法。我总结了两种方法，一一道来。 方法一利用canvas，就是有一个图片地址，利用canvas把图片画出来，之后再通过canvas的toDataURL方法，将图片转为base64的数据，再把这个数据赋值给a标签的href属性，就可以了。这里注意一点，canvas调取toDataURL方法时，如果是跨域图片需要后台允许跨域，还需要在img标签的”crossOrigin”属性设置为’Anonymous’才管用，最后贴出具体代码：1234567891011121314151617181920212223function downloadImg(url)&#123; // 通过构造函数来创建的 img 实例，在赋予 src 值后就会立刻下载图片，相比 createElement() 创建 &lt;img&gt; 省去了 append()，也就避免了文档冗余和污染 var Img = new Image(), dataURL=''; Img.setAttribute(\"crossOrigin\",'Anonymous'); // 这里允许了跨域图片 Img.src=url; Img.onload=function()&#123; // 要先确保图片完整获取到，这是个异步事件 var canvas = document.createElement(\"canvas\"), // 创建canvas元素 width=Img.width, // 确保canvas的尺寸和图片一样 height=Img.height; canvas.width=width; canvas.height=height; canvas.getContext(\"2d\").drawImage(Img,0,0,width,height); // 将图片绘制到canvas中 dataURL=canvas.toDataURL('image/jpeg'); // 转换图片为dataURL var a = document.createElement('a'), body = document.body; a.download = 'img.jpg'; a.href = dataURL; body.append(a); a.click(); body.removeChild(a); &#125;; &#125; 方法二第二种方法就需要后端配合了，前端使用ajax请求到图片的二进制数据，之后利用了FileReader这个API，具体看代码：1234567891011121314151617181920212223242526 function downloadImg(url) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', url, true); // 请求方式 xhr.responseType = \"blob\"; // 返回类型blob xhr.onload = function () &#123; // 请求完成 if (this.status === 200) &#123; // 返回200 var blob = this.response; var reader = new FileReader(); reader.readAsDataURL(blob); // 转换为base64，可以直接放入a标签的href reader.onload = function (e) &#123; // 转换完成，创建一个a标签用于下载 var a = document.createElement('a'), body = document.body; a.download = 'img.jpg'; a.href = e.target.result; body.append(a); a.click(); body.removeChild(a); &#125; &#125; &#125;; // 发送ajax请求 xhr.send()&#125; 这个方法需要后端发送图片的二进制数据，我也写了nodejs的发送方法，见《js图片下载之后端部分》 方法三这种方式兼容性比较好，方法二在ie(11)下是不兼容的,最好的兼容方法莫过于后端写一个返回图片流的get方式的接口，这样直接window.open或者a标签链接再或者form都可以直接下载，如果后端是post方式，那就只能是form来解决了，见代码：12345678910111213function downloadFile() &#123; var form = document.createElement(&apos;form&apos;); //创建form标签 form.setAttribute(&quot;style&quot;,&quot;display:none&quot;); form.setAttribute(&quot;method&quot;,&quot;post&quot;);//设置请求方式 form.setAttribute(&quot;action&quot;, hostUrl + &apos;/imgpath&apos;); //action属性设置请求路径 document.body.appendChild(form); //页面添加form标签 var input1 = document.createElement(&quot;input&quot;) //创建input标签 input1.setAttribute(&quot;name&quot;, &quot;id&quot;) //参数名 input1.setAttribute(&quot;value&quot;, 1) //参数值 form.appendChild(input1); form.submit();//表单提交即可下载！ document.body.removeChild(form); //页面删除form标签 &#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"浏览器消息提示Notification","slug":"浏览器消息提示Notification","date":"2019-02-14T06:41:44.000Z","updated":"2024-01-11T07:00:59.273Z","comments":true,"path":"2019/02/14/浏览器消息提示Notification/","link":"","permalink":"/2019/02/14/浏览器消息提示Notification/","excerpt":"浏览器自带的消息提示框","text":"浏览器自带的消息提示框 浏览器消息提示Notification这两天有一个新需求，微信网页版有这个功能，就是当浏览器最小化后，微信来消息，这时在电脑桌面的右下角会有消息提示框。这个功能用到了浏览器新特性的Notification接口，虽说兼容性不好，但是在现代浏览器上使用还是可以的。直接贴出demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Notification&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"message\"&gt;弹消息&lt;/button&gt; &lt;button id=\"message-delay\"&gt;弹消息延迟&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var btn = document.getElementById('message'); var btnDelay = document.getElementById('message-delay'); btn.addEventListener('click', ()=&gt; &#123; notifyMe(&#123; title: '消息通知', body: '菜品订单', icon: './asset/image/icon.png' &#125;); &#125;, false); btnDelay.addEventListener('click', ()=&gt; &#123; setTimeout(()=&gt; &#123; notifyMe(&#123; title: '消息通知', body: '菜品订单', icon: './asset/image/icon.png' &#125;); &#125;, 5000); &#125;, false); function notifyMe(options) &#123; // if(!document.hidden) return; // 判断浏览器是否最小化 // 先检查浏览器是否支持 if (!(\"Notification\" in window)) &#123; alert(\"This browser does not support desktop notification\"); &#125; // 检查用户是否同意接受通知 else if (Notification.permission === \"granted\") &#123; // If it's okay let's create a notification var notification = new Notification(options.title, &#123; body: options.body, icon: options.icon, &#125;); &#125; // 否则我们需要向用户获取权限 else if (Notification.permission !== 'denied') &#123; Notification.requestPermission(function (permission) &#123; // 如果用户同意，就可以向他们发送通知 if (permission === \"granted\") &#123; var notification = new Notification(options.title, &#123; body: options.body, icon: options.icon, &#125;); &#125; &#125;); &#125; // 过3秒关闭提示框 setTimeout(function() &#123; notification.close(); &#125;, 3000); &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-01-31T08:57:14.000Z","updated":"2024-09-05T02:32:22.688Z","comments":true,"path":"2019/01/31/git常用命令/","link":"","permalink":"/2019/01/31/git常用命令/","excerpt":"工作中常用的git命令小总结","text":"工作中常用的git命令小总结git常用命令git在我们工作中使用的很多，还有想github这样牛逼的代码托管网站，所以，git这个版本管理工具越来越多的被使用，其实git使用起来还是很复杂的，但是，我平时只是提交代码，所以就用到了几个命令而已，在这里做一下记录。这里，推荐一个git学习网站，点这里 先来个简单点的首先就是把现有的项目clone到本地。1git clone https://github.com/jixoba/jQuery-Seat-Charts.git 之后就是我常用的几个提交命令12345git status // 查看更改的文件有哪些git add . // add后边.的话，就是把所有改动的文件添加进去git commit -m &quot;提交log信息&quot; // 提交信息git pull // 拉取远程仓库的内容git push // 最后把更改内容推到远程仓库中 以上就是我经常用到的简单命令，如果有分支的话可能会复杂点，根据提示就可以了 说点复杂的查看已经add到暂存区的文件1git ls-files 查看提交日志12345678git log // 显示从最近到最远的提交日志git log --pretty=oneline // 信息简化的日志git log --graph --pretty=oneline --abbrev-commit // 查看分支合并信息git reflog // 记录你操作的每一次命令git log -p // 显示文件更改的内容git log --name-only // 查看都有哪些文件发生了改动git log --name-status // 查看都有哪些文件发生了改动并且显示是添加，修改，还是删除操作git log --oneline --decorate --all --graph // 以分支图的形式展示提交信息 版本回退12345678git reset --hard commit_id// 具体步骤1) git log // 查看所有的提交历史记录2) git reset --hard commit_id // 回退到指定的commit_id3) git push --force // 这里加上--force是强制更新远程库，如果不使用--force的话，会提示需要先拉取远程库，这样的话又回到了reset之前的commit版本了4) // 回退之后进行了相应处理，如果再想恢复到最新代码的版本的话 git reflog // reflog命令能够查看所有的commit版本信息，log的话只能查看当前版本之前的版本 5) git reset --hard commit_id // 再使用这个命令进行版本切换 撤销修改(只能撤销工作区的修改)1git checkout -- readme.txt // 就是让这个文件回到最近一次git commit或git add时的状态 撤销修改(已经add到暂存区，但是没有commit到版本库)12git reset HEAD readme.txt// 可以将暂存区文件修改恢复到工作区，再使用git checkout -- readme.txt，撤销工作区的修改 查看分支12git branch -a //查看所有分支git branch -r //查看远程分支 新建分支12git branch branchname // branchname就是分支名git switch -c branchname // 新版本git命令，创建并切换 本地切换分支12git checkout branchnamegit switch branchname // 新版本git命令，切换分支 删除本地分支12git branch -d branchnamegit branch -D branchname // 强制删除没有被合并的分支 合并分支merge123// 假设当前在master分支上，想合并bugFix分支的内容git merge bugFixgit merge --no-ff -m &quot;merge with no-ff&quot; bugFix // merge的时候不是Fast forward模式，此处会有一个commit提交点 cherry-pick12345// 单个pickgit cherry-pick 4c805e2// 场景，dev分支超master分支好多个commit，但是，master只想合并4c805e2这个commit，在master分支上使用git cherry-pick 4c805e2// 多个pickgit cherry-pick 4c805e1 4c805e2 4c805e3 4c805e4 4c805e5 合并分支rebase12// 假设当前在master分支上，想合并bugFix分支的内容git rebase bugFix 工作区暂时存储123456789git stash // 将当前工作区的修改存储起来，这时git status查看是clean的，之后可以新建分支或者切换分支等操作git stash list // 查看stash暂存列表git stash apply // 恢复git stash drop // 删除stash列表中的记录git stash pop // apply和drop的组合// 如果有多个stash，可以这样使用git stash pop stash@&#123;0&#125; 克隆带有分支的项目方法一1git clone -b template https://github.com/iview/iview-admin.git // clone template分支 克隆带有分支的项目方法二1234567git clone https://github.com/iview/iview-admin.git // clone整个项目git branch -a //列出所有分支名称如下： * 号表示当前分支 * dev remotes/origin/HEAD -&gt; origin/dev remotes/origin/desktop remotes/origin/template 接下来，可以在本地新建分支并与远程仓库的分支进行关联了1git checkout -b template origin/template // 作用是checkout远程仓库origin的分支template，在本地起名为template分支，并切换到本地的template分支 把本地已有的分支推送到远程仓库上1git push origin 本地分支名:远程分支名 删除远程仓库的分支1git push origin --delete 远程分支名 比较两个版本区别 diff12345678910111213141516171819git diff // 比较工作区和暂存区修改git diff HEAD // 比较工作区和当前分支最新的提交git diff commitId // 比较工作区和commitId版本的区别git diff branchName // 比较工作区和branchName分支最新提交的区别git diff --cached // 比较暂存区和当前分支最新提交区别,跟工作区比较一样，后边也可以接参数git diff commitId1 commitId2 // 比较两个commit之间的差异git diff HEAD^ HEAD // 还可以写HEAD来查看差异git diff branchName1 branchName2比较两个分支上最新提交之间的差异以上命令后边都可以接具体的文件夹或文件名，多个中间用空格分开git diff src1 src2git diff file1 file2在命令行查看信息不方便，可以把内容输出到一个文件：git diff commitId1 commitId2 &gt; difflog.txt 标签tagtag是相对于分支的，每个分支都有自己tag123456789101112git tag // 查看tag列表(查看的是本地tag列表，git pull后就会把远程的tag拉下来)git tag v1.0 // 当前分支的当前commit创建v1.o名字的taggit tag v2.0 f52c633 // 给id是f52c633的commit加taggit show &lt;tagname&gt; // 查看tag的详细信息git checkout &lt;tagname&gt; // 切换到指定的tag版本// 默认创建的tag只在本地，如果推送标签到远程库git push origin &lt;tagname&gt; // 推送单个taggit push origin --tags // 一次性推送全部尚未推送到远程的本地标签// 删除taggit tag -d &lt;tagname&gt; // 删除tag，只删除本地的taggit push origin :refs/tags/&lt;tagname&gt; // 删除远程的tag 配置123git config --global user.name &quot;myName&quot; // 配置全局用户名git config --global user.email &quot;123456@qq.com&quot; // 配置全局用户邮箱git config --global color.ui true // 配置Git显示颜色 git常用命令图片","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"jquery座位插件","slug":"jquery座位插件","date":"2019-01-29T07:44:05.000Z","updated":"2024-01-11T07:00:59.196Z","comments":true,"path":"2019/01/29/jquery座位插件/","link":"","permalink":"/2019/01/29/jquery座位插件/","excerpt":"一个画座位图的jquery插件","text":"一个画座位图的jquery插件 jquery座位插件最近这两天在画飞机的座位布局图和选座系统，本来想自己直接用原生画出来的，但是领导说其他部门做过相关功能，别的部门用的是jQuery-Seat-Charts这个插件，所以我也得使用。这里是插件地址，我fork了下来其实，这个插件的使用很简单，按照giyhub的文档就可以使用，因为需要定制开发，所以我大致的看了一下源码，觉得很好，主要是它在每个座位上加的事件，如果是我写的话，可能使用click事件，但是它用的focus事件和blur事件，正常情况下只有form表单的一些元素才有focus事件，但是想在div上也使用focus事件的话，需要给这个div加上tabIndex属性，一般情况下设为-1，就可以直接使用div的el.focus()方法了，我觉得这个好处就是，当点击其它座位时，之前focus的座位会触发blur事件，可以在这里做一些操作，简化了代码。以后再画座位的时候还可以使用这个插件，比如电影院选做系统，动车，飞机等，还是很方便的的。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"手写一个trigger插件","slug":"手写一个trigger插件","date":"2019-01-22T07:22:58.000Z","updated":"2024-02-20T07:11:25.725Z","comments":true,"path":"2019/01/22/手写一个trigger插件/","link":"","permalink":"/2019/01/22/手写一个trigger插件/","excerpt":"自己写一个简单的trigger来触发事件","text":"自己写一个简单的trigger来触发事件 手写一个trigger插件各位小伙伴们，jquery大家超级熟悉吧，jquery的trigger函数一定知道吧，反正我是非常喜欢用它，有时候比如要把一个弹出层隐藏掉，大家可能会去改这个弹出层的css，但是我可能会直接trigger一下这个弹出层取消按钮，因为我懒嘛，哈哈。但是，有时候可能想用trigger的时候，发现并没有使用jquery，额，自己写一个吧，其实，这段代码的核心部分我是参考了百度的一个手势库，好像叫touch.js,当时看的时候貌似这个库已经5年没人维护了，不过，模拟触发事件的代码被我留下了。见下面：12345678910111213141516171819202122232425262728293031323334;(function(root, factory) &#123; if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory; else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"jinuxTrigger\"] = factory; else root[\"jinuxTrigger\"] = factory;&#125;)(this, function(el, evt, detail) &#123; detail = detail || &#123;&#125;; var e, opt = &#123; bubbles: true, cancelable: true, detail: detail &#125;; try &#123; if (typeof CustomEvent !== 'undefined') &#123; e = new CustomEvent(evt, opt); if (el) &#123; el.dispatchEvent(e); &#125; &#125; else &#123; e = document.createEvent(\"CustomEvent\"); e.initCustomEvent(evt, true, true, detail); if (el) &#123; el.dispatchEvent(e); &#125; &#125; &#125; catch (ex) &#123; console.warn(\"jinux-trigger is not supported by environment.\"); &#125;&#125;); 再附上一个小demo123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jinux-trigger&lt;/title&gt; &lt;script src=\"./trigger.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;页面加载进来之后，等待3秒后代码触发按钮的点击事件&lt;/h1&gt; &lt;button&gt;点击...&lt;/button&gt;&lt;/body&gt;&lt;script&gt; const btn = document.querySelector('button'); btn.addEventListener('click',()=&gt;&#123; alert('点击按钮被点击了！！！'); &#125;,false); //页面加载进来之后，等待3秒后代码触发按钮的点击 setTimeout(()=&gt;&#123; jinuxTrigger(btn,'click'); &#125;,3000);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"手写","slug":"手写","permalink":"/tags/手写/"}]},{"title":"谷歌黑语法","slug":"谷歌黑语法","date":"2019-01-14T05:49:16.000Z","updated":"2024-01-11T07:00:59.278Z","comments":true,"path":"2019/01/14/谷歌黑语法/","link":"","permalink":"/2019/01/14/谷歌黑语法/","excerpt":"关于搜索引擎的一些使用技巧","text":"关于搜索引擎的一些使用技巧 谷歌黑语法平时，我们经常用百度来搜索一些东西，由于墙的原因，我们很少用谷歌，但是我们工作生活中使用百度就已经足够了。今天这篇文章介绍一下谷歌搜索的使用技巧，因为谷歌是所搜的老大，所以其它搜索引擎也来效仿谷歌，因而，下边介绍的这些搜索知识，基本上所有的搜索引擎都会适用的。 基础语法谷歌的默认搜索是and逻辑，意思就是，我们在输入关键字后进行搜索时，如输入：“program google”后，会搜出包含“program”和“google”的文件内容，如下图1所示。说到这里，我就插入一个小知识点：基础布尔逻辑。对于一个搜索引擎来说，进行搜索的时候是要搜索到匹配到所有关键词的页面，还是包含关键词中的任意关键词就可以，取决于一个搜索引擎的一些特别算法，称之为搜索引擎的布尔逻辑默认值。而google就是用and作为默认逻辑（搜索到所有的关键词），当然这个前提是我们没有输入一些特殊的命令。如果你不确定你要搜索的内容，或者你想搜索两个中的任意一个，那么就要使用关键词“OR”。注意：OR是大写的，小写是不起作用的，而且，每一个关键词与“OR”之间是有一个空格的，我们来看一下搜索结果。当然，可以预想的是，google的结果要比program多得多，所以结果第一页全是有关google的内容。此外，还可以借助计算机体系语言中的“|”来代替“OR”，效果是一样的。当然，如果你希望搜索“programgoogle”的内容，而不希望这两个单词之间有任何其他的内容，那么就要使用双引号把搜索的内容组成一个词组来达到目的。如下图3所示。如上图所示，结果中的programgoogle都是在一起的，没有分割。当然这样的结果比较少，只有2740个，但是看图1，结果却有7亿多个。而且，大部分搜索引擎都有智能断句的功能，如果没有特殊的命令，搜索引擎会一定量的根据大众的语言使用习惯来判断你要搜索什么，而这样的做法，不仅仅没有使搜索引擎显得不听话，反而对大众来讲搜索引擎变得十分智能和高效！但是如果我们只想看到“program”的内容，而不希望看到“google”的内容，就可以把“-”（减号或者破折号）应用到搜索当中去，语法为“program -google”，注意，“-”之前是有一个空格的，而其后却是和下一个关键词是紧紧相连的！搜索的结果如下图4所示。可以看得到结果中都会包含program，而不包含google。说到这里，还要提一下google的约束扩展问题了。一般来说，当输入关键词后，google会把相关网页和信息的结果呈现在我们面前。然而，有一些单词在搜索引擎中是会被智能忽略的，导致我们得不到想要的结果。比如十分常用的“www”和“the”，基本上任何一个网页上都会找到的东西，就会被google自动忽略（不要觉得这样不好，还是那个道理，在实际引用当中这样做反而显得更加高效和智能）。如果我们不想忽略这些词进行查询，就得在这些关键词的前面加上符号“+”。如下图5所示：看上去两者好像没有什么大的区别，其实仔细比较一下搜索结果就可以看得出，加上加号的搜索结果有一万多个，而不加加号的结果却有着55亿多！而因为google和www的关联度比较高，所以在前面的结果表现的差别不大。除了上述字符之外，一些搜索引擎支持一种叫做“stemming”（填充）的技术。Stemming是指在查询的关键词中添加一些通配符，通常是“*”，有时候也可能是“？”，这些通配符的作用是要求搜索引擎进行查询是可以返回多个不同的结果。其中通配符代表占位，可以匹配其他任意字母和单词，而其他的字或词组与用户输入的相同。如我们想要搜索“Lionel Messi”的内容，却忘记了第一个单词的一些拼写，就可以输入“l*Messi”进行查询，注意：此处整个字符串是要用一个英文半角双引号括住的！结果如下图所示。可以看到，google自动匹配出Lionel Messi的内容并且进行了搜索。这样的方式有利于我们只能记住单词或短语的一部分的内容时使用。基本的语法就讲到这里，上述的内容也没有列全，因为有些搜索功能不太常用。不过，这些语法就已经够我们日常使用的了，基本语法就是做基本的事，google也有一些高级的语法，见下边高级语法。 高级语法intitle首先要介绍的就是“intitle:”的用法，这个串的作用是将搜索的范围局限在标题上。在关键词前面加上这个，就会只对网页的标题进行搜索并且配对，最后将结果返回给用户。例如输入“intitle:program moon”进行搜索，就会返回如下图所示的结果。但是可以看到，貌似搜索结果中只出现了关于program的内容，而并没有moon相关的内容，这里其实还是牵扯到搜索引擎的基础布尔逻辑问题，在intitle:语法上，google会检索所有的网页，只要出现program或者moon其中的一个就会被匹配，意料之中的是，关于program的内容肯定是要远远多于moon的内容的，所以搜索结果里关于program的内容占据了主导，可以理解为moon这个关键词被一定量的智能忽略了。但是如果我们想要找到网页标题中既有program又有moon的网页呢?那么我们就要使用“intitle:”的一个变体“allintitle:”，使用这个前缀后，就能得到我们想要的结果了。如下图所示，除了第一条为google的图片推荐，其余的结果中网页的标题既含有program这个关键词，又含有moon这个关键词。 intext看到这个单词，大概就可以猜到它的意义了，“intext:”是用来搜索网页正文内容的，这样就可以忽略网页中的超文本链接、URL和题目。我们输入“intext:2018 program”进行搜索，结果如下图所示，结果中显示的网页大部分标题几乎没有规律，但是网页的索引中都包含着 “2018 program”，但是因为2018和program的同时出现的网页实在比较少，两个关键词的关联度实在不高（笔者此时的时间为2016年12月25日00:07:10），因为现在才是2016年，如果换成“2016 program”我相信应该会有更多的结果出现。但是我们要明白，这时搜索引擎关注的内容是网页的正文。与之相对应的也有一个变体：“allintext:”，用法和上面的“allintitle”相似，我就不做过多的介绍了。到这里恐怕就有读者要问了，这与我们平时的搜索相比没有什么高级的地方啊？确实，就平时的搜索来讲，这个语法的意义确实不太重大，但是在某些领域，例如黑客作为一名攻击者，构造好关键词配合适当的语法就可以进行撒网式的攻击，这个呢，我们点到为止，这里就不谈了。 inanchor这个语法的意思是在页面的链接锚点进行搜索。链接锚点指的是一个链接的描述文本，如这样的一段HTML代码：&lt;a href=https://www.baidu.com&gt;百度，链接的锚点就是“百度”了。我们搜索“inanchor:login”就可以搜索到有那些含有锚点的网页了，如下图所示。当然，这个语法也有一个变体“allinanchor:”，意思也与前面的类似。 site这个语法是把搜索限制在站点域名之内。例如我们搜索“program site:google.com”，结果如下图所示，这里呢，我们通常不需要加上前面的www，这样搜索的结果就会是包括所有含有google.com域名的有关内容，包括顶级域名和二级域名甚至三级域名的内容。也就是说我们甚至可以通过搜索，确定google.com大概有多少个子域名！ inurlinurl:会将搜索的范围限制在URL或者网站的页面上，这个语法对于查找搜索和帮助是很有用的，不仅适合我们普通的搜索，在黑客搜索中用处也很大。例如我们输入“inurl:password”，结果如下图所示，结果显示了所有URL中含有password的网页。另外，这个语法也有一个变体：“allinurl:”，用法与前面的相似。在黑客领域，inurl和site的使用是十分的频繁的，利用他们组合可以搜索到有用的信息，如我们可以使用1“site:google.com –inurl:www.google.com”，而这个语法的含义就是搜索google到底有多少个子域名。 link这个的功能是查询所有链接到某个特定URL上的列表。要注意的是，是特定的URL页面，如输入：1“link:www.baidu.com” 进行搜索，如下图所示，就会返回所有链接到百度主页的网页了。因此，我们同样可以指定特定的URL页面来进行搜索。 cacheCache可以帮助我们查找到google索引过的页面副本，它最大的好处就是即使源文件界面不存在了，或者变成了其它的内容，我们依然可以搜索的到。例如输入:1“cache：www.baidu.com” 结果如下所示，可以看到，格式虽然乱糟糟的，但是依稀可以从中获取一些有用的信息的。在国内的搜索引擎上，可能也有类似的功能，比如百度的网页快照，其功能与这个类似。 filetypefiletype是指搜索指定后缀的文件。这个不太常用，但是在黑客领域有一定的作用。但是我们的重点是讲解语法，所以这里就一笔带过（关于filetype的一些其他内容我会在以后的博文中展示），如下图所示，输入“filetype:mdb”，结果就会显示出一些网站的数据库文件。 related这个语法是用于搜索与某些页面相关的网站的，可以辅助我们搜索同类的页面。比如我们输入1“related:www.google.com” 显示的结果都是一些其他的搜索引擎。 info这个语法可以搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等，注意下面的英文信息就好。输入1“info:www.google.com” 结果如下图所示。 好了，大概就这么多了，还用别的这里就不介绍了，对于我这种小白来说已经够用的了。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"es6-async-await","slug":"es6-async-await","date":"2019-01-03T06:17:47.000Z","updated":"2024-01-11T07:00:59.180Z","comments":true,"path":"2019/01/03/es6-async-await/","link":"","permalink":"/2019/01/03/es6-async-await/","excerpt":"es6中async-await的demo","text":"es6中async-await的demo es6-async-awaites6现在已经在项目中使用了，async偶尔用，所以要用的时候总是忘记，写个小demo，用的时候看一眼，哈哈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;es7-async-await&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;es7-async-await&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; //写一个返回Promise的异步函数 function asyncTime(val, ms)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(val); &#125;,ms); &#125;); &#125; //async函数 async function testAsync()&#123; let a = await asyncTime(1, 1000); //a的值就是Promise函数里面resolve的参数值 console.log(a); let b = await asyncTime(a+1, 1000); console.log(b); let c = await asyncTime(b+1, 1000); console.log(c); let d = await 123; //await后面可以不是Promise函数，但是会自动包装成一个Promise函数并且立即向后执行 console.log(d); return c; &#125; testAsync().then(function(res)&#123; console.log('async函数的then函数-&gt;',res); &#125;); //async函数 async function testAsync_2()&#123; let a = await testAsync(); //因为async本身执行后会返回一个Promise函数(async函数内部return的值只作为async返回的Promise函数的then里的参数传入)，所以此处也可以在await后边写async函数。 console.log(a); return a; &#125; testAsync_2().then(function(res)&#123; console.log('async函数2的then函数-&gt;',res); &#125;); //再来一个多个异步函数执行的例子 async function testAsync_3()&#123; let a = await Promise.all([asyncTime('all1',2000),asyncTime('all2',2000),asyncTime('all3',2000)]); console.log(a); return a; &#125; testAsync_3().then(function(res)&#123; alert(res); &#125;);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"github预览静态库页面","slug":"github预览静态库页面","date":"2019-01-02T08:53:42.000Z","updated":"2024-01-11T07:00:59.181Z","comments":true,"path":"2019/01/02/github预览静态库页面/","link":"","permalink":"/2019/01/02/github预览静态库页面/","excerpt":"github预览静态库页面","text":"github预览静态库页面 github预览静态库页面类似于 https://jinux7.github.io 这样的github静态网站展示大家都知道怎么弄，在网上可以搜索到很多教程，我自己的blog网站就是这么搞的，但是这种方法我发现一个github账户只能弄出一个，今天我想说的是另一种方式，直接可以访问到普通库里的静态页面。这里需要github提供的一个服务地址，见下边：1https://htmlpreview.github.io/?https://raw.githubusercontent.com/jixoba/mobile_company/master/index.html 上边的这段地址就可以访问普通库里的静态页面了，注意jixoba/mobile_company这个，是库的名称，只需要更改这个库名，其它地方不需要动。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"cordova android打包配置详解","slug":"cordova-android打包配置详解","date":"2018-12-18T07:27:22.000Z","updated":"2024-01-11T07:00:59.178Z","comments":true,"path":"2018/12/18/cordova-android打包配置详解/","link":"","permalink":"/2018/12/18/cordova-android打包配置详解/","excerpt":"cordova打包android app","text":"cordova打包android app cordova android打包配置详解前几天在网上看到了cordova的东西，之前有过鼓捣react native和weex，所以看看它有什么特点。由于我用的是win10系统，所以在配置环境的时候相当的麻烦，这里稍微的屡一下。 一 安装JDKJDK是java的开发工具包，因为我们打包安卓的apk文件，安卓是依赖java的，所以这个必须安装。我刚开始安装的是最新版的，但是与cordova版本好像不是很搭，于是安装了JDK8这个版本。安装好了之后要配置环境变量，首先是新建变量名JAVA_HOME，指向JDK的安装目录，之后再配置一下path，指向JDK里的bin目录。再配置一下jre的path，也是指向jre里的bin目录。（jre安装有的直接安装JDK的时候顺便安装了，有的版本需要另外单独安装） 二 安装SDKSDK稍微有点复杂，首先还是下载SDK并且安装，这里需要注意，安装路径，我用的win10，必须安装在 用户/用户名/AppData/Local,其它系统可能无所谓。安装好了之后，还是配置环境变量，新建变量名ANDROID_SDK_HOME，指向安装的SDK目录，再配置path，指向SDK下的tools和platform-tools。 三 安装GradleGradle好像是一个打包工具，直接下载安装，之后配置一下Gradle的bin目录环境变量。 四 安装cordovacordova的安装和运行需要nodejs，所以用npm来安装。1npm i -g cordova@6.1.1 注意，这里我安装的是6.1.1版本，高版本莫名其妙的报错，这个稳妥一些。之后就是使用cordova来创建项目喽。12345cordova create app jinux.com.cn app // 创建一个项目cd app // 进入app项目cordova platform android // 添加安卓模板cordova requirements // 查看打包缺少什么依赖项cordova build android // 打包apk 以上的这些命令，在查看依赖项的时候肯定回报一些错误，SDK的一些依赖没有安装，进入SDK文件夹，打开SDK Manager.exe，根据依赖的提示下载相应的包，注意，这里是从谷歌上拉取，所以要开代理哦。第一次build的时候，Gradle需要从网络上下载一堆包，还是注意需要代理拉取谷歌的文件，很慢的，耐心等待。*下面是一个别人写的cordova博文，可供参考参考","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"/tags/cordova/"}]},{"title":"setTimeout&async&Promise执行顺序","slug":"setTimeout-async-Promise执行顺序","date":"2018-12-11T01:59:32.000Z","updated":"2024-01-11T07:00:59.230Z","comments":true,"path":"2018/12/11/setTimeout-async-Promise执行顺序/","link":"","permalink":"/2018/12/11/setTimeout-async-Promise执行顺序/","excerpt":"setTimeout&amp;async&amp;Promise执行顺序简要分析","text":"setTimeout&amp;async&amp;Promise执行顺序简要分析 setTimeout&amp;async&amp;Promise执行顺序看到标题，觉得这种需求在实际项目中基本遇不到，是的，我从没有遇到过，而且，要用就用一种，既然用了async，还用啥Promise。不过，网上有一道面试题，据说是今日头条的面试题，考的就是这方面的知识，先贴出代码。1234567891011121314151617181920async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1') resolve();&#125; ).then(function() &#123; console.log('promise2')&#125; )console.log('script end') 答案一会再说。先来分析一下，setTimeout,async,Promise执行的有先顺序。其实，要想研究明白这个问题，需要了解异步执行的宏任务，微任务知识，而且，在浏览器和nodejs环境下还不一样，这里我不对这些知识作深入分析，因为我看了些相关知识，看的晕头转向，所以，我只简单的记一下在浏览器环境下的优先顺序。异步发生的节点是：1.setTimeout的回调函数。2.Promise实例的then方法中的回调函数。3.async函数中await 后面紧跟着的函数（如async2），这个地方比较有意思，进入async2的时候是同步的，async2里边如果都是同步函数，那就继续执行，等执行完毕，返回先关东西后，”await async2()”这句话下边的语句不会马上执行，有点像Promise实例的then方法中的回调一样，需要排队等待。所以，优先顺序是Promise的then方法回调第一，async await 之后的语句排第二，setTimeout的回调排第三。记住了吗？我没有考虑理论知识，只是简单地死记硬背而已。最后，把上边代码的结果写出来，看看与你想的是否一样。12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"nodejs搭建https服务器","slug":"nodejs搭建https服务器","date":"2018-12-07T07:03:57.000Z","updated":"2024-01-11T07:00:59.226Z","comments":true,"path":"2018/12/07/nodejs搭建https服务器/","link":"","permalink":"/2018/12/07/nodejs搭建https服务器/","excerpt":"ssl证书的创建，https服务器的搭建","text":"ssl证书的创建，https服务器的搭建 nodejs搭建https服务器虽然作者是一名菜鸟前端，但是学习https相关的知识还是必须的。之前看过很多理论的文章，http与https的区别，ssl证书如何起作用的等等，说实话，我都忘记了，今天正好有时间，早上坐地铁就看了相关的文章，刚才写出了一个demo，现在就记录一下整个过程。 http与https区别 HTTP: 超文本传输协议 (Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTPS:（Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。创建ssl证书第一步，安装openssl安装openssl，很简单，按照正常的window软件按照下一步按照就可以，下面是下载地址，注意选择是64bit还是32bit哦,我下载了“Win64 OpenSSL v1.1.1a Ligh”这个版本，因为体积小，所以下载了light的版本。openssl下载地址安装好了之后，配置一下环境变量，这样在哪个文件夹下都可以直接使用openssl命令了。第二部，使用openssl创建ssl证书这个步骤还是有点小困难，在网上按照有的教程弄不好使，后来找到一个教程，好使，直接贴出命令行代码。12345678910111213141516171819202122232425262728293031323334#生成私钥key文件：~ D:\\workspace\\javascript\\nodejs-https&gt;openssl genrsa -out privatekey.pem 1024Generating RSA private key, 1024 bit long modulus...........................++++++........++++++e is 65537 (0x10001)#通过私钥生成CSR证书签名~ D:\\workspace\\javascript\\nodejs-https&gt;openssl req -new -key privatekey.pem -out certrequest.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:BeijingLocality Name (eg, city) []:BeijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:fens.meOrganizational Unit Name (eg, section) []:fens.meCommon Name (eg, YOUR name) []:Conan ZhangEmail Address []:bsspirit@gmail.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []:# 通过私钥和证书签名生成证书文件~ D:\\workspace\\javascript\\nodejs-https&gt;openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pemSignature oksubject=/C=CN/ST=Beijing/L=Beijing/O=fens.me/OU=fens.me/CN=Conan Zhang/emailAddress=bsspirit@gmail.comGetting Private key 注意在通过私钥生成CSR证书签名的时候需要添加一些个人信息。新生成了3个文件：certificate.pem, certrequest.csr, privatekey.pem privatekey.pem: 私钥 certrequest.csr: CSR证书签名 certificate.pem: 证书文件接下来，直接在nodejs的服务代码中引入相关文件就可以了。nodejs创建https服务器直接贴代码了，这步骤就很简单了1234567891011121314151617181920212223242526272829var app = require('express')();var fs = require('fs');var http = require('http');var https = require('https');var privateKey = fs.readFileSync('./ssl/privatekey.pem', 'utf8'), certificate = fs.readFileSync('./ssl/certificate.pem', 'utf8');var credentials = &#123;key: privateKey, cert: certificate&#125;;var httpServer = http.createServer(app);var httpsServer = https.createServer(credentials, app);var PORT = 18080;var SSLPORT = 18081;httpServer.listen(PORT, function() &#123; console.log('HTTP Server is running on: http://localhost:%s', PORT);&#125;);httpsServer.listen(SSLPORT, function() &#123; console.log('HTTPS Server is running on: https://localhost:%s', SSLPORT);&#125;);// Welcomeapp.get('/', function(req, res) &#123; if(req.protocol === 'https') &#123; res.status(200).send('Welcome to Safety Land!'); &#125; else &#123; res.status(200).send('Welcome!'); &#125;&#125;); 好了，https服务器搭建完成，原来这么简单。不过，有个问题，因为这个ssl证书属于个人证书，并不是第三方的安全CA证书，所以在浏览器访问https协议时候会有不安全的提醒文字，这个对于我们测试来说是没问题的，如果想在正规的网站上使用，我们还得去阿里云申请CA证书哦。最后，本想把本demo的代码上传到github，不过，代码实在是简单，不传了，直接放个截图得了。ssl文件夹里放了3个ssl文件哦。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"vue-iview Modal组件简单分析","slug":"vue-iview-Modal组件简单分析","date":"2018-12-04T07:49:12.000Z","updated":"2024-01-11T07:00:59.232Z","comments":true,"path":"2018/12/04/vue-iview-Modal组件简单分析/","link":"","permalink":"/2018/12/04/vue-iview-Modal组件简单分析/","excerpt":"vue-iview Modal组件简单分析","text":"vue-iview Modal组件简单分析 vue-iview Modal组件简单分析现在公司的项目前端框架用的是vue，在工作中避免不了要写一些组件，其实写组件的方法千千种，怎么写都行，但是，总想写出来的组件像一些ui框架里的组件一样高大上，于是乎，今天有点时间，大致的看了一下iview的Modal组件，简单的记录一下思想。由于时间原因，代码并没有深入往里边看，只是把大致的框框看了一下。首先，我们看看Modal组件的用法，官方文档点这里简单的用法如下：1234567&lt;Modal v-model=\"modal12\" draggable scrollable title=\"Modal 1\"&gt; &lt;div&gt;This is the first modal&lt;/div&gt;&lt;/Modal&gt;// 上边这个是基础写法// 下边这个写法可以直接调用，不需要在html中写出&lt;Modal&gt;&lt;/Modal&gt;标签this.$Modal.info(config)this.$Modal.success(config) 先看一下iview的Modal组件文件夹结构index文件是入口文件，里边导出了Modal对象。也就是可以使用标签的原因，因为给Modal对象加一大堆方法，但是它还是一个vue的基础组件。大家可能注意到了，当使用标签定义组建的时候，发现最后组件的dom元素被插入到了body下，而不是在具体引入的位置，这是因为Modal组件里有一个指令：12345// Modal组件里有directives: &#123; TransferDom &#125;// 追溯TransferDom指令，发现有如下代码parentNode.replaceChild(home, el); // moving out, el is no longer in the documentgetTarget(value).appendChild(el); // moving into new place modal.vue文件是组件的基础文件，也就是页面显示出来的东西，index文件里的东西可以看出来，只是给Modal对象添加了一些静态方法，为了this.$Modal.info(config)这样调用的时候使用。confrim文件里主要做了this.$Modal.info()这样调用的时候动态new Vue()实例，也是以modal.vue这个组件为基础，动态的插入到body节点里，代码见下边:就是通过new Vue()的实例获取到这个组建的html代码片段，再插入到body节点中。最后，再看看iview如何变成vue的全局组件的。123456789101112131415const install = function(Vue, opts = &#123;&#125;) &#123; ... // 这里添加全局组件 Object.keys(iview).forEach(key =&gt; &#123; Vue.component(key, iview[key]); &#125;); ... // 这里添加实例方法 Vue.prototype.$Modal = Modal; &#125;; 以上就是大概思路哈。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"小巧的html模板引擎","slug":"小巧的html模板引擎","date":"2018-11-30T06:57:20.000Z","updated":"2024-02-20T07:11:25.725Z","comments":true,"path":"2018/11/30/小巧的html模板引擎/","link":"","permalink":"/2018/11/30/小巧的html模板引擎/","excerpt":"小巧的html模板引擎","text":"小巧的html模板引擎 小巧的html模板引擎今天看coco大神的github，看到了他写的html模板引擎，默默地记录下来，其实，模板引擎我自己也写过一个，不过总觉得大神写的一定比我的好，点击这是我写的先贴出代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * coTemplate * */(function(name, definition) &#123; if (typeof define === 'function') &#123; define(definition); &#125; else &#123; this[name] = definition(); &#125;&#125;)('cotemplate', function() &#123; var tplReg = /\\$\\&#123;\\s*([^\\&#123;\\&#125;\\s]+)\\s*\\&#125;/g; var jsReg = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g; var code = 'var r=[];\\n'; var match = 'undefined'; var pointer = 0; /** * 添加单行逻辑 * @param &#123;*&#125; line */ function lineAdd(line) &#123; code += 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n'; &#125; /** * 模板拼接 * @param &#123;String&#125; tpl 模板字符串 * @param &#123;Objcet&#125; data 模板内替换对象 */ function cotemplate(tpl, data) &#123; while (match = tplReg.exec(tpl)) &#123; // 添加非逻辑部分 lineAdd(tpl.slice(pointer, match.index)); // 添加逻辑部分 \"$&#123;\" + match[1] + \"&#125;\"; code += ('r.push(String(this.' + match[1] + '));'); pointer = match.index + match[0].length; &#125; // 添加代码的最后一截 lineAdd(tpl.substr(pointer, tpl.length - pointer)); // 返回结果，在这里我们就拿到了装入数组后的代码 code += 'return r.join(\"\");'; console.log(code); return new Function(code.replace(/[\\r\\t\\n]/g, '')).apply(data); &#125; /** * export */ return cotemplate;&#125;); 用法Demo1234567891011121314151617181920212223242526&lt;script src=\"../js/cotemplate.js\"&gt;&lt;/script&gt;&lt;script&gt;var data = &#123; name: 'Coco', info: &#123; age: 18 &#125;, bar: &#123; foo: &#123; else: 'co-template' &#125; &#125;&#125;var tpl = ` &lt;p&gt;name:$&#123;coco&#125;&lt;/p&gt; &lt;p&gt;Age:$&#123;info.age&#125;&lt;/p&gt; &lt;div&gt;$&#123;bar.foo.else&#125;&lt;/div&gt; `;cotemplate(tpl, data);// &lt;p&gt;Name:Coco&lt;/p&gt; // &lt;p&gt;Age:18&lt;/p&gt; // &lt;div&gt;HTML-template:co-template&lt;/div&gt; &lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"传入标准时间，返回指定日期格式","slug":"传入标准时间，返回指定日期格式","date":"2018-11-30T06:30:31.000Z","updated":"2024-02-20T07:11:25.726Z","comments":true,"path":"2018/11/30/传入标准时间，返回指定日期格式/","link":"","permalink":"/2018/11/30/传入标准时间，返回指定日期格式/","excerpt":"传入标准时间，返回指定日期格式","text":"传入标准时间，返回指定日期格式 传入标准时间，返回指定日期格式平时在开发时经常会用到获取当前日期，有时候会自己写一个，今天网上闲逛，发现一个写的不错的，记录一下，以备后用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let common = &#123; /** * 传入标准时间，返回指定日期格式 * @param &#123;Number&#125; date * @param &#123;String&#125; format * @example * - dateSerialization(1511181312647, \"y-mm-dd h:i:s\") * - @return 2017-11-20 20:35:12 */ dateSerialization(date, format) &#123; let dateObj; let DEFAULT_FORMAT = \"y-mm-dd h:i:s\"; let _patternArr = [\"y\", \"mm\", \"dd\", \"h\", \"i\", \"s\"]; let _patternMap = &#123; y: function(d) &#123; return d.getFullYear(); &#125;, m: function(d) &#123; return d.getMonth() + 1; &#125;, mm: function(d) &#123; return _pad(d.getMonth() + 1); &#125;, d: function(d) &#123; return d.getDate(); &#125;, dd: function(d) &#123; return _pad(d.getDate()); &#125;, h: function(d) &#123; return _pad(d.getHours()); &#125;, i: function(d) &#123; return _pad(d.getMinutes()); &#125;, s: function(d) &#123; return _pad(d.getSeconds()); &#125; &#125;; if (/^\\d+$/.test(date)) &#123; dateObj = new Date(parseInt(date)); &#125; else if (typeof date == \"string\") &#123; dateObj = new Date(date.replace(/-/g, \"/\")); &#125; else if (_isDate(date)) &#123; dateObj = date; &#125; // 非法数据 if (!dateObj || dateObj.toString() == \"Invalid Date\") &#123; throw new Error(\"[common.date.format]the input cannot be converted to date object(\" + date + \")\"); return; &#125; format = format || DEFAULT_FORMAT; let _resultArr = format.split(/-|:|\\s/); let resultObj = &#123;&#125;; let result = \"\"; _patternArr.forEach(k =&gt; &#123; resultObj[k] = _patternMap[k](dateObj); &#125;); _resultArr.forEach(k =&gt; &#123; let regExp = new RegExp(k); format = format.replace(regExp, function(e) &#123; return resultObj[e]; &#125;); &#125;); return format; &#125;&#125;;function _toString(v) &#123; return Object.prototype.toString.call(v);&#125;function _isDate(v) &#123; return _toString(v) == \"[object Date]\";&#125;function _pad(n) &#123; return n &gt; 9 ? n : \"0\" + n;&#125;export default common;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"高阶函数和高阶组件","slug":"高阶函数和高阶组件","date":"2018-11-29T06:41:59.000Z","updated":"2024-01-11T07:00:59.293Z","comments":true,"path":"2018/11/29/高阶函数和高阶组件/","link":"","permalink":"/2018/11/29/高阶函数和高阶组件/","excerpt":"高阶函数和高阶组件简介","text":"高阶函数和高阶组件简介 高阶函数和高阶组件什么是高阶函数高阶函数就是传入的参数有函数的函数。（有点绕口:)） 什么是高阶组件高阶组件就是传入的参数有组件的组件。:)react比较容易实现高阶组件","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"web安全之CSRF","slug":"web安全之CSRF","date":"2018-11-28T03:10:48.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2018/11/28/web安全之CSRF/","link":"","permalink":"/2018/11/28/web安全之CSRF/","excerpt":"CSRF攻击的简要介绍","text":"CSRF攻击的简要介绍 web安全之CSRF一.CSRF是什么？CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 二.CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 三.CSRF漏洞现状CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别 爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而 现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 四.CSRF的原理下图简单阐述了CSRF攻击的思想：从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：1.登录受信任网站A，并在本地生成Cookie。2.在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 五例子上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1：银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000危险网站B，它里面有一段HTML的代码如下：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中 的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏 览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com /Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账 操作），所以就立刻进行转账操作…… 示例2：为了杜绝上面的问题，银行决定改用POST请求完成转账操作。银行网站A的WEB表单如下：危险网站B，它里面有一段HTML的代码如下：12345&lt;form action=\"Transfer.php\" method=\"POST\"&gt; &lt;p&gt;ToBankId: &lt;input type=\"text\" name=\"toBankId\" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=\"text\" name=\"money\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"Transfer\" /&gt;&lt;/p&gt; &lt;/form&gt; 后台处理页面Transfer.php如下：1234567&lt;?php session_start(); if (isset($_REQUEST['toBankId'] &amp;&amp; isset($_REQUEST['money'])) &#123; buy_stocks($_REQUEST['toBankId'], $_REQUEST['money']); &#125; ?&gt; 危险网站B，仍然只是包含那句HTML代码：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的 原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成 了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST 请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3：经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：1234567&lt;?php session_start(); if (isset($_POST['toBankId'] &amp;&amp; isset($_POST['money'])) &#123; buy_stocks($_POST['toBankId'], $_POST['money']); &#125; ?&gt; 然而，危险网站B与时俱进，它改了一下代码：1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function steal() &#123; iframe = document.frames[\"steal\"]; iframe.document.Submit(\"transfer\"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"steal()\"&gt; &lt;iframe name=\"steal\" display=\"none\"&gt; &lt;form method=\"POST\" name=\"transfer\" action=\"http://www.myBank.com/Transfer.php\"&gt; &lt;input type=\"hidden\" name=\"toBankId\" value=\"11\"&gt; &lt;input type=\"hidden\" name=\"money\" value=\"1000\"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一 个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了 CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 六.CSRF的防御我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 1.服务端进行CSRF防御服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值)：这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;12345&lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。123456789&lt;?php $hash = md5($_COOKIE['cookie']); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证123456789101112&lt;?php if(isset($_POST['check'])) &#123; $hash = md5($_COOKIE['cookie']); if($_POST['check'] == $hash) &#123; doJob(); &#125; else &#123; //... &#125; &#125; else &#123; //... &#125;?&gt; 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就 另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 (2).验证码这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值)在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提 交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单 都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。以下我的实现: 1).先是令牌生成函数(gen_token())：1234567&lt;?php function gen_token() &#123; //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token =md5(uniqid(rand(), true)); return $token; &#125; 2).然后是Session令牌生成函数(gen_stoken())：123456789101112 &lt;?php function gen_stoken() &#123; $pToken = \"\"; if($_SESSION[STOKEN_NAME] == $pToken)&#123; //没有值，赋新值 $_SESSION[STOKEN_NAME] =gen_token(); &#125; else&#123; //继续使用旧的值 &#125; &#125;?&gt; 3).WEB表单生成隐藏输入域的函数：1234567&lt;?php function gen_input() &#123; gen_stoken(); echo “&lt;input type=\\”hidden\\” name=\\”\" . FTOKEN_NAME . “\\” value=\\”\" . $_SESSION[STOKEN_NAME] . “\\”&gt; “; &#125;?&gt; 4).WEB表单结构：12345678910&lt;?php session_start(); include(”functions.php”);?&gt;&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt;&lt;/FORM&gt; 5).服务端核对令牌：这个很简单，这里就不再啰嗦了。上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"web安全之XSS","slug":"web安全之XSS","date":"2018-11-28T01:40:42.000Z","updated":"2024-01-11T07:00:59.237Z","comments":true,"path":"2018/11/28/web安全之XSS/","link":"","permalink":"/2018/11/28/web安全之XSS/","excerpt":"XSS攻击的简要介绍","text":"XSS攻击的简要介绍 web安全之XSS首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型 XSS非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。一个例子，比如你的 Web 页面中包含有以下代码：12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL1(类似：https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码非持久型 XSS 漏洞攻击有以下几点特征 :1 . 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据2 . 攻击者需要诱骗点击3 . 反馈率低，所以较难发现和响应修复4 . 盗取用户敏感保密信息 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情 :1 . Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。2 . 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。3 . 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。4 . 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。5 . 前端渲染的时候对任何的字段都需要做 escape 转义编码。 escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 &lt;，&gt;，空格 等，转义成 &lt;，&gt;， 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。 持久型 XSS持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件 :1 . POST 请求提交表单后端没做转义直接入库。2 . 后端从数据库中取出数据没做转义直接输出给前端。3 . 前端拿到后端数据没做转义直接渲染成 DOM。 持久型 XSS 有以下几个特点 :1 . 持久性，植入在数据库中2 . 危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。3 . 盗取用户敏感私密信息 为了防止持久型 XSS 漏洞，需要前后端共同努力 :1 . 后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。2 . 后端在输出给前端数据统一进行转义处理。3 . 前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。 基于字符集的 XSS其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。 以基于 utf-7 的 XSS 为例utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。123&lt;script&gt;alert(\"xss\")&lt;/script&gt;可以被解释为：+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4- 可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。 所以我们有什么办法避免这种 XSS 呢 ?1 . 记住指定 2 . XML 中不仅要指定字符集为 utf-8，而且标签要闭合3 . 牛文推荐：http://drops.wooyun.org/papers/1327 （这个讲的很详细） 基于 Flash 的跨站 XSS基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。 避免方法 :1 . 严格管理 cookie 的读写权限2 . 对 Flash 能接受用户输入的参数进行过滤 escape 转义处理 未经验证的跳转 XSS有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。 这时候需要通过以下方式来防止这类漏洞 :1 . 对待跳转的 URL 参数做白名单或者某种规则过滤2 . 后端注意对敏感信息的保护, 比如 cookie 使用来源验证。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"利用正则表达式统计代码行数","slug":"利用正则表达式统计代码行数","date":"2018-11-27T05:59:20.000Z","updated":"2024-01-11T07:00:59.259Z","comments":true,"path":"2018/11/27/利用正则表达式统计代码行数/","link":"","permalink":"/2018/11/27/利用正则表达式统计代码行数/","excerpt":"利用ide编辑器统计代码行数","text":"利用ide编辑器统计代码行数 利用正则表达式统计代码行数在项目中，我们常常有统计代码行数的需要，但是如果不利用第三方工具的话，面对一个项目（甚至一个工程或解决方案中若干个项目）中成百上千的代码文件，实在有一种力不从心的感觉。 但利用正则表达式可以巧妙解决。用的工具不是别的，正是所有的IDE（Visual Studio、Eclipse等等）和常用的文本编辑器（SublimeText2、Notepad++等）日常必备软件的“在文件中查找”，不同的软件略有不同，但大同小异。 再复杂的IDE，其搜索功能也是基于字符串的匹配进行的。我们知道，文本中每次换行会增加一个 \\n 。如果直接用正则\\n每一个匹配项就代表一次换行。但需要注意的是文件的最后一行是没有换行符的，所以文本行数=文件数+换行符数目，因而把两个看到的两个数字加起来才是文本行数。 1^.*$ 表示搜索条件为行首与行尾之间包含任意个任意字符（非换行符）。 上面的方法可以很迅速地得到代码行数，不过遗憾的是统计结果把空行（仅包含空格和制表符的行）也统计进去了，然而很多时候我们并不想把这些文本也给算进代码量里去，怎么办呢？别急，我们只要对正则表达式做一点点修改。我的思路是，只需要找出一个不是空格或制表符的字符即可，于是可写出了这个正则表达式1^\\s*[^\\s]+.*$ 它表示先忽略一行前面的连续空格和制表符等，然后寻找是否有一个字符不为空格、制表符、换行符和回车符，如果有则表明这行不为空行。不用1^\\s*\\S+.*$ 是为了下面方便添加其他要排除的注释行或者独立的括号行。 在实际项目中，我们或许认为注释行不应成为生产量，应从统计数据中排除出去。我们首先要能够对注释行有一个认识。很多程序设计语言中，注释行都会用“/”或者“#”等字符开头。我们假设项目中的注释行都是以“/”或“#”开头的（请读者考虑自己项目的特点自行修改）。下面的正则表示，我们要查找的是一行中第一个非空字符不是“/”或“#”或“{”或“}”的行12^\\s*[^\\s/#&#123;&#125;]+.*$ ^\\s*[^ \\t\\n\\r/#&#123;&#125;]+.*$ 作用同上，说明在中括号[]内自定义原子表，打个空格，也可以代表空格。因为控制开头和结尾，所以 + 后不必加问号 ? 取消贪婪模式了。 1^\\s*[^\\s/#&#123;&#125;]+ 也行，但是上面加上控制结尾比较严谨。另外，文本编辑框默认是视为单行的，没有设置多行模式，如果设为多行模式就得注意了。php 中，在定界符最右边加 m 即可视为多行。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"zepto源码","slug":"zepto源码","date":"2018-11-16T08:30:56.000Z","updated":"2024-01-11T07:00:59.241Z","comments":true,"path":"2018/11/16/zepto源码/","link":"","permalink":"/2018/11/16/zepto源码/","excerpt":"zepto源码，有注释","text":"zepto源码，有注释 zepto源码最近在看zepto源码，所以把一些注释也加上了，还没看完，以后继续加。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */(function(global, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) define(function() &#123; return factory(global) &#125;) else factory(global)&#125;(this, function(window) &#123; var Zepto = (function() &#123; var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice, document = window.document, elementDisplay = &#123;&#125;, classCache = &#123;&#125;, cssNumber = &#123; 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 &#125;, fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, // &lt;...&gt;都匹配 singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, // 只匹配没有内容的标签，如: &lt;div&gt;&lt;/div&gt;或&lt;input /&gt; // 匹配&lt;div /&gt;, &lt;: /&gt;这样的，除了&lt;input /&gt;,&lt;img /&gt;这样的 tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig, rootNodeRE = /^(?:body|html)$/i, capitalRE = /([A-Z])/g, // special attributes that should be get/set via method calls methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'], adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ], table = document.createElement('table'), tableRow = document.createElement('tr'), containers = &#123; 'tr': document.createElement('tbody'), 'tbody': table, 'thead': table, 'tfoot': table, 'td': tableRow, 'th': tableRow, '*': document.createElement('div') &#125;, readyRE = /complete|loaded|interactive/, simpleSelectorRE = /^[\\w-]*$/, class2type = &#123;&#125;, toString = class2type.toString, zepto = &#123;&#125;, camelize, uniq, tempParent = document.createElement('div'), propMap = &#123; 'tabindex': 'tabIndex', 'readonly': 'readOnly', 'for': 'htmlFor', 'class': 'className', 'maxlength': 'maxLength', 'cellspacing': 'cellSpacing', 'cellpadding': 'cellPadding', 'rowspan': 'rowSpan', 'colspan': 'colSpan', 'usemap': 'useMap', 'frameborder': 'frameBorder', 'contenteditable': 'contentEditable' &#125;, // 判断是否为数组 isArray = Array.isArray || function(object)&#123; return object instanceof Array &#125; // 判断节点是否包含选择器 zepto.matches = function(element, selector) &#123; if (!selector || !element || element.nodeType !== 1) return false var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector if (matchesSelector) return matchesSelector.call(element, selector) // fall back to performing a selector: var match, parent = element.parentNode, temp = !parent if (temp) (parent = tempParent).appendChild(element) // ~这个符号可以将-1转化为0，直接判断就是false了 match = ~zepto.qsa(parent, selector).indexOf(element) temp &amp;&amp; tempParent.removeChild(element) return match &#125; // 查看数据类型 function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\" &#125; // 判断是否为函数 function isFunction(value) &#123; return type(value) == \"function\" &#125; // 判断是否为window对象 function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125; // 判断是否为document对象 function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125; // 判断是否为object对象 function isObject(obj) &#123; return type(obj) == \"object\" &#125; // 判断是不是纯对象，如 &#123;&#125;,prototype没有添加的 function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype &#125; // 判断是不是类数组对象 function likeArray(obj) &#123; var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length, type = $.type(obj) return 'function' != type &amp;&amp; !isWindow(obj) &amp;&amp; ( 'array' == type || length === 0 || (typeof length == 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) ) &#125; // 压缩精简数组，去掉null，undefined function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array &#125; // 将font-size形式转换为fontSize驼峰形式 camelize = function(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : '' &#125;) &#125; // 将驼峰命名转为-形式,正则的$1,$2...代表前边小括号里的内容 function dasherize(str) &#123; return str.replace(/::/g, '/') .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2') .replace(/([a-z\\d])([A-Z])/g, '$1_$2') .replace(/_/g, '-') .toLowerCase() &#125; // 删除数组中重复的元素，这个方法好牛逼 uniq = function(array)&#123; return filter.call(array, function(item, idx)&#123; return array.indexOf(item) == idx &#125;) &#125; // 如果classCache中没有name的话，则新建一个这个name的正则 function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)')) &#125; // 应该是给css赋值的时候，如果没在cssNumber这个表中的话就加上'px'后缀 function maybeAddPx(name, value) &#123; return (typeof value == \"number\" &amp;&amp; !cssNumber[dasherize(name)]) ? value + \"px\" : value &#125; // 应该是查看如div,table这样的元素的默认display的值 function defaultDisplay(nodeName) &#123; var element, display if (!elementDisplay[nodeName]) &#123; element = document.createElement(nodeName) document.body.appendChild(element) display = getComputedStyle(element, '').getPropertyValue(\"display\") element.parentNode.removeChild(element) display == \"none\" &amp;&amp; (display = \"block\") elementDisplay[nodeName] = display &#125; return elementDisplay[nodeName] &#125; // 获取节点的子元素 function children(element) &#123; return 'children' in element ? slice.call(element.children) : $.map(element.childNodes, function(node)&#123; if (node.nodeType == 1) return node &#125;) &#125; // function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' &#125; // `$.zepto.fragment` takes a html string and an optional tag name // to generate DOM nodes from the given html string. // The generated DOM nodes are returned as an array. // This function can be overridden in plugins for example to make // it compatible with browsers that don't support the DOM fully. zepto.fragment = function(html, name, properties) &#123; var dom, nodes, container // A special case optimization for a single tag if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)) if (!dom) &#123; if (html.replace) html = html.replace(tagExpanderRE, \"&lt;$1&gt;&lt;/$2&gt;\") // 将&lt;div/&gt;转化成&lt;div&gt;&lt;/div&gt; if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1 if (!(name in containers)) name = '*' // 下面的做法就是将'&lt;span&gt;12345&lt;/span&gt;'这样的字符串转为dom节点的形式 container = containers[name] container.innerHTML = '' + html dom = $.each(slice.call(container.childNodes), function()&#123; container.removeChild(this) &#125;) &#125; if (isPlainObject(properties)) &#123; nodes = $(dom) $.each(properties, function(key, value) &#123; if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value) else nodes.attr(key, value) &#125;) &#125; return dom &#125; window.haha = zepto; // `$.zepto.Z` swaps out the prototype of the given `dom` array // of nodes with `$.fn` and thus supplying all the Zepto functions // to the array. This method can be overridden in plugins. zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; // `$.zepto.isZ` should return `true` if the given object is a Zepto // collection. This method can be overridden in plugins. zepto.isZ = function(object) &#123; return object instanceof zepto.Z &#125; // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and // takes a CSS selector and an optional context (and handles various // special cases). // This method can be overridden in plugins. zepto.init = function(selector, context) &#123; var dom // If nothing given, return an empty Zepto collection if (!selector) return zepto.Z() // Optimize for string selectors else if (typeof selector == 'string') &#123; selector = selector.trim() // If it's a html fragment, create nodes from it // Note: In both Chrome 21 and Firefox 15, DOM error 12 // is thrown if the fragment doesn't begin with &lt; if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // If it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // If a function is given, call it when the DOM is ready else if (isFunction(selector)) return $(document).ready(selector) // If a Zepto collection is given, just return it else if (zepto.isZ(selector)) return selector else &#123; // normalize array if an array of nodes is given if (isArray(selector)) dom = compact(selector) // Wrap DOM nodes. else if (isObject(selector)) dom = [selector], selector = null // If it's a html fragment, create nodes from it else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // create a new Zepto collection from the nodes found return zepto.Z(dom, selector) &#125; // `$` will be the base `Zepto` object. When calling this // function just call `$.zepto.init, which makes the implementation // details of selecting nodes and creating Zepto collections // patchable in plugins. $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 深度拷贝的函数 function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key] &#125; // Copy all but undefined properties from one or more // objects to the `target` object. $.extend = function(target)&#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target &#125; // `$.zepto.qsa` is Zepto's CSS selector implementation which // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`. // This method can be overridden in plugins. zepto.qsa = function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = simpleSelectorRE.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all ) &#125; function filtered(nodes, selector) &#123; return selector == null ? $(nodes) : $(nodes).filter(selector) &#125; // 判断父节点中是否包含子节点，parent为父节点，node为子节点 $.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg &#125; // 设置node节点的属性值 function setAttribute(node, name, value) &#123; value == null ? node.removeAttribute(name) : node.setAttribute(name, value) &#125; // access className property while respecting SVGAnimatedString function className(node, value)&#123; var klass = node.className || '', svg = klass &amp;&amp; klass.baseVal !== undefined if (value === undefined) return svg ? klass.baseVal : klass svg ? (klass.baseVal = value) : (node.className = value) &#125; // \"true\" =&gt; true // \"false\" =&gt; false // \"null\" =&gt; null // \"42\" =&gt; 42 // \"42.5\" =&gt; 42.5 // \"08\" =&gt; \"08\" // JSON =&gt; parse if valid // String =&gt; self // 反序列化 function deserializeValue(value) &#123; try &#123; return value ? value == \"true\" || ( value == \"false\" ? false : value == \"null\" ? null : +value + \"\" == value ? +value : /^[\\[\\&#123;]/.test(value) ? $.parseJSON(value) : value ) : value &#125; catch(e) &#123; return value &#125; &#125; $.type = type $.isFunction = isFunction $.isWindow = isWindow $.isArray = isArray $.isPlainObject = isPlainObject // 判断是否为空对象函数 $.isEmptyObject = function(obj) &#123; var name for (name in obj) return false return true &#125; // 判断是否是数字形式的 123或'123' $.isNumeric = function(val) &#123; var num = Number(val), type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; // 判断元素是否在数组中，array数组，elem元素，i是从数组中的第几位开始查找 $.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i) &#125; $.camelCase = camelize $.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str) &#125; // plugin compatibility $.uuid = 0 $.support = &#123; &#125; $.expr = &#123; &#125; $.noop = function() &#123;&#125; // map函数，对elements进行处理后返回新数组 $.map = function(elements, callback)&#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; // 遍历elements，执行callback函数，如果执行时返回false，则停止遍历操作 $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; // 过滤数组 $.grep = function(elements, callback)&#123; return filter.call(elements, callback) &#125; if (window.JSON) $.parseJSON = JSON.parse // Populate the class2type map $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase() &#125;) // Define methods that will be available on all // Zepto collections $.fn = &#123; constructor: zepto.Z, length: 0, // Because a collection acts like an array // copy over these useful array functions. forEach: emptyArray.forEach, reduce: emptyArray.reduce, push: emptyArray.push, sort: emptyArray.sort, splice: emptyArray.splice, indexOf: emptyArray.indexOf, concat: function()&#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) &#125;, // `map` and `slice` in the jQuery API work differently // from their array counterparts map: function(fn)&#123; return $($.map(this, function(el, i)&#123; return fn.call(el, i, el) &#125;)) &#125;, slice: function()&#123; return $(slice.apply(this, arguments)) &#125;, ready: function(callback)&#123; // need to check if document.body exists for IE as that browser reports // document ready when it hasn't yet created the body element if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($) else document.addEventListener('DOMContentLoaded', function()&#123; callback($) &#125;, false) return this &#125;, get: function(idx)&#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length] &#125;, toArray: function()&#123; return this.get() &#125;, size: function()&#123; return this.length &#125;, remove: function()&#123; return this.each(function()&#123; if (this.parentNode != null) this.parentNode.removeChild(this) &#125;) &#125;, each: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this &#125;, filter: function(selector)&#123; if (isFunction(selector)) return this.not(this.not(selector)) return $(filter.call(this, function(element)&#123; return zepto.matches(element, selector) &#125;)) &#125;, add: function(selector,context)&#123; return $(uniq(this.concat($(selector,context)))) &#125;, is: function(selector)&#123; return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector) &#125;, not: function(selector)&#123; var nodes=[] if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function(idx)&#123; if (!selector.call(this,idx)) nodes.push(this) &#125;) else &#123; var excludes = typeof selector == 'string' ? this.filter(selector) : (likeArray(selector) &amp;&amp; isFunction(selector.item)) ? slice.call(selector) : $(selector) this.forEach(function(el)&#123; if (excludes.indexOf(el) &lt; 0) nodes.push(el) &#125;) &#125; return $(nodes) &#125;, has: function(selector)&#123; return this.filter(function()&#123; return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size() &#125;) &#125;, eq: function(idx)&#123; return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1) &#125;, first: function()&#123; var el = this[0] return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, last: function()&#123; var el = this[this.length - 1] return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, find: function(selector)&#123; var result, $this = this if (!selector) result = $() else if (typeof selector == 'object') result = $(selector).filter(function()&#123; var node = this return emptyArray.some.call($this, function(parent)&#123; return $.contains(parent, node) &#125;) &#125;) else if (this.length == 1) result = $(zepto.qsa(this[0], selector)) else result = this.map(function()&#123; return zepto.qsa(this, selector) &#125;) return result &#125;, closest: function(selector, context)&#123; var nodes = [], collection = typeof selector == 'object' &amp;&amp; $(selector) this.each(function(_, node)&#123; while (node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector))) node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode if (node &amp;&amp; nodes.indexOf(node) &lt; 0) nodes.push(node) &#125;) return $(nodes) &#125;, parents: function(selector)&#123; var ancestors = [], nodes = this while (nodes.length &gt; 0) nodes = $.map(nodes, function(node)&#123; if ((node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0) &#123; ancestors.push(node) return node &#125; &#125;) return filtered(ancestors, selector) &#125;, parent: function(selector)&#123; return filtered(uniq(this.pluck('parentNode')), selector) &#125;, children: function(selector)&#123; return filtered(this.map(function()&#123; return children(this) &#125;), selector) &#125;, contents: function() &#123; return this.map(function() &#123; return this.contentDocument || slice.call(this.childNodes) &#125;) &#125;, siblings: function(selector)&#123; return filtered(this.map(function(i, el)&#123; return filter.call(children(el.parentNode), function(child)&#123; return child!==el &#125;) &#125;), selector) &#125;, empty: function()&#123; return this.each(function()&#123; this.innerHTML = '' &#125;) &#125;, // `pluck` is borrowed from Prototype.js pluck: function(property)&#123; return $.map(this, function(el)&#123; return el[property] &#125;) &#125;, show: function()&#123; return this.each(function()&#123; this.style.display == \"none\" &amp;&amp; (this.style.display = '') if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\") this.style.display = defaultDisplay(this.nodeName) &#125;) &#125;, replaceWith: function(newContent)&#123; return this.before(newContent).remove() &#125;, wrap: function(structure)&#123; var func = isFunction(structure) if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length &gt; 1 return this.each(function(index)&#123; $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ) &#125;) &#125;, wrapAll: function(structure)&#123; if (this[0]) &#123; $(this[0]).before(structure = $(structure)) var children // drill down to the inmost element while ((children = structure.children()).length) structure = children.first() $(structure).append(this) &#125; return this &#125;, wrapInner: function(structure)&#123; var func = isFunction(structure) return this.each(function(index)&#123; var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure contents.length ? contents.wrapAll(dom) : self.append(dom) &#125;) &#125;, unwrap: function()&#123; this.parent().each(function()&#123; $(this).replaceWith($(this).children()) &#125;) return this &#125;, clone: function()&#123; return this.map(function()&#123; return this.cloneNode(true) &#125;) &#125;, hide: function()&#123; return this.css(\"display\", \"none\") &#125;, toggle: function(setting)&#123; return this.each(function()&#123; var el = $(this) ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide() &#125;) &#125;, prev: function(selector)&#123; return $(this.pluck('previousElementSibling')).filter(selector || '*') &#125;, next: function(selector)&#123; return $(this.pluck('nextElementSibling')).filter(selector || '*') &#125;, html: function(html)&#123; return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : (0 in this ? this[0].innerHTML : null) &#125;, text: function(text)&#123; return 0 in arguments ? this.each(function(idx)&#123; var newText = funcArg(this, text, idx, this.textContent) this.textContent = newText == null ? '' : ''+newText &#125;) : (0 in this ? this.pluck('textContent').join(\"\") : null) &#125;, attr: function(name, value)&#123; var result return (typeof name == 'string' &amp;&amp; !(1 in arguments)) ? (0 in this &amp;&amp; this[0].nodeType == 1 &amp;&amp; (result = this[0].getAttribute(name)) != null ? result : undefined) : this.each(function(idx)&#123; if (this.nodeType !== 1) return if (isObject(name)) for (key in name) setAttribute(this, key, name[key]) else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))) &#125;) &#125;, removeAttr: function(name)&#123; return this.each(function()&#123; this.nodeType === 1 &amp;&amp; name.split(' ').forEach(function(attribute)&#123; setAttribute(this, attribute) &#125;, this)&#125;) &#125;, prop: function(name, value)&#123; name = propMap[name] || name return (1 in arguments) ? this.each(function(idx)&#123; this[name] = funcArg(this, value, idx, this[name]) &#125;) : (this[0] &amp;&amp; this[0][name]) &#125;, removeProp: function(name)&#123; name = propMap[name] || name return this.each(function()&#123; delete this[name] &#125;) &#125;, data: function(name, value)&#123; var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase() var data = (1 in arguments) ? this.attr(attrName, value) : this.attr(attrName) return data !== null ? deserializeValue(data) : undefined &#125;, val: function(value)&#123; if (0 in arguments) &#123; if (value == null) value = \"\" return this.each(function(idx)&#123; this.value = funcArg(this, value, idx, this.value) &#125;) &#125; else &#123; return this[0] &amp;&amp; (this[0].multiple ? $(this[0]).find('option').filter(function()&#123; return this.selected &#125;).pluck('value') : this[0].value) &#125; &#125;, offset: function(coordinates)&#123; if (coordinates) return this.each(function(index)&#123; var $this = $(this), coords = funcArg(this, coordinates, index, $this.offset()), parentOffset = $this.offsetParent().offset(), props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125; if ($this.css('position') == 'static') props['position'] = 'relative' $this.css(props) &#125;) if (!this.length) return null if (document.documentElement !== this[0] &amp;&amp; !$.contains(document.documentElement, this[0])) return &#123;top: 0, left: 0&#125; var obj = this[0].getBoundingClientRect() return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125; &#125;, css: function(property, value)&#123; if (arguments.length &lt; 2) &#123; var element = this[0] if (typeof property == 'string') &#123; if (!element) return return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property) &#125; else if (isArray(property)) &#123; if (!element) return var props = &#123;&#125; var computedStyle = getComputedStyle(element, '') $.each(property, function(_, prop)&#123; props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop)) &#125;) return props &#125; &#125; var css = '' if (type(property) == 'string') &#123; if (!value &amp;&amp; value !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(property)) &#125;) else css = dasherize(property) + \":\" + maybeAddPx(property, value) &#125; else &#123; for (key in property) if (!property[key] &amp;&amp; property[key] !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(key)) &#125;) else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';' &#125; return this.each(function()&#123; this.style.cssText += ';' + css &#125;) &#125;, index: function(element)&#123; return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]) &#125;, hasClass: function(name)&#123; if (!name) return false return emptyArray.some.call(this, function(el)&#123; return this.test(className(el)) &#125;, classRE(name)) &#125;, addClass: function(name)&#123; if (!name) return this return this.each(function(idx)&#123; if (!('className' in this)) return classList = [] var cls = className(this), newName = funcArg(this, name, idx, cls) newName.split(/\\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \")) &#125;) &#125;, removeClass: function(name)&#123; return this.each(function(idx)&#123; if (!('className' in this)) return if (name === undefined) return className(this, '') classList = className(this) funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass)&#123; classList = classList.replace(classRE(klass), \" \") &#125;) className(this, classList.trim()) &#125;) &#125;, toggleClass: function(name, when)&#123; if (!name) return this return this.each(function(idx)&#123; var $this = $(this), names = funcArg(this, name, idx, className(this)) names.split(/\\s+/g).forEach(function(klass)&#123; (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass) &#125;) &#125;) &#125;, scrollTop: function(value)&#123; if (!this.length) return var hasScrollTop = 'scrollTop' in this[0] if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset return this.each(hasScrollTop ? function()&#123; this.scrollTop = value &#125; : function()&#123; this.scrollTo(this.scrollX, value) &#125;) &#125;, scrollLeft: function(value)&#123; if (!this.length) return var hasScrollLeft = 'scrollLeft' in this[0] if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset return this.each(hasScrollLeft ? function()&#123; this.scrollLeft = value &#125; : function()&#123; this.scrollTo(value, this.scrollY) &#125;) &#125;, position: function() &#123; if (!this.length) return var elem = this[0], // Get *real* offsetParent offsetParent = this.offsetParent(), // Get correct offsets offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123; top: 0, left: 0 &#125; : offsetParent.offset() // Subtract element margins // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat( $(elem).css('margin-top') ) || 0 offset.left -= parseFloat( $(elem).css('margin-left') ) || 0 // Add offsetParent borders parentOffset.top += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0 parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0 // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125; &#125;, offsetParent: function() &#123; return this.map(function()&#123; var parent = this.offsetParent || document.body while (parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css(\"position\") == \"static\") parent = parent.offsetParent return parent &#125;) &#125; &#125; // for now $.fn.detach = $.fn.remove // Generate the `width` and `height` functions ;['width', 'height'].forEach(function(dimension)&#123; var dimensionProperty = dimension.replace(/./, function(m)&#123; return m[0].toUpperCase() &#125;) $.fn[dimension] = function(value)&#123; var offset, el = this[0] if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) &amp;&amp; offset[dimension] else return this.each(function(idx)&#123; el = $(this) el.css(dimension, funcArg(this, value, idx, el[dimension]())) &#125;) &#125; &#125;) function traverseNode(node, fun) &#123; fun(node) for (var i = 0, len = node.childNodes.length; i &lt; len; i++) traverseNode(node.childNodes[i], fun) &#125; // Generate the `after`, `prepend`, `before`, `append`, // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods. adjacencyOperators.forEach(function(operator, operatorIndex) &#123; var inside = operatorIndex % 2 //=&gt; prepend, append $.fn[operator] = function()&#123; // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings var argType, nodes = $.map(arguments, function(arg) &#123; var arr = [] argType = type(arg) if (argType == \"array\") &#123; arg.forEach(function(el) &#123; if (el.nodeType !== undefined) return arr.push(el) else if ($.zepto.isZ(el)) return arr = arr.concat(el.get()) arr = arr.concat(zepto.fragment(el)) &#125;) return arr &#125; return argType == \"object\" || arg == null ? arg : zepto.fragment(arg) &#125;), parent, copyByClone = this.length &gt; 1 if (nodes.length &lt; 1) return this return this.each(function(_, target)&#123; parent = inside ? target : target.parentNode // convert all methods to a \"before\" operation target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null var parentInDocument = $.contains(document.documentElement, parent) nodes.forEach(function(node)&#123; if (copyByClone) node = node.cloneNode(true) else if (!parent) return $(node).remove() parent.insertBefore(node, target) if (parentInDocument) traverseNode(node, function(el)&#123; if (el.nodeName != null &amp;&amp; el.nodeName.toUpperCase() === 'SCRIPT' &amp;&amp; (!el.type || el.type === 'text/javascript') &amp;&amp; !el.src)&#123; var target = el.ownerDocument ? el.ownerDocument.defaultView : window target['eval'].call(target, el.innerHTML) &#125; &#125;) &#125;) &#125;) &#125; // after =&gt; insertAfter // prepend =&gt; prependTo // before =&gt; insertBefore // append =&gt; appendTo $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html)&#123; $(html)[operator](this) return this &#125; &#125;) zepto.Z.prototype = Z.prototype = $.fn // Export internal API functions in the `$.zepto` namespace zepto.uniq = uniq zepto.deserializeValue = deserializeValue $.zepto = zepto return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto)// zepto的事件代码;(function($)&#123; var _zid = 1, undefined, slice = Array.prototype.slice, isFunction = $.isFunction, isString = function(obj)&#123; return typeof obj == 'string' &#125;, handlers = &#123;&#125;, specialEvents=&#123;&#125;, focusinSupported = 'onfocusin' in window, focus = &#123; focus: 'focusin', blur: 'focusout' &#125;, hover = &#123; mouseenter: 'mouseover', mouseleave: 'mouseout' &#125; specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents' function zid(element) &#123; return element._zid || (element._zid = _zid++) &#125; function findHandlers(element, event, fn, selector) &#123; event = parse(event) if (event.ns) var matcher = matcherFor(event.ns) return (handlers[zid(element)] || []).filter(function(handler) &#123; return handler &amp;&amp; (!event.e || handler.e == event.e) &amp;&amp; (!event.ns || matcher.test(handler.ns)) &amp;&amp; (!fn || zid(handler.fn) === zid(fn)) &amp;&amp; (!selector || handler.sel == selector) &#125;) &#125; function parse(event) &#123; var parts = ('' + event).split('.') return &#123;e: parts[0], ns: parts.slice(1).sort().join(' ')&#125; &#125; function matcherFor(ns) &#123; return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)') &#125; function eventCapture(handler, captureSetting) &#123; return handler.del &amp;&amp; (!focusinSupported &amp;&amp; (handler.e in focus)) || !!captureSetting &#125; function realEvent(type) &#123; return hover[type] || (focusinSupported &amp;&amp; focus[type]) || type &#125; function add(element, events, fn, data, selector, delegator, capture)&#123; var id = zid(element), set = (handlers[id] || (handlers[id] = [])) events.split(/\\s/).forEach(function(event)&#123; if (event == 'ready') return $(document).ready(fn) var handler = parse(event) handler.fn = fn handler.sel = selector // emulate mouseenter, mouseleave if (handler.e in hover) fn = function(e)&#123; var related = e.relatedTarget if (!related || (related !== this &amp;&amp; !$.contains(this, related))) return handler.fn.apply(this, arguments) &#125; handler.del = delegator var callback = delegator || fn handler.proxy = function(e)&#123; e = compatible(e) if (e.isImmediatePropagationStopped()) return e.data = data var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args)) if (result === false) e.preventDefault(), e.stopPropagation() return result &#125; handler.i = set.length set.push(handler) if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125; function remove(element, events, fn, selector, capture)&#123; var id = zid(element) ;(events || '').split(/\\s/).forEach(function(event)&#123; findHandlers(element, event, fn, selector).forEach(function(handler)&#123; delete handlers[id][handler.i] if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125;) &#125; $.event = &#123; add: add, remove: remove &#125; $.proxy = function(fn, context) &#123; var args = (2 in arguments) &amp;&amp; slice.call(arguments, 2) if (isFunction(fn)) &#123; var proxyFn = function()&#123; return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) &#125; proxyFn._zid = zid(fn) return proxyFn &#125; else if (isString(context)) &#123; if (args) &#123; args.unshift(fn[context], fn) return $.proxy.apply(null, args) &#125; else &#123; return $.proxy(fn[context], fn) &#125; &#125; else &#123; throw new TypeError(\"expected function\") &#125; &#125; $.fn.bind = function(event, data, callback)&#123; return this.on(event, data, callback) &#125; $.fn.unbind = function(event, callback)&#123; return this.off(event, callback) &#125; $.fn.one = function(event, selector, data, callback)&#123; return this.on(event, selector, data, callback, 1) &#125; var returnTrue = function()&#123;return true&#125;, returnFalse = function()&#123;return false&#125;, ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/, eventMethods = &#123; preventDefault: 'isDefaultPrevented', stopImmediatePropagation: 'isImmediatePropagationStopped', stopPropagation: 'isPropagationStopped' &#125; function compatible(event, source) &#123; if (source || !event.isDefaultPrevented) &#123; source || (source = event) $.each(eventMethods, function(name, predicate) &#123; var sourceMethod = source[name] event[name] = function()&#123; this[predicate] = returnTrue return sourceMethod &amp;&amp; sourceMethod.apply(source, arguments) &#125; event[predicate] = returnFalse &#125;) event.timeStamp || (event.timeStamp = Date.now()) if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault &amp;&amp; source.getPreventDefault()) event.isDefaultPrevented = returnTrue &#125; return event &#125; function createProxy(event) &#123; var key, proxy = &#123; originalEvent: event &#125; for (key in event) if (!ignoreProperties.test(key) &amp;&amp; event[key] !== undefined) proxy[key] = event[key] return compatible(proxy, event) &#125; $.fn.delegate = function(selector, event, callback)&#123; return this.on(event, selector, callback) &#125; $.fn.undelegate = function(selector, event, callback)&#123; return this.off(event, selector, callback) &#125; $.fn.live = function(event, callback)&#123; $(document.body).delegate(this.selector, event, callback) return this &#125; $.fn.die = function(event, callback)&#123; $(document.body).undelegate(this.selector, event, callback) return this &#125; $.fn.on = function(event, selector, data, callback, one)&#123; var autoRemove, delegator, $this = this if (event &amp;&amp; !isString(event)) &#123; $.each(event, function(type, fn)&#123; $this.on(type, selector, data, fn, one) &#125;) return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = data, data = selector, selector = undefined if (callback === undefined || data === false) callback = data, data = undefined if (callback === false) callback = returnFalse return $this.each(function(_, element)&#123; if (one) autoRemove = function(e)&#123; remove(element, e.type, callback) return callback.apply(this, arguments) &#125; if (selector) delegator = function(e)&#123; var evt, match = $(e.target).closest(selector, element).get(0) if (match &amp;&amp; match !== element) &#123; evt = $.extend(createProxy(e), &#123;currentTarget: match, liveFired: element&#125;) return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1))) &#125; &#125; add(element, event, callback, data, selector, delegator || autoRemove) &#125;) &#125; $.fn.off = function(event, selector, callback)&#123; var $this = this if (event &amp;&amp; !isString(event)) &#123; $.each(event, function(type, fn)&#123; $this.off(type, selector, fn) &#125;) return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = selector, selector = undefined if (callback === false) callback = returnFalse return $this.each(function()&#123; remove(this, event, callback, selector) &#125;) &#125; $.fn.trigger = function(event, args)&#123; event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event) event._args = args return this.each(function()&#123; // handle focus(), blur() by calling them directly if (event.type in focus &amp;&amp; typeof this[event.type] == \"function\") this[event.type]() // items in the collection might not be DOM elements else if ('dispatchEvent' in this) this.dispatchEvent(event) else $(this).triggerHandler(event, args) &#125;) &#125; // triggers event handlers on current element just as if an event occurred, // doesn't trigger an actual event, doesn't bubble $.fn.triggerHandler = function(event, args)&#123; var e, result this.each(function(i, element)&#123; e = createProxy(isString(event) ? $.Event(event) : event) e._args = args e.target = element $.each(findHandlers(element, event.type || event), function(i, handler)&#123; result = handler.proxy(e) if (e.isImmediatePropagationStopped()) return false &#125;) &#125;) return result &#125; // shortcut methods for `.bind(event, fn)` for each event type ;('focusin focusout focus blur load resize scroll unload click dblclick '+ 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+ 'change select keydown keypress keyup error').split(' ').forEach(function(event) &#123; $.fn[event] = function(callback) &#123; return (0 in arguments) ? this.bind(event, callback) : this.trigger(event) &#125; &#125;) $.Event = function(type, props) &#123; if (!isString(type)) props = type, type = props.type var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name]) event.initEvent(type, bubbles, true) return compatible(event) &#125;&#125;)(Zepto)// zepto的AJAX代码;(function($)&#123; var jsonpID = +new Date(), document = window.document, key, name, rscript = /&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;/gi, scriptTypeRE = /^(?:text|application)\\/javascript/i, xmlTypeRE = /^(?:text|application)\\/xml/i, jsonType = 'application/json', htmlType = 'text/html', blankRE = /^\\s*$/, originAnchor = document.createElement('a') originAnchor.href = window.location.href // trigger a custom event and return false if it was cancelled function triggerAndReturn(context, eventName, data) &#123; var event = $.Event(eventName) $(context).trigger(event, data) return !event.isDefaultPrevented() &#125; // trigger an Ajax \"global\" event function triggerGlobal(settings, context, eventName, data) &#123; if (settings.global) return triggerAndReturn(context || document, eventName, data) &#125; // Number of active Ajax requests $.active = 0 function ajaxStart(settings) &#123; if (settings.global &amp;&amp; $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart') &#125; function ajaxStop(settings) &#123; if (settings.global &amp;&amp; !(--$.active)) triggerGlobal(settings, null, 'ajaxStop') &#125; // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable function ajaxBeforeSend(xhr, settings) &#123; var context = settings.context if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]) &#125; function ajaxSuccess(data, xhr, settings, deferred) &#123; var context = settings.context, status = 'success' settings.success.call(context, data, status, xhr) if (deferred) deferred.resolveWith(context, [data, status, xhr]) triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]) ajaxComplete(status, xhr, settings) &#125; // type: \"timeout\", \"error\", \"abort\", \"parsererror\" function ajaxError(error, type, xhr, settings, deferred) &#123; var context = settings.context settings.error.call(context, xhr, type, error) if (deferred) deferred.rejectWith(context, [xhr, type, error]) triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]) ajaxComplete(type, xhr, settings) &#125; // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\" function ajaxComplete(status, xhr, settings) &#123; var context = settings.context settings.complete.call(context, xhr, status) triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]) ajaxStop(settings) &#125; function ajaxDataFilter(data, type, settings) &#123; if (settings.dataFilter == empty) return data var context = settings.context return settings.dataFilter.call(context, data, type) &#125; // Empty function, used as default callback function empty() &#123;&#125; $.ajaxJSONP = function(options, deferred)&#123; if (!('type' in options)) return $.ajax(options) var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)), script = document.createElement('script'), originalCallback = window[callbackName], responseData, abort = function(errorType) &#123; $(script).triggerHandler('error', errorType || 'abort') &#125;, xhr = &#123; abort: abort &#125;, abortTimeout if (deferred) deferred.promise(xhr) $(script).on('load error', function(e, errorType)&#123; clearTimeout(abortTimeout) $(script).off().remove() if (e.type == 'error' || !responseData) &#123; ajaxError(null, errorType || 'error', xhr, options, deferred) &#125; else &#123; ajaxSuccess(responseData[0], xhr, options, deferred) &#125; window[callbackName] = originalCallback if (responseData &amp;&amp; $.isFunction(originalCallback)) originalCallback(responseData[0]) originalCallback = responseData = undefined &#125;) if (ajaxBeforeSend(xhr, options) === false) &#123; abort('abort') return xhr &#125; window[callbackName] = function()&#123; responseData = arguments &#125; script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName) document.head.appendChild(script) if (options.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; abort('timeout') &#125;, options.timeout) return xhr &#125; $.ajaxSettings = &#123; // Default type of request type: 'GET', // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // The context for the callbacks context: null, // Whether to trigger \"global\" Ajax events global: true, // Transport xhr: function () &#123; return new window.XMLHttpRequest() &#125;, // MIME types mapping // IIS returns Javascript as \"application/x-javascript\" accepts: &#123; script: 'text/javascript, application/javascript, application/x-javascript', json: jsonType, xml: 'application/xml, text/xml', html: htmlType, text: 'text/plain' &#125;, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty &#125; function mimeToDataType(mime) &#123; if (mime) mime = mime.split(';', 2)[0] return mime &amp;&amp; ( mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) &amp;&amp; 'xml' ) || 'text' &#125; function appendQuery(url, query) &#123; if (query == '') return url return (url + '&amp;' + query).replace(/[&amp;?]&#123;1,2&#125;/, '?') &#125; // serialize payload and append it to the URL for GET requests function serializeData(options) &#123; if (options.processData &amp;&amp; options.data &amp;&amp; $.type(options.data) != \"string\") options.data = $.param(options.data, options.traditional) if (options.data &amp;&amp; (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined &#125; $.ajax = function(options)&#123; var settings = $.extend(&#123;&#125;, options || &#123;&#125;), deferred = $.Deferred &amp;&amp; $.Deferred(), urlAnchor, hashIndex for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key] ajaxStart(settings) if (!settings.crossDomain) &#123; urlAnchor = document.createElement('a') urlAnchor.href = settings.url // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049 urlAnchor.href = urlAnchor.href settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host) &#125; if (!settings.url) settings.url = window.location.toString() if ((hashIndex = settings.url.indexOf('#')) &gt; -1) settings.url = settings.url.slice(0, hashIndex) serializeData(settings) var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url) if (hasPlaceholder) dataType = 'jsonp' if (settings.cache === false || ( (!options || options.cache !== true) &amp;&amp; ('script' == dataType || 'jsonp' == dataType) )) settings.url = appendQuery(settings.url, '_=' + Date.now()) if ('jsonp' == dataType) &#123; if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?') return $.ajaxJSONP(settings, deferred) &#125; var mime = settings.accepts[dataType], headers = &#123; &#125;, setHeader = function(name, value) &#123; headers[name.toLowerCase()] = [name, value] &#125;, protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol, xhr = settings.xhr(), nativeSetHeader = xhr.setRequestHeader, abortTimeout if (deferred) deferred.promise(xhr) if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest') setHeader('Accept', mime || '*/*') if (mime = settings.mimeType || mime) &#123; if (mime.indexOf(',') &gt; -1) mime = mime.split(',', 2)[0] xhr.overrideMimeType &amp;&amp; xhr.overrideMimeType(mime) &#125; if (settings.contentType || (settings.contentType !== false &amp;&amp; settings.data &amp;&amp; settings.type.toUpperCase() != 'GET')) setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded') if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name]) xhr.setRequestHeader = setHeader xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; xhr.onreadystatechange = empty clearTimeout(abortTimeout) var result, error = false if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 || (xhr.status == 0 &amp;&amp; protocol == 'file:')) &#123; dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type')) if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob') result = xhr.response else &#123; result = xhr.responseText try &#123; // http://perfectionkills.com/global-eval-what-are-the-options/ // sanitize response accordingly if data filter callback provided result = ajaxDataFilter(result, dataType, settings) if (dataType == 'script') (1,eval)(result) else if (dataType == 'xml') result = xhr.responseXML else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result) &#125; catch (e) &#123; error = e &#125; if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred) &#125; ajaxSuccess(result, xhr, settings, deferred) &#125; else &#123; ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred) &#125; &#125; &#125; if (ajaxBeforeSend(xhr, settings) === false) &#123; xhr.abort() ajaxError(null, 'abort', xhr, settings, deferred) return xhr &#125; var async = 'async' in settings ? settings.async : true xhr.open(settings.type, settings.url, async, settings.username, settings.password) if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name] for (name in headers) nativeSetHeader.apply(xhr, headers[name]) if (settings.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; xhr.onreadystatechange = empty xhr.abort() ajaxError(null, 'timeout', xhr, settings, deferred) &#125;, settings.timeout) // avoid sending empty string (#319) xhr.send(settings.data ? settings.data : null) return xhr &#125; // handle optional data/success arguments function parseArguments(url, data, success, dataType) &#123; if ($.isFunction(data)) dataType = success, success = data, data = undefined if (!$.isFunction(success)) dataType = success, success = undefined return &#123; url: url , data: data , success: success , dataType: dataType &#125; &#125; $.get = function(/* url, data, success, dataType */)&#123; return $.ajax(parseArguments.apply(null, arguments)) &#125; $.post = function(/* url, data, success, dataType */)&#123; var options = parseArguments.apply(null, arguments) options.type = 'POST' return $.ajax(options) &#125; $.getJSON = function(/* url, data, success */)&#123; var options = parseArguments.apply(null, arguments) options.dataType = 'json' return $.ajax(options) &#125; $.fn.load = function(url, data, success)&#123; if (!this.length) return this var self = this, parts = url.split(/\\s/), selector, options = parseArguments(url, data, success), callback = options.success if (parts.length &gt; 1) options.url = parts[0], selector = parts[1] options.success = function(response)&#123; self.html(selector ? $('&lt;div&gt;').html(response.replace(rscript, \"\")).find(selector) : response) callback &amp;&amp; callback.apply(self, arguments) &#125; $.ajax(options) return this &#125; var escape = encodeURIComponent function serialize(params, obj, traditional, scope)&#123; var type, array = $.isArray(obj), hash = $.isPlainObject(obj) $.each(obj, function(key, value) &#123; type = $.type(value) if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']' // handle data in serializeArray() format if (!scope &amp;&amp; array) params.add(value.name, value.value) // recurse into nested objects else if (type == \"array\" || (!traditional &amp;&amp; type == \"object\")) serialize(params, value, traditional, key) else params.add(key, value) &#125;) &#125; $.param = function(obj, traditional)&#123; var params = [] params.add = function(key, value) &#123; if ($.isFunction(value)) value = value() if (value == null) value = \"\" this.push(escape(key) + '=' + escape(value)) &#125; serialize(params, obj, traditional) return params.join('&amp;').replace(/%20/g, '+') &#125;&#125;)(Zepto)// zepro的form表单处理;(function($)&#123; $.fn.serializeArray = function() &#123; var name, type, result = [], add = function(value) &#123; if (value.forEach) return value.forEach(add) result.push(&#123; name: name, value: value &#125;) &#125; if (this[0]) $.each(this[0].elements, function(_, field)&#123; type = field.type, name = field.name if (name &amp;&amp; field.nodeName.toLowerCase() != 'fieldset' &amp;&amp; !field.disabled &amp;&amp; type != 'submit' &amp;&amp; type != 'reset' &amp;&amp; type != 'button' &amp;&amp; type != 'file' &amp;&amp; ((type != 'radio' &amp;&amp; type != 'checkbox') || field.checked)) add($(field).val()) &#125;) return result &#125; $.fn.serialize = function()&#123; var result = [] this.serializeArray().forEach(function(elm)&#123; result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value)) &#125;) return result.join('&amp;') &#125; $.fn.submit = function(callback) &#123; if (0 in arguments) this.bind('submit', callback) else if (this.length) &#123; var event = $.Event('submit') this.eq(0).trigger(event) if (!event.isDefaultPrevented()) this.get(0).submit() &#125; return this &#125;&#125;)(Zepto);(function()&#123; // getComputedStyle shouldn't freak out when called // without a valid element as argument try &#123; getComputedStyle(undefined) &#125; catch(e) &#123; var nativeGetComputedStyle = getComputedStyle window.getComputedStyle = function(element, pseudoElement)&#123; try &#123; return nativeGetComputedStyle(element, pseudoElement) &#125; catch(e) &#123; return null &#125; &#125; &#125;&#125;)() return Zepto&#125;))","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"javascript获取数据类型","slug":"javascript获取数据类型","date":"2018-11-14T02:45:29.000Z","updated":"2024-01-11T07:00:59.195Z","comments":true,"path":"2018/11/14/javascript获取数据类型/","link":"","permalink":"/2018/11/14/javascript获取数据类型/","excerpt":"判断js的数据类型，如：Boolean Number String等","text":"判断js的数据类型，如：Boolean Number String等 javascript获取数据类型平时在工作中，偶尔会用到判断一下这个数据是什么类型，是数组的？string的？function的？我一般都直接按照代码的需求，只写了需要判断的类型，用完就丢到一边，最近在看jquery源码，人家大牛写的真不错，改一改，封装一下，自己用哈。话不多说，直接贴出代码，其实很简单的：123456789101112131415161718function toType( obj ) &#123; var class2type = &#123;&#125;, toString = class2type.toString; \"Boolean Number String Function Array Date RegExp Object Error Symbol\" .split( \" \" ) .forEach(function( name ) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase(); &#125;); if ( obj == null ) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ toString.call( obj ) ] || \"object\" : typeof obj; &#125; 代码一共没有几行，接下来看看管不管用12345678910111213// 测试一下console.log('对象的类型-&gt;',toType(&#123;&#125;));console.log('函数的类型-&gt;',toType(function()&#123;&#125;));console.log('null的类型-&gt;',toType(null));console.log('undefined的类型-&gt;',toType(undefined));console.log('boolean的类型-&gt;',toType(true));console.log('number的类型-&gt;',toType(555));console.log('string的类型-&gt;',toType('abc'));console.log('array的类型-&gt;',toType([]));console.log('date的类型-&gt;',toType(new Date()));console.log('正则的类型-&gt;',toType(/abc/g));console.log('symbol-&gt;',toType(Symbol()));console.log('Error的类型-&gt;',toType(new Error())); 基本上的类型都判断出来了，不错吧。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"tcp三次握手和四次挥手","slug":"tcp三次握手和四次挥手","date":"2018-11-07T06:34:14.000Z","updated":"2024-01-11T07:00:59.230Z","comments":true,"path":"2018/11/07/tcp三次握手和四次挥手/","link":"","permalink":"/2018/11/07/tcp三次握手和四次挥手/","excerpt":"我的tcp三次握手和四次挥手简洁理解。","text":"我的tcp三次握手和四次挥手简洁理解。 tcp三次握手和四次挥手tcp三次握手和四次挥手，这是一个很基础的计算机网络层面的基础问题，让我回答我也说不出来具体的东西，所以，为了加强记忆，按照自己的理解，把它记下来。 三次握手我们用打电话的生活场景来模拟三次握手：123client: 你好，能听到我说话吗？server：能听到，你能听到我说话吗？client：是的，我也能听到你说话。 像上面这样，来回通过3次对话，确认了双方都可以接收到相互的信息。 四次挥手我们还用打电话的生活场景来模拟四次挥手：1234client: 我有事，不跟你聊了哈。server：知道了。server：最后说一句，明天把书给我带来。client：好的，知道了。 好了，四次挥手也模拟完了。我这只是模拟了这两个过程而已，如果想学习真正的原理，请参考这里","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js抽象语法树AST","slug":"js抽象语法树AST","date":"2018-11-06T07:48:54.000Z","updated":"2024-01-11T07:00:59.218Z","comments":true,"path":"2018/11/06/js抽象语法树AST/","link":"","permalink":"/2018/11/06/js抽象语法树AST/","excerpt":"通过javascript parser将代码转化成抽象语法树，这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。","text":"通过javascript parser将代码转化成抽象语法树，这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。 js抽象语法树AST最近在研究webpack，想研究一下它是如何打包的，不过，刚刚入门，就有一个知识点把我难住了，那就是AST抽象语法树。于是乎，上网查了查，原理就是把代码解析，解析成一个有各种属性状态的json树，便于对代码进行操作，具体的解析代码当然是很难的，像我们这种菜鸟只需要了解一下用法就可以了。babel是现在几乎每个项目中必备的一个东西，但是其工作原理避不开对js的解析在生成的过程，babel有引擎babylon，早期fork了项目acron，了解这个之前我们先来看看这种引擎解析出来是什么东西。不光是babel还有webpack等。 什么是抽象语法树见下面例子：12var a = 1;var b = a + 1; 之后我们通过这个网站，他是一个esprima引擎的网站，十分好用.画成流程图如下：而他的json对象格式是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"VariableDeclaration\", \"declarations\": [ &#123; \"type\": \"VariableDeclarator\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"init\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; ], \"kind\": \"var\" &#125;, &#123; \"type\": \"VariableDeclaration\", \"declarations\": [ &#123; \"type\": \"VariableDeclarator\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"b\" &#125;, \"init\": &#123; \"type\": \"BinaryExpression\", \"operator\": \"+\", \"left\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"right\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; &#125; ], \"kind\": \"var\" &#125; ], \"sourceType\": \"script\"&#125; 众多AST解析引擎chrome有v8，firefix有spidermonkey.还有一些常用的引擎有： esprima acron Traceur UglifyJS2 shift AST的学习三板斧 通过esprima生成AST 通过estraverse遍历和更新AST 通过escodegen将AST重新生成源码 来一个简单例子，看看用法：1.先新建一个test的工程目录2.在test工程下安装esprima、estraverse、escodegen的npm模块1npm i esprima estraverse escodegen --save 3.在目录下面新建一个test.js文件,载入以下代码：1234const esprima = require('esprima');let code = 'const a = 1';const ast = esprima.parseScript(code);console.log(ast); 你将会看到输出结果：12345678Script &#123; type: 'Program', body: [ VariableDeclaration &#123; type: 'VariableDeclaration', declarations: [Array], kind: 'const' &#125; ], sourceType: 'script' &#125; 4.再在test文件中，载入以下代码：12345678const estraverse = require('estraverse');estraverse.traverse(ast, &#123; enter: function (node) &#123; node.kind = \"var\"; &#125;&#125;);console.log(ast); 输出的结果：12345678Script &#123; type: 'Program', body: [ VariableDeclaration &#123; type: 'VariableDeclaration', declarations: [Array], kind: 'var' &#125; ], sourceType: 'script' &#125; 5.最后在test文件中，加入以下代码：123const escodegen = require(\"escodegen\");const transformCode = escodegen.generate(ast)console.log(transformCode); 输出的结果：1var a = 1; 通过这三步，我们将const a = 1转化成了var a = 1 虽然，具体的解析原理我们并不知道，但是，通过这三个模块包，是不是有种自己搞出一个babel的赶脚。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"对象链式取值(如loadsh的_.get()方法)在项目中的应用","slug":"对象链式取值-如loadsh的-get-方法-在项目中的应用","date":"2018-11-05T05:27:11.000Z","updated":"2024-01-11T07:00:59.265Z","comments":true,"path":"2018/11/05/对象链式取值-如loadsh的-get-方法-在项目中的应用/","link":"","permalink":"/2018/11/05/对象链式取值-如loadsh的-get-方法-在项目中的应用/","excerpt":"对象的链式取值在项目中的应用场景。","text":"对象的链式取值在项目中的应用场景。 对象链式取值(如loadsh的_.get()方法)在项目中的应用相信大家在从后端获取数据的时候，像这样res.data.rows.count来获取数据的情况很多，如果后台返回的格式不对了，或则data是个null，那么很容易报Uncaught TypeError: Cannot read property ‘goods’ of undefined这样的错。我们一般会这样写：123if(res &amp;&amp; res.data &amp;&amp; res.data.rows &amp;&amp; res.data.count) &#123; ...&#125; 不过这么写实在是有些麻烦，我一般的做法是直接catch住error，然后定位到具体错误在哪，在改正。不过，最近在网上看到一篇专门写关于对象的链式取值的文章，里边写了大概4种解决方法，这里我只记录学习了其中一种，也是兼容性最好的一种，就想使用loadsh的_.get方法，先看看loadsh是怎么用的，见下边1234567var object = &#123; 'a': [&#123; 'b': &#123; 'c': 3 &#125; &#125;] &#125;;_.get(object, 'a[0].b.c');// =&gt; 3_.get(object, ['a', '0', 'b', 'c']);// =&gt; 3_.get(object, 'a.b.c', 'default');// =&gt; 'default' 使用方法一目了然，第一个参数：对象，第二个参数：链式字符串，第三个参数是，如果按照这个链式字符串在对象中取不到值，返回这个默认值。这样写的话，就像上边即使后台同事更改了数据结构，不会报错，而是返回默认值。（不过这种写法我觉得也有不好的地方，那就是不容易发现错误，后台返回的数据结构都变了，而我们前台并没有出现异常，而是返回来初始写的默认值，是不是有点。。。）不过，这种写法在其它场合我想一定会有用武之地。我现在的项目中并没有用到loadsh这个库，但是还想用咋办呢？自己写一个喽，还好，写法简单，容易理解，注意，下边给出的代码交通过函数解析字符串方式来处理的。1234567891011121314151617181920212223242526272829function get (obj, props, def) &#123; if((obj == null) || obj == null || typeof props !== 'string') return def; const temp = props.split('.'); const fieldArr = [].concat(temp); temp.forEach((e, i) =&gt; &#123; if(/^(\\w+)\\[(\\w+)\\]$/.test(e)) &#123; const matchs = e.match(/^(\\w+)\\[(\\w+)\\]$/); const field1 = matchs[1]; const field2 = matchs[2]; const index = fieldArr.indexOf(e); fieldArr.splice(index, 1, field1, field2); &#125; &#125;) return fieldArr.reduce((pre, cur) =&gt; &#123; const target = pre[cur] || def; if(target instanceof Array) &#123; return [].concat(target); &#125; if(target instanceof Object) &#123; return Object.assign(&#123;&#125;, target) &#125; return target; &#125;, obj)&#125;var c = &#123;a: &#123;b : [1,2,3] &#125;&#125;get(c ,'a.b') // [1,2,3]get(c, 'a.b[1]') // 2get(c, 'a.d', 12) // 12 其实，在项目无论如何使用都没什么问题，即使什么都不做，最后项目完成时，也一定会因为出现报错而改正过来，最多就是不够健壮。我觉得这个函数解析字符串的方式很好，值得举一反三，值得学习。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"webpack打包bundle.js文件代码分析","slug":"webpack打包bundle-js文件代码分析","date":"2018-11-01T06:16:54.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2018/11/01/webpack打包bundle-js文件代码分析/","link":"","permalink":"/2018/11/01/webpack打包bundle-js文件代码分析/","excerpt":"webpack这个打包工具，现在可以说很火，前一段时间为了优化公司项目，搞了一个月的gulp，说实在的，gulp的功能我感觉很强大了，而且用起来很灵活，最关键是简单，需要什么的时候直接弄个gulp任务，但是，使用场景很少了，由于之前的项目是php的，现在一般都用vue，react等，都已经集成了webpack，虽然说不用太多配置，但是需要配置的时候还是有的，所以，webpack研究一下也是有必要的，今天，复杂的先不说，只说说bundle.js这个文件里的代码都是干吗用的。","text":"webpack这个打包工具，现在可以说很火，前一段时间为了优化公司项目，搞了一个月的gulp，说实在的，gulp的功能我感觉很强大了，而且用起来很灵活，最关键是简单，需要什么的时候直接弄个gulp任务，但是，使用场景很少了，由于之前的项目是php的，现在一般都用vue，react等，都已经集成了webpack，虽然说不用太多配置，但是需要配置的时候还是有的，所以，webpack研究一下也是有必要的，今天，复杂的先不说，只说说bundle.js这个文件里的代码都是干吗用的。 webpack打包bundle.js文件代码分析一个入口，一个文件首先，webpack.config.js配置文件是这样滴：123456module.exports = &#123; entry:'./index.js', output:&#123; filename:'bundle.js' &#125;&#125;; index.js内容是这样滴：1console.log('index'); 最后再看看打完包后的bundle.js内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports) &#123; console.log('index');/***/ &#125;/******/ ]); 我们来分析一下bundle.js这个文件 1.整个内容是一个自执行函数，自执行函数传的参数是一个数组，数组里的元素是function函数，这个函数体的内容就是index.js文件的内容。 2.在这个闭包函数中，__webpack_require_是模块加载函数，接收模块id（对，webpack中每个模块都会有一个独一无二的id，其实也就是在IIFE传参数组中的索引值（0，1，2…..）。 3.真正执行module index里面语句的是个调用12// Execute the module functionmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__); 我们再来看一个例子 一个入口，两个文件，A依赖B先贴出文件内容：123456// a.jsvar b = require('./b.js');console.log('a');b.b1(); 12345678// b.jsexports.b1 = function () &#123; console.log('b1')&#125;;exports.b2 = function () &#123; console.log('b2')&#125;; 1234567891011121314151617181920212223242526272829303132// bundle.js/******/ (function(modules) &#123; // webpackBootstrap// 省略一大段.........../******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; var b = __webpack_require__(1); console.log('a'); b.b1();/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; exports.b1 = function () &#123; console.log('b1') &#125;; exports.b2 = function () &#123; console.log('b2') &#125;;/***/ &#125;/******/ ]); 我们再来分析一下上面的代码。 1.由于有两个文件，所以IIFE得参数为长度是2的数组，并按照require的顺序排列。 2.IIFE函数体部分是一模一样的，也就是说再复杂的，多个依赖的文件，函数体部分也不变滴。 3.module a发生了变化，因为a依赖b，所以在a中调用webpack加载模块的函数 12// 1是模块b的idvar b = __webpack_require__(1); 4.我们再来分析一下modules[moduleId].call(module.exports, module, module.exports, webpack_require);使用call是因为为了确保每个module中的this指向的是module本身。然后给它传__webpack_require函数是想让module有加载其他module的能力。 其它情况其它的情况，比如多入口，多出口情况这里就不做过多分析，我也没搞明白，接下来准备手写一个简单的仿webpack打包工具。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"移动端webview模板","slug":"移动端webview模板","date":"2018-10-30T02:29:58.000Z","updated":"2024-01-11T07:00:59.275Z","comments":true,"path":"2018/10/30/移动端webview模板/","link":"","permalink":"/2018/10/30/移动端webview模板/","excerpt":"移动端的页面平时偶尔会有需求需要做，特别是webview嵌入的页面居多，由于是有时候做，有时候不做，所以，需求来的时候从新写页面还是有点麻烦，所以把之前写的记录一下，下次直接copy就好了。","text":"移动端的页面平时偶尔会有需求需要做，特别是webview嵌入的页面居多，由于是有时候做，有时候不做，所以，需求来的时候从新写页面还是有点麻烦，所以把之前写的记录一下，下次直接copy就好了。 移动端webview模板css一些css初始化的内容123456789101112131415161718192021222324252627@charset \"utf-8\";/* CSS Document */body,ul,ol,p,h1,h2,h3,h4,h5,dl,dd,form,input,textarea,td,th,button,strong,em,select,video,canvas&#123;margin:0;padding:0;&#125;h1,h2,h3,h4,h5,h6&#123; font-weight:normal;&#125;li&#123;list-style:none;vertical-align:top;&#125;table&#123; border-collapse:collapse;&#125;textarea&#123;resize:none;overflow:auto;&#125;img&#123; border:none; vertical-align:middle; width:100%;&#125;em,i&#123; font-style:normal;&#125;a&#123; text-decoration:none;&#125;a,input&#123; -webkit-appearance: none;/*屏蔽阴影*/ -webkit-tap-highlight-color:rgba(0,0,0,0); /*ios android去除自带阴影的样式*/&#125;a, img &#123; /* 禁止长按链接与图片弹出菜单 */ -webkit-touch-callout: none;&#125;html, body &#123; /* 禁止选中文本(如无文本选中需求,此为必选项) */ -webkit-user-select: none; user-select: none; background:#f5f5f5; overflow-x:hidden;&#125; js来控制rem大小代码js来修改html的font-size大小123456789101112(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth/20 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); html页面内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;&lt;meta content=\"email=no\" name=\"format-detection\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../js/config.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 判断ios android var u = navigator.userAgent; var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端 var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 var goodsId = window.location.search.split('=')[1] var reqUrl = BASEURL +'/goods/shopProduct/findSpuDescsBySpuId/' + goodsId; $.ajax(&#123; method: 'POST', url: reqUrl, headers: &#123; 'client-token': 'eyJhbGciOiJIUzUxMiJ9.eyJ1aWQiOiIxMjMiLCJjZXJ0Tm8iOiI0NTYifQ.xTR4SG0z3Nuf-siW34XtVgqNPr9PRpPb8XFKY6Hrj_Qg8kl9C0AeVFcQ8NnguQ-SrlHHcv5M16SkjVYX3PKweg' &#125;, data: &#123;goodsId: goodsId&#125;, dataType: 'json', success: function(res)&#123; if(res.code === '0000') &#123; var innerContent = res.data; var bodyContent = $.parseHTML(innerContent); $('.content').append(bodyContent); if(isiOS) &#123; var imgNum = $('img').size(), loadCount=0; $('img').on('load', function(ev) &#123; loadCount++; if(loadCount === imgNum)&#123; // 获取到页面高度返给ios端 var bodyHeight = $('body').height() + 25; // 调取ios注入的方法 window.webkit.messageHandlers.jsCallNative.postMessage(&#123;height: bodyHeight&#125;); &#125; &#125;); &#125; &#125; &#125;, error: function() &#123;&#125;, &#125;);&lt;/script&gt;&lt;/html&gt; 这个webview页面相对麻烦些，需求是在ios页面的固定位置显示webview内容，并不是新开一个新页面来整个显示webview内容，这样ios需要获取h5页面的高，而页面的内容又是h5页面通过ajax获取回来的，所以，ajax请求成功后，将内容插入到页面中，如果有图片的话，等待图片全部加载之后再计算页面的高，返给ios。这时，ios提供了一个函数注入到h5页面里了，我们直接调用就可以，代码中就是这个函数window.webkit.messageHandlers.jsCallNative.postMessage(); 补充点这方面的知识2019/2/2123456789if(isiOS) &#123; // 如果是ios的话 window.webkit.messageHandlers.iosCallback.postMessage(null); // 我告诉ios端可以调我提供的callAppFnInfo函数，它会把值给我传过来。 function callAppFnInfo(info) &#123; alert(info); &#125;&#125;else &#123; // android环境 var da = window.WebViewInterface.getId(); // 直接调取android提供的方法，它可以直接返回值 alert(da);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js基础知识思维导图","slug":"js基础知识思维导图","date":"2018-10-29T05:50:50.000Z","updated":"2024-01-11T07:00:59.197Z","comments":true,"path":"2018/10/29/js基础知识思维导图/","link":"","permalink":"/2018/10/29/js基础知识思维导图/","excerpt":"在网上无意间发现了一套js基础的思维导图，赶紧收为己用，呵呵。","text":"在网上无意间发现了一套js基础的思维导图，赶紧收为己用，呵呵。 js基础知识思维导图1.变量 2.数组 3.运算符 4.流程语句 5.函数基础 6.字符串函数 7.基本dom操作 8.浏览器Bom对象 9.正则表达式","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js类的继承(ES5写法)","slug":"js类的继承-ES5写法","date":"2018-10-23T01:30:30.000Z","updated":"2024-01-11T07:00:59.221Z","comments":true,"path":"2018/10/23/js类的继承-ES5写法/","link":"","permalink":"/2018/10/23/js类的继承-ES5写法/","excerpt":"js继承之终极继承寄生组合式继承","text":"js继承之终极继承寄生组合式继承 js类的继承(ES5写法)js的继承方式有很多，大致的罗列一下： 构造继承 原型链继承 组合继承 原型式继承 寄生式继承 寄生组合式继承这里只是列举了一些，还有很多其它方法，就不一一写出。在这些方法中，寄生组合式继承被认为是最好的，所以，只要记住这一种写法不就可以了吗。寄生组合式继承代码如下：123456789101112131415161718192021222324252627function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"实现call函数","slug":"实现call函数","date":"2018-10-19T02:00:15.000Z","updated":"2024-01-11T07:00:59.264Z","comments":true,"path":"2018/10/19/实现call函数/","link":"","permalink":"/2018/10/19/实现call函数/","excerpt":"自己实现call函数","text":"自己实现call函数 实现call函数实现代码很简单，直接贴出来123456789101112131415161718Function.prototype.myCall = function(context) &#123; context.fn = this; var args = arguments, str=''; for(var i=1; i&lt;args.length; i++) &#123; str += (args[i]+','); &#125; var newStr = str.slice(0,(str.length-1)); eval('context.fn('+newStr+')');&#125;function abc(a,b) &#123; console.log(this.name+a+b);&#125;abc.myCall(&#123; name: 'join'&#125;,1,2);abc.myCall(&#123; name: 'mike'&#125;,3,4);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"ajax跨域请求自定义header字段问题","slug":"ajax跨域请求自定义header字段问题","date":"2018-10-16T03:14:48.000Z","updated":"2024-01-11T07:00:59.176Z","comments":true,"path":"2018/10/16/ajax跨域请求自定义header字段问题/","link":"","permalink":"/2018/10/16/ajax跨域请求自定义header字段问题/","excerpt":"Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX的处理办法","text":"Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX的处理办法 ajax跨域请求自定义header字段问题首先，在后端允许跨域请求的情况下，前端加上自定义的请求字段，如下123456789101112$.ajax(&#123; method: 'POST', url: reqUrl, headers: &#123; 'client-token': '123456' &#125;, data: &#123;goodsId: goodsId&#125;, dataType: 'json', success: function(res)&#123; &#125;, error: function() &#123;&#125;, &#125;); 客户端 按照上面的写，你需要处理的是 服务端 响应头的设置 1.第一步设置响应头123header('Access-Control-Allow-Origin:*'); //支持全域名访问，不安全，部署后需要固定限制为客户端网址header('Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE'); //支持的http 动作header('Access-Control-Allow-Headers:x-requested-with,content-type'); //响应头 请按照自己需求添加。 2.第二步了解IE chrome 等浏览器 对于 跨域请求并要求设置Headers自定义参数的时候的 “预请求” 就是如果遇到 跨域并设置headers的请求，所有请求需要两步完成！A 第一步：发送预请求 OPTIONS 请求。此时 服务器端需要对于OPTIONS请求作出响应 一般使用202响应即可 不用返回任何内容信息。（能看到这份手稿的人，本人不相信你后台处理不了一个options请求）B 第二步：服务器accepted 第一步请求后 浏览器自动执行第二步 发送真正的请求。此时 大多数人 会发现请求成功了，但是 有那么几个人会发现 请求成功了但是没有任何信息返回 why？因为你自定义的请求头在服务器响应中不存在！查看console输出 会发现一个问题：“Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX”【IE】，request header field xxxxxx is not allowed by Access-Control-Allow-Header【chrome】这是因为 你的XXXX请求头 没有在服务器端被允许哦~遇到这个问题 只有通过修改服务器端来完成，举例：需要设置 client-token这么一个自定义头，那么 你需要在 服务端里面 将header(‘Access-Control-Allow-Headers:x-requested-with,content-type，client-token’); 同学们自行体会吧 这种语法就是根据“,”分割 自己需要设置什么头，必须要在 服务端请求的响应头里面设置好，不然客户端永远永远提交不上去！至此 JavaScript/ajax 跨域+ 修改httpheader 任务完美实现。“人们都一直在抱怨 JavaScript同源策略限制了web前端的发展！然而是服务端做的不够细致！”","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"scratch介绍","slug":"scratch介绍","date":"2018-10-11T10:44:55.000Z","updated":"2024-01-11T07:00:59.229Z","comments":true,"path":"2018/10/11/scratch介绍/","link":"","permalink":"/2018/10/11/scratch介绍/","excerpt":"少儿编程神器scratch简单介绍","text":"少儿编程神器scratch简单介绍 scratch介绍scratch是一款儿童学习编程的软件，把具体的一些控制语句以图形的形式表现出来，可以用鼠标来拖动，很生动，简单，不理解编程的孩子们容易学习，本人也是刚刚接触学习scratch，跟孩子们一样需要重头来学习，因为我想做一名少儿编程启蒙老师。先把scratch的网址贴出来：scratch官网 安装scratch在线免安装首页点击try it out就进入在线页面玩耍了。 离线安装首页的footer位置，support下有Offline Editor连接，也可以点这里之后见下图位置可以下载安装了","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"少儿编程","slug":"少儿编程","permalink":"/tags/少儿编程/"}]},{"title":"编译与解释","slug":"编译与解释","date":"2018-10-10T05:11:48.000Z","updated":"2024-01-11T07:00:59.277Z","comments":true,"path":"2018/10/10/编译与解释/","link":"","permalink":"/2018/10/10/编译与解释/","excerpt":"编译与解释的介绍","text":"编译与解释的介绍 编译与解释什么是编译器编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。 什么是解释器在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码预编译成机器码。一个解释器，通常会用以下的姿势来执行程序代码：1.分析源代码，并且直接执行。2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。3.执行由解释器内部的编译器预编译后保存的代码可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。 分两个维度比较一下表现 Behavior 编译器把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。 解释器会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。 性能 Performance 编译器会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。 解释器会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。 关于代码，需要知道的几个概念在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。 高级语言代码 High-Level Code高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。 低级语言代码 Low-Level Code低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。但是这也意味着代码的可移植性很差。在我看来，高与低，只是一组相对词而已。越高级的语言，性能、自由度越不及低级语言。但是在抽象、可读可写性、可移植性越比低级语言优秀。在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。而到了今天，我们更多人对C语言偏向认知为「低级语言」。或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。 汇编语言 Assembly Language汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。它和计算机的体系结构以及机器指令是强关联的。换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。所以汇编语言也往往被称作象征性机器码(symbolic machine code) 字节码 Byte Code字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。它是由一堆指令集组成的代码，例如在javac编译过后的java源码产生的就是字节码。源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。 机器码 Machine Code机器码是一组可以直接被CPU执行的指令集，每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。 从熟悉的编程语言的角度来看看从左往右看，1.以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。2.以 BASIC 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。3.以 C 语言为例，我们在文本编译器编写好源代码，然后运行 gcc hello.c 编译出 hello.out 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。 抽象看本质：人与计算机之间的鸿沟无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。这也是很多人所说的「跳出这个框框再看」的思维方式。 无论是「编译 Compile」还是「解释 Interpret」。本质还是「人与计算机的交流形式」，人的语言最终转换成机器语言。一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。 就这么一个过程，我们就需要很多的翻译官。有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。 最后用一张图来展示一下编译与解释","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"编译","slug":"编译","permalink":"/tags/编译/"}]},{"title":"vue不同路由使用同一个组件重新加载这个组件","slug":"vue不同路由使用同一个组件重新加载这个组件","date":"2018-10-08T02:26:49.000Z","updated":"2024-01-11T07:00:59.233Z","comments":true,"path":"2018/10/08/vue不同路由使用同一个组件重新加载这个组件/","link":"","permalink":"/2018/10/08/vue不同路由使用同一个组件重新加载这个组件/","excerpt":"vue不同路由使用同一个组件重新加载这个组件","text":"vue不同路由使用同一个组件重新加载这个组件 vue不同路由使用同一个组件重新加载这个组件vue,react,angular都会有一个共同点，那就是如果两个路由用的是一个组件的话，在切换路由的时候组件的生命周期函数并没有被调用，比如有一些想在组件渲染之后调用的钩子函数并不会执行，这是为了性能的考虑。我之前用angular的时候有相应的解决办法，react也有，这里不做探讨，这里只说vue，昨天看到了一个这方面的解决方法，感觉很好，记录下来。有两种解决方案： 第一种监听$route的变化来初始化数据，如下：1234567891011121314151617181920212223data() &#123; return &#123; loading: false, error: null, post: null &#125;&#125;,watch: &#123; '$route': &#123; handler: 'resetData', immediate: true &#125;&#125;,methods: &#123; resetData() &#123; this.loading = false this.error = null this.post = null this.getPost(this.$route.params.id) &#125;, getPost(id)&#123; &#125;&#125; 第二种给router-view添加一个unique的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件，将key直接设置为路由的完整路径。1&lt;router-view :key=\"$route.fullpath\"&gt;&lt;/router-view&gt; 组件代码就可以正常的书写了，如下：123456789101112131415data() &#123; return &#123; loading: false, error: null, post: null &#125;&#125;,created () &#123; this.getPost(this.$route.params.id)&#125;,methods () &#123; getPost(postId) &#123; // ... &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"图片类型转换(image base64 file canvas)","slug":"图片类型转换-image-base64-file-canvas","date":"2018-09-29T03:32:57.000Z","updated":"2024-01-11T07:00:59.264Z","comments":true,"path":"2018/09/29/图片类型转换-image-base64-file-canvas/","link":"","permalink":"/2018/09/29/图片类型转换-image-base64-file-canvas/","excerpt":"图片的各种类型相互间的转换。","text":"图片的各种类型相互间的转换。 图片类型转换(image base64 file canvas)dom中的img标签来显示图片，在src上给一个图片的连接即可，但是如果想把这个图片放在canvas上，或者ipput上传的图片想显示出来，或者canvas剪裁的图片想保存为Blob格式用ajax上传等等一系列操作，如果不缕清楚的话真是迷糊，所以做一下小小的总结。 url连接urltoImage(url,fn) 会通过一个url加载所需要的图片对象，其中 url 参数传入图片的 url , fn 为回调方法,包含一个Image对象的参数，代码如下：1234567function urltoImage (url,fn)&#123; var img = new Image(); img.src = url; img.onload = function()&#123; fn(img); &#125;&#125;; canvas画图片imagetoCanvas(image) 会将一个 Image 对象转变为一个 Canvas 类型对象，其中 image 参数传入一个Image对象，代码如下：12345678function imagetoCanvas(image)&#123; var cvs = document.createElement(\"canvas\"); var ctx = cvs.getContext('2d'); cvs.width = image.width; cvs.height = image.height; ctx.drawImage(image, 0, 0, cvs.width, cvs.height); return cvs ;&#125;; canvas图片转Blob canvasResizetoFile(canvas,quality,fn) 会将一个 Canvas 对象压缩转变为一个 Blob 类型对象；其中 canvas 参数传入一个 Canvas 对象; quality 参数传入一个0-1的 number 类型，表示图片压缩质量; fn 为回调方法，包含一个 Blob 对象的参数;代码如下： 12345function canvasResizetoFile(canvas,quality,fn)&#123; canvas.toBlob(function(blob) &#123; fn(blob); &#125;,'image/jpeg',quality);&#125;; 这里的 Blob 对象表示不可变的类似文件对象的原始数据。 Blob 表示不一定是 JavaScript 原生形式的数据。 File 接口基于 Blob ，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件。我们可以把它当做File类型对待，其他更具体的用法可以参考MDN文档 canvas转dataURL canvasResizetoDataURL(canvas,quality) 会将一个 Canvas 对象压缩转变为一个 dataURL 字符串,其中 canvas 参数传入一个 Canvas 对象; quality 参数传入一个0-1的 number 类型，表示图片压缩质量;代码如下：123methods.canvasResizetoDataURL = function(canvas,quality)&#123; return canvas.toDataURL('image/jpeg',quality);&#125;; 其中的 toDataURL API可以参考MDN文档 File(Blob)转dataURL filetoDataURL(file,fn) 会将 File （ Blob ）类型文件转变为 dataURL 字符串,其中 file 参数传入一个 File （ Blob ）类型文件; fn 为回调方法，包含一个 dataURL 字符串的参数;代码如下： 1234567function filetoDataURL(file,fn)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; fn(e.target.result); &#125;; reader.readAsDataURL(file);&#125;; dataURL转为Image类型文件 dataURLtoImage(dataurl,fn) 会将一串 dataURL 字符串转变为 Image 类型文件,其中 dataurl 参数传入一个 dataURL 字符串, fn 为回调方法，包含一个 Image 类型文件的参数，代码如下： 1234567function dataURLtoImage(dataurl,fn)&#123; var img = new Image(); img.onload = function() &#123; fn(img); &#125;; img.src = dataurl;&#125;; dataURL转为Blob类型dataURLtoFile(dataurl) 会将一串 dataURL 字符串转变为 Blob 类型对象，其中 dataurl 参数传入一个 dataURL 字符串,代码如下：12345678function dataURLtoFile(dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type:mime&#125;);&#125;; 实际应用demo对于常用的将一个 File 对象压缩之后再变为 File 对象,我们可以将上面的方法再封装一下，参考如下代码：1234567function fileResizetoFile(file,quality,fn)&#123; filetoDataURL (file,function(dataurl)&#123; dataURLtoImage(dataurl,function(image)&#123; canvasResizetoFile(imagetoCanvas(image),quality,fn); &#125;) &#125;)&#125; 其中， file 参数传入一个 File （ Blob ）类型文件； quality 参数传入一个 0-1 的 number 类型，表示图片压缩质量； fn 为回调方法，包含一个 Blob 类型文件的参数。它使用起来就像下面这样：12345var file = document.getElementById('demo').files[0];fileResizetoFile(file,0.6,function(res)&#123; console.log(res); //拿到res，做出你要上传的操作；&#125;) 再来一个图片等比压缩的demo1234567891011121314151617181920212223242526272829function proDownImage(path,imgObj) &#123; // 等比压缩图片工具 //var proMaxHeight = 185; var proMaxHeight=300; var proMaxWidth = 175; var size = new Object(); var image = new Image(); image.src = path; image.attachEvent(\"onreadystatechange\", function() &#123; // 当加载状态改变时执行此方法,因为img的加载有延迟 if (image.readyState == \"complete\") &#123; // 当加载状态为完全结束时进入 if (image.width &gt; 0 &amp;&amp; image.height &gt; 0) &#123; var ww = proMaxWidth / image.width; var hh = proMaxHeight / image.height; var rate = (ww &lt; hh) ? ww: hh; if (rate &lt;= 1) &#123; alert(\"imgage width*rate is:\" + image.width * rate); size.width = image.width * rate; size.height = image.height * rate; &#125; else &#123; alert(\"imgage width is:\" + image.width); size.width = image.width; size.height = image.height; &#125; &#125; &#125; imgObj.attr(\"width\",size.width); imgObj.attr(\"height\",size.height); &#125;);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"一些好的文章收集","slug":"一些好的文章收集","date":"2018-09-28T02:19:50.000Z","updated":"2024-01-11T07:00:59.242Z","comments":true,"path":"2018/09/28/一些好的文章收集/","link":"","permalink":"/2018/09/28/一些好的文章收集/","excerpt":"网上看到的好文章，总结收集。","text":"网上看到的好文章，总结收集。 一些好的文章收集自己写博客文章真的是一件耗时的事儿，写文章需要把各个方面的知识都整理好，有时候我都是在网上看到一篇不错的文章，想记录下来，就照猫画虎的copy，但是，copy下拉也需要时间啊，没办法，现在我只能把连接记录下来，等有时间再好好地记录一下。 高频dom操作和页面性能优化探索 送你43道JS面试题 SVG快速入门 浏览器audio自动播放解决方式 前端基础拾遗90问 3D小游戏教程 3D模型下载 the-super-tiny-compiler,js编译器","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"文章收集","slug":"文章收集","permalink":"/tags/文章收集/"}]},{"title":"hexo中使用hexo-asset-image插件来加载本地图片","slug":"hexo中使用hexo-asset-image插件来加载本地图片","date":"2018-09-21T02:55:52.000Z","updated":"2024-01-11T07:00:59.191Z","comments":true,"path":"2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","link":"","permalink":"/2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","excerpt":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。","text":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。 hexo中使用hexo-asset-image插件来加载本地图片在使用hexo时，在md文件里加载图片一般都会用到网络上的图片，但是如果有些图片不允许使用，怎么办？当然可以用七牛云这种图床网站，如果想使用本地的图片怎么办呢？那就用到了hexo-asset-image这个插件，但是这个插件写的很早，与现在新版本的hexo不兼容，于是乎就有一些大牛进行了修改，这里贴出这位大牛的github地址，兼容新版本hexo的hexo-asset-image插件。使用方法就是替换掉npm安装的hexo-asset-image插件中的文件,代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 图片具体的引入方式：12345678MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.mdMake sure post_asset_folder: true in your _config.yml.Just use ![logo](logo.jpg) to insert logo.jpg.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"HTTP缓存机制及原理","slug":"HTTP缓存机制及原理","date":"2018-09-19T02:14:58.000Z","updated":"2024-01-11T07:00:59.122Z","comments":true,"path":"2018/09/19/HTTP缓存机制及原理/","link":"","permalink":"/2018/09/19/HTTP缓存机制及原理/","excerpt":"HTTP缓存机制及原理的一些小总结","text":"HTTP缓存机制及原理的一些小总结 HTTP缓存机制及原理前言Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。 在介绍HTTP缓存之前，作为知识铺垫，先简单介绍一下HTTP报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。已存在缓存数据时，仅基于强制缓存，请求数据的流程如下已存在缓存数据时，仅基于对比缓存，请求数据的流程如对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 ExpiresExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886）图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。第一次访问：再次访问：通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。 Last-Modified / If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。浏览器第一次请求：浏览器再次请求时：","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"css省略号","slug":"css省略号","date":"2018-09-14T07:39:45.000Z","updated":"2024-07-19T06:51:21.792Z","comments":true,"path":"2018/09/14/css省略号/","link":"","permalink":"/2018/09/14/css省略号/","excerpt":"页面中文字溢出的省略号","text":"页面中文字溢出的省略号 css文本溢出省略号单行文本省略号1234overflow: hidden;text-overflow: ellipsis;white-space: nowrap;// 有些浏览器需要加上width 多行文本溢出省略号在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp ；注意：这是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 兼容其它浏览器的写法html:1&lt;p&gt;WebKit Browsers will clamp the number of lines in this paragraph to 2. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt; css:12345678910111213141516p &#123; position:relative; line-height:1.4em; /* 3 times the line-height to show 3 lines */ height:4.2em; overflow:hidden;&#125;p::after &#123; content:\"...\"; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; background:url(http://css88.b0.upaiyun.com/css88/2014/09/ellipsis_bg.png) repeat-y;&#125; 这里注意几点： height高度最好是line-height的3倍； 结束的省略号用了半透明的png做了减淡的效果，或者设置背景颜色； IE6-7不显示content内容，所以要兼容IE6-7可以是在内容中加入一个标签，比如用…去模拟； 要支持IE8，需要将::after替换成:after；","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"资源导航","slug":"资源导航","date":"2018-09-06T09:05:00.000Z","updated":"2025-05-30T07:33:58.649Z","comments":true,"path":"2018/09/06/资源导航/","link":"","permalink":"/2018/09/06/资源导航/","excerpt":"整理常用的工具库和学习资源","text":"整理常用的工具库和学习资源 资源导航github coco大神的github 前端工匠-浪里行舟 造轮子教程 liriliri 街角小林 老陈打码 m3u8视频下载 学习资源 玄魂工作室-nw.js教程 WebGL教程-郭隆邦_技术博客 SVG教程 阮一峰javascript教程 阮一峰typeScript教程 阮一峰es6教程 阮一峰Web-API教程 廖雪峰的官方网站 软考高级架构师 技术胖-前端知识图谱+B站视频整合 汪图南 木易杨前端进阶 大深海的技术博客 苏南大叔 历时8个月！10w字前端知识体系+大厂面试总结（基础知识篇） 后盾人 SQL之母 街角小林 若川的博客 一尾流莺-架构师文章文档电子书 书栈网 看云-typescript 大团队官网 京东-凹凸实验室 腾讯-alloyteam 腾讯-imweb 淘宝-FED 百度-FEX工具库 JavaScript 资源大全中文版 阿里-imgcook-由设计稿一键智能生成代码 浏览器兼容性查看-caniuse html-在线guide css-在线guide 在线开发工具-可以选择各种框架一 在线开发工具-可以选择各种框架二 正则大全 30-seconds-of-code Turf-地理空间分析库，处理各种地图算法 PIXABAY-图片音频视频nodejs nodejs资源总汇 Nodejs技术栈 小满Nodejs教程刷题 web前端面试 力扣 javascriptQuestions工作参考 echarts案例合集AI网站 AI导航黄页 百度-文心一言 阿里-通义千问 腾讯-混元 讯飞星火 月之暗面AI学习 tensorflow.js 机器学习速成课程 LangGPT 结构化提示词","categories":[],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"资源导航","slug":"资源导航","permalink":"/tags/资源导航/"}]},{"title":"jquery上传文件","slug":"jquery上传文件","date":"2018-09-03T05:26:56.000Z","updated":"2024-01-11T07:00:59.196Z","comments":true,"path":"2018/09/03/jquery上传文件/","link":"","permalink":"/2018/09/03/jquery上传文件/","excerpt":"之前在项目中使用jquery，Formdata实现文件上传","text":"之前在项目中使用jquery，Formdata实现文件上传 jquery上传文件现在的上传文件插件非常的多，比如在一个表单中，上传身份证照片，点击上传按钮，选好图片，上传好了，一般都提交到了一个图片服务器上，这是常规做法，但是有遇到过，有的后端同事要求我在点击form的提交按钮时，图片和输入框，下拉信息一并提交，当然，直接用form来做都不用改什么就可以，但是，如果需要更灵活的话，我选择了FormData对象配合jquery来做，具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;upload file&lt;/title&gt; &lt;script src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt;.upload_area &gt; div, .userType_area &gt; div , .sendType_area &gt; div &#123; border: 1px solid #DAD5D5; padding: 10px 15px;&#125;#myUploadBtn&#123; background-color:#1874D5; border: none; color: #ffffff; padding: 5px 12px;&#125;h3 &#123; margin: 5px 0;&#125;.fileName &#123; margin-left: 15px;&#125;.userType_area &#123;&#125; .userType_area ul , .sendType_area ul &#123; overflow: hidden;&#125;.userType_area ul li , .sendType_area ul li &#123; position: relative; float: left; padding: 2px 5px; background-color:#1874D5; color: #ffffff; color: #ffffff; margin: 0 10px; cursor: pointer;&#125;span.checkMark &#123; position: absolute; top: 0; right: 0; width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0,0,0,.5); color: #fffff; text-align: center;&#125;.text_area &#123;&#125;.text_area textarea &#123; width: 100%; height: 120px;&#125;.mes_box &#123; display: none; position: absolute; top: 20%; left: 50%; margin:0 0 0 -150px; width: 300px; height: 200px; background-color: gray; border-radius: 5px; text-align: center;&#125;.mes_box &gt; .cancel &#123; position: absolute; width: 30px; height: 30px; border-radius: 20px; text-align: center; line-height:23px; color: #fff; font-size: 25px; right: 5px; top: 3px; border: 1px solid #fff; cursor: pointer;&#125;.mes_box &gt; strong &#123; color: #ffffff; display: inline-block; margin: 70px 0; font-size: 16px;&#125;&lt;/style&gt;&lt;div class=\"mes_box\"&gt; &lt;span class=\"cancel\"&gt;x&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;input type=\"file\" id=\"choosefile\" style=\"display:none;\" /&gt;&lt;div class=\"upload_area\"&gt; &lt;h3&gt;上传文件&lt;/h3&gt; &lt;div&gt; &lt;button id=\"myUploadBtn\"&gt;请选择您要上传的文件&lt;/button&gt; &lt;span class=\"fileName\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"userType_area\"&gt; &lt;h3&gt;选择用户类型&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;余额不足&lt;/li&gt; &lt;li data-code=\"2\"&gt;宽带到期&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"sendType_area\"&gt; &lt;h3&gt;选择推送触点&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;辽宁联通为信号&lt;/li&gt; &lt;li data-code=\"2\"&gt;短信&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"text_area\"&gt; &lt;h3&gt;输入推送需求&lt;/h3&gt; &lt;div&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;button id=\"sendFile\" type=\"button\" class=\"btn btn-primary bsok\"&gt;提交&lt;/button&gt;&lt;script&gt;(function()&#123; var isok = true , isover = false; //选择文件点击事件 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;); //上传选择文件change事件 $('#choosefile').on('change',function()&#123; $('.fileName').text('上传的文件名：'+$(this)[0].files[0].name); &#125;); //被选中函数 function checkMark($el,isDan)&#123; var strNode = '&lt;span class=\"checkMark\"&gt;√&lt;/span&gt;' if(isDan)&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.siblings().data('checkMark', false).find('span').remove(); $el.data('checkMark', true).append(strNode); &#125; &#125;else&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.data('checkMark', true).append(strNode); &#125; &#125; &#125; //获取被选中的code function getCode($el)&#123; var arr = []; $el.find('li').each(function(index, el) &#123; if($(this).data('checkMark') == true)&#123; arr.push($(this).data('code')); &#125; &#125;); return arr; &#125; //选择用户类型添加事件 $('.userType_area li').on('click',function()&#123; checkMark($(this),true); &#125;); //推送触点添加事件 $('.sendType_area li').on('click',function()&#123; checkMark($(this),false); &#125;); //上传文件点击事件 $('#sendFile').on('click',function()&#123; var fd = new FormData(); var upload_file = $('#choosefile')[0].files[0]; var userType = getCode($('.userType_area')); var sendType = getCode($('.sendType_area')); var text = $('.text_area textarea').val(); if(upload_file)&#123; var houz = /\\.[^\\.]+$/.exec(upload_file.name); var size = upload_file.size; &#125; console.log(upload_file); if(!upload_file)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择一个要上传的文件'); isok = false; &#125;else if(userType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择用户类型'); isok = false; &#125;else if(sendType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择推送触点'); isok = false; &#125;else if(!text)&#123; $('.mes_box').show(); $('.mes_box strong').text('请输入推送需求'); isok = false; &#125;else if(houz[0] !== '.txt')&#123; $('.mes_box').show(); $('.mes_box strong').text('请上传以txt结尾的文件'); isok = false; &#125;else if(size &gt; 4194304)&#123; $('.mes_box').show(); $('.mes_box strong').text('您上传的文件过大，请上传小于4M的文件'); isok = false; &#125;; fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file); if(isok)&#123; $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false, contentType: false, data: fd, success:function(res)&#123; $(\".modal-content\").mask(\"hide\"); if(true)&#123; $('.mes_box').show(); $('.mes_box strong').text('数据提交成功'); isover = true; &#125;else&#123; $('.mes_box').show(); $('.mes_box strong').text('服务器问题，数据提交失败'); &#125; &#125;, error:function(err)&#123; $(\".modal-content\").mask(\"hide\"); $('.mes_box').show(); $('.mes_box strong').text('由于网络原因提交失败'); &#125; &#125;); $(\".modal-content\").mask(\"show\");//ajax提交数据出现loading蒙层 &#125; &#125;); //提示框关闭按钮点击事件 $('.mes_box .cancel').on('click',function()&#123; $(this).parent().hide(); isok = true; if(isover === true)&#123; $('#createModal').remove(); $('.modal-backdrop.fade.in').remove(); &#125; &#125;);&#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是整个页面的内容，其实重要的几个点在这里：12345678910111213141516171819202122232425 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;);上边这个函数就是把实际的input file 标签隐藏，用其他的按钮来触发弹出选择文件的窗口，注意，不能直接用file.click()这种形式，要 (function()&#123; return file.click(); &#125;)();这样做才可以调出选择文件的窗口。再有一点，利用了h5的 var fd = new FormData(); 类，把需要上传的文件起个key值，直接放到fd实例里， fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file);之后用ajax直接把fd对象上传就可以了，以jquery为例 $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false,//不对数据进行处理，保持2进制 contentType: false,//不对数据进行处理，保持2进制 data: fd &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"javascript提高性能","slug":"javascript提高性能","date":"2018-09-01T07:00:22.000Z","updated":"2024-01-11T07:00:59.195Z","comments":true,"path":"2018/09/01/javascript提高性能/","link":"","permalink":"/2018/09/01/javascript提高性能/","excerpt":"javascript提高性能的方式总结","text":"javascript提高性能的方式总结 javascript提高性能&emsp;&emsp;javascript如何提高性能，这个在面试中被问到的几率也是蛮高的，之前我也就是想到哪里说到哪里，面试官估计也都是菜鸟（我面的也都是小公司），也觉得我说的对，但是，有空冷静下来，觉得自己说的每次都不是很全面，所以，我想把平时能想到的记录下来，这样再去面试的时候，呵呵，一定把面试官说蒙。 4种内存泄漏&emsp;&emsp;提高JavaScript性能，首先就是避免4种内存泄漏,这里只是简单列出。 1.意外的全局变量JavaScript的目标是开发一种看起来像Java但足够自由的被初学者使用的语言。JavaScript自由的其中一种方式是它可以处理没有声明的变量：一个未声明的变量的引用在全局对象中创建了一个新变量。在浏览器的环境中，全局对象是window。也就是说：1234567function foo(arg) &#123; bar = \"this is a hidden global variable\";&#125;实际上是：function foo(arg) &#123; window.bar = \"this is an explicit global variable\";&#125; 如果bar是仅在foo函数作用域内承载引用，并且你忘记用var来声明的变量，一个意外的全局变量就被创建了。在这个例子中，泄漏一个单一字符串不会有太大害处，但这的确是不好的。另一种意外全局变量被创建的方式是通过this：123456function foo() &#123; this.variable = \"potential accidental global\";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这种错误发生，在你的Javascript文件最前面添加’use strict;’。这开启了解析JavaScript的阻止意外全局的更严格的模式。全局变量的一个注意事项：即使我们谈了不明的全局变量，仍然存在很多代码被显式的全局变量填充的情况。这是通过定义不可收集的情况（除非清零或重新赋值）。特别的，用来临时存储和处理大量信息的全局变量会引起关注。如果必须用全局变量来存储很多数据，在处理完之后，确保对其清零或重新赋值。 一个在与全局连接上增加内存消耗常见的原因是缓存)。 缓存存储重复被使用的数据。为此，为了有效，缓存必须有其大小的上限。飙出限制的缓存可能会因为内容不可被回收，导致高内存消耗。 2.被遗忘的计时器或回调在JavaScript中setInterval的使用相当常见。其他库提供观察者和其他工具以回调。这些库中大多数，在引用的实例变成不可访问之后，负责让回调的任何引用也不可访问。在setInterval的情况下，这样的代码很常见：12345678var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource));&#125;&#125;, 1000); 这个例子表明了跳动的计时器可能发生什么：计时器使得节点或数据的引用不再被需要了。代表node的对象将来可能被移除，使得整个块在间隔中的处理不必要。然而，处理函数，由于间隔仍然是活跃的，不能被回收（间隔需要被停掉才能回收）。如果间隔处理不能被回收，它的依赖也不能被回收。那意味着可能存储着大量数据的someResource，也不能被回收。观察者情况下，一旦不被需要（或相关的对象快要访问不到）就创建明确移除他们的函数很重要。在过去，这由于特定浏览器（IE6）不能很好的管理循环引用（下面有更多相关信息），曾经尤为重要。现如今，一旦观察对象变成不可访问的，即使收听者没有明确的被移除，多数浏览器可以并会回收观察者处理函数。然而，它保持了在对象被处理前明确的移除这些观察者的好实践。例如：1234567891011var element = document.getElementById('button');function onClick(event) &#123; element.innerHtml = 'text';&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don't// handle cycles well. 一条关于对象观察者及循环引用的笔记观察者和循环引用曾经是JavaScript开发者的祸患。这是由于IE垃圾回收的一个bug(或者设计决议)出现的情况。IE的老版本不能检测到DOM节点和JavaScript代码间的循环引用。 这是一个通常为观察到的保留引用（如同上面的例子）的观察者的典型。 也就是说，每次在IE中对一个节点添加观察者的时候，会导致泄漏。这是开发者在节点或空引用之前开始明确的移除处理函数的原因。 现在，现代浏览器（包括IE和MS Edge）使用可以剪裁这些循环和正确处理的现代垃圾回收算法。换言之，在使一个节点不可访问前，调用removeEventLister不是严格意义上必须的。像Jquery一样的框架和库做了在处置一个节点前（当为其使用特定的API的时候）移除监听者的工作。这被在库内部处理，即使在像老版本IE一样有问题的浏览器里面跑，也会确保没有泄漏产生。 3. 超出DOM引用有时存储DOM节点到数据结构中可能有用。假设你想要迅速的更新一个表格几行内容。存储每个DOM行节点的引用到一个字典或数组会起作用。当这发生是，两个对于同个DOM元素的引用被留存：一个在DOM树中，另外一个在字典中。如果在将来的某些点你决定要移除这些行，需要让两个引用都不可用。123456789101112131415161718var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text')&#125;;function doStuff() &#123;image.src = 'http://some.url/image';button.click();console.log(text.innerHTML);// Much more logic&#125;function removeButton() &#123;// The button is a direct child of body.document.body.removeChild(document.getElementById('button'));// At this point, we still have a reference to #button in the global// elements dictionary. In other words, the button element is still in// memory and cannot be collected by the GC.&#125; 对此的额外考虑，必须处理DOM树内的内部节点或叶子节点。假设你在JavaScript代码中保留了一个对于特定的表格内节点（一个td标签）的引用。在将来的某个点决定从DOM中移除这个表格，但是保留对于那个节点的引用。直观的，会假设GC会回收除那个节点之外的每个节点。在实践中，这不会发生的：这个单节点是那个表格的子节点，子节点保留对父节点引用。换句话说，来自JavaScript代码的表格元素的引用会引起在内存里存整个表格。当保留DOM元素的引用的时候，仔细考虑下。 4.闭包一个JavaScript开发的关键点是闭包：从父级作用域捕获变量的匿名函数。很多开发者发现，由于JavaScript runtime的实现细节，有以一种微妙的方式泄漏的可能，这种特殊的情况：123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码片段做了一件事：每次replaceThing被调用的时候，theThing获取到一个包括一个大数组和新闭包(somMethod)的新对象。同时，变量unused保留了一个有originalThing（theThing从之前的对replaceThing的调用）引用的闭包。已经有点疑惑了，哈？重要的是一旦一个作用域被在同个父作用域下的闭包创建，那个作用域是共享的。这种情况下，为闭包somMethod创建的作用域被unused共享了。unused有一个对originalThing的引用。即使unused从来没被用过，someMethod可以通过theTing被使用。由于someMethod和unused共享了闭包作用域，即使unused从来没被用过，它对originalThing的引用迫使它停留在活跃状态（不能回收）。当这个代码片段重复运行的时候，可以看到内存使用稳步的增长。GC运行的时候，这并不会减轻。本质上，一组关联的闭包被创建（同unused变量在表单中的根节点一起），这些闭包作用域中每个带了大数组一个非直接的引用，导致了大型的泄漏。 垃圾回收的直观行为即使垃圾回收很方便，他们有自己的一套权衡方法。其中一个权衡是nondeterminism。也就是说，GC是不可预期的。通常不能确定什么时候回收器被执行。这意味着在一些情况下，需要比程序正在使用的更多的内存。其他情况下，短的暂停在特别敏感的应用中很明显。即使不确定性意味着不能确定回收什么时候执行，大多数GC实现共享在分配期间，普通的回收通行证模式。如果没有执行分配，大多数CG停留在休息状态。考虑下面的方案：1.执行一组大型的分配。2.多数元素（或所有）被标记为不可访问（假设我们置空了一个指向不再需要的缓存的引用）。3.没有进一步的分配执行了。在这个方案中，大多GC不会运行任何进一步的回收通行了。换言之，即使有可用于回收的，不可访问的引用，回收器不会要求他了。这不是严格的泄漏，但是也会导致比平常更高的内存使用率。Google在 JavaScript Memory Profiling docs, example #2.文章中，提供了一个优秀的例子。 编写javascript代码时的优化1.从JavaScript的作用域谈起当JavaScript代码执行时，JavaScript引擎会创建一个执行环境，又叫执行上下文。执行环境定义了变量或函数有权访问的其他数据，决定了它们的行为，每个执行环境都有一个与它关联的变量对象，环境中定义的所有函数、变量都保存在这个对象中。在页面加载的时候，JavaScript引擎会创建一个全局的执行环境，所有全局变量和函数都是作为window对象（浏览器中）的属性和方法创建的。在此之后，每执行一个函数，JavaScript引擎都会创建一个对应的执行环境，并将该环境放入环境栈中，所以当前正在执行的函数的执行环境是在环境栈的最顶部的，当函数执行完毕之后，其执行环境会弹出栈，并被销毁，保存在其中的变量和函数定义也会被销毁。当代码在一个执行环境中执行时，JavaScript引擎会创建变量对象的一个作用域链，它可以保证对执行环境有权访问的变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。全局环境的作用域链中只有一个变量对象，它定义了所有可用的全局变量和函数。当函数被创建时，JavaScript引擎会把创建时执行环境的作用域链赋给函数的内部属性[[scope]]；当函数被执行时，JavaScript引擎会创建一个活动对象，最开始时这个活动对象只有一个变量，即arguments对象。该活动对象会出现在执行环境作用域链的顶端，接下来是函数[[scope]]属性中的对象。当需要查找某个变量或函数时，JavaScript引擎会通过执行环境的作用域链来查找变量和函数，从作用域链的顶端开始，如果没找到，则向下寻找直至找到为止。若一直到全局作用域都没有找到,则该变量或函数为undefined。举个栗子：1234function add(a,b) &#123; return a + b;&#125;var result = add(2,3); 代码执行时，add函数有一个仅包含全局变量对象的[[scope]]属性，add函数执行时，JavaScript引擎创建新的执行环境以及一个包含this、arguments、a、b的活动对象，并将其添加到作用域链中。如下图所示： 2.使用局部变量了解了作用域链的概念，我们应该知道在查找变量会从作用域链的顶端开始一层一层的向下找。显然，查找的层数越多，花费的时间越多。所以为了提高查找的速度，我们应该尽量使用 局部变量（到目前为止，局部变量是JavaScript中读写最快的标识符）。例如：1234567function createEle() &#123; document.createElement(\"div\");&#125;function createEle() &#123; var doc = document; doc.createElement(\"div\");&#125; 当document使用次数比较少时，可能无所谓，可是如果在一个函数的循环中大量使用document，我们可以提前将document变成局部变量。来看看jquery怎么写的：12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery;&#125;)(window); 这样写的优势：1、window和undefined都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。（原来的window处于作用域链的最顶端，查找速度慢）2、在jquery压缩版本jquery.min.js中可以将局部变量window替换成单个字母，减小文件大小，提高加载速度3、undefined也是JavaScript中的全局属性。将undefined作为参数传递给闭包，因为没给它传递值，它的值就是undefined，这样闭包内部在使用它的时候就可以把它当做局部变量使用，从而提高查找速度。undefined并不是JavaScript的保留字或者关键字。4、undefined在某些低版本的浏览器（例如IE8、IE7）中值是可以被修改的（在ECMAScript3中，undefined是可读/写的变量，可以给它赋任意值，这个错误在ECMAScript5中做了修正），将undefined作为参数并且不给它传值可以防止因undefined的值被修改而产生的错误。 3.避免增长作用域链在JavaScript中，有两种语句可以临时增加作用域链：with、try-catchwith可以使对象的属性可以像全局变量来使用，它实际上是将一个新的变量对象添加到执行环境作用域的顶部，这个变量对象包含了指定对象的所有属性，因此可以直接访问。这样看似很方便，但是增长了作用域链，原来函数中的局部变量不在处于作用域链的顶端，因此在访问这些变量的时候要查找到第二层才能找到它。当with语句块之行结束后，作用域链将回到原来的状态。鉴于with的这个缺点，所以不推荐使用。try-catch中的catch从句和with类似，也是在作用域链的顶端增加了一个对象，该对象包含了由catch指定命名的异常对象。但是因为catch语句只有在放生错误的时候才执行，因此影响比较少。 4.字符串链接优化由于字符串是不可变的，所以在进行字符串连接时，需要创建临时字符串。频繁创建、销毁临时字符串会导致性能低下。当然，这个问题在新版本浏览器包括IE8+中都得到了优化，所以不需要担心在低版本浏览器（IE6、IE7）中，我们可以种数组的join方法来代替。123456var temp = [];var i = 0;temp[i++] = \"Hello\";temp[i++] = \" \";temp[i++] =\"everyone\";var outcome = temp.join(\"\"); 5.条件判断当出现条件判断时，我们采用什么样的结构才能使性能最优？1234567891011if(val == 0) &#123; return v0;&#125;else if(val == 1) &#123; return v1;&#125;else if(val == 2) &#123; return v2;&#125;else if(val == 3) &#123; return v3;&#125;else if(val == 4) &#123; return v4;&#125; 当条件分支比较多时，我们可以斟酌哪种条件出现的概率比较大，并将对应的语句放在最上面，这样可以减少判断次数。使用switch语句，新版的浏览器基本上都对switch做了优化，这样层数比较深时，性能比if会更好使用数组：12var v = [v0,v1,v2,v3,v4];return v[valeue]; 要求：对应的结果是单一值，而不是一系列操作另外，其他方面的优化，譬如1234567891011if(condition1) &#123; return v1;&#125;else &#123; return v2&#125;// 改成if(condition1) &#123; return v1;&#125;return v2; 6.快速循环1、循环总次数使用局部变量12345678for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125; 这样就避免了每次循环的属性查找。这点尤其重要，因为在进行dom操作时，很多人会这样写：1234var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125; 查找DOM元素的属性是相对耗时的，所以应该避免这种写法。2、如果可以，递减代替递增1234567891011121314151617for(var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成for(var i = arr.length - 1;i--;) &#123;&#125;var i = 0;while(i &lt; arr.length) &#123; i++;&#125;// 改成var i = arr.length - 1;while(i--) &#123;&#125; i=0的时候会直接跳出，循环次数比较多时还是很有用的。 7.展开循环1234var i = arr.length - 1;while(i--) &#123; dosomething(arr[i]);&#125; 遇到这样的情况时，执行一次循环的时候我们可以选择不止执行一次函数。12345678910111213141516171819var interations = Math.floor(arr.length / 8);var left = arr.length % 8;var i = 0;if(left) &#123; do &#123; dosomething(arr[i++]); &#125; while(--left);&#125;do &#123; dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]);&#125; while(--interations); 当遇到大数组，减少循环的开销，性能不就提上去了嘛。（至于为什么是每次循环，调8次函数，大牛测出来的，这样达到最佳） 8.高效存取数据JavaScript中4种地方可以存取数据：字面量值；变量；数组元素；对象属性字面量值和变量中存取数据是最快的，从数组元素和对象属性中存取数据相对较慢，并且随着深度增加，存取速度会越来越慢，譬如obj.item.value就比obj.item慢。某些情况下我们可以将对象、数组属性存成局部变量来提高速度，譬如：12345678910111213141516171819for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125;var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125;// 改成// var divList = document.getElementsByTagName(\"div\");for( var i = 0,len = divList.length;i &lt; len;i++) &#123;&#125; 9.事件委托事件委托就是利用冒泡的原理，将原本应该添加在某些元素身上的监听事件，添加到其父元素身上，来达到提高性能的效果。举个栗子：1234567891011121314151617181920212223242526&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); for(var i = 0,len = liList.length;i &lt; len;i++) &#123; liList[i].onclick = function() &#123; alert(this.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样我们就为每个li添加了监听事件了。显然，我们通过循环为每个li添加监听事件是不优化的。这样不仅浪费了内存，在新的li加入的时候我们还要重新为它添加监听事件。我们可以这样写：1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); ul.onclick = function(e) &#123; var e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName.toLowerCase() == \"li\") &#123; alert(target.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样写的好处：只添加一个监听事件，节省了内存；新加入li的时候我们也不用为它单独添加监听事件；在页面中添加事件处理程序所需的时候更少，因为我们只需要为一个DOM元素添加事件处理程序。 使用typescript使用typescript来提高性能我实在一本关于nodejs的书里看到的，主要还是用在chrome的V8引擎上，这本书里写的比如1234567// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; console.log(add(i + i*3));&#125; 书里说，如果V8引擎发现一个函数使用频率很高，而且参数传入的都是同一种类型的，好像是在内存寻址的时候书都很快，因为引擎认为传入的参数就是int型。再来看一个例子1234567891011// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; if(i % 8 === 0) &#123; console.log(add(i + i*0.3)); // 这里出现了浮点数 &#125;else &#123; console.log(add(i + i*3)); // 这里是整数 &#125;&#125; 上边的代码可以看到，在使用整形参数的时候突然传入浮点数，V8引擎寻址机制突然变化，丢弃之前的函数，使用新的来计算，性能下降。所以，如果使用typescript，类型固定，这样性能就会提高哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"vue双向绑定的简单实现","slug":"vue双向绑定的简单实现","date":"2018-08-30T03:13:39.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2018/08/30/vue双向绑定的简单实现/","link":"","permalink":"/2018/08/30/vue双向绑定的简单实现/","excerpt":"参考网上vue实现教程简单整理","text":"参考网上vue实现教程简单整理 vue双向绑定的简单实现&emsp;&emsp;首先，这篇文章并非我的原创，在网上看到了很多写vue原理的文章，感觉这篇写的层次结构清晰，容易理解，所以留作收藏。废话不多说，开始。 1.原理&emsp;&emsp;Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过 Object对象的defineProperty属性，重写data的set和get函数来实现的,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。添加网上的一张图 2.实现页面结构很简单，如下：1234567&lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button ype=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt;&lt;/div&gt; 包含：1.一个input，使用v-model指令2.一个button，使用v-click指令3.一个h3，使用v-bind指令。我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释：1234567891011var app = new myVue(&#123; el:'#app', data:&#123; number:0 &#125;, methods:&#123; increment:function()&#123; this.number++; &#125;, &#125; &#125;) 首先我们需要定义一个myVue构造函数：123function myVue(options)&#123;&#125; 为了初始化这个构造函数，给它添加一 个_init属性123456789function myVue(options) &#123; this._init(options);&#125;myVue.prototype._init = function (options) &#123; this.$options = options; // options 为上面使用时传入的结构体，包括el,data,methods this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素 this.$data = options.data; // this.$data = &#123;number: 0&#125; this.$methods = options.methods; // this.$methods = &#123;increment: function()&#123;&#125;&#125; &#125; 接下来实现_obverse函数，对data进行处理，重写data的set和get函数并改造_init函数12345678910111213141516171819202122232425262728293031323334myVue.prototype._obverse = function (obj) &#123; // obj = &#123;number: 0&#125; var value; for (key in obj) &#123; //遍历obj对象 if (obj.hasOwnProperty(key)) &#123; value = obj[key]; if (typeof value === 'object') &#123; //如果值还是对象，则遍历处理 this._obverse(value); &#125; Object.defineProperty(this.$data, key, &#123; //关键 enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; &#125; &#125; &#125;) &#125; &#125; &#125;myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._obverse(this.$data); &#125; 接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新12345678910111213function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。 &#125; 更新_init函数以及_obverse函数1234567891011121314151617181920212223242526272829myVue.prototype._init = function (options) &#123; //... this._binding = &#123;&#125;; //_binding保存着model与view的映射关系，也就是我们前面定义的Watcher的实例。当model改变时，我们会触发其中的指令类更新，保证view也能实时更新 //... &#125; myVue.prototype._obverse = function (obj) &#123; //... if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; // 按照前面的数据，_binding = &#123;number: _directives: []&#125; _directives: [] &#125;; //... var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; //... set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; // 当number改变时，触发_binding[number]._directives 中的绑定的Watcher类的更新 item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; 那么如何将view与model进行绑定呢？接下来我们定义一个_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 myVue.prototype._init = function (options) &#123; //... this._complie(this.$el); &#125; myVue.prototype._complie = function (root) &#123; root 为 id为app的Element元素，也就是我们的根元素 var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; // 对所有元素进行遍历，并进行处理 this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++ node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); //bind是使data的作用域与method函数的作用域保持一致 &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件 node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); //_this._binding['number']._directives = [一个Watcher实例] // 其中Watcher.prototype.update = function () &#123; // node['vaule'] = _this.$data['number']; 这就将node的值保持与number一致 // &#125; _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定 &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可 var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; 至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图 附上全部代码，不到150行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 &lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;myVue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #app &#123; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button type=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function myVue(options) &#123; this._init(options); &#125; myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._binding = &#123;&#125;; this._obverse(this.$data); this._complie(this.$el); &#125; myVue.prototype._obverse = function (obj) &#123; var value; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; _directives: [] &#125;; value = obj[key]; if (typeof value === 'object') &#123; this._obverse(value); &#125; var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; myVue.prototype._complie = function (root) &#123; var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; &#125; window.onload = function() &#123; var app = new myVue(&#123; el:'#app', data: &#123; number: 0 &#125;, methods: &#123; increment: function() &#123; this.number ++; &#125;, &#125; &#125;) &#125;&lt;/script&gt; 以上就是所有内容，这个代码不是我创造的，我只是代码的搬运工。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"webSocket","slug":"webSocket项目中的使用","date":"2018-08-29T01:23:54.000Z","updated":"2024-01-11T07:00:59.234Z","comments":true,"path":"2018/08/29/webSocket项目中的使用/","link":"","permalink":"/2018/08/29/webSocket项目中的使用/","excerpt":"在项目中使用websocket的小心得","text":"在项目中使用websocket的小心得 webSocket在项目中的使用&emsp;&emsp;webSocket,这个技术相信大家都已经很熟悉了，就是前端浏览器与后端服务器一直保持连通状态，我们在项目中，经常会遇到这样的需求，一个数据图表展示页面，产品的需求是每隔5秒钟页面刷新一次，传统的做法是请求轮询机制，也就是setInterval这个定时器，一遍又一遍的请求后端接口，这个方法简单（特别是后端简单），但是如果前端页面有大量的这种需求，会影响性能，所以，webSocket是现在最好的选择。&emsp;&emsp;其实webSocket现在还是比较重要的，一般在面试的时候，被问到的几率还是很大的。我之前在项目中没有用到过，但是自己写过webSocket的demo，浏览器配合nodejs来写，也是参考了网上的代码，还是很简单的webSocket详细代码看这里。在面试时被问到的时候，也是实话实说，有可能面试官也是小白，基本上都没往下问，但是，确实是这么简单吗？答案显然不是，待我慢慢道来。&emsp;&emsp;首先，我在最近两个项目中，都用到了webSocket，所以还是有发言权的。如果，产品提出了webSocket的需求，对于我们前端来说，并不是直接写个原生的webSocket就可以，而是需要看后端小伙伴们的脸色，什么意思？就是说得看后端用的是什么webSocket库，我接触的有两种，第一个是stomp,说是webSocket的子协议，后端选了这个库之后，我们前端也得相应的选择与后端相配合的前端库，一般情况下，官网很明确的给出了后端和前端相配合写法，当然，写法也是很简单，跟原生差不多。第二个是，sockjs这个库，当然，也是后端小伙伴选好了之后，告诉我，我相应的在前端也用的跟后端一样库。&emsp;&emsp;最后总结一下，webSocket技术并不难（对于我们前端来说，当然，nodejs的后端也很简单，java就不知道了，每次调起来看他们都是一脸懵逼的样子），无论是面试还是在实际工作中，问道这个问题时，我们首先想到的应该是，后端选择的是什么库，我们前端应该跟后端小伙伴保持一致，可别需求以来，觉得简单直接开些，等联调的时候，我靠，为什么连不上呢？你们前后端不在一个频道上，怎么连接啊。所以，我们要说，我做过的项目是这样这样滴，不知道这次我们后端小伙伴用到的webSocket库是什么呢？","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"webSocket","slug":"webSocket","permalink":"/tags/webSocket/"}]},{"title":"nodejs代理服务器","slug":"nodejs代理服务器","date":"2018-08-27T06:51:52.000Z","updated":"2024-01-11T07:00:59.225Z","comments":true,"path":"2018/08/27/nodejs代理服务器/","link":"","permalink":"/2018/08/27/nodejs代理服务器/","excerpt":"nodejs代理服务器简单实现","text":"nodejs代理服务器简单实现 nodejs代理服务 最近在与后台同事联调的时候，出现了点故障，跨域，这个经常碰到很好解决的问题，但是一般情况下需要前后端一起配合来解决，比如jsonp，或者h5后端在返回头加上允许跨域的头设置，但是如果后台同事是个小白，问啥啥不明白，也是没招了。我之前还用过将chrome的跨域设置给禁掉的方法，但是这次不知道为啥，也不好使了。最后，只能是用代理这种方式，我现在用的是vue框架，其实vue的脚手架已经集成了跨域功能，只需要配置一下就可以，但是，现在框架这么多，前一阵子还react，angular的项目，最近有换成vue，配置的话，肯定要去查看api，记不住啊，而且，版本不同，设置方法也不同，不如自己写一个，这样多简单，需要的时候把代理服务开启就搞定了。于是乎，自己写一个，当然，稍微想一下就知道，代理的原理，就是利用nodejs在中间做一次请求以及数据返回，不过自己写还得思考，上网找一下多简单，baidu一搜索，哇靠，第一个映入眼帘的就是nodejs代理服务8行代码，嗯，就是这么简单，废话不多说，上代码,当然，自己还得加工一下哦。123456789101112131415161718192021var express = require('express');var request = require('request');var app = express();const proxyUrl = process.argv[2] || 'http://127.0.0.1:8888'; // 如果有传入的代理url，使用它app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") res.send(200); // 让options请求快速返回 else next();&#125;);app.use('/', function(req, res) &#123; var url = proxyUrl + req.url; req.pipe(request(url)).pipe(res);&#125;);app.listen(process.env.PORT || 3000, ()=&gt;&#123; console.log('代理服务器，在3000端口已经开启');&#125;); 再把package.json文件内容贴出来12345678910111213141516&#123; &quot;name&quot;: &quot;node-proxy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;node server http://127.0.0.1:9000&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.3&quot;, &quot;request&quot;: &quot;^2.88.0&quot; &#125;&#125; 源码在这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端代理服务","slug":"后端代理服务","permalink":"/tags/后端代理服务/"}]}]}