{"meta":{"title":"jinux","subtitle":null,"description":"前端 学习 javascript","author":"jinux","url":""},"pages":[{"title":"categories","date":"2018-08-20T08:19:43.000Z","updated":"2018-10-12T02:42:30.655Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"javascriptnodejscss计算机原理少儿编程"},{"title":"tags-test","date":"2018-08-20T08:18:58.000Z","updated":"2018-08-27T06:24:35.212Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"tag-jquery"}],"posts":[{"title":"iPhoneX适配","slug":"iPhoneX适配","date":"2020-03-13T06:24:28.000Z","updated":"2020-03-13T06:44:07.611Z","comments":true,"path":"2020/03/13/iPhoneX适配/","link":"","permalink":"/2020/03/13/iPhoneX适配/","excerpt":"h5在iPhoneX中的页面兼容处理","text":"h5在iPhoneX中的页面兼容处理 iPhoneX适配基础设备信息首先在了解iPhoneX适配之前，需要了解关于iPhone设备的一些基础 关于iPhone的一些基础参数 iPhoneX设备信息iPhoneX屏幕组成：上部齐刘海sensor housing（44pt） + 安全区域safe area + 底部手势区域Home Indicator（34pt）safe area（安全区域）安全区域以外的是上部“齐刘海” 和 下部“手势区域”，一般情况下，我们都会在安全区域（safe area）中进行页面的编写； iPhoneX适配适配方案viewport-fit1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt; viewport-fit有两个值，contain和 cover默认是contain，页面内容显示在safe area中（不包括上部的齐刘海和下部的手势区域）cover值：页面内容充满屏幕 适配方案css constant()css constant()有四个值：safe-area-inset-top , safe-area-inset-left , safe-area-inset-right , safe-area-inset-bottom1)当viewport-fit:contain，上面这个四个值无效2)当viewport-fit:cover，这四个值需要设置，页面才会显示在安全区域中，设置如下：123456body &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px &#125; 适配方案媒体查询123@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123; // iphoneX css部分&#125; 总结viewport-fit:contain1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=contain&quot;&gt; viewpoer-fit: cover + css canstant()1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt; 123456body &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px &#125; css的媒体查询123@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123; // iphoneX css部分&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"/tags/兼容性/"}]},{"title":"generator自动运行器","slug":"generator自动运行器","date":"2020-03-12T07:08:06.000Z","updated":"2020-03-12T07:34:13.762Z","comments":true,"path":"2020/03/12/generator自动运行器/","link":"","permalink":"/2020/03/12/generator自动运行器/","excerpt":"手写一个generator自动运行器","text":"手写一个generator自动运行器 generator自动运行器generator函数是es6新出的功能，之后又推出了async函数，操作异步真的是超级简单。我觉得我们在实际项目中使用generator的机会非常少，即使使用，一般也会依赖co这样的库来方便的使用generator。但是我却想研究一下generator，所以写了一个generator不用手动的调用next函数，而是自动的调用。 generator手动next代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var p1 = function() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(1); &#125;, 2000); &#125;); &#125; var p2 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+2); &#125;, 2000); &#125;); &#125; var p3 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+3); &#125;, 1500); &#125;); &#125; var p1callback = function(res) &#123; console.log(&apos;第1个yield的callback啊-&gt;&apos;, res); &#125; var p2callback = function(res) &#123; console.log(&apos;第2个yield的callback啊-&gt;&apos;, res); &#125; var p3callback = function(res) &#123; console.log(&apos;第3个yield的callback啊-&gt;&apos;, res); &#125; function *gen() &#123; var val_1 = yield p1(); var val_2 = yield p2(val_1); var val_3 = yield p3(val_2); &#125; var g = gen(); window.gObj = null; window.gObj_index = 0; gObj = g.next(); gObj.value.then(function(res) &#123; console.log(&apos;第1个yield的callback啊-&gt;&apos;, res); gObj = g.next(res); gObj.value.then(function(res) &#123; console.log(&apos;第2个yield的callback啊-&gt;&apos;, res); gObj = g.next(res); gObj.value.then(function(res) &#123; console.log(&apos;第3个yield的callback啊-&gt;&apos;, res); &#125;); &#125;); &#125;); 上面的代码，需要在generator函数里手动定义yield的表达式，之后在执行的时候需要手动的调用next函数，但是可以看出来，还是有嵌套的情况。 generator自动运行代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// p1,p2,p3是3个Promise的执行函数 var p1 = function() &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(1); &#125;, 2000); &#125;); &#125; var p2 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+2); &#125;, 2000); &#125;); &#125; var p3 = function(val) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(val+3); &#125;, 1500); &#125;); &#125; // p1callback,p2callback,p3callback对应着p1,p2,p3的回调 var p1callback = function(res) &#123; console.log(&apos;第1个yield的callback啊-&gt;&apos;, res); &#125; var p2callback = function(res) &#123; console.log(&apos;第2个yield的callback啊-&gt;&apos;, res); &#125; var p3callback = function(res) &#123; console.log(&apos;第3个yield的callback啊-&gt;&apos;, res); &#125; /** * @desc generator的生成函数 * @param &#123; Array &#125; Promise的函数数组 * @retuen &#123; Function &#125; generator函数 */ function gen(arr) &#123; var valArr = []; return function *() &#123; for(var i=0; i&lt;arr.length; i++) &#123; valArr[i] = yield arr[i](valArr[i-1]); &#125; &#125; &#125; /** * @desc 自动执行generator的next()的函数 * @param &#123; Function &#125; gen函数 * @param &#123; Array &#125; Promise函数对应的回调函数数组 * @param &#123; Any &#125; 向generator的next中传入的值 */ function co(gen, arr, res) &#123; var g = gen(); var gObj = null; var gObj_index = 0; function innerCo(g, arr, res) &#123; gObj = g.next(res); if(gObj.done) return void 0; gObj.value.then(function(res) &#123; arr[gObj_index++](res); if(!gObj.done) &#123; innerCo(g, arr, res); &#125; &#125;); &#125; innerCo(g, arr, 0); &#125; // 执行co函数 co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0); 可以看出来，最后只需要co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);这样一行代码，省去了定义yield，省去了调用next。 总结 首先，我并没有去参考co这样的库的使用方法，如何使用都是自己想出来的。 目前代码只是超级简化版，我也是想验证一下我的想法而已，只有resolve的回调，并没写reject的回调。 最后，代码在这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"前端性能优化之时间切片","slug":"前端性能优化之时间切片","date":"2020-03-12T06:12:08.000Z","updated":"2020-03-12T07:00:54.136Z","comments":true,"path":"2020/03/12/前端性能优化之时间切片/","link":"","permalink":"/2020/03/12/前端性能优化之时间切片/","excerpt":"前端性能优化之时间切片","text":"前端性能优化之时间切片 前端性能优化之时间切片从用户的输入，再到显示器在视觉上给用户的输出，这一过程如果超过 100ms，那么用户会察觉到网页的卡顿，所以为了解决这个问题，每个任务不能超过 50ms，W3C 性能工作组在 LongTask 规范中也将超过 50ms 的任务定义为长任务。所以为了避免长任务，一种方案是使用 Web Worker，将长任务放在 Worker 线程中执行，缺点是无法访问 DOM，而另一种方案是使用时间切片。 什么是时间切片时间切片的核心思想是：如果任务不能在 50 毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过 50ms 的小任务分散在宏任务队列中执行。上图可以看到主线程中有一个长任务，这个任务会阻塞主线程。使用时间切片将它切割成很多个小任务后，如下图所示。可以看到现在的主线程有很多密密麻麻的小任务，我们将它放大后如下图所示。可以看到每个小任务中间是有空隙的，代表着任务执行了一小段时间后，将让出主线程的控制权，让浏览器执行其他的任务。 使用时间切片的缺点是，任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。但是为了避免卡死浏览器，这种取舍是很有必要的。 如何使用时间切片时间切片是一种概念，也可以理解为一种技术方案，它不是某个 API 的名字，也不是某个工具的名字。事实上，时间切片充分利用了“异步”，在早期，可以使用定时器来实现，例如：123456btn.onclick = function() &#123; someThing() // 执行了50毫秒 setTimeout(function() &#123; otherThing() // 执行了50毫秒 &#125;)&#125; 上面代码当按钮被点击时，本应执行 100 毫秒的任务现在被拆分成了两个 50 毫秒的任务。在实际应用中，我们可以进行一些封装，封装后的使用效果类似下面这样：123btn.onclick = ts([someThing, otherThing], function() &#123; console.log(&apos;done~&apos;)&#125;) 当然，关于ts这个函数的 API 的设计并不是本文的重点，这里想说明的是，在早期可以利用定时器来实现“时间切片”。ES6 带来了迭代器的概念，并提供了生成器 Generator 函数用来生成迭代器对象，虽然 Generator 函数最正统的用法是生成迭代器对象，但这不妨我们利用它的特性做一些其他的事情。Generator 函数提供了yield关键字，这个关键字可以让函数暂停执行。然后通过迭代器对象的next方法让函数继续执行。 对 Generator 函数不熟悉的同学，需要先学习 Generator 函数的用法。利用这个特性，我们可以设计出更方便使用的时间切片，例如：12345btn.onclick = ts(function*() &#123; someThing() // 执行了50毫秒 yield otherThing() // 执行了50毫秒&#125;) 可以看到，我们只需要使用yield这个关键字就可以将本应执行 100 毫秒的任务拆分成了两个 50 毫秒的任务。我们甚至可以将 yield 关键字放在循环里：123456btn.onclick = ts(function*() &#123; while (true) &#123; someThing() // 执行了50毫秒 yield &#125;&#125;) 上面代码我们写了一个死循环，但依然不会阻塞主线程，浏览器也不会卡死。 基于生成器的 ts 实现原理通过前面的例子，我们会发现基于 Generator 的时间切片非常好用，但其实 ts 函数的实现原理非常简单，一个最简单的 ts 函数只需要九行代码。123456789function ts(gen) &#123; if (typeof gen === &apos;function&apos;) gen = gen() if (!gen || typeof gen.next !== &apos;function&apos;) return return function next() &#123; const res = gen.next() if (res.done) return setTimeout(next) &#125;&#125; 代码虽然全部只有 9 行，关键代码只有 3、4 行，但这几行代码充分利用了事件循环机制以及 Generator 函数的特性。 创造出这样的代码我还是很开心的。 上面代码核心思想是：通过yield关键字可以将任务暂停执行，从而让出主线程的控制权；通过定时器可以将“未完成的任务”重新放在任务队列中继续执行。 避免把任务分解的过于零碎使用yield来切割任务非常方便，但如果切割的粒度特别细，反而效率不高。假设我们的任务执行100ms，最好的方式是切割成两个执行50ms的任务，而不是切割成 100 个执行1ms的任务。假设被切割的任务之间的间隔为4ms，那么切割成 100 个执行1ms的任务的总执行时间为：1(1 + 4) * 100 = 500ms 如果切割成两个执行时间为50ms的任务，那么总执行时间为：1(50 + 4) * 2 = 108ms 可以看到，在不影响用户体验的情况下，下面的总执行时间要比前面的少了 4.6 倍。保证切割的任务刚好接近50ms，可以在用户使用yield时自行评估，也可以在ts函数中根据任务的执行时间判断是否应该一次性执行多个任务。我们将ts函数稍微改进一下：1234567891011121314function ts(gen) &#123; if (typeof gen === &apos;function&apos;) gen = gen() if (!gen || typeof gen.next !== &apos;function&apos;) return return function next() &#123; const start = performance.now() let res = null do &#123; res = gen.next() &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 25) if (res.done) return setTimeout(next) &#125;&#125; 现在我们测试下：12345678ts(function*() &#123; const start = performance.now() while (performance.now() - start &lt; 1000) &#123; console.log(11) yield &#125; console.log(&apos;done!&apos;)&#125;)() 这段代码在之前的版本中，在我的电脑上可以打印出 215 次 11，在后面的版本中可以打印出 6300 次 11，说明在总时间相同的情况下，可以执行更多的任务。再看另一个例子：1234567ts(function*() &#123; for (let i = 0; i &lt; 10000; i++) &#123; console.log(11) yield &#125; console.log(&apos;done!&apos;)&#125;)() 在我的电脑上，这段代码在之前的版本中，被切割成一万个小任务，总执行时间为 46秒，在之后的版本中，被切割成 52 个小任务，总执行时间为 1.5秒。 总结以上代码出自于网络，这里感谢作者的付出，同时贴出作者的原创地址:《让你的网页更丝滑》","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"手写mockjs","slug":"手写mockjs","date":"2020-03-10T03:32:31.000Z","updated":"2020-03-10T05:43:36.531Z","comments":true,"path":"2020/03/10/手写mockjs/","link":"","permalink":"/2020/03/10/手写mockjs/","excerpt":"简单的写一个mockjs","text":"简单的写一个mockjs 手写mockjs在我们前端的开发中，mock数据是必须走的一环，我们可以完全脱离后端接口，等我们前端开发好了之后，再跟后台接口的无缝对接。其实mock数据的方式有很多，比如写一些静态text文档，用nodejs写一个后台服务，都可以满足mock数据的需求。但是，最方便的莫过于使用mockjs工具库了，他可以自动的拦截ajax请求，返回配置好的mock数据。我第一次这个库大概是2016年，感觉很方便，后来也想过它的实现原理是什么，不过当时没有想出来。最近在使用vue的ant pro时候，里面就使用了mockjs，于是准备自己写一个mockjs。我并没有看mockjs的源码，不知道它是怎么实现的，我的想法是既然它可以拦截ajax的请求，那么肯定对原生的XMLHttpRequest做了什么处理，于是乎，我准备覆盖掉原生的XMLHttpRequest对象，这样使用ajax的时候new出来的对象是我自己写的构造函数，不就可以满足拦截ajax请求的目的了吗。我只是实现了拦截ajax的初级功能，并没有深入，点到为止。mockjs代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849;// 将原生的XMLHttpRequest缓存起来window.XMLHttpRequestMock = window.XMLHttpRequest;// mock对象，用来存储ajax的path和返回的数据window.mock = &#123; urlData: &#123;&#125;, setPath: function(path, data) &#123; this.urlData[path] = data; &#125; &#125;// 覆盖原生XMLHttpRequest的构造函数function XmlMock() &#123; this.type = null; this.url = null; this.onreadystatechange = null;&#125;// open方法XmlMock.prototype.open = function(type, url) &#123; this.type = type; this.url = url; this.readyState = 4; this.status = 200&#125;// send方法，这里会判断，如果请求的path在mock.urlData中则返回设置好据的数，// 如果不在，则利用原生的XMLHttpRequest来进行ajax网络请求XmlMock.prototype.send = function(params) &#123; var path = &apos;&apos;; var _this = this; for(var key in mock.urlData) &#123; if((this.url).indexOf(key)&gt;-1) &#123; path = key; &#125; &#125; if(path) &#123; this.responseText = mock.urlData[path]; this.onreadystatechange(this); &#125;else &#123; var xhr = new XMLHttpRequestMock(); xhr.open(&apos;get&apos;, this.url, false); xhr.onreadystatechange = function() &#123; if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123; _this.responseText = xhr.responseText; _this.onreadystatechange(_this); &#125; &#125; xhr.send(); &#125;&#125;window.XMLHttpRequest = XmlMock; html使用代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script src=&quot;./mock.js&quot;&gt;&lt;/script&gt;&lt;script&gt; mock.setPath(&apos;get/小明&apos;, &#123;name: &apos;小明&apos;&#125;); mock.setPath(&apos;get/小红&apos;, &#123;name: &apos;小红&apos;&#125;); fetchData(&apos;http://jinux.top/get/小明&apos;, function(res) &#123; console.log(&apos;小明mock数据-&gt;&apos;, res); &#125;); fetchData(&apos;http://jinux.top/get/小红&apos;, function(res) &#123; console.log(&apos;小红mock数据-&gt;&apos;, res); &#125;); // 测试真实的ajax数据，用的实际百度的一个链接 var testUrl = &apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/home/js/nu_instant_search_baaa58d.js&apos;; fetchData(testUrl, function(res) &#123; console.log(&apos;百度的真是数据-&gt;&apos;, res); &#125;); // 封装的ajax请求方法 function fetchData(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, url, false); xhr.onreadystatechange = function() &#123; if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123; callback(xhr.responseText); &#125; &#125; xhr.send(); &#125;&lt;/script&gt;&lt;/html&gt; 最后，附上代码，点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"},{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"wireshark抓包工具","slug":"wireshark抓包工具","date":"2020-03-09T07:18:21.000Z","updated":"2020-03-09T08:11:46.624Z","comments":true,"path":"2020/03/09/wireshark抓包工具/","link":"","permalink":"/2020/03/09/wireshark抓包工具/","excerpt":"wireshark是一款非常厉害的网络抓包工具","text":"wireshark是一款非常厉害的网络抓包工具 wireshark抓包工具作为一个前端开发，讨论网络抓包有点不务正业，但是知道点还是有好处的。我平时用到的抓包工具有wireshark和charles，charles使用起来简单些，抓取http请求比较直观，wireshark的功能就强大得多，各种网络协议都可以解析，具体的使用细节就不说了，简单的说一下tcp协议的三次握手和四次挥手在wireshark中被抓取的数据。首先看一下tcp的三次握手和四次挥手图解过程1.三次握手：2.四次挥手：3.最后，wireshark抓取的数据：可以看到，前3个tcp是握手过程，最后4个tcp是挥手过程，中间的TLS协议是加密协议，因为我抓取的是https协议，所以会有加密协议。本想再贴一个http协议的抓取截屏，抓了几次太乱了，还有好多失败的包，不贴了，大同小异，大概了解过程就行了，有精力的话，继续深入研究。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"javascript严格模式","slug":"javascript严格模式","date":"2020-02-28T07:05:50.000Z","updated":"2020-03-01T08:45:34.425Z","comments":true,"path":"2020/02/28/javascript严格模式/","link":"","permalink":"/2020/02/28/javascript严格模式/","excerpt":"js的严格模式和普通模式的区别","text":"js的严格模式和普通模式的区别 javascript严格模式随着javascript的不断发展，严格模式在开发中是必须使用的，他有什么好处呢？严格模式消除了一些不确定的行为，并且对某些不安全的操作抛出异常。它有助于解析引擎，优化代码，提高执行速度，也为以后新标准的制定留出余地。下面将对严格模式做一个详细的介绍。 1.启用严格模式要使一个javascript文件运行于严格模式，只需要在文件顶部添加如下代码：1&quot;use strict&quot;; 或者1&apos;use strict&apos;; 这行代码是一个编译指示，用以告知解析引擎以严格模式解析脚本。严格模式可以用于整个脚本或单个函数。在用于脚本文件时，”use strict”需放在所有其它语句前面。123// whole-script strict mode syntax&quot;use strict&quot;;var v = &quot;Hi! I&apos;m a strict mode script!&quot;; 而用于函数时，需方在函数内第一行。1234567891011function strict() &#123; // Function-level strict mode syntax &apos;use strict&apos;; function nested() &#123; return &quot;And so am I!&quot;; &#125; return &quot;Hi! I&apos;m a strict mode function@ &quot; + nested();&#125;function notStrict() &#123; return &quot;I&apos;m not strict.&quot;;&#125; 2.严格模式带来的变化在语法和行为这两方面，严格模式都做了一些改变。这些变化主要分为以下几类。 对错误抛出异常，而不是静默地忽略； 简化变量的使用，去掉引擎难以优化的语法功能； 简化eval和arguments的使用； 增加安全特性； 为javascript迎接新标准做准备； 1)对错误抛出异常，而不是静默的忽略。严格模式将过去那些能够被静默忽略的错误变成异常抛出，因为这类错误代表着代码目的的矛盾。不一致的代码也许在当时不会产生什么不良后果，但未来可能会引起严重问题。严格模式不会容忍这些错误，使得开发者能够立即发现并且解决。 (1)在正常模式下，对一个没有声明的变量赋值，会自动作用到全局对象上（node的global对象，浏览器的window对象）。严格模式禁止这种做法，以避免意外地修改全局对象。12&quot;use strict&quot;mistypedVaraible = 17; // ReferenceError 上面的代码将会抛出类型为ReferenceError的异常 (2)在正常模式下，引擎会默认忽略对NaN赋值的语句，但在严格模式下，引擎会以抛异常的方式，立即向开发者反馈错误。类似的还有给一个指定为不可写的属性赋值，对只有取值函数getter的属性赋值，给一个不可扩展的对象增加属性。123456789101112131415161718192021&quot;use strict&quot;// Assignment to NaNNaN = &apos;a&apos;; // TypeError: Cannot assign to read noly property &apos;NaN&apos; of #&lt;Object&gt;// Assignment to a non-writable propertyvar obj1 = &#123;&#125;;Object.defineProperty(obj1, &quot;x&quot;, &#123; value: 42, writable: false&#125;);obj1.x = 9; // throws a TypeError// Assignment to a getter-only propertyvar obj2 = &#123; get x() &#123; return 18; &#125;&#125;;obj2.x = 5; // throws a TypeError// Assignment to a new property on a non-extensible objectvar fixed = &#123;&#125;;Object.preventExtensions(fixed);fixed.newProp = &quot;ohai&quot;; // throws a TypeError (3)严格模式禁止删除一个声明为不可删除的属性。12&quot;use strict&quot;;delete Object.prototype; // throws a TypeError (4)严格模式禁止声明重名属性。12345&quot;use strict&quot;;var o = &#123; p: 1, p: 2&#125;; // !!! syntax error (5)严格模式规定，函数的参数名必须唯一，否则抛出语法错误。在正常模式下，相同名称的参数，位置最靠后的会把前面的隐藏，但所有参数仍然可以借由arguments[i]访问，因此这种隐藏的意义不大，很可能写错了。1234function sum(a, a, c) &#123; // syntax error &quot;use strict&quot;; return a + b + c; // wrong if this code ran&#125; (6)八进制数的写法。ECMAScript 5 标准下的严格模式禁止八进制数，但在ECMAScript 6标准下，八进制数前面需要加0o。Node支持前面加0o的八进制数，例如：123456789&quot;use strict&quot;;// Rightvar a = 0o10; // ES6: Octalconsole.log(a);// 以下代码异常// SyntaxErrorvar sum = 015 + // syntax error 197 + 142; (7)严格模式禁止为基本数据类型添加属性，以下操作非法。123456(function() &#123; &quot;use strict&quot;; false.true = &quot;&quot;; // TypeError (14).sailing = &quot;home&quot;; // TypeError &quot;with&quot;.you = &quot;far away&quot;; // TypeError&#125;)(); 2)简化变量的使用，去掉引擎难以优化的语法功能。 (1)严格模式禁止使用with。with的问题在于，其语句内部的变量名只有在运行的时候才能够被决定，这使得引擎在编译阶段难以生成高效的代码。因为with代码块中的名称即有可能代表语句内部的变量，也有可能是with表达式中的对象属性，还有可能位于代码块外，甚至是全局对象的属性。12345&quot;use strict&quot;;var x = 18;with(obj) &#123; // syntax error x;&#125; (2)严格模式下，eval有单独的作用域，不能够使用eval语句在它之外创建变量。正常模式下，语句x;\")```会为它所在的运行环境声明一个变量x，在严格模式下，x只在eval语句的内部有效。12345```var x = 18;var evalX = eval(&quot;&apos;use strict&apos;; var x = 42; x&quot;);console.assert(x === 18);console.assert(evalX === 42); (3)严格模式禁止删除变量。1234&quot;use strict&quot;;var x;delete x; // syntax erroreval(&quot;var y; delete y;&quot;); // syntax error 3)简化eval和arguments的使用。严格模式将eval和arguments的一些怪异和奇特的用法做了限制，并倾向于将eval和arguments当作关键字处理。 (1)严格模式不允许对eval和arguments赋值。以下语句运行都会报错。1234567891011&quot;use strict&quot;;eval = 18;arguments++;++eval;var obj = &#123; set p(arguments) &#123; &#125; &#125;;var eval;try &#123; &#125; catch(arguments) &#123; &#125;function x(eval) &#123; &#125;function arguments() &#123; &#125;var y = function eval() &#123; &#125;;var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 18;&quot;); (2)在严格模式下，修改函数参数不会影响arguments，下面的示例代码能够正常运行。12345678function f(a) &#123; &quot;use strict&quot;; a = 42; return [a, arguments[0]];&#125;var pair = f(18);console.assert(pair[0] === 42);console.assert(pair[1] === 18); (3)arguments.callee不能再使用了。正常模式下，arguments.callee返回正在执行的函数本身的引用。在严格模式下，这种用法被禁止。12345&quot;use strict&quot;var f = function() &#123; return arguments.callee;&#125;f(); // throws a TypeError; 4)增加安全特性。在严格模式下，写出安全的代码变得更容易，引擎不会越俎代庖，除非使用者有意地这样做。 (1)在严格模式下，函数的上下文对象this可以是简单的值，并且避免了对全局对象的引用。在正常模式下，this只是一个对象，例如下面的代码：1234function() &#123; console.log(this);&#125;f.call(true); 运行结果为[Boolean: true]，引擎会自动地将简单类型打包为对应的对象。单严格模式不会做这样的转换。12345&quot;use strict&quot;;function f(a) &#123; console.log(this);&#125;f.call(true); 运行结果为true。正常模式下，如果不指定this对象，或者指定为undefined或null，则this引用的是全局对象。1234function f(a) &#123; console.log(this);&#125;f.call(null); 上面的代码打印出全局的global对象。但在严格模式下，除非使用call或apply明确指定this为global对象，否则this为null或者undefined。123456&quot;use strict&quot;;function f(a) &#123; console.log(this);&#125;f.call(null);f(); 结果为：12nullundefined (2)严格模式禁止访问函数对象属性caller和arguments，这意味着不再可能遍历调用堆栈了。123456789101112&quot;use strict&quot;;function outer() &#123; inner();&#125;function inner() &#123; console.log(arguments.callee.caller); // TypeError: &apos;caller&apos;, &apos;callee&apos;, and // &apos;arguments&apos; properties may not be accessed // on strict mode functions or the arguments // objects for calls to them&#125;outer(); 5)保留关键字。严格模式将implements,interface,let,package,private,protected,public,static和yield作为保留字，用户代码不能以这些名称命名变量。123456789101112function package(protected) &#123; // SyntaxError &quot;use strict&quot;; var implements; // SyntaxError interface; // SyntaxError while(true) &#123; break interface; // SyntaxError &#125; function private() &#123; &#125; // SyntaxError&#125;function fun(static) &#123; // SyntaxError &quot;use strict&quot;;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"前端异常处理","slug":"前端异常处理","date":"2020-02-27T06:23:25.000Z","updated":"2020-02-27T14:52:05.707Z","comments":true,"path":"2020/02/27/前端异常处理/","link":"","permalink":"/2020/02/27/前端异常处理/","excerpt":"异常在前端的处理","text":"异常在前端的处理 前端异常处理简介异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。 增强用户体验； 远程定位问题； 未雨绸缪，及早发现问题； 无法复线问题，尤其是移动端，机型，系统都是问题； 完善的前端方案，前端监控系统； 对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。 对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下： JS 语法错误、代码异常 AJAX 请求异常 静态资源加载异常 Promise 异常 Iframe 异常 跨域 Script error 崩溃和卡顿 下面我会针对每种具体情况来说明如何处理这些异常。 异常分类try-catchtry-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。1.同步运行时错误123456try &#123; let name = &apos;jartto&apos;; console.log(nam);&#125; catch(e) &#123; console.log(&apos;捕获到异常：&apos;,e);&#125; 控制台输出12捕获到异常： ReferenceError: nam is not defined at index.html:16 2.不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：123456try &#123; let name = &apos;jartto; console.log(nam);&#125; catch(e) &#123; console.log(&apos;捕获到异常：&apos;,e);&#125; 控制台输出12Uncaught SyntaxError: Invalid or unexpected token不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。 3.异步错误1234567try &#123; setTimeout(() =&gt; &#123; console.log(nam); &#125;, 1000)&#125; catch(e) &#123; console.log(&apos;捕获到异常：&apos;,e);&#125; 控制台输出12Uncaught ReferenceError: nam is not defined at index.html:31 可以看出，try-catch是捕获不到异步错误的，下面会介绍异步的错误如何捕获。 window.onerror当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。1.同步错误和异步错误都可以捕获到123456789// message：错误信息（字符串）。// source：发生错误的脚本URL（字符串）// lineno：发生错误的行号（数字）// colno：发生错误的列号（数字）// error：Error对象（对象）window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;); return true; // 这里返回true，控制台就不会输出被捕获的那个错误自己抛出的异常提示，见下面截图。&#125; 2.再试试语法错误1234window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);&#125;let name = &apos;Jartto 控制台输出1Uncaught SyntaxError: Invalid or unexpected token 语法错误还是不能捕获3.我们试试网络请求异常的情况1234567&lt;script&gt;window.onerror = function(message, source, lineno, colno, error) &#123; console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;); return true;&#125;&lt;/script&gt;&lt;img src=&quot;./jartto.png&quot;&gt; 不论是静态资源异常，或者接口异常，错误都无法捕获到。补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx，上面已经有提到过。需要注意： onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误； onerror 无法捕获语法错误；到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。window.addEventListener当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window，所以我们需要在每一个元素节点上监听error事件123456var nImgs = document.querySelectorAll(&apos;img&apos;); nImgs.forEach(item=&gt; &#123; item.addEventListener(&apos;error&apos;, function(ev) &#123; console.log(&apos;捕获到异常：&apos;, ev); &#125;, false); &#125;); 上面是来捕获页面中所有的img元素标签出现的错误。控制台输出1捕获到异常： Event &#123;isTrusted: true, type: &quot;error&quot;, target: img#img, currentTarget: img#img, eventPhase: 2, …&#125; 由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。需要注意： 不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。 需要注意避免 addEventListener 重复监听。 Promise Catch在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：1234567891011window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123; e.preventDefault() console.log(&apos;捕获到异常：&apos;, e); return true;&#125;);var pro = new Promise(function(resolve, reject) &#123; reject(&apos;错误&apos;);&#125;);// pro.catch(err=&gt; &#123;// console.log(&apos;promise catch 捕获：&apos; + err);// &#125;); 可以看到，如果忘记了catch的话，全局也可以捕获到Promise的错误。控制台输出1捕获到异常： PromiseRejectionEvent &#123;isTrusted: true, promise: Promise, reason: &quot;错误&quot;, type: &quot;unhandledrejection&quot;, target: Window, …&#125; 所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。补充一点：如果去掉控制台的异常显示，需要加上：1event.preventDefault(); iframe 异常对于 iframe 的异常捕获，我们还得借力 window.onerror1234567&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;script&gt; window.frames[0].onerror = function (message, source, lineno, colno, error) &#123; console.log(&apos;捕获到 iframe 异常：&apos;,&#123;message, source, lineno, colno, error&#125;); return true; &#125;;&lt;/script&gt; Script error一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。1&lt;script src=&quot;http://jartto.wang/main.js&quot; crossorigin&gt;&lt;/script&gt; 或者动态去添加 js 脚本：1234const script = document.createElement(&apos;script&apos;);script.crossOrigin = &apos;anonymous&apos;;script.src = url;document.body.appendChild(script); 特别注意，服务器端需要设置：Access-Control-Allow-Origin此外，我们也可以试试这个-解决 Script Error 的另类思路：123456789101112const originAddEventListener = EventTarget.prototype.addEventListener;EventTarget.prototype.addEventListener = function (type, listener, options) &#123; const wrappedListener = function (...args) &#123; try &#123; return listener.apply(this, args); &#125; catch (err) &#123; throw err; &#125; &#125; return originAddEventListener.call(this, type, wrappedListener, options);&#125; 简单解释一下：改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：123456789101112131415161718(() =&gt; &#123; const originAddEventListener = EventTarget.prototype.addEventListener; EventTarget.prototype.addEventListener = function (type, listener, options) &#123;+ // 捕获添加事件时的堆栈+ const addStack = new Error(`Event ($&#123;type&#125;)`).stack; const wrappedListener = function (...args) &#123; try &#123; return listener.apply(this, args); &#125; catch (err) &#123;+ // 异常发生时，扩展堆栈+ err.stack += &apos;\\n&apos; + addStack; throw err; &#125; &#125; return originAddEventListener.call(this, type, wrappedListener, options); &#125; &#125;)(); 崩溃和卡顿卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。123456789101112131415161718window.addEventListener(&apos;load&apos;, function () &#123; sessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;); setInterval(function () &#123; sessionStorage.setItem(&apos;time_before_crash&apos;, new Date().toString()); &#125;, 1000);&#125;);window.addEventListener(&apos;beforeunload&apos;, function () &#123; sessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;);&#125;);if(sessionStorage.getItem(&apos;good_exit&apos;) &amp;&amp; sessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) &#123; /* insert crash logging code here */ alert(&apos;Hey, welcome back from your crash, looks like you crashed on: &apos; + sessionStorage.getItem(&apos;time_before_crash&apos;));&#125; 2.基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。 VUE errorHandler123456Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error(&apos;通过vue errorHandler捕获的错误&apos;); console.error(err); console.error(vm); console.error(info);&#125; React 异常捕获React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息123componentDidCatch(error, info) &#123; console.log(error, info);&#125; 除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。需要注意的是：error boundaries 并不会捕捉下面这些错误。 事件处理器 异步代码 服务端的渲染代码 在 error boundaries 区域内的错误我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 然后我们像使用普通组件那样使用它123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！ 错误上报通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。动态创建 img 标签的形式1234function report(error) &#123; let reportUrl = &apos;http://jartto.wang/report&apos;; new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;&#125; 收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力123456Reporter.send = function(data) &#123; // 只采集 30% if(Math.random() &lt; 0.3) &#123; send(data) // 上报错误信息 &#125;&#125; 采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。 总结回到我们开头提出的那个问题，如何优雅的处理异常呢？ 可疑区域增加 Try-Catch 全局监控 JS 异常 window.onerror 全局监控静态资源异常 window.addEventListener 捕获没有 Catch 的 Promise 异常：unhandledrejection VUE errorHandler 和 React componentDidCatch 监控网页崩溃：window 对象的 load 和 beforeunload 跨域 crossOrigin 解决 其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。 这篇文章部分代码点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"html元素节点的attribute&property","slug":"html元素节点的attribute-property","date":"2020-02-24T03:06:49.000Z","updated":"2020-02-24T04:25:00.112Z","comments":true,"path":"2020/02/24/html元素节点的attribute-property/","link":"","permalink":"/2020/02/24/html元素节点的attribute-property/","excerpt":"元素节点attr和prop区别","text":"元素节点attr和prop区别 html元素节点的attribute&amp;property元素节点的attrbute和property大家可能都是用过，但是也是容易被大家忽略它俩到底区别在哪里。想当初在使用jquery时,$(‘ele’).attr(),$(‘’ele).prop(),这两个方法我也是没有深入研究，再后来使用angular的时候有看到attribute和property的区别，今天我好好总结一下。 attribute和property如何使用123456789// 这样一个input节点&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;// 首先，使用attribute来操作var nEle = document.getElementById(&apos;inp&apos;);nEle.setAttribute(&apos;class&apos;, &apos;wrap&apos;);nEle.getAttribute(&apos;class&apos;);// 使用property来操作nEle.index = 1;nEle.type = &apos;text&apos;; 其实，attribute是在这个元素节点上设置属性，而property是在这个元素节点的dom对象上设置属性。12345// 想看看元素节点的attribute属性nEle.attributes// 想看看元素节点的property属性console.dir(nEle);// 打印出来的内容可以看到attributes也在其中 attribute和property实际区别1234567&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;// 还是这个元素节点// 页面加载时如果使用getAttribute(&apos;value&apos;)是可以获取&apos;val&apos;值的，当然，nEle.value也可以获取到 &apos;val&apos;。// 但是，如果现在你在input框中，把&apos;val&apos;改成&apos;val123&apos;// 你再使用getAttribute(&apos;value&apos;)方式获取到的还是&apos;val&apos;,而使用nEle.value可以获取到最新值&apos;val123&apos;// 从这样一个简单的操作，可以理解为，attribute时html元素上的，而property是html元素对象上的。 其实，两者区别还有很多，这里不一一列举，一个小例子知道其区别就可以了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"http请求头的安全策略","slug":"http请求头的安全策略","date":"2020-02-18T07:51:36.000Z","updated":"2020-02-18T08:56:33.335Z","comments":true,"path":"2020/02/18/http请求头的安全策略/","link":"","permalink":"/2020/02/18/http请求头的安全策略/","excerpt":"http请求头中相关安全的头字段","text":"http请求头中相关安全的头字段 http请求头的安全策略我们的项目在经过开发，测试之后，还得经过安全小组的安全漏斗扫描，经常会暴漏一些返回头缺少安全字段的漏洞，今天我稍加整理常用的几个。如果想了解更多的请求头和响应头的字段信息，可以看本站另一篇文章，这里 1.X-Frame-Options如果网站可以嵌入到IFRAME元素中，则攻击者可以在社交场合设计一种情况，即受害者被指向攻击者控制的网站，该网站构成目标网站的框架。然后攻击者可以操纵受害者在目标网站上不知不觉地执行操作。即使有跨站点请求伪造保护，这种攻击也是可能的，并且被称为“clickjacking”，有关更多信息，请参阅。为了避免这种情况，创建了“X-Frame-Options”标题。此标题允许网站所有者决定允许哪些网站构建其网站。通常的建议是将此标头设置为“SAMEORIGIN”，它只允许属于同源策略的资源构成受保护资源的框架，或者设置为“DENY”，它拒绝任何资源（本地或远程）尝试框架也提供“X-Frame-Options”标头的资源。如下所示：X-Frame-Options：SAMEORIGIN请注意，“X-Frame-Options”标题已被弃用，将由内容安全策略中的Frame-Options指令替换，该指令仍处于活动开发阶段。但是，“X-Frame-Options”标题目前具有更广泛的支持，因此仍应实施安全措施。说白了呢，就是让你的网站禁止被嵌套。demo:12345&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt; &lt;/customHeaders&gt;&lt;/httpProtocol&gt; 2.Content-Security-Policy内容安全策略（CSP）旨在允许Web应用程序的所有者通知客户端浏览器有关应用程序的预期行为（包括内容源，脚本源，插件类型和其他远程资源），这允许浏览器更多智能地执行安全约束。虽然CSP本质上是复杂的，如果没有适当部署它可能会变得混乱，一个应用良好的CSP可以大大降低利用大多数形式的跨站点脚本攻击的机会。需要整个帖子来深入了解CSP允许的功能和不同设置，因此建议进一步阅读。以下是Mozilla开发者网络对CSP的精彩介绍性帖子下面的简要示例显示了如何使用CSP指定您的网站希望从任何URI加载图像，从受信任的媒体提供商（包括内容分发网络）列表中插入插件内容，以及仅从您控制的服务器加载脚本：1Content-Security-Policy：default-src&apos;self&apos;; img-src *; object-src media1.example.com media2.example.com * .cdn.example.com; script-src trustedscripts.example.com 请注意，使用CSP的主要问题涉及策略错误配置（即使用“不安全内联”），或使用过于宽松的策略，因此在实施CSP时应特别注意。这个呢，是将你引入的一切，加一个限制，这样如果别人想通过一些手段在你的网站加一些不好的东西，我们就可以有效地防止了。demo:12345&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=&quot;Content-Security-Policy&quot; value=&quot;script-src &apos;unsafe-inline&apos; http://localhost:56504; object-src &apos;none&apos;; style-src &apos;unsafe-inline&apos; http://localhost:56504;&quot; /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt; 其中预设值有以下这些： none 不匹配任何东西。 self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。 unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。 unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。 3.X-Content-Type-Options互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：”text/html”代表html文档，”image/png”是PNG图片，”text/css”是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。例如，我们即使给一个html文档指定Content-Type为”text/plain”，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：1X-Content-Type-Options: nosniff demo:12// phpheader(&quot;X-Content-Type-Options:nosniff&quot;); 4.X-XSS-Protection顾名思义，这个响应头是用来防范XSS的。最早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置： 0：禁用XSS保护； 1：启用XSS保护； 1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。demo:12// phpheader(&quot;X-XSS-Protection: 1&quot;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"图片裁剪插件","slug":"图片裁剪插件","date":"2020-02-16T07:51:13.000Z","updated":"2020-02-17T01:33:58.172Z","comments":true,"path":"2020/02/16/图片裁剪插件/","link":"","permalink":"/2020/02/16/图片裁剪插件/","excerpt":"一个图片裁剪插件，并穿给后端","text":"一个图片裁剪插件，并穿给后端 图片裁剪插件我们在日常开发中，裁剪图片并上传，是经常出现的需求。前几天，就有一个这样的需求，但是要求比较特殊，于是自己写了一个图片裁剪插件，因为自己写的改起来比较灵活。 其实裁剪图片无非就是: 文件选择图片，利用FileReader将文件格式的图片转成base64格式。 把这个base64格式显示在页面上，作为原图。 可以在原图的上面弄一个剪裁的方框，可以用鼠标来控制大小并移动，我觉得这里是最难的，需要很强的逻辑能力。 再利用canvas，以原图为基准，进行画图的裁剪，最后通过canvas方法得到裁剪后的base64格式图片。 最后把base64格式的图片转成Blob对象，利用ajax传送给后端。 关键方法选择图片文件转base6412345678function file2base64(imgFile, callBack) &#123; var fr = new FileReader(); fr.onload = function() &#123; // fr.result就是base64格式数据 callBack(fr.result); &#125; fr.readAsDataURL(imgFile);&#125; 将base64图片转化blob123456789101112function base64url2blob(base64url) &#123; var binaryString = atob(base64url.split(&apos;,&apos;)[1]), mimeType = base64url.split(&apos;,&apos;)[0].match(/:(.*?);/)[1], length = binaryString.length, u8arr = new Uint8Array(length), blob; while(length--) &#123; u8arr[length] = binaryString.charCodeAt(length); &#125; blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;); return blob;&#125; 将图片转化为blob1234567891011121314function img2blob(nImg, compressVal) &#123; // 获取图片原始宽高 var cloneImg = nImg.cloneNode(true); var nCanvas = document.createElement(&apos;canvas&apos;); nCanvas.style.display = &apos;none&apos;; document.body.appendChild(nCanvas); nCanvas.width = cloneImg.width; nCanvas.height = cloneImg.height; var ctx = nCanvas.getContext(&quot;2d&quot;); ctx.drawImage(nImg,0,0,cloneImg.width,cloneImg.height); var base64Data = nCanvas.toDataURL(&quot;image/jpeg&quot;, compressVal); var blob = this.base64url2blob(base64Data); return blob;&#125; 以上就是几个重要的格式转换方法。最后，贴出源码demo，里边包含后端接收的nodejs代码。点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"手写一个自己的webpack","slug":"手写一个自己的webpack","date":"2020-01-31T07:51:30.000Z","updated":"2020-01-31T09:24:16.564Z","comments":true,"path":"2020/01/31/手写一个自己的webpack/","link":"","permalink":"/2020/01/31/手写一个自己的webpack/","excerpt":"一个超级简化版的webpack打包工具","text":"一个超级简化版的webpack打包工具 手写一个自己的webpackwebpack现在用的人非常多，我们在开发vue，react，angular的时候默认的打包工具就是webpack，作为一名前端开发者来说，webpack是现在必须掌握的技能之一。随着webpack版本的不断增加，功能和复杂度越来越高，会配置的话都得学一阵子，但是，抛开使用来说，想没想过它的原理是什么？如果自己写一个该从哪里入手呢，今天我就写一个简化版的webpack。 功能简化版的webpack，实现了它的最基础的功能，也就是模块化的引用处理，比如，main.js文件依赖了a.js文件，使用es6的语法import语法，浏览器是不支持的，需要用工具打包成浏览器支持的语法，我就实现这个最基础的功能。 babel打包文件，首先需要分析代码，比如，入口文件main.js，分析出import语句，都依赖哪些文件，再去读取这些依赖的文件，而分析js代码就需要babel这个工具库，babel工具库可以将es6代码转换成es5，es3代码，功能特别强大。 打包流程这里，依赖babel的3个工具，分别是123&quot;@babel/core&quot;: &quot;^7.8.3&quot;,&quot;@babel/parser&quot;: &quot;^7.8.3&quot;,&quot;@babel/traverse&quot;: &quot;^7.8.3&quot; parser是用来将js代码解析成ast语法书。traverse可以将ast语法书进行遍历，对相应的ast语法书节点做单独的获取或者处理。babel-core是babel的核心，可以将es6的js代码或ast语法书转化成es5代码。 步骤1用paser将es6的代码先转成ast语法树 步骤2用traverse处理ast语法书中的import节点，获取依赖文件路径，并获取依赖文件的代码，重复做步骤1，步骤2的处理。 步骤3用babel-core将获取到的文件全部转成es5语法。 步骤4最后把这些文件拼接成一个可执行的js代码，保存起来，html直接引用就可以执行了。 源码上面步骤都说了，但是还是有点抽象，下面贴出代码，一目了然。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const parser = require(&apos;@babel/parser&apos;);const traverse = require(&apos;@babel/traverse&apos;).default;const babel = require(&apos;@babel/core&apos;);let ID = 0;function createAsset(fileName) &#123; // 这个文件里所依赖的其它文件路径 let dependencies = []; const content = fs.readFileSync(fileName, &apos;utf8&apos;); // 用babel的parser来解析读取的的文件内容content,获取ast抽象语法书 const ast = parser.parse(content, &#123; sourceType: &apos;module&apos; &#125;); // 用babel的traverse功能来观察ast语法树的相应节点，进行相应的处理 traverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; // console.log(node.source.value); dependencies.push(node.source.value); &#125; &#125;); // 用babel来讲es6语法转成es5语法 const &#123; code &#125; = babel.transformFromAstSync(ast, null, &#123; presets: [&apos;@babel/preset-env&apos;] &#125;) let id = ID++; return &#123; id, fileName, dependencies, code, &#125;;&#125;function createGraph() &#123; const mainAsset = createAsset(&apos;./src/main.js&apos;); // 队列存放单个文件资源,这里利用循环队列去搜寻依赖文件，而没有使用递归方法 const queue = [ mainAsset ]; for(const asset of queue) &#123; const dirname = path.dirname(asset.fileName); asset.mapping = &#123;&#125;; asset.dependencies.forEach(relativePath =&gt; &#123; const absolutePath = path.join(dirname, relativePath); const child = createAsset(absolutePath); asset.mapping[relativePath] = child.id; queue.push(child); &#125;); &#125; return queue;&#125;// 打包生成处理后的js文件function bundle() &#123; const graph = createGraph(&apos;./src/main.js&apos;); let modules = ``; graph.forEach(mod=&gt; &#123; modules += ` $&#123;mod.id&#125;: [ function(require, module, exports) &#123; $&#123;mod.code&#125; &#125;, $&#123;JSON.stringify(mod.mapping)&#125; ], `; &#125;); const result = `(function(modules) &#123; function require(id) &#123; const fn = modules[id][0], mapping = modules[id][1]; function localRequire(relativePath) &#123; return require(mapping[relativePath]); &#125; const module = &#123; exports: &#123;&#125; &#125;; fn(localRequire, module, module.exports); return module.exports; &#125; require(0); &#125;)(&#123;$&#123;modules&#125;&#125;)`; return result;&#125;const result = bundle();fs.writeFileSync(&apos;./dist/bundle.js&apos;, result); demo地址截这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"简单的聊聊iframe","slug":"简单的聊聊iframe","date":"2020-01-19T06:11:04.000Z","updated":"2020-01-19T06:41:47.197Z","comments":true,"path":"2020/01/19/简单的聊聊iframe/","link":"","permalink":"/2020/01/19/简单的聊聊iframe/","excerpt":"iframe在html中的简单使用","text":"iframe在html中的简单使用 简单的聊聊iframe我们在前端开发中，iframe的使用场景很多，即便是vue，react时代，我还是乐此不疲的在项目中使用iframe，因为它会隔离页面彼此的环境，避免造成一些不必要的干扰。 在同域下使用iframe在同域下使用iframe,父级页面可以获取iframe页面里的信息，还可以操作iframe页面中的内容。案例在同域下没什么好说的，父页面可以随意控制子页面。 跨域下使用iframe跨域下使用iframe,父页面是不能操作子页面的，但是子页面可以操作父页面。而且，后台返回的头信息，还能够更加严格的控制iframe123res.setHeader(&apos;X-Frame-Options&apos;, &apos;DENY&apos;); // 不允许此页面被iframe加载res.setHeader(&apos;X-Frame-Options&apos;, &apos;SAMEORIGIN&apos;); // 只可以在相同域名下加载res.setHeader(&apos;X-Frame-Options&apos;, &apos;allow-from http://baidu.com/&apos;); // 允许指定的url加载iframe,但是这个属性在chrome,firefox,opera并不好使,只在edge中兼容 案例目前为止，没有找到跨域控制iframe页面内容的方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"常用数据结构的JavaScript实现","slug":"常用数据结构的JavaScript实现","date":"2019-11-28T08:12:54.000Z","updated":"2019-11-28T08:16:47.245Z","comments":true,"path":"2019/11/28/常用数据结构的JavaScript实现/","link":"","permalink":"/2019/11/28/常用数据结构的JavaScript实现/","excerpt":"一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现","text":"一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现 常用数据结构的JavaScript实现觉得这篇文章很不错，收藏下来，感谢作者。这里是连接哦","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"linux的常用操作","slug":"linux的常用操作","date":"2019-11-28T01:46:55.000Z","updated":"2020-02-04T01:52:10.250Z","comments":true,"path":"2019/11/28/linux的常用操作/","link":"","permalink":"/2019/11/28/linux的常用操作/","excerpt":"linux的一些基础常用操作","text":"linux的一些基础常用操作 linux的常用操作安装应用在linux下安装应用的方法有很多，我也尝试了好几种，最后感觉还是用yum安装方便。在使用yum安装应用的时候需要配置一下yum源，这里写出两条命令，常用的应用软件都已经有了。12curl -O http://mirrors.aliyun.com/repo/Centos-7.repocurl -O http://mirrors.aliyun.com/repo/epel-7.repo 命令新建文件夹1mkdir &lt;filename&gt; 文件的移动12// 将repo结尾的文件移动到当前目录的back文件夹下mv *.repo ./back 删除123456789101、删除文件命令rm -f 文件名将会强行删除文件，且无提示需要注意：使用rm -rf要格外注意，linux中没有回收站，慎重删除2、删除文件夹以及文件夹中的所有文件命令：rm -rf 目录名字其中：-r：向下递归删除-f：直接强行删除，且没有任何提示 查看进程1ps -ef | grep node 杀死进程1kill -9 &lt;pid&gt; 搜索一个程序所在位置12345678910whereis &lt;程序名称&gt;查找软件的安装路径-b 只查找二进制文件-m 只查找帮助文件-s 只查找源代码-u 排除指定类型文件-f 只显示文件名-B &lt;目录&gt; 在指定目录下查找二进制文件-M &lt;目录&gt; 在指定目录下查找帮助文件-S &lt;目录&gt; 在指定目录下查找源代码 查找一个文件夹所在目录1find / -name &lt;文件名&gt; 文件的上传和下载使用之前确保安装了lrzsz1yum install lrzsz 上传文件1rz 下载文件1sz &lt;filename&gt; nginx安装nginx1yum install nginx 开启nginx服务12nginx -c /etc/nginx/nginx.conf.default// 以我的nginx安装目录为例，nginx.conf.default这个文件就是nginx的主默认配置文件 压缩和解压zip安装1234// 安装zipyum install zip// 安装unzipyum install unzip 使用zip1234// 将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：zip -q -r html.zip /home/html// 如果在我们在 /home/html 目录下，可以执行以下命令：zip -q -r html.zip * 使用unzip1234// 它会默认将文件解压到当前目录 # unzip test.zip // 如果要解压到指定目录，可以加上 -d 选项# unzip test.zip -d /root/","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}]},{"title":"chrome浏览器设置可跨域","slug":"chrome浏览器设置可跨域","date":"2019-11-20T07:39:35.000Z","updated":"2019-11-20T08:02:01.960Z","comments":true,"path":"2019/11/20/chrome浏览器设置可跨域/","link":"","permalink":"/2019/11/20/chrome浏览器设置可跨域/","excerpt":"chrome浏览器设置可跨域","text":"chrome浏览器设置可跨域 chrome浏览器设置可跨域跨域方法很多种，我比较喜欢简单粗暴的修改chrome配置1.先chrome鼠标右键打开下，点击打开属性，出现下面这幅图2.将下面的这段粘贴在目标的字符串的后面，注意要隔着一个空格chrome版本49之前：–disable-web-securitychrome版本49之后：open -a Google\\ Chrome –args –disable-web-security –user-data-dir","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"css初始化","slug":"css初始化","date":"2019-10-30T08:16:54.000Z","updated":"2019-10-30T08:31:54.672Z","comments":true,"path":"2019/10/30/css初始化/","link":"","permalink":"/2019/10/30/css初始化/","excerpt":"css的初始化设计","text":"css的初始化设计 css初始化123456789101112131415161718192021222324252627282930313233343536373839404142@charset \"utf-8\";html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,\"Hiragino Sans GB\",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,\"Hiragino Sans GB\",\"微软雅黑\",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:\"\\0020\"&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, \"Microsoft Yahei\", \"Helvetica Neue\", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125;a,input&#123; -webkit-appearance: none;/*屏蔽阴影*/ -webkit-tap-highlight-color:rgba(0,0,0,0); /*ios android去除自带阴影的样式*/&#125;a, img &#123; /* 禁止长按链接与图片弹出菜单 */ -webkit-touch-callout: none;&#125;html, body &#123; /* 禁止选中文本(如无文本选中需求,此为必选项) */ -webkit-user-select: none; user-select: none;&#125;* &#123; -webkit-overflow-scrolling: touch; // ios滑动不卡顿&#125;","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"VUE自定义组件v-model使用","slug":"VUE自定义组件v-model使用","date":"2019-10-22T05:55:13.000Z","updated":"2019-10-22T06:18:00.062Z","comments":true,"path":"2019/10/22/VUE自定义组件v-model使用/","link":"","permalink":"/2019/10/22/VUE自定义组件v-model使用/","excerpt":"vue中自定义组件v-model双向数据绑定的使用","text":"vue中自定义组件v-model双向数据绑定的使用 VUE自定义组件v-model使用我们在写vue组建的时候，可以往组件里传prop，但是普通的属性都是单向数据流，要想在子组件里修改父组件里值，必须在父组件中定义一个事件，在子组件里this.$emit(&#39;事件名&#39;,&#39;...参数&#39;),但是我觉得好麻烦，要想实现数据的双向绑定还得定义子组件调用的事件方法，我们可以直接使用v-model,可以简单些。父组件代码：123456789101112131415&lt;template&gt; &lt;div&gt; &lt;Child v-model=\"val\" /&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; val: 123 &#125; &#125;, components: &#123; Child &#125;&#125; 子组件代码：123456789101112131415161718&lt;template&gt; &lt;div&gt; &#123;&#123;val&#125;&#125; &lt;div @click=\"changeVal\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; &#125; &#125;, props: ['val'], methods: &#123; changeVal () &#123; this.$emit('input', 456); // 注意这里默认是input事件哦 &#125; &#125;&#125; 是不是双向数据绑定写着会简单些。最后，看一下vue中v-model的语法糖：12&lt;input v-model=\"price\"&gt;&lt;input type=\"text\" :value=\"price\" @input=\"price=$event.target.value\"&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"前端优化之Pre技术简介","slug":"前端优化之Pre技术简介","date":"2019-10-14T05:06:31.000Z","updated":"2019-10-14T05:23:30.164Z","comments":true,"path":"2019/10/14/前端优化之Pre技术简介/","link":"","permalink":"/2019/10/14/前端优化之Pre技术简介/","excerpt":"link标签中pre技术的介绍","text":"link标签中pre技术的介绍 前端优化之Pre技术简介Pre技术：预加载技术。提供在不影响当前页面情况下，浏览器预加载资源的性能优化方案。 DNS Prefetch就是上述提到的，用于告知浏览器，尽可能预先解析指定域名的DNS。使用方式：1&lt;link rel=\"dns-prefetch\" href=\"//the-domain-to-be-prefetched.com\" /&gt; 至于兼容性，可以说是目前为止所有的Pre技术里最好的了，兼容性查看IE是从IE9开始支持DNS Prefetch的，但是，是从IE10开始支持dns-prefetch。IE9里，并不是使用dns-prefetch来定义一个DNS的预解析，而是使用prefetch。挺尴尬的，因为prefetch在w3规范里又被用到了另一个Pre技术，下面会讲到。 Preconnect预连接。和DNS Prefetch类似，但是，更进一步。它不仅要求浏览器预解析指定域名的DNS，还需要预先与服务器握手以及TLS协商（如果使用了HTTPS）。使用方式：1&lt;link rel=\"preconnect\" href=\"//the-domain-to-be-preconnect.com\" crossorigin=\"anonymous\" /&gt; 兼容性查看由于会与服务器握手，因此，就需要确定“是否跨域”。和script类似，带crossorigin属性，以告知浏览器如何处理跨域和cookie。 Prefetch上述DNS Prefetch里提到过，IE9里使用的DNS Prefetch类型名是prefetch，但是，这个类型名在规范里又被用于另外一个意图。Prefetch：预获取，在Preconnect基础上更进一步，它要求浏览器获取整个的指定资源，link[href]值指定的是某个具体资源，而不是简单的一个域名了。除了和Preconnect一样拥有rel、href和crossorigin外，还有as，可用于告知浏览器资源类型，这个类型和MIME不一样，是一个统称类型，比如：所有的图片都是as=”image”，JS的是as=”script”，HTML的是 as=”html”等，具体可以参考。使用方式：1&lt;link rel=\"prefetch\" href=\"//the-domain.com/prefetch.js\" crossorigin as=\"script\" /&gt; as属性并不是必须的，但是建议加上，以便浏览器能更好的添加请求Header来优化资源的获取。使用Prefetch，整个资源都会被加载，但是，浏览器不允许对资源预处理或执行，资源只是被提前加载，并缓存起来，以便将来使用。兼容性查看 Prerender预渲染。与Prefetch类似，浏览器会下载整个资源，但是，Prefetch不允许浏览器对资源做预处理和执行，而Prerender则会告知浏览器，下载资源（HTML）并解析/执行它，包括被解析资源的子资源，这意味着会下载该HTML中的图片、样式、脚本等等。Prerender没有as属性，它下载的是HTML，使用方式1&lt;link rel=\"preconnect\" href=\"//the-domain-to-be-preconnect.com\" /&gt; 由于不允许对当前页面产生影响，浏览器设置预渲染的页面visibilityState属性为hidden。兼容性查看建议少用这个，太耗资源。而且，查看上述兼容性，你会看到Chrome 58里又把这个功能干掉了。 Preload预加载。这是一个和Prefetch几乎一模一样的功能，但是，其加载的资源适用的场景又完全不一样。使用方式只是将上述Prefetch中的prefetch改成preload。其他的完全一样：1&lt;link rel=\"preload\" href=\"//the-domain.com/prefetch.png\" crossorigin as=\"image\" /&gt; 与Prefetch*不同之处在于： Prefetch的优先级很低，低到浏览器可以不加载 Preload的优先级很高，浏览器一定要加载 Prefetch加载的资源用于将来某个页面中（这意味着它可能压根不会被用到） Preload加载的资源用于当前页面中 所以，在使用prefetch还是preload时候，需要考虑上述的不同点，而不应该盲目使用。[Preload以前叫Subresource]兼容性查看最后，上述Pre技术，除了Preload，其他的Pre都可能“不被浏览器执行”，这不是兼容性的问题，而是，这些Pre都不是浏览器必须行为，浏览器会根据一定的策略决定是否Pre相应的资源或操作，这些策略包括：CPU、内存等的占用率。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"<script>标签的defer,async,module","slug":"script-标签的defer-async-module","date":"2019-10-14T03:15:11.000Z","updated":"2019-10-14T04:32:47.370Z","comments":true,"path":"2019/10/14/script-标签的defer-async-module/","link":"","permalink":"/2019/10/14/script-标签的defer-async-module/","excerpt":"&lt;script&gt;标签中defer,async,module的使用","text":"&lt;script&gt;标签中defer,async,module的使用 &lt;script>标签的defer,async,moduledefer&amp;async传统方法HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。12345678&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=\"application/javascript\"&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\"&gt;&lt;/script&gt; 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=”application/javascript”可以省略。默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。12&lt;script src=\"path/to/myModule.js\" defer&gt;&lt;/script&gt;&lt;script src=\"path/to/myModule.js\" async&gt;&lt;/script&gt; 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 module加载规则浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=”module”属性。1&lt;script type=\"module\" src=\"./foo.js\"&gt;&lt;/script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。浏览器对于带有type=”module”的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。123&lt;script type=\"module\" src=\"./foo.js\"&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=\"module\" src=\"./foo.js\" defer&gt;&lt;/script&gt; 如果网页有多个&lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。&lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。1&lt;script type=\"module\" src=\"./foo.js\" async&gt;&lt;/script&gt; 一旦使用了async属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。12345&lt;script type=\"module\"&gt; import utils from \"./utils.js\"; // other code&lt;/script&gt; 对于外部的模块脚本（上例是foo.js），有几点需要注意。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。下面是一个示例模块。123456import utils from 'https://example.com/js/utils.js';const x = 1;console.log(x === window.x); //falseconsole.log(this === undefined); // true 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。1const isNotModuleScript = this !== undefined;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"测试相关术语整理","slug":"测试相关术语整理","date":"2019-10-12T07:38:38.000Z","updated":"2019-10-12T07:55:59.342Z","comments":true,"path":"2019/10/12/测试相关术语整理/","link":"","permalink":"/2019/10/12/测试相关术语整理/","excerpt":"介绍一些测试的相关术语","text":"介绍一些测试的相关术语 测试相关术语整理作为一名前端开发工程师，工作中肯定会和测试同事打交道，为了不丢面子，一些测试用语还是应该知道滴。 Unit testing（单元测试），指一段代码的基本测试，其实际大小是未定的，通常是一个函数或子程序，一般由开发者执行。 Integration testing（集成测试），被测试系统的所有组件都集成在一起，找出被测试系统组件之间关系和接口中的错误。该测试一般在单元测试之后进行。 Acceptance testing（验收测试），系统开发生命周期方法论的一个阶段，这时相关的用户和／或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。这是管理性和防御性控制。 Alpha testing (α测试),是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。 Beta testing(β测试),测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。 Black box testing（黑盒测试），指测试人员不关心程序具体如何实现的一种测试方法。根据软件的规格对软件进行各种输入和观察软件的各种输出结果来发现软件的缺陷的测试，这类测试不考虑软件内部的运作原理，因此软件对用户来说就像一个黑盒子。 White box testing（白盒测试），根据软件内部的工作原理分析来进行测试,基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。 Automated Testing（自动化测试），使用自动化测试工具来进行测试，这类测试一般不需要人干预，通常在GUI、性能等测试中用得较多。 Bug (错误)，有时称作defect（缺陷）或error（错误），软件程序中存在的编程错误，可能会带来不必要的副作用，软件的功能和特性与设计规格说明书或用户需求不一致的方面。软件缺陷表现特征为：软件未达到产品说明书标明的功能；软件出现产品说明书指明不会出现的错误；软件功能超出产品说明书指明的范围；虽然产品说明书未指出但是软件应达到的目标；软件测试人员或用户认为软件难以理解，不易使用，运行速度缓慢等问题。 Bug report（错误报告），也称为“Bug record（错误记录）”，记录发现的软件错误信息的文档，通常包括错误描述、复现步骤、抓取的错误图像和注释等。 Bug tracking system（错误跟踪系统，BTS），也称为“Defect tracking system，DTS”，管理软件测试缺陷的专用数据库系统，可以高效率地完成软件缺陷的报告、验证、修改、查询、统计、存储等任务。尤其适用于大型多语言软件的测试管理。 “抓虫大扫除”（Bug Bash）：在某一个版本的发行里程碑到达之后，在发行之前项目经理向全体开发组织发出通知，告诉大家哪一天的某个时间是Bug Bash的时间，到时候全体成员，包括开发、测试、文档等团队、甚至市场部门的员工，全都放下手中的工作，在规定的那一个或几个小时的时间里，每个人把自己当作是用户一样来使用这个未成品的软件，并且进行竞赛，看谁能找到最多的Bug。这样做的目的是，不是按照测试方案的顺序来检查软件，而是通过像真正的用户那样来使用软件，即完全是任意性的、无规则的顺序，看看在这样的使用条件下，还有没有仍旧没有被发现的严重的Bug。我们往往采用谁找到最严重的Bug 就得奖的方法来鼓励大家尽力找出Bug。抓虫大扫除一结束，项目经理马上进行新呈交的Bug数量的统计，然后向开发组织中的全体员工公布。得奖的小有免费的咖啡、午餐、电影票等，大有各种礼物。所以每次Bug Bash 大家都踊跃参加，找到很多测试案例执行时没找到的问题。 Exception（异常/例外），一个引起正常程序执行挂起的事件。 Crash（崩溃），计算机系统或组件突然并完全的丧失功能，例如软件或系统突然退出或没有任何反应（死机）。 Build（工作版本），软件开发过程中用于内部测试的功能和性能等不完善的软件版本。工作版本既可以是系统的可操作版本，也可以是展示要在最终产品中提供的部分功能的部分系统。 Functional testing (功能测试)，也称为behavioral testing（行为测试），根据产品特征、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化软件的功能测试，用于验证应用程序或网站对目标用户能正确工作。使用适当的平台、浏览器和测试脚本，以保证目标用户的体验将足够好，就像应用程序是专门为该市场开发的一样。 Load testing（负载测试），通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。在这种测试中，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力。负载测试的目标是确定并确保系统在超出最大预期工作量的情况下仍能正常运行。此外，负载测试还要评估性能特征，例如，响应时间、事务处理速率和其他与时间相关的方面。 Performance testing（性能测试），评价一个产品或组件与性能需求是否符合的测试。包括负载测试、强度测试、数据库容量测试、基准测试等类型。 Pilot testing（引导测试），软件开发中，验证系统在真实硬件和客户基础上处理典型操作的能力。在软件外包测试中，引导测试通常是客户检查软件测试公司测试能力的一种形式，只有通过了客户特定的引导测试，软件测试公司才能接受客户真实软件项目的软件测试。 Portability testing（可移植性测试），测试软件是否可以被成功移植到指定的硬件或软件平台上。 Compatibility Testing（兼容性测试），也称“Configuration testing（配置测试）”，测试软件是否和系统的其它与之交互的元素之间兼容，如：浏览器、操作系统、硬件等。验证测试对象在不同的软件和硬件配置中的运行情况。 Installing testing（安装测试），确保该软件在正常情况和异常情况的不同条件下，例如，进行首次安装、升级、完整的或自定义的安装都能进行安装。异常情况包括磁盘空间不足、缺少目录创建权限等。核实软件在安装后可立即正常运行。安装测试包括测试安装代码以及安装手册。安装手册提供如何进行安装，安装代码提供安装一些程序能够运行的基础数据。 International testing（国际化测试），国际化测试的目的是测试软件的国际化支持能力，发现软件的国际化的潜在问题，保证软件在世界不同区域中都能正常运行。国际化测试使用每种可能的国际输入类型，针对任何区域性或区域设置检查产品的功能是否正常，软件国际化测试的重点在于执行国际字符串的输入/输出功能。国际化测试数据必须包含东亚语言、德语、复杂脚本字符和英语（可选）的混合字符。 Localizability testing(本地化能力测试)，本地化能力是指不需要重新设计或修改代码，将程序的用户界面翻译成任何目标语言的能力。为了降低本地化能力测试的成本，提高测试效率，本地化能力侧是通常在软件的伪本地化版本上进行。本地化能力测试中发现的典型错误包括：字符的硬编码（即软件中需要本地化的字符写在了代码内部），对需要本地化的字符长度设置了国定值，在软件运行时以控件位置定位，图标和位图中包含了需要本地化的文本，软件的用户界面与文档术语不一致等。 Localization testing（本地化测试），本地化测试的对象是软件的本地化版本。本地化测试的目的是测试特定目标区域设置的软件本地化质量。本地化测试的环境是在本地化的操作系统上安装本地化的软件。从测试方法上可以分为基本功能测试，安装/卸载测试，当地区域的软硬件兼容性测试。测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和联机帮助等部分。 Ad hoc testing (随机测试)，没有书面测试用例、记录期望结果、检查列表、脚本或指令的测试。主要是根据测试者的经验对软件进行功能和性能抽查。随机测试是根据测试说明书执行用例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。 Smoke testing（冒烟测试），冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作。冒烟测试的执行者是版本编译人员。参考“Sanity testing（健全测试）”。 Sanity testing（健全测试），软件主要功能成分的简单测试以保证它是否能进行基本的测试。 User interface（用户界面，UI），广义是指使用户可以和计算机进行交互的硬件和/或软件。狭义是指软件中的可见外观及其底层与用户交互的部分（菜单、对话框、窗口和其它控件）。 User interface testing (用户界面测试)，指测试用户界面的风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等等。UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。 Static testing（静态测试），不通过执行来测试一个系统。如代码检查，文档检查和评审等。 Regression testing（回归测试），在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，对软件的任何新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再现。 Capture/Replay Tool (捕获/回放工具)，一种测试工具，能够捕获在测试过程中传递给软件的输入，并且能够在以后的时间中，重复这个执行的过程。这类工具一般在GUI测试中用的较多。 Debug（调试），开发人员确定引起错误的根本原因和确定可能的修复措施的过程。一般发生在子系统或单元模块编码完成时，或者根据测试错误报告指出错误以后，开发人员需要执行调试过程来解决已存在的错误。 Deployment（部署），也称为shipment(发布)，对内部IT系统而言，指它的第一个版本通过彻底的测试、形成产品、交付给付款客户的阶段。 Dynamic testing（动态测试），通过执行软件的手段来测试软件。 Garbage characters（乱码字符），程序界面中显示的无意义的字符，例如，程序对双字节字符集的字符不支持时，这些字符不能正确显示。 GB 18030 testing（GB 18030测试），软件支持GB 18030字符集标准能力的测试，包括GB 18030字符的输入、输出、显示、存储的支持程度。 Priority（优先权），从商业角度出发是指错误的重要性，尤其是从客户和用户的角度出发，是指错误对于系统的可行性和可接受性的影响。与“Severity（严重性）”相对照。 Severity（严重性），错误对被测系统的影响程度，在终端用户条件下发生的可能性，软件错误妨碍系统使用的程度。 Quality assurance（质量保证QA），采取相关活动，以保证一个开发组织交付的产品满足性能需求和已确立的标准和过程。 Review（评审），在产品开发过程中，把产品提交给项目成员、用户、管理者或其它相关人员评价或批准的过程。 Screen shot（抓屏、截图），软件测试中，将软件界面中的错误（窗口、菜单、对话框等）的全部或一部分，使用专用工具存储成图像文件，以便于后续处理。 Software life cycle（软件生命周期），开始于一个软件产品的构思，结束于该产品不再被使用的这段期间。 Structured query language（结构化查询语句，SQL），在一个关系数据库中查询和处理数据的一种语言。 TBD(To be determined，待定)，在测试文档中标是一项进行中的尚未最终确定的工作。 Test（测试），执行软件以验证其满足指定的需求并检测错误的过程。检测已有条件之间的不同，并评价软件项的特性软件项的分析过程。软件工程过程的一个活动，它将软件在预定的条件下运行以判断软件是否符合预期结果。 Test case（测试用例），为特定目标而开发的一组测试输入、执行条件和预期结果，其目标可以是测试某个程序路径或核实是否满足某个特定的需求。 Testing coverage（测试覆盖），指测试系统覆盖被测试系统的程度，一项给定测试或一组测试对某个给定系统或构件的所有指定测试用例进行处理所达到的程度。 Testing environment（测试环境），进行测试的环境，包括测试平台、测试基础设施、测试实验室和其他设施。 Testing item（测试项），作为测试对象的工作版本。 Testing plan（测试计划），描述了要进行的测试活动的范围、方法、资源和进度的文档。它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。 Testing procedure（测试过程），指设置、执行给定测试用例并对测试结果进行评估的一系列详细步骤。 Testing script（测试脚本），一般指的是一个特定测试的一系列指令，这些指令可以被自动化测试工具执行。 Testing suite（测试包），一组测试用里的执行框架；一种组织测试用例的方法。在测试包里，测试用例可以组合起来创造出独特的测试条件。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"带标签的模板字符串","slug":"带标签的模板字符串","date":"2019-10-12T07:01:55.000Z","updated":"2019-10-12T07:14:01.991Z","comments":true,"path":"2019/10/12/带标签的模板字符串/","link":"","permalink":"/2019/10/12/带标签的模板字符串/","excerpt":"模板字符串的特殊用法","text":"模板字符串的特殊用法 带标签的模板字符串模板字符串中我们使用 ${exporession} 作为占位符，而作为字符串连接的语法糖是其最基本的用法，而带标签的模板字符串则是一种函数调用，这能够让模板字符串更加强大，拥有真正模板引擎的功能。123456789var a = function (strs, ...args) &#123; console.log(strs) console.log(args)&#125;var name ='jinux'var age = 20a `name: $&#123;name&#125;, age: $&#123;age&#125;` 在浏览器的console面板打印一下。可以看到，标签模板字符串的标签函数的第一个参数是由原始的字符串由占位字符串分割而成的字符串组成的数组，剩下的参数则是对应占位符的值。利用这个特性常被提到的是避免XSS攻击：12345678function htmlEscape(literals, ...placeholders) &#123; return placeholders.reduce((pre, val, i) =&gt; pre + literals[i] + val .replace(/&amp;/g, '&amp;amp;') .replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;#39') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;'), '') + literals[literals.length - 1]&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"SPA应用前端预渲染之VUE","slug":"SPA应用前端预渲染之VUE","date":"2019-10-11T07:22:53.000Z","updated":"2019-10-12T06:22:35.408Z","comments":true,"path":"2019/10/11/SPA应用前端预渲染之VUE/","link":"","permalink":"/2019/10/11/SPA应用前端预渲染之VUE/","excerpt":"vue中如何实现预渲染","text":"vue中如何实现预渲染 SPA应用前端预渲染之VUESPA应用的缺点是第一次打开缓慢，再有就是SEO不友好，优化有两种方式，一种是前端预渲染，另一种是后端渲染ssr,今天我们只说前端预渲染。前端预渲染必须在webpack的基础上来做，用到的插件是prerender-spa-plugin。我们在创建vue项目的时候现在都是用vue-cli，这里我只举例3.0版本。 prerender-spa-plugin的使用安装1cnpm install prerender-spa-plugin --save vue-config.js中增加1234567891011121314151617181920212223242526272829const PrerenderSPAPlugin = require('prerender-spa-plugin');const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;const path = require('path');module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV !== 'production') return; return &#123; plugins: [ new PrerenderSPAPlugin(&#123; // 生成文件的路径，也可以与webpakc打包的一致。 // 下面这句话非常重要！！！ // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。 staticDir: path.join(__dirname,'dist'), // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。 routes: ['/', '/product','/about'], // 这个很重要，如果没有配置这段，也不会进行预编译 renderer: new Renderer(&#123; inject: &#123; foo: 'bar' &#125;, headless: false, // 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。 renderAfterDocumentEvent: 'render-event' &#125;) &#125;), ], &#125;; &#125;&#125; 在main.js中增加12345678new Vue(&#123; router, store, render: h =&gt; h(App), mounted () &#123; document.dispatchEvent(new Event('render-event')) &#125;&#125;).$mount('#app') 路由设置router.js 中设置mode: “history” 打包运行npm run build，之后在dist文件夹下可以看到跟预渲染路由名字一样文件夹，里边有一个index.html的文件，这就是预渲染页面。 总结在现实中，这种需求还是很多的，我现在做的项目领导对首页加载一直不满意，首页是一个登录页面，现在的做法我把登录页的内容直接写死到dom里了，当js文件加载好了之后再覆盖掉，这种方式也可以，我看掘金的首页就是这么干的。我来说一下我理解的预渲染，比如想把about页面预渲染出来，打包之后发现有两个html文件，正常的首页index.html页和about文件夹下的index.html页，仔细观察about预渲染页面，引入的js，css文件是一样的，只是显示的dom内容已经写死在dom里了，当然，也可以把首页的html文件预渲染，其实也是静态化，这样SEO就可以抓到里边的内容。预渲染的页面刚访问的时候里边内容是写死的，当点击路由后又切回到vue自己的路由模式来加载页面，当然，我猜在vue的路由里边已经删除了预渲染页面的路由，访问这些页面的时候只能去服务器端去下载静态的预渲染页面了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"flex简单教程","slug":"flex简单教程","date":"2019-10-10T05:27:39.000Z","updated":"2019-10-10T06:00:49.210Z","comments":true,"path":"2019/10/10/flex简单教程/","link":"","permalink":"/2019/10/10/flex简单教程/","excerpt":"flex语法的简单记录","text":"flex语法的简单记录 flex简单教程flex在项目中经常使用，但是语法还是经常忘，这里简单的记录下基本语法，以便方便查看，如果想系统学习，请阅读阮一峰老师的两篇文章Flex 布局教程：语法篇 和 Flex 布局教程：实例篇 容器指定为flex容器1234.box &#123; display: flex; // 块元素flex布局 display: inline-flex; // 行间元素flex布局&#125; flex容器的属性12345678910111213141516171819.box &#123; // 属性决定主轴的方向（即项目的排列方向）。 flex-direction: row | row-reverse | column | column-reverse; // flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-wrap: nowrap | wrap | wrap-reverse; // flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; // justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; // align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex容器里项目的属性12345678910111213141516171819.item &#123; // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 order: &lt;integer&gt;; // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-grow: &lt;number&gt;; /* default 0 */ // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-shrink: &lt;number&gt;; /* default 1 */ // flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex-basis: &lt;length&gt; | auto; /* default auto */ // flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] // 例：auto (1 1 auto) 和 none (0 0 auto) // align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"简单快速理解web缓存","slug":"简单快速理解web缓存","date":"2019-10-09T05:39:13.000Z","updated":"2019-10-09T06:51:14.510Z","comments":true,"path":"2019/10/09/简单快速理解web缓存/","link":"","permalink":"/2019/10/09/简单快速理解web缓存/","excerpt":"简单快速,5分钟你就能理解web缓存","text":"简单快速,5分钟你就能理解web缓存 简单快速理解web缓存之前我已经写过了一篇关于web缓存的文章，阅读点这里，不过，这篇文章比较长，今天再写个短小易懂的，便于快速查看。 服务器的缓存协商缓存有两种，一种是需要服务器验证，另外一种是不用发送请求验证。 ETag/Last-Modified这两种方式做法类似，都要向服务器发送一次请求进行验证。简直，缓存就缓存呗，为什么还要验证呢？ 其实，这是该协议的一种特有方式，发送一次验证主要是检查文件是否发生变化。 ETagETag是用来计算文件的内容是否发生变化，比如，你在文件中删除一个空格，这样都算文件内容发生变化。 通常做法是用md5或者SHA1算法，计算出文件的唯一值。 在前端其实都可以完成， 找到一个文件文件解析的md5算法，然后将文件传入，就可以得到ETag的值。 不过这里，我们着重点并不是让你生成Etag，而是看看ETag在缓存中的重要作用。 ETag是HTTP/1.1A的一种办法，由Web服务器生成，并写入响应头中。12//response HeadersETag:\"751F63A30AB5F98F855D1D90D217B356\" 接着，到了浏览器之后，便缓存在本地。 当下次打开同样的文章时，会在请求头中发送If-None-Match, 给服务器检查文件是否发生变化。如果没有，则告诉浏览器使用本地的，否则返回新文件12//request HeadersIf-None-Match: \"751F63A30AB5F98F855D1D90D217B356\" 通常情况下，服务器默认是打开Etag的，但是为了防止你的同事，或者后台哥哥的后台配置文件不正确，关闭了Etag，这时候，就需要你对对配置文件做一些设置。 这里我以Nginx为例: 打开ngnix.conf文件，检查是否有以下语句:123etag off;more_set_headers -s 404 -t 'ETag';more_clear_headers 'Etag'; 如果有则将其删除掉。然后重启nginx就可以了。他们将Etag关闭的原因其实也很简单，就是因为，Etag打开之后会增加服务器的负载，造成性能的局限性，所以，关闭或者打开Etag都要经过权衡的。 Last-Modified这和文档内容信息验证不同，这里采用的是日期验证办法。 即，服务器上会对文件打上一个文件改动的日期，然后客户端接受该日期，下次请求时，返回该日期，服务器验证，如果日期未变，则告诉浏览器使用本地缓存即可。 即，在服务器的相应头中，可以设置Last-Modified，来启用这一缓存协议.12//Response HeaderLast-Modified:Tue, 03 Mar 2015 01:38:18 GMT 接受到这一响应头之后，浏览器会对该文件做一个缓存，并保存该日期。当下次请求的时候，会通过If-Modified-Since将日期传入并验证:1If-Modified-Since:Tue, 03 Mar 2015 01:38:18 GMT 如果日期未变，则告诉浏览器使用缓存。 那我们通常应该怎样启用服务器这一功能呢？ 默认情况下，服务器会对静态资源发送Last-modified的tag。 但是，需要注意，Last-Modified的更新时间只能以秒来计，如果你文件改动过于频繁，Last-Modified是无效的(不过，谁牛逼到1s内能多次更新文件嘞~) 实际上.Last-Modified的这个标签的我们通常并不会单独使用它，通常与expires结合，形成一个可降级的缓存. Expires/Cache-ControlExpires/Cache协议与上述验证协议最大的不同在于，他可以省略发送验证请求环节，不需要服务器的验证，而直接使用本地缓存。 通常这种方式，适用于，项目稳定，版本迭代不多的时候。 Expires在服务器端可以设置Expires的一个绝对时间。12//Response HeadersExpires:Tue, 03 May 2016 09:33:34 GMT 这告诉浏览器,在2016.5.3号之前,可以直接使用该文本的缓存副本。但是，可能会因为服务器和客户端的GMT时间不同，会有一定的bug。 所以，这里只提议在长时间缓存的情况下使用。否则，应该选择Cache-Control. 那在服务器端该怎么设置呢？ 这里以nginx为例:12345location ~* \\.(?:css|js)$ &#123; expires 1d; access_log off; add_header Cache-Control \"public\";&#125; 通过expires设置过期时间为一天，此时，服务器会根据当前的时间，加上一天.同时添加Expires和Cache-Control头部标签。 即,得到的Response Header为:12Expires: Fri, 28 Feb 2014 10:42:09 GMTCache-Control: max-age=86400 //24*60*60 (HTTP规定，如果出现max-age和expires，则max-age默认覆盖掉expires) 当expires为负数表示no-cache，正数或零表示max-age=time。 如果你不想缓存，可以直接设置:1expires -1; //永远过期，Cache-Control: no-cache Cache-Control这应该是HTTP1.1为了解决HTTP1.0中expires的时间差的bug，而新添加的一个tag. 他的配置项很多，其实完全都可以取代expires(现在大多数服务器都支持). 引用一段原话: Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。 不过，目前大部分服务器都会将两者添加上，因为HTTP规定，如果Cache-Control和expires同时出现的话，expires会默认被覆盖掉。 此时，返回的响应码不再是304(文件未改动),而是200(资源成功访问). 当前每次发送请求之前浏览器会检查缓存系统里，是否有相应文件的备份，如果有的话，则直接从本地模仿一个Response头 理论知识铺垫完毕，我们来take a look. 看看cache-control 有哪些可以配置的属性(以下属性都跟在cache-control后)12345678public: 共有缓存，可被缓存代理服务器缓存,比如CDNprivate: 私有缓存，不能被共有缓存代理服务器缓存，可被用户的代理缓存如浏览器。max-age=[秒]：表示在这个时间范围内缓存是新鲜的无需更新。类似Expires时间，不过这个时间是相对的，而不是绝对的。也就是某次请求成功后多少秒内缓存是新鲜的。s-maxage=[秒]：类似max-age, 除了仅应用于共享缓存（如代理）。no-cache：这里不是不缓存的意思，只是每次在使用缓存之前都强制发送请求给源服务器进行验证，检查文件该没改变(其实这里和ETag/Last区别不大)no-store：就是禁止缓存，不让浏览器保留缓存副本must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是200而是304了。proxy-revalidate：类似must-revalidate，除了只能应用于代理缓存。 比如，这里我可以设置Cache-Control为:12//Response HeadersCache-Control:private, max-age=0, must-revalidate 该文件是一个私有文件,只能被浏览器缓存，而不能被代理缓存。max-age标识该缓存立即过期，其实和no-cache实际上区别不大. 然后must-revalidate告诉浏览器，你必须给我再验证文件过没过期，比如接下来可能会验证Last-Modified或者ETag.如果没有过期则使用本地缓存. 其实上面可以直接等同于:12//Response HeadersCache-Control:private,no-cache 使用no-store的结果12//Response HeadersCache-Control:no-store; 这样表明，不管一不一样都需要重新下载. 强烈表示，不让你使用缓存文件。后续的就不会去验证ETag了。 当然，如果你将IE6那种古老的浏览器考虑进来的话，那你干脆就做的不要脸一点，直接用下面的tag就行:123Cache-Control: no-cache, no-store, must-revalidate //HTTP1.1Pragma: no-cache //HTTP1.0Expires: 0 //Proxy 不过现在基本上也没有不支持Cache-Control的浏览器了。所以，正常情况下，可以直接使用.如下的策略来进行设置:(From google developer) 我们通常在nginx怎么配置对应的cache-control头呢？12345678910111213141516##设置no-cache//Nginxexpires -1;//cache-controlCache-Control:no-cache##设置max-age=0//Nginxexpires 0;//cache-controlCache-Control:max-age=0##设置其他头部//nginxadd_header Cache-Control \"no-cache\";add_header Pragma no-cache; 上面说的基本上是服务器的响应头，那在浏览器的Request headers里存在cache-control代表什么呢？ 当请求头中有:Cache-Control: max-age=0,表示缓存需要进行验证(ETag||Last-Modified)，如果缓存未过期,则可以使用。 当请求头中有:Cache-Control: no-cache,表示浏览器只能获取最新的文件。 和Response Header中的no-store相对应。 组合缓存策略上面介绍的last/ETag/Expires/Cache都是HTTP协议的缓存策略。当然，缓存不止这一种，比如在HTML 4.0中定义的某些meta也可以实现自定义缓存的123&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\" /&gt;&lt;meta http-equiv=\"Pragma\" content=\"no-cache\" /&gt;&lt;meta http-equiv=\"Expires\" content=\"0\" /&gt; 但，实际情况是，这些meta只能在file:// 本地文件中使用，如果是服务器则默认被覆盖。现在目前主流的就是使用HTTP1.1协议缓存 不过我们一般都不会单独使用某一项。 但是，组合之后他们的效果是怎样的呢？ 如果你的网页不是什么特别定制化的(私密)的，使用缓存能给你网站的性能带来极大的提升。所以很推荐使用。 一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件(视频就呵呵了). 我们可以针对这几类文件做一些缓存层级. 文件 缓存层级 HTML Cache-Control: no-cache,must-revalidate JS Cache-Control:private,max-age=86400 CSS Cache-Control:max-age=2629000 img\\fonts Cache-Control:max-age=2629000 上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"PWA应用","slug":"PWA应用","date":"2019-10-09T05:21:24.000Z","updated":"2019-10-09T05:30:13.844Z","comments":true,"path":"2019/10/09/PWA应用/","link":"","permalink":"/2019/10/09/PWA应用/","excerpt":"PWA应用教程","text":"PWA应用教程 PWA应用PWA是Progressive Web App的英文缩写， 翻译过来就是渐进式增强WEB应用， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。我也是正要准备学习，点这里学习在这里要感谢PWA学习手册的作者。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"SVG动画介绍","slug":"SVG动画介绍","date":"2019-09-30T03:19:26.000Z","updated":"2019-10-08T06:23:13.962Z","comments":true,"path":"2019/09/30/SVG动画介绍/","link":"","permalink":"/2019/09/30/SVG动画介绍/","excerpt":"SVG动画效果简单入门介绍","text":"SVG动画效果简单入门介绍 SVG动画介绍本文主要是讲解关于 SVG 的一些高级动画特效，比如 SVG 动画标签，图形渐变，路径动画，线条动画，SVG 裁剪等。例如：路径动画图形渐变：线条动画：以及，相关的动画的矩阵知识，这个也是现在 CSS 动画里面最重要，同时也是最为欠缺的知识点：文章会先从基本语法入手，然后，慢慢深入。介绍一些动画基本原理和对应的数学原理知识点。并且文章后面，还附有相关语法的介绍，当你在遇到不熟悉语法的时候可以参考参考。前面一篇文章，主要介绍了一些 SVG 的基本概念和基本图形。接下来我们需要了解一下，SVG 处理矢量这个特性之外，还有啥内容吸引我们，能让 SVG 现在普及度这么高？ SVG Animation在 SVG 中，如果我们想实现一个动画效果，可以使用 CSS，JS，或者直接使用 SVG 中自带的 animate 元素添加动画。使用 CSS 的话，有两种选择一种是通过 style 直接内联在里面，另外是直接使用相关的动画属性– transform。123&lt;use id=\"star\" class=\"starStyle\" xlink:href=\"#starDef\" transform=\"translate(100, 100)\" style=\"fill: #008000; stroke: #008000\"/&gt; 而使用 SVG 中自定的 animate 主要还是 SVG 自己的东西，比较好用。如果想用 CSS 的动画，这都无所谓。先看一个 SVG animate DEMO:12345678&lt;rect x=\"10\" y=\"10\" width=\"200\" height=\"20\" stroke=\"black\" fill=\"none\"&gt; &lt;animate attributeName=\"width\" attributeType=\"XML\" from=\"200\" to=\"20\" begin=\"0s\" dur=\"5s\" fill=\"freeze\" /&gt;&lt;/rect&gt; 通过将 animate 标签嵌套在指定的图形里面，即可实现变换的效果。另外，还有 animateTransform，它主要是用来做变形动画的。1234567&lt;rect x=\"-10\" y=\"-10\" width=\"20\" height=\"20\" style=\"fill: #ff9; stroke: black;\"&gt; &lt;animateTransform attributeType=\"XML\" attributeName=\"transform\" type=\"scale\" from=\"1\" to=\"4 2\" begin=\"0s\" dur=\"4s\" fill=\"freeze\"/&gt;&lt;/rect&gt; 简单来说： animate: 相当于 CSS 中的 transition animateTransform: 相当于 CSS 中的 transform 里面一些技术细节我们这里就不过多讲解了。这里，主要想介绍一下 animate 中的 morph 的效果。 animate morph该效果主要做的就是图形内部的渐变。如图：这种动画是怎么实现呢？直接看代码吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;path fill=\"#1EB287\"&gt; &lt;animate attributeName=\"d\" dur=\"1440ms\" repeatCount=\"indefinite\" keyTimes=\"0; .0625; .208333333; .3125; .395833333; .645833333; .833333333; 1\" calcMode=\"spline\" keySplines=\"0,0,1,1; .42,0,.58,1; .42,0,1,1; 0,0,.58,1; .42,0,.58,1; .42,0,.58,1; .42,0,.58,1\" values=\"M 0,0 C 50,0 50,0 100,0 100,50 100,50 100,100 50,100 50,100 0,100 0,50 0,50 0,0 Z; M 0,0 C 50,0 50,0 100,0 100,50 100,50 100,100 50,100 50,100 0,100 0,50 0,50 0,0 Z; M 50,0 C 75,25 75,25 100,50 75,75 75,75 50,100 25,75 25,75 0,50 25,25 25,25 50,0 Z; M 25,50 C 37.5,25 37.5,25 50,0 75,50 75,50 100,100 50,100 50,100 0,100 12.5,75 12.5,75 25,50 Z; M 25,50 C 37.5,25 37.5,25 50,0 75,50 75,50 100,100 50,100 50,100 0,100 12.5,75 12.5,75 25,50 Z; M 50,0 C 77.6,0 100,22.4 100,50 100,77.6 77.6,100 50,100 22.4,100, 0,77.6, 0,50 0,22.4, 22.4,0, 50,0 Z; M 50,0 C 77.6,0 100,22.4 100,50 100,77.6 77.6,100 50,100 22.4,100, 0,77.6, 0,50 0,22.4, 22.4,0, 50,0 Z; M 100,0 C 100,50 100,50 100,100 50,100 50,100 0,100 0,50 0,50 0,0 50,0 50,0 100,0 Z;\"/&gt; &lt;/path&gt; 这么多，是不是感觉有点懵逼。不过，我们细分来看一下其实很简单。里面主要是利用 animate 中的 keyTimes，calcMode，keySplines，以及 values 这几个属性。不急，我们一个一个来解释一下。 keyTimes: 这其实和 CSS 中定义的 @keyframes 一样。通过 0-1 之间的值，定义每段动画完成的时间。格式为：value;value…。例如 0;.0625;.208333333;.3125;.395833333;.645833333;.833333333;1。从第一个动画，到第二个动画经历的时间比例为 6.25%。并且，keyTimes 需要和 values 里面定义的帧数一致。 calcMode: 用来定义动画具体的插值模型。取值有: discrete | linear[default] | paced | spline。具体可以参考 MDN。这里我们主要介绍一下 spline。该值表示每个动画间使用自定的贝塞尔变换曲线。如果没有特殊要求，使用 linear 其实已经足够了，这样就不用麻烦去定义下面的 keySplines 属性。 keySplines：该值用来具体定义动画执行时的 贝塞尔曲线。使用格式是通过 ; 来分隔每一个值。即，cubic-bezier(.31,.57,.93,.46) 为一组。使用 keySplines 表达，则为：keySplines = “.31,.57,.93,.46;”。当然，里面的贝塞尔曲线组数为 整个动画帧数 - 1。 而 values 就很简单了。它是直接结合 attributeName 属性，来设置具体的值，每个值之间使用 ; 进行分隔。像上面那样，可以在指定元素里面嵌套多个 animate，既实现了形状的改变，又实现了颜色的改变。Morph 比较常用于数字的更迭，比如，倒数 10s 的相关动画。到这里，Morpah 相关的知识点就结束了。 接着，让我们来看一下 SVG 中，另外一非常重要的标签 – animateMotion。该标签可以让指定的元素，绕着指定的路径进行运动。所以这对于复杂的路径来说非常有用，因为我们很难使用 transform 去模拟复杂的变换路径。看一个 DEMO animateMotionanimateMotion 大致的属性和 animate 差不多，不过，它还拥有自己特有的属性，比如 keyPoints、rotate、path 等。不过，calcMode 在 AM(animateMotion) 中的默认属性由，linear 变为 paced。这些属性，我们慢慢介绍，先从最简单的开始吧。首先，我们来看一个 DEMO：12345&lt;g&gt; &lt;rect x=\"0\" y=\"0\" width=\"30\" height=\"30\" style=\"fill: #ccc;\"/&gt; &lt;circle cx=\"30\" cy=\"30\" r=\"15\" style=\"fill: #cfc; stroke: green;\"/&gt; &lt;animateMotion from=\"0,0\" to=\"60,30\" dur=\"4s\" fill=\"freeze\"/&gt;&lt;/g&gt; from，to：指定两点的位置，位置参数是以元素的坐标为原点的。 dur：执行渲染时间 fill：指定动画结束后停留的装填。有 freeze 和 remove 效果。remove 表示回到动画开始的位置，freeze 表示停留在动画结束的位置。 如果，你想要更复杂的路径，可以直接使用 path 属性来指定路径。用法和 path 标签中 d 属性是一样的。12345&lt;rect x=\"0\" y=\"0\" width=\"30\" height=\"30\" style=\"fill: #ccc;\"&gt; &lt;animateMotion path=\"M50,125 C 100,25 150,225, 200, 125\" dur=\"6s\" fill=\"freeze\"/&gt;&lt;/rect&gt; 或者使用 mpath 标签，引用外部的 path。1234567891011121314&lt;path d=\"M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110\" stroke=\"lightgrey\" stroke-width=\"2\" fill=\"none\" id=\"theMotionPath\"/&gt; &lt;circle cx=\"10\" cy=\"110\" r=\"3\" fill=\"lightgrey\" /&gt; &lt;circle cx=\"110\" cy=\"10\" r=\"3\" fill=\"lightgrey\" /&gt; &lt;!-- Red circle which will be moved along the motion path. --&gt; &lt;circle cx=\"\" cy=\"\" r=\"5\" fill=\"red\"&gt; &lt;!-- Define the motion path animation --&gt; &lt;animateMotion dur=\"6s\" repeatCount=\"indefinite\"&gt; &lt;mpath xlink:href=\"#theMotionPath\"/&gt; &lt;/animateMotion&gt; &lt;/circle&gt; 动画效果为：所以，一般而言我们在定义 AM 的路径的时候，只用一种方式定义即可，否则会发生相应的覆盖：mpath&gt;path&gt;values&gt;from/to。在 AM 运动中，还有一个很重要的概念就是旋转角。默认情况下，运动物体的角度是按照它和坐标轴的初始角度确定的。例如：这样看起来确实有些别扭，那能不能让物体垂直于路径进行运动呢？有的，根据 rotate 属性值，一共有 3 个值可供选择。 auto：让物体垂直于路径的切线方向运动。不过，如果你的路径是闭合曲线的话，需要注意起始点的位置。 例如： auto-reverse：让物体垂直于路径的切线方向并 + 180°。也就是和 auto 运动关于切线对称。 Number：让物体以固定的旋转角度运动。这个就相当于使用 transform:rotate(deg) 进行控制。 set该标签也是用来模拟 transition 效果的。它和 animate 的主要区别是，它仅仅需要 to 的指定属性，而不需要其他的参考属性，比如 from，by 等。那它有啥特别的存在意义吗？有的，因为 set 针对于所有属性，甚至包括 style 里面的相关 CSS 属性。所以，可以靠它来很好描述一些非 number 的属性值。12345&lt;text text-anchor=\"middle\" x=\"60\" y=\"60\" style=\"visibility: hidden;\"&gt; &lt;set attributeName=\"visibility\" attributeType=\"CSS\" to=\"visible\" begin=\"4.5s\" dur=\"1s\" fill=\"freeze\"/&gt; All gone!&lt;/text&gt; 矩阵动画上面差不多简单阐述了关于 SVG 一些比较有特点的动画。当然，还有比较重要的线条动画，这个我们放到后面进行讲解。这里先来看一下所有动画中，非常重要的矩阵原理。线性代数应该是大学里面来说，最容易学的一门科目，MD。。。还记得，大学线代期末考试的时候，100 分的同学应该说是如韭菜地般，一抓一大片（对不起，我没能和他们同流合污。）那矩阵是如何在动画中使用的呢？简单的说，矩阵中的每个元素其实可以等价代换为每个因式里面的系数：上面也叫作 三维矩阵。即，它涉及到 x,y,z 轴的计算。那对于我们平面 2D 变换来说，那么此时矩阵又是哪种形式呢？很简单，只要将 z 轴永远置为一个常数就 OK。这里，惯例上是直接取 0 0 1 来设置。不信的话，大家只要代进去乘以乘，应该就可以得到结果了。所以，在二维中，具体变换方式为：后面，我们也会依据这个公式进行相关的变形操作。那矩阵变换是怎么运用到 CSS/SVG 当中呢？在 CSS 中，是直接使用 transform 中的属性：1transform: matrix(a,b,c,d,e,f); 当然，在 SVG 中也是一样的：123&lt;g transform=\"matrix(1,2,3,4,5,6)\"&gt; &lt;line x1=\"10\" y1=\"20\" x2=\"30\" y2=\"40\" style=\"stroke-width: 10px; stroke: blue;\"/&gt; &lt;/g&gt; 所以，我们主要的重点就是讲解一下 matrix 这个属性。它的格式为：1matrix(a,b,c,d,e,f); 对应于我们上面的公式有：在接触 transform 的时候，大家应该了解到 transform 里面有很多固定的动画属性： translate() rotate() scale() skew()实际上，在底层还是使用 matrix 实现的变换。就拿 translate 举个例子吧。translate 的格式为：1translate(dx,dy) 相当于参考当前原点，在 x/y 轴上移动 dx/dy 的距离。那么映射到矩阵，应该如何表示呢？很简单，它等同于：1matrix(1 0 0 1 dx dy); 使用代数证明一下：假设有 matrix(1 0 0 1 20 30)变为矩阵为：根据，上面的表达式有：12X = x'*1 + y'*0 + 20 = x' + 20Y = x'*0 + y'*1 + 30 = y' + 30 所以，就是 X 在原有 X 轴坐标上向右移动 20 的距离，Y 相对于原有移动 30 的距离。那么其他几个属性呢？也是怎么变化的吗？恩，类似。只是里面取值不一样： scale(x,y): 放大 X/Y 轴，矩阵的表达为 matrix(x 0 0 y 0 0)。 rotate(θ): 坐标旋转，矩阵的表达为 matrix(cosθ sinθ -sinθ cosθ 0 0)。 skew(θx,θy): X/Y 轴拉伸，矩阵的表达为 matrix(1 tanθx tanθy 1 0 0)。 注意，上面三个都会改变原有物体的坐标系！！！ 这点很重要，换句话说，后面每次变换都是基于前面一个的变换结果的。详情看图：详情可以参考：MDN matrix不过，这并不是我们使用 matrix 的重点，也不是它的优势。它的优势在于可计算，即，能够将复杂的动画集合到一个表达式中，并且，后续的变换可以直接基于当前的 matrix。我们先来了解一下，如果多个变换动画一起使用，matrix 应该如何表达呢？只需要找到我们变换动画对应的矩阵，然后相乘即可。例如，先旋转 45°，然后放大 1.5 倍，则有变换动画为：1transform: rotate(45deg) scale(1.5,1.5); 注意，虽然，你定义动画是分开的，但此时的动画是同时进行的。为啥？因为，这两个动画实际上可以整合成为一个变换矩阵：并且，位置是不可以调换的。比如，transform: scale(2,2) translate(20px,30px)。即，你先放大两倍，然后移动 20,30 的距离。注意，这里移动的 20,30 相对的是已经放大过后的坐标，相对于原坐标而言就是 40,60 了。 如果，你调换位置，即 transform: translate(20px,30px) scale(2,2)。就变成现在原坐标移动 20,30，然后再放大两倍。而上面强调的顺序关系，实际上就可以理解为矩阵不满足交换律的原则。因为一旦交换，结果很可能不一样。 矩阵高级用法上面的内容只是简单的描述了关于矩阵的概念。在实际中，矩阵可以说是真正利器。假设现在有一个动画，要求你将一个物体从一个点通过抛物线的方式移动到另外一个点，那么此时要求 JS/CSS 随你挑。此时，你会不会感觉，呼吸急促，头脑发热呢？恩，matrix 可以治，而且包治百病。不过，matrix 有一个限制点，它只能用于一次线性动画表达式。即，针对于抛物线，椭圆曲线这类复杂曲线来说，不太合适。那么有什么办法吗？有的，微分思想。每一段动画其实都可以通过一定范围内的直线拼接而成，那么这样，我们就可以将一段抛物线拆分为由几段线段构成的曲线。当然，如果你分的越细，拟合度就越高。这里我们不打算过度你和，我们简单的将一段抛物线分为 5段。如图：那么接下来就是抠细节。这里，依次取倾角为 45°，30°，0°，-45°，-30° 这 5 段直线。每段分配的时间比例为 20%、25%、10%、25%、20% 这主要是用于 keyframe 的设定。现在，用数学来分析一下，这个动画到底该怎么弄。现在，已知两点之间的距离为 100px。那么我们同样根据上述比例分，则有 20px, 25px, 10px, 25px, 20px。这里我们以 45° 倾角为参考点，则终点坐标为 (20,20); 。那么，该段的矩阵为：12345// 注意 Y 轴需要取负值！ 1 0 20 0 1 -20 0 0 1 CSS 中的变形动画为：1transform: matrix(1,0,0,1,20,-20); 然后，第二段就为：1231 0 250 1 -14.40 0 1 使用矩阵的乘法法，则有：1231 0 45 0 1 -34.4 0 0 1 变形动画为： 1transform: matrix(1,0,0,1,45,-34.4); 剩余几段也是这样的做法。最终，整个 keyframe 就应该表示为：123456789@keyframe Parabola&#123; 20%&#123; transform: matrix(1,0,0,1,20,-20); &#125; 45%&#123; transform: matrix(1,0,0,1,45,-34.4); &#125; ...&#125; 整个动画过程差不多都是这样。当然，矩阵也不仅仅局限于这几个动画，凭借着高度定制化和灵活性的特点，这它还常常用于进行回弹，弹跳等动画中。如果大家有兴趣，后期也可以对这类动画进行简单的讲解。后面，我们最后来了解一下 SVG 中很重要的线条动画。 线条动画SVG 中的线条动画常常用作过渡屏（splash screen）中。例如： 或者，一些比较炫酷的 LOGO 中，比如 AllowTeam 的： 看到这些炫酷的效果，大家有没有动心想学一学，看看自己到底能否做的这么好呢？OK，我们现在来正式介绍一下线条动画。在 SVG 中，最长用到的线条标签就是 Path。这里我前面一篇文章已经做了介绍，我这里就不赘述了。而在具体变化当中用到的是关于 stroke 的相关属性：（下面的属性都可以直接用在 CSS 当中！） stroke：定义笔触的颜色。例如：stroke=”green” stroke-dasharray：定义 dash 和 gap 的长度。它主要是通过使用 , 来分隔 实线 和 间隔 的值。例如：stroke-dasharray=”5, 5” 表示，按照 实线为 5，间隔为 5 的排布重复下去。如下图：放大看有：另外，stroke-dasharray 并不局限于只能设置两个值，要知道，它本身的含义是设置最小重复单元，即，dash,gap,dash,gap…。比如，我定义 stroke-dasharray=”15, 10, 5” 则相当于，[15,10,5] 为一段。则有：放大看则有： stroke-dashoffset: 用来设置 dasharray 定义其实 dash 线条开始的位置。值可以为 number || percentage。百分数是相对于 SVG 的 viewport。通常结合 dasharray 可以实现线条的运动。 stroke-linecap: 线条的端点样式。 stroke-linejoin: 线条连接的样式 stroke-miterlimit: 一个比较复杂的概念，如果我们只是画一些一般的线段，使用上面 linejoin 即可。如果涉及对边角要求比较高的，则可以使用该属性进行定义。它的值，其实就是角长度比上线宽：而实际理解的话，就是假设当 width 为 1。此时比例为 2。那么 miter = 2。那么超过 2 的 miter 部分则会被 cut 掉。可以参照：他主要是配合 linejoin 一起使用。因为 linejoin 默认取值就是 miter。所以，默认情况下就可以使用该标签属性。它默认值为 4。其余的大家下去实践一下即可。详细可以参考: miter stroke-opacity：线段的透明度 stroke-width：线的粗细。 OK，介绍完关于 path 的所有 stroke 属性之后，我们就要开始动手写一下让线条动起来的代码。简单来说，就是通过 stroke-dashoffset 和 stroke-dasharray 来做。整个动画可以分为两个过程： 通过 dasharray 将实线部分隐藏，空余为全线段长。然后，将实线部分增加至全长。比如：dasharray: 0,1000 变为 dasharray: 1000,1000。 同时，通过 dashoffset 来移动新增的实线部分，造成线段移动的效果。有: dashoffset:0，变为 dashoffset:1000。 不过，这里我们不打算使用 Path 来做啥复杂的动画，这主要考虑到手头没有一些 SVG 生成工具。所以，这里我们就以 Text 来做吧（因为做起来真的简单）。这里，先以 IV-WEB 这段文字来做动画。先给大家看一下最终结果：那么这种动画是怎么做的呢？这里，我主要介绍一下关于 CSS 相关，SVG 就一个 Text 我直接贴代码了：123456789101112131415161718&lt;svg viewBox=\"0 0 1320 300\"&gt; &lt;!-- Symbol --&gt; &lt;symbol id=\"s-text\"&gt; &lt;text text-anchor=\"middle\" x=\"50%\" y=\"50%\" dy=\".35em\"&gt; IV-WEB &lt;/text&gt; &lt;/symbol&gt; &lt;!-- Duplicate symbols --&gt; &lt;use xlink:href=\"#s-text\" class=\"text\" &gt;&lt;/use&gt; &lt;use xlink:href=\"#s-text\" class=\"text\" &gt;&lt;/use&gt; &lt;use xlink:href=\"#s-text\" class=\"text\" &gt;&lt;/use&gt;&lt;/svg&gt; 上面是通过创建一个居中定位的字体，然后使用 3 个 text 重叠。具体 CSS 我们下面来说一下。首先，我们营造的效果是从无到有，就需要使用 dasharray 将 gap 设置的足够大。这里我取 300 即可。1stroke-dasharray: 0 300; 然后，通过 nth-child 选择器，给每一个文字使用不同的颜色值：12345678910.text:nth-child(3n + 1) &#123; stroke: #F60A0A;&#125;.text:nth-child(3n + 2) &#123; stroke: #F2FF14;&#125;.text:nth-child(3n + 3) &#123; stroke: #FB9505;&#125; 下面才是重点内容。此时，这 3 个 text 的起始点重合。我现在既要他们在运行时不完全重合，又要他们的线条能进行滚动。不啰嗦了，直接看代码吧：123456789101112131415161718192021@keyframes stroke &#123; 100% &#123; stroke-dashoffset: 1000; stroke-dasharray: 80 160; &#125;&#125;@keyframes stroke1 &#123; 100% &#123; stroke-dashoffset: 1080; stroke-dasharray: 80 160; &#125;&#125;@keyframes stroke2 &#123; 100% &#123; stroke-dashoffset: 1160; stroke-dasharray: 80 160; &#125;&#125; 这就是上面 3 个不同的 text 运用的动画。dashoffet 由 0 到 1000。这完成了滚动的目的。同时，为了让字体不重合，我还需要在对应字体的 dashoffset 上，加上不同的间隔距离。比如，第一个字体 offset 为 1000。那么第二个字体，我需要加上前一个字体 dash 的长度，即，80。所以，第二个字体就变为 1080。那么第三个就是加上前两个的 dash 长度，即 1160。大致过程就是这样，详情可以查看： IVWEB 线条动画。 SVG 中使用 transition在 SVG 中，本来就存在相关的动画 Tag，不过里面用起来比较复杂，最常用的还是直接利用 CSS 里面相关的属性标签来做。其中，transition 是最常用的。比如，想做一下颜色的渐变等等。这里可以直接利用 transition 修饰指定的 SVG 属性即可。1234# fill 是 SVG 中，专有属性path &#123; transition: fill .4s ease; &#125;#europe path &#123; fill: red; &#125;#europe:hover path &#123; fill: white; &#125; SVG 文字在 SVG 中定义文字直接使用 text 标签即可。关于文字来说，一般而言需要注意的点就那么即可，文字的排列，间距等等。这些都可以直接使用 CSS 进行控制。不过，有几个属性比较特殊，这里需要额外提一下。 text-anchor用来定义参考点和实际字符之间的定位关系。格式为： text-anchor: start | middle | end | inherit直接看代码解释吧：123456789&lt;!-- Anchors in action --&gt; &lt;text text-anchor=\"start\" x=\"60\" y=\"40\"&gt;A&lt;/text&gt; &lt;text text-anchor=\"middle\" x=\"60\" y=\"75\"&gt;A&lt;/text&gt; &lt;text text-anchor=\"end\" x=\"60\" y=\"110\"&gt;A&lt;/text&gt; 第一个 A，参考的是 (60,40) 的点，定义为 start ，那么参考点应该在字符的前面。而剩下两个也是同样的道理： tspan现在，假如我们想在 text 里面添加一些特殊的字符效果，比如斜体，加粗等。由于，text 标签不能实现嵌套，所以，为了解决这个痛点，提出了 tspan 的标签。它其实就是一个可以嵌套的 text 标签。12345&lt;text x=\"10\" y=\"30\" style=\"font-size:12pt;\"&gt; Switch among &lt;tspan style=\"font-style:italic\"&gt;italic&lt;/tspan&gt;, normal, and &lt;tspan style=\"font-weight:bold\"&gt;bold&lt;/tspan&gt; text.&lt;/text&gt; tspan 里面同样可以自定义相关的自身属性。详细的可以参考 tspan 我这里就不详述了。 在 Path 展示 textText 一般可以横放，竖放。那有没有啥办法让文字可以按照一定的路径任意排放呢？有的，这里可以使用 textPath 标签，来定义具体参考路径。123456789&lt;path id=\"sharp-corner\" d=\"M 30 110 100 110 100 160\" style=\"stroke: gray; fill: none;\"/&gt;&lt;text&gt; &lt;textPath xlink:href=\"#sharp-corner\"&gt; Making a quick turn &lt;/textPath&gt;&lt;/text&gt; 如图： Clip在 DOM 中如果想展示一个图片的部分，或者以某种形状展示图片的部分，一般是通过一个 cover div 来实现的。不过，如果涉及到不规则图形的话，那么 DOM 就有天生缺陷了（当然使用 CSS 里的 clip-path 可以完成，不过兼容性不太好）。而在 SVG 中，提供了 clipPath 标签，能够让我们自定义裁剪图片的范围和形状。clipPath 里面可以接任何图形，比如，path,rect 甚至是 text。使用的时候，直接在 style 中，指定 clip-path 即可，或者直接使用 clip-path 属性指定。123456789101112131415&lt;defs&gt; &lt;clipPath id=\"textClip\"&gt; &lt;text id=\"text1\" x=\"20\" y=\"20\" transform=\"rotate(60)\" style=\"font-family: 'Liberation Sans'; font-size: 48pt; stroke: black; fill: none;\"&gt;CLIP &lt;/text&gt; &lt;/clipPath&gt; &lt;/defs&gt; &lt;use transform=\"translate(100, 0)\" xlink:href=\"#shapes\" style=\"clip-path: url(#textClip);\"/&gt; &lt;use transform=\"translate(100, 0)\" xlink:href=\"#shapes\" clip-path=\"url(#textClip);\"/&gt; 或者说，如果我们想画一个圆的裁剪区域的话：1234567&lt;defs&gt; &lt;clipPath id=\"circularPath\" clipPathUnits=\"objectBoundingBox\"&gt; &lt;circle cx=\"0.5\" cy=\"0.5\" r=\"0.5\"/&gt; &lt;/clipPath&gt;&lt;/defs&gt;&lt;use xlink:href=\"#shapes\" style=\"clip-path: url(#circularPath);\" /&gt; Appendix 参考标签g分组标签应该毫无意外排第一，因为其实作为绘制图形中最常和最基本的标签。前面一篇文章也主要介绍过了，这里做点补充。每一个分组标签都带有 id 属性，唯一标识该分组，为什么呢？因为，后面我们可以使用该 id 标签添加动画，重用该分组等。123456&lt;g id=\"demo\" stroke=\"green\" fill=\"white\" stroke-width=\"5\"&gt; &lt;circle cx=\"25\" cy=\"25\" r=\"15\"/&gt; &lt;circle cx=\"40\" cy=\"25\" r=\"15\"/&gt; &lt;circle cx=\"55\" cy=\"25\" r=\"15\"/&gt; &lt;circle cx=\"70\" cy=\"25\" r=\"15\"/&gt;&lt;/g&gt; 每个分组里面可以含有一些描述标签，比如 desc。 这些描述内容是不会被渲染的。1234&lt;g id=\"demo\" stroke=\"green\" fill=\"white\" stroke-width=\"5\"&gt; &lt;desc&gt;Just Demo&lt;/desc&gt; &lt;circle cx=\"25\" cy=\"25\" r=\"15\"/&gt;&lt;/g&gt; use该标签就是结合 g 标签一起使用，作用是可以复用 g 分组的样式。1234&lt;g id=\"Port\"&gt; &lt;circle style=\"fill: inherit;\" r=\"10\"/&gt;&lt;/g&gt;&lt;use x=\"50\" y=\"30\" xlink:href=\"#Port\" class=\"classA\"/&gt; 里面使用 xlink:href 加上指定 group 的 id，然后通过 x，y 属性指定副本放置的位置。不过，有一个限制，use 标签的 style 属性，并不能覆盖点原始的 group style 样式。而且，有时候，我们只是想使用一些模板，即，图形并未被解析，只有代码存在。这时候，就需要使用 defs 来包裹了。 defs用来保存一些代码，使其不会被浏览器解析。并且里面的分组可以被 use 属性的 style 样式所覆盖。1234567 &lt;defs&gt; &lt;g id=\"Port\"&gt; &lt;circle style=\"fill: inherit;\" r=\"10\"/&gt; &lt;/g&gt; &lt;/defs&gt;&lt;use x=\"50\" y=\"50\" xlink:href=\"#Port\" style=\"fill: blue;\"/&gt; symbol该标签和 g 标签类似，也是用来进行分组。不过，它有个特点，即，不会被浏览器所渲染。那它不和 defs 差不多吗？恩，确实。不过，defs 是官方推荐，用来包裹一些模板 svg 代码而创造出来，用来增加可读性的标签。而 symbol 是存粹的作为一个模板。它可以独立于 svg 的 viewbox 来自定义子 viewbox 和 preserveAspectRatio。123456789&lt;symbol id=\"sym01\" viewBox=\"0 0 150 110\"&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"40\" stroke-width=\"8\" stroke=\"red\" fill=\"red\"/&gt; &lt;circle cx=\"90\" cy=\"60\" r=\"40\" stroke-width=\"8\" stroke=\"green\" fill=\"white\"/&gt;&lt;/symbol&gt;&lt;use href=\"#sym01\" x=\"0\" y=\"0\" width=\"100\" height=\"50\"/&gt; 同样使用该模板，也是使用 use 标签来完成。 image既然 use 可以重用 SVG 代码，那么 SVG 里面能不能重用已经画好的 png/jpg 的图片呢？这时候，就需要用到 image 标签。其可以用来加载外部的 PNG, JPEG 图片，注意，官方规定是前两种，其它图片支持不支持官方没做答复。即，如果你使用 GIF 图片，并不能保证所有的浏览器都能正常显示。1234&lt;image xlink:href=\"kwanghwamun.jpg\" x=\"72\" y=\"92\" width=\"160\" height=\"120\"/&gt;&lt;/svg&gt; 同样，该 image 标签也具有自定义 preserveAspectRatio 的效果。 x: 定义水平位置 y: 定义垂直位置 width: 图片渲染的宽度，必须有。 height: 图片渲染的高度，必须有。 preserveAspectRatio: 控制图片的缩放 markermarker 一般是用来画箭头或者线段始末的标识图形。123456789&lt;defs&gt; &lt;marker id=\"Triangle\" viewBox=\"0 0 10 10\" refX=\"1\" refY=\"5\" markerWidth=\"6\" markerHeight=\"6\" orient=\"auto\"&gt; &lt;path d=\"M 0 0 L 10 5 L 0 10 z\" /&gt; &lt;/marker&gt; &lt;/defs&gt; &lt;polyline points=\"10,90 50,80 90,20\" fill=\"none\" stroke=\"black\" stroke-width=\"2\" marker-end=\"url(#Triangle)\" /&gt; 如图:这里我们只需要里了解即可，因为在实际画的时候，直接使用相关工具生成更加方便。 a这里的 a 标签和我们直接在 HTML 使用的超链接 a 标签类似。也是用来定义一个外链的。123456&lt;a xlink:href=\"https://developer.mozilla.org/en-US/docs/SVG\" target=\"_blank\"&gt; &lt;rect height=\"30\" width=\"120\" y=\"0\" x=\"0\" rx=\"15\"/&gt; &lt;text fill=\"white\" text-anchor=\"middle\" y=\"21\" x=\"60\"&gt;SVG on MDN&lt;/text&gt;&lt;/a&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"}]},{"title":"SVG入门教程","slug":"SVG入门教程","date":"2019-09-29T02:04:14.000Z","updated":"2019-09-29T06:08:38.862Z","comments":true,"path":"2019/09/29/SVG入门教程/","link":"","permalink":"/2019/09/29/SVG入门教程/","excerpt":"SVG基础入门教程","text":"SVG基础入门教程 SVG入门教程svg和canvas是web页面画图的两个方式，我们在开发中常用的图形是折线图，柱形图，扇形图等，大多都用现有的库来做，如echarts，highcherts,d3等。但是有些特殊的图形用库是实现不了的，这时候就需要我们自己去完成，canvas性能好，但是难度大，所以，这次我来介绍下svg的基础写法，方便使用。SVG 全称是 Scalable Vector Graphics，即，矢量图。在 Web 中使用 SVG 可以解决位图放大失真的问题。首先，不要把 SVG 和 CSS，Canvas，HTML 搞混。他们之间并没有你中有我，我中有你的关系。SVG 是通过 XML 的形式写在 HTML 文档中的。 如何书写开篇说过，SVG 就是一个 XML。看一下代码吧：12345678&lt;svg x=\"0px\" y=\"0px\" width=\"450px\" height=\"100px\" viewBox=\"0 0 450 100\"&gt; &lt;rect x=\"10\" y=\"5\" fill=\"white\" stroke=\"black\" width=\"90\" height=\"90\"/&gt; &lt;circle fill=\"white\" stroke=\"black\" cx=\"170\" cy=\"50\" r=\"45\"/&gt; &lt;polygon fill=\"white\" stroke=\"black\" points=\"279,5 294,35 328,40 303,62 309,94 279,79 258,94 254,62 230,39 263,35\"/&gt; &lt;line fill=\"none\" stroke=\"black\" x1=\"410\" y1=\"95\" x2=\"440\" y2=\"6\"/&gt; &lt;line fill=\"none\" stroke=\"black\" x1=\"360\" y1=\"6\" x2=\"360\" y2=\"95\"/&gt;&lt;/svg&gt; 大家看 svg 标签中带有一个 viewBox 的属性。这其实是 SVG 中一个很重要的概念，后面的缩放都会与它有关。说到这里，我们就需要了解一下关于 SVG 的几个基本概念。 基本概念简单来说有 3 个基本概念： viewport: 物理窗口 viewbox: 实物窗口（算了，下面解释） preserveAspectRatio: 保留横纵比 我们接下来，一个一个的进行讲解吧。 viewport参照上面的 demo，这实际上就是你用 x,y,width,height。这 4 个属性，在页面上固定的矩形区域。 viewbox定义 SVG 元素在 viewport 中的具体尺寸比例。假设有如下内容：123&lt;svg width=\"500\" height=\"200\" viewBox=\"0 0 50 20\" &gt; &lt;rect x=\"20\" y=\"10\" width=\"10\" height=\"5\" style=\"stroke: #000000; fill:none;\"/&gt;&lt;/svg&gt; viewport 为 [0,0] 到 [500,200] viewbox 为 [0,0] 到 [50,20] 默认情况下 SVG 是自动填充满 viewport 的。注意，在 SVG 中，子标签的所有尺寸都是不能带单位的，因为初始单位就是根据上面两个概念确定。当为以上情况，SVG 中基本的尺寸则不是 1px，而是 500/50 = 10px。所以，如下的图形大小为：1&lt;rect x=\"20\" y=\"10\" width=\"10\" height=\"5\" style=\"stroke: #000000; fill:none;\"/&gt; 也就是在 SVG 里面定义的 rect 图形，它的实际尺寸为 [200,100] 到 [100,50]。 preserveAspectRatio该属性就是用来定义上面 viewport 和 viewbox 相互对齐的方式。换句话就是说，它的属性可以改变 viewbox 的具体位置。基本格式为：1&lt;align&gt; [&lt;meetOrSlice&gt;] align: 定义 viewport 和 viewbox 的对齐方式，分为 x,y 轴两个方向。X 轴方向有三种方式：左边重合（xMin），x 轴中点重合（xMid），右边重合（xMax）。同理，Y 轴也有 顶边重合（YMin），y 轴中点重合（YMid），底边边重合（YMax） meetOrSlice: 主要就是定义该 SVG 是内嵌，还是裁剪或是 none（听天有命）。 其中，align 需要着重理解一下。首先，它的默认值为 xMidYMid，即为中点重合。可以从图中看出，viewbox 是通过中心进行延展的。注意，它的原点坐标还是在 viewbox 的左上角。如果你是动态增加尺寸的话，此时并不是从左到右增加，而是从中心向两端扩张。同理，如果你使用的是 xMinYMin 的话，那么如果存在尺寸变化，那么相对点则是从左上角开始的。简单来说，align 相对点其实一共有 9 个。然后就是 meet || slice || none 这三个属性具体干的事情。在这之前，我们需要了解一个公式–缩放比计算公式：1vb_h * rat_y = vp_h; 或者 vb_w * rat_x = vp_w; 其中，vb_ 为 viewbox 简写，vp_ 为 viewport 的简写。vb_h 代表就是 viewbox height。vb_w 代表就是 viewbox width。rat_x/y 代表的是 x,y 轴的缩放比例。假设有下列情况：123&lt;svg width=\"400\" height=\"200\" viewBox=\"0 0 200 200\" preserveAspectRatio=\"xMinYMin slice\" style=\"border:1px solid #cd0000;\"&gt; &lt;rect x=\"10\" y=\"10\" width=\"150\" height=\"150\" fill=\"#cd0000\"/&gt;&lt;/svg&gt; 那么，rat_x 和 rat_y 分别为： rat_x = 400/200 = 2 rat_y = 200/200 = 1 现在，针对上面 meet/slice 不同的取值，实际应用到 svg 里面的缩放比例是不同的。 meet(默认值): 本意是让 svg 尽可能的显示在 viewport 里，即，会在 rat_x 和 rat_y 中选择最小的值作为缩放标准。 slice: 本意是让 svg 完全铺满 viewport，即，会在 rat_x 和 rat_y 中选择最大的值作为缩放标准。 所以针对不同的取值，基准比例也不同。当为 meet 的情况，那么实际缩放比例为 1。则里面实际矩形的大小就为 (10,10) 到 (150,150)。当为 slice 的情况，那么实际缩放比例为 2。则里面实际矩形的大小就为 (20,20) 到 (300,300)。如果你的值为 none 的话，他会直接铺满整个 viewport，即，实际矩形大小为：(20,10) 到 (300,150)。 响应式 SVG虽然讲起响应式，一些童鞋会想这 TM 又是啥奇技淫巧？对不起，并不是。。。就是一个 viewbox 并且不带 width/height 而已。看个实际的例子吧：123456789&lt;svg viewBox=\"0 0 218.8 87.1\"&gt; &lt;g fill=\"none\" stroke=\"#000\"&gt; &lt;path d=\"M7.3 75L25.9 6.8s58.4-6.4 33.5 13-41.1 32.8-11.2 30.8h15.9v5.5s42.6 18.8 0 20.6\" /&gt; &lt;path d=\"M133.1 58.2s12.7-69.2 24.4-47.5c0 0 4.1 8.6 9.5.9 0 0 5-10 10.4.9 0 0 12.2 32.6 13.6 43 0 0 39.8 5.4 15.8 15.4-13.2 5.5-53.8 13.1-77.4 5.9.1 0-51.9-15.4 3.7-18.6z\" /&gt; &lt;/g&gt; &lt;/svg&gt; 可以看到，上面的 svg 标签并没有带上啥 width/height 属性，只是简单描述了 viewBox 的范围而已。当然，里面的尺寸标准都是在这 viewBox 的范围内进行设置的。另外，在这里声明一下，本文章并不是新手教程，也就是说，不会教你一步一步的画直线啊，圆啊，矩形啊等等这些基本图形。这些直接 google 一下，一搜一大把。所以，这里假设大家的水平是处于，能对 SVG 基本的图形属性熟悉即可，对一些高级属性还不是很清楚和熟练。OK，继续~在 SVG 中，能够直接使用的图形有: rect circle ellipse line polyline polygon 上面没有啥说的，后面我详细说一下两个比较重要的概念，分组和 Path。 分组和 Path通常 Path 和 分组通常是一起使用的，如上：1234567&lt;g fill=\"none\" stroke=\"#000\"&gt; &lt;path d=\"M7.3 75L25.9 6.8s58.4-6.4 33.5 13-41.1 32.8-11.2 30.8h15.9v5.5s42.6 18.8 0 20.6\" /&gt; &lt;path d=\"M133.1 58.2s12.7-69.2 24.4-47.5c0 0 4.1 8.6 9.5.9 0 0 5-10 10.4.9 0 0 12.2 32.6 13.6 43 0 0 39.8 5.4 15.8 15.4-13.2 5.5-53.8 13.1-77.4 5.9.1 0-51.9-15.4 3.7-18.6z\" /&gt;&lt;/g&gt; 分组我们放到后面进行讲解，这里先看一下 Path。 PathPath 在 SVG 中的地位应该是比较高的，实际上，利用 Path 这个一个标签可以画出任意的图形。path 中 d(data) 属性是用来定义相关线条数据，通常是以 M/m 为起始，代表的就是 move to 的意思。在 path 中，一共可以定义 10 种不同的图形。例如 M/m，L/l。 大家可以注意，每种标识符有两种书写方式，即，大小写。 大写: 参照的是绝对坐标，即，SVG 的右上角 小写: 参照的相对坐标，即，前一个点的坐标。 而在 10 中不同表示符中，又可以分为直线和曲线两种不同的标识符。这里，我们分类来讲解一下。 线型M/m该使用定义起始点的，没啥特殊的作用。1&lt;path d=\"M10 10\"/&gt; 表示，以 (10,10) 为起始点。 L/l原意是 Line to，用来画线段的。格式和 M/m 差不多：1L x y (or l dx dy) H/h用来画水平线，即，Horizontal。既然方向已经定了，剩下的就是距离，格式很简单：1H x (or h dx) V/v用来画竖直线，即，vertical。同上，方向也定了，格式为：1V y (or v dy) 看个例子吧：1&lt;path d=&quot;M10 10 H 90 V 90 H 10 L 10 10&quot;/&gt; 该 path 实际上就是画了一个正方形，宽 = 高 = 90。 Z/z该标识符用来表示 path 的结束，并且将最后一点和 M/m 标识开头的一点连接起来。所以，它不存在什么表示点之类的，格式为：1Z (or z) 而上面也可以进行相关的优化，最终的结果为：123&lt;path d=\"M10 10 H 90 V 90 H 10 L 10 10\"/&gt;// 使用 Z&lt;path d=\"M10 10 H 90 V 90 H 10 Z\" fill=\"transparent\" stroke=\"black\"/&gt; 曲线曲线就是 Web 画图中常见的 Bezier Curves（贝塞尔），Arcs，several Bezier curves（很多贝塞尔 - .-）等。我们简单看一下： C/c这是正统的贝塞尔曲线，需要 4 个参考点，下图应该说比较确切表示了二次贝塞尔所需要的点。所以，C/c 需要定义三个点。基本格式为：1C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy) 例如：1&lt;path d=\"M10 10 C 20 20, 40 20, 50 10\" stroke=\"black\" fill=\"transparent\"/&gt; S/s该标识符实际上使用来表示一个反射贝塞尔，即，在原有贝塞尔上再加一段贝塞尔曲线，所以，S/s 一般和 C/c 一起使用。基本格式为：1S x2 y2, x y (or s dx2 dy2, dx dy) 实际样式图为：相当于原有的贝塞尔曲线的最后一段进行反向延长并对称。然后加上新定义的一段限制曲线。具体实例为：1&lt;path d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" stroke=\"black\" fill=\"transparent\"/&gt; Q/q该标识符是用来定义二次(quadratic)贝塞尔曲线，该曲线相当于上面传统的贝塞尔来说，更加简单，它只需要定义三个点，即可完整一个贝塞尔曲线，具体作图过程如下：基本格式为：1Q x1 y1, x y (or q dx1 dy1, dx dy) 即为图上点， P1(x1,y1)，P2(x,y)起始点为 M 定义的点，例如：1&lt;path d=\"M10 80 Q 95 10 180 80\" stroke=\"black\" fill=\"transparent\"/&gt; T/t该标识符和 S 差不多，也是一个贝塞尔曲线的延长。相当于原曲线的控制点 P1 相当于 end point P2 做对称，然后，只需要定义一个终点即可，即，T/t 只需要定义贝塞尔曲线里面的终点即可：1T x y (or t dx dy) 如图：所以，简单来说，C/S，Q/T 是两两搭配一起使用的。在使用的时候，千万不要搞混即可。 弧线A/a该曲线是用来画弧线(Arcs)，而，弧线通常是圆/椭圆的一部分。当，椭圆的两个轴径长相等则为圆，所以，A/a 是按照椭圆作为基准格式：12A rx ry x-axis-rotation large-arc-flag sweep-flag x ya rx ry x-axis-rotation large-arc-flag sweep-flag dx dy 说实在的，这个比较复杂。因为，他画椭圆的方式和我们平常不一样，一般情况下，椭圆只要确定一个中心，然后是长短轴，然后是弧度范围即可。但是，它这里是通过椭圆上的两点来确定的，在加上旋转角度，俩轴径等因素来确定的。另外，需要注意，它的起始点是从上一个命令的结束点位置开始计算的。OK，我们首先简单了解一下格式里面的参数： rx,ry: 代表的就是长轴短轴，没得说。 x,y: 代表的是弧长的结束点。开始点就是上一个命令的终点。 x-axis-rotation: x 轴的旋转角度。顺时针为正 large-arc-flag[0,1]: 表示取大弧还是小弧。因为两点之间的弧长有两部分。 sweep-flag[0,1]: 取顺时针的弧，还是逆时针的弧长。参考点是以起始点开始的。 上面几个属性中，比较难理解的就是 large-arc-flag 和 sweep-flag。这么说吧，前面几个属性充其量只能确定椭圆的位置，和经过椭圆的两个点，不过，一般能通过指定两点的椭圆有两个，而通过这两点划分又会出现 4 段弧长。为了确定 4 个弧长中，是哪一个，需要两个值来确定。即，4 抽 2，2 抽 1。简单说一种，例如当，laf 和 sf 都为 0的情况。首先，laf 为 0 选择的是小弧长。所以，里面两段比较小的弧长被抽出来。然后，sf 为 0 选择的是逆时针。即，以起始点为参考，选择通过逆时针方向到达终点的那段弧。即，2 抽 1。最终得出我们需要的弧。说实在的，这个是真 TM 复杂。。。给一个参考codepen。一般情况下，我们并不需要手动来确定 path，有工具为啥不用工具呢！比如，Illustrator, Sketch 等，都可以自动生成 SVG。不过，生成之后，需要对代码做相关的压缩优化，这些都可以直接在编译器里面找到。你也可以用一下可视化工具SVGOMG来简单看一下。 分组SVG 中的分组你可以理解为 PS 中的图层，一块图层里面通常只会放一下高内聚的图形，这样既方便移动又方便做动画。SVG 中的分组标签就是 g，使用 g 标签包裹的所有子元素都认同为一组。例如：12345678 &lt;g&gt; &lt;circle cx=\"20\" cy=\"20\" r=\"20\" fill=\"green\" /&gt; &lt;circle cx=\"70\" cy=\"70\" r=\"20\" fill=\"purple\" /&gt;&lt;/g&gt;&lt;g&gt; &lt;rect x=\"110\" y=\"110\" height=\"30\" width=\"30\" fill=\"blue\" /&gt; &lt;rect x=\"160\" y=\"160\" height=\"30\" width=\"30\" fill=\"red\" /&gt;&lt;/g&gt; 需要注意的是，使用 g 进行分组，并不会改变原有元素的在屏幕上展示的效果。不过，g 标签除了分组，还有另外一个很重要的功能–动画 分组动画在分组重定义动画是直接写在 transform 属性当中的。实际上，每个子标签都可以使用 transform 的相关属性。123&lt;g transform=\"translate(...) scale(...) rotate(...) translate(...) rotate(...)\"&gt; ...&lt;/g&gt; 每种变换动画之间是通过 空格或逗号 连接的。它的执行顺序是从右到左。为啥呢？实际上可以理解为，这就是几个嵌套的 g 叠在一起。12345678910111213141516 &lt;g transform=\"translate(...) scale(...) rotate(...) translate(...) rotate(...)\"&gt; ... &lt;/g&gt; // Being Equivalent to this: &lt;g transform=\"translate(...)\"&gt; &lt;g transform=\"scale(...)\"&gt; &lt;g transform=\"rotate(...)\"&gt; &lt;g transform=\"translate(...)\"&gt; &lt;g transform=\"rotate(...)\"&gt; ... &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt;&lt;/g&gt; 具体可以使用的动画形式和 CSS 动画一模一样，详情可以参考: SVG动画 以上就是SVG的简单入门介绍，原文请点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web图形","slug":"web图形","permalink":"/tags/web图形/"}]},{"title":"puppeteer爬取简书文章","slug":"puppeteer爬取简书文章","date":"2019-09-26T03:05:46.000Z","updated":"2019-10-10T05:36:26.016Z","comments":true,"path":"2019/09/26/puppeteer爬取简书文章/","link":"","permalink":"/2019/09/26/puppeteer爬取简书文章/","excerpt":"puppeteer爬取简书文章的小例子","text":"puppeteer爬取简书文章的小例子 puppeteer爬取简书文章puppeteer这个工具库我已经了解有些时候了，自己在之前的文章中也有简单的介绍，也列出了几个学习站点，不过，第一个爬虫的例子，还是缓缓的到来了。这个小例子很简单，只有几十行代码，大概的流程是，首先打开简书的首页，之后下拉到底部，加载数据，下拉几次之后就没有了下拉加载的功能，取而代之的是“阅读更多”按钮，点击后会加载新内容。就这样往复的加载文章的列表，当符合自己设定的上限值后，停止加载，拿到了文章列表后循环的打开相对应的页面，读取文章详细内容，并写到本地磁盘里。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const puppeteer = require('puppeteer');const fs = require('fs');// 简书网址const baseUrl = 'https://www.jianshu.com'; (async () =&gt; &#123; const browser = await puppeteer.launch(&#123; headless:false, slowMo:250, defaultViewport: &#123; width: 1200, height: 600 &#125; &#125;); const page = await browser.newPage(); // page.setDefaultNavigationTimeout(timeout); await page.goto(baseUrl); // await page.waitFor(1000); // 获取简书首页中的列表数据 const hrefList = await page.evaluate((baseUrl) =&gt; &#123; let arr = [], list; return new Promise((resolve, reject)=&gt; &#123; function loadPage() &#123; var btn = document.querySelector('.load-more'); if(btn) &#123; btn.click(); &#125;else &#123; var pageHeight = document.querySelector('#list-container').offsetHeight; for(let i=0; i&lt;pageHeight; i++) &#123; document.documentElement.scrollTo(0, i); &#125; &#125; setTimeout(() =&gt; &#123; list = document.querySelectorAll('#list-container .note-list li'); if(list.length &lt; 50) &#123; loadPage(); &#125;else &#123; for(let item of list) &#123; let href = item.querySelector('a').getAttribute('href'); arr.push(baseUrl + href); &#125; resolve(arr); &#125; &#125;, 2000); &#125; loadPage(); &#125;); &#125;, baseUrl); // 通过hrefList来获取单个的文章内容，并写入文章文件 for(let item of hrefList) &#123; try &#123; await page.goto(item); &#125; catch(err) &#123; continue; &#125; await page.waitFor(5000); var article = await page.evaluate(() =&gt; &#123; var mainText; try &#123; mainText = document.querySelector('._gp-ck').innerHTML; &#125; catch(err) &#123; mainText = '此页面有问题。'; &#125; return mainText; &#125;); fs.writeFileSync('./download-articles/'+item.replace(/\\/|\\:|\\./g, '')+'.txt', article, &#123; flag: 'a' &#125;); &#125; // 关闭浏览器 await browser.close();&#125;)(); 以后还会更新些更复杂的爬虫案例哦。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"/tags/爬虫/"}]},{"title":"文本文件和二进制文件的差异和区别","slug":"文本文件和二进制文件的差异和区别","date":"2019-09-24T01:46:35.000Z","updated":"2019-09-24T02:00:23.383Z","comments":true,"path":"2019/09/24/文本文件和二进制文件的差异和区别/","link":"","permalink":"/2019/09/24/文本文件和二进制文件的差异和区别/","excerpt":"文本文件和二进制文件的差异和区别","text":"文本文件和二进制文件的差异和区别 文本文件和二进制文件的差异和区别一：广义上的二进制文件包括文本文件，这里讨论的是狭义上的二进制文件与文本文件的比较： 1.能存储的数据类型不同文本文件只能存储char型字符变量。二进制文件可以存储char/int/short/long/float/……各种变量值。 2.每条数据的长度文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节…… 3.读取的软件不同文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器…… 4.操作系统对换行符(‘\\n’)的处理不同（不重要）文本文件，操作系统会对’\\n’进行一些隐式变换，因此文本文件直接跨平台使用会出问题。在Windows下，写入’\\n’时，操作系统会隐式的将’\\n’转换为”\\r\\n”，再写入到文件中；读的时候，会把“\\r\\n”隐式转化为’\\n’，再读到变量中。在Linux下，写入’\\n’时，操作系统不做隐式变换。二进制文件，操作系统不会对’\\n’进行隐式变换，很多二进制文件（如电影、图片等）可以跨平台使用。 从存储方式来说，文件在磁盘上的存储方式都是二进制形式，所以，文本文件其实也应该算二进制文件。先从他们的区别来说，虽然都是二进制文件，但是二进制代表的意思不一样。打个比方，一个人，我们可以叫他的大名，可以叫他的小名，但其实都是代表这个人。二进制读写是将内存里面的数据直接读写入文本中，而文本呢，则是将数据先转换成了字符串，再写入到文本中。要弄明白二者的区别，需要知道文件的读写过程。以读文件为例， 实际上是磁盘 》》 文件缓冲区》》应用程序内存空间这两个转化过程。我们说“文本文件和二进制文件没有区别”，实际上针对的是第一个过程；既然没有区别，那么打开方式不同，为何显示内容就不同呢？这个区别实际上是第二个过程造成的。 文件实际上包括两部分，控制信息和内容信息。纯文本文件仅仅是没有控制格式信息罢了； 实际上也是一种特殊的二进制文件。所以，我们很难区分二者的不同，因为他们的概念上不是完全互斥的。我们说文本文件是特殊的二进制文件，是因为文本文件实际上的解释格式已经确定了：ASCII或者unicode编码。文本文件的一个缺点是，它的熵往往较低，也就是说，其实本可以用更小的存储空间记录这些信息。比如，文本文件中的一个数字65536，需要用5个字节来存储；但是用二进制格式，采用int存储，仅仅需要2个字节。而二进制文件elf和bmp等，都往往有一个head，告诉你文件信息和解释方式。 记事本支持文本文件而不支持二进制文件，所以如果你用记事本打开文本文件那么一切正常，如果打开的是二进制文件就会出现乱码。但也有不乱码的地方，你会注意到那些地方都是字符编码的，而对于int、double等类型所对应的值都是乱码的，这是由于记事本只能够识别字符类型，而无法识别其他类型。 1.二进制文件是把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放，也就是说存放的是数据的原形式。 2.文本文件是把数据的终端形式的二进制数据输出到磁盘上存放，也就是说存放的是数据的终端形式。 字符数据本身在内存中就经过了编码，所以无论是二进制还是文本形式都是一样的，而对于非字符数据来说，例如inti=10；如果用二进制来进行存储的话为1010，但是如果需要用文本形式来进行存储的话就必须进行格式化编码（对1和0分别编码，即形式为‘1’和‘0’分别对应的码值）。 二：1.文本文件与二进制文件的定义大家都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（这样一个过程，可以看作是自定义编码。 从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对BMP文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前2字节用来记录文件为BMP格式，接下来的8个字节用来记录文件长度，再接下来的4字节用来记录bmp文件头的长度。 2.文本文件与二进制文件的存取文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流，然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。一般来说，你选取的解码方式会是ASCII码形式（ASCII码的一个字符是8个比特），接下来，它8个比特8个比特地来解释这个文件流。例如对于这么一个文件流”01000000_01000001_01000010_01000011”(下划线”_”，为了增强可读性手动添加的)，第一个8比特”01000000”按ASCII码来解码的话，所对应的字符是字符”A”，同理其它3个8比特可分别解码为”BCD”，即这个文件流可解释成“ABCD”，然后记事本就将这个“ABCD”显示在屏幕上。 事实上，世界上任何东西要与其他东西通信会话，都存在一个既定的协议，既定的编码。人与人之间通过文字联络，汉字“妈”代表生你的那个人，这就是一种既定的编码。但注意到这样一种情况，汉字“妈”在日本文字里有可能是你生下的那个人，所以当一个中国人A与日本B之间用“妈”这个字进行交流，出现误解就很正常的。用记事本打开二进制文件与上面的情况类似。记事本无论打开什么文件都按既定的字符编码工作（如ASCII码），所以当他打开二进制文件时，出现乱码也是很必然的一件事情了，解码和译码不对应嘛。例如文件流”00000000_00000000_00000000_00000001”可能在二进制文件中对应的是一个四字节的整数int 1，在记事本里解释就变成了”NULL_NULL_NULL_SOH”这四个控制符。 文本文件的存储与其读取基本上是个逆过程。而二进制文件的存取显然与文本文件的存取差不多，只是编／解码方式不同而已。 3.文本文件与二进制文件的优缺点因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点，这个找本编码的书来看看就比较清楚了。一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符。 在windows下,文本文件不一定是一ASCII来存贮的,因为ASCII码只能表示128的标识,你打开一个txt文档,然后另存为,有个选项是编码,可以选择存贮格式,一般来说UTF-8编码格式兼容性要好一些.而二进制用的计算机原始语言,不存贮兼容性. 很多书上还认为，文本文件的可读性要好些，存储要花费转换时间(读写要编译码)，而二进制文件可读性差，存储不存在转换时间（读写不要编解码，直接写值）．这里的可读性是从软件使用者角度来说的，因为我们用通用的记事本工具就几乎可以浏览所有文本文件，所以说文本文件可读性好；而读写一个具体的二进制文件需要一个具体的文件解码器，所以说二进制文件可读性差，比如读BMP文件，必须用读图软件。 而这里的存储转换时间应该是从编程的角度来说的，因为有些操作系统如windows需要对回车换行符进行转换(将”\\n”，换成”\\r\\n”，所以文件读写时，操作系统需要一个一个字符的检查当前字符是不是”\\n”或”\\r\\n”).这个在存储转换在Linux操作系统中并不需要，当然，当在两个不同的操作系统上共享文件时，这种存储转换又可能出来。 三：文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。 特别的是，文本文件是指以ASCII码方式(也称文本方式)存储的文件，更确切地说，英文、数字等字符存储的是ASCII码，而汉字存储的是机内码。文本文件中除了存储文件有效字符信息（包括能用ASCII码字符表示的回车、换行等信息）外，不能存储其他任何信息。 文本文件是一种由若干行字符构成的计算机文件。文本文件存在于计算机文件系统中。通常，通过在文本文件最后一行后放置文件结束标志来指明文件的结束。文本文件是指一种容器，而纯文本是指一种内容。文本文件可以包含纯文本。一般来说，计算机文件可以分为两类：文本文件和二进制文件。 只含有ASCII字符的文本文件可以在Unix、Macintosh、Microsoft Windows、DOS和其它操作系统之间自由交互，而其它格式的文件是很难做到这一点的。但是，在这些操作系统中，换行符并不相同，处理非ASCII字符的方式也不一致。 .txt是包含极少格式信息的文字文件的扩展名。.txt格式并没有明确的定义，它通常是指那些能够被系统终端或者简单的文本编辑器接受的格式。任何能读取文字的程序都能读取带有.txt扩展名的文件，因此，通常认为这种文件是通用的、跨平台的。 在英文文本文件中，ASCII字符集是最为常见的格式，而且在许多场合，它也是默认的格式。对于带重音符号的和其它的非ASCII字符，必须选择一种字符编码。在很多系统中，字符编码是由计算机的区域设置决定的。常见的字符编码包括支持许多欧洲语言的ISO 8859-1。 由于许多编码只能表达有限的字符，通常它们只能用于表达几种语言。Unicode制定了一种试图能够表达所有已知语言的标准，Unicode字符集非常大，它囊括了大多数已知的字符集。Unicode有多种字符编码，其中最常见的是UTF-8，这种编码能够向后兼容ASCII，相同内容的的ASCII文本文件和UTF-8文本文件完全一致。 微软的MS-DOS和Windows采用了相同的文本文件格式，它们都使用CR和LF两个字符作为换行符，这两个字符对应的ASCII码分别为13和10。通常，最后一行文本并不以换行符(CR-LF标志)结尾，包括记事本在内的很多文本编辑器也不在文件的最后添加换行符。 大多数Windows文本文件使用ANSI、OEM或者Unicode编码。Windows所指的ANSI编码通常是1字节的ISO-8859编码，不过对于像中文、日文、朝鲜文这样的环境，需要使用2字节字符集。在过渡至Unicode前，Windows一直用ANSI作为系统默认的编码。而OEM编码，也是通常所说的MS-DOS代码页，是IBM为早期IBM个人电脑的文本模式显示系统定义的。在全屏的MS-DOS程序中同时使用了图形的和按行绘制的字符。新版本的Windows可以使用UTF-16LE和UTF-8之类的Unicode编码。 由于结构简单，文本文件被广泛用于记录信息。它能够避免其它文件格式遇到的一些问题。此外，当文本文件中的部分信息出现错误时，往往能够比较容易的从错误中恢复出来，并继续处理其余的内容。文本文件的一个缺点是，它的熵往往较低，也就是说，可以用较小的存储空间记录这些信息。 文本文件基本上是定长编码的(也有非定长的编码如UTF-8)，基于字符，每个字符在具体编码中是固定的，ASCII码是8个比特的编码，UNICODE一般占16个比特。而二进制文件可看成是变长编码的，因为是值编码，多少个比特代表一个值，完全由自己决定。 广义的二进制文件即指文件，由文件在外部设备的存放形式为二进制而得名。狭义的二进制文件即除文本文件以外的文件。 每个字符由一个或多个字节组成，每个字节都是用的-128—127之间的部分数值来表示的，也就是说，-128——127之间还有一些数据没有对应任何字符的任何字节。如果一个文件中的每个字节的内容都是可以表示成字符的数据，我们就可以称这个文件为文本文件。文本文件只是二进制文件中的一种特例，为了与文本文件相区别，人们又把除了文本文件以外的文件称为二进制文件，由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件。 为什么要使用二进制文件。原因大概有三个： 第一是二进制文件比较节约空间，这两者储存字符型数据时并没有差别。但是在储存数字，特别是实型数字时，二进制更节省空间；第二个原因是，内存中参加计算的数据都是用二进制无格式储存起来的，因此，使用二进制储存到文件就更快捷。如果储存为文本文件，则需要一个转换的过程。在数据量很大的时候，两者就会有明显的速度差别了。第三，就是一些比较精确的数据，使用二进制储存不会造成有效位的丢失。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"WebGL是啥？","slug":"WebGL是啥？","date":"2019-09-23T01:48:45.000Z","updated":"2019-09-23T02:01:36.431Z","comments":true,"path":"2019/09/23/WebGL是啥？/","link":"","permalink":"/2019/09/23/WebGL是啥？/","excerpt":"简单的介绍一下WebGL是什么","text":"简单的介绍一下WebGL是什么 WebGL是啥？为了让大家快速认识WebGL，先不讲解具体的知识点，我相信很多程序员希望通过一个麻雀虽小，但是五脏俱全的demo来认识一个新的技术领域。所以这里通过一个简单的案例来给大家展示WebGL技术，下面的代码完成的效果就是在canvas画布上绘制一个点。 使用WebGL绘制一个点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;使用WebGL绘制一个点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--canvas标签创建一个宽高均为500像素，背景为蓝色的矩形画布--&gt;&lt;canvas id=\"webgl\" width=\"500\" height=\"500\" style=\"background-color: blue\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;!-- 顶点着色器源码 --&gt;&lt;script id=\"vertexShader\" type=\"x-shader/x-vertex\"&gt; void main() &#123; //给内置变量gl_PointSize赋值像素大小 gl_PointSize=20.0; //顶点位置，位于坐标原点 gl_Position =vec4(0.0,0.0,0.0,1.0); &#125;&lt;/script&gt;&lt;!-- 片元着色器源码 --&gt;&lt;script id=\"fragmentShader\" type=\"x-shader/x-fragment\"&gt; void main() &#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125;&lt;/script&gt;&lt;script&gt; //通过getElementById()方法获取canvas画布 var canvas=document.getElementById('webgl'); //通过方法getContext()获取WebGL上下文 var gl=canvas.getContext('webgl'); //顶点着色器源码 var vertexShaderSource = document.getElementById( 'vertexShader' ).innerText; //片元着色器源码 var fragShaderSource = document.getElementById( 'fragmentShader' ).innerText; //初始化着色器 var program = initShader(gl,vertexShaderSource,fragShaderSource); //开始绘制，显示器显示结果 gl.drawArrays(gl.POINTS,0,1); //声明初始化着色器函数 function initShader(gl,vertexShaderSource,fragmentShaderSource)&#123; //创建顶点着色器对象 var vertexShader = gl.createShader(gl.VERTEX_SHADER); //创建片元着色器对象 var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //引入顶点、片元着色器源代码 gl.shaderSource(vertexShader,vertexShaderSource); gl.shaderSource(fragmentShader,fragmentShaderSource); //编译顶点、片元着色器 gl.compileShader(vertexShader); gl.compileShader(fragmentShader); //创建程序对象program var program = gl.createProgram(); //附着顶点着色器和片元着色器到program gl.attachShader(program,vertexShader); gl.attachShader(program,fragmentShader); //链接program gl.linkProgram(program); //使用program gl.useProgram(program); //返回程序program对象 return program; &#125;&lt;/script&gt;&lt;/html&gt; 代码结构整个代码是一个.html文件，里面包含JavaScript代码和着色器语言代码，通过JavaScript调用WebGL API来完成绘制操作。 HMTL和JavaScript如果原来接触的是OpenGL，不了解WebGL，对浏览器的生态环境不了解，不了解前端知识，那么在学习WebGL之前，你应该先了解一下什么是HTML，什么是JavaScript语言。 canvascanvas和div一样也是HTML的一个元素，只不过通过这个元素可实现三维场景的回执和渲染。通过canvas对象的getContext方法可以返回一个2D或3D环境 canvas元素12&lt;!--canvas标签创建一个宽高均为500像素，背景为蓝色的矩形画布--&gt;&lt;canvas id=\"webgl\" width=\"500\" height=\"500\" style=\"background-color: blue\"&gt;&lt;/canvas&gt; 返回3D绘图环境通过返回的gl对象可以调用WebGL API，所有的WebGL API就是gl对象的方法。比如gl.linkProgram()1234//通过getElementById()方法获取canvas画布var canvas=document.getElementById('webgl');//通过方法getContext()获取WebGL上下文var gl=canvas.getContext('webgl'); 返回2D环境返回2D环境，就是大家平常说的canvas，通过canvas对象可以返回webgl绘图环境，也可以返回2D绘环境，不过大家在表达的时候，2D绘图环境通常表达为canvas，而canvas返回的3D环境，使用WebGL去表述。1var c=canvas.getContext('2d'); 着色器语言 GLSL顶点、片元着色器代码要通过着色器语言来编写，着色器语言在GPU中执行，而平时大家说的JavaScript、Python等语言都是在CPU中执行。在GPU中执行的着色器代码，需要先通过WebGL进行一定的处理然后传递到GPU才能执行，所以编写的着色器语言就是一段符合一定的规则的字符串。如果你现在还不能理解着色器语言的语法规则，也没有关系，作为初学者你现在只需要有一个印象，然后慢慢去学习。 顶点着色器内置变量gl_PointSize设置了顶点渲染后的显示大小，内置变量gl_Position决定了渲染的位置，你可以去修改位置变量的值，比如vec4(0.0,0.0,0.0,1.0)变成vec4(0.5,0.0,0.0,1.0)，你会发现渲染的点位置发生了变化。123456789&lt;!-- 顶点着色器源码 --&gt;&lt;script id=\"vertexShader\" type=\"x-shader/x-vertex\"&gt; void main() &#123; //给内置变量gl_PointSize赋值像素大小 gl_PointSize=20.0; //顶点位置，位于坐标原点 gl_Position =vec4(0.0,0.0,0.0,1.0); &#125;&lt;/script&gt; 片元着色器内置变量gl_FragColor设置渲染结果的颜色值，vec4(1.0,0.0,0.0,1.0)表示红色，如果改成vec4(0.0,1.0,0.0,1.0)，你会发现渲染结果是绿色，vec4的四个分量分别表示RGBA。1234567&lt;!-- 片元着色器源码 --&gt;&lt;script id=\"fragmentShader\" type=\"x-shader/x-fragment\"&gt; void main() &#123; gl_FragColor = vec4(1.0,0.0,0.0,1.0); &#125; &lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"iscroll移动端卡顿解决办法","slug":"iscroll移动端卡顿解决办法","date":"2019-09-19T05:36:02.000Z","updated":"2019-09-19T06:21:22.514Z","comments":true,"path":"2019/09/19/iscroll移动端卡顿解决办法/","link":"","permalink":"/2019/09/19/iscroll移动端卡顿解决办法/","excerpt":"解决iscroll在移动端卡顿","text":"解决iscroll在移动端卡顿 iscroll移动端卡顿解决办法iscroll是模拟区域滚动的一个库，很有名的，类似的还有一个库叫better-scroll，作者是中国人，好像是阿里的吧，是在iscroll的基础上开发的，很灵活，支持es6等语法导入，不过本篇博文不做介绍，我们来讨论iscroll。有一个需求是页面拒不缩放并且可以滚动，正好用到了iscroll-zoom.js,但是引入后发现在pc端嗷嗷流畅，但是移动端就卡顿，后来在网上查到解决办法，但是感觉并不是好的解决办法，应该还有更好的，暂时贴出现在的解决办法，以后在陆续跟进。 解决方法一1.123&lt;style type=\"text/css\"&gt; * &#123; touch-action: pan-y; &#125;&lt;/style&gt; 2.123456&lt;script&gt; window.PointerEvent = undefined; document.addEventListener('touchmove', function (e) &#123; e.preventDefault(); &#125;, false);&lt;/script&gt; 3.1234567891011&lt;script&gt; tabContentScroll = new IScroll(\"#tabContentWrapper\", &#123; tap: true, probeType: 2, deceleration: 0.001, vScrollbar: false &#125;); // 初始化IScroll的时候，加上vScrollbar: false，最关键这句，不加这句，完成其他几点只可以改好Chorme的问题，安卓的问题解决不了！！！&lt;/script&gt; 4.我觉得是最主要的，比如iscroll-zoom.js文件，我是用的是v5.2.0版本，大约在290行1234567 disablePointer : !utils.hasPointer,disableTouch : utils.hasPointer || !utils.hasTouch, disableMouse : utils.hasPointer || utils.hasTouch, // 修改成 disablePointer : true,disableTouch : false,disableMouse : true, 官网issus的解释这个是在网络上找到的参考答案连接 解决方法二既然v5.2.0有bug，那我们不用这个版本的，可以用以前的老版本啊。1npm info iscroll 可以查看历史版本等信息，我下载了v5.0.8这个版本，经过测试可用了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"Puppeteer","slug":"Puppeteer","date":"2019-09-10T06:50:51.000Z","updated":"2019-09-10T07:02:46.923Z","comments":true,"path":"2019/09/10/Puppeteer/","link":"","permalink":"/2019/09/10/Puppeteer/","excerpt":"Puppeteer工具","text":"Puppeteer工具 PuppeteerPuppeteer是谷歌官方出品的一个通过DevTools协议控制headless Chrome的Node库。可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。这里不做太多的介绍，贴出官方网址链接自行查看 npm-puppeteer findbestopensource Puppeteer 中文文档","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"JS中的offset、scroll、client","slug":"JS中的offset、scroll、client","date":"2019-09-09T07:44:40.000Z","updated":"2019-09-09T07:59:40.940Z","comments":true,"path":"2019/09/09/JS中的offset、scroll、client/","link":"","permalink":"/2019/09/09/JS中的offset、scroll、client/","excerpt":"JS中的offset、scroll、client简单整理","text":"JS中的offset、scroll、client简单整理 JS中的offset、scroll、client在下开发中经常碰到 offset、scroll、client 这几个关键字，比如 offsetLeft、offsetHeight、scrollHeight、clientTop 什么的，每次都要各种实验，这里总结一下，一劳永逸。来两张图先： 1. offsetoffset 指偏移，包括这个元素在文档中占用的所有显示宽度，包括滚动条、 padding、 border，不包括 overflow隐藏的部分。 offsetParent属性返回一个对象的引用，这个对象是距离调用 offsetParent的父级元素中最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。如果这个容器元素未进行CSS定位, 则 offsetParent属性的取值为根元素的引用。如果当前元素的父级元素中没有进行CSS定位（position为 absolute/relative）， offsetParent 为 body如果当前元素的父级元素中有CSS定位（ position 为 absolute/relative）， offsetParent 取父级中最近的元素 obj.offsetWidth 指 obj 控件自身的绝对宽度，不包括因 overflow 而未显示的部分，也就是其实际占据的宽度，整型，单位：像素。offsetWidth = border-width*2+ padding-left+ width+ padding-right obj.offsetHeight 指 obj 控件自身的绝对高度，不包括因 overflow 而未显示的部分，也就是其实际占据的高度，整型，单位：像素。offsetHeight = border-width*2+ padding-top+ height+ padding-bottom obj.offsetTop 指 obj 相对于版面或由 offsetParent 属性指定的父坐标的计算上侧位置，整型，单位：像素。offsetTop= offsetParent的padding-top + 中间元素的offsetHeight + 当前元素的margin-top obj.offsetLeft 指 obj 相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置，整型，单位：像素。offsetLeft= offsetParent的padding-left + 中间元素的offsetWidth + 当前元素的margin-left 2. scrollscroll指滚动，包括这个元素没显示出来的实际宽度，包括 padding，不包括滚动条、 border scrollHeight 获取对象的滚动高度，对象的实际高度； scrollLeft 设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 scrollTop 设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 scrollWidth 获取对象的滚动宽度 3. clientclient指元素本身的可视内容，不包括 overflow被折叠起来的部分，不包括滚动条、 border，包括 padding clientWidth 对象可见的宽度，不包括滚动条等边线，会随窗口的显示大小改变 clientHeight 对象可见的高度 clientTop、clientLeft 这两个返回的是元素周围边框的厚度，一般它的值就是0。因为滚动条不会出现在顶部或者左侧 最后，奉上一个demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #parent &#123; position: relative; margin: 20px auto; width: 300px; height: 400px; border: 1px solid blue; overflow: auto; &#125; #child &#123; width: 500px; height: 600px; margin: 10px; padding: 5px; background-color: blanchedalmond; box-sizing: border-box; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var nParent = document.querySelector('#parent'), nChild = document.querySelector('#child'); document.addEventListener('click', function() &#123; // offset偏移 console.log('父元素-&gt;', nChild.offsetParent); console.log('offsetWidth-&gt;', nChild.offsetWidth); console.log('offsetHeight-&gt;', nChild.offsetHeight); console.log('offsetTop-&gt;', nChild.offsetTop); console.log('offsetLeft-&gt;', nChild.offsetLeft); console.log('&lt;-------------------------&gt;'); // scroll滚动 console.log('scrollHeight-&gt;', nParent.scrollHeight); console.log('scrollLeft-&gt;', nParent.scrollLeft); console.log('scrollTop-&gt;', nParent.scrollTop); console.log('scrollWidth-&gt;', nParent.scrollWidth); console.log('&lt;-------------------------&gt;'); // client console.log('clientWidth-&gt;', nChild.clientWidth); console.log('clientHeight-&gt;', nChild.clientHeight); console.log('clientTop-&gt;', nChild.clientTop); console.log('clientLeft-&gt;', nChild.clientLeft); &#125;, false);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"一个页面loading小插件2","slug":"一个页面loading小插件2","date":"2019-09-04T06:53:02.000Z","updated":"2019-09-04T07:36:20.238Z","comments":true,"path":"2019/09/04/一个页面loading小插件2/","link":"","permalink":"/2019/09/04/一个页面loading小插件2/","excerpt":"有多种选择的loading插件","text":"有多种选择的loading插件 一个页面loading小插件2前些天写了一个loading的插件，点击查看,今天又写了一个，优点是可以进行loading样式的选择，有12种样式。先贴出loading插件代码:123456789101112131415161718192021222324252627282930313233343536373839/** * @description 移动端的loading效果小插件，内置了12种loading效果 * @description 使用demo：var mask = new JLoading(); * mask.init('loader-03'); * mask.show(); 显示 * mask.hide(); 隐藏 */function JLoading() &#123; this.loaderStr = 'loader-01,loader-02,loader-03,loader-04,loader-05,loader-06,loader-07,loader-08,loader-09,loader-10,loader-11,loader-12' this.type = '';&#125;JLoading.prototype.init = function(type) &#123; if(this.loaderStr.split(',').indexOf(type) &lt; 0) &#123; this.type = 'loader-01'; &#125; else &#123; this.type = type; &#125; this.loadIndex = this.type.slice(-2); var nBody = document.body, nHead = document.head; var nStyle = document.createElement('style'), nMask = document.createElement('div'), nLoader = document.createElement('div'); nMask.setAttribute('id', 'JLoading-mask-'+this.loadIndex); nLoader.setAttribute('class', this.type); nMask.appendChild(nLoader); nBody.appendChild(nMask); nStyle.innerHTML = `[id*=\"JLoading-mask\"]&#123;display:none;width:100%;height:100%;height:100vh;background-color:rgba(0,0,0,.8)&#125;[class*=\"loader-\"]&#123;position:absolute;display:inline-block;width:10%;padding-top:10%;color:#fff;vertical-align:middle;pointer-events:none;left:45%;top:45%&#125;.loader-01&#123;border:5px dotted currentcolor;border-radius:50%;-webkit-animation:1s loader-01 linear infinite;animation:1s loader-01 linear infinite&#125;@-webkit-keyframes loader-01&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-01&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-02&#123;border:5px solid transparent;border-left-color:currentcolor;border-right-color:currentcolor;border-radius:50%;-webkit-animation:1s loader-02 linear infinite;animation:1s loader-02 linear infinite&#125;@-webkit-keyframes loader-02&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-02&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-03&#123;border:2px solid currentcolor;border-bottom-color:transparent;border-radius:50%;-webkit-animation:1s loader-03 linear infinite;animation:1s loader-03 linear infinite;position:relative&#125;@-webkit-keyframes loader-03&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-03&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-04&#123;border:1px solid currentcolor;border-radius:50%;-webkit-animation:1s loader-04 linear infinite;animation:1s loader-04 linear infinite;position:relative&#125;.loader-04:before&#123;content:'';display:block;width:0;height:0;position:absolute;top:-3px;left:50%;border:3px solid currentcolor;border-radius:50%&#125;@-webkit-keyframes loader-04&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-04&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-05&#123;border:5px solid transparent;border-top-color:currentcolor;border-radius:50%;-webkit-animation:1s loader-05 linear infinite;animation:1s loader-05 linear infinite;position:relative&#125;.loader-05:before&#123;content:'';display:block;width:inherit;height:inherit;position:absolute;top:-5px;left:-5px;border:5px solid currentcolor;border-radius:50%;opacity:.5;width:100%;padding-top:100%&#125;@-webkit-keyframes loader-05&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-05&#123;0%&#123;-webkit-transform:rotate(0deg);transform:rotate(0deg)&#125;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;.loader-06&#123;border:5px solid currentcolor;border-radius:50%;-webkit-animation:loader-06 1s ease-out infinite;animation:loader-06 1s ease-out infinite&#125;@-webkit-keyframes loader-06&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;@keyframes loader-06&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;.loader-07&#123;border:0 solid transparent;border-radius:50%;position:relative&#125;.loader-07:before,.loader-07:after&#123;content:'';border:5px solid currentcolor;border-radius:50%;width:inherit;height:inherit;position:absolute;top:0;left:0;-webkit-animation:loader-07 1s linear infinite;animation:loader-07 1s linear infinite;opacity:0;width:100%;height:100%&#125;.loader-07:before&#123;-webkit-animation-delay:1s;animation-delay:1s&#125;.loader-07:after&#123;-webkit-animation-delay:.5s;animation-delay:.5s&#125;@-webkit-keyframes loader-07&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;@keyframes loader-07&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0);opacity:0&#125;50%&#123;opacity:1&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;.loader-08&#123;position:relative&#125;.loader-08:before,.loader-08:after&#123;content:'';width:inherit;height:inherit;border-radius:50%;background-color:currentcolor;opacity:.6;position:absolute;top:0;left:0;-webkit-animation:loader-08 2.0s infinite ease-in-out;animation:loader-08 2.0s infinite ease-in-out;width:100%;height:100%&#125;.loader-08:after&#123;-webkit-animation-delay:-1.0s;animation-delay:-1.0s&#125;@-webkit-keyframes loader-08&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes loader-08&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125; &#125;.loader-09&#123;background-color:currentcolor;border-radius:50%;-webkit-animation:loader-09 1.0s infinite ease-in-out;animation:loader-09 1.0s infinite ease-in-out&#125;@-webkit-keyframes loader-09&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;@keyframes loader-09&#123;0%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;100%&#123;-webkit-transform:scale(1);transform:scale(1);opacity:0&#125;&#125;.loader-10&#123;position:relative;-webkit-animation:loader-10-1 2.0s infinite linear;animation:loader-10-1 2.0s infinite linear&#125;.loader-10:before,.loader-10:after&#123;content:'';width:0!important;height:0!important;border:15px solid currentcolor;display:block;position:absolute;border-radius:100%;-webkit-animation:loader-10-2 2s infinite ease-in-out;animation:loader-10-2 2s infinite ease-in-out&#125;.loader-10:before&#123;top:0;left:50%&#125;.loader-10:after&#123;bottom:0;right:50%;-webkit-animation-delay:-1s;animation-delay:-1s&#125;@-webkit-keyframes loader-10-1&#123;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@keyframes loader-10-1&#123;100%&#123;-webkit-transform:rotate(360deg);transform:rotate(360deg)&#125;&#125;@-webkit-keyframes loader-10-2&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes loader-10-2&#123;0%,100%&#123;-webkit-transform:scale(0);transform:scale(0)&#125;50%&#123;-webkit-transform:scale(1);transform:scale(1)&#125;&#125;.loader-11&#123;background-color:currentcolor;-webkit-animation:loader-11 1.2s infinite ease-in-out;animation:loader-11 1.2s infinite ease-in-out&#125;@-webkit-keyframes loader-11&#123;0%&#123;-webkit-transform:perspective(120px) rotateX(0deg) rotateY(0deg);transform:perspective(120px) rotateX(0deg) rotateY(0deg)&#125;50%&#123;-webkit-transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg);transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg)&#125;100%&#123;-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg);transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)&#125;&#125;@keyframes loader-11&#123;0%&#123;-webkit-transform:perspective(120px) rotateX(0deg) rotateY(0deg);transform:perspective(120px) rotateX(0deg) rotateY(0deg)&#125;50%&#123;-webkit-transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg);transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg)&#125;100%&#123;-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg);transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)&#125;&#125;.loader-12&#123;position:relative&#125;.loader-12:before,.loader-12:after&#123;content:'';display:block;position:absolute;background-color:currentcolor;left:50%;right:0;top:0;bottom:50%;box-shadow:-.5em 0 0 currentcolor;-webkit-animation:loader-12 1s linear infinite;animation:loader-12 1s linear infinite&#125;.loader-12:after&#123;top:50%;bottom:0;-webkit-animation-delay:.25s;animation-delay:.25s&#125;@-webkit-keyframes loader-12&#123;0%,100%&#123;box-shadow:-20px 0 0 transparent;background-color:currentcolor&#125;50%&#123;box-shadow:-20px 0 0 currentcolor;background-color:transparent&#125;&#125;@keyframes loader-12&#123;0%,100%&#123;box-shadow:-20px 0 0 transparent;background-color:currentcolor&#125;50%&#123;box-shadow:-20px 0 0 currentcolor;background-color:transparent&#125;&#125;`; nHead.appendChild(nStyle); &#125;JLoading.prototype.show = function() &#123; var nMask = document.getElementById('JLoading-mask-'+this.loadIndex); nMask.style.display = 'block';&#125;JLoading.prototype.hide = function() &#123; var nMask = document.getElementById('JLoading-mask-'+this.loadIndex); nMask.style.display = 'none';&#125; 使用见下面代码:12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;&lt;loading-test&gt;&lt;/loading-test&gt;&lt;/title&gt; &lt;script src=\"./loading-plug.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var mask1 = new JLoading(); mask1.init('loader-12'); setTimeout(() =&gt; &#123; mask1.show(); &#125;, 1000); setTimeout(() =&gt; &#123; mask1.hide(); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用不同的样式，需要在mask1.init(‘loader-12’)方法中传入名字，比如’loader-02’,具体的样式名字见下图:","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"window下flutter环境搭建","slug":"window下flutter环境搭建","date":"2019-08-26T01:26:38.000Z","updated":"2019-08-26T02:11:45.203Z","comments":true,"path":"2019/08/26/window下flutter环境搭建/","link":"","permalink":"/2019/08/26/window下flutter环境搭建/","excerpt":"flutter在window 10下的环境搭建","text":"flutter在window 10下的环境搭建 window下flutter环境搭建flutter是google出的一个跨平台移动端app开发框架，据说性能已经超过了原生开发，作为一名前端，即使不深入研究，也得浅浅的看一下这是个什么东西吧，所以今天记录一下flutter在win10下的安装步骤。 1.安装flutter去flutter官网下载flutter的压缩包，flutter官网地址,将压缩包解压到一个目录下，之后配置一下环境变量（这里不细说了，就是把bin目录配到系统的环境变量下），之后开启终端，运行flutter，第一次运行flutter需要去网络拉取资源，所以电脑必须得安装好了git，再有一点，由于防火墙的原因，拉取国外资源有时候不成功，所以在运行flutter之前最好配一下资源镜像路径：12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 这两句话最好在git bash下执行哦，之后就可以运行flutter初始化了。 这里注意一下，最好选择flutter的最新版本安装，因为下一步会安装android sdk，android会自动下载最新版本的，所以为了兼容，我在有的电脑中安装的flutter不是最新版本，andriod是最新的，出现了无法run的问题。 2.安装JDK由于是android开发，所以java的sdk是必不可少的，去java sdk下载，注意，一定要下载java SE 8u***版本的，其他版本不兼容，下载之后安装即可。 3.安装vs code以及flutter插件。4.安装android studio下载链接,下载好之后，一路下一步就可以，第一次安装需要下载android sdk，会下载很长时间，不过虽然有墙的存在，但是依然可以安装成功,如果不成功就多试几次。安装好了sdk后，软件就会自动打开，来到首页，也就是新建项目的地方，这时候可以安装android studio的flutter插件，第一次打开安装插件面板的时候会一直loading，最开始我还以为是墙的原因呢，不要着急，慢慢的等待即可。安装好了flutter插件后重启ide，重启后新建一个flutter项目，建好之后我们创建android虚拟机，点击tools-&gt;avd manager,创建一个虚拟机。创建虚拟机需要安装android的系统，非常的慢，慢慢等待吧。 有的电脑安装模拟器的时候会报HAXM的安装不上错误，这是因为win10默认开启了Hyer-V微软的虚拟机，只需到服务里把它关掉即可。 5.以上完成之后，打开命令行，运行flutter doctor,会有一段12Android toolchain - develop for Android devices (Android SDK version 29.0.2) X Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses 的提示，直接运行flutter doctor –android-licenses，一路y就可以。 如果顺利的话，现在就可以运行你的flutter项目了，我在自己的电脑上安装的很顺利，但是在公司的电脑上安装的很是肯可啊。 还需要注意下，有的电脑会让你升级android sdk，命令行会提示你具体的路径，里边是一个.bat的文件，不用担心，.bat和.exe一样的，在cmd下一样可以在后边传参数。如果你运行的是powerShell，注意一下，执行命令需要这样./manager.bat。再有，升级可能会删除tools文件夹再下载，不过win10不允许程序随意删除文件，这时候需要手动删除一下（改个名字更好）。 总结以上就是我在搭建flutter环境的时候遇到的一些状况。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"nw.js入门小结","slug":"nw-js入门小结","date":"2019-08-22T08:17:18.000Z","updated":"2019-08-23T01:21:03.007Z","comments":true,"path":"2019/08/22/nw-js入门小结/","link":"","permalink":"/2019/08/22/nw-js入门小结/","excerpt":"nw.js方便简单的pc端app开发工具","text":"nw.js方便简单的pc端app开发工具 nw.js入门小结nw.js和electron都是利用html来开发pc端应用的工具，今天我写一写nw.js的入门知识。 安装首先，去官网下载nw，官网地址,首页就可以看到下载地址，有两个下载，一个是normal,一个是sdk，见下图：sdk是有调试功能的，生成的应用，在上面点击右键可以看到类似浏览器F12的调试面板。normal就是没有调试功能的包，用于生产发布的时候用。下载后不需要安装，直接解压后就可以使用。 使用在nw的sdk包解压后的文件中，新建一个app文件夹，在app文件夹中放一个index.html的页面，再建一个package.json的文件，内容是：123456789101112131415161718192021222324252627282930&#123; \"fullscreen\": true, \"main\": \"index.html\", \"name\": \"layout\", \"description\": \"nw学习\", \"version\": \"0.1.0\", \"keywords\": [ \"指令学习\", \"在线\"], \"window\": &#123; \"title\": \"指令学习\", \"icon\": \"icon.png\", \"toolbar\": true, \"frame\": false, \"width\": 375, \"height\": 750, \"position\": \"center\", \"min_width\": 375, \"min_height\": 750, \"max_width\": 1920, \"max_height\": 1080, \"resizable\": true &#125;, \"webkit\": &#123; \"plugin\": false, \"java\": false, \"page-cache\": false &#125;, \"user-agent\": \"%name %ver %nwver %webkit_ver %osinfo\", \"chromium-args\": \"--allow-file-access-from-files\"&#125;// main属性是关键，指的是入口文件的位置 准备工作完毕，目录结构见下图：将app文件夹拖拽到nw.exe上即可打开应用进行开发调试。 打包发布如果开发完了之后，给别人用，就需要进行打包了。首先将app文件夹压缩，比如压缩成app.zip文件，之后改名为app.nw文件。打包需要在命令行下进行，打开cmd命令行（注意，这里只能用cmd，gitBash和powerShell都不好使哦），切换到当前目录，执行下面的命令:1copy /b nw.exe+app.nw app.exe 可以看到，app.exe就是打包出来的可执行文件，这时候直接点击它就可以运行程序了。 把这个app.exe文件复制到normal的运行文件夹下，也可以点击运行，这时其实就是一个绿色版的应用程序了，完全可以交付给客户使用了。 如果感觉一堆文件看起来不舒服，还可以使用enigmavirtualbox工具进行打包成一个.exe的文件，不过这个文件一般都比较大哦。 最后一种方法，innosetup工具，可以制作成安装版本，这样体积就小了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"前端静态资源服务器都用到了啥？","slug":"前端静态资源服务器都用到了啥？","date":"2019-08-22T06:45:46.000Z","updated":"2019-08-22T07:03:14.115Z","comments":true,"path":"2019/08/22/前端静态资源服务器都用到了啥？/","link":"","permalink":"/2019/08/22/前端静态资源服务器都用到了啥？/","excerpt":"前端都用到了哪些技术实现静态资源服务器","text":"前端都用到了哪些技术实现静态资源服务器 前端静态资源服务器都用到了啥？平时我们在开发的时候，肯定会自己架一个服务，把网页放进去，再跑，那么，我们平时都用到了哪些手段来实现呢？ http-server官网,使用起来很方便。 browser-sync官网,功能非常之强大。 nginx官网下载,nginx可是现在静态资源服务器中响应速度最快的了，如果在生产环境下，还是使用nginx吧。 apachenginx出来之前大家都用，现在基本上没人用了，淘汰掉。 webpack-dev这个其实是webpack的一个插件，我们在开发react，vue，angular的时候会用到它。 express&amp;koaexpress和koa中都有静态资源的中间件，用起来就是麻烦些。 nodejs最后就是可以利用nodejs的http模块手写一个静态资源服务器。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"移动端设置root font-size代码","slug":"移动端设置root-font-size代码","date":"2019-08-18T05:16:50.000Z","updated":"2019-08-18T05:19:07.887Z","comments":true,"path":"2019/08/18/移动端设置root-font-size代码/","link":"","permalink":"/2019/08/18/移动端设置root-font-size代码/","excerpt":"移动端设置html元素的font-size代码，方便使用rem","text":"移动端设置html元素的font-size代码，方便使用rem 移动端设置root font-size代码123456789101112(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth/20 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"一个页面loading小插件","slug":"一个页面loading小插件","date":"2019-08-18T04:44:28.000Z","updated":"2019-08-18T05:10:53.959Z","comments":true,"path":"2019/08/18/一个页面loading小插件/","link":"","permalink":"/2019/08/18/一个页面loading小插件/","excerpt":"移动端的loading小插件","text":"移动端的loading小插件 一个页面loading小插件这是一个移动端的loading蒙版，细节不说了，为了以后备用，直接上代码了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * @description 一个页面加载的loading小插件 * @description 注意，引用的时候一定要放到html文档的最后，因为需要向body插入内容，这里没有使用document的DOMContentLoaded，和window的loaded也是为了loading效果能够最快速的显示。 * @description 这里css用到了rem，需要注意。 * @method window.showLoadingEarth() 显示 * @method window.hideLoadingEarth() 隐藏 */(function(win) &#123; window.showLoadingEarth = function() &#123; nDiv.style.display = 'block'; &#125; window.hideLoadingEarth = function() &#123; nDiv.style.display = 'none'; &#125; var templateStr = `&lt;div class=\"loading-inner\"&gt; &lt;span class=\"dong\"&gt;&lt;/span&gt; &lt;strong class=\"dong\"&gt;&lt;/strong&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt;`; var cssStr = `#loading-earth &#123; display: none; position: absolute; width: 100%; height: 100%; top: 0; left: 0; background-color: rgba(0,0,0,.8); z-index: 999; &#125; #loading-earth .loading-inner &#123; width: 4rem; height: 4rem; /* background-color: #ffffff; */ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; #loading-earth .loading-inner span &#123; display: inline-block; width: 3.6rem; height: 3.6rem; background-image: url('data:image/png;base64,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'); background-size: 100% 100%; position: absolute; top: 0.2rem; left: 0.2rem; &#125; #loading-earth .loading-inner strong &#123; display: inline-block; width: 4.4rem; height: 4.4rem; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOwAAADsCAYAAAB300oUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MUIwQTYzQUE3QzY1MTFFOUI2MTBCNUY1MUM1NkE0N0IiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MUIwQTYzQTk3QzY1MTFFOUI2MTBCNUY1MUM1NkE0N0IiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTNDMUY2RDY2OTc3MTFFOUExOEY4RENGRjlFNzIwMzEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTNDMUY2RDc2OTc3MTFFOUExOEY4RENGRjlFNzIwMzEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz51xfIrAAAF60lEQVR42uzd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'); background-size: 100% 100%; position: absolute; top: -0.2rem; left: -0.2rem; /* transform: rotateZ(10deg); */ &#125; #loading-earth .loading-inner em &#123; display: inline-block; width: 2.4rem; height: 2.4rem; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABxCAYAAADifkzQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDEzMkZFRjg3QzY1MTFFOUExOTVEOEFCMTlCNUY3NjUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDEzMkZFRjc3QzY1MTFFOUExOTVEOEFCMTlCNUY3NjUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNCNTcyQTZGRjc1MTFFODhDMkFBOUYyRUM3RDc4QTYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNCNTcyQTdGRjc1MTFFODhDMkFBOUYyRUM3RDc4QTYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6mADWiAAAVBklEQVR42uxd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'); background-size: 100% 100%; position: absolute; top: 0.8rem; left: 0.8rem; &#125; #loading-earth .dong&#123; -webkit-animation:animations 2s linear infinite ; -moz-animation:animations 2s linear infinite ; -o-animation:animations 2s linear infinite ; -ms-animation:animations 2s linear infinite ; animation:animations 2s linear infinite ; &#125; @-webkit-keyframes animations&#123; 0%&#123;-webkit-transform:rotateZ(0deg)&#125; 10%&#123;-webkit-transform:rotateZ(36deg)&#125; 20%&#123;-webkit-transform:rotateZ(72deg)&#125; 30%&#123;-webkit-transform:rotateZ(108deg)&#125; 40%&#123;-webkit-transform:rotateZ(144eg)&#125; 50%&#123;-webkit-transform:rotateZ(180deg)&#125; 60%&#123;-webkit-transform:rotateZ(216deg)&#125; 70%&#123;-webkit-transform:rotateZ(252deg)&#125; 80%&#123;-webkit-transform:rotateZ(288deg)&#125; 90%&#123;-webkit-transform:rotateZ(324deg)&#125; 100%&#123;-webkit-transform:rotateZ(360deg)&#125; &#125;` // 创建div和style节点 var nDiv = document.createElement('div'), nStyle = document.createElement('style'); // 给div和style添加模板内容 nDiv.setAttribute('id', 'loading-earth'); nDiv.innerHTML = templateStr; nStyle.setAttribute('type', 'text/css'); nStyle.innerHTML = cssStr; // 获取head， body节点元素 var nBody = document.body, nHead = document.head; // 添加这两个节点元素 nHead.appendChild(nStyle); nBody.appendChild(nDiv);&#125;)(window)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"js中的valueOf和toString","slug":"js中的valueOf和toString","date":"2019-08-02T01:52:26.000Z","updated":"2019-08-02T02:09:39.167Z","comments":true,"path":"2019/08/02/js中的valueOf和toString/","link":"","permalink":"/2019/08/02/js中的valueOf和toString/","excerpt":"js中的valueOf和toString","text":"js中的valueOf和toString js中的valueOf和toStringvalueOf和toSring两个函数是除null和undefined两种数据类型以外其他五种数据类型（number/string/bool/object/symbol）原型链上共有的函数，那么这两个函数主要是用来干什么的呢？司徒正美大神给出的答案是：值运算和显示问题，一般在隐式类型转换时会自动调用(经典面试题见备注3)。 例1：如果同时重写了valueOf和toString方法：123456789101112131415161718var aaa = &#123; i: 10, valueOf: function() &#123; console.log('valueOf') return this.i+30; &#125;, toString: function() &#123; console.log('toString') return this.i+10; &#125;&#125; console.log(aaa &gt; 20); // valueOf true console.log('' + aaa); // valueOf 40 console.log(++aaa); // valueOf 41 console.log(+aaa); // valueOf 40 alert(aaa); // toString 20 console.log(aaa == 40) //valueOf true console.log(String(aaa)) // toString 20 总结：涉及到操作符的问题，valueOf的优先级比toString的优先级高，涉及到显示问题，toString方法优先级比valueOf方法高。 例2：如果只是重写了toString方法：1234567891011121314var aaa = &#123; i: 10, toString: function() &#123; console.log('toString') return this.i+10; &#125;&#125; console.log(aaa &gt; 20); // toString false console.log('' + aaa); // toString 20 console.log(++aaa); // toString 21 console.log(+aaa); // toSring 20 alert(aaa); // toString 20 console.log(aaa == 20) //toString true console.log(String(aaa)) // toString 20 总结：只重写了toString方法的话，toString方法比原型链上的valueOf方法优先级高。 例3如果只重写了valueOf方法：1234567891011121314var aaa = &#123; i: 10, valueOf: function() &#123; console.log('valueOf') return this.i+30; &#125;&#125; console.log(aaa &gt; 20); // valueOf true console.log('' + aaa); // valueOf 40 console.log(++aaa); // valueOf 41 console.log(+aaa); // valueOf 40 alert(aaa); // [object Object] console.log(aaa == 20) //valueOf false console.log(String(aaa)) // [object Object] 总结：只重写了valueOf方法的话，涉及到值运算优先调用valueOf方法，涉及到显示问题还是优先调用原型链上的toString方法。 备注针对一般没有对valueOf和toString方法进行重写的情况：1.对除null和undefined(这两种类型的原型上没有valueOf方法)以外的数据类型调用valueOf方法，得到的都是数据本身。12345678910111213141516171819var a = 1var aa = a.valueOf()aa === a //truevar b = 'a'var bb = b.valueOf()bb ===b //truevar c = truevar cc = c.valueOf()cc === c //truevar obj = &#123;name: 'age'&#125;var objobj = obj.valueOf()obj === objobj //truevar s = Symbol()var ss = s.valueOf()ss === s //true 2.对number/string/bool/symbol类型数据调用toString方法得到的是对应的字符串，对object类型数据调用toString的方法得到的是”[object Object]”，null和undefined两种数据类型的原型链上没有toString方法。12345var aaa = a.toString() // \"1\"var bbb = b.toString() // \"a\"var ccc = c.toString() // \"true\"var objobjobj = obj.toString() //\"[object Object]\"var sss = s.toString() //\"Symbol()\" 3.也可以得到一个经典前端面试题的一种解法,如何能够使得下列的表达式返回true1a==1 &amp;&amp; a==2 &amp;&amp; a==3 解法如下：1234567var a = &#123; i: 1, valueOf: function() &#123; return a.i++ &#125;&#125;a==1 &amp;&amp; a==2 &amp;&amp; a==3 //返回true 以上重写了valueOf函数，比较运算时会优先调用该函数。当然，如果重写toString方法的话，比较运算也会优先调用该toString函数，因此可以到达同样的效果。还有其他一种常见的解法：1234567var val = 1Object.defineProperty(window, 'a', &#123; get() &#123; return val++ &#125;&#125;)a==1 &amp;&amp; a==2 &amp;&amp; a==3 //同样返回true","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js读取和导出excel文件","slug":"js读取和导出excel文件","date":"2019-07-31T08:29:45.000Z","updated":"2019-08-01T07:22:35.159Z","comments":true,"path":"2019/07/31/js读取和导出excel文件/","link":"","permalink":"/2019/07/31/js读取和导出excel文件/","excerpt":"javascript对excel文件进行导入导出的处理","text":"javascript对excel文件进行导入导出的处理 js读取和导出excel文件js-xlsx 介绍由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。 官方github：https://github.com/SheetJS/js-xlsx 本文配套demo：点这里兼容性见下图：如何使用dist目录下有很多个JS文件，一般情况下用xlsx.core.min.js就够了，xlsx.full.min.js则是包含了所有功能模块。直接script标签引入即可：1&lt;script type=\"text/javascript\" src=\"./js/xlsx.core.min.js\"&gt;&lt;/script&gt; 读取excel读取excel主要是通过XLSX.read(data, {type: type});方法来实现，返回一个叫WorkBook的对象，type主要取值如下： base64: 以base64方式读取； binary: BinaryString格式(byte n is data.charCodeAt(n)) string: UTF8编码的字符串； buffer: nodejs Buffer； array: Uint8Array，8位无符号数组； file: 文件的路径（仅nodejs下支持）； 获取workbook对象读取本地文件12345678910// 读取本地excel文件function readWorkbookFromLocalFile(file, callback) &#123; var reader = new FileReader(); reader.onload = function(e) &#123; var data = e.target.result; var workbook = XLSX.read(data, &#123;type: 'binary'&#125;); if(callback) callback(workbook); &#125;; reader.readAsBinaryString(file);&#125; 读取网络文件1234567891011121314// 从网络上读取某个excel文件，url必须同域，否则报错function readWorkbookFromRemoteFile(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = function(e) &#123; if(xhr.status == 200) &#123; var data = new Uint8Array(xhr.response) var workbook = XLSX.read(data, &#123;type: 'array'&#125;); if(callback) callback(workbook); &#125; &#125;; xhr.send();&#125; 详解 workbookWorkbook Objectworkbook里面有什么东西呢，我们打印出来看一下：可以看到，SheetNames里面保存了所有的sheet名字，然后Sheets则保存了每个sheet的具体内容（我们称之为Sheet Object）。每一个sheet是通过类似A1这样的键值保存每个单元格的内容，我们称之为单元格对象（Cell Object）： Sheet Object每一个Sheet Object表示一张表格，只要不是!开头的都表示普通cell，否则，表示一些特殊含义，具体如下： sheet[‘!ref’]：表示所有单元格的范围，例如从A1到F8则记录为A1:F8； sheet[!merges]：存放一些单元格合并信息，是一个数组，每个数组由包含s和e构成的对象组成，s表示开始，e表示结束，r表示行，c表示列； 等等； 关于单元格合并，看懂下面这张图基本上就没问题了：结果如下： 单元格对象每一个单元格是一个对象（Cell Object），主要有t、v、r、h、w等字段（详见这里）： t：表示内容类型，s表示string类型，n表示number类型，b表示boolean类型，d表示date类型，等等 v：表示原始值； f：表示公式，如B2+B3； h：HTML内容 w：格式化后的内容 r：富文本内容rich text 等等 读取workbook普通方法：1234567891011// 读取 excel文件function outputWorkbook(workbook) &#123; var sheetNames = workbook.SheetNames; // 工作表名称集合 sheetNames.forEach(name =&gt; &#123; var worksheet = workbook.Sheets[name]; // 只能通过工作表名称来获取指定工作表 for(var key in worksheet) &#123; // v是读取单元格的原始值 console.log(key, key[0] === '!' ? worksheet[key] : worksheet[key].v); &#125; &#125;);&#125; 根据!ref确定excel的范围，再根据!merges确定单元格合并（如果有），最后输出整个table，比较麻烦，幸运的是，插件自身已经写好工具类XLSX.utils给我们直接使用，无需我们自己遍历，工具类输出主要包括如下：有些不常用，常用的主要是： XLSX.utils.sheet_to_csv：生成CSV格式 XLSX.utils.sheet_to_txt：生成纯文本格式 XLSX.utils.sheet_to_html：生成HTML格式 XLSX.utils.sheet_to_json：输出JSON格式 常用的主要是sheet_to_csv或者sheet_to_html，转csv的话会忽略格式、单元格合并等信息，所以复杂表格可能不适用。转html的话会保留单元格合并，但是生成的是12345678910111213141516171819202122232425262728293031323334``` javascriptfunction readWorkbook(workbook)&#123; var sheetNames = workbook.SheetNames; // 工作表名称集合 var worksheet = workbook.Sheets[sheetNames[0]]; // 这里我们只读取第一张sheet var csv = XLSX.utils.sheet_to_csv(worksheet); document.getElementById(&apos;result&apos;).innerHTML = csv2table(csv);&#125;// 将csv转换成简单的表格，会忽略单元格合并，在第一行和第一列追加类似excel的索引function csv2table(csv)&#123; var html = &apos;&lt;table&gt;&apos;; var rows = csv.split(&apos;\\n&apos;); rows.pop(); // 最后一行没用的 rows.forEach(function(row, idx) &#123; var columns = row.split(&apos;,&apos;); columns.unshift(idx+1); // 添加行索引 if(idx == 0) &#123; // 添加列索引 html += &apos;&lt;tr&gt;&apos;; for(var i=0; i&lt;columns.length; i++) &#123; html += &apos;&lt;th&gt;&apos; + (i==0?&apos;&apos;:String.fromCharCode(65+i-1)) + &apos;&lt;/th&gt;&apos;; &#125; html += &apos;&lt;/tr&gt;&apos;; &#125; html += &apos;&lt;tr&gt;&apos;; columns.forEach(function(column) &#123; html += &apos;&lt;td&gt;&apos;+column+&apos;&lt;/td&gt;&apos;; &#125;); html += &apos;&lt;/tr&gt;&apos;; &#125;); html += &apos;&lt;/table&gt;&apos;; return html;&#125; 导出excel导出分为2种，一种是基于现有excel修改，一种是全新生成，前者比较简单，我们这里着重讲后者。 自己手写代码生成导出excel文件，主要是如何生成一个sheet，我们这里写一个最简单的csv转excel示例：123456789101112131415161718192021222324252627282930313233343536373839// csv转sheet对象function csv2sheet(csv) &#123; var sheet = &#123;&#125;; // 将要生成的sheet csv = csv.split('\\n'); csv.forEach(function(row, i) &#123; row = row.split(','); if(i == 0) sheet['!ref'] = 'A1:'+String.fromCharCode(65+row.length-1)+(csv.length-1); row.forEach(function(col, j) &#123; sheet[String.fromCharCode(65+j)+(i+1)] = &#123;v: col&#125;; &#125;); &#125;); return sheet;&#125;// 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载function sheet2blob(sheet, sheetName) &#123; sheetName = sheetName || 'sheet1'; var workbook = &#123; SheetNames: [sheetName], Sheets: &#123;&#125; &#125;; workbook.Sheets[sheetName] = sheet; // 生成excel的配置项 var wopts = &#123; bookType: 'xlsx', // 要生成的文件类型 bookSST: false, // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: 'binary' &#125;; var wbout = XLSX.write(workbook, wopts); var blob = new Blob([s2ab(wbout)], &#123;type:\"application/octet-stream\"&#125;); // 字符串转ArrayBuffer function s2ab(s) &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF; return buf; &#125; return blob;&#125; 拿到上面的blob对象就可以直接下载了，参考我之前在JS弹出下载对话框里面封装好的openDownloadDialog方法：1234567891011121314151617181920212223/** * 通用的打开下载对话框方法，没有测试过具体兼容性 * @param url 下载地址，也可以是一个blob对象，必选 * @param saveName 保存文件名，可选 */function openDownloadDialog(url, saveName)&#123; if(typeof url == 'object' &amp;&amp; url instanceof Blob) &#123; url = URL.createObjectURL(url); // 创建blob地址 &#125; var aLink = document.createElement('a'); aLink.href = url; aLink.download = saveName || ''; // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效 var event; if(window.MouseEvent) event = new MouseEvent('click'); else &#123; event = document.createEvent('MouseEvents'); event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); &#125; aLink.dispatchEvent(event);&#125; 所以，最终下载实现如下：123456// 传入csv，执行后就会弹出下载框function exportExcel(csv) &#123; var sheet = csv2sheet(csv); var blob = sheet2blob(sheet); openDownloadDialog(blob, '导出.xlsx')；&#125; 利用官方工具类生成其实上面这些代码都不需要我们手写，官方已经提供好了现成的工具类给我们使用，主要包括： aoa_to_sheet: 这个工具类最强大也最实用了，将一个二维数组转成sheet，会自动处理number、string、boolean、date等类型数据； table_to_sheet: 将一个table dom直接转成sheet，会自动识别colspan和rowspan并将其转成对应的单元格合并； json_to_sheet: 将一个由对象组成的数组转成sheet； aoa_to_sheet示例：1234567var aoa = [ ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()]];var sheet = XLSX.utils.aoa_to_sheet(aoa);openDownloadDialog(sheet2blob(sheet), '导出.xlsx'); table_to_sheet就更简单了，直接XLSX.utils.table_to_sheet($(‘table’)[0])即可； 处理单元格合并一般来说，前端生成excel而不是csv最主要目的都是为了解决csv不能实现单元格合并的问题，要不然直接导出csv文件就好了，何必引入几百kb的插件。假设我们要生成如下格式的excel文件，其中A1-C1进行单元格合并：代码如下：123456789101112var aoa = [ ['主要信息', null, null, '其它信息'], // 特别注意合并的地方后面预留2个null ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()]];var sheet = XLSX.utils.aoa_to_sheet(aoa);sheet['!merges'] = [ // 设置A1-C1的单元格合并 &#123;s: &#123;r: 0, c: 0&#125;, e: &#123;r: 0, c: 2&#125;&#125;];openDownloadDialog(sheet2blob(sheet), '单元格合并示例.xlsx'); 需要注意的地方就是被合并的单元格要用null预留出位置，否则后面的内容（本例中是第四列其它信息）会被覆盖。 自定义样式普通版本不支持定义字体、颜色、背景色等，有这个功能需要的可以使用pro版，好像是要收费的，因为官网没看到下载地址。 总结上面的代码在上传本地excel文件转换时候没什么问题，但是在用ajax请求的excel文件在转换时，chrome浏览器报错，firefox和opera正常。我觉得问题出在我是用的excel的版本上，我在网上下载的excel文件就可以正常解析，这里要注意哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"ES6-Symbol.iterator 迭代器","slug":"ES6-Symbol-iterator-迭代器","date":"2019-07-30T08:51:28.000Z","updated":"2019-07-30T09:06:25.685Z","comments":true,"path":"2019/07/30/ES6-Symbol-iterator-迭代器/","link":"","permalink":"/2019/07/30/ES6-Symbol-iterator-迭代器/","excerpt":"ES6-Symbol.iterator 迭代器原理剖析","text":"ES6-Symbol.iterator 迭代器原理剖析 ES6-Symbol.iterator 迭代器一个数据结构只要部署了Symbol.iterator属性就能使用 for…of遍历 与 …运算符 操作Object身上没有Symbol.iterator，当直接使用时会报错123456789let obj = &#123; 0: 'a', 1: 'b', 2: 'c',&#125;console.log([...obj])//报错obj is not iterable &lt;br&gt; 在没有Symbol.iterator方法下运行for(let p of obj)&#123; console.log(p);//TypeError: obj is not iterable&#125; Array身上天生具备Symbol.iterator123let arr = [1,2,3,4];// 数组，天生具备Symbol.iterator方法所以可以使用console.log([...arr]);//(4) [1, 2, 3, 4] 而我们Object需要用到…运算符 与 for of遍历怎么办呢如果我们要使用它的话，Object身上需要有一个Symbol.iterator属性代码如下：123456789101112131415161718192021222324let obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: function () &#123; // index用来记遍历圈数 let index = 0; let next = () =&gt; &#123; return &#123; value: this[index], done: this.length == ++index &#125; &#125; return &#123; next &#125; &#125;&#125;// console.log(obj.length)console.log([...obj]);//(2) [\"a\", \"b\"]for(let p of obj)&#123; console.log(p) //\"a\" \"b\"&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端touch事件简介","slug":"移动端touch事件简介","date":"2019-07-30T06:11:43.000Z","updated":"2019-07-30T06:30:12.252Z","comments":true,"path":"2019/07/30/移动端touch事件简介/","link":"","permalink":"/2019/07/30/移动端touch事件简介/","excerpt":"移动端的touch事件的简单入门介绍","text":"移动端的touch事件的简单入门介绍 移动端touch事件简介touch事件首先 touch 包含三类事件，它们分别是：touchstart、touchmove、touchend 。 touchstart：手指触摸到一个 DOM 元素时触发。 touchmove：手指在一个 DOM 元素上滑动时触发。 touchend：手指从一个 DOM 元素上移开时触发。 这三个事件又分别对应三个相同的触摸列表： touches：正在触摸屏幕的所有手指的一个列表。 targetTouches：正在触摸当前 DOM 元素上的手指的一个列表。 changedTouches：涉及当前事件的手指的一个列表。 touch事件属性事件对应的三个列表虽然名字不一样，但是它们里面装的东西都是差不多的，包含了当前事件的一些相关信息，比如：一些坐标信息。1234567891011clientX:65 // 触摸点在浏览器窗口中的横坐标clientY:18 // 触摸点在浏览器窗口中的纵坐标force:1 // 触摸点压力大小identifier:0 // 触摸点唯一标识（ID）pageX:65 // 触摸点在页面中的横坐标pageY:18 // 触摸点在页面中的纵坐标radiusX:11.5 // 触摸点椭圆的水平半径radiusY:11.5 // 触摸点椭圆的垂直半径rotationAngle:0 // 旋转角度screenX:560 // 触摸点在屏幕中的横坐标screenY:175 // 触摸点在屏幕中的纵坐标 上面就是一个 TouchList 列表。它对应的就是前面提到的三种事件（touchstart、touchmove、touchend）中的一种，在触发时生成的一个对象列表。列表里最有用的就是 Touch 对象了，Touch 对象里存放着对应事件的一些相关的信息，我们就是通过这种个事件里这些属性的有机结合来实现各种效果。通过上面的 radiusX，radiusY，rotationAngle 这三个属性就可以计算出你的手指触摸手机屏幕时的一个接触面，只不过这个接触面是用一个近似的椭圆来表示，也就是说它不是一个真正意义上的接触面，而是一个大概的接触面。相信心细的朋友应该会看到 TouchList 对象里有一个 length 属性，并且它的值为 1 ，这说明当前只有一个手指触发了事件（比如：touchstart 事件），换句话说，此时你只有一个手指放到了手机屏幕上，这个手指对应的一些信息存放在 Touch 对象里。因为只有一个手指放在了屏幕上，所以这个 TouchList 里只有一个 Touch 对象，并且是第一个下标为 0 。TouchList 列表里还有一个 target 属性，这个应该很好理解，就是触摸的目标。为了让你能更加立体地理解上面的这些属性，我专门从网上找了一段话来作为补充： 来自 mozilla 1.Touch.identifier：此 Touch 对象的唯一标识符。 一次触摸动作(我们指的是手指的触摸)在平面上移动的整个过程中，该标识符不变。 可以根据它来判断跟踪的是否是同一次触摸过程，此值为只读属性。 2.Touch.screenX：触点相对于屏幕左边沿的X坐标。只读属性。 3.Touch.screenY：触点相对于屏幕上边沿的Y坐标。只读属性。 4.Touch.clientX：触点相对于可见视区(visual viewport)左边沿的X坐标。不包括任何滚动偏移。只读属性。 5.Touch.clientY：触点相对于可见视区(visual viewport)上边沿的Y坐标。不包括任何滚动偏移。只读属性。 6.Touch.pageX：触点相对于HTML文档左边沿的X坐标。当存在水平滚动的偏移时，这个值包含了水平滚动的偏移。只读属性。 7.Touch.pageY：触点相对于HTML文档上边沿的Y坐标。当存在水平滚动的偏移时，这个值包含了垂直滚动的偏移。只读属性。 8.Touch.radiusX：能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴)半径。这个值的单位和 screenX 相同。只读属性。 9.Touch.radiusY：能够包围用户和触摸平面的接触面的最小椭圆的垂直轴(Y轴)半径。这个值的单位和 screenY 相同。只读属性。 10.Touch.rotationAngle：它是这样一个角度值：由radiusX 和 radiusY描述的正方向的椭圆，需要通过顺时针旋转这个角度值，才能最精确地覆盖住用户和触摸平面的接触面。只读属性。 11.Touch.force：手指挤压触摸平面的压力大小，从0.0(没有压力)到1.0(最大压力)的浮点数。只读属性。 12.Touch.target：当这个触点最开始被跟踪时(在 touchstart 事件中)，触点位于的HTML元素。哪怕在触点移动过程中，触点的位置已经离开了这个元素的有效交互区域，或者这个元素已经被从文档中移除。需要注意的是，如果这个元素在触摸过程中被移除，这个事件仍然会指向它，但是不会再冒泡这个事件到 window 或 document 对象。因此，如果有元素在触摸过程中可能被移除，最佳实践是将触摸事件的监听器绑定到这个元素本身，防止元素被移除后，无法再从它的上一级元素上侦测到从该元素冒泡的事件。只读属性。 总结这里只是简单地介绍了一下移动端的touch事件，主要还是记住touchstart，touchmove，touchend这三个事件，还有事件里的touches，targetTouches，changedTouches这三个属性，我们尝试用的还是targetTouches,touches的兼容性不好，一般我们不使用。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"你真的了解回流和重绘吗?","slug":"你真的了解回流和重绘吗","date":"2019-07-29T08:03:47.000Z","updated":"2019-07-29T08:39:36.837Z","comments":true,"path":"2019/07/29/你真的了解回流和重绘吗/","link":"","permalink":"/2019/07/29/你真的了解回流和重绘吗/","excerpt":"你真的了解回流和重绘吗","text":"你真的了解回流和重绘吗 你真的了解回流和重绘吗回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是我之前一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合一些例子，写了这篇文章，希望可以帮助到大家。 浏览器的渲染过程本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自MDN） 从上面这个图上，我们可以看到，浏览器渲染过程如下： 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客） 渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。 生成渲染树 为了构建渲染树，浏览器主要完成了以下工作： 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 注意：渲染树只包含可见的节点 回流前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"width: 50%\"&gt; &lt;div style=\"width: 50%\"&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图） 重绘最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。 既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。 何时发生回流重绘我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 注意：回流一定会触发重绘，而重绘不一定会回流 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 浏览器的优化机制现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 减少回流和重绘好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。 最小化重绘和重排由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子 1234const el = document.getElementById('test');el.style.padding = '5px';el.style.borderLeft = '1px';el.style.borderRight = '2px'; 例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。 因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式： 使用cssText 12const el = document.getElementById('test');el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; 修改CSS的class 12const el = document.getElementById('test');el.className += ' active'; 批量修改DOM当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。 有三种方式可以让DOM脱离文档流： 隐藏元素，应用修改，重新显示 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 考虑我们要执行一段批量插入节点的代码： 1234567891011function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');appendDataToElement(ul, data); 如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。 我们可以使用这三种方式进行优化: 隐藏元素，应用修改，重新显示 这个会在展示和隐藏节点的时候，产生两次重绘 123456789101112function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档 1234const ul = document.getElementById('list');const fragment = document.createDocumentFragment();appendDataToElement(fragment, data);ul.appendChild(fragment); 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 1234const ul = document.getElementById('list');const clone = ul.cloneNode(true);appendDataToElement(clone, data);ul.parentNode.replaceChild(clone, ul); 对于上述那种情况，我写了一个demo来测试修改前和修改后的性能。然而实验结果不是很理想。 原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。 避免触发同步布局事件上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码： 12345function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px'; &#125;&#125; 这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为: 123456const width = box.offsetWidth;function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px'; &#125;&#125; 同样，我也写了个demo来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比差距就比较明显。 对于复杂动画效果,使用绝对定位让其脱离文档流对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个例子。 打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。 从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。 css3硬件加速（GPU加速）比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！ 划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。 如何使用常见的触发硬件加速的css属性： transform opacity filters Will-change 效果我们可以先看个例子。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图： 从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。 重点 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 css3硬件加速的坑 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 总结本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。 参考文献 渲染树构建、布局及绘制 高性能Javascript 文章出处-&gt;博客地址, 欢迎给个 start 或 follow","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"模块化CommonJS与AMD的手写实现","slug":"模块化CommonJS与AMD的手写实现","date":"2019-07-24T08:34:06.000Z","updated":"2019-07-24T09:09:10.064Z","comments":true,"path":"2019/07/24/模块化CommonJS与AMD的手写实现/","link":"","permalink":"/2019/07/24/模块化CommonJS与AMD的手写实现/","excerpt":"javascript模块化CommonJS与AMD是如何实现的","text":"javascript模块化CommonJS与AMD是如何实现的 模块化CommonJS与AMD的手写实现现在的前端开发都采用的模块化思想，之前都是使用全局变量，但是弊端这里就不过多描述了。模块化有CommonJS,AMD,CMD,ES6的模块新规范这4种，今天我们来实现以下CommonJS和AMD的规范。 CommonJS首先，CommonJS一般都用在nodejs里，写法如下:12345// 导入const someFun= require('./moduleA');someFun();// 导出module.exports = someFunc; 我们来看一下简单的实现方法123456789101112131415161718// a.jslet fs = require('fs');let path = require('path');let b = req('./b.js');function req(mod) &#123; let filename = path.join(__dirname, mod); let content = fs.readFileSync(filename, 'utf8'); let fn = new Function('exports', 'require', 'module', '__filename', '__dirname', content + '\\n return module.exports;'); let module = &#123; exports: &#123;&#125; &#125;; return fn(module.exports, req, module, __filename, __dirname);&#125;// b.jsconsole.log('bbb');exports.name = 'zfpx'; AMD我们再来看看AMD规范，AMD规范的实现库是大名鼎鼎requirejs1234567891011// 定义一个模块define('a', [], function () &#123; return 'a';&#125;);define('b', ['a'], function (a) &#123; return a + 'b';&#125;);// 导入和使用require(['b'], function (b) &#123; console.log(b);&#125;); 简单的实现1234567891011121314151617let factories = &#123;&#125;;function define(modName, dependencies, factory) &#123; factory.dependencies = dependencies; factories[modName] = factory;&#125;function require(modNames, callback) &#123; let loadedModNames = modNames.map(function (modName) &#123; let factory = factories[modName]; let dependencies = factory.dependencies; let exports; require(dependencies, function (...dependencyMods) &#123; exports = factory.apply(null, dependencyMods); &#125;); return exports; &#125;) callback.apply(null, loadedModNames);&#125; ES6 模块化ES6 模块化是ECMA提出的JavaScript模块化规范，它在语言的层面上实现了模块化。浏览器厂商和Node.js 都宣布要原生支持该规范。它将逐渐取代CommonJS和AMD`规范，成为浏览器和服务器通用的模块解决方案。 采用 ES6 模块化导入及导出时的代码如下1234// 导入import &#123; name &#125; from './person.js';// 导出export const name = 'zfpx'; ES6模块虽然是终极模块化方案，但它的缺点在于目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"javascript的FileReader类","slug":"javascript的FileReader类","date":"2019-07-24T06:23:49.000Z","updated":"2019-10-29T03:26:56.590Z","comments":true,"path":"2019/07/24/javascript的FileReader类/","link":"","permalink":"/2019/07/24/javascript的FileReader类/","excerpt":"javascript的FileReader类","text":"javascript的FileReader类 javascript的FileReader类2019-07-24内容现在，我们在前端对文件处理的需求已经慢慢增加了，比如，前端上传图片的回显，还有excel文件的解析等，都需要FileReader这个类来实现，这个类有4个方法: FileReader.readAsBinaryString(Blob|File) FileReader.readAsText(Blob|File, opt_encoding) FileReader.readAsDataURL(Blob|File) FileReader.readAsArrayBuffer(Blob|File) 这里，具体的使用方法不过多介绍，详情点击这里 2019-10-29追加内容readAsArrayBuffer=&gt;ArrayBuffer二进制数据的存储器,可通过ArrayBufferView以8位、16位、32位、64位数字为元素对ArrayBuffer内的二进制数据进行展现。可用于生成Blob,然后添加到FormData去上传。 readAsBinaryString =&gt;BinaryString是二进制数据直接以byte的形式展现的字符串,ArrayBuffer对应的Uint8Array的字符形式的表现 readAsDataURL =&gt;DataURL包括mimeType和base64编码后的binaryString,可以直接给使用：data:[mimeType];base64,[base64(binaryString)]可借此获取mimeType和binaryStringvar binaryString = atob(dataUrl.split(‘,’)[1]),mimeType = dataUrl.split(‘,’)[0].match(/:(.*?);/)[1]; 说一个截图上传的小例子 canvas截图并使用toDataURL,获取DataURL 通过binaryString = atob(dataUrl.split(‘,’)[1])获取BinaryString 通过Uint8Array和charCodeAt把binaryString转化为ArrayBuffer ArrayBuffer存入Blob并添加到FormData上传,服务器最终收到BinaryString 注意,formdata在send时必须使用ArrayBuffer,因为BinaryString为字符串,当send发送时会对字符串进行utf8编码导致数据被破坏。demo:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name='test'&gt; &lt;input type=\"file\" name='file'&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;img src=\"\" alt=\"\"&gt; &lt;script&gt; var img = document.querySelector('img'), preview; document.test.file.addEventListener('change', function() &#123; var fr = new FileReader(); fr.onload = function() &#123; preview = this.result; img.src = preview; &#125;; fr.readAsDataURL(this.files[0]); &#125;) document.test.addEventListener('submit', function(e) &#123; e.preventDefault(); var binaryString = atob(preview.split(',')[1]), mimeType = preview.split(',')[0].match(/:(.*?);/)[1], length = binaryString.length, u8arr = new Uint8Array(length), blob, fd = new FormData(), xhr = new XMLHttpRequest(); while(length--) &#123; u8arr[length] = binaryString.charCodeAt(length); &#125; blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;); fd.append('file', blob); xhr.open('post', '/upload'); xhr.send(fd); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端利用hammer制作移动缩放旋转功能","slug":"移动端利用hammer制作移动缩放旋转功能","date":"2019-07-16T01:43:08.000Z","updated":"2019-07-16T02:33:28.704Z","comments":true,"path":"2019/07/16/移动端利用hammer制作移动缩放旋转功能/","link":"","permalink":"/2019/07/16/移动端利用hammer制作移动缩放旋转功能/","excerpt":"移动端利用hammer制作移动缩放旋转功能","text":"移动端利用hammer制作移动缩放旋转功能 移动端利用hammer制作移动缩放旋转功能最近在项目中，有个需求是页面放大，我二话不说，直接把viewport的user-scalable属性设为yes，这倒是勉强的完成了需求的要求，但是这只是整个页面的缩放，而且初始上来的页面只能放大，并不能缩小，如果再加点需求，局部放大，这就挂了。。。。。。于是乎，这几天有空闲的时候补了补关于移动端手势事件的一些知识，为了完成这几项功能，最终选了hammer这个插件，其实这类插件很多，大同小异，选一个稳定点，普及广的，还在维护的就行。当然了，不用插件，自己用原生的touchstart,touchmove,touchend事件也可以完成，但是各种算法还是很复杂的。下面是几个例子： 元素的缩放123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./hammer.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"./vconsole.min.js\"&gt;&lt;/script&gt; --&gt; &lt;style&gt; #myElement &#123; background: silver; height: 300px; text-align: center; font: 30px/300px Helvetica, Arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myElement\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // var vConsole = new VConsole(); var scale = 1, old_scale; var myElement = document.getElementById('myElement'); var mc = new Hammer.Manager(myElement); // pinch var pinch = new Hammer.Pinch(); // add to the Manager mc.add([pinch]); // pinch事件 mc.on(\"pinchstart\", function(ev) &#123; // 注意这里1 old_scale = scale; &#125;); mc.on(\"pinchmove\", function(ev) &#123; // 注意这里2 scale =ev.scale + old_scale-1; // myElement.style.transform = `scale($&#123;scale&#125;)`; updateTransform(); &#125;); // 更新样式函数 function updateTransform() &#123; var val = [ `scale($&#123;scale&#125;)` // `rotate(`+deg+`deg)` ]; myElement.style.transform = val.join(' '); &#125;&lt;/script&gt;&lt;/html&gt; 元素的旋转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./hammer.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"./vconsole.min.js\"&gt;&lt;/script&gt; --&gt; &lt;style&gt; #myElement &#123; background: silver; height: 300px; text-align: center; font: 30px/300px Helvetica, Arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myElement\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // var vConsole = new VConsole(); var deg = 0, init_deg=0, rotate_deg, start_deg, pre_deg, flag_deg; var myElement = document.getElementById('myElement'); var mc = new Hammer.Manager(myElement); // rotate var rotate = new Hammer.Rotate(); // add to the Manager mc.add([rotate]); // rotate事件 mc.on(\"rotatestart\", function(ev) &#123; // 注意这里1 start_deg = ev.rotation; // 开始旋转时记录下当前rotation的角度 flag_deg = 0; &#125;); mc.on(\"rotatemove\", function(ev) &#123; // 注意这里2 rotate_deg = ev.rotation - start_deg; // rotation的角度减去开始旋转的角度就是转过了多少角度 deg = init_deg + rotate_deg; // 元素旋转之前的角度 + 旋转了多少角度是当前元素的状态 // myElement.style.transform = `rotate(`+deg+`deg)`; updateTransform(); &#125;); mc.on(\"rotateend\", function(ev) &#123; // 注意这里3 init_deg = deg; // 旋转结束时别忘了把当前角度状态赋值给初始化角度，以便下次旋转时接着上次的角度转 &#125;); // 更新样式函数 function updateTransform() &#123; var val = [ // `scale($&#123;scale&#125;)` `rotate(`+deg+`deg)` ]; myElement.style.transform = val.join(' '); &#125;&lt;/script&gt;&lt;/html&gt; 最后，附上一个拖拽，缩放，旋转的 拖拽，缩放，旋转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./hammer.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"./vconsole.min.js\"&gt;&lt;/script&gt; --&gt; &lt;style&gt; #myElement &#123; background: silver; width: 250px; height: 250px; text-align: center; font: 30px/300px Helvetica, Arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myElement\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var reqAnimationFrame = (function () &#123; return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;; &#125;)(); var el = document.querySelector(\"#myElement\"); var START_X = Math.round((window.innerWidth - el.offsetWidth) / 2); var START_Y = Math.round((window.innerHeight - el.offsetHeight) / 2); var ticking = false; var transform; //图像效果 var timer; var initAngle = 0; //旋转角度 var initScale = 1; //放大倍数 var mc = new Hammer.Manager(el); //用管理器 可以同时触发旋转 拖拽 移动 //var mc = new Hammer(el); //旋转和移动互斥 /** ev.srcEvent.type touchstart touchend touchmove ev.deltaX 手势移动位移变量 */ mc.add(new Hammer.Pan(&#123; threshold: 0, pointers: 0 &#125;)); mc.add(new Hammer.Rotate(&#123; threshold: 0 &#125;)).recognizeWith(mc.get('pan')); mc.add(new Hammer.Pinch(&#123; threshold: 0 &#125;)).recognizeWith([mc.get('pan'), mc.get('rotate')]); //结束时做一些处理 mc.on(\"hammer.input\", function(ev) &#123; if(ev.isFinal) &#123; console.log(START_X+\" \"+transform.translate.x +\" \"+ev.deltaX); START_X = transform.translate.x ; START_Y = transform.translate.y ; &#125; &#125;); mc.on(\"panstart panmove\", onPan); mc.on(\"rotatestart rotatemove rotateend\", onRotate); mc.on(\"pinchstart pinchmove\", onPinch); /** 第二次进入拖拽时 delta位移重置 移动时 初始位置startxy不动。delta增加 */ function onPan(ev)&#123; if(!ev.isFinal) &#123; el.className = ''; console.log(START_X +\" \"+ START_Y +\" | \"+ev.deltaX +\" \"+ ev.deltaY); transform.translate = &#123; x: START_X + ev.deltaX, y: START_Y + ev.deltaY &#125;; requestElementUpdate(); &#125; &#125; function onPinch(ev)&#123; if(ev.type == 'pinchstart') &#123; initScale = transform.scale || 1; &#125; el.className = ''; transform.scale = initScale * ev.scale; requestElementUpdate(); &#125; //旋转相关 var preAngle =0 ; var tempAngleFlag=0; var deltaAngle = 0; var startRotateAngle = 0; function onRotate(ev) &#123; //点下第二个触控点时触发 if(ev.type == 'rotatestart') &#123; startRotateAngle = ev.rotation ; tempAngleFlag = 0 ; &#125; if(ev.type == 'rotatemove')&#123; if(tempAngleFlag == 0)&#123; preAngle = startRotateAngle; tempAngleFlag ++; &#125;else&#123; deltaAngle = ev.rotation - preAngle; el.className = ''; transform.rz = 1; //非0 垂直xy轴 transform.angle =initAngle + deltaAngle; requestElementUpdate(); &#125; &#125; //旋转结束 记录当前图片角度 if(ev.type =='rotateend')&#123; initAngle = transform.angle; &#125; &#125; function updateElementTransform() &#123; var value = [ 'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)', 'scale(' + transform.scale + ', ' + transform.scale + ')', 'rotate3d('+ transform.rx +','+ transform.ry +','+ transform.rz +','+ transform.angle + 'deg)' ]; value = value.join(\" \"); el.style.webkitTransform = value; /*为Chrome/Safari*/ el.style.mozTransform = value; /*为Firefox*/ el.style.transform = value; /*IE Opera?*/ ticking = false; &#125; function requestElementUpdate() &#123; if(!ticking) &#123; reqAnimationFrame(updateElementTransform); ticking = true; &#125; &#125; /** 初始化设置 */ function resetElement() &#123; el.className = 'animate'; transform = &#123; translate: &#123; x: START_X, y: START_Y &#125;, scale: 1, angle: 0, rx: 0, ry: 0, rz: 0 &#125;; requestElementUpdate(); &#125; resetElement();&lt;/script&gt;&lt;/html&gt; 最后，附上github源码地址，点这里","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}]},{"title":"实现一个串行异步执行类","slug":"实现一个串行异步执行类","date":"2019-07-08T05:56:34.000Z","updated":"2019-07-08T06:12:19.392Z","comments":true,"path":"2019/07/08/实现一个串行异步执行类/","link":"","permalink":"/2019/07/08/实现一个串行异步执行类/","excerpt":"写一个按顺序执行操作的类工具","text":"写一个按顺序执行操作的类工具 实现一个串行异步执行类今天在学习webpack源码时，看到了webpack的核心模块tapable，里边有很多方法，其中之一就是串行异步执行方法，于是，自己准备实现一个简单的，其实很简单，见下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 声明类SerialAsyncfunction SerialAsync() &#123; this.arrFns = [];&#125;// 原型链上添加addFn方法SerialAsync.prototype.addFn = function(fn) &#123; this.arrFns.push(fn);&#125;// 原型链上添加emitFn方法SerialAsync.prototype.emitFn = function(callback) &#123; let self = this; let index = 0; // next是核心代码 function next(par) &#123; let fn = self.arrFns[index++]; fn?fn(next):callback(par); &#125; next();&#125;// SerialAsync结束// 是不是超级的简单，就15行代码，记住，核心代码是next方法// 下面是具体的使用var s = new SerialAsync();s.addFn(function(done)&#123; setTimeout(function()&#123; console.log(1); done(1); &#125;, 1000)&#125;);s.addFn(function(done)&#123; setTimeout(function()&#123; console.log(2); done(2); &#125;, 2000);&#125;);s.addFn(function(done)&#123; setTimeout(function()&#123; console.log(5); done(2); &#125;, 5000);&#125;);console.time();s.emitFn((par)=&gt;&#123; console.log('over-&gt;', par); console.timeEnd();&#125;); 可以看到，最关键部分就是next函数，有个递归的过程，据说，nodejs中很多类似的串行方法都是这么实现的，一定要记住哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"js中小数精度问题","slug":"js中小数精度问题","date":"2019-07-04T03:13:00.000Z","updated":"2019-07-04T05:17:06.012Z","comments":true,"path":"2019/07/04/js中小数精度问题/","link":"","permalink":"/2019/07/04/js中小数精度问题/","excerpt":"js中的小数精度问题分析","text":"js中的小数精度问题分析 js中小数精度问题我们在日常开发中，是否遇到过0.1+0.2，一看马上答案就出来了，0.3啊，多么简单的加法，但是，如果你在代码里运行一下，结果出乎意料哦，是0.30000000000000004，哈哈，有意思吧，不仅在js中这样，java，python等语言都是这个德行。奇怪了，这是为什么呢？这就需要了解一下小数在计算机中的存储方式了。我在这里只说小数部分的保存方式。先来说一下小数如何存储，如0.6： 将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，直到小数部分为0。 特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因再具体的分步骤看一下：1234560.6 * 2 = 1.2 —————— 1 0.2 * 2 = 0.4 —————— 0 0.4 * 2 = 0.8 —————— 0 0.8 * 2 = 1.6 —————— 1 0.6 * 2 = 1.2 —————— 1 ………… 我们可以发现在该计算中已经出现了循环，0.6用二进制表示为 1001 1001 1001 1001 ……如果是10.6，那个10.6的完整二进制表示为 1010.100110011001……通过上边的解释，就知道为什么有的小数在js里会出现精度不准的问题了吧，接下来，我们再看看二进制小数如何还原成十进制。我们还拿0.6这个小数来举例子,1001 1001 1001 1001 : 从左到右，v[i] * 2^( - i ), i 为从左到右的index，v[i]为该位的值，直接看例子，很直接的10.6 = 1 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 + 1 * 2^-4 + …… 好了，通过上面大概的了解了小数为什么精度有时候不准的问题，这也只是粗略的理解一下而已，具体在各种语言中运行时可能情况会很复杂，我就点到而止了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js中的递归总结","slug":"js中的递归总结","date":"2019-07-02T01:54:14.000Z","updated":"2019-07-03T06:04:30.800Z","comments":true,"path":"2019/07/02/js中的递归总结/","link":"","permalink":"/2019/07/02/js中的递归总结/","excerpt":"js中各种递归的知识总结","text":"js中各种递归的知识总结 js中的递归总结递归，在我们平时编程中用到的地方很多，但是，对我而然，它是又熟悉又陌生，也就是说，不能熟练地应用到具体的实际业务代码中，所以，我想好好总结总结，以便可以更好地使用它。 数字递归(最简单的入门)12345678910111213141516171819// 加法的递归function sum(num)&#123; if (num === 0) &#123; return 0; &#125; else &#123; return num + sum(--num) &#125;&#125;sum(4); // 10// 再来一个阶乘的递归function fn(num) &#123; if(num === 1) &#123; return 1; &#125;else &#123; return num*fn(num-1) &#125;&#125;fn(5) // 120 数组递归12345678910// 数组中的各个元素相加之和function fn(arr) &#123; if(arr.length === 1) &#123; return arr[0]; &#125;else &#123; var val = arr.shift(); return val + fn(arr); &#125;&#125;fn([1,2,3,4,6,5,7,8,9,10]) // 55 123456789101112131415161718// 将嵌套的多维数组转成一纬数组var arr = [1,2,3,[4,5,6,[7,[8,[9,10]]]],11,[12]];function transformArr(arr) &#123; var newArr = []; recursiveArr(arr, newArr); return newArr;&#125;function recursiveArr(arr, newArr) &#123; arr.forEach(function(item) &#123; if(item instanceof Array) &#123; recursiveArr(item, newArr); &#125;else &#123; newArr.push(item); &#125; &#125;);&#125;console.log(transformArr(arr), '@_@');// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 一纬数组，元素都是对象，互相有父子关系，将这些数组转换成父子结构的对象格式// 数据，parentId是其父节点的id var data = [ &#123; name: '数据1', id: 11, parentId: 1 &#125;, &#123; name: '数据2', id: 12, parentId: 11 &#125;, &#123; name: '数据3', id: 13, parentId: 11 &#125;, &#123; name: '数据4', id: 14, parentId: 12 &#125;, &#123; name: '数据5', id: 15, parentId: 13 &#125;, &#123; name: '数据6', id: 16, parentId: 15 &#125;, &#123; name: '数据7', id: 17, parentId: 16 &#125;, &#123; name: '数据8', id: 18, parentId: 16 &#125;,];// transformData这个函数是辅助生成对象的函数function transformData(data, parentId) &#123; var obj = &#123; children: [] &#125;; generaterTree(data, obj, 1); return obj;&#125;// generaterTree这个函数是递归调用的核心函数function generaterTree(data, obj, parentId) &#123; data.forEach(item=&gt; &#123; item.children = item.children?item.children:[]; if(item.parentId === parentId) &#123; obj.children.push(item); generaterTree(data, item, item.id); // 继续递归回调 &#125; &#125;);&#125; console.log(transformData(data)); 对象的递归其实，对象的递归里边也包含了数组等的一些基础型数据，我们常用的就是对象的深拷贝1234567891011121314151617181920212223242526var data = &#123; \"name\": \"jinux\", \"like\": [\"football\",\"basketball\",\"voliball\"], \"work\": &#123; \"company\": \"technology\", \"address\": \"hunnan\", \"tongshi\": [\"lining\",\"lvnan\"], \"isLeader\": false &#125;&#125;function deepClone(data) &#123; if(typeof data !== 'object') &#123; return data; &#125; if(data === null) &#123; return data; &#125; var obj = Object.prototype.toString.call(data)==='[object Array]'? []:&#123;&#125;; for(var key in data) &#123; obj[key] = arguments.callee(data[key]); // obj[key] = deepClone(data[key]); 与上边的一个意思 &#125; return obj;&#125;console.log(deepClone(data), \"&lt;-&gt;\"); 目前暂时整理这么多，以后会陆续增加递归的小demo.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"快速创建含有多个元素的数组","slug":"快速创建含有多个元素的数组","date":"2019-07-01T02:17:23.000Z","updated":"2019-07-01T05:43:42.900Z","comments":true,"path":"2019/07/01/快速创建含有多个元素的数组/","link":"","permalink":"/2019/07/01/快速创建含有多个元素的数组/","excerpt":"快速并且简单的创建数组","text":"快速并且简单的创建数组 快速创建含有多个元素的数组我们平时在开发时，有时候可能会创建一个包含20个元素的数组，之后对这个数组进行加工操作，来制作一个符合业务要求的数组。12345// 比如我要创建一个包含20个元素的数组var arr = [];for(var 1=0; i&lt;20; i++) &#123; arr.push(undefined);&#125; 上面虽然创建了数组，但是感觉麻烦了点。123456var arr = new Array(20);// 这样创建的数组，只是有长度，但是数组里并没有元素arr.length // 200 in arr // false// arr 这个数组使用map， forEach等方法是便利不了的// 创建一个长度为20的数组，注意该数组的元素并没有被初始化 好了，有几种方便的创建方式，见下面123456789// 首先，看一下vue官网里出现的创建方式Array.apply(null, &#123;length: 20&#125;); // ES5开始apply函数的第二个参数除了可以是数组外，还可以是类数组对象（即包含length属性，且length属性值是个数字的对象）// 这里顺便说一下&#123;length: 20&#125;这个参数的作用function fn() &#123; console.log(arguments)&#125;fn(undefined,undefined,undefined);fn.apply(null, &#123;length: 3&#125;);// 通过上面的代码，就可以看出来&#123;length: 3&#125;这个参数的含义了吧 最后，总结一下可以快速创建有初始值得数组方法123456// 1Array.apply(null, &#123;length: 20&#125;);// 2Array.from(&#123;length: 20&#125;)// 3Array(20).fill(undefined)","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"手写前端自动化构建工具","slug":"手写前端自动化构建工具","date":"2019-06-26T03:13:33.000Z","updated":"2020-01-31T08:21:07.493Z","comments":true,"path":"2019/06/26/手写前端自动化构建工具/","link":"","permalink":"/2019/06/26/手写前端自动化构建工具/","excerpt":"写一个自己的前端自动化构建工具","text":"写一个自己的前端自动化构建工具 手写前端自动化构建工具现在我们使用vue，react等框架来开发已经很普遍了，当我们初始化一个项目的时候，是不是在命令行下按照提示一步一步的操作，最后在本地生成了一个现成的项目，是不是感觉很快捷，很方便，用来生成这个项目的工具就叫做构建工具（有的也称之为脚手架工具）。我现在需要在命令行下进行各种操作，交互，npm上已经有人写好了这类工具，常用的就是commander和inquirer,使用它们来开发脚手架，真的是好简单。我写了两个小demo，一个是围绕着commander，另一个则是围绕inquirer。这两个小例子都很简单，可以根据具体的要求组合到一起。点这里看源码select-list.js这个文件的功能是，可以根据列表的上下选择，下载github上对应的项目模板。init-commander.js这个文件的功能是，命令行里传入的文件夹名和文件名来生成新项目文件。题外话，这里还可以制作成系统命令，在package.json里的bin字段下。如果，都配置好了，就可以使用1npm link 这个命令，把bin字段下的内容生成系统命令，这是一种方式来生成系统命令，另一种应该是把这个项目发布到npm上，安装的时候直接全局安装就可以喽。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"javascript设计模式","slug":"javascript设计模式","date":"2019-06-24T02:16:13.000Z","updated":"2019-06-24T07:13:28.334Z","comments":true,"path":"2019/06/24/javascript设计模式/","link":"","permalink":"/2019/06/24/javascript设计模式/","excerpt":"基本上所有的设计模式都在这里了","text":"基本上所有的设计模式都在这里了 javascript设计模式其实，设计模式在前端，平时很少会遇到，这只是作为我们这些菜鸟前端来说，但是，对于那些高级的，写插件，库之类的前端童鞋来说，设计模式还是不可或缺的，这可是实实在在的会带入到项目中的哦。我只知道常见的几种，也都是为了应付面试的时候被问到，不过，今天我要终结一下，代码部分来源于网络，我只是整理一下，以备被问到时能够快速的回答出来。 1.灵活模式 2.面向对象编程 3.简单工厂模式 4.工厂方法模式 5.抽象工厂模式 6.建造者模式 7.原型模式 8.单例模式 9.外观模式 10.适配器模式 11.代理模式 12.装饰者模式 13.桥接模式 14.组合模式 15.享元模式 16.模板方法模式 17.观察者模式 18.状态模式 19.策略模式 20.职责链模式 21.命令模式 22.访问者模式 23.中介者模式 24.备忘录模式 25.迭代器模式 26.解释器模式 27.链式模式 28.委托模式 29.数据访问对象模式 30.节流模式 31.简单模板模式 32.惰性模式 33.参与者模式 34.等待者模式 35.同步模块模式 36.异步模块模式 37.widget模式 38.MVC模式 39.MVVM模式","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"写一个自己的富文本编辑器","slug":"写一个自己的富文本编辑器","date":"2019-06-22T08:42:09.000Z","updated":"2019-06-22T09:10:22.225Z","comments":true,"path":"2019/06/22/写一个自己的富文本编辑器/","link":"","permalink":"/2019/06/22/写一个自己的富文本编辑器/","excerpt":"写一个稍微复杂点的富文本编辑器","text":"写一个稍微复杂点的富文本编辑器 写一个自己的富文本编辑器前几天写了一个《简单的富文本编辑器》这篇博文，没想到刚过两天，项目中就需要自己写一个富文本编辑器。具体的需求是，在富文本编辑器中编辑好内容，存到数据库，之后app端拿到这些数据以webview的形式展示出来，当然，webview这块也是我来做，但是，在pc端编辑的内容直接放到移动端显示是有问题的，比如像图片大小问题，而且编辑的样式和展示出来的样式完全不一样。所以，我就想自己写一个，不用第三方的库，这样自己可以灵活的按照需求来修改。暂时写这个小插件只用了一天多，还不是很完善，有些地方还有待修改，如果有时间的话，以后会陆续更新。废话不多说，直接贴源码地址喽:jinux-editor这里有些注意的地方，比如把文字变成粗体，用到了1document.execCommand(\"bold\",false,null); 而取消粗体还是用到了这个命令，执行同一个命令，会切换字体的粗体和非粗体的状态。但是，这里注意，还有一个方法可以获取现在文本是否是粗体状态1document.queryCommandState('bold'); 可以用上面这个命令判断现在的状态，进而修改点击按钮的样式。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"base64加密原理","slug":"base64加密原理","date":"2019-06-20T00:30:09.000Z","updated":"2019-06-20T00:40:18.705Z","comments":true,"path":"2019/06/20/base64加密原理/","link":"","permalink":"/2019/06/20/base64加密原理/","excerpt":"你知道我们常用的base64是什么吗？","text":"你知道我们常用的base64是什么吗？ base64加密原理开发者对Base64编码肯定很熟悉，是否对它有很清晰的认识就不一定了。实际 上Base64已经简单到不能再简单了，如果对它的理解还是模棱两可实在不应该。大概介绍一下Base64的相关内容，花几分钟时间就可以彻底理解它。文 章下边贴了一个Base64的编解码器，方便阅读文章的同时来实验。 一. Base64编码由来 为什么会有Base64编码呢？因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就 不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情 况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。Base64编码应运而生，Base64就是一种 基于64个可打印字符来表示二进制数据的表示方法。 二. Base64编码原理 看一下Base64的索引表，字符选用了”A-Z、a-z、0-9、+、/“ 64个可打印字符。数值代表字符的索引，这个是标准Base64协议规定的，不能更改。64个字符用6个bit位就可以全部表示，一个字节有8个bit 位，剩下两个bit就浪费掉了，这样就不得不牺牲一部分空间了。这里需要弄明白的就是一个Base64字符是8个bit，但是有效部分只有右边的6个 bit，左边两个永远是0。那么怎么用6个有效bit来表示传统字符的8个bit呢？8和6的最小公倍数 是24，也就是说3个传统字节可以由4个Base64字符来表示，保证有效位数是一样的，这样就多了1/3的字节数来弥补Base64只有6个有效bit 的不足。你也可以说用两个Base64字符也能表示一个传统字符，但是采用最小公倍数的方案其实是最减少浪费的。结合下边的图比较容易理解。Man是三个 字符，一共24个有效bit，只好用4个Base64字符来凑齐24个有效位。红框表示的是对应的Base64，6个有效位转化成相应的索引值再对应 Base64字符表，查出”Man”对应的Base64字符是”TWFU”。说到这里有个原则不知道你发现了没有，要转换成Base64的最小单位就是三个字节，对一个字符串来说每次都是三个字节三个字节的转换，对应的是Base64的四个字节。这个搞清楚了其实就差不多了。 但是转换到最后你发现不够三个字节了怎么办呢？愿望终于实现了，我们可以用两 个Base64来表示一个字符或用三个Base64表示两个字符，像下图的A对应的第二个Base64的二进制位只有两个，把后边的四个补0就是了。所以 A对应的Base64字符就是QQ。上边已经说过了，原则是Base64字符的最小单位是四个字符一组，那这才两个字 符，后边补两个”=”吧。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。由此可见 Base64字符串只可能最后出现一个或两个”=”，中间是不可能出现”=”的。下图中字符”BC”的编码过程也是一样的。 三. 总结 说起Base64编码可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而Base64的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。 Base64编码主要用在传输、存储、表示二进制等领域，还可以用来加密，但是这种加密比较简单，只是一眼看上去不知道什么内容罢了，当然也可以对Base64的字符序列进行定制来进行加密。 Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二 进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"测试及爬虫工具nightmare","slug":"测试及爬虫工具nightmare","date":"2019-06-18T06:21:24.000Z","updated":"2019-06-18T07:00:25.232Z","comments":true,"path":"2019/06/18/测试及爬虫工具nightmare/","link":"","permalink":"/2019/06/18/测试及爬虫工具nightmare/","excerpt":"nightmare工具的使用","text":"nightmare工具的使用 测试及爬虫工具nightmarenightmare是一个可视化的页面操作工具，官网点这里如何安装就不说了，npm就可以搞定，但是，安装的时候会很慢，因为它依赖electron具体的使用方法可以直接看官网的api，下面是一个小demo，是对本博客网站的简单操作，可以看一下它强大的效果1234567891011121314151617181920212223var Nightmare = require('nightmare'); var nightmare = Nightmare(&#123; show: true, gotoTimeout: 100000 // goto页面的等待时长，不写的话默认30000ms，访问慢的网页会报错 &#125;);nightmare .goto('https://jinux7.github.io') // 打开的网页 .type('.m_search .u-search-input', 'javascript') // 向input中写入javascript .type('.m_search .u-search-input', '\\u000d') // 触发input的点击回车事件 .wait('.icon.icon-close') // 等待弹出层的.icon.icon-close元素节点出现 .click('.icon.icon-close') // 出现后点击它 .evaluate(function () &#123; // 注入到页面里执行的js代码 // do something return document.querySelector('.avatar.waves-image').src; &#125;) // .end() // 关闭nightmare .then(function (result) &#123; console.log(result); &#125;) .catch(function (error) &#123; console.error('Search failed:', error); &#125;); 如需要更丰富的功能，按照api一点点添加就可以喽.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"简单的富文本编辑器","slug":"简单的富文本编辑器","date":"2019-06-17T05:30:10.000Z","updated":"2019-06-17T05:45:03.898Z","comments":true,"path":"2019/06/17/简单的富文本编辑器/","link":"","permalink":"/2019/06/17/简单的富文本编辑器/","excerpt":"超级简单的富文本编辑器","text":"超级简单的富文本编辑器 简单的富文本编辑器这是一个超级简单富文本编辑器，功能很简单，但是富文本编辑器的写法基础是有的，可以在这个基础上进行增加改进。主要用到了div的contentEditable属性，还有document.execCommand方法，具体代码见下面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;简易富文本编辑器.html&lt;/title&gt; &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt; &lt;meta http-equiv=\"description\" content=\"this is my page\"&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"&gt; &lt;style type=\"text/css\"&gt; #editor &#123;width:600px;height:200px;border:1px solid #ccc; &#125; button &#123;margin:1px;border:1px solid #aaa;background:#ffe;cursor:pointer;overflow:hidden;&#125; button:hover &#123;background:#ccc;border:1px solid #00f;&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn1\"&gt;&lt;/button&gt; &lt;button id=\"btn2\"&gt;&lt;/button&gt; &lt;button id=\"btn3\"&gt;&lt;/button&gt; &lt;button id=\"btn4\"&gt;&lt;/button&gt; &lt;div id=\"editor\"&gt; Click to Editor... &lt;/div&gt; &lt;input id=\"printContent\" type=\"button\" value=\"打印编辑器内容\"&gt; &lt;script type=\"text/javascript\"&gt; initEditor(); //初始化 function initEditor() &#123; openOrCloseEditor(\"editor\", \"true\");//开启元素编辑 bindBtnCommand();//给样式按钮绑定命令 &#125; /** * * 功能： 开启元素编辑功能 * 输入： el：编辑器ID; operate：Boolean值，表示启动还是关闭 */ function openOrCloseEditor(el, operate) &#123; var editor = document.getElementById(el); editor.contentEditable = operate; &#125; //按钮绑定命令 function bindBtnCommand() &#123; var btns = document.getElementsByTagName(\"button\"), btnConfigs = \"backcolor|#f00|设置背景色 bold|null|字体加粗 indent|null|缩进 fontName|微软雅黑|转换字体\".split(\" \"), len = btnConfigs.length; for(var i = 0, btnConfig; btnConfig = btnConfigs[i]; i++) &#123; (function(btnConfig, btn) &#123; var msg = btnConfig.split(\"|\"), lab = msg[0], value = msg[1], title = msg[2]; btn.innerHTML = lab; btn.title = title; btn.onclick = function(e) &#123; document.execCommand(lab, false, value); &#125; &#125;)(btnConfig, btns[i]); &#125; &#125; //获取编辑器内嵌内容 function getContent(el) &#123; var editor = document.getElementById(el); return editor.innerHTML; &#125; //打印按钮绑定触发事件 document.getElementById(\"printContent\").onclick = function(e) &#123; var content = getContent(\"editor\"); document.write(content); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码直接粘贴就可以跑起来哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"vue,react中百度地图的使用","slug":"vue-react中百度地图的使用","date":"2019-06-13T05:13:09.000Z","updated":"2019-06-13T05:34:31.251Z","comments":true,"path":"2019/06/13/vue-react中百度地图的使用/","link":"","permalink":"/2019/06/13/vue-react中百度地图的使用/","excerpt":"vue,react等框架，百度地图的最优使用方式","text":"vue,react等框架，百度地图的最优使用方式 vue,react中百度地图的使用现在vue，react框架大行其道，很多项目都是用它们开发的，我的项目也都在用，之前，在使用百度地图的时候，我都是把百度地图封了一个组件，直接插入到dom中，但是，有些功能莫名其妙的不好使，我猜可能是跟vue有兼容性问题，还有一个页面中引入多个地图的情况下，像城市切换插件就不好使了，相互冲突了，所以，最终的解决方案是用iframe来引入百度地图。这个好处就是完全隔离开项目框架与百度地图之间的冲突。首先，建一个百度地图的html页面，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=yes\" /&gt; &lt;link href=\"https://api.map.baidu.com/library/IndoorMap/1.0/src/indoor.min.css?v=1.0.1 \" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;style type=\"text/css\"&gt; body, html,#map &#123;width: 100%;height: 100%;overflow: hidden;margin:0;font-family:\"微软雅黑\";&#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"https://api.map.baidu.com/api?v=3.0&amp;ak=PaxZEfdK60GDxScXccj81kBW\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://api.map.baidu.com/library/IndoorMap/1.0/src/indoor.min.js?v=1.0.1 \"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"map\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\"&gt; var obj = &#123; lng:'', lat:'' &#125;; var tab = getQueryString('tab'); // 获取url信息 function getQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var reg_rewrite = new RegExp(\"(^|/)\" + name + \"/([^/]*)(/|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); var q = window.location.pathname.substr(1).match(reg_rewrite); if(r != null)&#123; return unescape(r[2]); &#125;else if(q != null)&#123; return unescape(q[2]); &#125;else&#123; return null; &#125; &#125; // 百度地图API功能 var map = new BMap.Map(\"map\"); map.centerAndZoom(new BMap.Point(123.436, 41.816), 11); var topLeftControl = new BMap.ScaleControl(&#123; anchor: BMAP_ANCHOR_BOTTOM_LEFT &#125;); // 城市选择控件 var cityListControl = new BMap.CityListControl(&#123; anchor: BMAP_ANCHOR_TOP_RIGHT &#125;); // 比例尺控件 var topLeftNavigation = new BMap.NavigationControl(); map.addControl(topLeftControl); map.addControl(topLeftNavigation); map.addControl(cityListControl); map.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放 // 创建室内图实例 var indoorManager = new BMapLib.IndoorManager(map); // 点击获取经纬度 map.addEventListener(\"click\", function(e) &#123; obj.lng = parseFloat(e.point.lng) + ''; obj.lat = parseFloat(e.point.lat) + ''; drawLocation() selectLocation(); &#125;); function selectLocation() &#123; window.parent.postMessage(&#123; refresh:obj, tab &#125;,'*'); &#125; function drawLocation() &#123; if (obj.lng !== \"\" &amp;&amp; obj.lat !== \"\") &#123; map.clearOverlays(); var new_point = new BMap.Point(obj.lng, obj.lat); var marker = new BMap.Marker(new_point); map.addOverlay(marker); map.panTo(new_point); &#125; &#125;&lt;/script&gt; 之后就是在项目中用iframe标签引入。重要的地方来了，就是父子页面通信，在子页面点击选好地点后，肯定需要把选好点的坐标给父页面，这里有一个简单的方法，在子页面中点击选点时，给父页面发信息代码如下：1234window.parent.postMessage(&#123; val: '信息' &#125;,'*');// 具体使用方法自行百度 子页面消息发出去了，父页面如何接收呢？见下面代码12345window.addEventListener('message',function(event)&#123; console.log(event);&#125;);// 可以打印出很多需要的信息喽// 据说，IE8+都支持哦 好了，总结一下，vue中最好还是以这种方式使用哈。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"web页面性能测试demo","slug":"web页面性能测试demo","date":"2019-06-06T07:30:17.000Z","updated":"2019-06-06T07:54:33.774Z","comments":true,"path":"2019/06/06/web页面性能测试demo/","link":"","permalink":"/2019/06/06/web页面性能测试demo/","excerpt":"web页面性能测试demo","text":"web页面性能测试demo web页面性能测试demo写这篇文章的起因，有时候有人问，css会不会阻塞页面渲染了，js如何触发页面渲染了等等，所以，最好的方式就是自己写一个小demo，自己试一下不就一目了然了吗，目前这个demo的内容很简单，以后会慢慢增加。下面是github的链接地址:点我进入仓库","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web性能","slug":"web性能","permalink":"/tags/web性能/"}]},{"title":"docker常用命令","slug":"docker常用命令","date":"2019-05-28T06:14:50.000Z","updated":"2019-11-28T01:55:02.363Z","comments":true,"path":"2019/05/28/docker常用命令/","link":"","permalink":"/2019/05/28/docker常用命令/","excerpt":"docker常用命令","text":"docker常用命令 docker常用命令最近想在win10下安装mysql5.6版本，装了半天没装成功，于是乎用docker来解决了。docker需要命令行，这里以mysql为例，贴出一个别人的blog(懒得写了)。docker运行mysql","categories":[{"name":"服务器","slug":"服务器","permalink":"/categories/服务器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"/tags/docker/"}]},{"title":"windows下git命令批处理执行","slug":"windows下git命令批处理执行","date":"2019-05-24T06:04:09.000Z","updated":"2019-05-27T03:13:50.466Z","comments":true,"path":"2019/05/24/windows下git命令批处理执行/","link":"","permalink":"/2019/05/24/windows下git命令批处理执行/","excerpt":"win10操作系统下利用批处理程序来运行git操作。","text":"win10操作系统下利用批处理程序来运行git操作。 windows下git命令批处理执行首先，我说一下我要这样做的起因，也许大家都会有感。目前，我在做的项目是一个，但是下面分了5个子项目，这5个子项目，每一个自己拥有一个git仓库，所以，我在上传代码的操作就是，commit-&gt;pull-&gt;push,这样反复5回，因为有5个仓库嘛。有时候一天要好多次，效率太低了，于是我就想起了利用windows系统的批处理来做。在使用批处理来操作git命令，首先需要把git的操作仓库方式改为ssh，使用ssh的话，还需要ssh key，ssh key的生成方法是，打开git的命令行工具，输入1234567891011// 首先检查一下现在电脑里是否已经有生成的ssh keycd ~/.ssh// ~这个符号我在git命令行下才能打出来，cmd没打出来。// ~/ 这个路径就是C:\\Users\\kaiya这个，看看现在是否已经有现成的ssh key// 如果有，就不用再生成了// 接下来是生成ssh key命令ssh-keygen -t rsa -C &quot;124076***@qq.com&quot;// 需要自己在电脑中注册的git邮箱,如果不知道，可以查一下 git config --global user.email// 生成的ssh key自动保存在C:\\Users\\kaiya这个目录下（这个是我的用户名）// 生成过程中一路回车就好，不用设置密码等 有了ssh key，添加到github或自己公司的gitlab上就好了。比如要添加到github上，登录账号进入自己的github库，步骤见下图点进去之后，按照页面提示填写就可以了。以上就是配置好了ssh key，之后就是用git拉取，推送代码了，这里有一个地方需要注意，那就是Git对仓库的操作方式，既然已经添加了ssh key，就需要用git的ssh提交方式。查看.git文件夹下的config文件，找到下面的内容12345678[remote &quot;origin&quot;] // 这个是ssh提交方式 url = git@172.24.112.158:root/airport.git // 这个是http提交方式 url = http://172.24.112.158/root/webviewpage fetch = +refs/heads/*:refs/remotes/origin/* 按照上面的写法，只留下ssh提交方式即可。接下来，我们来写windows的批处理命令,先写一个处理一个仓库的git操作批处理。123456789101112chcp 65001cd C:\\WORK\\git-ku\\ejashop@echo offecho git批处理开始执行git statusgit add .git commit -m &quot;update&quot;git pullgit pushecho ----------echo git commit pull push都已完成，点击任意键退出pause 再写一个调用多个批处理文件的操作123456chcp 65001pausestart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\git&quot; call ehome.batstart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\git&quot; call airport.batstart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\git&quot; call eHomeOperation.batstart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\git&quot; call kaidian.bat 这里，需要注意一下，因为批处理是在cmd命令行下执行的，所以要把git的环境变量配好哦。好了，通过这样的方法，以后麻烦的git操作，点击一下就可以搞定喽。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"多个ajax请求,页面渲染顺序问题","slug":"多个ajax请求-页面渲染顺序问题","date":"2019-05-20T07:04:15.000Z","updated":"2019-05-21T00:52:30.868Z","comments":true,"path":"2019/05/20/多个ajax请求-页面渲染顺序问题/","link":"","permalink":"/2019/05/20/多个ajax请求-页面渲染顺序问题/","excerpt":"在一个页面中,多个ajax请求,页面渲染顺序问题。","text":"在一个页面中,多个ajax请求,页面渲染顺序问题。 多个ajax请求,页面渲染顺序问题如题，比如说在一个页面中有两个按钮或者多个，按照先后顺序点击，都发出了ajax请求，但是他们返回的顺序就不会按照点击按钮的顺序返回，如果，它们操作的是页面的同一个显示区域，比如列表，那就ajax访问最慢的接口最后被渲染出来，有可能这个接口是用户最开始点击的按钮渲染出来的，这样就会产生错误信息，用户本想最后点击那个按钮返回的数据才是他想要的。其实，这个问题我并没有遇到过，这个是大约一年前我再一次面试中被问到的，当时由于没有做好准备，我也只能诚实的回答没有遇到过此场景，今天我又来了兴致，把它的解决方法记录下来（我的拖延症是不是很严重），这个解决方式是我自己定的，其实也是实现起来比较简单的。为了加快写作，直接把代码贴出来，在代码中写注释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;script src=\"./jquery.js\"&gt;&lt;/script&gt; &lt;title&gt;多个ajax请求,页面渲染顺序问题&lt;/title&gt; &lt;style&gt; .content &#123; width: 500px; height: 100px; background-color: #eeeeee; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; 原始内容 &lt;/div&gt; &lt;button id=\"btn1\"&gt;按钮2s&lt;/button&gt; &lt;button id=\"btn2\"&gt;按钮5s&lt;/button&gt; &lt;button id=\"btn3\"&gt;按钮3s&lt;/button&gt;&lt;/body&gt;&lt;script&gt; // 后端地址 var baseUrl = \"http://localhost:3000/\"; // 存放ajax标志的数组，用来区分是哪个ajax var orderArr = []; // 按钮1加点击事件 $('#btn1').on('click', function() &#123; // 将btn1按钮的标志传入数组 ajaxOrder('btn1'); $.post(baseUrl+'delay2s', (res)=&gt; &#123; // 渲染页面 render('btn1', res.data); &#125;); &#125;); // 按钮2加点击事件 $('#btn2').on('click', function() &#123; ajaxOrder('btn2'); $.post(baseUrl+'delay5s', (res)=&gt; &#123; render('btn2', res.data); &#125;); &#125;); // 按钮3加点击事件 $('#btn3').on('click', function() &#123; ajaxOrder('btn3'); $.post(baseUrl+'delay3s', (res)=&gt; &#123; render('btn3', res.data); &#125;); &#125;); // 向存放ajax标志位数组中push ajax标志 function ajaxOrder(flag) &#123; orderArr.push(flag); &#125; // 根据ajax的标志来渲染页面 function render(flag, val) &#123; // 如果数组中只有一个标志的情况，直接渲染并清空数组 if(orderArr.length === 1) &#123; orderArr = []; $('.content').html(val); return void 0; &#125; // 如果标志数组中多余一个标志 if(orderArr.length &gt; 1) &#123; // 如果这个标志是第一个请求的标志，则渲染页面 if(orderArr.indexOf(flag) === 0) &#123; orderArr.shift(); $('.content').html(val); return void 0; &#125;else &#123; // 如果不是第一个，则不渲染页面，并把这个标志剔除 let index = orderArr.indexOf(flag); orderArr.splice(index,1); &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 大概的流程就是，按照按钮点击的顺序来显示请求的结果。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"webpack打包多页面项目","slug":"webpack打包多页面项目","date":"2019-05-20T02:26:35.000Z","updated":"2019-05-20T02:46:28.390Z","comments":true,"path":"2019/05/20/webpack打包多页面项目/","link":"","permalink":"/2019/05/20/webpack打包多页面项目/","excerpt":"webpack打包多页面项目","text":"webpack打包多页面项目 webpack打包多页面项目平时我们在工作中，使用webpack来打包单页面应用的项目很多，多页面应用之前我都是使用gulp来做，今天我在github发现一个不错的demo，我就不写具体的分析步骤了，代码里边写的很清楚，直接贴地址喽。点击这里看项目","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"import和require的本质区别","slug":"import和require的本质区别","date":"2019-05-09T08:00:05.000Z","updated":"2019-05-09T08:44:15.447Z","comments":true,"path":"2019/05/09/import和require的本质区别/","link":"","permalink":"/2019/05/09/import和require的本质区别/","excerpt":"简单的说一下import和require的本质区别","text":"简单的说一下import和require的本质区别 import和require的本质区别import是ES6的模块规范，require是commonjs的模块规范，详细的用法我不介绍，我只想说一下他们最基本的区别，import是静态加载模块，require是动态加载，那么静态加载和动态加载的区别是什么呢？静态加载时代码在编译的时候已经执行了，动态加载是编译后在代码运行的时候再执行，那么具体点是什么呢？先说说import，如下代码123456// main.js文件import &#123; name &#125; from 'name.js'// name.js文件export let name = 'jinux'export let age = 20 上面的代码表示main.js文件里引入了name.js文件导出的变量，在代码编译阶段执行后的代码如下：12// main.js文件let name = 'jinux' 这个是我自己理解的，其实就是直接把name.js里的代码放到了main.js文件里，好比是在main.js文件中声明一样。再来看看require123456789// main.js文件var obj = require('obj.js');// obj.js文件var obj = &#123; name: 'jinux', age: 20&#125;module.export obj; require是在运行阶段，需要把obj对象整个加载进内存，之后用到哪个变量就用哪个，这里再对比一下import，import是静态加载，如果只引入了name，age是不会引入的，所以是按需引入，性能更高。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"http常用状态码","slug":"http常用状态码","date":"2019-05-06T02:52:37.000Z","updated":"2019-05-06T05:21:56.964Z","comments":true,"path":"2019/05/06/http常用状态码/","link":"","permalink":"/2019/05/06/http常用状态码/","excerpt":"列出了一些常用的http请求状态码","text":"列出了一些常用的http请求状态码 http常用状态码我们在日常开发中，经常会使用ajax，会看到请求返回的状态码，也就是Status Code。常见的3个是: 200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务器超时 但是，作为一个合格的前端，还需要掌握的详细点，下面列出常用的状态码，也不是最全的哦。 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 100（继续）: 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议）: 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示成功处理了请求的状态码。 200（成功）: 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。 201（已创建）: 请求成功并且服务器创建了新的资源。 202（已接受）: 服务器已接受请求，但尚未处理。 203（非授权信息）: 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）: 服务器成功处理了请求，但没有返回任何内容。 205（重置内容）: 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容）: 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。通常，这些状态码用来重定向。 300（多种选择）: 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）: 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置）: 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改）: 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305（使用代理）: 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301&lt;/a&gt; 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）: 服务器不理解请求的语法。 401（未授权）: 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）: 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）: 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 405（方法禁用）: 禁用请求中指定的方法。 406（不接受）: 无法使用请求的内容特性响应请求的网页。 407（需要代理授权）: 此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）&lt;/a&gt;类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时）: 服务器等候请求时发生超时。 409（冲突）: 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除）: 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度）: 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）: 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）: 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长）: 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）: 请求的格式不受请求页面的支持。 416（请求范围不符合要求）: 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值）: 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 以上就是一些常用的http状态吗，如果想了解更多，点击这里喽","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"nodejs将vue的dist目录文件copy到目标目录","slug":"nodejs将vue的dist目录文件copy到目标目录","date":"2019-04-23T05:32:30.000Z","updated":"2019-04-23T07:01:49.223Z","comments":true,"path":"2019/04/23/nodejs将vue的dist目录文件copy到目标目录/","link":"","permalink":"/2019/04/23/nodejs将vue的dist目录文件copy到目标目录/","excerpt":"利用nodejs拷贝转移文件","text":"利用nodejs拷贝转移文件 nodejs将vue的dist目录文件copy到目标目录上篇文章写了《window批处理执行webpack打包》，这篇文章主要写打包好的文件自动转移到git目录下。其实就是用的nodejs的读写文件API而已，代码不多，见下面：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let fs = require('fs');let fse = require('fs-extra') // 文件的正删改查模块，比原生方便let path = require('path');// 复制文件var copy=function(src,dst)&#123; let paths = fs.readdirSync(src); //同步读取当前目录 paths.forEach(function(path)&#123; var _src=src+'/'+path; var _dst=dst+'/'+path; fs.stat(_src,function(err,stats)&#123; //stats 该对象 包含文件属性 if(err)throw err; if(stats.isFile())&#123; //如果是个文件则拷贝 let _dst = dst+'/' + path; let readable=fs.createReadStream(_src);//创建读取流 let writable=fs.createWriteStream(_dst);//创建写入流 readable.pipe(writable); &#125;else if(stats.isDirectory())&#123; //是目录则 递归 checkDirectory(_src,_dst,copy); &#125; &#125;); &#125;);&#125;// 检查文件夹是否存在，新建文件夹并copyvar checkDirectory=function(src,dst,callback)&#123; fs.access(dst, fs.constants.F_OK, (err) =&gt; &#123; if(err)&#123; fs.mkdirSync(dst); callback(src,dst); &#125;else&#123; callback(src,dst); &#125; &#125;);&#125;;// 删除旧文件var cleanOld = function(dest) &#123; let dest_static = path.join(dest, 'static'); let dest_index = path.join(dest, 'index.html'); fs.exists(dest_static,function(exists)&#123; if(exists) fse.removeSync(dest_static); &#125;); fs.exists(dest_index,function(exists)&#123; if(exists) fse.removeSync(dest_index); &#125;);&#125;// 文件路径let url_src_ehome = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\ejashop\\\\dist\\\\'), url_dest_ehome = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\ehome'), url_src_airport = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\airport\\\\dist\\\\'), url_dest_airport = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\airport'), url_src_operation = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\eHomeOperation\\\\dist\\\\'), url_dest_operation = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\operation'), url_src_openShop = path.relative(__dirname, 'C:\\\\WORK\\\\new-airport\\\\6 编码\\\\5 Web\\\\kaidian\\\\dist\\\\'), url_dest_openShop = path.relative(__dirname, 'C:\\\\Users\\\\kaiya\\\\Desktop\\\\公司文件\\\\gitlang\\\\langcnew\\\\demo2\\\\openShop');// copy之前先清空旧文件cleanOld(url_dest_ehome);cleanOld(url_dest_airport);cleanOld(url_dest_operation);cleanOld(url_dest_openShop);// 4个项目的copy转移checkDirectory(url_src_ehome, url_dest_ehome,copy);checkDirectory(url_src_airport, url_dest_airport,copy);checkDirectory(url_src_operation, url_dest_operation,copy);checkDirectory(url_src_openShop, url_dest_openShop,copy); 这里需要注意一点，path.relative(__dirname, ‘C:\\WORK\\new-airport\\6 编码\\5 Web\\ejashop\\dist\\‘);利用path模块将两个绝对路径变成相对路径。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"工具库","slug":"工具库","permalink":"/tags/工具库/"}]},{"title":"window批处理执行webpack打包","slug":"window批处理执行webpack打包","date":"2019-04-19T01:14:31.000Z","updated":"2019-04-19T01:37:13.570Z","comments":true,"path":"2019/04/19/window批处理执行webpack打包/","link":"","permalink":"/2019/04/19/window批处理执行webpack打包/","excerpt":"利用window的批处理文件bat来批量执行debpack打包命令。","text":"利用window的批处理文件bat来批量执行debpack打包命令。 window批处理执行webpack打包现在的前端开发，使用vue，react，angular等框架的项目非常多，部署的时候需要打包后进行部署，比如运行npm run build命令，但是比如我现在的项目，有4个子平台，每个平台是独立的一套vue，每次打包的时候需要进入到4个不同的平台目录进行打包命令操作，还有一点，我们项目分为测试环境，生产环境，这样就会出现更多次打包操作，每次都很烦，进入一个文件夹，打开命令提示符，输入npm run build，有没有方便点的方式呢，有，可以利用window系统的批处理文件来操作。首先，下面的是执行一个打包命令的.bat文件1234chcp 65001cd C:\\WORK\\new-airport\\6 编码\\5 Web\\ejashopnpm run buildpause chcp 65001 //是用来可以在文件路径中使用中文 cd C:\\WORK\\new-airport\\6 编码\\5 Web\\ejashop //进入到项目的目录 npm run build //执行打包命令 pause // 命令行暂停，等待下一步操作 上面的是执行一个打包命令的，多个打包操作需要创建多个.bat文件，每执行一个点击一下也很麻烦，我们可以在创建一个.bat文件，用来执行这些批处理文件操作，向下面这样:123456chcp 65001pausestart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\build&quot; call ehome.batstart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\build&quot; call airport.batstart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\build&quot; call eHomeOperation.batstart /D &quot;C:\\Users\\kaiya\\Desktop\\批处理node\\build&quot; call kaidian.bat chcp 65001 //是用来可以在文件路径中使用中文 start /D “C:\\Users\\kaiya\\Desktop\\批处理node\\build” call ehome.bat //执行具体的.bat文件","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"http请求头响应头字段详解","slug":"http请求头响应头字段详解","date":"2019-04-15T09:04:24.000Z","updated":"2019-04-16T08:35:39.798Z","comments":true,"path":"2019/04/15/http请求头响应头字段详解/","link":"","permalink":"/2019/04/15/http请求头响应头字段详解/","excerpt":"http请求头和返回头字段的解释","text":"http请求头和返回头字段的解释 http请求头响应头字段详解作为一名前端开发人员，肯定少不了要和网络打交道，因为要从服务器端拉取数据，从服务端获取数据最常用的方式还是通过HTTP请求。给服务器发请求的时候有请求头，接受服务器响应的时候有响应头，客户端和服务器端互相沟通需要的信息都是通过这些“头”来传送，这些信息是一些类似key:value的键值对。了解这些“头”中字段的含义对于理解整个请求过程有很大的帮助。这里列举了常用的“头”字段的解释以及例子，本文可以作为工具文收藏，以备需要时查看。 常用标准请求头字段 Accept 设置接受的内容类型Accept: text/plain Accept-Charset 设置接受的字符编码Accept-Charset: utf-8 Accept-Encoding 设置接受的编码格式Accept-Encoding: gzip, deflate Accept-Datetime 设置接受的版本时间Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT Accept-Language 设置接受的语言Accept-Language: en-US Authorization 设置HTTP身份验证的凭证Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令Cache-Control: no-cache Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项Connection: keep-aliveConnection: Upgrade Content-Length 设置请求体的字节长度Content-Length: 348 Content-MD5 设置基于MD5算法对请求体内容进行Base64二进制编码Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Type 设置请求体的MIME类型（适用POST和PUT请求）Content-Type: application/x-www-form-urlencoded Cookie 设置服务器使用Set-Cookie发送的http cookieCookie: $Version=1; Skin=new; Date 设置消息发送的日期和时间Date: Tue, 15 Nov 1994 08:12:31 GMT Expect 标识客户端需要的特殊浏览器行为Expect: 100-continue Forwarded 披露客户端通过http代理连接web服务的源信息Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43Forwarded: for=192.0.2.43, for=198.51.100.17 From 设置发送请求的用户的email地址From: user@example.com Host 设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略Host: en.wikipedia.org:8080Host: en.wikipedia.org If-Match 设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源If-Match: “737060cd8c284d8af7ad3082f209582d If-Modified-Since 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not ModifiedIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT If-None-Match 设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not ModifiedIf-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT Max-Forwards 限制代理或网关转发消息的次数Max-Forwards: 10 Origin 标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）Origin: http://www.example-social-network.com Pragma 设置特殊实现字段，可能会对请求响应链有多种影响Pragma: no-cache Proxy-Authorization 为连接代理授权认证信息Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte servingRange: bytes=500-999 Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址（轶事：这个单词正确的拼法应该是”referrer”,但是在很多规范中都拼成了”referer”，所以这个单词也就成为标准用法）Referer: http://en.wikipedia.org/wiki/Main_Page TE 设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样TE: trailers, deflate Upgrade 请求服务端升级协议Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket User-Agent 用户代理的字符串值User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 Via 通知服务器代理请求Via: 1.0 fred, 1.1 example.com (Apache/1.1) Warning 实体可能会发生的问题的通用警告Warning: 199 Miscellaneous warning 常用非标准请求头字段 X-Requested-With 标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequestX-Requested-With: XMLHttpRequest DNT 请求web应用禁用用户追踪DNT: 1 (Do Not Track Enabled)DNT: 0 (Do Not Track Disabled) X-Forwarded-For 一个事实标准，用来标识客户端通过HTTP代理或者负载均衡器连接的web服务器的原始IP地址X-Forwarded-For: client1, proxy1, proxy2X-Forwarded-For: 129.78.138.66, 129.78.64.103 X-Forwarded-Host 一个事实标准，用来标识客户端在HTTP请求头中请求的原始host,因为主机名或者反向代理的端口可能与处理请求的原始服务器不同X-Forwarded-Host: en.wikipedia.org:8080X-Forwarded-Host: en.wikipedia.org X-Forwarded-Proto 一个事实标准，用来标识HTTP原始协议，因为反向代理或者负载均衡器和web服务器可能使用http,但是请求到反向代理使用的是httpsX-Forwarded-Proto: https Front-End-Https 微软应用程序和负载均衡器使用的非标准header字段Front-End-Https: on X-Http-Method-Override 请求web应用时，使用header字段中给定的方法（通常是put或者delete）覆盖请求中指定的方法（通常是post）,如果用户代理或者防火墙不支持直接使用put或者delete方法发送请求时，可以使用这个字段X-HTTP-Method-Override: DELETE X-ATT-DeviceId 允许更简单的解析用户代理在AT&amp;T设备上的MakeModel/FirmwareX-Att-Deviceid: GT-P7320/P7320XXLPG X-Wap-Profile 设置描述当前连接设备的详细信息的xml文件在网络中的位置x-wap-profile: http://wap.samsungmobile.com/uaprof/SGH-I777.xml Proxy-Connection 早起HTTP版本中的一个误称，现在使用标准的connection字段Proxy-Connection: keep-alive X-UIDH 服务端深度包检测插入的一个唯一ID标识Verizon Wireless的客户X-UIDH: … X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN 防止跨站请求伪造X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql X-Request-ID,X-Correlation-ID 标识客户端和服务端的HTTP请求X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5 常用标准响应头字段 Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享Access-Control-Allow-Origin: * Accept-Patch 指定服务器支持的补丁文档格式，适用于http的patch方法Accept-Patch: text/example;charset=utf-8 Accept-Ranges 服务器通过byte serving支持的部分内容范围类型Accept-Ranges: bytes Age 对象在代理缓存中暂存的秒数Age: 12 Allow 设置特定资源的有效行为，适用方法不被允许的http 405错误Allow: GET, HEAD Alt-Svc 服务器使用”Alt-Svc”（Alternative Servicesde的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取Alt-Svc: h2=”http2.example.com:443”; ma=7200 Cache-Control 告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒Cache-Control: max-age=3600 Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项Connection: close Content-Disposition 告诉客户端弹出一个文件下载框，并且可以指定下载文件名Content-Disposition: attachment; filename=”fname.ext” Content-Encoding 设置数据使用的编码类型Content-Encoding: gzip Content-Language 为封闭内容设置自然语言或者目标用户语言Content-Language: en Content-Length 响应体的字节长度Content-Length: 348 Content-Location 设置返回数据的另一个位置Content-Location: /index.htm Content-MD5 设置基于MD5算法对响应体内容进行Base64二进制编码Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 标识响应体内容属于完整消息体中的那一部分Content-Range: bytes 21010-47021/47022 Content-Type 设置响应体的MIME类型Content-Type: text/html; charset=utf-8 Date 设置消息发送的日期和时间Date: Tue, 15 Nov 1994 08:12:31 GMT ETag 特定版本资源的标识符，通常是消息摘要ETag: “737060cd8c284d8af7ad3082f209582d” Expires 设置响应体的过期时间Expires: Thu, 01 Dec 1994 16:00:00 GMT Last-Modified 设置请求对象最后一次的修改日期Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT Link 设置与其他资源的类型关系Link: ; rel=”alternate” Location 在重定向中或者创建新资源时使用Location: http://www.w3.org/pub/WWW/People.html P3P 以P3P:CP=”your_compact_policy”的格式设置支持P3P(Platform for Privacy Preferences Project)策略，大部分浏览器没有完全支持P3P策略，许多站点设置假的策略内容欺骗支持P3P策略的浏览器以获取第三方cookie的授权P3P: CP=”This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657 for more info.” Pragma 设置特殊实现字段，可能会对请求响应链有多种影响Pragma: no-cache Proxy-Authenticate 设置访问代理的请求权限Proxy-Authenticate: Basic Public-Key-Pins 设置站点的授权TLS证书Public-Key-Pins: max-age=2592000; pin-sha256=”E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=”; Refresh “重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持 12&lt;meta http-equiv=\"refresh\" content=\"5; url=http://example.com/\"&gt;Refresh: 5; url=http://www.w3.org/pub/WWW/People.html Retry-After 如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者HTTP时间Example 1: Retry-After: 120Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT Server 服务器名称Server: Apache/2.4.1 (Unix) Set-Cookie 设置HTTP CookieSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Status 设置HTTP响应状态Status: 200 OK Strict-Transport-Security 一种HSTS策略通知HTTP客户端缓存HTTPS策略多长时间以及是否应用到子域Strict-Transport-Security: max-age=16070400; includeSubDomains Trailer 标识给定的header字段将展示在后续的chunked编码的消息中Trailer: Max-Forwards Transfer-Encoding 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identityTransfer-Encoding: chunked TSV Tracking Status Value，在响应中设置给DNT(do-not-track),可能的取值 “!” — under construction “?” — dynamic “G” — gateway to multiple parties “N” — not tracking “T” — tracking “C” — tracking with consent “P” — tracking only if consented “D” — disregarding DNT “U” — updatedTSV: ? Upgrade 请求客户端升级协议Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket Vary 通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的Example 1: Vary: *Example 2: Vary: Accept-Language Via 通知客户端代理，通过其要发送什么响应Via: 1.0 fred, 1.1 example.com (Apache/1.1) Warning 实体可能会发生的问题的通用警告Warning: 199 Miscellaneous warning WWW-Authenticate 标识访问请求实体的身份验证方案WWW-Authenticate: Basic X-Frame-Options 点击劫持保护： deny frame中不渲染 sameorigin 如果源不匹配不渲染 allow-from 允许指定位置访问 allowall 不标准，允许任意位置访问X-Frame-Options: deny 常用非标准响应头字段 X-XSS-Protection 过滤跨站脚本X-XSS-Protection: 1; mode=block Content-Security-Policy, X-Content-Security-Policy,X-WebKit-CSP 定义内容安全策略X-WebKit-CSP: default-src ‘self’ X-Content-Type-Options 唯一的取值是””,阻止IE在响应中嗅探定义的内容格式以外的其他MIME格式X-Content-Type-Options: nosniff X-Powered-By 指定支持web应用的技术X-Powered-By: PHP/5.4.0 X-UA-Compatible 推荐首选的渲染引擎来展示内容，通常向后兼容，也用于激活IE中内嵌chrome框架插件X-UA-Compatible: IE=EmulateIE7X-UA-Compatible: IE=edgeX-UA-Compatible: Chrome=1 X-Content-Duration 提供音视频的持续时间，单位是秒，只有Gecko内核浏览器支持X-Content-Duration: 42.666 Upgrade-Insecure-Requests 标识服务器是否可以处理HTTPS协议Upgrade-Insecure-Requests: 1 X-Request-ID,X-Correlation-ID 标识一个客户端和服务端的请求X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"ajax携带cookie","slug":"ajax携带cookie","date":"2019-04-15T08:39:46.000Z","updated":"2019-04-15T08:59:48.714Z","comments":true,"path":"2019/04/15/ajax携带cookie/","link":"","permalink":"/2019/04/15/ajax携带cookie/","excerpt":"ajax同域和跨域情况下携带cookie问题","text":"ajax同域和跨域情况下携带cookie问题 ajax携带cookie这是一个老生常谈的问题，但是时间长了总容易忘掉，今天记录下来，以便下次方便记起来。 首先，今天我遇到了一个坑，chrome浏览无论是同域还是跨域状态下，浏览器request headers里居然都不显示，刚开始我还以为是设置错了，后来发现其他浏览器都显示，我想有可能是chrome浏览器安全考虑吧，但是，这并不影响后台接收，只是不显示而已。 同域下无可厚非，什么都不用做就会带上cookie。 跨域下的设置：浏览器端，需要设置withCredentials为true1234567891011121314151617181920212223// 原生方式var xhr = new XMLHttpRequest();xhr.open('GET', 'http://example.com/', true);xhr.withCredentials = true;// jquery方式$.ajax(&#123; url: \"http://192.168.252.12:3006/post_form\", type: 'POST', xhrFields: &#123; withCredentials: true // 这里设置了withCredentials &#125;, success: function(data) &#123; console.log(data) &#125;, error: function(err) &#123; console.error(err) &#125; &#125;);// axios方式import axios from 'axios';axios.defaults.withCredentials = true; 再来说说后端的设置，以nodejs的express为例：123// 返回头设置res.header(\"Access-Control-Allow-Origin\", \"http://localhost:9000\"); // 注意，这里不能写*,应该是具体的地址res.header(\"Access-Control-Allow-Credentials\", \"true\"); 最后附上demo代码：前端12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; ajax cookie demo&lt;/body&gt;&lt;script&gt; $.ajax(&#123; url: \"http://192.168.252.12:3006/post_form\", type: 'POST', xhrFields: &#123; withCredentials: true // 这里设置了withCredentials &#125;, success: function(data) &#123; console.log(data) &#125;, error: function(err) &#123; console.error(err) &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 后端123456789101112131415161718192021222324252627282930313233343536373839var express = require('express');var app = express();var multiparty = require('multiparty');var bodyParser = require('body-parser');var cookieParser = require('cookie-parser'); app.set('port',process.env.PORT || 3006); //设置端口app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"http://localhost:9000\"); res.header(\"Access-Control-Allow-Credentials\", \"true\"); res.header(\"Access-Control-Allow-Headers\", \"client-token,Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1'); if(req.method==\"OPTIONS\") res.send(200); //让options请求快速返回 else next();&#125;);//使用static中间件 制定public目录为静态资源目录,其中资源不会经过任何处理app.use(express.static(__dirname + '/public'));app.use(bodyParser.json()); // for parsing application/jsonapp.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // for parsing application/x-www-form-urlencodedapp.use(cookieParser()); // cookie解析app.post('/post_form',function(req,res)&#123; var data = &#123; name: req.body.name, info: req.body.info, hostName: req.hostname &#125;; res.cookie(\"add\", 'test456', &#123;maxAge: 900000, httpOnly: true&#125;); // 设置cookie console.log('cookie-&gt;' + req.cookies.add); // 读取cookie res.send(data); &#125;);app.listen(app.get('port'), function () &#123; console.log( '服务器启动完成，端口为： '+app.get('port') );&#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"let存在变量提升吗?","slug":"let存在变量提升吗","date":"2019-04-10T07:20:08.000Z","updated":"2019-04-10T08:02:51.446Z","comments":true,"path":"2019/04/10/let存在变量提升吗/","link":"","permalink":"/2019/04/10/let存在变量提升吗/","excerpt":"javascript中关于let的一些小知识","text":"javascript中关于let的一些小知识 let存在变量提升吗?let是ES6推出的新语法，平时简单的用大家都明白，但是里边的原理还是很深的。在MDN的文档中对于let的特性是这样说的： let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时死区，不会被提升。我们来看一个小demo123456789&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;);&lt;/script&gt;&lt;script&gt; let b = 12 console.log(b)&lt;/script&gt; 代码执行报错：Uncaught SyntaxError: Identifier ‘b’ has already been declared 先给window创建b的属性，然后再去声明b，这个时候，b是个全局变量可以直接通过b访问，let 又不可以重复声明。此处可以解释的通。那么请看下面的代码123456789&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;); let b = 12&lt;/script&gt;&lt;script&gt; console.log(b)&lt;/script&gt; 如果把let b 提升到上面的script块就可以声明成功。如果说从上往下执行的话，b是已经存在的了，那么let b是不可以声明的成功的。 到这里就有些解释不通了。为什么window已经声明了b的属性，会成为一个单独的b变量。let 的时候却没有报错呢。这里就需要对let 是不是会变量提升划一个问号了。 先把这个问题放在这里，我们继续看下面这段代码。12345678&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;); console.log(window.b) let b = 12 console.log(b)&lt;/script&gt; window下已经声明了b的属性，而且let 一个b 打印出来分别是22和12。这里我们假设存在变量提升的话，那么js引擎在预解析的时候会先声明b对象。然后实际执行的时候，再给window创建b属性。到这里我们就可以解释的通了。既然存在变量提升的话，我是不是可以在声明之前打印一下b的值呢？1234567&lt;script&gt; Object.defineProperty(window, 'b', &#123; value: 22 &#125;); console.log(b) let b = 12&lt;/script&gt; 报错 Uncaught ReferenceError: b is not defined纳尼？难道let 真的不存在变量提升？因为鄙人有强迫症，本着不达目的不罢休的目的，问了度娘，找到了如下的参考资料。要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」。我们来看看 var 声明的「创建、初始化和赋值」过程1234567&lt;script&gt;function fn()&#123; var x = 1 var y = 2&#125;fn()&lt;/script&gt; 在执行 fn 时，会有以下过程（不完全）： 1.进入 fn，为 fn 创建一个环境。2.找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。3.将这些变量「初始化」为 undefined。4.开始执行代码5.x = 1 将 x 变量「赋值」为 16.y = 2 将 y 变量「赋值」为 2也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。接下来来看 function 声明的「创建、初始化和赋值」过程假设代码如下：1234567&lt;script&gt;fn2() function fn2()&#123; console.log(2)&#125;&lt;/script&gt; JS 引擎会有一下过程：1.找到所有用 function 声明的变量，在环境中「创建」这些变量。2.将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。3.开始执行代码 fn2()也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。接下来看 let 声明的「创建、初始化和赋值」过程假设代码如下123456&lt;script&gt;&#123; let x = 1 x = 2&#125;&lt;/script&gt; 我们只看 {} 里面的过程：1.找到所有用 let 声明的变量，在环境中「创建」这些变量2.开始执行代码（注意现在还没有初始化）3.执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）4.执行 x = 2，对 x 进行「赋值」这就解释了为什么在 let x 之前使用 x 会报错：1234567&lt;script&gt;let x = 'global'&#123; console.log(x) // Uncaught ReferenceError: x is not defined let x = 1&#125;&lt;/script&gt; 原因有两个1.console.log(x) 中的 x 指的是下面的 x，而不是全局的 x2.执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）看到这里，你应该明白了 let 到底有没有提升：1.let 的「创建」过程被提升了，但是初始化没有提升。2.var 的「创建」和「初始化」都被提升了。function 的「创建」「初始化」和「赋值」都被提升了。 至此 我们也可以解释 为什么跨script标签提示重复声明：因为浏览器是从上往下执行js代码的，也就是说在第一段js执行完成之后，再去预解析第二段js代码，执行第二段代码。 为什么在同一个script标签中可以定义b： 因为在js引擎预解析script的时候先创建了b。然后再执行Object.defineProperty为window增加b属性。所以此处的b和window.b不是一个变量。 为什么在同一个script标签中可以定义b，但是在b声明之前会报错b没有定义：因为只是创建了b变量，并没有初始化。没有初始化，变量是不可以使用的","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"封装ajax工具插件","slug":"封装ajax工具插件","date":"2019-04-03T06:47:46.000Z","updated":"2019-04-03T07:07:43.636Z","comments":true,"path":"2019/04/03/封装ajax工具插件/","link":"","permalink":"/2019/04/03/封装ajax工具插件/","excerpt":"封装一个自己的ajax工具插件","text":"封装一个自己的ajax工具插件 封装ajax工具插件我们在平时开发的时候，ajax请求都会用到现有库，用的比较多的如jquery，axios等，偶尔自己写个原生ajax请求的情况也有，这些库是怎么写的呢，我们自己封装一个库，来学习学习ajax的一些基础知识。在写这篇文章的时候，是因为头两天同事问我一个ajax问题，关于请求参数的，我突然回答不出来，忘记了，于是翻出来2年前自己封的ajax工具看了一眼，知道了怎么回事，决定把代码写到博客里，忘了的时候方便看一下。下面我只贴出了核心代码，其他部分我会提供github的地址：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184;(function(window,undefined)&#123; // jinuxAjax挂载到window上 window.jinuxAjax = function(opt)&#123; ieAjaxInit(); //默认参数配置 var defaultOpt = &#123; url:'', type: 'GET', data: null, contentType: 'application/x-www-form-urlencoded',//'text/plain;charset=UTF-8','application/json','multipart/form-data' timeOut: 5000, files:[], progress: null, before: fn, success: fn, error: fn, complete: fn &#125;; //参数对象继承获取新参数对象 if(Object.assign)&#123; var opt = Object.assign(&#123;&#125;, defaultOpt, opt); &#125;else &#123; for(var name in defaultOpt)&#123; defaultOpt[name] = opt[name] || defaultOpt[name]; &#125; var opt = defaultOpt; &#125; requestData(opt); &#125; //将json格式数据转成application/x-www-form-urlencoded格式数据 function encodeFormData(data)&#123; if(!data) return ''; var pairs = []; for(var name in data)&#123; if(!data.hasOwnProperty(name)) continue; if(typeof data[name] === 'function') continue; var value = data[name].toString(); name = encodeURIComponent(name.replace('%20','+')); value = encodeURIComponent(value.replace('%20','+')); pairs.push(name + '=' + value); &#125; return pairs.join('&amp;'); &#125; //ajax的get请求函数 function getData(opt)&#123; var request = new XMLHttpRequest(); var timeoutFlag = false; //是否超时 //启动计时器，做超时处理 var timer = setTimeout(function()&#123; timeoutFlag = true; request.abort(); &#125;,opt.timeOut); request.open('GET',opt.url +'?'+ encodeFormData(opt.data)); opt.before(); //请求之前执行before函数 request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(timeoutFlag) return; clearTimeout(timer); if(request.status === 200)&#123; var type = request.getResponseHeader('Content-Type'); //检查type类型做相应的解析处理 if(type.indexOf('xml') !== -1 &amp;&amp; request.responseXML)&#123; //xml相应 opt.success(request.responseXML); &#125;else if(type.indexOf('application/json') !== -1) &#123; //json相应 opt.success(JSON.parse(request.responseText)); &#125;else &#123; opt.success(request.responseText); &#125; &#125;else &#123; opt.error(request); &#125; opt.complete(); &#125; &#125; request.send(null); &#125; //ajax的post请求函数 function postData(opt)&#123; var request = new XMLHttpRequest(), sendData=null; var timeoutFlag = false; //是否超时 //启动计时器，做超时处理 var timer = setTimeout(function()&#123; timeoutFlag = true; request.abort(); &#125;,opt.timeOut); request.open('POST',opt.url); request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(timeoutFlag) return; clearTimeout(timer); if(request.status === 200)&#123; var type = request.getResponseHeader('Content-Type'); //检查type类型做相应的解析处理 if(type.indexOf('xml') !== -1 &amp;&amp; request.responseXML)&#123; //xml相应 opt.success(request.responseXML); &#125;else if(type.indexOf('application/json') !== -1) &#123; //json相应 opt.success(JSON.parse(request.responseText)); &#125;else &#123; opt.success(request.responseText); &#125; &#125;else &#123; opt.error(request); &#125; opt.complete(); &#125; &#125; //处理接收进度事件 if(opt.progress.enable &amp;&amp; request.upload)&#123; request.upload.onprogress = function(ev)&#123; if(ev.lengthComputable)&#123; opt.progress.receiveHandle(ev); &#125; &#125; request.upload.onload = function(ev)&#123; opt.progress.successHandle(ev); &#125; &#125; if(opt.contentType === 'application/x-www-form-urlencoded')&#123; request.setRequestHeader('Content-Type','application/x-www-form-urlencoded; charset=UTF-8'); sendData = encodeFormData(opt.data); &#125;else if(opt.contentType === 'application/json') &#123; request.setRequestHeader('Content-Type','application/json; charset=utf-8'); sendData = JSON.stringify(opt.data); &#125;else if(opt.contentType === 'multipart/form-data') &#123; var fd = new FormData(); for(var name in opt.data)&#123; if( !opt.data.hasOwnProperty(name) ) continue; if( typeof opt.data[name] === 'function' ) continue; fd.append(name,opt.data[name]); &#125; for(var i=0; i&lt;opt.files.length; i++)&#123; fd.append('file'+i,opt.files[i]); &#125; sendData = fd; &#125; request.send(sendData); &#125; //ajax请求函数，在函数内再调用get或者post function requestData(opt)&#123; if(opt.type === 'GET')&#123; getData(opt); &#125; else &#123; postData(opt); &#125; &#125; // 定义一个空函数 function fn()&#123;&#125; // 如果是ie6，创建XMLHttpRequest对象 function ieAjaxInit()&#123; if(window.XMLHttpRequest === undefined)&#123; window.XMLHttpRequest = function()&#123; try &#123; return new ActiveXObject('Msxml2.XMLHTTP.6.0'); &#125; catch (e1) &#123; try &#123; return new ActiveXObject('Msxml2.XMLHTTP.3.0'); &#125; catch (e2) &#123; throw new Error('不支持XMLHttpRequest'); &#125; &#125; &#125; &#125; &#125; //&#125;)(window); 详细代码请点击这里看源码","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2019-04-03T05:45:23.000Z","updated":"2019-04-03T06:32:46.011Z","comments":true,"path":"2019/04/03/防抖与节流/","link":"","permalink":"/2019/04/03/防抖与节流/","excerpt":"简单的介绍一下防抖与节流","text":"简单的介绍一下防抖与节流作为一名前端开发者，我们经常会处理各种事件，比如常见的click、scroll、 resize等等。仔细一想，会发现像scroll、scroll、onchange这类事件会频繁触发，如果我们在回调中计算元素位置、做一些跟DOM相关的操作，引起浏览器回流和重绘，频繁触发回调，很可能会造成浏览器掉帧，甚至会使浏览器崩溃，影响用户体验。针对这种现象，目前有两种常用的解决方案：防抖和节流。 防抖（debounce）所谓防抖，就是指触发事件后，就是把触发非常频繁的事件合并成一次去执行。即在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算。 以我们生活中乘车刷卡的情景举例，只要乘客不断地在刷卡，司机师傅就不能开车，乘客刷卡完毕之后，司机会等待几分钟，确定乘客坐稳再开车。如果司机在最后等待的时间内又有新的乘客上车，那么司机等乘客刷卡完毕之后，还要再等待一会，等待所有乘客坐稳再开车。具体应该怎么去实现这样的功能呢？第一时间肯定会想到使用setTimeout方法，那我们就尝试写一个简单的函数来实现这个功能吧~12345678910var debounce = function(fn, delayTime) &#123; var timeId; return function() &#123; var context = this, args = arguments; timeId &amp;&amp; clearTimeout(timeout); timeId = setTimeout(function &#123; fn.apply(context, args); &#125;, delayTime) &#125;&#125; 思路解析：执行debounce函数之后会返回一个新的函数，通过闭包的形式，维护一个变量timeId，每次执行该函数的时候会结束之前的延迟操作，重新执行setTimeout方法，也就实现了上面所说的指定的时间内多次触发同一个事件，会合并执行一次。温馨提示：1、上述代码中arguments只会保存事件回调函数中的参数，譬如：事件对象等，并不会保存fn、delayTime2、使用apply改变传入的fn方法中的this指向，指向绑定事件的DOM元素。 节流（throttle）所谓节流，是指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。 类比到生活中的水龙头，拧紧水龙头到某种程度会发现，每隔一段时间，就会有水滴流出。说到时间间隔，大家肯定会想到使用setTimeout来实现，在这里，我们使用两种方法来简单实现这种功能：时间戳和setTimeout定时器。 时间戳123456789101112var throttle = (fn, delayTime) = &gt;&#123; var _start = Date.now(); return function() &#123; var _now = Date.now(), context = this, args = arguments; if (_now - _start &gt;= delayTime) &#123; fn.apply(context, args); _start = Date.now(); &#125; &#125;&#125; 通过比较两次时间戳的间隔是否大于等于我们事先指定的时间来决定是否执行事件回调。 定时器12345678910111213var throttle = function(fn, delayTime) &#123; var flag; return function() &#123; var context = this, args = arguments; if (!flag) &#123; flag = setTimeout(function() &#123; fn.apply(context, args); flag = false; &#125;,delayTime); &#125; &#125;&#125; 在上述实现过程中，我们设置了一个标志变量flag，当delayTime之后执行事件回调，便会把这个变量重置，表示一次回调已经执行结束。 对比上述两种实现，我们会发现一个有趣的现象：1、使用时间戳方式，页面加载的时候就会开始计时，如果页面加载时间大于我们设定的delayTime，第一次触发事件回调的时候便会立即fn，并不会延迟。如果最后一次触发回调与前一次触发回调的时间差小于delayTime，则最后一次触发事件并不会执行fn；2、使用定时器方式，我们第一次触发回调的时候才会开始计时，如果最后一次触发回调事件与前一次时间间隔小于delayTime，delayTime之后仍会执行fn。这两种方式有点优势互补的意思，哈哈~我们考虑把这两种方式结合起来，便会在第一次触发事件时执行fn，最后一次与前一次间隔比较短，delayTime之后再次执行fn。想法简单实现如下：12345678910111213141516var throttle = function(fn, delayTime) &#123; var flag, _start = Date.now(); return function() &#123; var context = this, args = arguments, _now = Date.now(), remainTime = delayTime - (_now - _start); if (remainTime &lt;= 0) &#123; fn.apply(this, args); &#125; else &#123; setTimeout(function() &#123; fn.apply(this, args); &#125;,remainTime) &#125; &#125;&#125; 通过上面的分析，可以很明显的看出函数防抖和函数节流的区别：频繁触发事件时，函数防抖只会在最后一次触发事件只会才会执行回调内容，其他情况下会重新计算延迟事件，而函数节流便会很有规律的每隔一定时间执行一次回调函数。 requestAnimationFrame之前，我们使用setTimeout简单实现了防抖和节流功能，如果我们不考虑兼容性，追求精度比较高的页面效果，可以考虑试试html5提供的API–requestAnimationFrame。与setTimeout相比，requestAnimationFrame的时间间隔是有系统来决定，保证屏幕刷新一次，回调函数只会执行一次，比如屏幕的刷新频率是60HZ，即间隔1000ms/60会执行一次回调。1234567891011var throttle = function(fn, delayTime) &#123; var flag; return function() &#123; if (!flag) &#123; requestAnimationFrame(function() &#123; fn(); flag = false; &#125;); flag = true; &#125; &#125; 上述代码的基本功能就是保证在屏幕刷新的时候（对于大多数的屏幕来说，大约16.67ms），可以执行一次回调函数fn。使用这种方式也存在一种比较明显的缺点，时间间隔只能跟随系统变化，我们无法修改，但是准确性会比setTimeout高一些。注意： 防抖和节流只是减少了事件回调函数的执行次数，并不会减少事件的触发频率。 防抖和节流并没有从本质上解决性能问题，我们还应该注意优化我们事件回调函数的逻辑功能，避免在回调中执行比较复杂的DOM操作，减少浏览器reflow和repaint。上面的示例代码比较简单，只是说明了基本的思路。目前已经有工具库实现了这些功能，比如underscore，考虑的情况也会比较多，大家可以去查看源码，学习作者的思路，加深理解。underscore的debounce方法源码：1234567891011121314151617181920212223_.debounce = function(func, wait, immediate) &#123; var timeout, result; var later = function(context, args) &#123; timeout = null; if (args) result = func.apply(context, args); &#125;; var debounced = restArguments(function(args) &#123; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); &#125; else &#123; timeout = _.delay(later, wait, this, args); &#125; return result; &#125;); debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125;; underscore的throttle源码：1234567891011121314151617181920212223242526272829303132333435363738_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled;&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"HTML5中Video标签无法播放mp4的解决办法","slug":"HTML5中Video标签无法播放mp4的解决办法","date":"2019-03-21T01:13:22.000Z","updated":"2019-03-27T07:32:06.085Z","comments":true,"path":"2019/03/21/HTML5中Video标签无法播放mp4的解决办法/","link":"","permalink":"/2019/03/21/HTML5中Video标签无法播放mp4的解决办法/","excerpt":"解决其它格式视频转mp4格式文件，video标签无法播放问题","text":"解决其它格式视频转mp4格式文件，video标签无法播放问题 HTML5中Video标签无法播放mp4的解决办法首先，浏览器使用环境chrome在使用video标签播放视频的时候，我一般都选择mp4格式的文件，在网上下载的demo视频或者是手机拍摄的mp4文件都可以播放，但是，我用格式工厂把avi格式的文件转换成mp4文件就无法播放，为什么呢？带着疑问，上网找答案，找到了原因，如下：使用格式工厂的mp4转换功能转出来的mp4文件并不能使用，于是把能播放的视频文件和不能播放的视频文件的编码格式对比了一下可以播放的：不可以播放的：所以，在格式工厂转换的时候需要转成AVC编码格式的mp4文件好了，按照这种方式就可以正常播放了。*补充更新：上边的方式在pc端chrome浏览器上可以，但是在移动端上还是无法播放，最后没有办法，我采用了WebM格式。格式工厂可以转换，见下图","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端兼容性","slug":"移动端兼容性","date":"2019-03-05T01:43:57.000Z","updated":"2020-03-13T06:29:35.882Z","comments":true,"path":"2019/03/05/移动端兼容性/","link":"","permalink":"/2019/03/05/移动端兼容性/","excerpt":"移动端有关html标签节点的兼容性问题","text":"移动端有关html标签节点的兼容性问题 移动端兼容性meta标签1234567891011121314151617// viewport就啥也不说了，必须得加&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;// 启动或禁用自动识别页面中的电话号码&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;// 启动或禁用自动识别邮箱地址&lt;meta name=\"format-detection\" content=\"email=no\" /&gt; // 设置 Web 应用是否以全屏模式运行。&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;// ios 的 safari 顶端状态条的样式，可选的参数有：default、black、black-translucent&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;// winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; body,img等标签123456789// 禁止 ios 长按时不触发系统的菜单，禁止 ios&amp;android 长按时下载图片.css &#123; -webkit-touch-callout: none&#125;// 禁止ios和android用户选中文字.css &#123; -webkit-user-select:none&#125; 图片不清晰12345678910111213// 比如，iphone6，设备款375，物理像素750，正常一张占1/3屏幕的图片，125px，如果准备一张125的// 肯定会模糊，必须准备250px的。如果像iphone6 plus，像素比3， 占1/3的图片138px，实际需要414px。// 解决方案：@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .css &#123; background-image: url('2x.png'); &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .css &#123; background-image: url('3x.png'); &#125;&#125; 表单的标签123456789101112131415161718192021222324252627282930313233343536373839404142// input 输入框不可编辑&lt;input type=\"text\" name=\"name\" value=\"xxx\" disabled=\"true\"/&gt;&lt;input type=\"text\" name=\"name\" value=\"xxx\" readonly=\"true\"/&gt;/* disabled 文本框变灰，通过request.getParameter(\"name\")得不到文本框中的内容readonly 只是使文本框不能输入，样式没有变化，通过request.getParameter(\"name\")可以得到内容 */// ios 输入的时候英文首字母的默认大写&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt;// android 上去掉语音输入按钮input::-webkit-input-speech-button &#123; display: none&#125;// ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only;&#125; /* -webkit-user-modify 这个属性使用需谨慎，副作用就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类，不使用a或者input标签，直接用div标签 */// 表单元素的默认外观重置 -webkit-appearance:none;// 修改表单输入框 placeholder 的颜色值 input::-webkit-input-placeholder&#123;color:#ccc;&#125; input:focus::-webkit-input-placeholder&#123;color:#eee;&#125; // 注意 placeholder, ios 可以换行，android 不可以// Input 的placeholder会出现文本位置偏上的情况input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal// 禁用 select 默认下拉箭头select::-ms-expand &#123;display: none;&#125; // 禁用 radio 和 checkbox 默认样式input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display: none; &#125; a标签12部分安卓手机 a 标签用作按钮的时候，页面显示空白解决办法：用 button 标签替换 a 标签 button12345678910// 去除button在ios上的默认样式.css &#123; -webkit-appearance: none; border-radius: 0 &#125;// 不想让按钮touch时有蓝色的边框 .css &#123; -webkit-tap-highlight-color:rgba(0,0,0,0);&#125; audio和video12345678910111213// 在ios和andriod中,audio元素和video元素在无法自动播放// 应对方案：触屏即播$('html').one('touchstart',function()&#123; audio.play()&#125;)// ios 视频默认全屏播放，如何阻止全屏播放－ webkit-playsinline&lt;video id=\"video\" src=\"\" webkit-playsinline poster=\"\" &gt;&lt;/video&gt;// 视频，音频获取播放结束后的回调函数－ended$('#video').on('ended',function()&#123; alert(0);&#125;); click点击事件300毫秒延迟1234// 300毫秒延迟解决方案1.fastclick可以解决在手机上点击事件的300ms延迟2.zepto的touch模块，tap事件也是为了解决在click的延迟问题3.触摸事件的响应顺序为 touchstart --&gt; touchmove --&gt; touchend --&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题 ios(label,span)监听click事件,不触发1234// 所监听元素加上.css &#123; cursor:pointer&#125; css部分@-webkit-keyframes 注意12以0%开始100%结束，0%的百分号不能去掉after和before伪类无法使用动画 border-radius 注意123不支持%单位三星 Galaxy S4中自带浏览器不支持 border-radius 缩写同时写入 border-radius 和背景色的时候，背景色会溢出到圆角以外部分 解决 transition 闪屏123456.css&#123; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; &#125; 阻止用户调整微信浏览器字体大小1234// ios 管事，android 暂无解决方案body&#123; -webkit-text-size-adjust: 100%!important;&#125; 屏幕旋转的事件和样式12345678910111213141516171819202122232425// 1. 事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；// 代码判断window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125; &#125;// 2. 样式/*竖屏时使用的样式*/ @media all and (orientation:portrait) &#123; .css&#123;&#125; &#125;/*横屏时使用的样式*/ @media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; fixed元素无法点击1234567场景：父元素设置position: fixed;子元素设置position: absolute;此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。测试平台： 小米1S，Android4.0的Chrome18解决办法： 把父元素和子元素的overflow: hidden去掉。 overflow1234body如果设置height:100%;overflow:hidden是依然可以滑动的，如果需禁止，要再加一层div设置 height:100%加overflow：hidden（html,body加height:100%） ，这样元素超出body的高度也不能滑动了。或者同时给html，body加height:100%;overflow:hidden ios阻止旋转屏幕时自动调整字体大小123html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust:none;&#125; 通过transform进行skew变形，rotate旋转会造成出现锯齿现象123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0);transform: rotate(-4deg) skew(10deg) translateZ(0);outline: 1px solid rgba(255,255,255,0) iOS6下伪类:hover12345除了&lt;a&gt;之外的元素无效；在Android下则有效。类似div#topFloatBar_l:hover #topFloatBar_menu &#123; display:block; &#125;这样的导航显示在iOS6点击没有点击效果，只能通过增加点击侦听器给元素增减class来控制子元素。 点击按钮时背景变黑色的解决12345678910// 点击按钮时背景变黑色的解决-webkit-tap-highlight-color: transparent;// 当我们去掉默认的大黑块儿后，要添加自己想要的点击时按住按钮的效果，用以下代码：span:active&#123; box-shadow: inset 0 5px 10px #B41313,inset 0 -5px 10px #B41313;&#125;// 添加完上述代码后，在安卓上，都可以看到想要的效果，但是iphone上依旧不行，// :active 需要一个触发事件才可以，于是乎，用以下代码：document.body.addEventListener('touchstart', function () &#123;&#125;); retina屏下border的1px会变粗123456789101112131415161718192021222324252627282930313233343536373839404142434445// 因为像素比，比如，iphone6的像素比是2，window.devicePixelRatio可以查看，// iphone6的设备宽是375,而物理像素是750，在css中的1px，实际控制的是2px的像素，// 所以看起来会变粗了// 解决一：IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125;// 解决二：background渐变// 背景渐变, 渐变在透明色和边框色中间分割, frozenUI用的就是这种方法, 借用它的上边框写法:@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .ui-border-t &#123; background-position: left top; background-image: -webkit-gradient(linear,left bottom,left top,color-stop(0.5,transparent),color-stop(0.5,#e0e0e0),to(#e0e0e0)); &#125;&#125;// 解决三：// :before, :after与transform.radius-border&#123; position: relative;&#125;@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .radius-border:before&#123; content: \"\"; pointer-events: none; /* 防止点击触发 */ box-sizing: border-box; position: absolute; width: 200%; height: 200%; left: 0; top: 0; border-radius: 8px; border:1px solid #999; -webkit-transform(scale(0.5)); -webkit-transform-origin: 0 0; transform(scale(0.5)); transform-origin: 0 0; &#125;&#125; iphoneX兼容补充iphoneX适配","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"/tags/兼容性/"}]},{"title":"vue自定义指令之输入框限制字数","slug":"vue自定义指令之输入框限制字数","date":"2019-03-01T06:36:24.000Z","updated":"2019-03-04T08:15:45.039Z","comments":true,"path":"2019/03/01/vue自定义指令之输入框限制字数/","link":"","permalink":"/2019/03/01/vue自定义指令之输入框限制字数/","excerpt":"input输入框限制字数的指令制作","text":"input输入框限制字数的指令制作 vue自定义指令之输入框限制字数vue自定义指令没啥说的，说明见官网,具体代码见下面:12345678910111213141516171819Vue.directive('inputvalidatecounter', &#123; inserted: function (el, binding) &#123; var nSpan = document.createElement('span'), nInput = el.querySelector('input'), count = +binding.expression || 50; el.appendChild(nSpan); nSpan.innerHTML = '还可以填写'+count+'字'; nInput.addEventListener('input', function(ev) &#123; var num = count - this.value.length; if(num&lt;=0) &#123; setTimeout(() =&gt; &#123; var substr = this.value.substring(0,count-1); this.value = substr; &#125;, 10); &#125; nSpan.innerHTML = '还可以填写'+(num&lt;0?0:num)+'字'; &#125;, false); &#125;&#125;); 需要注意的地方： 这个指令只适用于iview的Input组件，看里边操作dom元素就可以看出来，想改成其它的也是简单。 在更改input的value的时候，最开始改不过来，后来我做了下延迟才解决这个问题，我想应该是在直接给input的value赋值后由于vue还在做监控，所以又给改回去了，所以来个延迟，在它监控触发结束后再改正。2019年3月4日更改123456789101112131415161718192021222324252627Vue.directive('inputvalidatecounter', &#123; inserted: function (el, binding, vnode) &#123; var nSpan = document.createElement('span'), nInput = el.querySelector('input') || el.querySelector('textarea'), count = +binding.expression || 50; el.appendChild(nSpan); nSpan.innerHTML = '还可以填写'+count+'字'; nInput.addEventListener('input', function(ev) &#123; var num = count - this.value.length; if(num&lt;=0) &#123; setTimeout(() =&gt; &#123; var substr = this.value.substring(0,count); this.value = substr; // 新添加开始 var keyArr = vnode.data.model.expression.split('.'); var evalStr = 'vnode.context._data'; keyArr.forEach((item, index)=&gt; &#123; evalStr += '[\"'+item+'\"]'; &#125;); eval(evalStr+'=\"'+this.value+'\"') // 新添加结束 &#125;, 10); &#125; nSpan.innerHTML = '还可以填写'+(num&lt;0?0:num)+'字'; &#125;, false); &#125;&#125;); 新添加的内容只有几行，其实是为了修改第一版的bug，当在input里输入内容的时候，超过一定字数后，进入延迟函数，这里把input的value值更改了，但是并没有更改这个指令所在组件里v-model的值，所以，这里需要修正。1234567891011// vnode是这个指令所在的组建的虚拟dom// vnode.data.model.expression 这就可以直接找到v-model里的变量名var keyArr = vnode.data.model.expression.split('.');// vnode知道了，vnode.context很显然就是组件所在的父级组件，可以通过 _data 这个数据去改变v-model里变量的值。var evalStr = 'vnode.context._data';keyArr.forEach((item, index)=&gt; &#123; evalStr += '[\"'+item+'\"]';&#125;);// 经过上边的循环是因为这种情况, v-model=\"formitem.name\"，像这种的值，而不是v-model=\"name\"这种。// 最后需要eval来执行这些字符串组成的代码。eval(evalStr+'=\"'+this.value+'\"')","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"js图片下载之后端部分","slug":"js图片下载之后端部分","date":"2019-02-27T05:31:24.000Z","updated":"2019-02-27T06:05:37.582Z","comments":true,"path":"2019/02/27/js图片下载之后端部分/","link":"","permalink":"/2019/02/27/js图片下载之后端部分/","excerpt":"nodejs服务返回图片二进制数据","text":"nodejs服务返回图片二进制数据 js图片下载之后端部分本站《js图片下载之前端部分》,写了如何利用js来下载图片，第二种方式需要后端返回图片的二进制数据，这篇文章我来写一下如何使用nodejs向前端返图片的二进制数据，我总结了三种方法。 方法一12345app.post('/downimg', function (req, res, next) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.createReadStream('./img/1.jpg') .pipe(res);&#125;); 这种方法利用了stream和pipe，一行代码就解决了，利用fs去读取图片的流只有，用pipe方法把流转给res，res自动就把数据返回给前端。 方法二1234567891011121314151617app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); var data = ''; var readerStream = fs.createReadStream(process.cwd() + '/img/1.jpg'); // 设置编码为 binary 必须 readerStream.setEncoding('binary'); readerStream.on('data', function(chunk) &#123; data += chunk; &#125;); readerStream.on('end',function()&#123; // 必须加上binary，返回的是二进制 res.end(data, 'binary'); &#125;); readerStream.on('error', function(err)&#123; console.log(err.stack); &#125;);&#125;); 这个方法其实跟第一个差不多，都是使用了fs的流来读取图片，但是没有使用pipe直接把数据流转给res，需要自己监听数据来处理，这里我试验了好多方式，终于成功了，注意readerStream.setEncoding(‘binary’)和res.end(data, ‘binary’)，都需要加上binary格式。 方法三123456789app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.readFile('./img/1.jpg', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; res.end(data); &#125;);&#125;); 这种方法时最简单的，但是遇到大文件会影响计算机的性能。 总结最后整体代码贴一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var express = require('express');var fs = require('fs');var app = express(); app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;);// stream+pipe方式一app.post('/downimg', function (req, res, next) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.createReadStream('./img/1.jpg') .pipe(res);&#125;); // stream方式二app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); var data = ''; var readerStream = fs.createReadStream(process.cwd() + '/img/1.jpg'); // 设置编码为 binary 必须 readerStream.setEncoding('binary'); readerStream.on('data', function(chunk) &#123; data += chunk; &#125;); readerStream.on('end',function()&#123; // 必须加上binary，返回的是二进制 res.end(data, 'binary'); &#125;); readerStream.on('error', function(err)&#123; console.log(err.stack); &#125;);&#125;);// 直接读取整个文件方式三app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.readFile('./img/1.jpg', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; res.end(data); &#125;);&#125;);var server = app.listen(3000, function () &#123; console.log(\"应用实例，访问地址为 http://%s:%s\", '127.0.0.1', '3000')&#125;)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"js图片下载之前端部分","slug":"js图片下载之前端部分","date":"2019-02-27T02:31:41.000Z","updated":"2019-02-27T06:03:47.927Z","comments":true,"path":"2019/02/27/js图片下载之前端部分/","link":"","permalink":"/2019/02/27/js图片下载之前端部分/","excerpt":"js控制图片下载","text":"js控制图片下载 js图片下载之前端部分这两天有一个小需求，就是点击页面中的下载按钮，下载指定的图片。经过一番的小研究，发现想实现这个功能，基本上都用到a标签的download属性，也就a标签的href指向图片地址，加上download属性后，点a标签就可以下载图片了。但是，有个问题，这需要在同域名下才好用，跨域貌似都不行，所以，在跨域的情况下就得另想办法。我总结了两种方法，一一道来。 方法一利用canvas，就是有一个图片地址，利用canvas把图片画出来，之后再通过canvas的toDataURL方法，将图片转为base64的数据，再把这个数据赋值给a标签的href属性，就可以了。这里注意一点，canvas调取toDataURL方法时，如果是跨域图片需要后台允许跨域，还需要在img标签的”crossOrigin”属性设置为’Anonymous’才管用，最后贴出具体代码：1234567891011121314151617181920212223function downloadImg(url)&#123; // 通过构造函数来创建的 img 实例，在赋予 src 值后就会立刻下载图片，相比 createElement() 创建 &lt;img&gt; 省去了 append()，也就避免了文档冗余和污染 var Img = new Image(), dataURL=''; Img.setAttribute(\"crossOrigin\",'Anonymous'); // 这里允许了跨域图片 Img.src=url; Img.onload=function()&#123; // 要先确保图片完整获取到，这是个异步事件 var canvas = document.createElement(\"canvas\"), // 创建canvas元素 width=Img.width, // 确保canvas的尺寸和图片一样 height=Img.height; canvas.width=width; canvas.height=height; canvas.getContext(\"2d\").drawImage(Img,0,0,width,height); // 将图片绘制到canvas中 dataURL=canvas.toDataURL('image/jpeg'); // 转换图片为dataURL var a = document.createElement('a'), body = document.body; a.download = 'img.jpg'; a.href = dataURL; body.append(a); a.click(); body.removeChild(a); &#125;; &#125; 方法二第二种方法就需要后端配合了，前端使用ajax请求到图片的二进制数据，之后利用了FileReader这个API，具体看代码：1234567891011121314151617181920212223242526 function downloadImg(url) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', url, true); // 请求方式 xhr.responseType = \"blob\"; // 返回类型blob xhr.onload = function () &#123; // 请求完成 if (this.status === 200) &#123; // 返回200 var blob = this.response; var reader = new FileReader(); reader.readAsDataURL(blob); // 转换为base64，可以直接放入a标签的href reader.onload = function (e) &#123; // 转换完成，创建一个a标签用于下载 var a = document.createElement('a'), body = document.body; a.download = 'img.jpg'; a.href = e.target.result; body.append(a); a.click(); body.removeChild(a); &#125; &#125; &#125;; // 发送ajax请求 xhr.send()&#125; 这个方法需要后端发送图片的二进制数据，我也写了nodejs的发送方法，见《js图片下载之后端部分》","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"浏览器消息提示Notification","slug":"浏览器消息提示Notification","date":"2019-02-14T06:41:44.000Z","updated":"2019-02-14T06:54:50.672Z","comments":true,"path":"2019/02/14/浏览器消息提示Notification/","link":"","permalink":"/2019/02/14/浏览器消息提示Notification/","excerpt":"浏览器自带的消息提示框","text":"浏览器自带的消息提示框 浏览器消息提示Notification这两天有一个新需求，微信网页版有这个功能，就是当浏览器最小化后，微信来消息，这时在电脑桌面的右下角会有消息提示框。这个功能用到了浏览器新特性的Notification接口，虽说兼容性不好，但是在现代浏览器上使用还是可以的。直接贴出demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Notification&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"message\"&gt;弹消息&lt;/button&gt; &lt;button id=\"message-delay\"&gt;弹消息延迟&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var btn = document.getElementById('message'); var btnDelay = document.getElementById('message-delay'); btn.addEventListener('click', ()=&gt; &#123; notifyMe(&#123; title: '消息通知', body: '菜品订单', icon: './asset/image/icon.png' &#125;); &#125;, false); btnDelay.addEventListener('click', ()=&gt; &#123; setTimeout(()=&gt; &#123; notifyMe(&#123; title: '消息通知', body: '菜品订单', icon: './asset/image/icon.png' &#125;); &#125;, 5000); &#125;, false); function notifyMe(options) &#123; // if(!document.hidden) return; // 判断浏览器是否最小化 // 先检查浏览器是否支持 if (!(\"Notification\" in window)) &#123; alert(\"This browser does not support desktop notification\"); &#125; // 检查用户是否同意接受通知 else if (Notification.permission === \"granted\") &#123; // If it's okay let's create a notification var notification = new Notification(options.title, &#123; body: options.body, icon: options.icon, &#125;); &#125; // 否则我们需要向用户获取权限 else if (Notification.permission !== 'denied') &#123; Notification.requestPermission(function (permission) &#123; // 如果用户同意，就可以向他们发送通知 if (permission === \"granted\") &#123; var notification = new Notification(options.title, &#123; body: options.body, icon: options.icon, &#125;); &#125; &#125;); &#125; // 过3秒关闭提示框 setTimeout(function() &#123; notification.close(); &#125;, 3000); &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-01-31T08:57:14.000Z","updated":"2019-10-29T06:57:57.616Z","comments":true,"path":"2019/01/31/git常用命令/","link":"","permalink":"/2019/01/31/git常用命令/","excerpt":"工作中常用的git命令小总结","text":"工作中常用的git命令小总结 git常用命令git在我们工作中使用的很多，还有想github这样牛逼的代码托管网站，所以，git这个版本管理工具越来越多的被使用，其实git使用起来还是很复杂的，但是，我平时只是提交代码，所以就用到了几个命令而已，在这里做一下记录。这里，推荐一个git学习网站，点这里 先来个简单点的 首先就是把现有的项目clone到本地。 1git clone https://github.com/jixoba/jQuery-Seat-Charts.git 之后就是我常用的几个提交命令 12345git status // 查看更改的文件有哪些git add . // add后边.的话，就是把所有改动的文件添加进去git commit -m &quot;提交log信息&quot; // 提交信息git pull // 拉取远程仓库的内容git push // 最后把更改内容推到远程仓库中 以上就是我经常用到的简单命令，如果有分支的话可能会复杂点，根据提示就可以了 说点复杂的 新建分支 1git branch branchname // branchname就是分支名 查看分支 12git branch -a //查看所有分支git branch -r //查看远程分支 本地切换分支 1git checkout branchname 删除本地分支 1git branch -d branchname 合并分支merge 12// 假设当前在master分支上，想合并bugFix分支的内容git merge bugFix 合并分支rebase 12// 假设当前在master分支上，想合并bugFix分支的内容git rebase bugFix 分支的移动 12345678910111213// 比如当前有两个分支master和bugFix，当前在master上// 现在想在master分支得提交记录往前移动2步git checkout HEAD^^git checkout master^^git checkout master~2git checkout 40位的哈希值 // 这个哈希值可以用git log来查看// 以上4种方法都可以移动提交位置// 现在想在bugFix分支得提交记录往前移动1步git checkout bugFix^git checkout bugFix~git checkout 40位的哈希值// 注意，这里不能用HEAD，因为当前并不在bugFix分支上 分支的强制移动指向 12git branch -f master bugFix~3// 将master强制指向了bugFix分支往前3个提交 撤销提交 1234// 本地的commit撤销git reset HEAD// 远程的commit撤销git revert HEAD 分支的复制 12// 当前在master分支上，想把bugFix分支复制到当前分支之前，可以查看master之前分支的commit记录git cherry-pick bugFix 克隆带有分支的项目方法一 1git clone -b template https://github.com/iview/iview-admin.git // clone template分支 克隆带有分支的项目方法二 1234567git clone https://github.com/iview/iview-admin.git // clone整个项目git branch -a //列出所有分支名称如下： * 号表示当前分支 * dev remotes/origin/HEAD -&gt; origin/dev remotes/origin/desktop remotes/origin/template 接下来，可以在本地新建分支并与远程仓库的分支进行关联了 1git checkout -b template origin/template // 作用是checkout远程仓库origin的分支template，在本地起名为template分支，并切换到本地的template分支 把本地已有的分支推送到远程仓库上 1git push origin 本地分支名:远程分支名 删除远程仓库的分支 1git push origin --delete 远程分支名","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"jquery座位插件","slug":"jquery座位插件","date":"2019-01-29T07:44:05.000Z","updated":"2019-01-29T08:38:49.604Z","comments":true,"path":"2019/01/29/jquery座位插件/","link":"","permalink":"/2019/01/29/jquery座位插件/","excerpt":"一个画座位图的jquery插件","text":"一个画座位图的jquery插件 jquery座位插件最近这两天在画飞机的座位布局图和选座系统，本来想自己直接用原生画出来的，但是领导说其他部门做过相关功能，别的部门用的是jQuery-Seat-Charts这个插件，所以我也得使用。这里是插件地址，我fork了下来其实，这个插件的使用很简单，按照giyhub的文档就可以使用，因为需要定制开发，所以我大致的看了一下源码，觉得很好，主要是它在每个座位上加的事件，如果是我写的话，可能使用click事件，但是它用的focus事件和blur事件，正常情况下只有form表单的一些元素才有focus事件，但是想在div上也使用focus事件的话，需要给这个div加上tabIndex属性，一般情况下设为-1，就可以直接使用div的el.focus()方法了，我觉得这个好处就是，当点击其它座位时，之前focus的座位会触发blur事件，可以在这里做一些操作，简化了代码。以后再画座位的时候还可以使用这个插件，比如电影院选做系统，动车，飞机等，还是很方便的的。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"手写一个trigger插件","slug":"手写一个trigger插件","date":"2019-01-22T07:22:58.000Z","updated":"2019-01-22T08:41:41.185Z","comments":true,"path":"2019/01/22/手写一个trigger插件/","link":"","permalink":"/2019/01/22/手写一个trigger插件/","excerpt":"自己写一个简单的trigger来触发事件","text":"自己写一个简单的trigger来触发事件 手写一个trigger插件各位小伙伴们，jquery大家超级熟悉吧，jquery的trigger函数一定知道吧，反正我是非常喜欢用它，有时候比如要把一个弹出层隐藏掉，大家可能会去改这个弹出层的css，但是我可能会直接trigger一下这个弹出层取消按钮，因为我懒嘛，哈哈。但是，有时候可能想用trigger的时候，发现并没有使用jquery，额，自己写一个吧，其实，这段代码的核心部分我是参考了百度的一个手势库，好像叫touch.js,当时看的时候貌似这个库已经5年没人维护了，不过，模拟触发事件的代码被我留下了。见下面：12345678910111213141516171819202122232425262728293031323334;(function(root, factory) &#123; if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory; else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"jinuxTrigger\"] = factory; else root[\"jinuxTrigger\"] = factory;&#125;)(this, function(el, evt, detail) &#123; detail = detail || &#123;&#125;; var e, opt = &#123; bubbles: true, cancelable: true, detail: detail &#125;; try &#123; if (typeof CustomEvent !== 'undefined') &#123; e = new CustomEvent(evt, opt); if (el) &#123; el.dispatchEvent(e); &#125; &#125; else &#123; e = document.createEvent(\"CustomEvent\"); e.initCustomEvent(evt, true, true, detail); if (el) &#123; el.dispatchEvent(e); &#125; &#125; &#125; catch (ex) &#123; console.warn(\"jinux-trigger is not supported by environment.\"); &#125;&#125;); 再附上一个小demo123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jinux-trigger&lt;/title&gt; &lt;script src=\"./trigger.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;页面加载进来之后，等待3秒后代码触发按钮的点击事件&lt;/h1&gt; &lt;button&gt;点击...&lt;/button&gt;&lt;/body&gt;&lt;script&gt; const btn = document.querySelector('button'); btn.addEventListener('click',()=&gt;&#123; alert('点击按钮被点击了！！！'); &#125;,false); //页面加载进来之后，等待3秒后代码触发按钮的点击 setTimeout(()=&gt;&#123; jinuxTrigger(btn,'click'); &#125;,3000);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"js工具库","slug":"js工具库","permalink":"/tags/js工具库/"}]},{"title":"谷歌黑语法","slug":"谷歌黑语法","date":"2019-01-14T05:49:16.000Z","updated":"2019-01-15T06:05:34.367Z","comments":true,"path":"2019/01/14/谷歌黑语法/","link":"","permalink":"/2019/01/14/谷歌黑语法/","excerpt":"关于搜索引擎的一些使用技巧","text":"关于搜索引擎的一些使用技巧 谷歌黑语法平时，我们经常用百度来搜索一些东西，由于墙的原因，我们很少用谷歌，但是我们工作生活中使用百度就已经足够了。今天这篇文章介绍一下谷歌搜索的使用技巧，因为谷歌是所搜的老大，所以其它搜索引擎也来效仿谷歌，因而，下边介绍的这些搜索知识，基本上所有的搜索引擎都会适用的。 基础语法谷歌的默认搜索是and逻辑，意思就是，我们在输入关键字后进行搜索时，如输入：“program google”后，会搜出包含“program”和“google”的文件内容，如下图1所示。说到这里，我就插入一个小知识点：基础布尔逻辑。对于一个搜索引擎来说，进行搜索的时候是要搜索到匹配到所有关键词的页面，还是包含关键词中的任意关键词就可以，取决于一个搜索引擎的一些特别算法，称之为搜索引擎的布尔逻辑默认值。而google就是用and作为默认逻辑（搜索到所有的关键词），当然这个前提是我们没有输入一些特殊的命令。如果你不确定你要搜索的内容，或者你想搜索两个中的任意一个，那么就要使用关键词“OR”。注意：OR是大写的，小写是不起作用的，而且，每一个关键词与“OR”之间是有一个空格的，我们来看一下搜索结果。当然，可以预想的是，google的结果要比program多得多，所以结果第一页全是有关google的内容。此外，还可以借助计算机体系语言中的“|”来代替“OR”，效果是一样的。当然，如果你希望搜索“programgoogle”的内容，而不希望这两个单词之间有任何其他的内容，那么就要使用双引号把搜索的内容组成一个词组来达到目的。如下图3所示。如上图所示，结果中的programgoogle都是在一起的，没有分割。当然这样的结果比较少，只有2740个，但是看图1，结果却有7亿多个。而且，大部分搜索引擎都有智能断句的功能，如果没有特殊的命令，搜索引擎会一定量的根据大众的语言使用习惯来判断你要搜索什么，而这样的做法，不仅仅没有使搜索引擎显得不听话，反而对大众来讲搜索引擎变得十分智能和高效！但是如果我们只想看到“program”的内容，而不希望看到“google”的内容，就可以把“-”（减号或者破折号）应用到搜索当中去，语法为“program -google”，注意，“-”之前是有一个空格的，而其后却是和下一个关键词是紧紧相连的！搜索的结果如下图4所示。可以看得到结果中都会包含program，而不包含google。说到这里，还要提一下google的约束扩展问题了。一般来说，当输入关键词后，google会把相关网页和信息的结果呈现在我们面前。然而，有一些单词在搜索引擎中是会被智能忽略的，导致我们得不到想要的结果。比如十分常用的“www”和“the”，基本上任何一个网页上都会找到的东西，就会被google自动忽略（不要觉得这样不好，还是那个道理，在实际引用当中这样做反而显得更加高效和智能）。如果我们不想忽略这些词进行查询，就得在这些关键词的前面加上符号“+”。如下图5所示：看上去两者好像没有什么大的区别，其实仔细比较一下搜索结果就可以看得出，加上加号的搜索结果有一万多个，而不加加号的结果却有着55亿多！而因为google和www的关联度比较高，所以在前面的结果表现的差别不大。除了上述字符之外，一些搜索引擎支持一种叫做“stemming”（填充）的技术。Stemming是指在查询的关键词中添加一些通配符，通常是“*”，有时候也可能是“？”，这些通配符的作用是要求搜索引擎进行查询是可以返回多个不同的结果。其中通配符代表占位，可以匹配其他任意字母和单词，而其他的字或词组与用户输入的相同。如我们想要搜索“Lionel Messi”的内容，却忘记了第一个单词的一些拼写，就可以输入“l*Messi”进行查询，注意：此处整个字符串是要用一个英文半角双引号括住的！结果如下图所示。可以看到，google自动匹配出Lionel Messi的内容并且进行了搜索。这样的方式有利于我们只能记住单词或短语的一部分的内容时使用。基本的语法就讲到这里，上述的内容也没有列全，因为有些搜索功能不太常用。不过，这些语法就已经够我们日常使用的了，基本语法就是做基本的事，google也有一些高级的语法，见下边高级语法。 高级语法intitle首先要介绍的就是“intitle:”的用法，这个串的作用是将搜索的范围局限在标题上。在关键词前面加上这个，就会只对网页的标题进行搜索并且配对，最后将结果返回给用户。例如输入“intitle:program moon”进行搜索，就会返回如下图所示的结果。但是可以看到，貌似搜索结果中只出现了关于program的内容，而并没有moon相关的内容，这里其实还是牵扯到搜索引擎的基础布尔逻辑问题，在intitle:语法上，google会检索所有的网页，只要出现program或者moon其中的一个就会被匹配，意料之中的是，关于program的内容肯定是要远远多于moon的内容的，所以搜索结果里关于program的内容占据了主导，可以理解为moon这个关键词被一定量的智能忽略了。但是如果我们想要找到网页标题中既有program又有moon的网页呢?那么我们就要使用“intitle:”的一个变体“allintitle:”，使用这个前缀后，就能得到我们想要的结果了。如下图所示，除了第一条为google的图片推荐，其余的结果中网页的标题既含有program这个关键词，又含有moon这个关键词。 intext看到这个单词，大概就可以猜到它的意义了，“intext:”是用来搜索网页正文内容的，这样就可以忽略网页中的超文本链接、URL和题目。我们输入“intext:2018 program”进行搜索，结果如下图所示，结果中显示的网页大部分标题几乎没有规律，但是网页的索引中都包含着 “2018 program”，但是因为2018和program的同时出现的网页实在比较少，两个关键词的关联度实在不高（笔者此时的时间为2016年12月25日00:07:10），因为现在才是2016年，如果换成“2016 program”我相信应该会有更多的结果出现。但是我们要明白，这时搜索引擎关注的内容是网页的正文。与之相对应的也有一个变体：“allintext:”，用法和上面的“allintitle”相似，我就不做过多的介绍了。到这里恐怕就有读者要问了，这与我们平时的搜索相比没有什么高级的地方啊？确实，就平时的搜索来讲，这个语法的意义确实不太重大，但是在某些领域，例如黑客作为一名攻击者，构造好关键词配合适当的语法就可以进行撒网式的攻击，这个呢，我们点到为止，这里就不谈了。 inanchor这个语法的意思是在页面的链接锚点进行搜索。链接锚点指的是一个链接的描述文本，如这样的一段HTML代码：&lt;a href=https://www.baidu.com&gt;百度，链接的锚点就是“百度”了。我们搜索“inanchor:login”就可以搜索到有那些含有锚点的网页了，如下图所示。当然，这个语法也有一个变体“allinanchor:”，意思也与前面的类似。 site这个语法是把搜索限制在站点域名之内。例如我们搜索“program site:google.com”，结果如下图所示，这里呢，我们通常不需要加上前面的www，这样搜索的结果就会是包括所有含有google.com域名的有关内容，包括顶级域名和二级域名甚至三级域名的内容。也就是说我们甚至可以通过搜索，确定google.com大概有多少个子域名！ inurlinurl:会将搜索的范围限制在URL或者网站的页面上，这个语法对于查找搜索和帮助是很有用的，不仅适合我们普通的搜索，在黑客搜索中用处也很大。例如我们输入“inurl:password”，结果如下图所示，结果显示了所有URL中含有password的网页。另外，这个语法也有一个变体：“allinurl:”，用法与前面的相似。在黑客领域，inurl和site的使用是十分的频繁的，利用他们组合可以搜索到有用的信息，如我们可以使用1“site:google.com –inurl:www.google.com”，而这个语法的含义就是搜索google到底有多少个子域名。 link这个的功能是查询所有链接到某个特定URL上的列表。要注意的是，是特定的URL页面，如输入：1“link:www.baidu.com” 进行搜索，如下图所示，就会返回所有链接到百度主页的网页了。因此，我们同样可以指定特定的URL页面来进行搜索。 cacheCache可以帮助我们查找到google索引过的页面副本，它最大的好处就是即使源文件界面不存在了，或者变成了其它的内容，我们依然可以搜索的到。例如输入:1“cache：www.baidu.com” 结果如下所示，可以看到，格式虽然乱糟糟的，但是依稀可以从中获取一些有用的信息的。在国内的搜索引擎上，可能也有类似的功能，比如百度的网页快照，其功能与这个类似。 filetypefiletype是指搜索指定后缀的文件。这个不太常用，但是在黑客领域有一定的作用。但是我们的重点是讲解语法，所以这里就一笔带过（关于filetype的一些其他内容我会在以后的博文中展示），如下图所示，输入“filetype:mdb”，结果就会显示出一些网站的数据库文件。 related这个语法是用于搜索与某些页面相关的网站的，可以辅助我们搜索同类的页面。比如我们输入1“related:www.google.com” 显示的结果都是一些其他的搜索引擎。 info这个语法可以搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等，注意下面的英文信息就好。输入1“info:www.google.com” 结果如下图所示。 好了，大概就这么多了，还用别的这里就不介绍了，对于我这种小白来说已经够用的了。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"es6-async-await","slug":"es6-async-await","date":"2019-01-03T06:17:47.000Z","updated":"2019-01-03T06:26:12.963Z","comments":true,"path":"2019/01/03/es6-async-await/","link":"","permalink":"/2019/01/03/es6-async-await/","excerpt":"es6中async-await的demo","text":"es6中async-await的demo es6-async-awaites6现在已经在项目中使用了，async偶尔用，所以要用的时候总是忘记，写个小demo，用的时候看一眼，哈哈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;es7-async-await&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;es7-async-await&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; //写一个返回Promise的异步函数 function asyncTime(val, ms)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(val); &#125;,ms); &#125;); &#125; //async函数 async function testAsync()&#123; let a = await asyncTime(1, 1000); //a的值就是Promise函数里面resolve的参数值 console.log(a); let b = await asyncTime(a+1, 1000); console.log(b); let c = await asyncTime(b+1, 1000); console.log(c); let d = await 123; //await后面可以不是Promise函数，但是会自动包装成一个Promise函数并且立即向后执行 console.log(d); return c; &#125; testAsync().then(function(res)&#123; console.log('async函数的then函数-&gt;',res); &#125;); //async函数 async function testAsync_2()&#123; let a = await testAsync(); //因为async本身执行后会返回一个Promise函数(async函数内部return的值只作为async返回的Promise函数的then里的参数传入)，所以此处也可以在await后边写async函数。 console.log(a); return a; &#125; testAsync_2().then(function(res)&#123; console.log('async函数2的then函数-&gt;',res); &#125;); //再来一个多个异步函数执行的例子 async function testAsync_3()&#123; let a = await Promise.all([asyncTime('all1',2000),asyncTime('all2',2000),asyncTime('all3',2000)]); console.log(a); return a; &#125; testAsync_3().then(function(res)&#123; alert(res); &#125;);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"github预览静态库页面","slug":"github预览静态库页面","date":"2019-01-02T08:53:42.000Z","updated":"2019-01-03T00:52:33.164Z","comments":true,"path":"2019/01/02/github预览静态库页面/","link":"","permalink":"/2019/01/02/github预览静态库页面/","excerpt":"github预览静态库页面","text":"github预览静态库页面 github预览静态库页面类似于 https://jinux7.github.io 这样的github静态网站展示大家都知道怎么弄，在网上可以搜索到很多教程，我自己的blog网站就是这么搞的，但是这种方法我发现一个github账户只能弄出一个，今天我想说的是另一种方式，直接可以访问到普通库里的静态页面。这里需要github提供的一个服务地址，见下边：1https://htmlpreview.github.io/?https://raw.githubusercontent.com/jixoba/mobile_company/master/index.html 上边的这段地址就可以访问普通库里的静态页面了，注意jixoba/mobile_company这个，是库的名称，只需要更改这个库名，其它地方不需要动。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"cordova android打包配置详解","slug":"cordova-android打包配置详解","date":"2018-12-18T07:27:22.000Z","updated":"2018-12-19T05:22:57.679Z","comments":true,"path":"2018/12/18/cordova-android打包配置详解/","link":"","permalink":"/2018/12/18/cordova-android打包配置详解/","excerpt":"cordova打包android app","text":"cordova打包android app cordova android打包配置详解前几天在网上看到了cordova的东西，之前有过鼓捣react native和weex，所以看看它有什么特点。由于我用的是win10系统，所以在配置环境的时候相当的麻烦，这里稍微的屡一下。 一 安装JDKJDK是java的开发工具包，因为我们打包安卓的apk文件，安卓是依赖java的，所以这个必须安装。我刚开始安装的是最新版的，但是与cordova版本好像不是很搭，于是安装了JDK8这个版本。安装好了之后要配置环境变量，首先是新建变量名JAVA_HOME，指向JDK的安装目录，之后再配置一下path，指向JDK里的bin目录。再配置一下jre的path，也是指向jre里的bin目录。（jre安装有的直接安装JDK的时候顺便安装了，有的版本需要另外单独安装） 二 安装SDKSDK稍微有点复杂，首先还是下载SDK并且安装，这里需要注意，安装路径，我用的win10，必须安装在 用户/用户名/AppData/Local,其它系统可能无所谓。安装好了之后，还是配置环境变量，新建变量名ANDROID_SDK_HOME，指向安装的SDK目录，再配置path，指向SDK下的tools和platform-tools。 三 安装GradleGradle好像是一个打包工具，直接下载安装，之后配置一下Gradle的bin目录环境变量。 四 安装cordovacordova的安装和运行需要nodejs，所以用npm来安装。1npm i -g cordova@6.1.1 注意，这里我安装的是6.1.1版本，高版本莫名其妙的报错，这个稳妥一些。之后就是使用cordova来创建项目喽。12345cordova create app jinux.com.cn app // 创建一个项目cd app // 进入app项目cordova platform android // 添加安卓模板cordova requirements // 查看打包缺少什么依赖项cordova build android // 打包apk 以上的这些命令，在查看依赖项的时候肯定回报一些错误，SDK的一些依赖没有安装，进入SDK文件夹，打开SDK Manager.exe，根据依赖的提示下载相应的包，注意，这里是从谷歌上拉取，所以要开代理哦。第一次build的时候，Gradle需要从网络上下载一堆包，还是注意需要代理拉取谷歌的文件，很慢的，耐心等待。*下面是一个别人写的cordova博文，可供参考参考","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"/tags/cordova/"}]},{"title":"setTimeout&async&Promise执行顺序","slug":"setTimeout-async-Promise执行顺序","date":"2018-12-11T01:59:32.000Z","updated":"2018-12-11T02:36:37.697Z","comments":true,"path":"2018/12/11/setTimeout-async-Promise执行顺序/","link":"","permalink":"/2018/12/11/setTimeout-async-Promise执行顺序/","excerpt":"setTimeout&amp;async&amp;Promise执行顺序简要分析","text":"setTimeout&amp;async&amp;Promise执行顺序简要分析 setTimeout&amp;async&amp;Promise执行顺序看到标题，觉得这种需求在实际项目中基本遇不到，是的，我从没有遇到过，而且，要用就用一种，既然用了async，还用啥Promise。不过，网上有一道面试题，据说是今日头条的面试题，考的就是这方面的知识，先贴出代码。1234567891011121314151617181920async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1') resolve();&#125; ).then(function() &#123; console.log('promise2')&#125; )console.log('script end') 答案一会再说。先来分析一下，setTimeout,async,Promise执行的有先顺序。其实，要想研究明白这个问题，需要了解异步执行的宏任务，微任务知识，而且，在浏览器和nodejs环境下还不一样，这里我不对这些知识作深入分析，因为我看了些相关知识，看的晕头转向，所以，我只简单的记一下在浏览器环境下的优先顺序。异步发生的节点是：1.setTimeout的回调函数。2.Promise实例的then方法中的回调函数。3.async函数中await 后面紧跟着的函数（如async2），这个地方比较有意思，进入async2的时候是同步的，async2里边如果都是同步函数，那就继续执行，等执行完毕，返回先关东西后，”await async2()”这句话下边的语句不会马上执行，有点像Promise实例的then方法中的回调一样，需要排队等待。所以，优先顺序是Promise的then方法回调第一，async await 之后的语句排第二，setTimeout的回调排第三。记住了吗？我没有考虑理论知识，只是简单地死记硬背而已。最后，把上边代码的结果写出来，看看与你想的是否一样。12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"nodejs搭建https服务器","slug":"nodejs搭建https服务器","date":"2018-12-07T07:03:57.000Z","updated":"2018-12-07T08:03:44.502Z","comments":true,"path":"2018/12/07/nodejs搭建https服务器/","link":"","permalink":"/2018/12/07/nodejs搭建https服务器/","excerpt":"ssl证书的创建，https服务器的搭建","text":"ssl证书的创建，https服务器的搭建 nodejs搭建https服务器虽然作者是一名菜鸟前端，但是学习https相关的知识还是必须的。之前看过很多理论的文章，http与https的区别，ssl证书如何起作用的等等，说实话，我都忘记了，今天正好有时间，早上坐地铁就看了相关的文章，刚才写出了一个demo，现在就记录一下整个过程。 http与https区别 HTTP: 超文本传输协议 (Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTPS:（Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。创建ssl证书第一步，安装openssl安装openssl，很简单，按照正常的window软件按照下一步按照就可以，下面是下载地址，注意选择是64bit还是32bit哦,我下载了“Win64 OpenSSL v1.1.1a Ligh”这个版本，因为体积小，所以下载了light的版本。openssl下载地址安装好了之后，配置一下环境变量，这样在哪个文件夹下都可以直接使用openssl命令了。第二部，使用openssl创建ssl证书这个步骤还是有点小困难，在网上按照有的教程弄不好使，后来找到一个教程，好使，直接贴出命令行代码。12345678910111213141516171819202122232425262728293031323334#生成私钥key文件：~ D:\\workspace\\javascript\\nodejs-https&gt;openssl genrsa -out privatekey.pem 1024Generating RSA private key, 1024 bit long modulus...........................++++++........++++++e is 65537 (0x10001)#通过私钥生成CSR证书签名~ D:\\workspace\\javascript\\nodejs-https&gt;openssl req -new -key privatekey.pem -out certrequest.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:BeijingLocality Name (eg, city) []:BeijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:fens.meOrganizational Unit Name (eg, section) []:fens.meCommon Name (eg, YOUR name) []:Conan ZhangEmail Address []:bsspirit@gmail.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []:# 通过私钥和证书签名生成证书文件~ D:\\workspace\\javascript\\nodejs-https&gt;openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pemSignature oksubject=/C=CN/ST=Beijing/L=Beijing/O=fens.me/OU=fens.me/CN=Conan Zhang/emailAddress=bsspirit@gmail.comGetting Private key 注意在通过私钥生成CSR证书签名的时候需要添加一些个人信息。新生成了3个文件：certificate.pem, certrequest.csr, privatekey.pem privatekey.pem: 私钥 certrequest.csr: CSR证书签名 certificate.pem: 证书文件接下来，直接在nodejs的服务代码中引入相关文件就可以了。nodejs创建https服务器直接贴代码了，这步骤就很简单了1234567891011121314151617181920212223242526272829var app = require('express')();var fs = require('fs');var http = require('http');var https = require('https');var privateKey = fs.readFileSync('./ssl/privatekey.pem', 'utf8'), certificate = fs.readFileSync('./ssl/certificate.pem', 'utf8');var credentials = &#123;key: privateKey, cert: certificate&#125;;var httpServer = http.createServer(app);var httpsServer = https.createServer(credentials, app);var PORT = 18080;var SSLPORT = 18081;httpServer.listen(PORT, function() &#123; console.log('HTTP Server is running on: http://localhost:%s', PORT);&#125;);httpsServer.listen(SSLPORT, function() &#123; console.log('HTTPS Server is running on: https://localhost:%s', SSLPORT);&#125;);// Welcomeapp.get('/', function(req, res) &#123; if(req.protocol === 'https') &#123; res.status(200).send('Welcome to Safety Land!'); &#125; else &#123; res.status(200).send('Welcome!'); &#125;&#125;); 好了，https服务器搭建完成，原来这么简单。不过，有个问题，因为这个ssl证书属于个人证书，并不是第三方的安全CA证书，所以在浏览器访问https协议时候会有不安全的提醒文字，这个对于我们测试来说是没问题的，如果想在正规的网站上使用，我们还得去阿里云申请CA证书哦。最后，本想把本demo的代码上传到github，不过，代码实在是简单，不传了，直接放个截图得了。ssl文件夹里放了3个ssl文件哦。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"vue-iview Modal组件简单分析","slug":"vue-iview-Modal组件简单分析","date":"2018-12-04T07:49:12.000Z","updated":"2018-12-05T02:22:50.407Z","comments":true,"path":"2018/12/04/vue-iview-Modal组件简单分析/","link":"","permalink":"/2018/12/04/vue-iview-Modal组件简单分析/","excerpt":"vue-iview Modal组件简单分析","text":"vue-iview Modal组件简单分析 vue-iview Modal组件简单分析现在公司的项目前端框架用的是vue，在工作中避免不了要写一些组件，其实写组件的方法千千种，怎么写都行，但是，总想写出来的组件像一些ui框架里的组件一样高大上，于是乎，今天有点时间，大致的看了一下iview的Modal组件，简单的记录一下思想。由于时间原因，代码并没有深入往里边看，只是把大致的框框看了一下。首先，我们看看Modal组件的用法，官方文档点这里简单的用法如下：1234567&lt;Modal v-model=\"modal12\" draggable scrollable title=\"Modal 1\"&gt; &lt;div&gt;This is the first modal&lt;/div&gt;&lt;/Modal&gt;// 上边这个是基础写法// 下边这个写法可以直接调用，不需要在html中写出&lt;Modal&gt;&lt;/Modal&gt;标签this.$Modal.info(config)this.$Modal.success(config) 先看一下iview的Modal组件文件夹结构index文件是入口文件，里边导出了Modal对象。也就是可以使用标签的原因，因为给Modal对象加一大堆方法，但是它还是一个vue的基础组件。大家可能注意到了，当使用标签定义组建的时候，发现最后组件的dom元素被插入到了body下，而不是在具体引入的位置，这是因为Modal组件里有一个指令：12345// Modal组件里有directives: &#123; TransferDom &#125;// 追溯TransferDom指令，发现有如下代码parentNode.replaceChild(home, el); // moving out, el is no longer in the documentgetTarget(value).appendChild(el); // moving into new place modal.vue文件是组件的基础文件，也就是页面显示出来的东西，index文件里的东西可以看出来，只是给Modal对象添加了一些静态方法，为了this.$Modal.info(config)这样调用的时候使用。confrim文件里主要做了this.$Modal.info()这样调用的时候动态new Vue()实例，也是以modal.vue这个组件为基础，动态的插入到body节点里，代码见下边:就是通过new Vue()的实例获取到这个组建的html代码片段，再插入到body节点中。最后，再看看iview如何变成vue的全局组件的。123456789101112131415const install = function(Vue, opts = &#123;&#125;) &#123; ... // 这里添加全局组件 Object.keys(iview).forEach(key =&gt; &#123; Vue.component(key, iview[key]); &#125;); ... // 这里添加实例方法 Vue.prototype.$Modal = Modal; &#125;; 以上就是大概思路哈。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"小巧的html模板引擎","slug":"小巧的html模板引擎","date":"2018-11-30T06:57:20.000Z","updated":"2018-11-30T07:16:38.370Z","comments":true,"path":"2018/11/30/小巧的html模板引擎/","link":"","permalink":"/2018/11/30/小巧的html模板引擎/","excerpt":"小巧的html模板引擎","text":"小巧的html模板引擎 小巧的html模板引擎今天看coco大神的github，看到了他写的html模板引擎，默默地记录下来，其实，模板引擎我自己也写过一个，不过总觉得大神写的一定比我的好，点击这是我写的先贴出代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * coTemplate * */(function(name, definition) &#123; if (typeof define === 'function') &#123; define(definition); &#125; else &#123; this[name] = definition(); &#125;&#125;)('cotemplate', function() &#123; var tplReg = /\\$\\&#123;\\s*([^\\&#123;\\&#125;\\s]+)\\s*\\&#125;/g; var jsReg = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g; var code = 'var r=[];\\n'; var match = 'undefined'; var pointer = 0; /** * 添加单行逻辑 * @param &#123;*&#125; line */ function lineAdd(line) &#123; code += 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n'; &#125; /** * 模板拼接 * @param &#123;String&#125; tpl 模板字符串 * @param &#123;Objcet&#125; data 模板内替换对象 */ function cotemplate(tpl, data) &#123; while (match = tplReg.exec(tpl)) &#123; // 添加非逻辑部分 lineAdd(tpl.slice(pointer, match.index)); // 添加逻辑部分 \"$&#123;\" + match[1] + \"&#125;\"; code += ('r.push(String(this.' + match[1] + '));'); pointer = match.index + match[0].length; &#125; // 添加代码的最后一截 lineAdd(tpl.substr(pointer, tpl.length - pointer)); // 返回结果，在这里我们就拿到了装入数组后的代码 code += 'return r.join(\"\");'; console.log(code); return new Function(code.replace(/[\\r\\t\\n]/g, '')).apply(data); &#125; /** * export */ return cotemplate;&#125;); 用法Demo1234567891011121314151617181920212223242526&lt;script src=\"../js/cotemplate.js\"&gt;&lt;/script&gt;&lt;script&gt;var data = &#123; name: 'Coco', info: &#123; age: 18 &#125;, bar: &#123; foo: &#123; else: 'co-template' &#125; &#125;&#125;var tpl = ` &lt;p&gt;name:$&#123;coco&#125;&lt;/p&gt; &lt;p&gt;Age:$&#123;info.age&#125;&lt;/p&gt; &lt;div&gt;$&#123;bar.foo.else&#125;&lt;/div&gt; `;cotemplate(tpl, data);// &lt;p&gt;Name:Coco&lt;/p&gt; // &lt;p&gt;Age:18&lt;/p&gt; // &lt;div&gt;HTML-template:co-template&lt;/div&gt; &lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"js工具库","slug":"js工具库","permalink":"/tags/js工具库/"}]},{"title":"传入标准时间，返回指定日期格式","slug":"传入标准时间，返回指定日期格式","date":"2018-11-30T06:30:31.000Z","updated":"2018-11-30T06:42:56.079Z","comments":true,"path":"2018/11/30/传入标准时间，返回指定日期格式/","link":"","permalink":"/2018/11/30/传入标准时间，返回指定日期格式/","excerpt":"传入标准时间，返回指定日期格式","text":"传入标准时间，返回指定日期格式 传入标准时间，返回指定日期格式平时在开发时经常会用到获取当前日期，有时候会自己写一个，今天网上闲逛，发现一个写的不错的，记录一下，以备后用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let common = &#123; /** * 传入标准时间，返回指定日期格式 * @param &#123;Number&#125; date * @param &#123;String&#125; format * @example * - dateSerialization(1511181312647, \"y-mm-dd h:i:s\") * - @return 2017-11-20 20:35:12 */ dateSerialization(date, format) &#123; let dateObj; let DEFAULT_FORMAT = \"y-mm-dd h:i:s\"; let _patternArr = [\"y\", \"mm\", \"dd\", \"h\", \"i\", \"s\"]; let _patternMap = &#123; y: function(d) &#123; return d.getFullYear(); &#125;, m: function(d) &#123; return d.getMonth() + 1; &#125;, mm: function(d) &#123; return _pad(d.getMonth() + 1); &#125;, d: function(d) &#123; return d.getDate(); &#125;, dd: function(d) &#123; return _pad(d.getDate()); &#125;, h: function(d) &#123; return _pad(d.getHours()); &#125;, i: function(d) &#123; return _pad(d.getMinutes()); &#125;, s: function(d) &#123; return _pad(d.getSeconds()); &#125; &#125;; if (/^\\d+$/.test(date)) &#123; dateObj = new Date(parseInt(date)); &#125; else if (typeof date == \"string\") &#123; dateObj = new Date(date.replace(/-/g, \"/\")); &#125; else if (_isDate(date)) &#123; dateObj = date; &#125; // 非法数据 if (!dateObj || dateObj.toString() == \"Invalid Date\") &#123; throw new Error(\"[common.date.format]the input cannot be converted to date object(\" + date + \")\"); return; &#125; format = format || DEFAULT_FORMAT; let _resultArr = format.split(/-|:|\\s/); let resultObj = &#123;&#125;; let result = \"\"; _patternArr.forEach(k =&gt; &#123; resultObj[k] = _patternMap[k](dateObj); &#125;); _resultArr.forEach(k =&gt; &#123; let regExp = new RegExp(k); format = format.replace(regExp, function(e) &#123; return resultObj[e]; &#125;); &#125;); return format; &#125;&#125;;function _toString(v) &#123; return Object.prototype.toString.call(v);&#125;function _isDate(v) &#123; return _toString(v) == \"[object Date]\";&#125;function _pad(n) &#123; return n &gt; 9 ? n : \"0\" + n;&#125;export default common;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"js工具库","slug":"js工具库","permalink":"/tags/js工具库/"}]},{"title":"高阶函数和高阶组件","slug":"高阶函数和高阶组件","date":"2018-11-29T06:41:59.000Z","updated":"2018-11-29T06:58:20.220Z","comments":true,"path":"2018/11/29/高阶函数和高阶组件/","link":"","permalink":"/2018/11/29/高阶函数和高阶组件/","excerpt":"高阶函数和高阶组件简介","text":"高阶函数和高阶组件简介 高阶函数和高阶组件什么是高阶函数高阶函数就是传入的参数有函数的函数。（有点绕口:)） 什么是高阶组件高阶组件就是传入的参数有组件的组件。:)react比较容易实现高阶组件","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"web安全之CSRF","slug":"web安全之CSRF","date":"2018-11-28T03:10:48.000Z","updated":"2018-11-29T06:33:21.211Z","comments":true,"path":"2018/11/28/web安全之CSRF/","link":"","permalink":"/2018/11/28/web安全之CSRF/","excerpt":"CSRF攻击的简要介绍","text":"CSRF攻击的简要介绍 web安全之CSRF一.CSRF是什么？CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 二.CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 三.CSRF漏洞现状CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别 爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而 现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 四.CSRF的原理下图简单阐述了CSRF攻击的思想：从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：1.登录受信任网站A，并在本地生成Cookie。2.在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 五例子上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1：银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000危险网站B，它里面有一段HTML的代码如下：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中 的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏 览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com /Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账 操作），所以就立刻进行转账操作…… 示例2：为了杜绝上面的问题，银行决定改用POST请求完成转账操作。银行网站A的WEB表单如下：危险网站B，它里面有一段HTML的代码如下：12345&lt;form action=\"Transfer.php\" method=\"POST\"&gt; &lt;p&gt;ToBankId: &lt;input type=\"text\" name=\"toBankId\" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=\"text\" name=\"money\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"Transfer\" /&gt;&lt;/p&gt; &lt;/form&gt; 后台处理页面Transfer.php如下：1234567&lt;?php session_start(); if (isset($_REQUEST['toBankId'] &amp;&amp; isset($_REQUEST['money'])) &#123; buy_stocks($_REQUEST['toBankId'], $_REQUEST['money']); &#125; ?&gt; 危险网站B，仍然只是包含那句HTML代码：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的 原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成 了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST 请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3：经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：1234567&lt;?php session_start(); if (isset($_POST['toBankId'] &amp;&amp; isset($_POST['money'])) &#123; buy_stocks($_POST['toBankId'], $_POST['money']); &#125; ?&gt; 然而，危险网站B与时俱进，它改了一下代码：1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function steal() &#123; iframe = document.frames[\"steal\"]; iframe.document.Submit(\"transfer\"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"steal()\"&gt; &lt;iframe name=\"steal\" display=\"none\"&gt; &lt;form method=\"POST\" name=\"transfer\" action=\"http://www.myBank.com/Transfer.php\"&gt; &lt;input type=\"hidden\" name=\"toBankId\" value=\"11\"&gt; &lt;input type=\"hidden\" name=\"money\" value=\"1000\"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一 个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了 CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 六.CSRF的防御我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 1.服务端进行CSRF防御服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值)：这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;12345&lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。123456789&lt;?php $hash = md5($_COOKIE['cookie']); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证123456789101112&lt;?php if(isset($_POST['check'])) &#123; $hash = md5($_COOKIE['cookie']); if($_POST['check'] == $hash) &#123; doJob(); &#125; else &#123; //... &#125; &#125; else &#123; //... &#125;?&gt; 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就 另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 (2).验证码这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值)在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提 交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单 都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。以下我的实现: 1).先是令牌生成函数(gen_token())：1234567&lt;?php function gen_token() &#123; //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token =md5(uniqid(rand(), true)); return $token; &#125; 2).然后是Session令牌生成函数(gen_stoken())：123456789101112 &lt;?php function gen_stoken() &#123; $pToken = \"\"; if($_SESSION[STOKEN_NAME] == $pToken)&#123; //没有值，赋新值 $_SESSION[STOKEN_NAME] =gen_token(); &#125; else&#123; //继续使用旧的值 &#125; &#125;?&gt; 3).WEB表单生成隐藏输入域的函数：1234567&lt;?php function gen_input() &#123; gen_stoken(); echo “&lt;input type=\\”hidden\\” name=\\”\" . FTOKEN_NAME . “\\” value=\\”\" . $_SESSION[STOKEN_NAME] . “\\”&gt; “; &#125;?&gt; 4).WEB表单结构：12345678910&lt;?php session_start(); include(”functions.php”);?&gt;&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt;&lt;/FORM&gt; 5).服务端核对令牌：这个很简单，这里就不再啰嗦了。上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"web安全之XSS","slug":"web安全之XSS","date":"2018-11-28T01:40:42.000Z","updated":"2018-11-28T03:05:14.090Z","comments":true,"path":"2018/11/28/web安全之XSS/","link":"","permalink":"/2018/11/28/web安全之XSS/","excerpt":"XSS攻击的简要介绍","text":"XSS攻击的简要介绍 web安全之XSS首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型 XSS非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。一个例子，比如你的 Web 页面中包含有以下代码：12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL1(类似：https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码非持久型 XSS 漏洞攻击有以下几点特征 :1 . 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据2 . 攻击者需要诱骗点击3 . 反馈率低，所以较难发现和响应修复4 . 盗取用户敏感保密信息 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情 :1 . Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。2 . 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。3 . 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。4 . 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。5 . 前端渲染的时候对任何的字段都需要做 escape 转义编码。 escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 &lt;，&gt;，空格 等，转义成 &lt;，&gt;， 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。 持久型 XSS持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件 :1 . POST 请求提交表单后端没做转义直接入库。2 . 后端从数据库中取出数据没做转义直接输出给前端。3 . 前端拿到后端数据没做转义直接渲染成 DOM。 持久型 XSS 有以下几个特点 :1 . 持久性，植入在数据库中2 . 危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。3 . 盗取用户敏感私密信息 为了防止持久型 XSS 漏洞，需要前后端共同努力 :1 . 后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。2 . 后端在输出给前端数据统一进行转义处理。3 . 前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。 基于字符集的 XSS其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。 以基于 utf-7 的 XSS 为例utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。123&lt;script&gt;alert(\"xss\")&lt;/script&gt;可以被解释为：+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4- 可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。 所以我们有什么办法避免这种 XSS 呢 ?1 . 记住指定 2 . XML 中不仅要指定字符集为 utf-8，而且标签要闭合3 . 牛文推荐：http://drops.wooyun.org/papers/1327 （这个讲的很详细） 基于 Flash 的跨站 XSS基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。 避免方法 :1 . 严格管理 cookie 的读写权限2 . 对 Flash 能接受用户输入的参数进行过滤 escape 转义处理 未经验证的跳转 XSS有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。 这时候需要通过以下方式来防止这类漏洞 :1 . 对待跳转的 URL 参数做白名单或者某种规则过滤2 . 后端注意对敏感信息的保护, 比如 cookie 使用来源验证。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"利用正则表达式统计代码行数","slug":"利用正则表达式统计代码行数","date":"2018-11-27T05:59:20.000Z","updated":"2018-11-27T06:30:45.581Z","comments":true,"path":"2018/11/27/利用正则表达式统计代码行数/","link":"","permalink":"/2018/11/27/利用正则表达式统计代码行数/","excerpt":"利用ide编辑器统计代码行数","text":"利用ide编辑器统计代码行数 利用正则表达式统计代码行数在项目中，我们常常有统计代码行数的需要，但是如果不利用第三方工具的话，面对一个项目（甚至一个工程或解决方案中若干个项目）中成百上千的代码文件，实在有一种力不从心的感觉。 但利用正则表达式可以巧妙解决。用的工具不是别的，正是所有的IDE（Visual Studio、Eclipse等等）和常用的文本编辑器（SublimeText2、Notepad++等）日常必备软件的“在文件中查找”，不同的软件略有不同，但大同小异。 再复杂的IDE，其搜索功能也是基于字符串的匹配进行的。我们知道，文本中每次换行会增加一个 \\n 。如果直接用正则\\n每一个匹配项就代表一次换行。但需要注意的是文件的最后一行是没有换行符的，所以文本行数=文件数+换行符数目，因而把两个看到的两个数字加起来才是文本行数。 1^.*$ 表示搜索条件为行首与行尾之间包含任意个任意字符（非换行符）。 上面的方法可以很迅速地得到代码行数，不过遗憾的是统计结果把空行（仅包含空格和制表符的行）也统计进去了，然而很多时候我们并不想把这些文本也给算进代码量里去，怎么办呢？别急，我们只要对正则表达式做一点点修改。我的思路是，只需要找出一个不是空格或制表符的字符即可，于是可写出了这个正则表达式1^\\s*[^\\s]+.*$ 它表示先忽略一行前面的连续空格和制表符等，然后寻找是否有一个字符不为空格、制表符、换行符和回车符，如果有则表明这行不为空行。不用1^\\s*\\S+.*$ 是为了下面方便添加其他要排除的注释行或者独立的括号行。 在实际项目中，我们或许认为注释行不应成为生产量，应从统计数据中排除出去。我们首先要能够对注释行有一个认识。很多程序设计语言中，注释行都会用“/”或者“#”等字符开头。我们假设项目中的注释行都是以“/”或“#”开头的（请读者考虑自己项目的特点自行修改）。下面的正则表示，我们要查找的是一行中第一个非空字符不是“/”或“#”或“{”或“}”的行12^\\s*[^\\s/#&#123;&#125;]+.*$ ^\\s*[^ \\t\\n\\r/#&#123;&#125;]+.*$ 作用同上，说明在中括号[]内自定义原子表，打个空格，也可以代表空格。因为控制开头和结尾，所以 + 后不必加问号 ? 取消贪婪模式了。 1^\\s*[^\\s/#&#123;&#125;]+ 也行，但是上面加上控制结尾比较严谨。另外，文本编辑框默认是视为单行的，没有设置多行模式，如果设为多行模式就得注意了。php 中，在定界符最右边加 m 即可视为多行。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"zepto源码","slug":"zepto源码","date":"2018-11-16T08:30:56.000Z","updated":"2018-11-23T08:39:10.510Z","comments":true,"path":"2018/11/16/zepto源码/","link":"","permalink":"/2018/11/16/zepto源码/","excerpt":"zepto源码，有注释","text":"zepto源码，有注释 zepto源码最近在看zepto源码，所以把一些注释也加上了，还没看完，以后继续加。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */(function(global, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) define(function() &#123; return factory(global) &#125;) else factory(global)&#125;(this, function(window) &#123; var Zepto = (function() &#123; var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice, document = window.document, elementDisplay = &#123;&#125;, classCache = &#123;&#125;, cssNumber = &#123; 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 &#125;, fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, // &lt;...&gt;都匹配 singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, // 只匹配没有内容的标签，如: &lt;div&gt;&lt;/div&gt;或&lt;input /&gt; // 匹配&lt;div /&gt;, &lt;: /&gt;这样的，除了&lt;input /&gt;,&lt;img /&gt;这样的 tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig, rootNodeRE = /^(?:body|html)$/i, capitalRE = /([A-Z])/g, // special attributes that should be get/set via method calls methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'], adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ], table = document.createElement('table'), tableRow = document.createElement('tr'), containers = &#123; 'tr': document.createElement('tbody'), 'tbody': table, 'thead': table, 'tfoot': table, 'td': tableRow, 'th': tableRow, '*': document.createElement('div') &#125;, readyRE = /complete|loaded|interactive/, simpleSelectorRE = /^[\\w-]*$/, class2type = &#123;&#125;, toString = class2type.toString, zepto = &#123;&#125;, camelize, uniq, tempParent = document.createElement('div'), propMap = &#123; 'tabindex': 'tabIndex', 'readonly': 'readOnly', 'for': 'htmlFor', 'class': 'className', 'maxlength': 'maxLength', 'cellspacing': 'cellSpacing', 'cellpadding': 'cellPadding', 'rowspan': 'rowSpan', 'colspan': 'colSpan', 'usemap': 'useMap', 'frameborder': 'frameBorder', 'contenteditable': 'contentEditable' &#125;, // 判断是否为数组 isArray = Array.isArray || function(object)&#123; return object instanceof Array &#125; // 判断节点是否包含选择器 zepto.matches = function(element, selector) &#123; if (!selector || !element || element.nodeType !== 1) return false var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector if (matchesSelector) return matchesSelector.call(element, selector) // fall back to performing a selector: var match, parent = element.parentNode, temp = !parent if (temp) (parent = tempParent).appendChild(element) // ~这个符号可以将-1转化为0，直接判断就是false了 match = ~zepto.qsa(parent, selector).indexOf(element) temp &amp;&amp; tempParent.removeChild(element) return match &#125; // 查看数据类型 function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\" &#125; // 判断是否为函数 function isFunction(value) &#123; return type(value) == \"function\" &#125; // 判断是否为window对象 function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125; // 判断是否为document对象 function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125; // 判断是否为object对象 function isObject(obj) &#123; return type(obj) == \"object\" &#125; // 判断是不是纯对象，如 &#123;&#125;,prototype没有添加的 function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype &#125; // 判断是不是类数组对象 function likeArray(obj) &#123; var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length, type = $.type(obj) return 'function' != type &amp;&amp; !isWindow(obj) &amp;&amp; ( 'array' == type || length === 0 || (typeof length == 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) ) &#125; // 压缩精简数组，去掉null，undefined function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array &#125; // 将font-size形式转换为fontSize驼峰形式 camelize = function(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : '' &#125;) &#125; // 将驼峰命名转为-形式,正则的$1,$2...代表前边小括号里的内容 function dasherize(str) &#123; return str.replace(/::/g, '/') .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2') .replace(/([a-z\\d])([A-Z])/g, '$1_$2') .replace(/_/g, '-') .toLowerCase() &#125; // 删除数组中重复的元素，这个方法好牛逼 uniq = function(array)&#123; return filter.call(array, function(item, idx)&#123; return array.indexOf(item) == idx &#125;) &#125; // 如果classCache中没有name的话，则新建一个这个name的正则 function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)')) &#125; // 应该是给css赋值的时候，如果没在cssNumber这个表中的话就加上'px'后缀 function maybeAddPx(name, value) &#123; return (typeof value == \"number\" &amp;&amp; !cssNumber[dasherize(name)]) ? value + \"px\" : value &#125; // 应该是查看如div,table这样的元素的默认display的值 function defaultDisplay(nodeName) &#123; var element, display if (!elementDisplay[nodeName]) &#123; element = document.createElement(nodeName) document.body.appendChild(element) display = getComputedStyle(element, '').getPropertyValue(\"display\") element.parentNode.removeChild(element) display == \"none\" &amp;&amp; (display = \"block\") elementDisplay[nodeName] = display &#125; return elementDisplay[nodeName] &#125; // 获取节点的子元素 function children(element) &#123; return 'children' in element ? slice.call(element.children) : $.map(element.childNodes, function(node)&#123; if (node.nodeType == 1) return node &#125;) &#125; // function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' &#125; // `$.zepto.fragment` takes a html string and an optional tag name // to generate DOM nodes from the given html string. // The generated DOM nodes are returned as an array. // This function can be overridden in plugins for example to make // it compatible with browsers that don't support the DOM fully. zepto.fragment = function(html, name, properties) &#123; var dom, nodes, container // A special case optimization for a single tag if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)) if (!dom) &#123; if (html.replace) html = html.replace(tagExpanderRE, \"&lt;$1&gt;&lt;/$2&gt;\") // 将&lt;div/&gt;转化成&lt;div&gt;&lt;/div&gt; if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1 if (!(name in containers)) name = '*' // 下面的做法就是将'&lt;span&gt;12345&lt;/span&gt;'这样的字符串转为dom节点的形式 container = containers[name] container.innerHTML = '' + html dom = $.each(slice.call(container.childNodes), function()&#123; container.removeChild(this) &#125;) &#125; if (isPlainObject(properties)) &#123; nodes = $(dom) $.each(properties, function(key, value) &#123; if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value) else nodes.attr(key, value) &#125;) &#125; return dom &#125; window.haha = zepto; // `$.zepto.Z` swaps out the prototype of the given `dom` array // of nodes with `$.fn` and thus supplying all the Zepto functions // to the array. This method can be overridden in plugins. zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; // `$.zepto.isZ` should return `true` if the given object is a Zepto // collection. This method can be overridden in plugins. zepto.isZ = function(object) &#123; return object instanceof zepto.Z &#125; // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and // takes a CSS selector and an optional context (and handles various // special cases). // This method can be overridden in plugins. zepto.init = function(selector, context) &#123; var dom // If nothing given, return an empty Zepto collection if (!selector) return zepto.Z() // Optimize for string selectors else if (typeof selector == 'string') &#123; selector = selector.trim() // If it's a html fragment, create nodes from it // Note: In both Chrome 21 and Firefox 15, DOM error 12 // is thrown if the fragment doesn't begin with &lt; if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // If it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // If a function is given, call it when the DOM is ready else if (isFunction(selector)) return $(document).ready(selector) // If a Zepto collection is given, just return it else if (zepto.isZ(selector)) return selector else &#123; // normalize array if an array of nodes is given if (isArray(selector)) dom = compact(selector) // Wrap DOM nodes. else if (isObject(selector)) dom = [selector], selector = null // If it's a html fragment, create nodes from it else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // create a new Zepto collection from the nodes found return zepto.Z(dom, selector) &#125; // `$` will be the base `Zepto` object. When calling this // function just call `$.zepto.init, which makes the implementation // details of selecting nodes and creating Zepto collections // patchable in plugins. $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 深度拷贝的函数 function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key] &#125; // Copy all but undefined properties from one or more // objects to the `target` object. $.extend = function(target)&#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target &#125; // `$.zepto.qsa` is Zepto's CSS selector implementation which // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`. // This method can be overridden in plugins. zepto.qsa = function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = simpleSelectorRE.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all ) &#125; function filtered(nodes, selector) &#123; return selector == null ? $(nodes) : $(nodes).filter(selector) &#125; // 判断父节点中是否包含子节点，parent为父节点，node为子节点 $.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg &#125; // 设置node节点的属性值 function setAttribute(node, name, value) &#123; value == null ? node.removeAttribute(name) : node.setAttribute(name, value) &#125; // access className property while respecting SVGAnimatedString function className(node, value)&#123; var klass = node.className || '', svg = klass &amp;&amp; klass.baseVal !== undefined if (value === undefined) return svg ? klass.baseVal : klass svg ? (klass.baseVal = value) : (node.className = value) &#125; // \"true\" =&gt; true // \"false\" =&gt; false // \"null\" =&gt; null // \"42\" =&gt; 42 // \"42.5\" =&gt; 42.5 // \"08\" =&gt; \"08\" // JSON =&gt; parse if valid // String =&gt; self // 反序列化 function deserializeValue(value) &#123; try &#123; return value ? value == \"true\" || ( value == \"false\" ? false : value == \"null\" ? null : +value + \"\" == value ? +value : /^[\\[\\&#123;]/.test(value) ? $.parseJSON(value) : value ) : value &#125; catch(e) &#123; return value &#125; &#125; $.type = type $.isFunction = isFunction $.isWindow = isWindow $.isArray = isArray $.isPlainObject = isPlainObject // 判断是否为空对象函数 $.isEmptyObject = function(obj) &#123; var name for (name in obj) return false return true &#125; // 判断是否是数字形式的 123或'123' $.isNumeric = function(val) &#123; var num = Number(val), type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; // 判断元素是否在数组中，array数组，elem元素，i是从数组中的第几位开始查找 $.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i) &#125; $.camelCase = camelize $.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str) &#125; // plugin compatibility $.uuid = 0 $.support = &#123; &#125; $.expr = &#123; &#125; $.noop = function() &#123;&#125; // map函数，对elements进行处理后返回新数组 $.map = function(elements, callback)&#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; // 遍历elements，执行callback函数，如果执行时返回false，则停止遍历操作 $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; // 过滤数组 $.grep = function(elements, callback)&#123; return filter.call(elements, callback) &#125; if (window.JSON) $.parseJSON = JSON.parse // Populate the class2type map $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase() &#125;) // Define methods that will be available on all // Zepto collections $.fn = &#123; constructor: zepto.Z, length: 0, // Because a collection acts like an array // copy over these useful array functions. forEach: emptyArray.forEach, reduce: emptyArray.reduce, push: emptyArray.push, sort: emptyArray.sort, splice: emptyArray.splice, indexOf: emptyArray.indexOf, concat: function()&#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) &#125;, // `map` and `slice` in the jQuery API work differently // from their array counterparts map: function(fn)&#123; return $($.map(this, function(el, i)&#123; return fn.call(el, i, el) &#125;)) &#125;, slice: function()&#123; return $(slice.apply(this, arguments)) &#125;, ready: function(callback)&#123; // need to check if document.body exists for IE as that browser reports // document ready when it hasn't yet created the body element if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($) else document.addEventListener('DOMContentLoaded', function()&#123; callback($) &#125;, false) return this &#125;, get: function(idx)&#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length] &#125;, toArray: function()&#123; return this.get() &#125;, size: function()&#123; return this.length &#125;, remove: function()&#123; return this.each(function()&#123; if (this.parentNode != null) this.parentNode.removeChild(this) &#125;) &#125;, each: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this &#125;, filter: function(selector)&#123; if (isFunction(selector)) return this.not(this.not(selector)) return $(filter.call(this, function(element)&#123; return zepto.matches(element, selector) &#125;)) &#125;, add: function(selector,context)&#123; return $(uniq(this.concat($(selector,context)))) &#125;, is: function(selector)&#123; return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector) &#125;, not: function(selector)&#123; var nodes=[] if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function(idx)&#123; if (!selector.call(this,idx)) nodes.push(this) &#125;) else &#123; var excludes = typeof selector == 'string' ? this.filter(selector) : (likeArray(selector) &amp;&amp; isFunction(selector.item)) ? slice.call(selector) : $(selector) this.forEach(function(el)&#123; if (excludes.indexOf(el) &lt; 0) nodes.push(el) &#125;) &#125; return $(nodes) &#125;, has: function(selector)&#123; return this.filter(function()&#123; return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size() &#125;) &#125;, eq: function(idx)&#123; return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1) &#125;, first: function()&#123; var el = this[0] return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, last: function()&#123; var el = this[this.length - 1] return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, find: function(selector)&#123; var result, $this = this if (!selector) result = $() else if (typeof selector == 'object') result = $(selector).filter(function()&#123; var node = this return emptyArray.some.call($this, function(parent)&#123; return $.contains(parent, node) &#125;) &#125;) else if (this.length == 1) result = $(zepto.qsa(this[0], selector)) else result = this.map(function()&#123; return zepto.qsa(this, selector) &#125;) return result &#125;, closest: function(selector, context)&#123; var nodes = [], collection = typeof selector == 'object' &amp;&amp; $(selector) this.each(function(_, node)&#123; while (node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector))) node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode if (node &amp;&amp; nodes.indexOf(node) &lt; 0) nodes.push(node) &#125;) return $(nodes) &#125;, parents: function(selector)&#123; var ancestors = [], nodes = this while (nodes.length &gt; 0) nodes = $.map(nodes, function(node)&#123; if ((node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0) &#123; ancestors.push(node) return node &#125; &#125;) return filtered(ancestors, selector) &#125;, parent: function(selector)&#123; return filtered(uniq(this.pluck('parentNode')), selector) &#125;, children: function(selector)&#123; return filtered(this.map(function()&#123; return children(this) &#125;), selector) &#125;, contents: function() &#123; return this.map(function() &#123; return this.contentDocument || slice.call(this.childNodes) &#125;) &#125;, siblings: function(selector)&#123; return filtered(this.map(function(i, el)&#123; return filter.call(children(el.parentNode), function(child)&#123; return child!==el &#125;) &#125;), selector) &#125;, empty: function()&#123; return this.each(function()&#123; this.innerHTML = '' &#125;) &#125;, // `pluck` is borrowed from Prototype.js pluck: function(property)&#123; return $.map(this, function(el)&#123; return el[property] &#125;) &#125;, show: function()&#123; return this.each(function()&#123; this.style.display == \"none\" &amp;&amp; (this.style.display = '') if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\") this.style.display = defaultDisplay(this.nodeName) &#125;) &#125;, replaceWith: function(newContent)&#123; return this.before(newContent).remove() &#125;, wrap: function(structure)&#123; var func = isFunction(structure) if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length &gt; 1 return this.each(function(index)&#123; $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ) &#125;) &#125;, wrapAll: function(structure)&#123; if (this[0]) &#123; $(this[0]).before(structure = $(structure)) var children // drill down to the inmost element while ((children = structure.children()).length) structure = children.first() $(structure).append(this) &#125; return this &#125;, wrapInner: function(structure)&#123; var func = isFunction(structure) return this.each(function(index)&#123; var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure contents.length ? contents.wrapAll(dom) : self.append(dom) &#125;) &#125;, unwrap: function()&#123; this.parent().each(function()&#123; $(this).replaceWith($(this).children()) &#125;) return this &#125;, clone: function()&#123; return this.map(function()&#123; return this.cloneNode(true) &#125;) &#125;, hide: function()&#123; return this.css(\"display\", \"none\") &#125;, toggle: function(setting)&#123; return this.each(function()&#123; var el = $(this) ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide() &#125;) &#125;, prev: function(selector)&#123; return $(this.pluck('previousElementSibling')).filter(selector || '*') &#125;, next: function(selector)&#123; return $(this.pluck('nextElementSibling')).filter(selector || '*') &#125;, html: function(html)&#123; return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : (0 in this ? this[0].innerHTML : null) &#125;, text: function(text)&#123; return 0 in arguments ? this.each(function(idx)&#123; var newText = funcArg(this, text, idx, this.textContent) this.textContent = newText == null ? '' : ''+newText &#125;) : (0 in this ? this.pluck('textContent').join(\"\") : null) &#125;, attr: function(name, value)&#123; var result return (typeof name == 'string' &amp;&amp; !(1 in arguments)) ? (0 in this &amp;&amp; this[0].nodeType == 1 &amp;&amp; (result = this[0].getAttribute(name)) != null ? result : undefined) : this.each(function(idx)&#123; if (this.nodeType !== 1) return if (isObject(name)) for (key in name) setAttribute(this, key, name[key]) else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))) &#125;) &#125;, removeAttr: function(name)&#123; return this.each(function()&#123; this.nodeType === 1 &amp;&amp; name.split(' ').forEach(function(attribute)&#123; setAttribute(this, attribute) &#125;, this)&#125;) &#125;, prop: function(name, value)&#123; name = propMap[name] || name return (1 in arguments) ? this.each(function(idx)&#123; this[name] = funcArg(this, value, idx, this[name]) &#125;) : (this[0] &amp;&amp; this[0][name]) &#125;, removeProp: function(name)&#123; name = propMap[name] || name return this.each(function()&#123; delete this[name] &#125;) &#125;, data: function(name, value)&#123; var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase() var data = (1 in arguments) ? this.attr(attrName, value) : this.attr(attrName) return data !== null ? deserializeValue(data) : undefined &#125;, val: function(value)&#123; if (0 in arguments) &#123; if (value == null) value = \"\" return this.each(function(idx)&#123; this.value = funcArg(this, value, idx, this.value) &#125;) &#125; else &#123; return this[0] &amp;&amp; (this[0].multiple ? $(this[0]).find('option').filter(function()&#123; return this.selected &#125;).pluck('value') : this[0].value) &#125; &#125;, offset: function(coordinates)&#123; if (coordinates) return this.each(function(index)&#123; var $this = $(this), coords = funcArg(this, coordinates, index, $this.offset()), parentOffset = $this.offsetParent().offset(), props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125; if ($this.css('position') == 'static') props['position'] = 'relative' $this.css(props) &#125;) if (!this.length) return null if (document.documentElement !== this[0] &amp;&amp; !$.contains(document.documentElement, this[0])) return &#123;top: 0, left: 0&#125; var obj = this[0].getBoundingClientRect() return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125; &#125;, css: function(property, value)&#123; if (arguments.length &lt; 2) &#123; var element = this[0] if (typeof property == 'string') &#123; if (!element) return return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property) &#125; else if (isArray(property)) &#123; if (!element) return var props = &#123;&#125; var computedStyle = getComputedStyle(element, '') $.each(property, function(_, prop)&#123; props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop)) &#125;) return props &#125; &#125; var css = '' if (type(property) == 'string') &#123; if (!value &amp;&amp; value !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(property)) &#125;) else css = dasherize(property) + \":\" + maybeAddPx(property, value) &#125; else &#123; for (key in property) if (!property[key] &amp;&amp; property[key] !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(key)) &#125;) else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';' &#125; return this.each(function()&#123; this.style.cssText += ';' + css &#125;) &#125;, index: function(element)&#123; return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]) &#125;, hasClass: function(name)&#123; if (!name) return false return emptyArray.some.call(this, function(el)&#123; return this.test(className(el)) &#125;, classRE(name)) &#125;, addClass: function(name)&#123; if (!name) return this return this.each(function(idx)&#123; if (!('className' in this)) return classList = [] var cls = className(this), newName = funcArg(this, name, idx, cls) newName.split(/\\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \")) &#125;) &#125;, removeClass: function(name)&#123; return this.each(function(idx)&#123; if (!('className' in this)) return if (name === undefined) return className(this, '') classList = className(this) funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass)&#123; classList = classList.replace(classRE(klass), \" \") &#125;) className(this, classList.trim()) &#125;) &#125;, toggleClass: function(name, when)&#123; if (!name) return this return this.each(function(idx)&#123; var $this = $(this), names = funcArg(this, name, idx, className(this)) names.split(/\\s+/g).forEach(function(klass)&#123; (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass) &#125;) &#125;) &#125;, scrollTop: function(value)&#123; if (!this.length) return var hasScrollTop = 'scrollTop' in this[0] if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset return this.each(hasScrollTop ? function()&#123; this.scrollTop = value &#125; : function()&#123; this.scrollTo(this.scrollX, value) &#125;) &#125;, scrollLeft: function(value)&#123; if (!this.length) return var hasScrollLeft = 'scrollLeft' in this[0] if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset return this.each(hasScrollLeft ? function()&#123; this.scrollLeft = value &#125; : function()&#123; this.scrollTo(value, this.scrollY) &#125;) &#125;, position: function() &#123; if (!this.length) return var elem = this[0], // Get *real* offsetParent offsetParent = this.offsetParent(), // Get correct offsets offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123; top: 0, left: 0 &#125; : offsetParent.offset() // Subtract element margins // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat( $(elem).css('margin-top') ) || 0 offset.left -= parseFloat( $(elem).css('margin-left') ) || 0 // Add offsetParent borders parentOffset.top += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0 parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0 // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125; &#125;, offsetParent: function() &#123; return this.map(function()&#123; var parent = this.offsetParent || document.body while (parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css(\"position\") == \"static\") parent = parent.offsetParent return parent &#125;) &#125; &#125; // for now $.fn.detach = $.fn.remove // Generate the `width` and `height` functions ;['width', 'height'].forEach(function(dimension)&#123; var dimensionProperty = dimension.replace(/./, function(m)&#123; return m[0].toUpperCase() &#125;) $.fn[dimension] = function(value)&#123; var offset, el = this[0] if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) &amp;&amp; offset[dimension] else return this.each(function(idx)&#123; el = $(this) el.css(dimension, funcArg(this, value, idx, el[dimension]())) &#125;) &#125; &#125;) function traverseNode(node, fun) &#123; fun(node) for (var i = 0, len = node.childNodes.length; i &lt; len; i++) traverseNode(node.childNodes[i], fun) &#125; // Generate the `after`, `prepend`, `before`, `append`, // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods. adjacencyOperators.forEach(function(operator, operatorIndex) &#123; var inside = operatorIndex % 2 //=&gt; prepend, append $.fn[operator] = function()&#123; // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings var argType, nodes = $.map(arguments, function(arg) &#123; var arr = [] argType = type(arg) if (argType == \"array\") &#123; arg.forEach(function(el) &#123; if (el.nodeType !== undefined) return arr.push(el) else if ($.zepto.isZ(el)) return arr = arr.concat(el.get()) arr = arr.concat(zepto.fragment(el)) &#125;) return arr &#125; return argType == \"object\" || arg == null ? arg : zepto.fragment(arg) &#125;), parent, copyByClone = this.length &gt; 1 if (nodes.length &lt; 1) return this return this.each(function(_, target)&#123; parent = inside ? target : target.parentNode // convert all methods to a \"before\" operation target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null var parentInDocument = $.contains(document.documentElement, parent) nodes.forEach(function(node)&#123; if (copyByClone) node = node.cloneNode(true) else if (!parent) return $(node).remove() parent.insertBefore(node, target) if (parentInDocument) traverseNode(node, function(el)&#123; if (el.nodeName != null &amp;&amp; el.nodeName.toUpperCase() === 'SCRIPT' &amp;&amp; (!el.type || el.type === 'text/javascript') &amp;&amp; !el.src)&#123; var target = el.ownerDocument ? el.ownerDocument.defaultView : window target['eval'].call(target, el.innerHTML) &#125; &#125;) &#125;) &#125;) &#125; // after =&gt; insertAfter // prepend =&gt; prependTo // before =&gt; insertBefore // append =&gt; appendTo $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html)&#123; $(html)[operator](this) return this &#125; &#125;) zepto.Z.prototype = Z.prototype = $.fn // Export internal API functions in the `$.zepto` namespace zepto.uniq = uniq zepto.deserializeValue = deserializeValue $.zepto = zepto return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto)// zepto的事件代码;(function($)&#123; var _zid = 1, undefined, slice = Array.prototype.slice, isFunction = $.isFunction, isString = function(obj)&#123; return typeof obj == 'string' &#125;, handlers = &#123;&#125;, specialEvents=&#123;&#125;, focusinSupported = 'onfocusin' in window, focus = &#123; focus: 'focusin', blur: 'focusout' &#125;, hover = &#123; mouseenter: 'mouseover', mouseleave: 'mouseout' &#125; specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents' function zid(element) &#123; return element._zid || (element._zid = _zid++) &#125; function findHandlers(element, event, fn, selector) &#123; event = parse(event) if (event.ns) var matcher = matcherFor(event.ns) return (handlers[zid(element)] || []).filter(function(handler) &#123; return handler &amp;&amp; (!event.e || handler.e == event.e) &amp;&amp; (!event.ns || matcher.test(handler.ns)) &amp;&amp; (!fn || zid(handler.fn) === zid(fn)) &amp;&amp; (!selector || handler.sel == selector) &#125;) &#125; function parse(event) &#123; var parts = ('' + event).split('.') return &#123;e: parts[0], ns: parts.slice(1).sort().join(' ')&#125; &#125; function matcherFor(ns) &#123; return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)') &#125; function eventCapture(handler, captureSetting) &#123; return handler.del &amp;&amp; (!focusinSupported &amp;&amp; (handler.e in focus)) || !!captureSetting &#125; function realEvent(type) &#123; return hover[type] || (focusinSupported &amp;&amp; focus[type]) || type &#125; function add(element, events, fn, data, selector, delegator, capture)&#123; var id = zid(element), set = (handlers[id] || (handlers[id] = [])) events.split(/\\s/).forEach(function(event)&#123; if (event == 'ready') return $(document).ready(fn) var handler = parse(event) handler.fn = fn handler.sel = selector // emulate mouseenter, mouseleave if (handler.e in hover) fn = function(e)&#123; var related = e.relatedTarget if (!related || (related !== this &amp;&amp; !$.contains(this, related))) return handler.fn.apply(this, arguments) &#125; handler.del = delegator var callback = delegator || fn handler.proxy = function(e)&#123; e = compatible(e) if (e.isImmediatePropagationStopped()) return e.data = data var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args)) if (result === false) e.preventDefault(), e.stopPropagation() return result &#125; handler.i = set.length set.push(handler) if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125; function remove(element, events, fn, selector, capture)&#123; var id = zid(element) ;(events || '').split(/\\s/).forEach(function(event)&#123; findHandlers(element, event, fn, selector).forEach(function(handler)&#123; delete handlers[id][handler.i] if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125;) &#125; $.event = &#123; add: add, remove: remove &#125; $.proxy = function(fn, context) &#123; var args = (2 in arguments) &amp;&amp; slice.call(arguments, 2) if (isFunction(fn)) &#123; var proxyFn = function()&#123; return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) &#125; proxyFn._zid = zid(fn) return proxyFn &#125; else if (isString(context)) &#123; if (args) &#123; args.unshift(fn[context], fn) return $.proxy.apply(null, args) &#125; else &#123; return $.proxy(fn[context], fn) &#125; &#125; else &#123; throw new TypeError(\"expected function\") &#125; &#125; $.fn.bind = function(event, data, callback)&#123; return this.on(event, data, callback) &#125; $.fn.unbind = function(event, callback)&#123; return this.off(event, callback) &#125; $.fn.one = function(event, selector, data, callback)&#123; return this.on(event, selector, data, callback, 1) &#125; var returnTrue = function()&#123;return true&#125;, returnFalse = function()&#123;return false&#125;, ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/, eventMethods = &#123; preventDefault: 'isDefaultPrevented', stopImmediatePropagation: 'isImmediatePropagationStopped', stopPropagation: 'isPropagationStopped' &#125; function compatible(event, source) &#123; if (source || !event.isDefaultPrevented) &#123; source || (source = event) $.each(eventMethods, function(name, predicate) &#123; var sourceMethod = source[name] event[name] = function()&#123; this[predicate] = returnTrue return sourceMethod &amp;&amp; sourceMethod.apply(source, arguments) &#125; event[predicate] = returnFalse &#125;) event.timeStamp || (event.timeStamp = Date.now()) if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault &amp;&amp; source.getPreventDefault()) event.isDefaultPrevented = returnTrue &#125; return event &#125; function createProxy(event) &#123; var key, proxy = &#123; originalEvent: event &#125; for (key in event) if (!ignoreProperties.test(key) &amp;&amp; event[key] !== undefined) proxy[key] = event[key] return compatible(proxy, event) &#125; $.fn.delegate = function(selector, event, callback)&#123; return this.on(event, selector, callback) &#125; $.fn.undelegate = function(selector, event, callback)&#123; return this.off(event, selector, callback) &#125; $.fn.live = function(event, callback)&#123; $(document.body).delegate(this.selector, event, callback) return this &#125; $.fn.die = function(event, callback)&#123; $(document.body).undelegate(this.selector, event, callback) return this &#125; $.fn.on = function(event, selector, data, callback, one)&#123; var autoRemove, delegator, $this = this if (event &amp;&amp; !isString(event)) &#123; $.each(event, function(type, fn)&#123; $this.on(type, selector, data, fn, one) &#125;) return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = data, data = selector, selector = undefined if (callback === undefined || data === false) callback = data, data = undefined if (callback === false) callback = returnFalse return $this.each(function(_, element)&#123; if (one) autoRemove = function(e)&#123; remove(element, e.type, callback) return callback.apply(this, arguments) &#125; if (selector) delegator = function(e)&#123; var evt, match = $(e.target).closest(selector, element).get(0) if (match &amp;&amp; match !== element) &#123; evt = $.extend(createProxy(e), &#123;currentTarget: match, liveFired: element&#125;) return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1))) &#125; &#125; add(element, event, callback, data, selector, delegator || autoRemove) &#125;) &#125; $.fn.off = function(event, selector, callback)&#123; var $this = this if (event &amp;&amp; !isString(event)) &#123; $.each(event, function(type, fn)&#123; $this.off(type, selector, fn) &#125;) return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = selector, selector = undefined if (callback === false) callback = returnFalse return $this.each(function()&#123; remove(this, event, callback, selector) &#125;) &#125; $.fn.trigger = function(event, args)&#123; event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event) event._args = args return this.each(function()&#123; // handle focus(), blur() by calling them directly if (event.type in focus &amp;&amp; typeof this[event.type] == \"function\") this[event.type]() // items in the collection might not be DOM elements else if ('dispatchEvent' in this) this.dispatchEvent(event) else $(this).triggerHandler(event, args) &#125;) &#125; // triggers event handlers on current element just as if an event occurred, // doesn't trigger an actual event, doesn't bubble $.fn.triggerHandler = function(event, args)&#123; var e, result this.each(function(i, element)&#123; e = createProxy(isString(event) ? $.Event(event) : event) e._args = args e.target = element $.each(findHandlers(element, event.type || event), function(i, handler)&#123; result = handler.proxy(e) if (e.isImmediatePropagationStopped()) return false &#125;) &#125;) return result &#125; // shortcut methods for `.bind(event, fn)` for each event type ;('focusin focusout focus blur load resize scroll unload click dblclick '+ 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+ 'change select keydown keypress keyup error').split(' ').forEach(function(event) &#123; $.fn[event] = function(callback) &#123; return (0 in arguments) ? this.bind(event, callback) : this.trigger(event) &#125; &#125;) $.Event = function(type, props) &#123; if (!isString(type)) props = type, type = props.type var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name]) event.initEvent(type, bubbles, true) return compatible(event) &#125;&#125;)(Zepto)// zepto的AJAX代码;(function($)&#123; var jsonpID = +new Date(), document = window.document, key, name, rscript = /&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;/gi, scriptTypeRE = /^(?:text|application)\\/javascript/i, xmlTypeRE = /^(?:text|application)\\/xml/i, jsonType = 'application/json', htmlType = 'text/html', blankRE = /^\\s*$/, originAnchor = document.createElement('a') originAnchor.href = window.location.href // trigger a custom event and return false if it was cancelled function triggerAndReturn(context, eventName, data) &#123; var event = $.Event(eventName) $(context).trigger(event, data) return !event.isDefaultPrevented() &#125; // trigger an Ajax \"global\" event function triggerGlobal(settings, context, eventName, data) &#123; if (settings.global) return triggerAndReturn(context || document, eventName, data) &#125; // Number of active Ajax requests $.active = 0 function ajaxStart(settings) &#123; if (settings.global &amp;&amp; $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart') &#125; function ajaxStop(settings) &#123; if (settings.global &amp;&amp; !(--$.active)) triggerGlobal(settings, null, 'ajaxStop') &#125; // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable function ajaxBeforeSend(xhr, settings) &#123; var context = settings.context if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]) &#125; function ajaxSuccess(data, xhr, settings, deferred) &#123; var context = settings.context, status = 'success' settings.success.call(context, data, status, xhr) if (deferred) deferred.resolveWith(context, [data, status, xhr]) triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]) ajaxComplete(status, xhr, settings) &#125; // type: \"timeout\", \"error\", \"abort\", \"parsererror\" function ajaxError(error, type, xhr, settings, deferred) &#123; var context = settings.context settings.error.call(context, xhr, type, error) if (deferred) deferred.rejectWith(context, [xhr, type, error]) triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]) ajaxComplete(type, xhr, settings) &#125; // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\" function ajaxComplete(status, xhr, settings) &#123; var context = settings.context settings.complete.call(context, xhr, status) triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]) ajaxStop(settings) &#125; function ajaxDataFilter(data, type, settings) &#123; if (settings.dataFilter == empty) return data var context = settings.context return settings.dataFilter.call(context, data, type) &#125; // Empty function, used as default callback function empty() &#123;&#125; $.ajaxJSONP = function(options, deferred)&#123; if (!('type' in options)) return $.ajax(options) var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)), script = document.createElement('script'), originalCallback = window[callbackName], responseData, abort = function(errorType) &#123; $(script).triggerHandler('error', errorType || 'abort') &#125;, xhr = &#123; abort: abort &#125;, abortTimeout if (deferred) deferred.promise(xhr) $(script).on('load error', function(e, errorType)&#123; clearTimeout(abortTimeout) $(script).off().remove() if (e.type == 'error' || !responseData) &#123; ajaxError(null, errorType || 'error', xhr, options, deferred) &#125; else &#123; ajaxSuccess(responseData[0], xhr, options, deferred) &#125; window[callbackName] = originalCallback if (responseData &amp;&amp; $.isFunction(originalCallback)) originalCallback(responseData[0]) originalCallback = responseData = undefined &#125;) if (ajaxBeforeSend(xhr, options) === false) &#123; abort('abort') return xhr &#125; window[callbackName] = function()&#123; responseData = arguments &#125; script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName) document.head.appendChild(script) if (options.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; abort('timeout') &#125;, options.timeout) return xhr &#125; $.ajaxSettings = &#123; // Default type of request type: 'GET', // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // The context for the callbacks context: null, // Whether to trigger \"global\" Ajax events global: true, // Transport xhr: function () &#123; return new window.XMLHttpRequest() &#125;, // MIME types mapping // IIS returns Javascript as \"application/x-javascript\" accepts: &#123; script: 'text/javascript, application/javascript, application/x-javascript', json: jsonType, xml: 'application/xml, text/xml', html: htmlType, text: 'text/plain' &#125;, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty &#125; function mimeToDataType(mime) &#123; if (mime) mime = mime.split(';', 2)[0] return mime &amp;&amp; ( mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) &amp;&amp; 'xml' ) || 'text' &#125; function appendQuery(url, query) &#123; if (query == '') return url return (url + '&amp;' + query).replace(/[&amp;?]&#123;1,2&#125;/, '?') &#125; // serialize payload and append it to the URL for GET requests function serializeData(options) &#123; if (options.processData &amp;&amp; options.data &amp;&amp; $.type(options.data) != \"string\") options.data = $.param(options.data, options.traditional) if (options.data &amp;&amp; (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined &#125; $.ajax = function(options)&#123; var settings = $.extend(&#123;&#125;, options || &#123;&#125;), deferred = $.Deferred &amp;&amp; $.Deferred(), urlAnchor, hashIndex for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key] ajaxStart(settings) if (!settings.crossDomain) &#123; urlAnchor = document.createElement('a') urlAnchor.href = settings.url // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049 urlAnchor.href = urlAnchor.href settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host) &#125; if (!settings.url) settings.url = window.location.toString() if ((hashIndex = settings.url.indexOf('#')) &gt; -1) settings.url = settings.url.slice(0, hashIndex) serializeData(settings) var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url) if (hasPlaceholder) dataType = 'jsonp' if (settings.cache === false || ( (!options || options.cache !== true) &amp;&amp; ('script' == dataType || 'jsonp' == dataType) )) settings.url = appendQuery(settings.url, '_=' + Date.now()) if ('jsonp' == dataType) &#123; if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?') return $.ajaxJSONP(settings, deferred) &#125; var mime = settings.accepts[dataType], headers = &#123; &#125;, setHeader = function(name, value) &#123; headers[name.toLowerCase()] = [name, value] &#125;, protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol, xhr = settings.xhr(), nativeSetHeader = xhr.setRequestHeader, abortTimeout if (deferred) deferred.promise(xhr) if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest') setHeader('Accept', mime || '*/*') if (mime = settings.mimeType || mime) &#123; if (mime.indexOf(',') &gt; -1) mime = mime.split(',', 2)[0] xhr.overrideMimeType &amp;&amp; xhr.overrideMimeType(mime) &#125; if (settings.contentType || (settings.contentType !== false &amp;&amp; settings.data &amp;&amp; settings.type.toUpperCase() != 'GET')) setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded') if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name]) xhr.setRequestHeader = setHeader xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; xhr.onreadystatechange = empty clearTimeout(abortTimeout) var result, error = false if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 || (xhr.status == 0 &amp;&amp; protocol == 'file:')) &#123; dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type')) if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob') result = xhr.response else &#123; result = xhr.responseText try &#123; // http://perfectionkills.com/global-eval-what-are-the-options/ // sanitize response accordingly if data filter callback provided result = ajaxDataFilter(result, dataType, settings) if (dataType == 'script') (1,eval)(result) else if (dataType == 'xml') result = xhr.responseXML else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result) &#125; catch (e) &#123; error = e &#125; if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred) &#125; ajaxSuccess(result, xhr, settings, deferred) &#125; else &#123; ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred) &#125; &#125; &#125; if (ajaxBeforeSend(xhr, settings) === false) &#123; xhr.abort() ajaxError(null, 'abort', xhr, settings, deferred) return xhr &#125; var async = 'async' in settings ? settings.async : true xhr.open(settings.type, settings.url, async, settings.username, settings.password) if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name] for (name in headers) nativeSetHeader.apply(xhr, headers[name]) if (settings.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; xhr.onreadystatechange = empty xhr.abort() ajaxError(null, 'timeout', xhr, settings, deferred) &#125;, settings.timeout) // avoid sending empty string (#319) xhr.send(settings.data ? settings.data : null) return xhr &#125; // handle optional data/success arguments function parseArguments(url, data, success, dataType) &#123; if ($.isFunction(data)) dataType = success, success = data, data = undefined if (!$.isFunction(success)) dataType = success, success = undefined return &#123; url: url , data: data , success: success , dataType: dataType &#125; &#125; $.get = function(/* url, data, success, dataType */)&#123; return $.ajax(parseArguments.apply(null, arguments)) &#125; $.post = function(/* url, data, success, dataType */)&#123; var options = parseArguments.apply(null, arguments) options.type = 'POST' return $.ajax(options) &#125; $.getJSON = function(/* url, data, success */)&#123; var options = parseArguments.apply(null, arguments) options.dataType = 'json' return $.ajax(options) &#125; $.fn.load = function(url, data, success)&#123; if (!this.length) return this var self = this, parts = url.split(/\\s/), selector, options = parseArguments(url, data, success), callback = options.success if (parts.length &gt; 1) options.url = parts[0], selector = parts[1] options.success = function(response)&#123; self.html(selector ? $('&lt;div&gt;').html(response.replace(rscript, \"\")).find(selector) : response) callback &amp;&amp; callback.apply(self, arguments) &#125; $.ajax(options) return this &#125; var escape = encodeURIComponent function serialize(params, obj, traditional, scope)&#123; var type, array = $.isArray(obj), hash = $.isPlainObject(obj) $.each(obj, function(key, value) &#123; type = $.type(value) if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']' // handle data in serializeArray() format if (!scope &amp;&amp; array) params.add(value.name, value.value) // recurse into nested objects else if (type == \"array\" || (!traditional &amp;&amp; type == \"object\")) serialize(params, value, traditional, key) else params.add(key, value) &#125;) &#125; $.param = function(obj, traditional)&#123; var params = [] params.add = function(key, value) &#123; if ($.isFunction(value)) value = value() if (value == null) value = \"\" this.push(escape(key) + '=' + escape(value)) &#125; serialize(params, obj, traditional) return params.join('&amp;').replace(/%20/g, '+') &#125;&#125;)(Zepto)// zepro的form表单处理;(function($)&#123; $.fn.serializeArray = function() &#123; var name, type, result = [], add = function(value) &#123; if (value.forEach) return value.forEach(add) result.push(&#123; name: name, value: value &#125;) &#125; if (this[0]) $.each(this[0].elements, function(_, field)&#123; type = field.type, name = field.name if (name &amp;&amp; field.nodeName.toLowerCase() != 'fieldset' &amp;&amp; !field.disabled &amp;&amp; type != 'submit' &amp;&amp; type != 'reset' &amp;&amp; type != 'button' &amp;&amp; type != 'file' &amp;&amp; ((type != 'radio' &amp;&amp; type != 'checkbox') || field.checked)) add($(field).val()) &#125;) return result &#125; $.fn.serialize = function()&#123; var result = [] this.serializeArray().forEach(function(elm)&#123; result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value)) &#125;) return result.join('&amp;') &#125; $.fn.submit = function(callback) &#123; if (0 in arguments) this.bind('submit', callback) else if (this.length) &#123; var event = $.Event('submit') this.eq(0).trigger(event) if (!event.isDefaultPrevented()) this.get(0).submit() &#125; return this &#125;&#125;)(Zepto);(function()&#123; // getComputedStyle shouldn't freak out when called // without a valid element as argument try &#123; getComputedStyle(undefined) &#125; catch(e) &#123; var nativeGetComputedStyle = getComputedStyle window.getComputedStyle = function(element, pseudoElement)&#123; try &#123; return nativeGetComputedStyle(element, pseudoElement) &#125; catch(e) &#123; return null &#125; &#125; &#125;&#125;)() return Zepto&#125;))","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"javascript获取数据类型","slug":"javascript获取数据类型","date":"2018-11-14T02:45:29.000Z","updated":"2019-01-10T02:29:05.470Z","comments":true,"path":"2018/11/14/javascript获取数据类型/","link":"","permalink":"/2018/11/14/javascript获取数据类型/","excerpt":"判断js的数据类型，如：Boolean Number String等","text":"判断js的数据类型，如：Boolean Number String等 javascript获取数据类型平时在工作中，偶尔会用到判断一下这个数据是什么类型，是数组的？string的？function的？我一般都直接按照代码的需求，只写了需要判断的类型，用完就丢到一边，最近在看jquery源码，人家大牛写的真不错，改一改，封装一下，自己用哈。话不多说，直接贴出代码，其实很简单的：123456789101112131415161718function toType( obj ) &#123; var class2type = &#123;&#125;, toString = class2type.toString; \"Boolean Number String Function Array Date RegExp Object Error Symbol\" .split( \" \" ) .forEach(function( name ) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase(); &#125;); if ( obj == null ) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ toString.call( obj ) ] || \"object\" : typeof obj; &#125; 代码一共没有几行，接下来看看管不管用12345678910111213// 测试一下console.log('对象的类型-&gt;',toType(&#123;&#125;));console.log('函数的类型-&gt;',toType(function()&#123;&#125;));console.log('null的类型-&gt;',toType(null));console.log('undefined的类型-&gt;',toType(undefined));console.log('boolean的类型-&gt;',toType(true));console.log('number的类型-&gt;',toType(555));console.log('string的类型-&gt;',toType('abc'));console.log('array的类型-&gt;',toType([]));console.log('date的类型-&gt;',toType(new Date()));console.log('正则的类型-&gt;',toType(/abc/g));console.log('symbol-&gt;',toType(Symbol()));console.log('Error的类型-&gt;',toType(new Error())); 基本上的类型都判断出来了，不错吧。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"tcp三次握手和四次挥手","slug":"tcp三次握手和四次挥手","date":"2018-11-07T06:34:14.000Z","updated":"2018-11-07T06:58:56.835Z","comments":true,"path":"2018/11/07/tcp三次握手和四次挥手/","link":"","permalink":"/2018/11/07/tcp三次握手和四次挥手/","excerpt":"我的tcp三次握手和四次挥手简洁理解。","text":"我的tcp三次握手和四次挥手简洁理解。 tcp三次握手和四次挥手tcp三次握手和四次挥手，这是一个很基础的计算机网络层面的基础问题，让我回答我也说不出来具体的东西，所以，为了加强记忆，按照自己的理解，把它记下来。 三次握手我们用打电话的生活场景来模拟三次握手：123client: 你好，能听到我说话吗？server：能听到，你能听到我说话吗？client：是的，我也能听到你说话。 像上面这样，来回通过3次对话，确认了双方都可以接收到相互的信息。 四次挥手我们还用打电话的生活场景来模拟四次挥手：1234client: 我有事，不跟你聊了哈。server：知道了。server：最后说一句，明天把书给我带来。client：好的，知道了。 好了，四次挥手也模拟完了。我这只是模拟了这两个过程而已，如果想学习真正的原理，请参考这里","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js抽象语法树AST","slug":"js抽象语法树AST","date":"2018-11-06T07:48:54.000Z","updated":"2018-11-06T09:02:14.113Z","comments":true,"path":"2018/11/06/js抽象语法树AST/","link":"","permalink":"/2018/11/06/js抽象语法树AST/","excerpt":"通过javascript parser将代码转化成抽象语法树，这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。","text":"通过javascript parser将代码转化成抽象语法树，这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。 js抽象语法树AST最近在研究webpack，想研究一下它是如何打包的，不过，刚刚入门，就有一个知识点把我难住了，那就是AST抽象语法树。于是乎，上网查了查，原理就是把代码解析，解析成一个有各种属性状态的json树，便于对代码进行操作，具体的解析代码当然是很难的，像我们这种菜鸟只需要了解一下用法就可以了。babel是现在几乎每个项目中必备的一个东西，但是其工作原理避不开对js的解析在生成的过程，babel有引擎babylon，早期fork了项目acron，了解这个之前我们先来看看这种引擎解析出来是什么东西。不光是babel还有webpack等。 什么是抽象语法树见下面例子：12var a = 1;var b = a + 1; 之后我们通过这个网站，他是一个esprima引擎的网站，十分好用.画成流程图如下：而他的json对象格式是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"VariableDeclaration\", \"declarations\": [ &#123; \"type\": \"VariableDeclarator\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"init\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; ], \"kind\": \"var\" &#125;, &#123; \"type\": \"VariableDeclaration\", \"declarations\": [ &#123; \"type\": \"VariableDeclarator\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"b\" &#125;, \"init\": &#123; \"type\": \"BinaryExpression\", \"operator\": \"+\", \"left\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"right\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; &#125; ], \"kind\": \"var\" &#125; ], \"sourceType\": \"script\"&#125; 众多AST解析引擎chrome有v8，firefix有spidermonkey.还有一些常用的引擎有： esprima acron Traceur UglifyJS2 shift AST的学习三板斧 通过esprima生成AST 通过estraverse遍历和更新AST 通过escodegen将AST重新生成源码 来一个简单例子，看看用法：1.先新建一个test的工程目录2.在test工程下安装esprima、estraverse、escodegen的npm模块1npm i esprima estraverse escodegen --save 3.在目录下面新建一个test.js文件,载入以下代码：1234const esprima = require('esprima');let code = 'const a = 1';const ast = esprima.parseScript(code);console.log(ast); 你将会看到输出结果：12345678Script &#123; type: 'Program', body: [ VariableDeclaration &#123; type: 'VariableDeclaration', declarations: [Array], kind: 'const' &#125; ], sourceType: 'script' &#125; 4.再在test文件中，载入以下代码：12345678const estraverse = require('estraverse');estraverse.traverse(ast, &#123; enter: function (node) &#123; node.kind = \"var\"; &#125;&#125;);console.log(ast); 输出的结果：12345678Script &#123; type: 'Program', body: [ VariableDeclaration &#123; type: 'VariableDeclaration', declarations: [Array], kind: 'var' &#125; ], sourceType: 'script' &#125; 5.最后在test文件中，加入以下代码：123const escodegen = require(\"escodegen\");const transformCode = escodegen.generate(ast)console.log(transformCode); 输出的结果：1var a = 1; 通过这三步，我们将const a = 1转化成了var a = 1 虽然，具体的解析原理我们并不知道，但是，通过这三个模块包，是不是有种自己搞出一个babel的赶脚。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"对象链式取值(如loadsh的_.get()方法)在项目中的应用","slug":"对象链式取值-如loadsh的-get-方法-在项目中的应用","date":"2018-11-05T05:27:11.000Z","updated":"2018-11-05T06:15:20.933Z","comments":true,"path":"2018/11/05/对象链式取值-如loadsh的-get-方法-在项目中的应用/","link":"","permalink":"/2018/11/05/对象链式取值-如loadsh的-get-方法-在项目中的应用/","excerpt":"对象的链式取值在项目中的应用场景。","text":"对象的链式取值在项目中的应用场景。 对象链式取值(如loadsh的_.get()方法)在项目中的应用相信大家在从后端获取数据的时候，像这样res.data.rows.count来获取数据的情况很多，如果后台返回的格式不对了，或则data是个null，那么很容易报Uncaught TypeError: Cannot read property ‘goods’ of undefined这样的错。我们一般会这样写：123if(res &amp;&amp; res.data &amp;&amp; res.data.rows &amp;&amp; res.data.count) &#123; ...&#125; 不过这么写实在是有些麻烦，我一般的做法是直接catch住error，然后定位到具体错误在哪，在改正。不过，最近在网上看到一篇专门写关于对象的链式取值的文章，里边写了大概4种解决方法，这里我只记录学习了其中一种，也是兼容性最好的一种，就想使用loadsh的_.get方法，先看看loadsh是怎么用的，见下边1234567var object = &#123; 'a': [&#123; 'b': &#123; 'c': 3 &#125; &#125;] &#125;;_.get(object, 'a[0].b.c');// =&gt; 3_.get(object, ['a', '0', 'b', 'c']);// =&gt; 3_.get(object, 'a.b.c', 'default');// =&gt; 'default' 使用方法一目了然，第一个参数：对象，第二个参数：链式字符串，第三个参数是，如果按照这个链式字符串在对象中取不到值，返回这个默认值。这样写的话，就像上边即使后台同事更改了数据结构，不会报错，而是返回默认值。（不过这种写法我觉得也有不好的地方，那就是不容易发现错误，后台返回的数据结构都变了，而我们前台并没有出现异常，而是返回来初始写的默认值，是不是有点。。。）不过，这种写法在其它场合我想一定会有用武之地。我现在的项目中并没有用到loadsh这个库，但是还想用咋办呢？自己写一个喽，还好，写法简单，容易理解，注意，下边给出的代码交通过函数解析字符串方式来处理的。1234567891011121314151617181920212223242526272829function get (obj, props, def) &#123; if((obj == null) || obj == null || typeof props !== 'string') return def; const temp = props.split('.'); const fieldArr = [].concat(temp); temp.forEach((e, i) =&gt; &#123; if(/^(\\w+)\\[(\\w+)\\]$/.test(e)) &#123; const matchs = e.match(/^(\\w+)\\[(\\w+)\\]$/); const field1 = matchs[1]; const field2 = matchs[2]; const index = fieldArr.indexOf(e); fieldArr.splice(index, 1, field1, field2); &#125; &#125;) return fieldArr.reduce((pre, cur) =&gt; &#123; const target = pre[cur] || def; if(target instanceof Array) &#123; return [].concat(target); &#125; if(target instanceof Object) &#123; return Object.assign(&#123;&#125;, target) &#125; return target; &#125;, obj)&#125;var c = &#123;a: &#123;b : [1,2,3] &#125;&#125;get(c ,'a.b') // [1,2,3]get(c, 'a.b[1]') // 2get(c, 'a.d', 12) // 12 其实，在项目无论如何使用都没什么问题，即使什么都不做，最后项目完成时，也一定会因为出现报错而改正过来，最多就是不够健壮。我觉得这个函数解析字符串的方式很好，值得举一反三，值得学习。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"webpack打包bundle.js文件代码分析","slug":"webpack打包bundle-js文件代码分析","date":"2018-11-01T06:16:54.000Z","updated":"2018-11-01T08:31:47.325Z","comments":true,"path":"2018/11/01/webpack打包bundle-js文件代码分析/","link":"","permalink":"/2018/11/01/webpack打包bundle-js文件代码分析/","excerpt":"webpack这个打包工具，现在可以说很火，前一段时间为了优化公司项目，搞了一个月的gulp，说实在的，gulp的功能我感觉很强大了，而且用起来很灵活，最关键是简单，需要什么的时候直接弄个gulp任务，但是，使用场景很少了，由于之前的项目是php的，现在一般都用vue，react等，都已经集成了webpack，虽然说不用太多配置，但是需要配置的时候还是有的，所以，webpack研究一下也是有必要的，今天，复杂的先不说，只说说bundle.js这个文件里的代码都是干吗用的。","text":"webpack这个打包工具，现在可以说很火，前一段时间为了优化公司项目，搞了一个月的gulp，说实在的，gulp的功能我感觉很强大了，而且用起来很灵活，最关键是简单，需要什么的时候直接弄个gulp任务，但是，使用场景很少了，由于之前的项目是php的，现在一般都用vue，react等，都已经集成了webpack，虽然说不用太多配置，但是需要配置的时候还是有的，所以，webpack研究一下也是有必要的，今天，复杂的先不说，只说说bundle.js这个文件里的代码都是干吗用的。 webpack打包bundle.js文件代码分析一个入口，一个文件首先，webpack.config.js配置文件是这样滴：123456module.exports = &#123; entry:'./index.js', output:&#123; filename:'bundle.js' &#125;&#125;; index.js内容是这样滴：1console.log('index'); 最后再看看打完包后的bundle.js内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports) &#123; console.log('index');/***/ &#125;/******/ ]); 我们来分析一下bundle.js这个文件 1.整个内容是一个自执行函数，自执行函数传的参数是一个数组，数组里的元素是function函数，这个函数体的内容就是index.js文件的内容。 2.在这个闭包函数中，__webpack_require_是模块加载函数，接收模块id（对，webpack中每个模块都会有一个独一无二的id，其实也就是在IIFE传参数组中的索引值（0，1，2…..）。 3.真正执行module index里面语句的是个调用12// Execute the module functionmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__); 我们再来看一个例子 一个入口，两个文件，A依赖B先贴出文件内容：123456// a.jsvar b = require('./b.js');console.log('a');b.b1(); 12345678// b.jsexports.b1 = function () &#123; console.log('b1')&#125;;exports.b2 = function () &#123; console.log('b2')&#125;; 1234567891011121314151617181920212223242526272829303132// bundle.js/******/ (function(modules) &#123; // webpackBootstrap// 省略一大段.........../******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; var b = __webpack_require__(1); console.log('a'); b.b1();/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; exports.b1 = function () &#123; console.log('b1') &#125;; exports.b2 = function () &#123; console.log('b2') &#125;;/***/ &#125;/******/ ]); 我们再来分析一下上面的代码。 1.由于有两个文件，所以IIFE得参数为长度是2的数组，并按照require的顺序排列。 2.IIFE函数体部分是一模一样的，也就是说再复杂的，多个依赖的文件，函数体部分也不变滴。 3.module a发生了变化，因为a依赖b，所以在a中调用webpack加载模块的函数 12// 1是模块b的idvar b = __webpack_require__(1); 4.我们再来分析一下modules[moduleId].call(module.exports, module, module.exports, webpack_require);使用call是因为为了确保每个module中的this指向的是module本身。然后给它传__webpack_require函数是想让module有加载其他module的能力。 其它情况其它的情况，比如多入口，多出口情况这里就不做过多分析，我也没搞明白，接下来准备手写一个简单的仿webpack打包工具。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"移动端webview模板","slug":"移动端webview模板","date":"2018-10-30T02:29:58.000Z","updated":"2019-02-02T02:05:38.715Z","comments":true,"path":"2018/10/30/移动端webview模板/","link":"","permalink":"/2018/10/30/移动端webview模板/","excerpt":"移动端的页面平时偶尔会有需求需要做，特别是webview嵌入的页面居多，由于是有时候做，有时候不做，所以，需求来的时候从新写页面还是有点麻烦，所以把之前写的记录一下，下次直接copy就好了。","text":"移动端的页面平时偶尔会有需求需要做，特别是webview嵌入的页面居多，由于是有时候做，有时候不做，所以，需求来的时候从新写页面还是有点麻烦，所以把之前写的记录一下，下次直接copy就好了。 移动端webview模板css一些css初始化的内容123456789101112131415161718192021222324252627@charset \"utf-8\";/* CSS Document */body,ul,ol,p,h1,h2,h3,h4,h5,dl,dd,form,input,textarea,td,th,button,strong,em,select,video,canvas&#123;margin:0;padding:0;&#125;h1,h2,h3,h4,h5,h6&#123; font-weight:normal;&#125;li&#123;list-style:none;vertical-align:top;&#125;table&#123; border-collapse:collapse;&#125;textarea&#123;resize:none;overflow:auto;&#125;img&#123; border:none; vertical-align:middle; width:100%;&#125;em,i&#123; font-style:normal;&#125;a&#123; text-decoration:none;&#125;a,input&#123; -webkit-appearance: none;/*屏蔽阴影*/ -webkit-tap-highlight-color:rgba(0,0,0,0); /*ios android去除自带阴影的样式*/&#125;a, img &#123; /* 禁止长按链接与图片弹出菜单 */ -webkit-touch-callout: none;&#125;html, body &#123; /* 禁止选中文本(如无文本选中需求,此为必选项) */ -webkit-user-select: none; user-select: none; background:#f5f5f5; overflow-x:hidden;&#125; js来控制rem大小代码js来修改html的font-size大小123456789101112(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth/20 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); html页面内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;&lt;meta content=\"email=no\" name=\"format-detection\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../js/config.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 判断ios android var u = navigator.userAgent; var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端 var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 var goodsId = window.location.search.split('=')[1] var reqUrl = BASEURL +'/goods/shopProduct/findSpuDescsBySpuId/' + goodsId; $.ajax(&#123; method: 'POST', url: reqUrl, headers: &#123; 'client-token': 'eyJhbGciOiJIUzUxMiJ9.eyJ1aWQiOiIxMjMiLCJjZXJ0Tm8iOiI0NTYifQ.xTR4SG0z3Nuf-siW34XtVgqNPr9PRpPb8XFKY6Hrj_Qg8kl9C0AeVFcQ8NnguQ-SrlHHcv5M16SkjVYX3PKweg' &#125;, data: &#123;goodsId: goodsId&#125;, dataType: 'json', success: function(res)&#123; if(res.code === '0000') &#123; var innerContent = res.data; var bodyContent = $.parseHTML(innerContent); $('.content').append(bodyContent); if(isiOS) &#123; var imgNum = $('img').size(), loadCount=0; $('img').on('load', function(ev) &#123; loadCount++; if(loadCount === imgNum)&#123; // 获取到页面高度返给ios端 var bodyHeight = $('body').height() + 25; // 调取ios注入的方法 window.webkit.messageHandlers.jsCallNative.postMessage(&#123;height: bodyHeight&#125;); &#125; &#125;); &#125; &#125; &#125;, error: function() &#123;&#125;, &#125;);&lt;/script&gt;&lt;/html&gt; 这个webview页面相对麻烦些，需求是在ios页面的固定位置显示webview内容，并不是新开一个新页面来整个显示webview内容，这样ios需要获取h5页面的高，而页面的内容又是h5页面通过ajax获取回来的，所以，ajax请求成功后，将内容插入到页面中，如果有图片的话，等待图片全部加载之后再计算页面的高，返给ios。这时，ios提供了一个函数注入到h5页面里了，我们直接调用就可以，代码中就是这个函数window.webkit.messageHandlers.jsCallNative.postMessage(); 补充点这方面的知识2019/2/2123456789if(isiOS) &#123; // 如果是ios的话 window.webkit.messageHandlers.iosCallback.postMessage(null); // 我告诉ios端可以调我提供的callAppFnInfo函数，它会把值给我传过来。 function callAppFnInfo(info) &#123; alert(info); &#125;&#125;else &#123; // android环境 var da = window.WebViewInterface.getId(); // 直接调取android提供的方法，它可以直接返回值 alert(da);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js基础知识思维导图","slug":"js基础知识思维导图","date":"2018-10-29T05:50:50.000Z","updated":"2018-10-29T07:38:50.287Z","comments":true,"path":"2018/10/29/js基础知识思维导图/","link":"","permalink":"/2018/10/29/js基础知识思维导图/","excerpt":"在网上无意间发现了一套js基础的思维导图，赶紧收为己用，呵呵。","text":"在网上无意间发现了一套js基础的思维导图，赶紧收为己用，呵呵。 js基础知识思维导图1.变量 2.数组 3.运算符 4.流程语句 5.函数基础 6.字符串函数 7.基本dom操作 8.浏览器Bom对象 9.正则表达式","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js类的继承(ES5写法)","slug":"js类的继承-ES5写法","date":"2018-10-23T01:30:30.000Z","updated":"2019-10-25T01:37:01.093Z","comments":true,"path":"2018/10/23/js类的继承-ES5写法/","link":"","permalink":"/2018/10/23/js类的继承-ES5写法/","excerpt":"js继承之终极继承寄生组合式继承","text":"js继承之终极继承寄生组合式继承 js类的继承(ES5写法)js的继承方式有很多，大致的罗列一下： 构造继承 原型链继承 组合继承 原型式继承 寄生式继承 寄生组合式继承这里只是列举了一些，还有很多其它方法，就不一一写出。在这些方法中，寄生组合式继承被认为是最好的，所以，只要记住这一种写法不就可以了吗。寄生组合式继承代码如下：123456789101112131415161718192021222324252627function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"实现call函数","slug":"实现call函数","date":"2018-10-19T02:00:15.000Z","updated":"2018-10-19T06:03:10.245Z","comments":true,"path":"2018/10/19/实现call函数/","link":"","permalink":"/2018/10/19/实现call函数/","excerpt":"自己实现call函数","text":"自己实现call函数 实现call函数实现代码很简单，直接贴出来123456789101112131415161718Function.prototype.myCall = function(context) &#123; context.fn = this; var args = arguments, str=''; for(var i=1; i&lt;args.length; i++) &#123; str += (args[i]+','); &#125; var newStr = str.slice(0,(str.length-1)); eval('context.fn('+newStr+')');&#125;function abc(a,b) &#123; console.log(this.name+a+b);&#125;abc.myCall(&#123; name: 'join'&#125;,1,2);abc.myCall(&#123; name: 'mike'&#125;,3,4);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"ajax跨域请求自定义header字段问题","slug":"ajax跨域请求自定义header字段问题","date":"2018-10-16T03:14:48.000Z","updated":"2018-10-16T03:31:27.520Z","comments":true,"path":"2018/10/16/ajax跨域请求自定义header字段问题/","link":"","permalink":"/2018/10/16/ajax跨域请求自定义header字段问题/","excerpt":"Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX的处理办法","text":"Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX的处理办法 ajax跨域请求自定义header字段问题首先，在后端允许跨域请求的情况下，前端加上自定义的请求字段，如下123456789101112$.ajax(&#123; method: 'POST', url: reqUrl, headers: &#123; 'client-token': '123456' &#125;, data: &#123;goodsId: goodsId&#125;, dataType: 'json', success: function(res)&#123; &#125;, error: function() &#123;&#125;, &#125;); 客户端 按照上面的写，你需要处理的是 服务端 响应头的设置 1.第一步设置响应头123header('Access-Control-Allow-Origin:*'); //支持全域名访问，不安全，部署后需要固定限制为客户端网址header('Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE'); //支持的http 动作header('Access-Control-Allow-Headers:x-requested-with,content-type'); //响应头 请按照自己需求添加。 2.第二步了解IE chrome 等浏览器 对于 跨域请求并要求设置Headers自定义参数的时候的 “预请求” 就是如果遇到 跨域并设置headers的请求，所有请求需要两步完成！A 第一步：发送预请求 OPTIONS 请求。此时 服务器端需要对于OPTIONS请求作出响应 一般使用202响应即可 不用返回任何内容信息。（能看到这份手稿的人，本人不相信你后台处理不了一个options请求）B 第二步：服务器accepted 第一步请求后 浏览器自动执行第二步 发送真正的请求。此时 大多数人 会发现请求成功了，但是 有那么几个人会发现 请求成功了但是没有任何信息返回 why？因为你自定义的请求头在服务器响应中不存在！查看console输出 会发现一个问题：“Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX”【IE】，request header field xxxxxx is not allowed by Access-Control-Allow-Header【chrome】这是因为 你的XXXX请求头 没有在服务器端被允许哦~遇到这个问题 只有通过修改服务器端来完成，举例：需要设置 client-token这么一个自定义头，那么 你需要在 服务端里面 将header(‘Access-Control-Allow-Headers:x-requested-with,content-type，client-token’); 同学们自行体会吧 这种语法就是根据“,”分割 自己需要设置什么头，必须要在 服务端请求的响应头里面设置好，不然客户端永远永远提交不上去！至此 JavaScript/ajax 跨域+ 修改httpheader 任务完美实现。“人们都一直在抱怨 JavaScript同源策略限制了web前端的发展！然而是服务端做的不够细致！”","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"scratch介绍","slug":"scratch介绍","date":"2018-10-11T10:44:55.000Z","updated":"2018-10-12T05:10:36.869Z","comments":true,"path":"2018/10/11/scratch介绍/","link":"","permalink":"/2018/10/11/scratch介绍/","excerpt":"少儿编程神器scratch简单介绍","text":"少儿编程神器scratch简单介绍 scratch介绍scratch是一款儿童学习编程的软件，把具体的一些控制语句以图形的形式表现出来，可以用鼠标来拖动，很生动，简单，不理解编程的孩子们容易学习，本人也是刚刚接触学习scratch，跟孩子们一样需要重头来学习，因为我想做一名少儿编程启蒙老师。先把scratch的网址贴出来：scratch官网 安装scratch在线免安装首页点击try it out就进入在线页面玩耍了。 离线安装首页的footer位置，support下有Offline Editor连接，也可以点这里之后见下图位置可以下载安装了","categories":[{"name":"少儿编程","slug":"少儿编程","permalink":"/categories/少儿编程/"}],"tags":[{"name":"scratch","slug":"scratch","permalink":"/tags/scratch/"}]},{"title":"编译与解释","slug":"编译与解释","date":"2018-10-10T05:11:48.000Z","updated":"2018-10-10T06:09:09.952Z","comments":true,"path":"2018/10/10/编译与解释/","link":"","permalink":"/2018/10/10/编译与解释/","excerpt":"编译与解释的介绍","text":"编译与解释的介绍 编译与解释什么是编译器编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。 什么是解释器在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码预编译成机器码。一个解释器，通常会用以下的姿势来执行程序代码：1.分析源代码，并且直接执行。2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。3.执行由解释器内部的编译器预编译后保存的代码可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。 分两个维度比较一下表现 Behavior 编译器把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。 解释器会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。 性能 Performance 编译器会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。 解释器会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。 关于代码，需要知道的几个概念在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。 高级语言代码 High-Level Code高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。 低级语言代码 Low-Level Code低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。但是这也意味着代码的可移植性很差。在我看来，高与低，只是一组相对词而已。越高级的语言，性能、自由度越不及低级语言。但是在抽象、可读可写性、可移植性越比低级语言优秀。在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。而到了今天，我们更多人对C语言偏向认知为「低级语言」。或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。 汇编语言 Assembly Language汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。它和计算机的体系结构以及机器指令是强关联的。换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。所以汇编语言也往往被称作象征性机器码(symbolic machine code) 字节码 Byte Code字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。它是由一堆指令集组成的代码，例如在javac编译过后的java源码产生的就是字节码。源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。 机器码 Machine Code机器码是一组可以直接被CPU执行的指令集，每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。 从熟悉的编程语言的角度来看看从左往右看，1.以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。2.以 BASIC 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。3.以 C 语言为例，我们在文本编译器编写好源代码，然后运行 gcc hello.c 编译出 hello.out 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。 抽象看本质：人与计算机之间的鸿沟无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。这也是很多人所说的「跳出这个框框再看」的思维方式。 无论是「编译 Compile」还是「解释 Interpret」。本质还是「人与计算机的交流形式」，人的语言最终转换成机器语言。一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。 就这么一个过程，我们就需要很多的翻译官。有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。 最后用一张图来展示一下编译与解释","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"vue不同路由使用同一个组件重新加载这个组件","slug":"vue不同路由使用同一个组件重新加载这个组件","date":"2018-10-08T02:26:49.000Z","updated":"2018-10-08T05:26:06.679Z","comments":true,"path":"2018/10/08/vue不同路由使用同一个组件重新加载这个组件/","link":"","permalink":"/2018/10/08/vue不同路由使用同一个组件重新加载这个组件/","excerpt":"vue不同路由使用同一个组件重新加载这个组件","text":"vue不同路由使用同一个组件重新加载这个组件 vue不同路由使用同一个组件重新加载这个组件vue,react,angular都会有一个共同点，那就是如果两个路由用的是一个组件的话，在切换路由的时候组件的生命周期函数并没有被调用，比如有一些想在组件渲染之后调用的钩子函数并不会执行，这是为了性能的考虑。我之前用angular的时候有相应的解决办法，react也有，这里不做探讨，这里只说vue，昨天看到了一个这方面的解决方法，感觉很好，记录下来。有两种解决方案： 第一种监听$route的变化来初始化数据，如下：1234567891011121314151617181920212223data() &#123; return &#123; loading: false, error: null, post: null &#125;&#125;,watch: &#123; '$route': &#123; handler: 'resetData', immediate: true &#125;&#125;,methods: &#123; resetData() &#123; this.loading = false this.error = null this.post = null this.getPost(this.$route.params.id) &#125;, getPost(id)&#123; &#125;&#125; 第二种给router-view添加一个unique的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件，将key直接设置为路由的完整路径。1&lt;router-view :key=\"$route.fullpath\"&gt;&lt;/router-view&gt; 组件代码就可以正常的书写了，如下：123456789101112131415data() &#123; return &#123; loading: false, error: null, post: null &#125;&#125;,created () &#123; this.getPost(this.$route.params.id)&#125;,methods () &#123; getPost(postId) &#123; // ... &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"图片类型转换(image base64 file canvas)","slug":"图片类型转换-image-base64-file-canvas","date":"2018-09-29T03:32:57.000Z","updated":"2018-09-29T05:22:22.078Z","comments":true,"path":"2018/09/29/图片类型转换-image-base64-file-canvas/","link":"","permalink":"/2018/09/29/图片类型转换-image-base64-file-canvas/","excerpt":"图片的各种类型相互间的转换。","text":"图片的各种类型相互间的转换。 图片类型转换(image base64 file canvas)dom中的img标签来显示图片，在src上给一个图片的连接即可，但是如果想把这个图片放在canvas上，或者ipput上传的图片想显示出来，或者canvas剪裁的图片想保存为Blob格式用ajax上传等等一系列操作，如果不缕清楚的话真是迷糊，所以做一下小小的总结。 url连接urltoImage(url,fn) 会通过一个url加载所需要的图片对象，其中 url 参数传入图片的 url , fn 为回调方法,包含一个Image对象的参数，代码如下：1234567function urltoImage (url,fn)&#123; var img = new Image(); img.src = url; img.onload = function()&#123; fn(img); &#125;&#125;; canvas画图片imagetoCanvas(image) 会将一个 Image 对象转变为一个 Canvas 类型对象，其中 image 参数传入一个Image对象，代码如下：12345678function imagetoCanvas(image)&#123; var cvs = document.createElement(\"canvas\"); var ctx = cvs.getContext('2d'); cvs.width = image.width; cvs.height = image.height; ctx.drawImage(image, 0, 0, cvs.width, cvs.height); return cvs ;&#125;; canvas图片转Blob canvasResizetoFile(canvas,quality,fn) 会将一个 Canvas 对象压缩转变为一个 Blob 类型对象；其中 canvas 参数传入一个 Canvas 对象; quality 参数传入一个0-1的 number 类型，表示图片压缩质量; fn 为回调方法，包含一个 Blob 对象的参数;代码如下： 12345function canvasResizetoFile(canvas,quality,fn)&#123; canvas.toBlob(function(blob) &#123; fn(blob); &#125;,'image/jpeg',quality);&#125;; 这里的 Blob 对象表示不可变的类似文件对象的原始数据。 Blob 表示不一定是 JavaScript 原生形式的数据。 File 接口基于 Blob ，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件。我们可以把它当做File类型对待，其他更具体的用法可以参考MDN文档 canvas转dataURL canvasResizetoDataURL(canvas,quality) 会将一个 Canvas 对象压缩转变为一个 dataURL 字符串,其中 canvas 参数传入一个 Canvas 对象; quality 参数传入一个0-1的 number 类型，表示图片压缩质量;代码如下：123methods.canvasResizetoDataURL = function(canvas,quality)&#123; return canvas.toDataURL('image/jpeg',quality);&#125;; 其中的 toDataURL API可以参考MDN文档 File(Blob)转dataURL filetoDataURL(file,fn) 会将 File （ Blob ）类型文件转变为 dataURL 字符串,其中 file 参数传入一个 File （ Blob ）类型文件; fn 为回调方法，包含一个 dataURL 字符串的参数;代码如下： 1234567function filetoDataURL(file,fn)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; fn(e.target.result); &#125;; reader.readAsDataURL(file);&#125;; dataURL转为Image类型文件 dataURLtoImage(dataurl,fn) 会将一串 dataURL 字符串转变为 Image 类型文件,其中 dataurl 参数传入一个 dataURL 字符串, fn 为回调方法，包含一个 Image 类型文件的参数，代码如下： 1234567function dataURLtoImage(dataurl,fn)&#123; var img = new Image(); img.onload = function() &#123; fn(img); &#125;; img.src = dataurl;&#125;; dataURL转为Blob类型dataURLtoFile(dataurl) 会将一串 dataURL 字符串转变为 Blob 类型对象，其中 dataurl 参数传入一个 dataURL 字符串,代码如下：12345678function dataURLtoFile(dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type:mime&#125;);&#125;; 实际应用demo对于常用的将一个 File 对象压缩之后再变为 File 对象,我们可以将上面的方法再封装一下，参考如下代码：1234567function fileResizetoFile(file,quality,fn)&#123; filetoDataURL (file,function(dataurl)&#123; dataURLtoImage(dataurl,function(image)&#123; canvasResizetoFile(imagetoCanvas(image),quality,fn); &#125;) &#125;)&#125; 其中， file 参数传入一个 File （ Blob ）类型文件； quality 参数传入一个 0-1 的 number 类型，表示图片压缩质量； fn 为回调方法，包含一个 Blob 类型文件的参数。它使用起来就像下面这样：12345var file = document.getElementById('demo').files[0];fileResizetoFile(file,0.6,function(res)&#123; console.log(res); //拿到res，做出你要上传的操作；&#125;) 再来一个图片等比压缩的demo1234567891011121314151617181920212223242526272829function proDownImage(path,imgObj) &#123; // 等比压缩图片工具 //var proMaxHeight = 185; var proMaxHeight=300; var proMaxWidth = 175; var size = new Object(); var image = new Image(); image.src = path; image.attachEvent(\"onreadystatechange\", function() &#123; // 当加载状态改变时执行此方法,因为img的加载有延迟 if (image.readyState == \"complete\") &#123; // 当加载状态为完全结束时进入 if (image.width &gt; 0 &amp;&amp; image.height &gt; 0) &#123; var ww = proMaxWidth / image.width; var hh = proMaxHeight / image.height; var rate = (ww &lt; hh) ? ww: hh; if (rate &lt;= 1) &#123; alert(\"imgage width*rate is:\" + image.width * rate); size.width = image.width * rate; size.height = image.height * rate; &#125; else &#123; alert(\"imgage width is:\" + image.width); size.width = image.width; size.height = image.height; &#125; &#125; &#125; imgObj.attr(\"width\",size.width); imgObj.attr(\"height\",size.height); &#125;);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"一些好的文章收集","slug":"一些好的文章收集","date":"2018-09-28T02:19:50.000Z","updated":"2019-11-26T08:57:32.550Z","comments":true,"path":"2018/09/28/一些好的文章收集/","link":"","permalink":"/2018/09/28/一些好的文章收集/","excerpt":"网上看到的好文章，总结收集。","text":"网上看到的好文章，总结收集。 一些好的文章收集自己写博客文章真的是一件耗时的事儿，写文章需要把各个方面的知识都整理好，有时候我都是在网上看到一篇不错的文章，想记录下来，就照猫画虎的copy，但是，copy下拉也需要时间啊，没办法，现在我只能把连接记录下来，等有时间再好好地记录一下。 高频dom操作和页面性能优化探索 送你43道JS面试题 SVG快速入门 浏览器audio自动播放解决方式","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"文章收集","slug":"文章收集","permalink":"/tags/文章收集/"}]},{"title":"hexo中使用hexo-asset-image插件来加载本地图片","slug":"hexo中使用hexo-asset-image插件来加载本地图片","date":"2018-09-21T02:55:52.000Z","updated":"2018-09-21T03:34:34.812Z","comments":true,"path":"2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","link":"","permalink":"/2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","excerpt":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。","text":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。 hexo中使用hexo-asset-image插件来加载本地图片在使用hexo时，在md文件里加载图片一般都会用到网络上的图片，但是如果有些图片不允许使用，怎么办？当然可以用七牛云这种图床网站，如果想使用本地的图片怎么办呢？那就用到了hexo-asset-image这个插件，但是这个插件写的很早，与现在新版本的hexo不兼容，于是乎就有一些大牛进行了修改，这里贴出这位大牛的github地址，兼容新版本hexo的hexo-asset-image插件。使用方法就是替换掉npm安装的hexo-asset-image插件中的文件,代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 图片具体的引入方式：12345678MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.mdMake sure post_asset_folder: true in your _config.yml.Just use ![logo](logo.jpg) to insert logo.jpg.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"HTTP缓存机制及原理","slug":"HTTP缓存机制及原理","date":"2018-09-19T02:14:58.000Z","updated":"2018-09-21T03:32:01.666Z","comments":true,"path":"2018/09/19/HTTP缓存机制及原理/","link":"","permalink":"/2018/09/19/HTTP缓存机制及原理/","excerpt":"HTTP缓存机制及原理的一些小总结","text":"HTTP缓存机制及原理的一些小总结 HTTP缓存机制及原理前言Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。 在介绍HTTP缓存之前，作为知识铺垫，先简单介绍一下HTTP报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。已存在缓存数据时，仅基于强制缓存，请求数据的流程如下已存在缓存数据时，仅基于对比缓存，请求数据的流程如对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 ExpiresExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886）图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。第一次访问：再次访问：通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。 Last-Modified / If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。浏览器第一次请求：浏览器再次请求时：","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"css省略号","slug":"css省略号","date":"2018-09-14T07:39:45.000Z","updated":"2018-09-14T08:09:22.697Z","comments":true,"path":"2018/09/14/css省略号/","link":"","permalink":"/2018/09/14/css省略号/","excerpt":"页面中文字溢出的省略号","text":"页面中文字溢出的省略号 css文本溢出省略号单行文本省略号1234overflow: hidden;text-overflow: ellipsis;white-space: nowrap;// 有些浏览器需要加上width 多行文本溢出省略号在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp ；注意：这是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 兼容其它浏览器的写法html:1&lt;p&gt;WebKit Browsers will clamp the number of lines in this paragraph to 2. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt; css:12345678910111213141516p &#123; position:relative; line-height:1.4em; /* 3 times the line-height to show 3 lines */ height:4.2em; overflow:hidden;&#125;p::after &#123; content:\"...\"; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; background:url(http://css88.b0.upaiyun.com/css88/2014/09/ellipsis_bg.png) repeat-y;&#125; 这里注意几点： height高度真好是line-height的3倍； 结束的省略好用了半透明的png做了减淡的效果，或者设置背景颜色； IE6-7不显示content内容，所以要兼容IE6-7可以是在内容中加入一个标签，比如用…去模拟； 要支持IE8，需要将::after替换成:after；","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"技术博客网站收集整理","slug":"技术博客网站收集整理","date":"2018-09-06T09:05:00.000Z","updated":"2020-03-04T01:41:09.822Z","comments":true,"path":"2018/09/06/技术博客网站收集整理/","link":"","permalink":"/2018/09/06/技术博客网站收集整理/","excerpt":"对一些大牛的blog或者github的收集。","text":"对一些大牛的blog或者github的收集。 技术博客列表 coco大神的github 大神写webpack 比较不错的面试题收集 前端俱乐部 灰风GreyWind的github,有面试题整理 webpack4教程挺好 前端面试100问 玄魂工作室-nw.js教程 WebGL教程-郭隆邦_技术博客 一些算法的经典面试题 前端工匠 JavaScript 资源大全中文版 AlienZHOU","categories":[],"tags":[{"name":"大牛分享","slug":"大牛分享","permalink":"/tags/大牛分享/"}]},{"title":"jquery上传文件","slug":"jquery上传文件","date":"2018-09-03T05:26:56.000Z","updated":"2018-09-14T06:00:01.826Z","comments":true,"path":"2018/09/03/jquery上传文件/","link":"","permalink":"/2018/09/03/jquery上传文件/","excerpt":"之前在项目中使用jquery，Formdata实现文件上传","text":"之前在项目中使用jquery，Formdata实现文件上传 jquery上传文件现在的上传文件插件非常的多，比如在一个表单中，上传身份证照片，点击上传按钮，选好图片，上传好了，一般都提交到了一个图片服务器上，这是常规做法，但是有遇到过，有的后端同事要求我在点击form的提交按钮时，图片和输入框，下拉信息一并提交，当然，直接用form来做都不用改什么就可以，但是，如果需要更灵活的话，我选择了FormData对象配合jquery来做，具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;upload file&lt;/title&gt; &lt;script src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt;.upload_area &gt; div, .userType_area &gt; div , .sendType_area &gt; div &#123; border: 1px solid #DAD5D5; padding: 10px 15px;&#125;#myUploadBtn&#123; background-color:#1874D5; border: none; color: #ffffff; padding: 5px 12px;&#125;h3 &#123; margin: 5px 0;&#125;.fileName &#123; margin-left: 15px;&#125;.userType_area &#123;&#125; .userType_area ul , .sendType_area ul &#123; overflow: hidden;&#125;.userType_area ul li , .sendType_area ul li &#123; position: relative; float: left; padding: 2px 5px; background-color:#1874D5; color: #ffffff; color: #ffffff; margin: 0 10px; cursor: pointer;&#125;span.checkMark &#123; position: absolute; top: 0; right: 0; width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0,0,0,.5); color: #fffff; text-align: center;&#125;.text_area &#123;&#125;.text_area textarea &#123; width: 100%; height: 120px;&#125;.mes_box &#123; display: none; position: absolute; top: 20%; left: 50%; margin:0 0 0 -150px; width: 300px; height: 200px; background-color: gray; border-radius: 5px; text-align: center;&#125;.mes_box &gt; .cancel &#123; position: absolute; width: 30px; height: 30px; border-radius: 20px; text-align: center; line-height:23px; color: #fff; font-size: 25px; right: 5px; top: 3px; border: 1px solid #fff; cursor: pointer;&#125;.mes_box &gt; strong &#123; color: #ffffff; display: inline-block; margin: 70px 0; font-size: 16px;&#125;&lt;/style&gt;&lt;div class=\"mes_box\"&gt; &lt;span class=\"cancel\"&gt;x&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;input type=\"file\" id=\"choosefile\" style=\"display:none;\" /&gt;&lt;div class=\"upload_area\"&gt; &lt;h3&gt;上传文件&lt;/h3&gt; &lt;div&gt; &lt;button id=\"myUploadBtn\"&gt;请选择您要上传的文件&lt;/button&gt; &lt;span class=\"fileName\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"userType_area\"&gt; &lt;h3&gt;选择用户类型&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;余额不足&lt;/li&gt; &lt;li data-code=\"2\"&gt;宽带到期&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"sendType_area\"&gt; &lt;h3&gt;选择推送触点&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;辽宁联通为信号&lt;/li&gt; &lt;li data-code=\"2\"&gt;短信&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"text_area\"&gt; &lt;h3&gt;输入推送需求&lt;/h3&gt; &lt;div&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;button id=\"sendFile\" type=\"button\" class=\"btn btn-primary bsok\"&gt;提交&lt;/button&gt;&lt;script&gt;(function()&#123; var isok = true , isover = false; //选择文件点击事件 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;); //上传选择文件change事件 $('#choosefile').on('change',function()&#123; $('.fileName').text('上传的文件名：'+$(this)[0].files[0].name); &#125;); //被选中函数 function checkMark($el,isDan)&#123; var strNode = '&lt;span class=\"checkMark\"&gt;√&lt;/span&gt;' if(isDan)&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.siblings().data('checkMark', false).find('span').remove(); $el.data('checkMark', true).append(strNode); &#125; &#125;else&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.data('checkMark', true).append(strNode); &#125; &#125; &#125; //获取被选中的code function getCode($el)&#123; var arr = []; $el.find('li').each(function(index, el) &#123; if($(this).data('checkMark') == true)&#123; arr.push($(this).data('code')); &#125; &#125;); return arr; &#125; //选择用户类型添加事件 $('.userType_area li').on('click',function()&#123; checkMark($(this),true); &#125;); //推送触点添加事件 $('.sendType_area li').on('click',function()&#123; checkMark($(this),false); &#125;); //上传文件点击事件 $('#sendFile').on('click',function()&#123; var fd = new FormData(); var upload_file = $('#choosefile')[0].files[0]; var userType = getCode($('.userType_area')); var sendType = getCode($('.sendType_area')); var text = $('.text_area textarea').val(); if(upload_file)&#123; var houz = /\\.[^\\.]+$/.exec(upload_file.name); var size = upload_file.size; &#125; console.log(upload_file); if(!upload_file)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择一个要上传的文件'); isok = false; &#125;else if(userType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择用户类型'); isok = false; &#125;else if(sendType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择推送触点'); isok = false; &#125;else if(!text)&#123; $('.mes_box').show(); $('.mes_box strong').text('请输入推送需求'); isok = false; &#125;else if(houz[0] !== '.txt')&#123; $('.mes_box').show(); $('.mes_box strong').text('请上传以txt结尾的文件'); isok = false; &#125;else if(size &gt; 4194304)&#123; $('.mes_box').show(); $('.mes_box strong').text('您上传的文件过大，请上传小于4M的文件'); isok = false; &#125;; fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file); if(isok)&#123; $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false, contentType: false, data: fd, success:function(res)&#123; $(\".modal-content\").mask(\"hide\"); if(true)&#123; $('.mes_box').show(); $('.mes_box strong').text('数据提交成功'); isover = true; &#125;else&#123; $('.mes_box').show(); $('.mes_box strong').text('服务器问题，数据提交失败'); &#125; &#125;, error:function(err)&#123; $(\".modal-content\").mask(\"hide\"); $('.mes_box').show(); $('.mes_box strong').text('由于网络原因提交失败'); &#125; &#125;); $(\".modal-content\").mask(\"show\");//ajax提交数据出现loading蒙层 &#125; &#125;); //提示框关闭按钮点击事件 $('.mes_box .cancel').on('click',function()&#123; $(this).parent().hide(); isok = true; if(isover === true)&#123; $('#createModal').remove(); $('.modal-backdrop.fade.in').remove(); &#125; &#125;);&#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是整个页面的内容，其实重要的几个点在这里：12345678910111213141516171819202122232425 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;);上边这个函数就是把实际的input file 标签隐藏，用其他的按钮来触发弹出选择文件的窗口，注意，不能直接用file.click()这种形式，要 (function()&#123; return file.click(); &#125;)();这样做才可以调出选择文件的窗口。再有一点，利用了h5的 var fd = new FormData(); 类，把需要上传的文件起个key值，直接放到fd实例里， fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file);之后用ajax直接把fd对象上传就可以了，以jquery为例 $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false,//不对数据进行处理，保持2进制 contentType: false,//不对数据进行处理，保持2进制 data: fd &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"javascript提高性能","slug":"javascript提高性能","date":"2018-09-01T07:00:22.000Z","updated":"2018-09-14T06:00:39.290Z","comments":true,"path":"2018/09/01/javascript提高性能/","link":"","permalink":"/2018/09/01/javascript提高性能/","excerpt":"javascript提高性能的方式总结","text":"javascript提高性能的方式总结 javascript提高性能&emsp;&emsp;javascript如何提高性能，这个在面试中被问到的几率也是蛮高的，之前我也就是想到哪里说到哪里，面试官估计也都是菜鸟（我面的也都是小公司），也觉得我说的对，但是，有空冷静下来，觉得自己说的每次都不是很全面，所以，我想把平时能想到的记录下来，这样再去面试的时候，呵呵，一定把面试官说蒙。 4种内存泄漏&emsp;&emsp;提高JavaScript性能，首先就是避免4种内存泄漏,这里只是简单列出。 1.意外的全局变量JavaScript的目标是开发一种看起来像Java但足够自由的被初学者使用的语言。JavaScript自由的其中一种方式是它可以处理没有声明的变量：一个未声明的变量的引用在全局对象中创建了一个新变量。在浏览器的环境中，全局对象是window。也就是说：1234567function foo(arg) &#123; bar = \"this is a hidden global variable\";&#125;实际上是：function foo(arg) &#123; window.bar = \"this is an explicit global variable\";&#125; 如果bar是仅在foo函数作用域内承载引用，并且你忘记用var来声明的变量，一个意外的全局变量就被创建了。在这个例子中，泄漏一个单一字符串不会有太大害处，但这的确是不好的。另一种意外全局变量被创建的方式是通过this：123456function foo() &#123; this.variable = \"potential accidental global\";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这种错误发生，在你的Javascript文件最前面添加’use strict;’。这开启了解析JavaScript的阻止意外全局的更严格的模式。全局变量的一个注意事项：即使我们谈了不明的全局变量，仍然存在很多代码被显式的全局变量填充的情况。这是通过定义不可收集的情况（除非清零或重新赋值）。特别的，用来临时存储和处理大量信息的全局变量会引起关注。如果必须用全局变量来存储很多数据，在处理完之后，确保对其清零或重新赋值。 一个在与全局连接上增加内存消耗常见的原因是缓存)。 缓存存储重复被使用的数据。为此，为了有效，缓存必须有其大小的上限。飙出限制的缓存可能会因为内容不可被回收，导致高内存消耗。 2.被遗忘的计时器或回调在JavaScript中setInterval的使用相当常见。其他库提供观察者和其他工具以回调。这些库中大多数，在引用的实例变成不可访问之后，负责让回调的任何引用也不可访问。在setInterval的情况下，这样的代码很常见：12345678var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource));&#125;&#125;, 1000); 这个例子表明了跳动的计时器可能发生什么：计时器使得节点或数据的引用不再被需要了。代表node的对象将来可能被移除，使得整个块在间隔中的处理不必要。然而，处理函数，由于间隔仍然是活跃的，不能被回收（间隔需要被停掉才能回收）。如果间隔处理不能被回收，它的依赖也不能被回收。那意味着可能存储着大量数据的someResource，也不能被回收。观察者情况下，一旦不被需要（或相关的对象快要访问不到）就创建明确移除他们的函数很重要。在过去，这由于特定浏览器（IE6）不能很好的管理循环引用（下面有更多相关信息），曾经尤为重要。现如今，一旦观察对象变成不可访问的，即使收听者没有明确的被移除，多数浏览器可以并会回收观察者处理函数。然而，它保持了在对象被处理前明确的移除这些观察者的好实践。例如：1234567891011var element = document.getElementById('button');function onClick(event) &#123; element.innerHtml = 'text';&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don't// handle cycles well. 一条关于对象观察者及循环引用的笔记观察者和循环引用曾经是JavaScript开发者的祸患。这是由于IE垃圾回收的一个bug(或者设计决议)出现的情况。IE的老版本不能检测到DOM节点和JavaScript代码间的循环引用。 这是一个通常为观察到的保留引用（如同上面的例子）的观察者的典型。 也就是说，每次在IE中对一个节点添加观察者的时候，会导致泄漏。这是开发者在节点或空引用之前开始明确的移除处理函数的原因。 现在，现代浏览器（包括IE和MS Edge）使用可以剪裁这些循环和正确处理的现代垃圾回收算法。换言之，在使一个节点不可访问前，调用removeEventLister不是严格意义上必须的。像Jquery一样的框架和库做了在处置一个节点前（当为其使用特定的API的时候）移除监听者的工作。这被在库内部处理，即使在像老版本IE一样有问题的浏览器里面跑，也会确保没有泄漏产生。 3. 超出DOM引用有时存储DOM节点到数据结构中可能有用。假设你想要迅速的更新一个表格几行内容。存储每个DOM行节点的引用到一个字典或数组会起作用。当这发生是，两个对于同个DOM元素的引用被留存：一个在DOM树中，另外一个在字典中。如果在将来的某些点你决定要移除这些行，需要让两个引用都不可用。123456789101112131415161718var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text')&#125;;function doStuff() &#123;image.src = 'http://some.url/image';button.click();console.log(text.innerHTML);// Much more logic&#125;function removeButton() &#123;// The button is a direct child of body.document.body.removeChild(document.getElementById('button'));// At this point, we still have a reference to #button in the global// elements dictionary. In other words, the button element is still in// memory and cannot be collected by the GC.&#125; 对此的额外考虑，必须处理DOM树内的内部节点或叶子节点。假设你在JavaScript代码中保留了一个对于特定的表格内节点（一个td标签）的引用。在将来的某个点决定从DOM中移除这个表格，但是保留对于那个节点的引用。直观的，会假设GC会回收除那个节点之外的每个节点。在实践中，这不会发生的：这个单节点是那个表格的子节点，子节点保留对父节点引用。换句话说，来自JavaScript代码的表格元素的引用会引起在内存里存整个表格。当保留DOM元素的引用的时候，仔细考虑下。 4.闭包一个JavaScript开发的关键点是闭包：从父级作用域捕获变量的匿名函数。很多开发者发现，由于JavaScript runtime的实现细节，有以一种微妙的方式泄漏的可能，这种特殊的情况：123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码片段做了一件事：每次replaceThing被调用的时候，theThing获取到一个包括一个大数组和新闭包(somMethod)的新对象。同时，变量unused保留了一个有originalThing（theThing从之前的对replaceThing的调用）引用的闭包。已经有点疑惑了，哈？重要的是一旦一个作用域被在同个父作用域下的闭包创建，那个作用域是共享的。这种情况下，为闭包somMethod创建的作用域被unused共享了。unused有一个对originalThing的引用。即使unused从来没被用过，someMethod可以通过theTing被使用。由于someMethod和unused共享了闭包作用域，即使unused从来没被用过，它对originalThing的引用迫使它停留在活跃状态（不能回收）。当这个代码片段重复运行的时候，可以看到内存使用稳步的增长。GC运行的时候，这并不会减轻。本质上，一组关联的闭包被创建（同unused变量在表单中的根节点一起），这些闭包作用域中每个带了大数组一个非直接的引用，导致了大型的泄漏。 垃圾回收的直观行为即使垃圾回收很方便，他们有自己的一套权衡方法。其中一个权衡是nondeterminism。也就是说，GC是不可预期的。通常不能确定什么时候回收器被执行。这意味着在一些情况下，需要比程序正在使用的更多的内存。其他情况下，短的暂停在特别敏感的应用中很明显。即使不确定性意味着不能确定回收什么时候执行，大多数GC实现共享在分配期间，普通的回收通行证模式。如果没有执行分配，大多数CG停留在休息状态。考虑下面的方案：1.执行一组大型的分配。2.多数元素（或所有）被标记为不可访问（假设我们置空了一个指向不再需要的缓存的引用）。3.没有进一步的分配执行了。在这个方案中，大多GC不会运行任何进一步的回收通行了。换言之，即使有可用于回收的，不可访问的引用，回收器不会要求他了。这不是严格的泄漏，但是也会导致比平常更高的内存使用率。Google在 JavaScript Memory Profiling docs, example #2.文章中，提供了一个优秀的例子。 编写javascript代码时的优化1.从JavaScript的作用域谈起当JavaScript代码执行时，JavaScript引擎会创建一个执行环境，又叫执行上下文。执行环境定义了变量或函数有权访问的其他数据，决定了它们的行为，每个执行环境都有一个与它关联的变量对象，环境中定义的所有函数、变量都保存在这个对象中。在页面加载的时候，JavaScript引擎会创建一个全局的执行环境，所有全局变量和函数都是作为window对象（浏览器中）的属性和方法创建的。在此之后，每执行一个函数，JavaScript引擎都会创建一个对应的执行环境，并将该环境放入环境栈中，所以当前正在执行的函数的执行环境是在环境栈的最顶部的，当函数执行完毕之后，其执行环境会弹出栈，并被销毁，保存在其中的变量和函数定义也会被销毁。当代码在一个执行环境中执行时，JavaScript引擎会创建变量对象的一个作用域链，它可以保证对执行环境有权访问的变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。全局环境的作用域链中只有一个变量对象，它定义了所有可用的全局变量和函数。当函数被创建时，JavaScript引擎会把创建时执行环境的作用域链赋给函数的内部属性[[scope]]；当函数被执行时，JavaScript引擎会创建一个活动对象，最开始时这个活动对象只有一个变量，即arguments对象。该活动对象会出现在执行环境作用域链的顶端，接下来是函数[[scope]]属性中的对象。当需要查找某个变量或函数时，JavaScript引擎会通过执行环境的作用域链来查找变量和函数，从作用域链的顶端开始，如果没找到，则向下寻找直至找到为止。若一直到全局作用域都没有找到,则该变量或函数为undefined。举个栗子：1234function add(a,b) &#123; return a + b;&#125;var result = add(2,3); 代码执行时，add函数有一个仅包含全局变量对象的[[scope]]属性，add函数执行时，JavaScript引擎创建新的执行环境以及一个包含this、arguments、a、b的活动对象，并将其添加到作用域链中。如下图所示： 2.使用局部变量了解了作用域链的概念，我们应该知道在查找变量会从作用域链的顶端开始一层一层的向下找。显然，查找的层数越多，花费的时间越多。所以为了提高查找的速度，我们应该尽量使用 局部变量（到目前为止，局部变量是JavaScript中读写最快的标识符）。例如：1234567function createEle() &#123; document.createElement(\"div\");&#125;function createEle() &#123; var doc = document; doc.createElement(\"div\");&#125; 当document使用次数比较少时，可能无所谓，可是如果在一个函数的循环中大量使用document，我们可以提前将document变成局部变量。来看看jquery怎么写的：12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery;&#125;)(window); 这样写的优势：1、window和undefined都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。（原来的window处于作用域链的最顶端，查找速度慢）2、在jquery压缩版本jquery.min.js中可以将局部变量window替换成单个字母，减小文件大小，提高加载速度3、undefined也是JavaScript中的全局属性。将undefined作为参数传递给闭包，因为没给它传递值，它的值就是undefined，这样闭包内部在使用它的时候就可以把它当做局部变量使用，从而提高查找速度。undefined并不是JavaScript的保留字或者关键字。4、undefined在某些低版本的浏览器（例如IE8、IE7）中值是可以被修改的（在ECMAScript3中，undefined是可读/写的变量，可以给它赋任意值，这个错误在ECMAScript5中做了修正），将undefined作为参数并且不给它传值可以防止因undefined的值被修改而产生的错误。 3.避免增长作用域链在JavaScript中，有两种语句可以临时增加作用域链：with、try-catchwith可以使对象的属性可以像全局变量来使用，它实际上是将一个新的变量对象添加到执行环境作用域的顶部，这个变量对象包含了指定对象的所有属性，因此可以直接访问。这样看似很方便，但是增长了作用域链，原来函数中的局部变量不在处于作用域链的顶端，因此在访问这些变量的时候要查找到第二层才能找到它。当with语句块之行结束后，作用域链将回到原来的状态。鉴于with的这个缺点，所以不推荐使用。try-catch中的catch从句和with类似，也是在作用域链的顶端增加了一个对象，该对象包含了由catch指定命名的异常对象。但是因为catch语句只有在放生错误的时候才执行，因此影响比较少。 4.字符串链接优化由于字符串是不可变的，所以在进行字符串连接时，需要创建临时字符串。频繁创建、销毁临时字符串会导致性能低下。当然，这个问题在新版本浏览器包括IE8+中都得到了优化，所以不需要担心在低版本浏览器（IE6、IE7）中，我们可以种数组的join方法来代替。123456var temp = [];var i = 0;temp[i++] = \"Hello\";temp[i++] = \" \";temp[i++] =\"everyone\";var outcome = temp.join(\"\"); 5.条件判断当出现条件判断时，我们采用什么样的结构才能使性能最优？1234567891011if(val == 0) &#123; return v0;&#125;else if(val == 1) &#123; return v1;&#125;else if(val == 2) &#123; return v2;&#125;else if(val == 3) &#123; return v3;&#125;else if(val == 4) &#123; return v4;&#125; 当条件分支比较多时，我们可以斟酌哪种条件出现的概率比较大，并将对应的语句放在最上面，这样可以减少判断次数。使用switch语句，新版的浏览器基本上都对switch做了优化，这样层数比较深时，性能比if会更好使用数组：12var v = [v0,v1,v2,v3,v4];return v[valeue]; 要求：对应的结果是单一值，而不是一系列操作另外，其他方面的优化，譬如1234567891011if(condition1) &#123; return v1;&#125;else &#123; return v2&#125;// 改成if(condition1) &#123; return v1;&#125;return v2; 6.快速循环1、循环总次数使用局部变量12345678for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125; 这样就避免了每次循环的属性查找。这点尤其重要，因为在进行dom操作时，很多人会这样写：1234var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125; 查找DOM元素的属性是相对耗时的，所以应该避免这种写法。2、如果可以，递减代替递增1234567891011121314151617for(var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成for(var i = arr.length - 1;i--;) &#123;&#125;var i = 0;while(i &lt; arr.length) &#123; i++;&#125;// 改成var i = arr.length - 1;while(i--) &#123;&#125; i=0的时候会直接跳出，循环次数比较多时还是很有用的。 7.展开循环1234var i = arr.length - 1;while(i--) &#123; dosomething(arr[i]);&#125; 遇到这样的情况时，执行一次循环的时候我们可以选择不止执行一次函数。12345678910111213141516171819var interations = Math.floor(arr.length / 8);var left = arr.length % 8;var i = 0;if(left) &#123; do &#123; dosomething(arr[i++]); &#125; while(--left);&#125;do &#123; dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]);&#125; while(--interations); 当遇到大数组，减少循环的开销，性能不就提上去了嘛。（至于为什么是每次循环，调8次函数，大牛测出来的，这样达到最佳） 8.高效存取数据JavaScript中4种地方可以存取数据：字面量值；变量；数组元素；对象属性字面量值和变量中存取数据是最快的，从数组元素和对象属性中存取数据相对较慢，并且随着深度增加，存取速度会越来越慢，譬如obj.item.value就比obj.item慢。某些情况下我们可以将对象、数组属性存成局部变量来提高速度，譬如：12345678910111213141516171819for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125;var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125;// 改成// var divList = document.getElementsByTagName(\"div\");for( var i = 0,len = divList.length;i &lt; len;i++) &#123;&#125; 9.事件委托事件委托就是利用冒泡的原理，将原本应该添加在某些元素身上的监听事件，添加到其父元素身上，来达到提高性能的效果。举个栗子：1234567891011121314151617181920212223242526&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); for(var i = 0,len = liList.length;i &lt; len;i++) &#123; liList[i].onclick = function() &#123; alert(this.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样我们就为每个li添加了监听事件了。显然，我们通过循环为每个li添加监听事件是不优化的。这样不仅浪费了内存，在新的li加入的时候我们还要重新为它添加监听事件。我们可以这样写：1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); ul.onclick = function(e) &#123; var e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName.toLowerCase() == \"li\") &#123; alert(target.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样写的好处：只添加一个监听事件，节省了内存；新加入li的时候我们也不用为它单独添加监听事件；在页面中添加事件处理程序所需的时候更少，因为我们只需要为一个DOM元素添加事件处理程序。 使用typescript使用typescript来提高性能我实在一本关于nodejs的书里看到的，主要还是用在chrome的V8引擎上，这本书里写的比如1234567// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; console.log(add(i + i*3));&#125; 书里说，如果V8引擎发现一个函数使用频率很高，而且参数传入的都是同一种类型的，好像是在内存寻址的时候书都很快，因为引擎认为传入的参数就是int型。再来看一个例子1234567891011// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; if(i % 8 === 0) &#123; console.log(add(i + i*0.3)); // 这里出现了浮点数 &#125;else &#123; console.log(add(i + i*3)); // 这里是整数 &#125;&#125; 上边的代码可以看到，在使用整形参数的时候突然传入浮点数，V8引擎寻址机制突然变化，丢弃之前的函数，使用新的来计算，性能下降。所以，如果使用typescript，类型固定，这样性能就会提高哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"vue双向绑定的简单实现","slug":"vue双向绑定的简单实现","date":"2018-08-30T03:13:39.000Z","updated":"2018-09-14T05:58:16.386Z","comments":true,"path":"2018/08/30/vue双向绑定的简单实现/","link":"","permalink":"/2018/08/30/vue双向绑定的简单实现/","excerpt":"参考网上vue实现教程简单整理","text":"参考网上vue实现教程简单整理 vue双向绑定的简单实现&emsp;&emsp;首先，这篇文章并非我的原创，在网上看到了很多写vue原理的文章，感觉这篇写的层次结构清晰，容易理解，所以留作收藏。废话不多说，开始。 1.原理&emsp;&emsp;Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过 Object对象的defineProperty属性，重写data的set和get函数来实现的,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。添加网上的一张图 2.实现页面结构很简单，如下：1234567&lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button ype=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt;&lt;/div&gt; 包含：1.一个input，使用v-model指令2.一个button，使用v-click指令3.一个h3，使用v-bind指令。我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释：1234567891011var app = new myVue(&#123; el:'#app', data:&#123; number:0 &#125;, methods:&#123; increment:function()&#123; this.number++; &#125;, &#125; &#125;) 首先我们需要定义一个myVue构造函数：123function myVue(options)&#123;&#125; 为了初始化这个构造函数，给它添加一 个_init属性123456789function myVue(options) &#123; this._init(options);&#125;myVue.prototype._init = function (options) &#123; this.$options = options; // options 为上面使用时传入的结构体，包括el,data,methods this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素 this.$data = options.data; // this.$data = &#123;number: 0&#125; this.$methods = options.methods; // this.$methods = &#123;increment: function()&#123;&#125;&#125; &#125; 接下来实现_obverse函数，对data进行处理，重写data的set和get函数并改造_init函数12345678910111213141516171819202122232425262728293031323334myVue.prototype._obverse = function (obj) &#123; // obj = &#123;number: 0&#125; var value; for (key in obj) &#123; //遍历obj对象 if (obj.hasOwnProperty(key)) &#123; value = obj[key]; if (typeof value === 'object') &#123; //如果值还是对象，则遍历处理 this._obverse(value); &#125; Object.defineProperty(this.$data, key, &#123; //关键 enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; &#125; &#125; &#125;) &#125; &#125; &#125;myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._obverse(this.$data); &#125; 接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新12345678910111213function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。 &#125; 更新_init函数以及_obverse函数1234567891011121314151617181920212223242526272829myVue.prototype._init = function (options) &#123; //... this._binding = &#123;&#125;; //_binding保存着model与view的映射关系，也就是我们前面定义的Watcher的实例。当model改变时，我们会触发其中的指令类更新，保证view也能实时更新 //... &#125; myVue.prototype._obverse = function (obj) &#123; //... if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; // 按照前面的数据，_binding = &#123;number: _directives: []&#125; _directives: [] &#125;; //... var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; //... set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; // 当number改变时，触发_binding[number]._directives 中的绑定的Watcher类的更新 item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; 那么如何将view与model进行绑定呢？接下来我们定义一个_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 myVue.prototype._init = function (options) &#123; //... this._complie(this.$el); &#125; myVue.prototype._complie = function (root) &#123; root 为 id为app的Element元素，也就是我们的根元素 var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; // 对所有元素进行遍历，并进行处理 this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++ node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); //bind是使data的作用域与method函数的作用域保持一致 &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件 node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); //_this._binding['number']._directives = [一个Watcher实例] // 其中Watcher.prototype.update = function () &#123; // node['vaule'] = _this.$data['number']; 这就将node的值保持与number一致 // &#125; _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定 &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可 var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; 至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图 附上全部代码，不到150行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 &lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;myVue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #app &#123; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button type=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function myVue(options) &#123; this._init(options); &#125; myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._binding = &#123;&#125;; this._obverse(this.$data); this._complie(this.$el); &#125; myVue.prototype._obverse = function (obj) &#123; var value; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; _directives: [] &#125;; value = obj[key]; if (typeof value === 'object') &#123; this._obverse(value); &#125; var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; myVue.prototype._complie = function (root) &#123; var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; &#125; window.onload = function() &#123; var app = new myVue(&#123; el:'#app', data: &#123; number: 0 &#125;, methods: &#123; increment: function() &#123; this.number ++; &#125;, &#125; &#125;) &#125;&lt;/script&gt; 以上就是所有内容，这个代码不是我创造的，我只是代码的搬运工。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"webSocket","slug":"webSocket项目中的使用","date":"2018-08-29T01:23:54.000Z","updated":"2018-09-14T05:52:25.058Z","comments":true,"path":"2018/08/29/webSocket项目中的使用/","link":"","permalink":"/2018/08/29/webSocket项目中的使用/","excerpt":"在项目中使用websocket的小心得","text":"在项目中使用websocket的小心得 webSocket在项目中的使用&emsp;&emsp;webSocket,这个技术相信大家都已经很熟悉了，就是前端浏览器与后端服务器一直保持连通状态，我们在项目中，经常会遇到这样的需求，一个数据图表展示页面，产品的需求是每隔5秒钟页面刷新一次，传统的做法是请求轮询机制，也就是setInterval这个定时器，一遍又一遍的请求后端接口，这个方法简单（特别是后端简单），但是如果前端页面有大量的这种需求，会影响性能，所以，webSocket是现在最好的选择。&emsp;&emsp;其实webSocket现在还是比较重要的，一般在面试的时候，被问到的几率还是很大的。我之前在项目中没有用到过，但是自己写过webSocket的demo，浏览器配合nodejs来写，也是参考了网上的代码，还是很简单的webSocket详细代码看这里。在面试时被问到的时候，也是实话实说，有可能面试官也是小白，基本上都没往下问，但是，确实是这么简单吗？答案显然不是，待我慢慢道来。&emsp;&emsp;首先，我在最近两个项目中，都用到了webSocket，所以还是有发言权的。如果，产品提出了webSocket的需求，对于我们前端来说，并不是直接写个原生的webSocket就可以，而是需要看后端小伙伴们的脸色，什么意思？就是说得看后端用的是什么webSocket库，我接触的有两种，第一个是stomp,说是webSocket的子协议，后端选了这个库之后，我们前端也得相应的选择与后端相配合的前端库，一般情况下，官网很明确的给出了后端和前端相配合写法，当然，写法也是很简单，跟原生差不多。第二个是，sockjs这个库，当然，也是后端小伙伴选好了之后，告诉我，我相应的在前端也用的跟后端一样库。&emsp;&emsp;最后总结一下，webSocket技术并不难（对于我们前端来说，当然，nodejs的后端也很简单，java就不知道了，每次调起来看他们都是一脸懵逼的样子），无论是面试还是在实际工作中，问道这个问题时，我们首先想到的应该是，后端选择的是什么库，我们前端应该跟后端小伙伴保持一致，可别需求以来，觉得简单直接开些，等联调的时候，我靠，为什么连不上呢？你们前后端不在一个频道上，怎么连接啊。所以，我们要说，我做过的项目是这样这样滴，不知道这次我们后端小伙伴用到的webSocket库是什么呢？","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"webSocket","slug":"webSocket","permalink":"/tags/webSocket/"}]},{"title":"nodejs代理服务器","slug":"nodejs代理服务器","date":"2018-08-27T06:51:52.000Z","updated":"2018-09-14T05:59:05.665Z","comments":true,"path":"2018/08/27/nodejs代理服务器/","link":"","permalink":"/2018/08/27/nodejs代理服务器/","excerpt":"nodejs代理服务器简单实现","text":"nodejs代理服务器简单实现 nodejs代理服务 最近在与后台同事联调的时候，出现了点故障，跨域，这个经常碰到很好解决的问题，但是一般情况下需要前后端一起配合来解决，比如jsonp，或者h5后端在返回头加上允许跨域的头设置，但是如果后台同事是个小白，问啥啥不明白，也是没招了。我之前还用过将chrome的跨域设置给禁掉的方法，但是这次不知道为啥，也不好使了。最后，只能是用代理这种方式，我现在用的是vue框架，其实vue的脚手架已经集成了跨域功能，只需要配置一下就可以，但是，现在框架这么多，前一阵子还react，angular的项目，最近有换成vue，配置的话，肯定要去查看api，记不住啊，而且，版本不同，设置方法也不同，不如自己写一个，这样多简单，需要的时候把代理服务开启就搞定了。于是乎，自己写一个，当然，稍微想一下就知道，代理的原理，就是利用nodejs在中间做一次请求以及数据返回，不过自己写还得思考，上网找一下多简单，baidu一搜索，哇靠，第一个映入眼帘的就是nodejs代理服务8行代码，嗯，就是这么简单，废话不多说，上代码,当然，自己还得加工一下哦。123456789101112131415161718192021var express = require('express');var request = require('request');var app = express();const proxyUrl = process.argv[2] || 'http://127.0.0.1:8888'; // 如果有传入的代理url，使用它app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") res.send(200); // 让options请求快速返回 else next();&#125;);app.use('/', function(req, res) &#123; var url = proxyUrl + req.url; req.pipe(request(url)).pipe(res);&#125;);app.listen(process.env.PORT || 3000, ()=&gt;&#123; console.log('代理服务器，在3000端口已经开启');&#125;); 再把package.json文件内容贴出来12345678910111213141516&#123; &quot;name&quot;: &quot;node-proxy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;node server http://127.0.0.1:9000&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.3&quot;, &quot;request&quot;: &quot;^2.88.0&quot; &#125;&#125; 源码在这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端代理服务","slug":"后端代理服务","permalink":"/tags/后端代理服务/"}]}]}