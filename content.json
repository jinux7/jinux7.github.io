{"meta":{"title":"jinux","subtitle":null,"description":"前端 学习 javascript","author":"jinux","url":""},"pages":[{"title":"categories","date":"2018-08-20T08:19:43.000Z","updated":"2018-10-12T02:42:30.655Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"javascriptnodejscss计算机原理少儿编程"},{"title":"tags-test","date":"2018-08-20T08:18:58.000Z","updated":"2018-08-27T06:24:35.212Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"tag-jquery"}],"posts":[{"title":"HTML5中Video标签无法播放mp4的解决办法","slug":"HTML5中Video标签无法播放mp4的解决办法","date":"2019-03-21T01:13:22.000Z","updated":"2019-03-21T01:49:40.609Z","comments":true,"path":"2019/03/21/HTML5中Video标签无法播放mp4的解决办法/","link":"","permalink":"/2019/03/21/HTML5中Video标签无法播放mp4的解决办法/","excerpt":"解决其它格式视频转mp4格式文件，video标签无法播放问题","text":"解决其它格式视频转mp4格式文件，video标签无法播放问题 HTML5中Video标签无法播放mp4的解决办法首先，浏览器使用环境chrome在使用video标签播放视频的时候，我一般都选择mp4格式的文件，在网上下载的demo视频或者是手机拍摄的mp4文件都可以播放，但是，我用格式工厂把avi格式的文件转换成mp4文件就无法播放，为什么呢？带着疑问，上网找答案，找到了原因，如下：使用格式工厂的mp4转换功能转出来的mp4文件并不能使用，于是把能播放的视频文件和不能播放的视频文件的编码格式对比了一下可以播放的：不可以播放的：所以，在格式工厂转换的时候需要转成AVC编码格式的mp4文件好了，按照这种方式就可以正常播放了。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"移动端兼容性","slug":"移动端兼容性","date":"2019-03-05T01:43:57.000Z","updated":"2019-03-07T06:05:28.759Z","comments":true,"path":"2019/03/05/移动端兼容性/","link":"","permalink":"/2019/03/05/移动端兼容性/","excerpt":"移动端有关html标签节点的兼容性问题","text":"移动端有关html标签节点的兼容性问题 移动端兼容性meta标签1234567891011121314151617// viewport就啥也不说了，必须得加&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;// 启动或禁用自动识别页面中的电话号码&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;// 启动或禁用自动识别邮箱地址&lt;meta name=\"format-detection\" content=\"email=no\" /&gt; // 设置 Web 应用是否以全屏模式运行。&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;// ios 的 safari 顶端状态条的样式，可选的参数有：default、black、black-translucent&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;// winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; body,img等标签123456789// 禁止 ios 长按时不触发系统的菜单，禁止 ios&amp;android 长按时下载图片.css &#123; -webkit-touch-callout: none&#125;// 禁止ios和android用户选中文字.css &#123; -webkit-user-select:none&#125; 图片不清晰12345678910111213// 比如，iphone6，设备款375，物理像素750，正常一张占1/3屏幕的图片，125px，如果准备一张125的// 肯定会模糊，必须准备250px的。如果像iphone6 plus，像素比3， 占1/3的图片138px，实际需要414px。// 解决方案：@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .css &#123; background-image: url('2x.png'); &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .css &#123; background-image: url('3x.png'); &#125;&#125; 表单的标签123456789101112131415161718192021222324252627282930313233343536373839404142// input 输入框不可编辑&lt;input type=\"text\" name=\"name\" value=\"xxx\" disabled=\"true\"/&gt;&lt;input type=\"text\" name=\"name\" value=\"xxx\" readonly=\"true\"/&gt;/* disabled 文本框变灰，通过request.getParameter(\"name\")得不到文本框中的内容readonly 只是使文本框不能输入，样式没有变化，通过request.getParameter(\"name\")可以得到内容 */// ios 输入的时候英文首字母的默认大写&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt;// android 上去掉语音输入按钮input::-webkit-input-speech-button &#123; display: none&#125;// ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only;&#125; /* -webkit-user-modify 这个属性使用需谨慎，副作用就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类，不使用a或者input标签，直接用div标签 */// 表单元素的默认外观重置 -webkit-appearance:none;// 修改表单输入框 placeholder 的颜色值 input::-webkit-input-placeholder&#123;color:#ccc;&#125; input:focus::-webkit-input-placeholder&#123;color:#eee;&#125; // 注意 placeholder, ios 可以换行，android 不可以// Input 的placeholder会出现文本位置偏上的情况input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal// 禁用 select 默认下拉箭头select::-ms-expand &#123;display: none;&#125; // 禁用 radio 和 checkbox 默认样式input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display: none; &#125; a标签12部分安卓手机 a 标签用作按钮的时候，页面显示空白解决办法：用 button 标签替换 a 标签 button12345678910// 去除button在ios上的默认样式.css &#123; -webkit-appearance: none; border-radius: 0 &#125;// 不想让按钮touch时有蓝色的边框 .css &#123; -webkit-tap-highlight-color:rgba(0,0,0,0);&#125; audio和video12345678910111213// 在ios和andriod中,audio元素和video元素在无法自动播放// 应对方案：触屏即播$('html').one('touchstart',function()&#123; audio.play()&#125;)// ios 视频默认全屏播放，如何阻止全屏播放－ webkit-playsinline&lt;video id=\"video\" src=\"\" webkit-playsinline poster=\"\" &gt;&lt;/video&gt;// 视频，音频获取播放结束后的回调函数－ended$('#video').on('ended',function()&#123; alert(0);&#125;); click点击事件300毫秒延迟1234// 300毫秒延迟解决方案1.fastclick可以解决在手机上点击事件的300ms延迟2.zepto的touch模块，tap事件也是为了解决在click的延迟问题3.触摸事件的响应顺序为 touchstart --&gt; touchmove --&gt; touchend --&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题 ios(label,span)监听click事件,不触发1234// 所监听元素加上.css &#123; cursor:pointer&#125; css部分@-webkit-keyframes 注意12以0%开始100%结束，0%的百分号不能去掉after和before伪类无法使用动画 border-radius 注意123不支持%单位三星 Galaxy S4中自带浏览器不支持 border-radius 缩写同时写入 border-radius 和背景色的时候，背景色会溢出到圆角以外部分 解决 transition 闪屏123456.css&#123; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; &#125; 阻止用户调整微信浏览器字体大小1234// ios 管事，android 暂无解决方案body&#123; -webkit-text-size-adjust: 100%!important;&#125; 屏幕旋转的事件和样式12345678910111213141516171819202122232425// 1. 事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；// 代码判断window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125; &#125;// 2. 样式/*竖屏时使用的样式*/ @media all and (orientation:portrait) &#123; .css&#123;&#125; &#125;/*横屏时使用的样式*/ @media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; fixed元素无法点击1234567场景：父元素设置position: fixed;子元素设置position: absolute;此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。测试平台： 小米1S，Android4.0的Chrome18解决办法： 把父元素和子元素的overflow: hidden去掉。 overflow1234body如果设置height:100%;overflow:hidden是依然可以滑动的，如果需禁止，要再加一层div设置 height:100%加overflow：hidden（html,body加height:100%） ，这样元素超出body的高度也不能滑动了。或者同时给html，body加height:100%;overflow:hidden ios阻止旋转屏幕时自动调整字体大小123html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust:none;&#125; 通过transform进行skew变形，rotate旋转会造成出现锯齿现象123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0);transform: rotate(-4deg) skew(10deg) translateZ(0);outline: 1px solid rgba(255,255,255,0) iOS6下伪类:hover12345除了&lt;a&gt;之外的元素无效；在Android下则有效。类似div#topFloatBar_l:hover #topFloatBar_menu &#123; display:block; &#125;这样的导航显示在iOS6点击没有点击效果，只能通过增加点击侦听器给元素增减class来控制子元素。 点击按钮时背景变黑色的解决12345678910// 点击按钮时背景变黑色的解决-webkit-tap-highlight-color: transparent;// 当我们去掉默认的大黑块儿后，要添加自己想要的点击时按住按钮的效果，用以下代码：span:active&#123; box-shadow: inset 0 5px 10px #B41313,inset 0 -5px 10px #B41313;&#125;// 添加完上述代码后，在安卓上，都可以看到想要的效果，但是iphone上依旧不行，// :active 需要一个触发事件才可以，于是乎，用以下代码：document.body.addEventListener('touchstart', function () &#123;&#125;); retina屏下border的1px会变粗123456789101112131415161718192021222324252627282930313233343536373839404142434445// 因为像素比，比如，iphone6的像素比是2，window.devicePixelRatio可以查看，// iphone6的设备宽是375,而物理像素是750，在css中的1px，实际控制的是2px的像素，// 所以看起来会变粗了// 解决一：IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125;// 解决二：background渐变// 背景渐变, 渐变在透明色和边框色中间分割, frozenUI用的就是这种方法, 借用它的上边框写法:@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .ui-border-t &#123; background-position: left top; background-image: -webkit-gradient(linear,left bottom,left top,color-stop(0.5,transparent),color-stop(0.5,#e0e0e0),to(#e0e0e0)); &#125;&#125;// 解决三：// :before, :after与transform.radius-border&#123; position: relative;&#125;@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .radius-border:before&#123; content: \"\"; pointer-events: none; /* 防止点击触发 */ box-sizing: border-box; position: absolute; width: 200%; height: 200%; left: 0; top: 0; border-radius: 8px; border:1px solid #999; -webkit-transform(scale(0.5)); -webkit-transform-origin: 0 0; transform(scale(0.5)); transform-origin: 0 0; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"/tags/兼容性/"}]},{"title":"vue自定义指令之输入框限制字数","slug":"vue自定义指令之输入框限制字数","date":"2019-03-01T06:36:24.000Z","updated":"2019-03-04T08:15:45.039Z","comments":true,"path":"2019/03/01/vue自定义指令之输入框限制字数/","link":"","permalink":"/2019/03/01/vue自定义指令之输入框限制字数/","excerpt":"input输入框限制字数的指令制作","text":"input输入框限制字数的指令制作 vue自定义指令之输入框限制字数vue自定义指令没啥说的，说明见官网,具体代码见下面:12345678910111213141516171819Vue.directive('inputvalidatecounter', &#123; inserted: function (el, binding) &#123; var nSpan = document.createElement('span'), nInput = el.querySelector('input'), count = +binding.expression || 50; el.appendChild(nSpan); nSpan.innerHTML = '还可以填写'+count+'字'; nInput.addEventListener('input', function(ev) &#123; var num = count - this.value.length; if(num&lt;=0) &#123; setTimeout(() =&gt; &#123; var substr = this.value.substring(0,count-1); this.value = substr; &#125;, 10); &#125; nSpan.innerHTML = '还可以填写'+(num&lt;0?0:num)+'字'; &#125;, false); &#125;&#125;); 需要注意的地方： 这个指令只适用于iview的Input组件，看里边操作dom元素就可以看出来，想改成其它的也是简单。 在更改input的value的时候，最开始改不过来，后来我做了下延迟才解决这个问题，我想应该是在直接给input的value赋值后由于vue还在做监控，所以又给改回去了，所以来个延迟，在它监控触发结束后再改正。2019年3月4日更改123456789101112131415161718192021222324252627Vue.directive('inputvalidatecounter', &#123; inserted: function (el, binding, vnode) &#123; var nSpan = document.createElement('span'), nInput = el.querySelector('input') || el.querySelector('textarea'), count = +binding.expression || 50; el.appendChild(nSpan); nSpan.innerHTML = '还可以填写'+count+'字'; nInput.addEventListener('input', function(ev) &#123; var num = count - this.value.length; if(num&lt;=0) &#123; setTimeout(() =&gt; &#123; var substr = this.value.substring(0,count); this.value = substr; // 新添加开始 var keyArr = vnode.data.model.expression.split('.'); var evalStr = 'vnode.context._data'; keyArr.forEach((item, index)=&gt; &#123; evalStr += '[\"'+item+'\"]'; &#125;); eval(evalStr+'=\"'+this.value+'\"') // 新添加结束 &#125;, 10); &#125; nSpan.innerHTML = '还可以填写'+(num&lt;0?0:num)+'字'; &#125;, false); &#125;&#125;); 新添加的内容只有几行，其实是为了修改第一版的bug，当在input里输入内容的时候，超过一定字数后，进入延迟函数，这里把input的value值更改了，但是并没有更改这个指令所在组件里v-model的值，所以，这里需要修正。1234567891011// vnode是这个指令所在的组建的虚拟dom// vnode.data.model.expression 这就可以直接找到v-model里的变量名var keyArr = vnode.data.model.expression.split('.');// vnode知道了，vnode.context很显然就是组件所在的父级组件，可以通过 _data 这个数据去改变v-model里变量的值。var evalStr = 'vnode.context._data';keyArr.forEach((item, index)=&gt; &#123; evalStr += '[\"'+item+'\"]';&#125;);// 经过上边的循环是因为这种情况, v-model=\"formitem.name\"，像这种的值，而不是v-model=\"name\"这种。// 最后需要eval来执行这些字符串组成的代码。eval(evalStr+'=\"'+this.value+'\"')","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"js图片下载之后端部分","slug":"js图片下载之后端部分","date":"2019-02-27T05:31:24.000Z","updated":"2019-02-27T06:05:37.582Z","comments":true,"path":"2019/02/27/js图片下载之后端部分/","link":"","permalink":"/2019/02/27/js图片下载之后端部分/","excerpt":"nodejs服务返回图片二进制数据","text":"nodejs服务返回图片二进制数据 js图片下载之后端部分本站《js图片下载之前端部分》,写了如何利用js来下载图片，第二种方式需要后端返回图片的二进制数据，这篇文章我来写一下如何使用nodejs向前端返图片的二进制数据，我总结了三种方法。 方法一12345app.post('/downimg', function (req, res, next) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.createReadStream('./img/1.jpg') .pipe(res);&#125;); 这种方法利用了stream和pipe，一行代码就解决了，利用fs去读取图片的流只有，用pipe方法把流转给res，res自动就把数据返回给前端。 方法二1234567891011121314151617app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); var data = ''; var readerStream = fs.createReadStream(process.cwd() + '/img/1.jpg'); // 设置编码为 binary 必须 readerStream.setEncoding('binary'); readerStream.on('data', function(chunk) &#123; data += chunk; &#125;); readerStream.on('end',function()&#123; // 必须加上binary，返回的是二进制 res.end(data, 'binary'); &#125;); readerStream.on('error', function(err)&#123; console.log(err.stack); &#125;);&#125;); 这个方法其实跟第一个差不多，都是使用了fs的流来读取图片，但是没有使用pipe直接把数据流转给res，需要自己监听数据来处理，这里我试验了好多方式，终于成功了，注意readerStream.setEncoding(‘binary’)和res.end(data, ‘binary’)，都需要加上binary格式。 方法三123456789app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.readFile('./img/1.jpg', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; res.end(data); &#125;);&#125;); 这种方法时最简单的，但是遇到大文件会影响计算机的性能。 总结最后整体代码贴一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var express = require('express');var fs = require('fs');var app = express(); app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;);// stream+pipe方式一app.post('/downimg', function (req, res, next) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.createReadStream('./img/1.jpg') .pipe(res);&#125;); // stream方式二app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); var data = ''; var readerStream = fs.createReadStream(process.cwd() + '/img/1.jpg'); // 设置编码为 binary 必须 readerStream.setEncoding('binary'); readerStream.on('data', function(chunk) &#123; data += chunk; &#125;); readerStream.on('end',function()&#123; // 必须加上binary，返回的是二进制 res.end(data, 'binary'); &#125;); readerStream.on('error', function(err)&#123; console.log(err.stack); &#125;);&#125;);// 直接读取整个文件方式三app.post('/downimg', function (req, res) &#123; res.header(\"Content-Type\", \"application/octet-stream\"); fs.readFile('./img/1.jpg', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; res.end(data); &#125;);&#125;);var server = app.listen(3000, function () &#123; console.log(\"应用实例，访问地址为 http://%s:%s\", '127.0.0.1', '3000')&#125;)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"js图片下载之前端部分","slug":"js图片下载之前端部分","date":"2019-02-27T02:31:41.000Z","updated":"2019-02-27T06:03:47.927Z","comments":true,"path":"2019/02/27/js图片下载之前端部分/","link":"","permalink":"/2019/02/27/js图片下载之前端部分/","excerpt":"js控制图片下载","text":"js控制图片下载 js图片下载之前端部分这两天有一个小需求，就是点击页面中的下载按钮，下载指定的图片。经过一番的小研究，发现想实现这个功能，基本上都用到a标签的download属性，也就a标签的href指向图片地址，加上download属性后，点a标签就可以下载图片了。但是，有个问题，这需要在同域名下才好用，跨域貌似都不行，所以，在跨域的情况下就得另想办法。我总结了两种方法，一一道来。 方法一利用canvas，就是有一个图片地址，利用canvas把图片画出来，之后再通过canvas的toDataURL方法，将图片转为base64的数据，再把这个数据赋值给a标签的href属性，就可以了。这里注意一点，canvas调取toDataURL方法时，如果是跨域图片需要后台允许跨域，还需要在img标签的”crossOrigin”属性设置为’Anonymous’才管用，最后贴出具体代码：1234567891011121314151617181920212223function downloadImg(url)&#123; // 通过构造函数来创建的 img 实例，在赋予 src 值后就会立刻下载图片，相比 createElement() 创建 &lt;img&gt; 省去了 append()，也就避免了文档冗余和污染 var Img = new Image(), dataURL=''; Img.setAttribute(\"crossOrigin\",'Anonymous'); // 这里允许了跨域图片 Img.src=url; Img.onload=function()&#123; // 要先确保图片完整获取到，这是个异步事件 var canvas = document.createElement(\"canvas\"), // 创建canvas元素 width=Img.width, // 确保canvas的尺寸和图片一样 height=Img.height; canvas.width=width; canvas.height=height; canvas.getContext(\"2d\").drawImage(Img,0,0,width,height); // 将图片绘制到canvas中 dataURL=canvas.toDataURL('image/jpeg'); // 转换图片为dataURL var a = document.createElement('a'), body = document.body; a.download = 'img.jpg'; a.href = dataURL; body.append(a); a.click(); body.removeChild(a); &#125;; &#125; 方法二第二种方法就需要后端配合了，前端使用ajax请求到图片的二进制数据，之后利用了FileReader这个API，具体看代码：1234567891011121314151617181920212223242526 function downloadImg(url) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', url, true); // 请求方式 xhr.responseType = \"blob\"; // 返回类型blob xhr.onload = function () &#123; // 请求完成 if (this.status === 200) &#123; // 返回200 var blob = this.response; var reader = new FileReader(); reader.readAsDataURL(blob); // 转换为base64，可以直接放入a标签的href reader.onload = function (e) &#123; // 转换完成，创建一个a标签用于下载 var a = document.createElement('a'), body = document.body; a.download = 'img.jpg'; a.href = e.target.result; body.append(a); a.click(); body.removeChild(a); &#125; &#125; &#125;; // 发送ajax请求 xhr.send()&#125; 这个方法需要后端发送图片的二进制数据，我也写了nodejs的发送方法，见《js图片下载之后端部分》","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"浏览器消息提示Notification","slug":"浏览器消息提示Notification","date":"2019-02-14T06:41:44.000Z","updated":"2019-02-14T06:54:50.672Z","comments":true,"path":"2019/02/14/浏览器消息提示Notification/","link":"","permalink":"/2019/02/14/浏览器消息提示Notification/","excerpt":"浏览器自带的消息提示框","text":"浏览器自带的消息提示框 浏览器消息提示Notification这两天有一个新需求，微信网页版有这个功能，就是当浏览器最小化后，微信来消息，这时在电脑桌面的右下角会有消息提示框。这个功能用到了浏览器新特性的Notification接口，虽说兼容性不好，但是在现代浏览器上使用还是可以的。直接贴出demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Notification&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"message\"&gt;弹消息&lt;/button&gt; &lt;button id=\"message-delay\"&gt;弹消息延迟&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var btn = document.getElementById('message'); var btnDelay = document.getElementById('message-delay'); btn.addEventListener('click', ()=&gt; &#123; notifyMe(&#123; title: '消息通知', body: '菜品订单', icon: './asset/image/icon.png' &#125;); &#125;, false); btnDelay.addEventListener('click', ()=&gt; &#123; setTimeout(()=&gt; &#123; notifyMe(&#123; title: '消息通知', body: '菜品订单', icon: './asset/image/icon.png' &#125;); &#125;, 5000); &#125;, false); function notifyMe(options) &#123; // if(!document.hidden) return; // 判断浏览器是否最小化 // 先检查浏览器是否支持 if (!(\"Notification\" in window)) &#123; alert(\"This browser does not support desktop notification\"); &#125; // 检查用户是否同意接受通知 else if (Notification.permission === \"granted\") &#123; // If it's okay let's create a notification var notification = new Notification(options.title, &#123; body: options.body, icon: options.icon, &#125;); &#125; // 否则我们需要向用户获取权限 else if (Notification.permission !== 'denied') &#123; Notification.requestPermission(function (permission) &#123; // 如果用户同意，就可以向他们发送通知 if (permission === \"granted\") &#123; var notification = new Notification(options.title, &#123; body: options.body, icon: options.icon, &#125;); &#125; &#125;); &#125; // 过3秒关闭提示框 setTimeout(function() &#123; notification.close(); &#125;, 3000); &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-01-31T08:57:14.000Z","updated":"2019-02-01T05:08:51.840Z","comments":true,"path":"2019/01/31/git常用命令/","link":"","permalink":"/2019/01/31/git常用命令/","excerpt":"工作中常用的git命令小总结","text":"工作中常用的git命令小总结 git常用命令git在我们工作中使用的很多，还有想github这样牛逼的代码托管网站，所以，git这个版本管理工具越来越多的被使用，其实git使用起来还是很复杂的，但是，我平时只是提交代码，所以就用到了几个命令而已，在这里做一下记录。 先来个简单点的 首先就是把现有的项目clone到本地。 1git clone https://github.com/jixoba/jQuery-Seat-Charts.git 之后就是我常用的几个提交命令 1234git status // 查看更改的文件有哪些git add . // add后边.的话，就是把所有改动的文件添加进去git commit -m &quot;提交log信息&quot; // 提交信息git push // 最后把更改内容推到远程仓库中 以上就是我经常用到的简单命令，如果有分支的话可能会复杂点，根据提示就可以了 说点复杂的 新建分支 1git branch branchname // branchname就是分支名 查看分支 12git branch -a //查看所有分支git branch -r //查看远程分支 本地切换分支 1git checkout branchname 克隆带有分支的项目方法一 1git clone -b template https://github.com/iview/iview-admin.git // clone template分支 克隆带有分支的项目方法二 1234567git clone https://github.com/iview/iview-admin.git // clone整个项目git branch -a //列出所有分支名称如下： * 号表示当前分支 * dev remotes/origin/HEAD -&gt; origin/dev remotes/origin/desktop remotes/origin/template 接下来，可以在本地新建分支并与远程仓库的分支进行关联了 1git checkout -b template origin/template // 作用是checkout远程仓库origin的分支template，在本地起名为template分支，并切换到本地的template分支","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"jquery座位插件","slug":"jquery座位插件","date":"2019-01-29T07:44:05.000Z","updated":"2019-01-29T08:38:49.604Z","comments":true,"path":"2019/01/29/jquery座位插件/","link":"","permalink":"/2019/01/29/jquery座位插件/","excerpt":"一个画座位图的jquery插件","text":"一个画座位图的jquery插件 jquery座位插件最近这两天在画飞机的座位布局图和选座系统，本来想自己直接用原生画出来的，但是领导说其他部门做过相关功能，别的部门用的是jQuery-Seat-Charts这个插件，所以我也得使用。这里是插件地址，我fork了下来其实，这个插件的使用很简单，按照giyhub的文档就可以使用，因为需要定制开发，所以我大致的看了一下源码，觉得很好，主要是它在每个座位上加的事件，如果是我写的话，可能使用click事件，但是它用的focus事件和blur事件，正常情况下只有form表单的一些元素才有focus事件，但是想在div上也使用focus事件的话，需要给这个div加上tabIndex属性，一般情况下设为-1，就可以直接使用div的el.focus()方法了，我觉得这个好处就是，当点击其它座位时，之前focus的座位会触发blur事件，可以在这里做一些操作，简化了代码。以后再画座位的时候还可以使用这个插件，比如电影院选做系统，动车，飞机等，还是很方便的的。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"手写一个trigger插件","slug":"手写一个trigger插件","date":"2019-01-22T07:22:58.000Z","updated":"2019-01-22T08:41:41.185Z","comments":true,"path":"2019/01/22/手写一个trigger插件/","link":"","permalink":"/2019/01/22/手写一个trigger插件/","excerpt":"自己写一个简单的trigger来触发事件","text":"自己写一个简单的trigger来触发事件 手写一个trigger插件各位小伙伴们，jquery大家超级熟悉吧，jquery的trigger函数一定知道吧，反正我是非常喜欢用它，有时候比如要把一个弹出层隐藏掉，大家可能会去改这个弹出层的css，但是我可能会直接trigger一下这个弹出层取消按钮，因为我懒嘛，哈哈。但是，有时候可能想用trigger的时候，发现并没有使用jquery，额，自己写一个吧，其实，这段代码的核心部分我是参考了百度的一个手势库，好像叫touch.js,当时看的时候貌似这个库已经5年没人维护了，不过，模拟触发事件的代码被我留下了。见下面：12345678910111213141516171819202122232425262728293031323334;(function(root, factory) &#123; if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory; else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"jinuxTrigger\"] = factory; else root[\"jinuxTrigger\"] = factory;&#125;)(this, function(el, evt, detail) &#123; detail = detail || &#123;&#125;; var e, opt = &#123; bubbles: true, cancelable: true, detail: detail &#125;; try &#123; if (typeof CustomEvent !== 'undefined') &#123; e = new CustomEvent(evt, opt); if (el) &#123; el.dispatchEvent(e); &#125; &#125; else &#123; e = document.createEvent(\"CustomEvent\"); e.initCustomEvent(evt, true, true, detail); if (el) &#123; el.dispatchEvent(e); &#125; &#125; &#125; catch (ex) &#123; console.warn(\"jinux-trigger is not supported by environment.\"); &#125;&#125;); 再附上一个小demo123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jinux-trigger&lt;/title&gt; &lt;script src=\"./trigger.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;页面加载进来之后，等待3秒后代码触发按钮的点击事件&lt;/h1&gt; &lt;button&gt;点击...&lt;/button&gt;&lt;/body&gt;&lt;script&gt; const btn = document.querySelector('button'); btn.addEventListener('click',()=&gt;&#123; alert('点击按钮被点击了！！！'); &#125;,false); //页面加载进来之后，等待3秒后代码触发按钮的点击 setTimeout(()=&gt;&#123; jinuxTrigger(btn,'click'); &#125;,3000);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"js工具库","slug":"js工具库","permalink":"/tags/js工具库/"}]},{"title":"谷歌黑语法","slug":"谷歌黑语法","date":"2019-01-14T05:49:16.000Z","updated":"2019-01-15T06:05:34.367Z","comments":true,"path":"2019/01/14/谷歌黑语法/","link":"","permalink":"/2019/01/14/谷歌黑语法/","excerpt":"关于搜索引擎的一些使用技巧","text":"关于搜索引擎的一些使用技巧 谷歌黑语法平时，我们经常用百度来搜索一些东西，由于墙的原因，我们很少用谷歌，但是我们工作生活中使用百度就已经足够了。今天这篇文章介绍一下谷歌搜索的使用技巧，因为谷歌是所搜的老大，所以其它搜索引擎也来效仿谷歌，因而，下边介绍的这些搜索知识，基本上所有的搜索引擎都会适用的。 基础语法谷歌的默认搜索是and逻辑，意思就是，我们在输入关键字后进行搜索时，如输入：“program google”后，会搜出包含“program”和“google”的文件内容，如下图1所示。说到这里，我就插入一个小知识点：基础布尔逻辑。对于一个搜索引擎来说，进行搜索的时候是要搜索到匹配到所有关键词的页面，还是包含关键词中的任意关键词就可以，取决于一个搜索引擎的一些特别算法，称之为搜索引擎的布尔逻辑默认值。而google就是用and作为默认逻辑（搜索到所有的关键词），当然这个前提是我们没有输入一些特殊的命令。如果你不确定你要搜索的内容，或者你想搜索两个中的任意一个，那么就要使用关键词“OR”。注意：OR是大写的，小写是不起作用的，而且，每一个关键词与“OR”之间是有一个空格的，我们来看一下搜索结果。当然，可以预想的是，google的结果要比program多得多，所以结果第一页全是有关google的内容。此外，还可以借助计算机体系语言中的“|”来代替“OR”，效果是一样的。当然，如果你希望搜索“programgoogle”的内容，而不希望这两个单词之间有任何其他的内容，那么就要使用双引号把搜索的内容组成一个词组来达到目的。如下图3所示。如上图所示，结果中的programgoogle都是在一起的，没有分割。当然这样的结果比较少，只有2740个，但是看图1，结果却有7亿多个。而且，大部分搜索引擎都有智能断句的功能，如果没有特殊的命令，搜索引擎会一定量的根据大众的语言使用习惯来判断你要搜索什么，而这样的做法，不仅仅没有使搜索引擎显得不听话，反而对大众来讲搜索引擎变得十分智能和高效！但是如果我们只想看到“program”的内容，而不希望看到“google”的内容，就可以把“-”（减号或者破折号）应用到搜索当中去，语法为“program -google”，注意，“-”之前是有一个空格的，而其后却是和下一个关键词是紧紧相连的！搜索的结果如下图4所示。可以看得到结果中都会包含program，而不包含google。说到这里，还要提一下google的约束扩展问题了。一般来说，当输入关键词后，google会把相关网页和信息的结果呈现在我们面前。然而，有一些单词在搜索引擎中是会被智能忽略的，导致我们得不到想要的结果。比如十分常用的“www”和“the”，基本上任何一个网页上都会找到的东西，就会被google自动忽略（不要觉得这样不好，还是那个道理，在实际引用当中这样做反而显得更加高效和智能）。如果我们不想忽略这些词进行查询，就得在这些关键词的前面加上符号“+”。如下图5所示：看上去两者好像没有什么大的区别，其实仔细比较一下搜索结果就可以看得出，加上加号的搜索结果有一万多个，而不加加号的结果却有着55亿多！而因为google和www的关联度比较高，所以在前面的结果表现的差别不大。除了上述字符之外，一些搜索引擎支持一种叫做“stemming”（填充）的技术。Stemming是指在查询的关键词中添加一些通配符，通常是“*”，有时候也可能是“？”，这些通配符的作用是要求搜索引擎进行查询是可以返回多个不同的结果。其中通配符代表占位，可以匹配其他任意字母和单词，而其他的字或词组与用户输入的相同。如我们想要搜索“Lionel Messi”的内容，却忘记了第一个单词的一些拼写，就可以输入“l*Messi”进行查询，注意：此处整个字符串是要用一个英文半角双引号括住的！结果如下图所示。可以看到，google自动匹配出Lionel Messi的内容并且进行了搜索。这样的方式有利于我们只能记住单词或短语的一部分的内容时使用。基本的语法就讲到这里，上述的内容也没有列全，因为有些搜索功能不太常用。不过，这些语法就已经够我们日常使用的了，基本语法就是做基本的事，google也有一些高级的语法，见下边高级语法。 高级语法intitle首先要介绍的就是“intitle:”的用法，这个串的作用是将搜索的范围局限在标题上。在关键词前面加上这个，就会只对网页的标题进行搜索并且配对，最后将结果返回给用户。例如输入“intitle:program moon”进行搜索，就会返回如下图所示的结果。但是可以看到，貌似搜索结果中只出现了关于program的内容，而并没有moon相关的内容，这里其实还是牵扯到搜索引擎的基础布尔逻辑问题，在intitle:语法上，google会检索所有的网页，只要出现program或者moon其中的一个就会被匹配，意料之中的是，关于program的内容肯定是要远远多于moon的内容的，所以搜索结果里关于program的内容占据了主导，可以理解为moon这个关键词被一定量的智能忽略了。但是如果我们想要找到网页标题中既有program又有moon的网页呢?那么我们就要使用“intitle:”的一个变体“allintitle:”，使用这个前缀后，就能得到我们想要的结果了。如下图所示，除了第一条为google的图片推荐，其余的结果中网页的标题既含有program这个关键词，又含有moon这个关键词。 intext看到这个单词，大概就可以猜到它的意义了，“intext:”是用来搜索网页正文内容的，这样就可以忽略网页中的超文本链接、URL和题目。我们输入“intext:2018 program”进行搜索，结果如下图所示，结果中显示的网页大部分标题几乎没有规律，但是网页的索引中都包含着 “2018 program”，但是因为2018和program的同时出现的网页实在比较少，两个关键词的关联度实在不高（笔者此时的时间为2016年12月25日00:07:10），因为现在才是2016年，如果换成“2016 program”我相信应该会有更多的结果出现。但是我们要明白，这时搜索引擎关注的内容是网页的正文。与之相对应的也有一个变体：“allintext:”，用法和上面的“allintitle”相似，我就不做过多的介绍了。到这里恐怕就有读者要问了，这与我们平时的搜索相比没有什么高级的地方啊？确实，就平时的搜索来讲，这个语法的意义确实不太重大，但是在某些领域，例如黑客作为一名攻击者，构造好关键词配合适当的语法就可以进行撒网式的攻击，这个呢，我们点到为止，这里就不谈了。 inanchor这个语法的意思是在页面的链接锚点进行搜索。链接锚点指的是一个链接的描述文本，如这样的一段HTML代码：&lt;a href=https://www.baidu.com&gt;百度，链接的锚点就是“百度”了。我们搜索“inanchor:login”就可以搜索到有那些含有锚点的网页了，如下图所示。当然，这个语法也有一个变体“allinanchor:”，意思也与前面的类似。 site这个语法是把搜索限制在站点域名之内。例如我们搜索“program site:google.com”，结果如下图所示，这里呢，我们通常不需要加上前面的www，这样搜索的结果就会是包括所有含有google.com域名的有关内容，包括顶级域名和二级域名甚至三级域名的内容。也就是说我们甚至可以通过搜索，确定google.com大概有多少个子域名！ inurlinurl:会将搜索的范围限制在URL或者网站的页面上，这个语法对于查找搜索和帮助是很有用的，不仅适合我们普通的搜索，在黑客搜索中用处也很大。例如我们输入“inurl:password”，结果如下图所示，结果显示了所有URL中含有password的网页。另外，这个语法也有一个变体：“allinurl:”，用法与前面的相似。在黑客领域，inurl和site的使用是十分的频繁的，利用他们组合可以搜索到有用的信息，如我们可以使用1“site:google.com –inurl:www.google.com”，而这个语法的含义就是搜索google到底有多少个子域名。 link这个的功能是查询所有链接到某个特定URL上的列表。要注意的是，是特定的URL页面，如输入：1“link:www.baidu.com” 进行搜索，如下图所示，就会返回所有链接到百度主页的网页了。因此，我们同样可以指定特定的URL页面来进行搜索。 cacheCache可以帮助我们查找到google索引过的页面副本，它最大的好处就是即使源文件界面不存在了，或者变成了其它的内容，我们依然可以搜索的到。例如输入:1“cache：www.baidu.com” 结果如下所示，可以看到，格式虽然乱糟糟的，但是依稀可以从中获取一些有用的信息的。在国内的搜索引擎上，可能也有类似的功能，比如百度的网页快照，其功能与这个类似。 filetypefiletype是指搜索指定后缀的文件。这个不太常用，但是在黑客领域有一定的作用。但是我们的重点是讲解语法，所以这里就一笔带过（关于filetype的一些其他内容我会在以后的博文中展示），如下图所示，输入“filetype:mdb”，结果就会显示出一些网站的数据库文件。 related这个语法是用于搜索与某些页面相关的网站的，可以辅助我们搜索同类的页面。比如我们输入1“related:www.google.com” 显示的结果都是一些其他的搜索引擎。 info这个语法可以搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等，注意下面的英文信息就好。输入1“info:www.google.com” 结果如下图所示。 好了，大概就这么多了，还用别的这里就不介绍了，对于我这种小白来说已经够用的了。","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"}]},{"title":"es6-async-await","slug":"es6-async-await","date":"2019-01-03T06:17:47.000Z","updated":"2019-01-03T06:26:12.963Z","comments":true,"path":"2019/01/03/es6-async-await/","link":"","permalink":"/2019/01/03/es6-async-await/","excerpt":"es6中async-await的demo","text":"es6中async-await的demo es6-async-awaites6现在已经在项目中使用了，async偶尔用，所以要用的时候总是忘记，写个小demo，用的时候看一眼，哈哈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;es7-async-await&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;es7-async-await&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; //写一个返回Promise的异步函数 function asyncTime(val, ms)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(val); &#125;,ms); &#125;); &#125; //async函数 async function testAsync()&#123; let a = await asyncTime(1, 1000); //a的值就是Promise函数里面resolve的参数值 console.log(a); let b = await asyncTime(a+1, 1000); console.log(b); let c = await asyncTime(b+1, 1000); console.log(c); let d = await 123; //await后面可以不是Promise函数，但是会自动包装成一个Promise函数并且立即向后执行 console.log(d); return c; &#125; testAsync().then(function(res)&#123; console.log('async函数的then函数-&gt;',res); &#125;); //async函数 async function testAsync_2()&#123; let a = await testAsync(); //因为async本身执行后会返回一个Promise函数(async函数内部return的值只作为async返回的Promise函数的then里的参数传入)，所以此处也可以在await后边写async函数。 console.log(a); return a; &#125; testAsync_2().then(function(res)&#123; console.log('async函数2的then函数-&gt;',res); &#125;); //再来一个多个异步函数执行的例子 async function testAsync_3()&#123; let a = await Promise.all([asyncTime('all1',2000),asyncTime('all2',2000),asyncTime('all3',2000)]); console.log(a); return a; &#125; testAsync_3().then(function(res)&#123; alert(res); &#125;);&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"github预览静态库页面","slug":"github预览静态库页面","date":"2019-01-02T08:53:42.000Z","updated":"2019-01-03T00:52:33.164Z","comments":true,"path":"2019/01/02/github预览静态库页面/","link":"","permalink":"/2019/01/02/github预览静态库页面/","excerpt":"github预览静态库页面","text":"github预览静态库页面 github预览静态库页面类似于 https://jinux7.github.io 这样的github静态网站展示大家都知道怎么弄，在网上可以搜索到很多教程，我自己的blog网站就是这么搞的，但是这种方法我发现一个github账户只能弄出一个，今天我想说的是另一种方式，直接可以访问到普通库里的静态页面。这里需要github提供的一个服务地址，见下边：1https://htmlpreview.github.io/?https://raw.githubusercontent.com/jixoba/mobile_company/master/index.html 上边的这段地址就可以访问普通库里的静态页面了，注意jixoba/mobile_company这个，是库的名称，只需要更改这个库名，其它地方不需要动。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"cordova android打包配置详解","slug":"cordova-android打包配置详解","date":"2018-12-18T07:27:22.000Z","updated":"2018-12-19T05:22:57.679Z","comments":true,"path":"2018/12/18/cordova-android打包配置详解/","link":"","permalink":"/2018/12/18/cordova-android打包配置详解/","excerpt":"cordova打包android app","text":"cordova打包android app cordova android打包配置详解前几天在网上看到了cordova的东西，之前有过鼓捣react native和weex，所以看看它有什么特点。由于我用的是win10系统，所以在配置环境的时候相当的麻烦，这里稍微的屡一下。 一 安装JDKJDK是java的开发工具包，因为我们打包安卓的apk文件，安卓是依赖java的，所以这个必须安装。我刚开始安装的是最新版的，但是与cordova版本好像不是很搭，于是安装了JDK8这个版本。安装好了之后要配置环境变量，首先是新建变量名JAVA_HOME，指向JDK的安装目录，之后再配置一下path，指向JDK里的bin目录。再配置一下jre的path，也是指向jre里的bin目录。（jre安装有的直接安装JDK的时候顺便安装了，有的版本需要另外单独安装） 二 安装SDKSDK稍微有点复杂，首先还是下载SDK并且安装，这里需要注意，安装路径，我用的win10，必须安装在 用户/用户名/AppData/Local,其它系统可能无所谓。安装好了之后，还是配置环境变量，新建变量名ANDROID_SDK_HOME，指向安装的SDK目录，再配置path，指向SDK下的tools和platform-tools。 三 安装GradleGradle好像是一个打包工具，直接下载安装，之后配置一下Gradle的bin目录环境变量。 四 安装cordovacordova的安装和运行需要nodejs，所以用npm来安装。1npm i -g cordova@6.1.1 注意，这里我安装的是6.1.1版本，高版本莫名其妙的报错，这个稳妥一些。之后就是使用cordova来创建项目喽。12345cordova create app jinux.com.cn app // 创建一个项目cd app // 进入app项目cordova platform android // 添加安卓模板cordova requirements // 查看打包缺少什么依赖项cordova build android // 打包apk 以上的这些命令，在查看依赖项的时候肯定回报一些错误，SDK的一些依赖没有安装，进入SDK文件夹，打开SDK Manager.exe，根据依赖的提示下载相应的包，注意，这里是从谷歌上拉取，所以要开代理哦。第一次build的时候，Gradle需要从网络上下载一堆包，还是注意需要代理拉取谷歌的文件，很慢的，耐心等待。*下面是一个别人写的cordova博文，可供参考参考","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"/tags/cordova/"}]},{"title":"setTimeout&async&Promise执行顺序","slug":"setTimeout-async-Promise执行顺序","date":"2018-12-11T01:59:32.000Z","updated":"2018-12-11T02:36:37.697Z","comments":true,"path":"2018/12/11/setTimeout-async-Promise执行顺序/","link":"","permalink":"/2018/12/11/setTimeout-async-Promise执行顺序/","excerpt":"setTimeout&amp;async&amp;Promise执行顺序简要分析","text":"setTimeout&amp;async&amp;Promise执行顺序简要分析 setTimeout&amp;async&amp;Promise执行顺序看到标题，觉得这种需求在实际项目中基本遇不到，是的，我从没有遇到过，而且，要用就用一种，既然用了async，还用啥Promise。不过，网上有一道面试题，据说是今日头条的面试题，考的就是这方面的知识，先贴出代码。1234567891011121314151617181920async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1') resolve();&#125; ).then(function() &#123; console.log('promise2')&#125; )console.log('script end') 答案一会再说。先来分析一下，setTimeout,async,Promise执行的有先顺序。其实，要想研究明白这个问题，需要了解异步执行的宏任务，微任务知识，而且，在浏览器和nodejs环境下还不一样，这里我不对这些知识作深入分析，因为我看了些相关知识，看的晕头转向，所以，我只简单的记一下在浏览器环境下的优先顺序。异步发生的节点是：1.setTimeout的回调函数。2.Promise实例的then方法中的回调函数。3.async函数中await 后面紧跟着的函数（如async2），这个地方比较有意思，进入async2的时候是同步的，async2里边如果都是同步函数，那就继续执行，等执行完毕，返回先关东西后，”await async2()”这句话下边的语句不会马上执行，有点像Promise实例的then方法中的回调一样，需要排队等待。所以，优先顺序是Promise的then方法回调第一，async await 之后的语句排第二，setTimeout的回调排第三。记住了吗？我没有考虑理论知识，只是简单地死记硬背而已。最后，把上边代码的结果写出来，看看与你想的是否一样。12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"nodejs搭建https服务器","slug":"nodejs搭建https服务器","date":"2018-12-07T07:03:57.000Z","updated":"2018-12-07T08:03:44.502Z","comments":true,"path":"2018/12/07/nodejs搭建https服务器/","link":"","permalink":"/2018/12/07/nodejs搭建https服务器/","excerpt":"ssl证书的创建，https服务器的搭建","text":"ssl证书的创建，https服务器的搭建 nodejs搭建https服务器虽然作者是一名菜鸟前端，但是学习https相关的知识还是必须的。之前看过很多理论的文章，http与https的区别，ssl证书如何起作用的等等，说实话，我都忘记了，今天正好有时间，早上坐地铁就看了相关的文章，刚才写出了一个demo，现在就记录一下整个过程。 http与https区别 HTTP: 超文本传输协议 (Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTPS:（Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。创建ssl证书第一步，安装openssl安装openssl，很简单，按照正常的window软件按照下一步按照就可以，下面是下载地址，注意选择是64bit还是32bit哦,我下载了“Win64 OpenSSL v1.1.1a Ligh”这个版本，因为体积小，所以下载了light的版本。openssl下载地址安装好了之后，配置一下环境变量，这样在哪个文件夹下都可以直接使用openssl命令了。第二部，使用openssl创建ssl证书这个步骤还是有点小困难，在网上按照有的教程弄不好使，后来找到一个教程，好使，直接贴出命令行代码。12345678910111213141516171819202122232425262728293031323334#生成私钥key文件：~ D:\\workspace\\javascript\\nodejs-https&gt;openssl genrsa -out privatekey.pem 1024Generating RSA private key, 1024 bit long modulus...........................++++++........++++++e is 65537 (0x10001)#通过私钥生成CSR证书签名~ D:\\workspace\\javascript\\nodejs-https&gt;openssl req -new -key privatekey.pem -out certrequest.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:BeijingLocality Name (eg, city) []:BeijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:fens.meOrganizational Unit Name (eg, section) []:fens.meCommon Name (eg, YOUR name) []:Conan ZhangEmail Address []:bsspirit@gmail.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []:# 通过私钥和证书签名生成证书文件~ D:\\workspace\\javascript\\nodejs-https&gt;openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pemSignature oksubject=/C=CN/ST=Beijing/L=Beijing/O=fens.me/OU=fens.me/CN=Conan Zhang/emailAddress=bsspirit@gmail.comGetting Private key 注意在通过私钥生成CSR证书签名的时候需要添加一些个人信息。新生成了3个文件：certificate.pem, certrequest.csr, privatekey.pem privatekey.pem: 私钥 certrequest.csr: CSR证书签名 certificate.pem: 证书文件接下来，直接在nodejs的服务代码中引入相关文件就可以了。nodejs创建https服务器直接贴代码了，这步骤就很简单了1234567891011121314151617181920212223242526272829var app = require('express')();var fs = require('fs');var http = require('http');var https = require('https');var privateKey = fs.readFileSync('./ssl/privatekey.pem', 'utf8'), certificate = fs.readFileSync('./ssl/certificate.pem', 'utf8');var credentials = &#123;key: privateKey, cert: certificate&#125;;var httpServer = http.createServer(app);var httpsServer = https.createServer(credentials, app);var PORT = 18080;var SSLPORT = 18081;httpServer.listen(PORT, function() &#123; console.log('HTTP Server is running on: http://localhost:%s', PORT);&#125;);httpsServer.listen(SSLPORT, function() &#123; console.log('HTTPS Server is running on: https://localhost:%s', SSLPORT);&#125;);// Welcomeapp.get('/', function(req, res) &#123; if(req.protocol === 'https') &#123; res.status(200).send('Welcome to Safety Land!'); &#125; else &#123; res.status(200).send('Welcome!'); &#125;&#125;); 好了，https服务器搭建完成，原来这么简单。不过，有个问题，因为这个ssl证书属于个人证书，并不是第三方的安全CA证书，所以在浏览器访问https协议时候会有不安全的提醒文字，这个对于我们测试来说是没问题的，如果想在正规的网站上使用，我们还得去阿里云申请CA证书哦。最后，本想把本demo的代码上传到github，不过，代码实在是简单，不传了，直接放个截图得了。ssl文件夹里放了3个ssl文件哦。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"vue-iview Modal组件简单分析","slug":"vue-iview-Modal组件简单分析","date":"2018-12-04T07:49:12.000Z","updated":"2018-12-05T02:22:50.407Z","comments":true,"path":"2018/12/04/vue-iview-Modal组件简单分析/","link":"","permalink":"/2018/12/04/vue-iview-Modal组件简单分析/","excerpt":"vue-iview Modal组件简单分析","text":"vue-iview Modal组件简单分析 vue-iview Modal组件简单分析现在公司的项目前端框架用的是vue，在工作中避免不了要写一些组件，其实写组件的方法千千种，怎么写都行，但是，总想写出来的组件像一些ui框架里的组件一样高大上，于是乎，今天有点时间，大致的看了一下iview的Modal组件，简单的记录一下思想。由于时间原因，代码并没有深入往里边看，只是把大致的框框看了一下。首先，我们看看Modal组件的用法，官方文档点这里简单的用法如下：1234567&lt;Modal v-model=\"modal12\" draggable scrollable title=\"Modal 1\"&gt; &lt;div&gt;This is the first modal&lt;/div&gt;&lt;/Modal&gt;// 上边这个是基础写法// 下边这个写法可以直接调用，不需要在html中写出&lt;Modal&gt;&lt;/Modal&gt;标签this.$Modal.info(config)this.$Modal.success(config) 先看一下iview的Modal组件文件夹结构index文件是入口文件，里边导出了Modal对象。也就是可以使用标签的原因，因为给Modal对象加一大堆方法，但是它还是一个vue的基础组件。大家可能注意到了，当使用标签定义组建的时候，发现最后组件的dom元素被插入到了body下，而不是在具体引入的位置，这是因为Modal组件里有一个指令：12345// Modal组件里有directives: &#123; TransferDom &#125;// 追溯TransferDom指令，发现有如下代码parentNode.replaceChild(home, el); // moving out, el is no longer in the documentgetTarget(value).appendChild(el); // moving into new place modal.vue文件是组件的基础文件，也就是页面显示出来的东西，index文件里的东西可以看出来，只是给Modal对象添加了一些静态方法，为了this.$Modal.info(config)这样调用的时候使用。confrim文件里主要做了this.$Modal.info()这样调用的时候动态new Vue()实例，也是以modal.vue这个组件为基础，动态的插入到body节点里，代码见下边:就是通过new Vue()的实例获取到这个组建的html代码片段，再插入到body节点中。最后，再看看iview如何变成vue的全局组件的。123456789101112131415const install = function(Vue, opts = &#123;&#125;) &#123; ... // 这里添加全局组件 Object.keys(iview).forEach(key =&gt; &#123; Vue.component(key, iview[key]); &#125;); ... // 这里添加实例方法 Vue.prototype.$Modal = Modal; &#125;; 以上就是大概思路哈。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"小巧的html模板引擎","slug":"小巧的html模板引擎","date":"2018-11-30T06:57:20.000Z","updated":"2018-11-30T07:16:38.370Z","comments":true,"path":"2018/11/30/小巧的html模板引擎/","link":"","permalink":"/2018/11/30/小巧的html模板引擎/","excerpt":"小巧的html模板引擎","text":"小巧的html模板引擎 小巧的html模板引擎今天看coco大神的github，看到了他写的html模板引擎，默默地记录下来，其实，模板引擎我自己也写过一个，不过总觉得大神写的一定比我的好，点击这是我写的先贴出代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * coTemplate * */(function(name, definition) &#123; if (typeof define === 'function') &#123; define(definition); &#125; else &#123; this[name] = definition(); &#125;&#125;)('cotemplate', function() &#123; var tplReg = /\\$\\&#123;\\s*([^\\&#123;\\&#125;\\s]+)\\s*\\&#125;/g; var jsReg = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g; var code = 'var r=[];\\n'; var match = 'undefined'; var pointer = 0; /** * 添加单行逻辑 * @param &#123;*&#125; line */ function lineAdd(line) &#123; code += 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n'; &#125; /** * 模板拼接 * @param &#123;String&#125; tpl 模板字符串 * @param &#123;Objcet&#125; data 模板内替换对象 */ function cotemplate(tpl, data) &#123; while (match = tplReg.exec(tpl)) &#123; // 添加非逻辑部分 lineAdd(tpl.slice(pointer, match.index)); // 添加逻辑部分 \"$&#123;\" + match[1] + \"&#125;\"; code += ('r.push(String(this.' + match[1] + '));'); pointer = match.index + match[0].length; &#125; // 添加代码的最后一截 lineAdd(tpl.substr(pointer, tpl.length - pointer)); // 返回结果，在这里我们就拿到了装入数组后的代码 code += 'return r.join(\"\");'; console.log(code); return new Function(code.replace(/[\\r\\t\\n]/g, '')).apply(data); &#125; /** * export */ return cotemplate;&#125;); 用法Demo1234567891011121314151617181920212223242526&lt;script src=\"../js/cotemplate.js\"&gt;&lt;/script&gt;&lt;script&gt;var data = &#123; name: 'Coco', info: &#123; age: 18 &#125;, bar: &#123; foo: &#123; else: 'co-template' &#125; &#125;&#125;var tpl = ` &lt;p&gt;name:$&#123;coco&#125;&lt;/p&gt; &lt;p&gt;Age:$&#123;info.age&#125;&lt;/p&gt; &lt;div&gt;$&#123;bar.foo.else&#125;&lt;/div&gt; `;cotemplate(tpl, data);// &lt;p&gt;Name:Coco&lt;/p&gt; // &lt;p&gt;Age:18&lt;/p&gt; // &lt;div&gt;HTML-template:co-template&lt;/div&gt; &lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"js工具库","slug":"js工具库","permalink":"/tags/js工具库/"}]},{"title":"传入标准时间，返回指定日期格式","slug":"传入标准时间，返回指定日期格式","date":"2018-11-30T06:30:31.000Z","updated":"2018-11-30T06:42:56.079Z","comments":true,"path":"2018/11/30/传入标准时间，返回指定日期格式/","link":"","permalink":"/2018/11/30/传入标准时间，返回指定日期格式/","excerpt":"传入标准时间，返回指定日期格式","text":"传入标准时间，返回指定日期格式 传入标准时间，返回指定日期格式平时在开发时经常会用到获取当前日期，有时候会自己写一个，今天网上闲逛，发现一个写的不错的，记录一下，以备后用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let common = &#123; /** * 传入标准时间，返回指定日期格式 * @param &#123;Number&#125; date * @param &#123;String&#125; format * @example * - dateSerialization(1511181312647, \"y-mm-dd h:i:s\") * - @return 2017-11-20 20:35:12 */ dateSerialization(date, format) &#123; let dateObj; let DEFAULT_FORMAT = \"y-mm-dd h:i:s\"; let _patternArr = [\"y\", \"mm\", \"dd\", \"h\", \"i\", \"s\"]; let _patternMap = &#123; y: function(d) &#123; return d.getFullYear(); &#125;, m: function(d) &#123; return d.getMonth() + 1; &#125;, mm: function(d) &#123; return _pad(d.getMonth() + 1); &#125;, d: function(d) &#123; return d.getDate(); &#125;, dd: function(d) &#123; return _pad(d.getDate()); &#125;, h: function(d) &#123; return _pad(d.getHours()); &#125;, i: function(d) &#123; return _pad(d.getMinutes()); &#125;, s: function(d) &#123; return _pad(d.getSeconds()); &#125; &#125;; if (/^\\d+$/.test(date)) &#123; dateObj = new Date(parseInt(date)); &#125; else if (typeof date == \"string\") &#123; dateObj = new Date(date.replace(/-/g, \"/\")); &#125; else if (_isDate(date)) &#123; dateObj = date; &#125; // 非法数据 if (!dateObj || dateObj.toString() == \"Invalid Date\") &#123; throw new Error(\"[common.date.format]the input cannot be converted to date object(\" + date + \")\"); return; &#125; format = format || DEFAULT_FORMAT; let _resultArr = format.split(/-|:|\\s/); let resultObj = &#123;&#125;; let result = \"\"; _patternArr.forEach(k =&gt; &#123; resultObj[k] = _patternMap[k](dateObj); &#125;); _resultArr.forEach(k =&gt; &#123; let regExp = new RegExp(k); format = format.replace(regExp, function(e) &#123; return resultObj[e]; &#125;); &#125;); return format; &#125;&#125;;function _toString(v) &#123; return Object.prototype.toString.call(v);&#125;function _isDate(v) &#123; return _toString(v) == \"[object Date]\";&#125;function _pad(n) &#123; return n &gt; 9 ? n : \"0\" + n;&#125;export default common;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"js工具库","slug":"js工具库","permalink":"/tags/js工具库/"}]},{"title":"高阶函数和高阶组件","slug":"高阶函数和高阶组件","date":"2018-11-29T06:41:59.000Z","updated":"2018-11-29T06:58:20.220Z","comments":true,"path":"2018/11/29/高阶函数和高阶组件/","link":"","permalink":"/2018/11/29/高阶函数和高阶组件/","excerpt":"高阶函数和高阶组件简介","text":"高阶函数和高阶组件简介 高阶函数和高阶组件什么是高阶函数高阶函数就是传入的参数有函数的函数。（有点绕口:)） 什么是高阶组件高阶组件就是传入的参数有组件的组件。:)react比较容易实现高阶组件","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"web安全之CSRF","slug":"web安全之CSRF","date":"2018-11-28T03:10:48.000Z","updated":"2018-11-29T06:33:21.211Z","comments":true,"path":"2018/11/28/web安全之CSRF/","link":"","permalink":"/2018/11/28/web安全之CSRF/","excerpt":"CSRF攻击的简要介绍","text":"CSRF攻击的简要介绍 web安全之CSRF一.CSRF是什么？CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 二.CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 三.CSRF漏洞现状CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别 爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而 现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 四.CSRF的原理下图简单阐述了CSRF攻击的思想：从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：1.登录受信任网站A，并在本地生成Cookie。2.在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 五例子上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1：银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000危险网站B，它里面有一段HTML的代码如下：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中 的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏 览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com /Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账 操作），所以就立刻进行转账操作…… 示例2：为了杜绝上面的问题，银行决定改用POST请求完成转账操作。银行网站A的WEB表单如下：危险网站B，它里面有一段HTML的代码如下：12345&lt;form action=\"Transfer.php\" method=\"POST\"&gt; &lt;p&gt;ToBankId: &lt;input type=\"text\" name=\"toBankId\" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=\"text\" name=\"money\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"Transfer\" /&gt;&lt;/p&gt; &lt;/form&gt; 后台处理页面Transfer.php如下：1234567&lt;?php session_start(); if (isset($_REQUEST['toBankId'] &amp;&amp; isset($_REQUEST['money'])) &#123; buy_stocks($_REQUEST['toBankId'], $_REQUEST['money']); &#125; ?&gt; 危险网站B，仍然只是包含那句HTML代码：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的 原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成 了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST 请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3：经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：1234567&lt;?php session_start(); if (isset($_POST['toBankId'] &amp;&amp; isset($_POST['money'])) &#123; buy_stocks($_POST['toBankId'], $_POST['money']); &#125; ?&gt; 然而，危险网站B与时俱进，它改了一下代码：1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function steal() &#123; iframe = document.frames[\"steal\"]; iframe.document.Submit(\"transfer\"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"steal()\"&gt; &lt;iframe name=\"steal\" display=\"none\"&gt; &lt;form method=\"POST\" name=\"transfer\" action=\"http://www.myBank.com/Transfer.php\"&gt; &lt;input type=\"hidden\" name=\"toBankId\" value=\"11\"&gt; &lt;input type=\"hidden\" name=\"money\" value=\"1000\"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一 个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了 CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 六.CSRF的防御我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 1.服务端进行CSRF防御服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值)：这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;12345&lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。123456789&lt;?php $hash = md5($_COOKIE['cookie']); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证123456789101112&lt;?php if(isset($_POST['check'])) &#123; $hash = md5($_COOKIE['cookie']); if($_POST['check'] == $hash) &#123; doJob(); &#125; else &#123; //... &#125; &#125; else &#123; //... &#125;?&gt; 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就 另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 (2).验证码这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值)在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提 交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单 都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。以下我的实现: 1).先是令牌生成函数(gen_token())：1234567&lt;?php function gen_token() &#123; //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token =md5(uniqid(rand(), true)); return $token; &#125; 2).然后是Session令牌生成函数(gen_stoken())：123456789101112 &lt;?php function gen_stoken() &#123; $pToken = \"\"; if($_SESSION[STOKEN_NAME] == $pToken)&#123; //没有值，赋新值 $_SESSION[STOKEN_NAME] =gen_token(); &#125; else&#123; //继续使用旧的值 &#125; &#125;?&gt; 3).WEB表单生成隐藏输入域的函数：1234567&lt;?php function gen_input() &#123; gen_stoken(); echo “&lt;input type=\\”hidden\\” name=\\”\" . FTOKEN_NAME . “\\” value=\\”\" . $_SESSION[STOKEN_NAME] . “\\”&gt; “; &#125;?&gt; 4).WEB表单结构：12345678910&lt;?php session_start(); include(”functions.php”);?&gt;&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt;&lt;/FORM&gt; 5).服务端核对令牌：这个很简单，这里就不再啰嗦了。上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"web安全之XSS","slug":"web安全之XSS","date":"2018-11-28T01:40:42.000Z","updated":"2018-11-28T03:05:14.090Z","comments":true,"path":"2018/11/28/web安全之XSS/","link":"","permalink":"/2018/11/28/web安全之XSS/","excerpt":"XSS攻击的简要介绍","text":"XSS攻击的简要介绍 web安全之XSS首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型 XSS非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。一个例子，比如你的 Web 页面中包含有以下代码：12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL1(类似：https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码非持久型 XSS 漏洞攻击有以下几点特征 :1 . 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据2 . 攻击者需要诱骗点击3 . 反馈率低，所以较难发现和响应修复4 . 盗取用户敏感保密信息 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情 :1 . Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。2 . 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。3 . 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。4 . 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。5 . 前端渲染的时候对任何的字段都需要做 escape 转义编码。 escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 &lt;，&gt;，空格 等，转义成 &lt;，&gt;， 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。 持久型 XSS持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件 :1 . POST 请求提交表单后端没做转义直接入库。2 . 后端从数据库中取出数据没做转义直接输出给前端。3 . 前端拿到后端数据没做转义直接渲染成 DOM。 持久型 XSS 有以下几个特点 :1 . 持久性，植入在数据库中2 . 危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。3 . 盗取用户敏感私密信息 为了防止持久型 XSS 漏洞，需要前后端共同努力 :1 . 后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。2 . 后端在输出给前端数据统一进行转义处理。3 . 前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。 基于字符集的 XSS其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。 以基于 utf-7 的 XSS 为例utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。123&lt;script&gt;alert(\"xss\")&lt;/script&gt;可以被解释为：+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4- 可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。 所以我们有什么办法避免这种 XSS 呢 ?1 . 记住指定 2 . XML 中不仅要指定字符集为 utf-8，而且标签要闭合3 . 牛文推荐：http://drops.wooyun.org/papers/1327 （这个讲的很详细） 基于 Flash 的跨站 XSS基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。 避免方法 :1 . 严格管理 cookie 的读写权限2 . 对 Flash 能接受用户输入的参数进行过滤 escape 转义处理 未经验证的跳转 XSS有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。 这时候需要通过以下方式来防止这类漏洞 :1 . 对待跳转的 URL 参数做白名单或者某种规则过滤2 . 后端注意对敏感信息的保护, 比如 cookie 使用来源验证。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"利用正则表达式统计代码行数","slug":"利用正则表达式统计代码行数","date":"2018-11-27T05:59:20.000Z","updated":"2018-11-27T06:30:45.581Z","comments":true,"path":"2018/11/27/利用正则表达式统计代码行数/","link":"","permalink":"/2018/11/27/利用正则表达式统计代码行数/","excerpt":"利用ide编辑器统计代码行数","text":"利用ide编辑器统计代码行数 利用正则表达式统计代码行数在项目中，我们常常有统计代码行数的需要，但是如果不利用第三方工具的话，面对一个项目（甚至一个工程或解决方案中若干个项目）中成百上千的代码文件，实在有一种力不从心的感觉。 但利用正则表达式可以巧妙解决。用的工具不是别的，正是所有的IDE（Visual Studio、Eclipse等等）和常用的文本编辑器（SublimeText2、Notepad++等）日常必备软件的“在文件中查找”，不同的软件略有不同，但大同小异。 再复杂的IDE，其搜索功能也是基于字符串的匹配进行的。我们知道，文本中每次换行会增加一个 \\n 。如果直接用正则\\n每一个匹配项就代表一次换行。但需要注意的是文件的最后一行是没有换行符的，所以文本行数=文件数+换行符数目，因而把两个看到的两个数字加起来才是文本行数。 1^.*$ 表示搜索条件为行首与行尾之间包含任意个任意字符（非换行符）。 上面的方法可以很迅速地得到代码行数，不过遗憾的是统计结果把空行（仅包含空格和制表符的行）也统计进去了，然而很多时候我们并不想把这些文本也给算进代码量里去，怎么办呢？别急，我们只要对正则表达式做一点点修改。我的思路是，只需要找出一个不是空格或制表符的字符即可，于是可写出了这个正则表达式1^\\s*[^\\s]+.*$ 它表示先忽略一行前面的连续空格和制表符等，然后寻找是否有一个字符不为空格、制表符、换行符和回车符，如果有则表明这行不为空行。不用1^\\s*\\S+.*$ 是为了下面方便添加其他要排除的注释行或者独立的括号行。 在实际项目中，我们或许认为注释行不应成为生产量，应从统计数据中排除出去。我们首先要能够对注释行有一个认识。很多程序设计语言中，注释行都会用“/”或者“#”等字符开头。我们假设项目中的注释行都是以“/”或“#”开头的（请读者考虑自己项目的特点自行修改）。下面的正则表示，我们要查找的是一行中第一个非空字符不是“/”或“#”或“{”或“}”的行12^\\s*[^\\s/#&#123;&#125;]+.*$ ^\\s*[^ \\t\\n\\r/#&#123;&#125;]+.*$ 作用同上，说明在中括号[]内自定义原子表，打个空格，也可以代表空格。因为控制开头和结尾，所以 + 后不必加问号 ? 取消贪婪模式了。 1^\\s*[^\\s/#&#123;&#125;]+ 也行，但是上面加上控制结尾比较严谨。另外，文本编辑框默认是视为单行的，没有设置多行模式，如果设为多行模式就得注意了。php 中，在定界符最右边加 m 即可视为多行。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"zepto源码","slug":"zepto源码","date":"2018-11-16T08:30:56.000Z","updated":"2018-11-23T08:39:10.510Z","comments":true,"path":"2018/11/16/zepto源码/","link":"","permalink":"/2018/11/16/zepto源码/","excerpt":"zepto源码，有注释","text":"zepto源码，有注释 zepto源码最近在看zepto源码，所以把一些注释也加上了，还没看完，以后继续加。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */(function(global, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) define(function() &#123; return factory(global) &#125;) else factory(global)&#125;(this, function(window) &#123; var Zepto = (function() &#123; var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice, document = window.document, elementDisplay = &#123;&#125;, classCache = &#123;&#125;, cssNumber = &#123; 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 &#125;, fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, // &lt;...&gt;都匹配 singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, // 只匹配没有内容的标签，如: &lt;div&gt;&lt;/div&gt;或&lt;input /&gt; // 匹配&lt;div /&gt;, &lt;: /&gt;这样的，除了&lt;input /&gt;,&lt;img /&gt;这样的 tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig, rootNodeRE = /^(?:body|html)$/i, capitalRE = /([A-Z])/g, // special attributes that should be get/set via method calls methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'], adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ], table = document.createElement('table'), tableRow = document.createElement('tr'), containers = &#123; 'tr': document.createElement('tbody'), 'tbody': table, 'thead': table, 'tfoot': table, 'td': tableRow, 'th': tableRow, '*': document.createElement('div') &#125;, readyRE = /complete|loaded|interactive/, simpleSelectorRE = /^[\\w-]*$/, class2type = &#123;&#125;, toString = class2type.toString, zepto = &#123;&#125;, camelize, uniq, tempParent = document.createElement('div'), propMap = &#123; 'tabindex': 'tabIndex', 'readonly': 'readOnly', 'for': 'htmlFor', 'class': 'className', 'maxlength': 'maxLength', 'cellspacing': 'cellSpacing', 'cellpadding': 'cellPadding', 'rowspan': 'rowSpan', 'colspan': 'colSpan', 'usemap': 'useMap', 'frameborder': 'frameBorder', 'contenteditable': 'contentEditable' &#125;, // 判断是否为数组 isArray = Array.isArray || function(object)&#123; return object instanceof Array &#125; // 判断节点是否包含选择器 zepto.matches = function(element, selector) &#123; if (!selector || !element || element.nodeType !== 1) return false var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector if (matchesSelector) return matchesSelector.call(element, selector) // fall back to performing a selector: var match, parent = element.parentNode, temp = !parent if (temp) (parent = tempParent).appendChild(element) // ~这个符号可以将-1转化为0，直接判断就是false了 match = ~zepto.qsa(parent, selector).indexOf(element) temp &amp;&amp; tempParent.removeChild(element) return match &#125; // 查看数据类型 function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\" &#125; // 判断是否为函数 function isFunction(value) &#123; return type(value) == \"function\" &#125; // 判断是否为window对象 function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125; // 判断是否为document对象 function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125; // 判断是否为object对象 function isObject(obj) &#123; return type(obj) == \"object\" &#125; // 判断是不是纯对象，如 &#123;&#125;,prototype没有添加的 function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype &#125; // 判断是不是类数组对象 function likeArray(obj) &#123; var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length, type = $.type(obj) return 'function' != type &amp;&amp; !isWindow(obj) &amp;&amp; ( 'array' == type || length === 0 || (typeof length == 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) ) &#125; // 压缩精简数组，去掉null，undefined function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array &#125; // 将font-size形式转换为fontSize驼峰形式 camelize = function(str)&#123; return str.replace(/-+(.)?/g, function(match, chr)&#123; return chr ? chr.toUpperCase() : '' &#125;) &#125; // 将驼峰命名转为-形式,正则的$1,$2...代表前边小括号里的内容 function dasherize(str) &#123; return str.replace(/::/g, '/') .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2') .replace(/([a-z\\d])([A-Z])/g, '$1_$2') .replace(/_/g, '-') .toLowerCase() &#125; // 删除数组中重复的元素，这个方法好牛逼 uniq = function(array)&#123; return filter.call(array, function(item, idx)&#123; return array.indexOf(item) == idx &#125;) &#125; // 如果classCache中没有name的话，则新建一个这个name的正则 function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)')) &#125; // 应该是给css赋值的时候，如果没在cssNumber这个表中的话就加上'px'后缀 function maybeAddPx(name, value) &#123; return (typeof value == \"number\" &amp;&amp; !cssNumber[dasherize(name)]) ? value + \"px\" : value &#125; // 应该是查看如div,table这样的元素的默认display的值 function defaultDisplay(nodeName) &#123; var element, display if (!elementDisplay[nodeName]) &#123; element = document.createElement(nodeName) document.body.appendChild(element) display = getComputedStyle(element, '').getPropertyValue(\"display\") element.parentNode.removeChild(element) display == \"none\" &amp;&amp; (display = \"block\") elementDisplay[nodeName] = display &#125; return elementDisplay[nodeName] &#125; // 获取节点的子元素 function children(element) &#123; return 'children' in element ? slice.call(element.children) : $.map(element.childNodes, function(node)&#123; if (node.nodeType == 1) return node &#125;) &#125; // function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' &#125; // `$.zepto.fragment` takes a html string and an optional tag name // to generate DOM nodes from the given html string. // The generated DOM nodes are returned as an array. // This function can be overridden in plugins for example to make // it compatible with browsers that don't support the DOM fully. zepto.fragment = function(html, name, properties) &#123; var dom, nodes, container // A special case optimization for a single tag if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)) if (!dom) &#123; if (html.replace) html = html.replace(tagExpanderRE, \"&lt;$1&gt;&lt;/$2&gt;\") // 将&lt;div/&gt;转化成&lt;div&gt;&lt;/div&gt; if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1 if (!(name in containers)) name = '*' // 下面的做法就是将'&lt;span&gt;12345&lt;/span&gt;'这样的字符串转为dom节点的形式 container = containers[name] container.innerHTML = '' + html dom = $.each(slice.call(container.childNodes), function()&#123; container.removeChild(this) &#125;) &#125; if (isPlainObject(properties)) &#123; nodes = $(dom) $.each(properties, function(key, value) &#123; if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value) else nodes.attr(key, value) &#125;) &#125; return dom &#125; window.haha = zepto; // `$.zepto.Z` swaps out the prototype of the given `dom` array // of nodes with `$.fn` and thus supplying all the Zepto functions // to the array. This method can be overridden in plugins. zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; // `$.zepto.isZ` should return `true` if the given object is a Zepto // collection. This method can be overridden in plugins. zepto.isZ = function(object) &#123; return object instanceof zepto.Z &#125; // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and // takes a CSS selector and an optional context (and handles various // special cases). // This method can be overridden in plugins. zepto.init = function(selector, context) &#123; var dom // If nothing given, return an empty Zepto collection if (!selector) return zepto.Z() // Optimize for string selectors else if (typeof selector == 'string') &#123; selector = selector.trim() // If it's a html fragment, create nodes from it // Note: In both Chrome 21 and Firefox 15, DOM error 12 // is thrown if the fragment doesn't begin with &lt; if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // If it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // If a function is given, call it when the DOM is ready else if (isFunction(selector)) return $(document).ready(selector) // If a Zepto collection is given, just return it else if (zepto.isZ(selector)) return selector else &#123; // normalize array if an array of nodes is given if (isArray(selector)) dom = compact(selector) // Wrap DOM nodes. else if (isObject(selector)) dom = [selector], selector = null // If it's a html fragment, create nodes from it else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // create a new Zepto collection from the nodes found return zepto.Z(dom, selector) &#125; // `$` will be the base `Zepto` object. When calling this // function just call `$.zepto.init, which makes the implementation // details of selecting nodes and creating Zepto collections // patchable in plugins. $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 深度拷贝的函数 function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key] &#125; // Copy all but undefined properties from one or more // objects to the `target` object. $.extend = function(target)&#123; var deep, args = slice.call(arguments, 1) if (typeof target == 'boolean') &#123; deep = target target = args.shift() &#125; args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target &#125; // `$.zepto.qsa` is Zepto's CSS selector implementation which // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`. // This method can be overridden in plugins. zepto.qsa = function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = simpleSelectorRE.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all ) &#125; function filtered(nodes, selector) &#123; return selector == null ? $(nodes) : $(nodes).filter(selector) &#125; // 判断父节点中是否包含子节点，parent为父节点，node为子节点 $.contains = document.documentElement.contains ? function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true return false &#125; function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg &#125; // 设置node节点的属性值 function setAttribute(node, name, value) &#123; value == null ? node.removeAttribute(name) : node.setAttribute(name, value) &#125; // access className property while respecting SVGAnimatedString function className(node, value)&#123; var klass = node.className || '', svg = klass &amp;&amp; klass.baseVal !== undefined if (value === undefined) return svg ? klass.baseVal : klass svg ? (klass.baseVal = value) : (node.className = value) &#125; // \"true\" =&gt; true // \"false\" =&gt; false // \"null\" =&gt; null // \"42\" =&gt; 42 // \"42.5\" =&gt; 42.5 // \"08\" =&gt; \"08\" // JSON =&gt; parse if valid // String =&gt; self // 反序列化 function deserializeValue(value) &#123; try &#123; return value ? value == \"true\" || ( value == \"false\" ? false : value == \"null\" ? null : +value + \"\" == value ? +value : /^[\\[\\&#123;]/.test(value) ? $.parseJSON(value) : value ) : value &#125; catch(e) &#123; return value &#125; &#125; $.type = type $.isFunction = isFunction $.isWindow = isWindow $.isArray = isArray $.isPlainObject = isPlainObject // 判断是否为空对象函数 $.isEmptyObject = function(obj) &#123; var name for (name in obj) return false return true &#125; // 判断是否是数字形式的 123或'123' $.isNumeric = function(val) &#123; var num = Number(val), type = typeof val return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125; // 判断元素是否在数组中，array数组，elem元素，i是从数组中的第几位开始查找 $.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i) &#125; $.camelCase = camelize $.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str) &#125; // plugin compatibility $.uuid = 0 $.support = &#123; &#125; $.expr = &#123; &#125; $.noop = function() &#123;&#125; // map函数，对elements进行处理后返回新数组 $.map = function(elements, callback)&#123; var value, values = [], i, key if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i) if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key) if (value != null) values.push(value) &#125; return flatten(values) &#125; // 遍历elements，执行callback函数，如果执行时返回false，则停止遍历操作 $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; // 过滤数组 $.grep = function(elements, callback)&#123; return filter.call(elements, callback) &#125; if (window.JSON) $.parseJSON = JSON.parse // Populate the class2type map $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase() &#125;) // Define methods that will be available on all // Zepto collections $.fn = &#123; constructor: zepto.Z, length: 0, // Because a collection acts like an array // copy over these useful array functions. forEach: emptyArray.forEach, reduce: emptyArray.reduce, push: emptyArray.push, sort: emptyArray.sort, splice: emptyArray.splice, indexOf: emptyArray.indexOf, concat: function()&#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) &#125;, // `map` and `slice` in the jQuery API work differently // from their array counterparts map: function(fn)&#123; return $($.map(this, function(el, i)&#123; return fn.call(el, i, el) &#125;)) &#125;, slice: function()&#123; return $(slice.apply(this, arguments)) &#125;, ready: function(callback)&#123; // need to check if document.body exists for IE as that browser reports // document ready when it hasn't yet created the body element if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($) else document.addEventListener('DOMContentLoaded', function()&#123; callback($) &#125;, false) return this &#125;, get: function(idx)&#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length] &#125;, toArray: function()&#123; return this.get() &#125;, size: function()&#123; return this.length &#125;, remove: function()&#123; return this.each(function()&#123; if (this.parentNode != null) this.parentNode.removeChild(this) &#125;) &#125;, each: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this &#125;, filter: function(selector)&#123; if (isFunction(selector)) return this.not(this.not(selector)) return $(filter.call(this, function(element)&#123; return zepto.matches(element, selector) &#125;)) &#125;, add: function(selector,context)&#123; return $(uniq(this.concat($(selector,context)))) &#125;, is: function(selector)&#123; return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector) &#125;, not: function(selector)&#123; var nodes=[] if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function(idx)&#123; if (!selector.call(this,idx)) nodes.push(this) &#125;) else &#123; var excludes = typeof selector == 'string' ? this.filter(selector) : (likeArray(selector) &amp;&amp; isFunction(selector.item)) ? slice.call(selector) : $(selector) this.forEach(function(el)&#123; if (excludes.indexOf(el) &lt; 0) nodes.push(el) &#125;) &#125; return $(nodes) &#125;, has: function(selector)&#123; return this.filter(function()&#123; return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size() &#125;) &#125;, eq: function(idx)&#123; return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1) &#125;, first: function()&#123; var el = this[0] return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, last: function()&#123; var el = this[this.length - 1] return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, find: function(selector)&#123; var result, $this = this if (!selector) result = $() else if (typeof selector == 'object') result = $(selector).filter(function()&#123; var node = this return emptyArray.some.call($this, function(parent)&#123; return $.contains(parent, node) &#125;) &#125;) else if (this.length == 1) result = $(zepto.qsa(this[0], selector)) else result = this.map(function()&#123; return zepto.qsa(this, selector) &#125;) return result &#125;, closest: function(selector, context)&#123; var nodes = [], collection = typeof selector == 'object' &amp;&amp; $(selector) this.each(function(_, node)&#123; while (node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector))) node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode if (node &amp;&amp; nodes.indexOf(node) &lt; 0) nodes.push(node) &#125;) return $(nodes) &#125;, parents: function(selector)&#123; var ancestors = [], nodes = this while (nodes.length &gt; 0) nodes = $.map(nodes, function(node)&#123; if ((node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0) &#123; ancestors.push(node) return node &#125; &#125;) return filtered(ancestors, selector) &#125;, parent: function(selector)&#123; return filtered(uniq(this.pluck('parentNode')), selector) &#125;, children: function(selector)&#123; return filtered(this.map(function()&#123; return children(this) &#125;), selector) &#125;, contents: function() &#123; return this.map(function() &#123; return this.contentDocument || slice.call(this.childNodes) &#125;) &#125;, siblings: function(selector)&#123; return filtered(this.map(function(i, el)&#123; return filter.call(children(el.parentNode), function(child)&#123; return child!==el &#125;) &#125;), selector) &#125;, empty: function()&#123; return this.each(function()&#123; this.innerHTML = '' &#125;) &#125;, // `pluck` is borrowed from Prototype.js pluck: function(property)&#123; return $.map(this, function(el)&#123; return el[property] &#125;) &#125;, show: function()&#123; return this.each(function()&#123; this.style.display == \"none\" &amp;&amp; (this.style.display = '') if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\") this.style.display = defaultDisplay(this.nodeName) &#125;) &#125;, replaceWith: function(newContent)&#123; return this.before(newContent).remove() &#125;, wrap: function(structure)&#123; var func = isFunction(structure) if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length &gt; 1 return this.each(function(index)&#123; $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ) &#125;) &#125;, wrapAll: function(structure)&#123; if (this[0]) &#123; $(this[0]).before(structure = $(structure)) var children // drill down to the inmost element while ((children = structure.children()).length) structure = children.first() $(structure).append(this) &#125; return this &#125;, wrapInner: function(structure)&#123; var func = isFunction(structure) return this.each(function(index)&#123; var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure contents.length ? contents.wrapAll(dom) : self.append(dom) &#125;) &#125;, unwrap: function()&#123; this.parent().each(function()&#123; $(this).replaceWith($(this).children()) &#125;) return this &#125;, clone: function()&#123; return this.map(function()&#123; return this.cloneNode(true) &#125;) &#125;, hide: function()&#123; return this.css(\"display\", \"none\") &#125;, toggle: function(setting)&#123; return this.each(function()&#123; var el = $(this) ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide() &#125;) &#125;, prev: function(selector)&#123; return $(this.pluck('previousElementSibling')).filter(selector || '*') &#125;, next: function(selector)&#123; return $(this.pluck('nextElementSibling')).filter(selector || '*') &#125;, html: function(html)&#123; return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : (0 in this ? this[0].innerHTML : null) &#125;, text: function(text)&#123; return 0 in arguments ? this.each(function(idx)&#123; var newText = funcArg(this, text, idx, this.textContent) this.textContent = newText == null ? '' : ''+newText &#125;) : (0 in this ? this.pluck('textContent').join(\"\") : null) &#125;, attr: function(name, value)&#123; var result return (typeof name == 'string' &amp;&amp; !(1 in arguments)) ? (0 in this &amp;&amp; this[0].nodeType == 1 &amp;&amp; (result = this[0].getAttribute(name)) != null ? result : undefined) : this.each(function(idx)&#123; if (this.nodeType !== 1) return if (isObject(name)) for (key in name) setAttribute(this, key, name[key]) else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))) &#125;) &#125;, removeAttr: function(name)&#123; return this.each(function()&#123; this.nodeType === 1 &amp;&amp; name.split(' ').forEach(function(attribute)&#123; setAttribute(this, attribute) &#125;, this)&#125;) &#125;, prop: function(name, value)&#123; name = propMap[name] || name return (1 in arguments) ? this.each(function(idx)&#123; this[name] = funcArg(this, value, idx, this[name]) &#125;) : (this[0] &amp;&amp; this[0][name]) &#125;, removeProp: function(name)&#123; name = propMap[name] || name return this.each(function()&#123; delete this[name] &#125;) &#125;, data: function(name, value)&#123; var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase() var data = (1 in arguments) ? this.attr(attrName, value) : this.attr(attrName) return data !== null ? deserializeValue(data) : undefined &#125;, val: function(value)&#123; if (0 in arguments) &#123; if (value == null) value = \"\" return this.each(function(idx)&#123; this.value = funcArg(this, value, idx, this.value) &#125;) &#125; else &#123; return this[0] &amp;&amp; (this[0].multiple ? $(this[0]).find('option').filter(function()&#123; return this.selected &#125;).pluck('value') : this[0].value) &#125; &#125;, offset: function(coordinates)&#123; if (coordinates) return this.each(function(index)&#123; var $this = $(this), coords = funcArg(this, coordinates, index, $this.offset()), parentOffset = $this.offsetParent().offset(), props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125; if ($this.css('position') == 'static') props['position'] = 'relative' $this.css(props) &#125;) if (!this.length) return null if (document.documentElement !== this[0] &amp;&amp; !$.contains(document.documentElement, this[0])) return &#123;top: 0, left: 0&#125; var obj = this[0].getBoundingClientRect() return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125; &#125;, css: function(property, value)&#123; if (arguments.length &lt; 2) &#123; var element = this[0] if (typeof property == 'string') &#123; if (!element) return return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property) &#125; else if (isArray(property)) &#123; if (!element) return var props = &#123;&#125; var computedStyle = getComputedStyle(element, '') $.each(property, function(_, prop)&#123; props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop)) &#125;) return props &#125; &#125; var css = '' if (type(property) == 'string') &#123; if (!value &amp;&amp; value !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(property)) &#125;) else css = dasherize(property) + \":\" + maybeAddPx(property, value) &#125; else &#123; for (key in property) if (!property[key] &amp;&amp; property[key] !== 0) this.each(function()&#123; this.style.removeProperty(dasherize(key)) &#125;) else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';' &#125; return this.each(function()&#123; this.style.cssText += ';' + css &#125;) &#125;, index: function(element)&#123; return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]) &#125;, hasClass: function(name)&#123; if (!name) return false return emptyArray.some.call(this, function(el)&#123; return this.test(className(el)) &#125;, classRE(name)) &#125;, addClass: function(name)&#123; if (!name) return this return this.each(function(idx)&#123; if (!('className' in this)) return classList = [] var cls = className(this), newName = funcArg(this, name, idx, cls) newName.split(/\\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \")) &#125;) &#125;, removeClass: function(name)&#123; return this.each(function(idx)&#123; if (!('className' in this)) return if (name === undefined) return className(this, '') classList = className(this) funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass)&#123; classList = classList.replace(classRE(klass), \" \") &#125;) className(this, classList.trim()) &#125;) &#125;, toggleClass: function(name, when)&#123; if (!name) return this return this.each(function(idx)&#123; var $this = $(this), names = funcArg(this, name, idx, className(this)) names.split(/\\s+/g).forEach(function(klass)&#123; (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass) &#125;) &#125;) &#125;, scrollTop: function(value)&#123; if (!this.length) return var hasScrollTop = 'scrollTop' in this[0] if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset return this.each(hasScrollTop ? function()&#123; this.scrollTop = value &#125; : function()&#123; this.scrollTo(this.scrollX, value) &#125;) &#125;, scrollLeft: function(value)&#123; if (!this.length) return var hasScrollLeft = 'scrollLeft' in this[0] if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset return this.each(hasScrollLeft ? function()&#123; this.scrollLeft = value &#125; : function()&#123; this.scrollTo(value, this.scrollY) &#125;) &#125;, position: function() &#123; if (!this.length) return var elem = this[0], // Get *real* offsetParent offsetParent = this.offsetParent(), // Get correct offsets offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123; top: 0, left: 0 &#125; : offsetParent.offset() // Subtract element margins // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat( $(elem).css('margin-top') ) || 0 offset.left -= parseFloat( $(elem).css('margin-left') ) || 0 // Add offsetParent borders parentOffset.top += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0 parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0 // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125; &#125;, offsetParent: function() &#123; return this.map(function()&#123; var parent = this.offsetParent || document.body while (parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css(\"position\") == \"static\") parent = parent.offsetParent return parent &#125;) &#125; &#125; // for now $.fn.detach = $.fn.remove // Generate the `width` and `height` functions ;['width', 'height'].forEach(function(dimension)&#123; var dimensionProperty = dimension.replace(/./, function(m)&#123; return m[0].toUpperCase() &#125;) $.fn[dimension] = function(value)&#123; var offset, el = this[0] if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) &amp;&amp; offset[dimension] else return this.each(function(idx)&#123; el = $(this) el.css(dimension, funcArg(this, value, idx, el[dimension]())) &#125;) &#125; &#125;) function traverseNode(node, fun) &#123; fun(node) for (var i = 0, len = node.childNodes.length; i &lt; len; i++) traverseNode(node.childNodes[i], fun) &#125; // Generate the `after`, `prepend`, `before`, `append`, // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods. adjacencyOperators.forEach(function(operator, operatorIndex) &#123; var inside = operatorIndex % 2 //=&gt; prepend, append $.fn[operator] = function()&#123; // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings var argType, nodes = $.map(arguments, function(arg) &#123; var arr = [] argType = type(arg) if (argType == \"array\") &#123; arg.forEach(function(el) &#123; if (el.nodeType !== undefined) return arr.push(el) else if ($.zepto.isZ(el)) return arr = arr.concat(el.get()) arr = arr.concat(zepto.fragment(el)) &#125;) return arr &#125; return argType == \"object\" || arg == null ? arg : zepto.fragment(arg) &#125;), parent, copyByClone = this.length &gt; 1 if (nodes.length &lt; 1) return this return this.each(function(_, target)&#123; parent = inside ? target : target.parentNode // convert all methods to a \"before\" operation target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null var parentInDocument = $.contains(document.documentElement, parent) nodes.forEach(function(node)&#123; if (copyByClone) node = node.cloneNode(true) else if (!parent) return $(node).remove() parent.insertBefore(node, target) if (parentInDocument) traverseNode(node, function(el)&#123; if (el.nodeName != null &amp;&amp; el.nodeName.toUpperCase() === 'SCRIPT' &amp;&amp; (!el.type || el.type === 'text/javascript') &amp;&amp; !el.src)&#123; var target = el.ownerDocument ? el.ownerDocument.defaultView : window target['eval'].call(target, el.innerHTML) &#125; &#125;) &#125;) &#125;) &#125; // after =&gt; insertAfter // prepend =&gt; prependTo // before =&gt; insertBefore // append =&gt; appendTo $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html)&#123; $(html)[operator](this) return this &#125; &#125;) zepto.Z.prototype = Z.prototype = $.fn // Export internal API functions in the `$.zepto` namespace zepto.uniq = uniq zepto.deserializeValue = deserializeValue $.zepto = zepto return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto)// zepto的事件代码;(function($)&#123; var _zid = 1, undefined, slice = Array.prototype.slice, isFunction = $.isFunction, isString = function(obj)&#123; return typeof obj == 'string' &#125;, handlers = &#123;&#125;, specialEvents=&#123;&#125;, focusinSupported = 'onfocusin' in window, focus = &#123; focus: 'focusin', blur: 'focusout' &#125;, hover = &#123; mouseenter: 'mouseover', mouseleave: 'mouseout' &#125; specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents' function zid(element) &#123; return element._zid || (element._zid = _zid++) &#125; function findHandlers(element, event, fn, selector) &#123; event = parse(event) if (event.ns) var matcher = matcherFor(event.ns) return (handlers[zid(element)] || []).filter(function(handler) &#123; return handler &amp;&amp; (!event.e || handler.e == event.e) &amp;&amp; (!event.ns || matcher.test(handler.ns)) &amp;&amp; (!fn || zid(handler.fn) === zid(fn)) &amp;&amp; (!selector || handler.sel == selector) &#125;) &#125; function parse(event) &#123; var parts = ('' + event).split('.') return &#123;e: parts[0], ns: parts.slice(1).sort().join(' ')&#125; &#125; function matcherFor(ns) &#123; return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)') &#125; function eventCapture(handler, captureSetting) &#123; return handler.del &amp;&amp; (!focusinSupported &amp;&amp; (handler.e in focus)) || !!captureSetting &#125; function realEvent(type) &#123; return hover[type] || (focusinSupported &amp;&amp; focus[type]) || type &#125; function add(element, events, fn, data, selector, delegator, capture)&#123; var id = zid(element), set = (handlers[id] || (handlers[id] = [])) events.split(/\\s/).forEach(function(event)&#123; if (event == 'ready') return $(document).ready(fn) var handler = parse(event) handler.fn = fn handler.sel = selector // emulate mouseenter, mouseleave if (handler.e in hover) fn = function(e)&#123; var related = e.relatedTarget if (!related || (related !== this &amp;&amp; !$.contains(this, related))) return handler.fn.apply(this, arguments) &#125; handler.del = delegator var callback = delegator || fn handler.proxy = function(e)&#123; e = compatible(e) if (e.isImmediatePropagationStopped()) return e.data = data var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args)) if (result === false) e.preventDefault(), e.stopPropagation() return result &#125; handler.i = set.length set.push(handler) if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125; function remove(element, events, fn, selector, capture)&#123; var id = zid(element) ;(events || '').split(/\\s/).forEach(function(event)&#123; findHandlers(element, event, fn, selector).forEach(function(handler)&#123; delete handlers[id][handler.i] if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125;) &#125; $.event = &#123; add: add, remove: remove &#125; $.proxy = function(fn, context) &#123; var args = (2 in arguments) &amp;&amp; slice.call(arguments, 2) if (isFunction(fn)) &#123; var proxyFn = function()&#123; return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) &#125; proxyFn._zid = zid(fn) return proxyFn &#125; else if (isString(context)) &#123; if (args) &#123; args.unshift(fn[context], fn) return $.proxy.apply(null, args) &#125; else &#123; return $.proxy(fn[context], fn) &#125; &#125; else &#123; throw new TypeError(\"expected function\") &#125; &#125; $.fn.bind = function(event, data, callback)&#123; return this.on(event, data, callback) &#125; $.fn.unbind = function(event, callback)&#123; return this.off(event, callback) &#125; $.fn.one = function(event, selector, data, callback)&#123; return this.on(event, selector, data, callback, 1) &#125; var returnTrue = function()&#123;return true&#125;, returnFalse = function()&#123;return false&#125;, ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/, eventMethods = &#123; preventDefault: 'isDefaultPrevented', stopImmediatePropagation: 'isImmediatePropagationStopped', stopPropagation: 'isPropagationStopped' &#125; function compatible(event, source) &#123; if (source || !event.isDefaultPrevented) &#123; source || (source = event) $.each(eventMethods, function(name, predicate) &#123; var sourceMethod = source[name] event[name] = function()&#123; this[predicate] = returnTrue return sourceMethod &amp;&amp; sourceMethod.apply(source, arguments) &#125; event[predicate] = returnFalse &#125;) event.timeStamp || (event.timeStamp = Date.now()) if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault &amp;&amp; source.getPreventDefault()) event.isDefaultPrevented = returnTrue &#125; return event &#125; function createProxy(event) &#123; var key, proxy = &#123; originalEvent: event &#125; for (key in event) if (!ignoreProperties.test(key) &amp;&amp; event[key] !== undefined) proxy[key] = event[key] return compatible(proxy, event) &#125; $.fn.delegate = function(selector, event, callback)&#123; return this.on(event, selector, callback) &#125; $.fn.undelegate = function(selector, event, callback)&#123; return this.off(event, selector, callback) &#125; $.fn.live = function(event, callback)&#123; $(document.body).delegate(this.selector, event, callback) return this &#125; $.fn.die = function(event, callback)&#123; $(document.body).undelegate(this.selector, event, callback) return this &#125; $.fn.on = function(event, selector, data, callback, one)&#123; var autoRemove, delegator, $this = this if (event &amp;&amp; !isString(event)) &#123; $.each(event, function(type, fn)&#123; $this.on(type, selector, data, fn, one) &#125;) return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = data, data = selector, selector = undefined if (callback === undefined || data === false) callback = data, data = undefined if (callback === false) callback = returnFalse return $this.each(function(_, element)&#123; if (one) autoRemove = function(e)&#123; remove(element, e.type, callback) return callback.apply(this, arguments) &#125; if (selector) delegator = function(e)&#123; var evt, match = $(e.target).closest(selector, element).get(0) if (match &amp;&amp; match !== element) &#123; evt = $.extend(createProxy(e), &#123;currentTarget: match, liveFired: element&#125;) return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1))) &#125; &#125; add(element, event, callback, data, selector, delegator || autoRemove) &#125;) &#125; $.fn.off = function(event, selector, callback)&#123; var $this = this if (event &amp;&amp; !isString(event)) &#123; $.each(event, function(type, fn)&#123; $this.off(type, selector, fn) &#125;) return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = selector, selector = undefined if (callback === false) callback = returnFalse return $this.each(function()&#123; remove(this, event, callback, selector) &#125;) &#125; $.fn.trigger = function(event, args)&#123; event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event) event._args = args return this.each(function()&#123; // handle focus(), blur() by calling them directly if (event.type in focus &amp;&amp; typeof this[event.type] == \"function\") this[event.type]() // items in the collection might not be DOM elements else if ('dispatchEvent' in this) this.dispatchEvent(event) else $(this).triggerHandler(event, args) &#125;) &#125; // triggers event handlers on current element just as if an event occurred, // doesn't trigger an actual event, doesn't bubble $.fn.triggerHandler = function(event, args)&#123; var e, result this.each(function(i, element)&#123; e = createProxy(isString(event) ? $.Event(event) : event) e._args = args e.target = element $.each(findHandlers(element, event.type || event), function(i, handler)&#123; result = handler.proxy(e) if (e.isImmediatePropagationStopped()) return false &#125;) &#125;) return result &#125; // shortcut methods for `.bind(event, fn)` for each event type ;('focusin focusout focus blur load resize scroll unload click dblclick '+ 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+ 'change select keydown keypress keyup error').split(' ').forEach(function(event) &#123; $.fn[event] = function(callback) &#123; return (0 in arguments) ? this.bind(event, callback) : this.trigger(event) &#125; &#125;) $.Event = function(type, props) &#123; if (!isString(type)) props = type, type = props.type var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name]) event.initEvent(type, bubbles, true) return compatible(event) &#125;&#125;)(Zepto)// zepto的AJAX代码;(function($)&#123; var jsonpID = +new Date(), document = window.document, key, name, rscript = /&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;/gi, scriptTypeRE = /^(?:text|application)\\/javascript/i, xmlTypeRE = /^(?:text|application)\\/xml/i, jsonType = 'application/json', htmlType = 'text/html', blankRE = /^\\s*$/, originAnchor = document.createElement('a') originAnchor.href = window.location.href // trigger a custom event and return false if it was cancelled function triggerAndReturn(context, eventName, data) &#123; var event = $.Event(eventName) $(context).trigger(event, data) return !event.isDefaultPrevented() &#125; // trigger an Ajax \"global\" event function triggerGlobal(settings, context, eventName, data) &#123; if (settings.global) return triggerAndReturn(context || document, eventName, data) &#125; // Number of active Ajax requests $.active = 0 function ajaxStart(settings) &#123; if (settings.global &amp;&amp; $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart') &#125; function ajaxStop(settings) &#123; if (settings.global &amp;&amp; !(--$.active)) triggerGlobal(settings, null, 'ajaxStop') &#125; // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable function ajaxBeforeSend(xhr, settings) &#123; var context = settings.context if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]) &#125; function ajaxSuccess(data, xhr, settings, deferred) &#123; var context = settings.context, status = 'success' settings.success.call(context, data, status, xhr) if (deferred) deferred.resolveWith(context, [data, status, xhr]) triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]) ajaxComplete(status, xhr, settings) &#125; // type: \"timeout\", \"error\", \"abort\", \"parsererror\" function ajaxError(error, type, xhr, settings, deferred) &#123; var context = settings.context settings.error.call(context, xhr, type, error) if (deferred) deferred.rejectWith(context, [xhr, type, error]) triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]) ajaxComplete(type, xhr, settings) &#125; // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\" function ajaxComplete(status, xhr, settings) &#123; var context = settings.context settings.complete.call(context, xhr, status) triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]) ajaxStop(settings) &#125; function ajaxDataFilter(data, type, settings) &#123; if (settings.dataFilter == empty) return data var context = settings.context return settings.dataFilter.call(context, data, type) &#125; // Empty function, used as default callback function empty() &#123;&#125; $.ajaxJSONP = function(options, deferred)&#123; if (!('type' in options)) return $.ajax(options) var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)), script = document.createElement('script'), originalCallback = window[callbackName], responseData, abort = function(errorType) &#123; $(script).triggerHandler('error', errorType || 'abort') &#125;, xhr = &#123; abort: abort &#125;, abortTimeout if (deferred) deferred.promise(xhr) $(script).on('load error', function(e, errorType)&#123; clearTimeout(abortTimeout) $(script).off().remove() if (e.type == 'error' || !responseData) &#123; ajaxError(null, errorType || 'error', xhr, options, deferred) &#125; else &#123; ajaxSuccess(responseData[0], xhr, options, deferred) &#125; window[callbackName] = originalCallback if (responseData &amp;&amp; $.isFunction(originalCallback)) originalCallback(responseData[0]) originalCallback = responseData = undefined &#125;) if (ajaxBeforeSend(xhr, options) === false) &#123; abort('abort') return xhr &#125; window[callbackName] = function()&#123; responseData = arguments &#125; script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName) document.head.appendChild(script) if (options.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; abort('timeout') &#125;, options.timeout) return xhr &#125; $.ajaxSettings = &#123; // Default type of request type: 'GET', // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // The context for the callbacks context: null, // Whether to trigger \"global\" Ajax events global: true, // Transport xhr: function () &#123; return new window.XMLHttpRequest() &#125;, // MIME types mapping // IIS returns Javascript as \"application/x-javascript\" accepts: &#123; script: 'text/javascript, application/javascript, application/x-javascript', json: jsonType, xml: 'application/xml, text/xml', html: htmlType, text: 'text/plain' &#125;, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty &#125; function mimeToDataType(mime) &#123; if (mime) mime = mime.split(';', 2)[0] return mime &amp;&amp; ( mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) &amp;&amp; 'xml' ) || 'text' &#125; function appendQuery(url, query) &#123; if (query == '') return url return (url + '&amp;' + query).replace(/[&amp;?]&#123;1,2&#125;/, '?') &#125; // serialize payload and append it to the URL for GET requests function serializeData(options) &#123; if (options.processData &amp;&amp; options.data &amp;&amp; $.type(options.data) != \"string\") options.data = $.param(options.data, options.traditional) if (options.data &amp;&amp; (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined &#125; $.ajax = function(options)&#123; var settings = $.extend(&#123;&#125;, options || &#123;&#125;), deferred = $.Deferred &amp;&amp; $.Deferred(), urlAnchor, hashIndex for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key] ajaxStart(settings) if (!settings.crossDomain) &#123; urlAnchor = document.createElement('a') urlAnchor.href = settings.url // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049 urlAnchor.href = urlAnchor.href settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host) &#125; if (!settings.url) settings.url = window.location.toString() if ((hashIndex = settings.url.indexOf('#')) &gt; -1) settings.url = settings.url.slice(0, hashIndex) serializeData(settings) var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url) if (hasPlaceholder) dataType = 'jsonp' if (settings.cache === false || ( (!options || options.cache !== true) &amp;&amp; ('script' == dataType || 'jsonp' == dataType) )) settings.url = appendQuery(settings.url, '_=' + Date.now()) if ('jsonp' == dataType) &#123; if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?') return $.ajaxJSONP(settings, deferred) &#125; var mime = settings.accepts[dataType], headers = &#123; &#125;, setHeader = function(name, value) &#123; headers[name.toLowerCase()] = [name, value] &#125;, protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol, xhr = settings.xhr(), nativeSetHeader = xhr.setRequestHeader, abortTimeout if (deferred) deferred.promise(xhr) if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest') setHeader('Accept', mime || '*/*') if (mime = settings.mimeType || mime) &#123; if (mime.indexOf(',') &gt; -1) mime = mime.split(',', 2)[0] xhr.overrideMimeType &amp;&amp; xhr.overrideMimeType(mime) &#125; if (settings.contentType || (settings.contentType !== false &amp;&amp; settings.data &amp;&amp; settings.type.toUpperCase() != 'GET')) setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded') if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name]) xhr.setRequestHeader = setHeader xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; xhr.onreadystatechange = empty clearTimeout(abortTimeout) var result, error = false if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 || (xhr.status == 0 &amp;&amp; protocol == 'file:')) &#123; dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type')) if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob') result = xhr.response else &#123; result = xhr.responseText try &#123; // http://perfectionkills.com/global-eval-what-are-the-options/ // sanitize response accordingly if data filter callback provided result = ajaxDataFilter(result, dataType, settings) if (dataType == 'script') (1,eval)(result) else if (dataType == 'xml') result = xhr.responseXML else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result) &#125; catch (e) &#123; error = e &#125; if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred) &#125; ajaxSuccess(result, xhr, settings, deferred) &#125; else &#123; ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred) &#125; &#125; &#125; if (ajaxBeforeSend(xhr, settings) === false) &#123; xhr.abort() ajaxError(null, 'abort', xhr, settings, deferred) return xhr &#125; var async = 'async' in settings ? settings.async : true xhr.open(settings.type, settings.url, async, settings.username, settings.password) if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name] for (name in headers) nativeSetHeader.apply(xhr, headers[name]) if (settings.timeout &gt; 0) abortTimeout = setTimeout(function()&#123; xhr.onreadystatechange = empty xhr.abort() ajaxError(null, 'timeout', xhr, settings, deferred) &#125;, settings.timeout) // avoid sending empty string (#319) xhr.send(settings.data ? settings.data : null) return xhr &#125; // handle optional data/success arguments function parseArguments(url, data, success, dataType) &#123; if ($.isFunction(data)) dataType = success, success = data, data = undefined if (!$.isFunction(success)) dataType = success, success = undefined return &#123; url: url , data: data , success: success , dataType: dataType &#125; &#125; $.get = function(/* url, data, success, dataType */)&#123; return $.ajax(parseArguments.apply(null, arguments)) &#125; $.post = function(/* url, data, success, dataType */)&#123; var options = parseArguments.apply(null, arguments) options.type = 'POST' return $.ajax(options) &#125; $.getJSON = function(/* url, data, success */)&#123; var options = parseArguments.apply(null, arguments) options.dataType = 'json' return $.ajax(options) &#125; $.fn.load = function(url, data, success)&#123; if (!this.length) return this var self = this, parts = url.split(/\\s/), selector, options = parseArguments(url, data, success), callback = options.success if (parts.length &gt; 1) options.url = parts[0], selector = parts[1] options.success = function(response)&#123; self.html(selector ? $('&lt;div&gt;').html(response.replace(rscript, \"\")).find(selector) : response) callback &amp;&amp; callback.apply(self, arguments) &#125; $.ajax(options) return this &#125; var escape = encodeURIComponent function serialize(params, obj, traditional, scope)&#123; var type, array = $.isArray(obj), hash = $.isPlainObject(obj) $.each(obj, function(key, value) &#123; type = $.type(value) if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']' // handle data in serializeArray() format if (!scope &amp;&amp; array) params.add(value.name, value.value) // recurse into nested objects else if (type == \"array\" || (!traditional &amp;&amp; type == \"object\")) serialize(params, value, traditional, key) else params.add(key, value) &#125;) &#125; $.param = function(obj, traditional)&#123; var params = [] params.add = function(key, value) &#123; if ($.isFunction(value)) value = value() if (value == null) value = \"\" this.push(escape(key) + '=' + escape(value)) &#125; serialize(params, obj, traditional) return params.join('&amp;').replace(/%20/g, '+') &#125;&#125;)(Zepto)// zepro的form表单处理;(function($)&#123; $.fn.serializeArray = function() &#123; var name, type, result = [], add = function(value) &#123; if (value.forEach) return value.forEach(add) result.push(&#123; name: name, value: value &#125;) &#125; if (this[0]) $.each(this[0].elements, function(_, field)&#123; type = field.type, name = field.name if (name &amp;&amp; field.nodeName.toLowerCase() != 'fieldset' &amp;&amp; !field.disabled &amp;&amp; type != 'submit' &amp;&amp; type != 'reset' &amp;&amp; type != 'button' &amp;&amp; type != 'file' &amp;&amp; ((type != 'radio' &amp;&amp; type != 'checkbox') || field.checked)) add($(field).val()) &#125;) return result &#125; $.fn.serialize = function()&#123; var result = [] this.serializeArray().forEach(function(elm)&#123; result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value)) &#125;) return result.join('&amp;') &#125; $.fn.submit = function(callback) &#123; if (0 in arguments) this.bind('submit', callback) else if (this.length) &#123; var event = $.Event('submit') this.eq(0).trigger(event) if (!event.isDefaultPrevented()) this.get(0).submit() &#125; return this &#125;&#125;)(Zepto);(function()&#123; // getComputedStyle shouldn't freak out when called // without a valid element as argument try &#123; getComputedStyle(undefined) &#125; catch(e) &#123; var nativeGetComputedStyle = getComputedStyle window.getComputedStyle = function(element, pseudoElement)&#123; try &#123; return nativeGetComputedStyle(element, pseudoElement) &#125; catch(e) &#123; return null &#125; &#125; &#125;&#125;)() return Zepto&#125;))","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"javascript获取数据类型","slug":"javascript获取数据类型","date":"2018-11-14T02:45:29.000Z","updated":"2019-01-10T02:29:05.470Z","comments":true,"path":"2018/11/14/javascript获取数据类型/","link":"","permalink":"/2018/11/14/javascript获取数据类型/","excerpt":"判断js的数据类型，如：Boolean Number String等","text":"判断js的数据类型，如：Boolean Number String等 javascript获取数据类型平时在工作中，偶尔会用到判断一下这个数据是什么类型，是数组的？string的？function的？我一般都直接按照代码的需求，只写了需要判断的类型，用完就丢到一边，最近在看jquery源码，人家大牛写的真不错，改一改，封装一下，自己用哈。话不多说，直接贴出代码，其实很简单的：123456789101112131415161718function toType( obj ) &#123; var class2type = &#123;&#125;, toString = class2type.toString; \"Boolean Number String Function Array Date RegExp Object Error Symbol\" .split( \" \" ) .forEach(function( name ) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase(); &#125;); if ( obj == null ) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ toString.call( obj ) ] || \"object\" : typeof obj; &#125; 代码一共没有几行，接下来看看管不管用12345678910111213// 测试一下console.log('对象的类型-&gt;',toType(&#123;&#125;));console.log('函数的类型-&gt;',toType(function()&#123;&#125;));console.log('null的类型-&gt;',toType(null));console.log('undefined的类型-&gt;',toType(undefined));console.log('boolean的类型-&gt;',toType(true));console.log('number的类型-&gt;',toType(555));console.log('string的类型-&gt;',toType('abc'));console.log('array的类型-&gt;',toType([]));console.log('date的类型-&gt;',toType(new Date()));console.log('正则的类型-&gt;',toType(/abc/g));console.log('symbol-&gt;',toType(Symbol()));console.log('Error的类型-&gt;',toType(new Error())); 基本上的类型都判断出来了，不错吧。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"tcp三次握手和四次挥手","slug":"tcp三次握手和四次挥手","date":"2018-11-07T06:34:14.000Z","updated":"2018-11-07T06:58:56.835Z","comments":true,"path":"2018/11/07/tcp三次握手和四次挥手/","link":"","permalink":"/2018/11/07/tcp三次握手和四次挥手/","excerpt":"我的tcp三次握手和四次挥手简洁理解。","text":"我的tcp三次握手和四次挥手简洁理解。 tcp三次握手和四次挥手tcp三次握手和四次挥手，这是一个很基础的计算机网络层面的基础问题，让我回答我也说不出来具体的东西，所以，为了加强记忆，按照自己的理解，把它记下来。 三次握手我们用打电话的生活场景来模拟三次握手：123client: 你好，能听到我说话吗？server：能听到，你能听到我说话吗？client：是的，我也能听到你说话。 像上面这样，来回通过3次对话，确认了双方都可以接收到相互的信息。 四次挥手我们还用打电话的生活场景来模拟四次挥手：1234client: 我有事，不跟你聊了哈。server：知道了。server：最后说一句，明天把书给我带来。client：好的，知道了。 好了，四次挥手也模拟完了。我这只是模拟了这两个过程而已，如果想学习真正的原理，请参考这里","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js抽象语法树AST","slug":"js抽象语法树AST","date":"2018-11-06T07:48:54.000Z","updated":"2018-11-06T09:02:14.113Z","comments":true,"path":"2018/11/06/js抽象语法树AST/","link":"","permalink":"/2018/11/06/js抽象语法树AST/","excerpt":"通过javascript parser将代码转化成抽象语法树，这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。","text":"通过javascript parser将代码转化成抽象语法树，这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。 js抽象语法树AST最近在研究webpack，想研究一下它是如何打包的，不过，刚刚入门，就有一个知识点把我难住了，那就是AST抽象语法树。于是乎，上网查了查，原理就是把代码解析，解析成一个有各种属性状态的json树，便于对代码进行操作，具体的解析代码当然是很难的，像我们这种菜鸟只需要了解一下用法就可以了。babel是现在几乎每个项目中必备的一个东西，但是其工作原理避不开对js的解析在生成的过程，babel有引擎babylon，早期fork了项目acron，了解这个之前我们先来看看这种引擎解析出来是什么东西。不光是babel还有webpack等。 什么是抽象语法树见下面例子：12var a = 1;var b = a + 1; 之后我们通过这个网站，他是一个esprima引擎的网站，十分好用.画成流程图如下：而他的json对象格式是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"VariableDeclaration\", \"declarations\": [ &#123; \"type\": \"VariableDeclarator\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"init\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; ], \"kind\": \"var\" &#125;, &#123; \"type\": \"VariableDeclaration\", \"declarations\": [ &#123; \"type\": \"VariableDeclarator\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"b\" &#125;, \"init\": &#123; \"type\": \"BinaryExpression\", \"operator\": \"+\", \"left\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"right\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; &#125; ], \"kind\": \"var\" &#125; ], \"sourceType\": \"script\"&#125; 众多AST解析引擎chrome有v8，firefix有spidermonkey.还有一些常用的引擎有： esprima acron Traceur UglifyJS2 shift AST的学习三板斧 通过esprima生成AST 通过estraverse遍历和更新AST 通过escodegen将AST重新生成源码 来一个简单例子，看看用法：1.先新建一个test的工程目录2.在test工程下安装esprima、estraverse、escodegen的npm模块1npm i esprima estraverse escodegen --save 3.在目录下面新建一个test.js文件,载入以下代码：1234const esprima = require('esprima');let code = 'const a = 1';const ast = esprima.parseScript(code);console.log(ast); 你将会看到输出结果：12345678Script &#123; type: 'Program', body: [ VariableDeclaration &#123; type: 'VariableDeclaration', declarations: [Array], kind: 'const' &#125; ], sourceType: 'script' &#125; 4.再在test文件中，载入以下代码：12345678const estraverse = require('estraverse');estraverse.traverse(ast, &#123; enter: function (node) &#123; node.kind = \"var\"; &#125;&#125;);console.log(ast); 输出的结果：12345678Script &#123; type: 'Program', body: [ VariableDeclaration &#123; type: 'VariableDeclaration', declarations: [Array], kind: 'var' &#125; ], sourceType: 'script' &#125; 5.最后在test文件中，加入以下代码：123const escodegen = require(\"escodegen\");const transformCode = escodegen.generate(ast)console.log(transformCode); 输出的结果：1var a = 1; 通过这三步，我们将const a = 1转化成了var a = 1 虽然，具体的解析原理我们并不知道，但是，通过这三个模块包，是不是有种自己搞出一个babel的赶脚。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"},{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"对象链式取值(如loadsh的_.get()方法)在项目中的应用","slug":"对象链式取值-如loadsh的-get-方法-在项目中的应用","date":"2018-11-05T05:27:11.000Z","updated":"2018-11-05T06:15:20.933Z","comments":true,"path":"2018/11/05/对象链式取值-如loadsh的-get-方法-在项目中的应用/","link":"","permalink":"/2018/11/05/对象链式取值-如loadsh的-get-方法-在项目中的应用/","excerpt":"对象的链式取值在项目中的应用场景。","text":"对象的链式取值在项目中的应用场景。 对象链式取值(如loadsh的_.get()方法)在项目中的应用相信大家在从后端获取数据的时候，像这样res.data.rows.count来获取数据的情况很多，如果后台返回的格式不对了，或则data是个null，那么很容易报Uncaught TypeError: Cannot read property ‘goods’ of undefined这样的错。我们一般会这样写：123if(res &amp;&amp; res.data &amp;&amp; res.data.rows &amp;&amp; res.data.count) &#123; ...&#125; 不过这么写实在是有些麻烦，我一般的做法是直接catch住error，然后定位到具体错误在哪，在改正。不过，最近在网上看到一篇专门写关于对象的链式取值的文章，里边写了大概4种解决方法，这里我只记录学习了其中一种，也是兼容性最好的一种，就想使用loadsh的_.get方法，先看看loadsh是怎么用的，见下边1234567var object = &#123; 'a': [&#123; 'b': &#123; 'c': 3 &#125; &#125;] &#125;;_.get(object, 'a[0].b.c');// =&gt; 3_.get(object, ['a', '0', 'b', 'c']);// =&gt; 3_.get(object, 'a.b.c', 'default');// =&gt; 'default' 使用方法一目了然，第一个参数：对象，第二个参数：链式字符串，第三个参数是，如果按照这个链式字符串在对象中取不到值，返回这个默认值。这样写的话，就像上边即使后台同事更改了数据结构，不会报错，而是返回默认值。（不过这种写法我觉得也有不好的地方，那就是不容易发现错误，后台返回的数据结构都变了，而我们前台并没有出现异常，而是返回来初始写的默认值，是不是有点。。。）不过，这种写法在其它场合我想一定会有用武之地。我现在的项目中并没有用到loadsh这个库，但是还想用咋办呢？自己写一个喽，还好，写法简单，容易理解，注意，下边给出的代码交通过函数解析字符串方式来处理的。1234567891011121314151617181920212223242526272829function get (obj, props, def) &#123; if((obj == null) || obj == null || typeof props !== 'string') return def; const temp = props.split('.'); const fieldArr = [].concat(temp); temp.forEach((e, i) =&gt; &#123; if(/^(\\w+)\\[(\\w+)\\]$/.test(e)) &#123; const matchs = e.match(/^(\\w+)\\[(\\w+)\\]$/); const field1 = matchs[1]; const field2 = matchs[2]; const index = fieldArr.indexOf(e); fieldArr.splice(index, 1, field1, field2); &#125; &#125;) return fieldArr.reduce((pre, cur) =&gt; &#123; const target = pre[cur] || def; if(target instanceof Array) &#123; return [].concat(target); &#125; if(target instanceof Object) &#123; return Object.assign(&#123;&#125;, target) &#125; return target; &#125;, obj)&#125;var c = &#123;a: &#123;b : [1,2,3] &#125;&#125;get(c ,'a.b') // [1,2,3]get(c, 'a.b[1]') // 2get(c, 'a.d', 12) // 12 其实，在项目无论如何使用都没什么问题，即使什么都不做，最后项目完成时，也一定会因为出现报错而改正过来，最多就是不够健壮。我觉得这个函数解析字符串的方式很好，值得举一反三，值得学习。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"webpack打包bundle.js文件代码分析","slug":"webpack打包bundle-js文件代码分析","date":"2018-11-01T06:16:54.000Z","updated":"2018-11-01T08:31:47.325Z","comments":true,"path":"2018/11/01/webpack打包bundle-js文件代码分析/","link":"","permalink":"/2018/11/01/webpack打包bundle-js文件代码分析/","excerpt":"webpack这个打包工具，现在可以说很火，前一段时间为了优化公司项目，搞了一个月的gulp，说实在的，gulp的功能我感觉很强大了，而且用起来很灵活，最关键是简单，需要什么的时候直接弄个gulp任务，但是，使用场景很少了，由于之前的项目是php的，现在一般都用vue，react等，都已经集成了webpack，虽然说不用太多配置，但是需要配置的时候还是有的，所以，webpack研究一下也是有必要的，今天，复杂的先不说，只说说bundle.js这个文件里的代码都是干吗用的。","text":"webpack这个打包工具，现在可以说很火，前一段时间为了优化公司项目，搞了一个月的gulp，说实在的，gulp的功能我感觉很强大了，而且用起来很灵活，最关键是简单，需要什么的时候直接弄个gulp任务，但是，使用场景很少了，由于之前的项目是php的，现在一般都用vue，react等，都已经集成了webpack，虽然说不用太多配置，但是需要配置的时候还是有的，所以，webpack研究一下也是有必要的，今天，复杂的先不说，只说说bundle.js这个文件里的代码都是干吗用的。 webpack打包bundle.js文件代码分析一个入口，一个文件首先，webpack.config.js配置文件是这样滴：123456module.exports = &#123; entry:'./index.js', output:&#123; filename:'bundle.js' &#125;&#125;; index.js内容是这样滴：1console.log('index'); 最后再看看打完包后的bundle.js内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// bundle.js/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports) &#123; console.log('index');/***/ &#125;/******/ ]); 我们来分析一下bundle.js这个文件 1.整个内容是一个自执行函数，自执行函数传的参数是一个数组，数组里的元素是function函数，这个函数体的内容就是index.js文件的内容。 2.在这个闭包函数中，__webpack_require_是模块加载函数，接收模块id（对，webpack中每个模块都会有一个独一无二的id，其实也就是在IIFE传参数组中的索引值（0，1，2…..）。 3.真正执行module index里面语句的是个调用12// Execute the module functionmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__); 我们再来看一个例子 一个入口，两个文件，A依赖B先贴出文件内容：123456// a.jsvar b = require('./b.js');console.log('a');b.b1(); 12345678// b.jsexports.b1 = function () &#123; console.log('b1')&#125;;exports.b2 = function () &#123; console.log('b2')&#125;; 1234567891011121314151617181920212223242526272829303132// bundle.js/******/ (function(modules) &#123; // webpackBootstrap// 省略一大段.........../******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; var b = __webpack_require__(1); console.log('a'); b.b1();/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; exports.b1 = function () &#123; console.log('b1') &#125;; exports.b2 = function () &#123; console.log('b2') &#125;;/***/ &#125;/******/ ]); 我们再来分析一下上面的代码。 1.由于有两个文件，所以IIFE得参数为长度是2的数组，并按照require的顺序排列。 2.IIFE函数体部分是一模一样的，也就是说再复杂的，多个依赖的文件，函数体部分也不变滴。 3.module a发生了变化，因为a依赖b，所以在a中调用webpack加载模块的函数 12// 1是模块b的idvar b = __webpack_require__(1); 4.我们再来分析一下modules[moduleId].call(module.exports, module, module.exports, webpack_require);使用call是因为为了确保每个module中的this指向的是module本身。然后给它传__webpack_require函数是想让module有加载其他module的能力。 其它情况其它的情况，比如多入口，多出口情况这里就不做过多分析，我也没搞明白，接下来准备手写一个简单的仿webpack打包工具。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"移动端webview模板","slug":"移动端webview模板","date":"2018-10-30T02:29:58.000Z","updated":"2019-02-02T02:05:38.715Z","comments":true,"path":"2018/10/30/移动端webview模板/","link":"","permalink":"/2018/10/30/移动端webview模板/","excerpt":"移动端的页面平时偶尔会有需求需要做，特别是webview嵌入的页面居多，由于是有时候做，有时候不做，所以，需求来的时候从新写页面还是有点麻烦，所以把之前写的记录一下，下次直接copy就好了。","text":"移动端的页面平时偶尔会有需求需要做，特别是webview嵌入的页面居多，由于是有时候做，有时候不做，所以，需求来的时候从新写页面还是有点麻烦，所以把之前写的记录一下，下次直接copy就好了。 移动端webview模板css一些css初始化的内容123456789101112131415161718192021222324252627@charset \"utf-8\";/* CSS Document */body,ul,ol,p,h1,h2,h3,h4,h5,dl,dd,form,input,textarea,td,th,button,strong,em,select,video,canvas&#123;margin:0;padding:0;&#125;h1,h2,h3,h4,h5,h6&#123; font-weight:normal;&#125;li&#123;list-style:none;vertical-align:top;&#125;table&#123; border-collapse:collapse;&#125;textarea&#123;resize:none;overflow:auto;&#125;img&#123; border:none; vertical-align:middle; width:100%;&#125;em,i&#123; font-style:normal;&#125;a&#123; text-decoration:none;&#125;a,input&#123; -webkit-appearance: none;/*屏蔽阴影*/ -webkit-tap-highlight-color:rgba(0,0,0,0); /*ios android去除自带阴影的样式*/&#125;a, img &#123; /* 禁止长按链接与图片弹出菜单 */ -webkit-touch-callout: none;&#125;html, body &#123; /* 禁止选中文本(如无文本选中需求,此为必选项) */ -webkit-user-select: none; user-select: none; background:#f5f5f5; overflow-x:hidden;&#125; js来控制rem大小代码js来修改html的font-size大小123456789101112(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth/20 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); html页面内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;&lt;meta content=\"email=no\" name=\"format-detection\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../js/config.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"content\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 判断ios android var u = navigator.userAgent; var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1; //android终端 var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 var goodsId = window.location.search.split('=')[1] var reqUrl = BASEURL +'/goods/shopProduct/findSpuDescsBySpuId/' + goodsId; $.ajax(&#123; method: 'POST', url: reqUrl, headers: &#123; 'client-token': 'eyJhbGciOiJIUzUxMiJ9.eyJ1aWQiOiIxMjMiLCJjZXJ0Tm8iOiI0NTYifQ.xTR4SG0z3Nuf-siW34XtVgqNPr9PRpPb8XFKY6Hrj_Qg8kl9C0AeVFcQ8NnguQ-SrlHHcv5M16SkjVYX3PKweg' &#125;, data: &#123;goodsId: goodsId&#125;, dataType: 'json', success: function(res)&#123; if(res.code === '0000') &#123; var innerContent = res.data; var bodyContent = $.parseHTML(innerContent); $('.content').append(bodyContent); if(isiOS) &#123; var imgNum = $('img').size(), loadCount=0; $('img').on('load', function(ev) &#123; loadCount++; if(loadCount === imgNum)&#123; // 获取到页面高度返给ios端 var bodyHeight = $('body').height() + 25; // 调取ios注入的方法 window.webkit.messageHandlers.jsCallNative.postMessage(&#123;height: bodyHeight&#125;); &#125; &#125;); &#125; &#125; &#125;, error: function() &#123;&#125;, &#125;);&lt;/script&gt;&lt;/html&gt; 这个webview页面相对麻烦些，需求是在ios页面的固定位置显示webview内容，并不是新开一个新页面来整个显示webview内容，这样ios需要获取h5页面的高，而页面的内容又是h5页面通过ajax获取回来的，所以，ajax请求成功后，将内容插入到页面中，如果有图片的话，等待图片全部加载之后再计算页面的高，返给ios。这时，ios提供了一个函数注入到h5页面里了，我们直接调用就可以，代码中就是这个函数window.webkit.messageHandlers.jsCallNative.postMessage(); 补充点这方面的知识2019/2/2123456789if(isiOS) &#123; // 如果是ios的话 window.webkit.messageHandlers.iosCallback.postMessage(null); // 我告诉ios端可以调我提供的callAppFnInfo函数，它会把值给我传过来。 function callAppFnInfo(info) &#123; alert(info); &#125;&#125;else &#123; // android环境 var da = window.WebViewInterface.getId(); // 直接调取android提供的方法，它可以直接返回值 alert(da);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js基础知识思维导图","slug":"js基础知识思维导图","date":"2018-10-29T05:50:50.000Z","updated":"2018-10-29T07:38:50.287Z","comments":true,"path":"2018/10/29/js基础知识思维导图/","link":"","permalink":"/2018/10/29/js基础知识思维导图/","excerpt":"在网上无意间发现了一套js基础的思维导图，赶紧收为己用，呵呵。","text":"在网上无意间发现了一套js基础的思维导图，赶紧收为己用，呵呵。 js基础知识思维导图1.变量 2.数组 3.运算符 4.流程语句 5.函数基础 6.字符串函数 7.基本dom操作 8.浏览器Bom对象 9.正则表达式","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"js类的继承(ES5写法)","slug":"js类的继承-ES5写法","date":"2018-10-23T01:30:30.000Z","updated":"2018-10-26T01:10:55.777Z","comments":true,"path":"2018/10/23/js类的继承-ES5写法/","link":"","permalink":"/2018/10/23/js类的继承-ES5写法/","excerpt":"js继承之终极继承寄生组合式继承","text":"js继承之终极继承寄生组合式继承 js类的继承(ES5写法)js的继承方式有很多，大致的罗列一下： 构造继承 原型链继承 组合继承 原型式继承 寄生式继承 寄生组合式继承这里只是列举了一些，还有很多其它方法，就不一一写出。在这些方法中，寄生组合式继承被认为是最好的，所以，只要记住这一种写法不就可以了吗。寄生组合式继承代码如下：123456789101112131415function inheritPrototype(Super,Sub)&#123; var superProtoClone = Object.Create(Super.prototype); superProtoClone.constructor = Sub; Sub.prototype = superProtoClone;&#125;function Super(name, age) &#123; this.name = name; this.age = age;&#125;function Sub(name, age, job)&#123; Super.call(this, name, age); Sub.job = job;&#125;inheritPrototype(Super,Sub);var s = new Sub('mike', 20); 这里用到了Object.Create方法，如果浏览器不兼容的话，顺便把兼容写法写出来：12345678910111213141516171819202122232425262728293031323334353637383940414243if (typeof Object.create != 'function') &#123; // Production steps of ECMA-262, Edition 5, 15.2.3.5 // Reference: http://es5.github.io/#x15.2.3.5 Object.create = (function() &#123; // To save on memory, use a shared constructor function Temp() &#123;&#125; // make a safe reference to Object.prototype.hasOwnProperty var hasOwn = Object.prototype.hasOwnProperty; return function (O) &#123; // 1. If Type(O) is not Object or Null throw a TypeError exception. if (typeof O != 'object') &#123; throw TypeError('Object prototype may only be an Object or null'); &#125; // 2. Let obj be the result of creating a new object as if by the // expression new Object() where Object is the standard built-in // constructor with that name // 3. Set the [[Prototype]] internal property of obj to O. Temp.prototype = O; var obj = new Temp(); Temp.prototype = null; // Let's not keep a stray reference to O... // 4. If the argument Properties is present and not undefined, add // own properties to obj as if by calling the standard built-in // function Object.defineProperties with arguments obj and // Properties. if (arguments.length &gt; 1) &#123; // Object.defineProperties does ToObject on its first argument. var Properties = Object(arguments[1]); for (var prop in Properties) &#123; if (hasOwn.call(Properties, prop)) &#123; obj[prop] = Properties[prop]; &#125; &#125; &#125; // 5. Return obj return obj; &#125;; &#125;)();&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"实现call函数","slug":"实现call函数","date":"2018-10-19T02:00:15.000Z","updated":"2018-10-19T06:03:10.245Z","comments":true,"path":"2018/10/19/实现call函数/","link":"","permalink":"/2018/10/19/实现call函数/","excerpt":"自己实现call函数","text":"自己实现call函数 实现call函数实现代码很简单，直接贴出来123456789101112131415161718Function.prototype.myCall = function(context) &#123; context.fn = this; var args = arguments, str=''; for(var i=1; i&lt;args.length; i++) &#123; str += (args[i]+','); &#125; var newStr = str.slice(0,(str.length-1)); eval('context.fn('+newStr+')');&#125;function abc(a,b) &#123; console.log(this.name+a+b);&#125;abc.myCall(&#123; name: 'join'&#125;,1,2);abc.myCall(&#123; name: 'mike'&#125;,3,4);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"ajax跨域请求自定义header字段问题","slug":"ajax跨域请求自定义header字段问题","date":"2018-10-16T03:14:48.000Z","updated":"2018-10-16T03:31:27.520Z","comments":true,"path":"2018/10/16/ajax跨域请求自定义header字段问题/","link":"","permalink":"/2018/10/16/ajax跨域请求自定义header字段问题/","excerpt":"Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX的处理办法","text":"Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX的处理办法 ajax跨域请求自定义header字段问题首先，在后端允许跨域请求的情况下，前端加上自定义的请求字段，如下123456789101112$.ajax(&#123; method: 'POST', url: reqUrl, headers: &#123; 'client-token': '123456' &#125;, data: &#123;goodsId: goodsId&#125;, dataType: 'json', success: function(res)&#123; &#125;, error: function() &#123;&#125;, &#125;); 客户端 按照上面的写，你需要处理的是 服务端 响应头的设置 1.第一步设置响应头123header('Access-Control-Allow-Origin:*'); //支持全域名访问，不安全，部署后需要固定限制为客户端网址header('Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE'); //支持的http 动作header('Access-Control-Allow-Headers:x-requested-with,content-type'); //响应头 请按照自己需求添加。 2.第二步了解IE chrome 等浏览器 对于 跨域请求并要求设置Headers自定义参数的时候的 “预请求” 就是如果遇到 跨域并设置headers的请求，所有请求需要两步完成！A 第一步：发送预请求 OPTIONS 请求。此时 服务器端需要对于OPTIONS请求作出响应 一般使用202响应即可 不用返回任何内容信息。（能看到这份手稿的人，本人不相信你后台处理不了一个options请求）B 第二步：服务器accepted 第一步请求后 浏览器自动执行第二步 发送真正的请求。此时 大多数人 会发现请求成功了，但是 有那么几个人会发现 请求成功了但是没有任何信息返回 why？因为你自定义的请求头在服务器响应中不存在！查看console输出 会发现一个问题：“Access-Control-Allow-Headers 列表中不存在请求标头 XXXXXX”【IE】，request header field xxxxxx is not allowed by Access-Control-Allow-Header【chrome】这是因为 你的XXXX请求头 没有在服务器端被允许哦~遇到这个问题 只有通过修改服务器端来完成，举例：需要设置 client-token这么一个自定义头，那么 你需要在 服务端里面 将header(‘Access-Control-Allow-Headers:x-requested-with,content-type，client-token’); 同学们自行体会吧 这种语法就是根据“,”分割 自己需要设置什么头，必须要在 服务端请求的响应头里面设置好，不然客户端永远永远提交不上去！至此 JavaScript/ajax 跨域+ 修改httpheader 任务完美实现。“人们都一直在抱怨 JavaScript同源策略限制了web前端的发展！然而是服务端做的不够细致！”","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"scratch介绍","slug":"scratch介绍","date":"2018-10-11T10:44:55.000Z","updated":"2018-10-12T05:10:36.869Z","comments":true,"path":"2018/10/11/scratch介绍/","link":"","permalink":"/2018/10/11/scratch介绍/","excerpt":"少儿编程神器scratch简单介绍","text":"少儿编程神器scratch简单介绍 scratch介绍scratch是一款儿童学习编程的软件，把具体的一些控制语句以图形的形式表现出来，可以用鼠标来拖动，很生动，简单，不理解编程的孩子们容易学习，本人也是刚刚接触学习scratch，跟孩子们一样需要重头来学习，因为我想做一名少儿编程启蒙老师。先把scratch的网址贴出来：scratch官网 安装scratch在线免安装首页点击try it out就进入在线页面玩耍了。 离线安装首页的footer位置，support下有Offline Editor连接，也可以点这里之后见下图位置可以下载安装了","categories":[{"name":"少儿编程","slug":"少儿编程","permalink":"/categories/少儿编程/"}],"tags":[{"name":"scratch","slug":"scratch","permalink":"/tags/scratch/"}]},{"title":"编译与解释","slug":"编译与解释","date":"2018-10-10T05:11:48.000Z","updated":"2018-10-10T06:09:09.952Z","comments":true,"path":"2018/10/10/编译与解释/","link":"","permalink":"/2018/10/10/编译与解释/","excerpt":"编译与解释的介绍","text":"编译与解释的介绍 编译与解释什么是编译器编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。 什么是解释器在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码预编译成机器码。一个解释器，通常会用以下的姿势来执行程序代码：1.分析源代码，并且直接执行。2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。3.执行由解释器内部的编译器预编译后保存的代码可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。 分两个维度比较一下表现 Behavior 编译器把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。 解释器会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。 性能 Performance 编译器会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。 解释器会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。 关于代码，需要知道的几个概念在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。 高级语言代码 High-Level Code高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。 低级语言代码 Low-Level Code低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。但是这也意味着代码的可移植性很差。在我看来，高与低，只是一组相对词而已。越高级的语言，性能、自由度越不及低级语言。但是在抽象、可读可写性、可移植性越比低级语言优秀。在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。而到了今天，我们更多人对C语言偏向认知为「低级语言」。或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。 汇编语言 Assembly Language汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。它和计算机的体系结构以及机器指令是强关联的。换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。所以汇编语言也往往被称作象征性机器码(symbolic machine code) 字节码 Byte Code字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。它是由一堆指令集组成的代码，例如在javac编译过后的java源码产生的就是字节码。源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。 机器码 Machine Code机器码是一组可以直接被CPU执行的指令集，每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。 从熟悉的编程语言的角度来看看从左往右看，1.以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。2.以 BASIC 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。3.以 C 语言为例，我们在文本编译器编写好源代码，然后运行 gcc hello.c 编译出 hello.out 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。 抽象看本质：人与计算机之间的鸿沟无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。这也是很多人所说的「跳出这个框框再看」的思维方式。 无论是「编译 Compile」还是「解释 Interpret」。本质还是「人与计算机的交流形式」，人的语言最终转换成机器语言。一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。 就这么一个过程，我们就需要很多的翻译官。有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。 最后用一张图来展示一下编译与解释","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"/categories/计算机原理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"/tags/基础知识/"}]},{"title":"vue不同路由使用同一个组件重新加载这个组件","slug":"vue不同路由使用同一个组件重新加载这个组件","date":"2018-10-08T02:26:49.000Z","updated":"2018-10-08T05:26:06.679Z","comments":true,"path":"2018/10/08/vue不同路由使用同一个组件重新加载这个组件/","link":"","permalink":"/2018/10/08/vue不同路由使用同一个组件重新加载这个组件/","excerpt":"vue不同路由使用同一个组件重新加载这个组件","text":"vue不同路由使用同一个组件重新加载这个组件 vue不同路由使用同一个组件重新加载这个组件vue,react,angular都会有一个共同点，那就是如果两个路由用的是一个组件的话，在切换路由的时候组件的生命周期函数并没有被调用，比如有一些想在组件渲染之后调用的钩子函数并不会执行，这是为了性能的考虑。我之前用angular的时候有相应的解决办法，react也有，这里不做探讨，这里只说vue，昨天看到了一个这方面的解决方法，感觉很好，记录下来。有两种解决方案： 第一种监听$route的变化来初始化数据，如下：1234567891011121314151617181920212223data() &#123; return &#123; loading: false, error: null, post: null &#125;&#125;,watch: &#123; '$route': &#123; handler: 'resetData', immediate: true &#125;&#125;,methods: &#123; resetData() &#123; this.loading = false this.error = null this.post = null this.getPost(this.$route.params.id) &#125;, getPost(id)&#123; &#125;&#125; 第二种给router-view添加一个unique的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件，将key直接设置为路由的完整路径。1&lt;router-view :key=\"$route.fullpath\"&gt;&lt;/router-view&gt; 组件代码就可以正常的书写了，如下：123456789101112131415data() &#123; return &#123; loading: false, error: null, post: null &#125;&#125;,created () &#123; this.getPost(this.$route.params.id)&#125;,methods () &#123; getPost(postId) &#123; // ... &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"图片类型转换(image base64 file canvas)","slug":"图片类型转换-image-base64-file-canvas","date":"2018-09-29T03:32:57.000Z","updated":"2018-09-29T05:22:22.078Z","comments":true,"path":"2018/09/29/图片类型转换-image-base64-file-canvas/","link":"","permalink":"/2018/09/29/图片类型转换-image-base64-file-canvas/","excerpt":"图片的各种类型相互间的转换。","text":"图片的各种类型相互间的转换。 图片类型转换(image base64 file canvas)dom中的img标签来显示图片，在src上给一个图片的连接即可，但是如果想把这个图片放在canvas上，或者ipput上传的图片想显示出来，或者canvas剪裁的图片想保存为Blob格式用ajax上传等等一系列操作，如果不缕清楚的话真是迷糊，所以做一下小小的总结。 url连接urltoImage(url,fn) 会通过一个url加载所需要的图片对象，其中 url 参数传入图片的 url , fn 为回调方法,包含一个Image对象的参数，代码如下：1234567function urltoImage (url,fn)&#123; var img = new Image(); img.src = url; img.onload = function()&#123; fn(img); &#125;&#125;; canvas画图片imagetoCanvas(image) 会将一个 Image 对象转变为一个 Canvas 类型对象，其中 image 参数传入一个Image对象，代码如下：12345678function imagetoCanvas(image)&#123; var cvs = document.createElement(\"canvas\"); var ctx = cvs.getContext('2d'); cvs.width = image.width; cvs.height = image.height; ctx.drawImage(image, 0, 0, cvs.width, cvs.height); return cvs ;&#125;; canvas图片转Blob canvasResizetoFile(canvas,quality,fn) 会将一个 Canvas 对象压缩转变为一个 Blob 类型对象；其中 canvas 参数传入一个 Canvas 对象; quality 参数传入一个0-1的 number 类型，表示图片压缩质量; fn 为回调方法，包含一个 Blob 对象的参数;代码如下： 12345function canvasResizetoFile(canvas,quality,fn)&#123; canvas.toBlob(function(blob) &#123; fn(blob); &#125;,'image/jpeg',quality);&#125;; 这里的 Blob 对象表示不可变的类似文件对象的原始数据。 Blob 表示不一定是 JavaScript 原生形式的数据。 File 接口基于 Blob ，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件。我们可以把它当做File类型对待，其他更具体的用法可以参考MDN文档 canvas转dataURL canvasResizetoDataURL(canvas,quality) 会将一个 Canvas 对象压缩转变为一个 dataURL 字符串,其中 canvas 参数传入一个 Canvas 对象; quality 参数传入一个0-1的 number 类型，表示图片压缩质量;代码如下：123methods.canvasResizetoDataURL = function(canvas,quality)&#123; return canvas.toDataURL('image/jpeg',quality);&#125;; 其中的 toDataURL API可以参考MDN文档 File(Blob)转dataURL filetoDataURL(file,fn) 会将 File （ Blob ）类型文件转变为 dataURL 字符串,其中 file 参数传入一个 File （ Blob ）类型文件; fn 为回调方法，包含一个 dataURL 字符串的参数;代码如下： 1234567function filetoDataURL(file,fn)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; fn(e.target.result); &#125;; reader.readAsDataURL(file);&#125;; dataURL转为Image类型文件 dataURLtoImage(dataurl,fn) 会将一串 dataURL 字符串转变为 Image 类型文件,其中 dataurl 参数传入一个 dataURL 字符串, fn 为回调方法，包含一个 Image 类型文件的参数，代码如下： 1234567function dataURLtoImage(dataurl,fn)&#123; var img = new Image(); img.onload = function() &#123; fn(img); &#125;; img.src = dataurl;&#125;; dataURL转为Blob类型dataURLtoFile(dataurl) 会将一串 dataURL 字符串转变为 Blob 类型对象，其中 dataurl 参数传入一个 dataURL 字符串,代码如下：12345678function dataURLtoFile(dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type:mime&#125;);&#125;; 实际应用demo对于常用的将一个 File 对象压缩之后再变为 File 对象,我们可以将上面的方法再封装一下，参考如下代码：1234567function fileResizetoFile(file,quality,fn)&#123; filetoDataURL (file,function(dataurl)&#123; dataURLtoImage(dataurl,function(image)&#123; canvasResizetoFile(imagetoCanvas(image),quality,fn); &#125;) &#125;)&#125; 其中， file 参数传入一个 File （ Blob ）类型文件； quality 参数传入一个 0-1 的 number 类型，表示图片压缩质量； fn 为回调方法，包含一个 Blob 类型文件的参数。它使用起来就像下面这样：12345var file = document.getElementById('demo').files[0];fileResizetoFile(file,0.6,function(res)&#123; console.log(res); //拿到res，做出你要上传的操作；&#125;) 再来一个图片等比压缩的demo1234567891011121314151617181920212223242526272829function proDownImage(path,imgObj) &#123; // 等比压缩图片工具 //var proMaxHeight = 185; var proMaxHeight=300; var proMaxWidth = 175; var size = new Object(); var image = new Image(); image.src = path; image.attachEvent(\"onreadystatechange\", function() &#123; // 当加载状态改变时执行此方法,因为img的加载有延迟 if (image.readyState == \"complete\") &#123; // 当加载状态为完全结束时进入 if (image.width &gt; 0 &amp;&amp; image.height &gt; 0) &#123; var ww = proMaxWidth / image.width; var hh = proMaxHeight / image.height; var rate = (ww &lt; hh) ? ww: hh; if (rate &lt;= 1) &#123; alert(\"imgage width*rate is:\" + image.width * rate); size.width = image.width * rate; size.height = image.height * rate; &#125; else &#123; alert(\"imgage width is:\" + image.width); size.width = image.width; size.height = image.height; &#125; &#125; &#125; imgObj.attr(\"width\",size.width); imgObj.attr(\"height\",size.height); &#125;);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"图片处理","slug":"图片处理","permalink":"/tags/图片处理/"}]},{"title":"一些好的文章收集","slug":"一些好的文章收集","date":"2018-09-28T02:19:50.000Z","updated":"2018-09-29T03:34:56.966Z","comments":true,"path":"2018/09/28/一些好的文章收集/","link":"","permalink":"/2018/09/28/一些好的文章收集/","excerpt":"网上看到的好文章，总结收集。","text":"网上看到的好文章，总结收集。 一些好的文章收集自己写博客文章真的是一件耗时的事儿，写文章需要把各个方面的知识都整理好，有时候我都是在网上看到一篇不错的文章，想记录下来，就照猫画虎的copy，但是，copy下拉也需要时间啊，没办法，现在我只能把连接记录下来，等有时间再好好地记录一下。 页面渲染优化 高频dom操作和页面性能优化探索","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"文章收集","slug":"文章收集","permalink":"/tags/文章收集/"}]},{"title":"hexo中使用hexo-asset-image插件来加载本地图片","slug":"hexo中使用hexo-asset-image插件来加载本地图片","date":"2018-09-21T02:55:52.000Z","updated":"2018-09-21T03:34:34.812Z","comments":true,"path":"2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","link":"","permalink":"/2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","excerpt":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。","text":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。 hexo中使用hexo-asset-image插件来加载本地图片在使用hexo时，在md文件里加载图片一般都会用到网络上的图片，但是如果有些图片不允许使用，怎么办？当然可以用七牛云这种图床网站，如果想使用本地的图片怎么办呢？那就用到了hexo-asset-image这个插件，但是这个插件写的很早，与现在新版本的hexo不兼容，于是乎就有一些大牛进行了修改，这里贴出这位大牛的github地址，兼容新版本hexo的hexo-asset-image插件。使用方法就是替换掉npm安装的hexo-asset-image插件中的文件,代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 图片具体的引入方式：12345678MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.mdMake sure post_asset_folder: true in your _config.yml.Just use ![logo](logo.jpg) to insert logo.jpg.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"HTTP缓存机制及原理","slug":"HTTP缓存机制及原理","date":"2018-09-19T02:14:58.000Z","updated":"2018-09-21T03:32:01.666Z","comments":true,"path":"2018/09/19/HTTP缓存机制及原理/","link":"","permalink":"/2018/09/19/HTTP缓存机制及原理/","excerpt":"HTTP缓存机制及原理的一些小总结","text":"HTTP缓存机制及原理的一些小总结 HTTP缓存机制及原理前言Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。 在介绍HTTP缓存之前，作为知识铺垫，先简单介绍一下HTTP报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。已存在缓存数据时，仅基于强制缓存，请求数据的流程如下已存在缓存数据时，仅基于对比缓存，请求数据的流程如对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 ExpiresExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886）图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。第一次访问：再次访问：通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。 Last-Modified / If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。浏览器第一次请求：浏览器再次请求时：","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"css省略号","slug":"css省略号","date":"2018-09-14T07:39:45.000Z","updated":"2018-09-14T08:09:22.697Z","comments":true,"path":"2018/09/14/css省略号/","link":"","permalink":"/2018/09/14/css省略号/","excerpt":"页面中文字溢出的省略号","text":"页面中文字溢出的省略号 css文本溢出省略号单行文本省略号1234overflow: hidden;text-overflow: ellipsis;white-space: nowrap;// 有些浏览器需要加上width 多行文本溢出省略号在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp ；注意：这是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 兼容其它浏览器的写法html:1&lt;p&gt;WebKit Browsers will clamp the number of lines in this paragraph to 2. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt; css:12345678910111213141516p &#123; position:relative; line-height:1.4em; /* 3 times the line-height to show 3 lines */ height:4.2em; overflow:hidden;&#125;p::after &#123; content:\"...\"; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; background:url(http://css88.b0.upaiyun.com/css88/2014/09/ellipsis_bg.png) repeat-y;&#125; 这里注意几点： height高度真好是line-height的3倍； 结束的省略好用了半透明的png做了减淡的效果，或者设置背景颜色； IE6-7不显示content内容，所以要兼容IE6-7可以是在内容中加入一个标签，比如用…去模拟； 要支持IE8，需要将::after替换成:after；","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"技术博客网站收集整理","slug":"技术博客网站收集整理","date":"2018-09-06T09:05:00.000Z","updated":"2018-11-26T08:30:21.829Z","comments":true,"path":"2018/09/06/技术博客网站收集整理/","link":"","permalink":"/2018/09/06/技术博客网站收集整理/","excerpt":"对一些大牛的blog或者github的收集。","text":"对一些大牛的blog或者github的收集。 技术博客列表 coco大神的github 大神写webpack 比较不错的面试题收集 前端俱乐部 灰风GreyWind的github,有面试题整理","categories":[],"tags":[{"name":"大牛分享","slug":"大牛分享","permalink":"/tags/大牛分享/"}]},{"title":"jquery上传文件","slug":"jquery上传文件","date":"2018-09-03T05:26:56.000Z","updated":"2018-09-14T06:00:01.826Z","comments":true,"path":"2018/09/03/jquery上传文件/","link":"","permalink":"/2018/09/03/jquery上传文件/","excerpt":"之前在项目中使用jquery，Formdata实现文件上传","text":"之前在项目中使用jquery，Formdata实现文件上传 jquery上传文件现在的上传文件插件非常的多，比如在一个表单中，上传身份证照片，点击上传按钮，选好图片，上传好了，一般都提交到了一个图片服务器上，这是常规做法，但是有遇到过，有的后端同事要求我在点击form的提交按钮时，图片和输入框，下拉信息一并提交，当然，直接用form来做都不用改什么就可以，但是，如果需要更灵活的话，我选择了FormData对象配合jquery来做，具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;upload file&lt;/title&gt; &lt;script src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt;.upload_area &gt; div, .userType_area &gt; div , .sendType_area &gt; div &#123; border: 1px solid #DAD5D5; padding: 10px 15px;&#125;#myUploadBtn&#123; background-color:#1874D5; border: none; color: #ffffff; padding: 5px 12px;&#125;h3 &#123; margin: 5px 0;&#125;.fileName &#123; margin-left: 15px;&#125;.userType_area &#123;&#125; .userType_area ul , .sendType_area ul &#123; overflow: hidden;&#125;.userType_area ul li , .sendType_area ul li &#123; position: relative; float: left; padding: 2px 5px; background-color:#1874D5; color: #ffffff; color: #ffffff; margin: 0 10px; cursor: pointer;&#125;span.checkMark &#123; position: absolute; top: 0; right: 0; width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0,0,0,.5); color: #fffff; text-align: center;&#125;.text_area &#123;&#125;.text_area textarea &#123; width: 100%; height: 120px;&#125;.mes_box &#123; display: none; position: absolute; top: 20%; left: 50%; margin:0 0 0 -150px; width: 300px; height: 200px; background-color: gray; border-radius: 5px; text-align: center;&#125;.mes_box &gt; .cancel &#123; position: absolute; width: 30px; height: 30px; border-radius: 20px; text-align: center; line-height:23px; color: #fff; font-size: 25px; right: 5px; top: 3px; border: 1px solid #fff; cursor: pointer;&#125;.mes_box &gt; strong &#123; color: #ffffff; display: inline-block; margin: 70px 0; font-size: 16px;&#125;&lt;/style&gt;&lt;div class=\"mes_box\"&gt; &lt;span class=\"cancel\"&gt;x&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;input type=\"file\" id=\"choosefile\" style=\"display:none;\" /&gt;&lt;div class=\"upload_area\"&gt; &lt;h3&gt;上传文件&lt;/h3&gt; &lt;div&gt; &lt;button id=\"myUploadBtn\"&gt;请选择您要上传的文件&lt;/button&gt; &lt;span class=\"fileName\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"userType_area\"&gt; &lt;h3&gt;选择用户类型&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;余额不足&lt;/li&gt; &lt;li data-code=\"2\"&gt;宽带到期&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"sendType_area\"&gt; &lt;h3&gt;选择推送触点&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;辽宁联通为信号&lt;/li&gt; &lt;li data-code=\"2\"&gt;短信&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"text_area\"&gt; &lt;h3&gt;输入推送需求&lt;/h3&gt; &lt;div&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;button id=\"sendFile\" type=\"button\" class=\"btn btn-primary bsok\"&gt;提交&lt;/button&gt;&lt;script&gt;(function()&#123; var isok = true , isover = false; //选择文件点击事件 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;); //上传选择文件change事件 $('#choosefile').on('change',function()&#123; $('.fileName').text('上传的文件名：'+$(this)[0].files[0].name); &#125;); //被选中函数 function checkMark($el,isDan)&#123; var strNode = '&lt;span class=\"checkMark\"&gt;√&lt;/span&gt;' if(isDan)&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.siblings().data('checkMark', false).find('span').remove(); $el.data('checkMark', true).append(strNode); &#125; &#125;else&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.data('checkMark', true).append(strNode); &#125; &#125; &#125; //获取被选中的code function getCode($el)&#123; var arr = []; $el.find('li').each(function(index, el) &#123; if($(this).data('checkMark') == true)&#123; arr.push($(this).data('code')); &#125; &#125;); return arr; &#125; //选择用户类型添加事件 $('.userType_area li').on('click',function()&#123; checkMark($(this),true); &#125;); //推送触点添加事件 $('.sendType_area li').on('click',function()&#123; checkMark($(this),false); &#125;); //上传文件点击事件 $('#sendFile').on('click',function()&#123; var fd = new FormData(); var upload_file = $('#choosefile')[0].files[0]; var userType = getCode($('.userType_area')); var sendType = getCode($('.sendType_area')); var text = $('.text_area textarea').val(); if(upload_file)&#123; var houz = /\\.[^\\.]+$/.exec(upload_file.name); var size = upload_file.size; &#125; console.log(upload_file); if(!upload_file)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择一个要上传的文件'); isok = false; &#125;else if(userType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择用户类型'); isok = false; &#125;else if(sendType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择推送触点'); isok = false; &#125;else if(!text)&#123; $('.mes_box').show(); $('.mes_box strong').text('请输入推送需求'); isok = false; &#125;else if(houz[0] !== '.txt')&#123; $('.mes_box').show(); $('.mes_box strong').text('请上传以txt结尾的文件'); isok = false; &#125;else if(size &gt; 4194304)&#123; $('.mes_box').show(); $('.mes_box strong').text('您上传的文件过大，请上传小于4M的文件'); isok = false; &#125;; fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file); if(isok)&#123; $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false, contentType: false, data: fd, success:function(res)&#123; $(\".modal-content\").mask(\"hide\"); if(true)&#123; $('.mes_box').show(); $('.mes_box strong').text('数据提交成功'); isover = true; &#125;else&#123; $('.mes_box').show(); $('.mes_box strong').text('服务器问题，数据提交失败'); &#125; &#125;, error:function(err)&#123; $(\".modal-content\").mask(\"hide\"); $('.mes_box').show(); $('.mes_box strong').text('由于网络原因提交失败'); &#125; &#125;); $(\".modal-content\").mask(\"show\");//ajax提交数据出现loading蒙层 &#125; &#125;); //提示框关闭按钮点击事件 $('.mes_box .cancel').on('click',function()&#123; $(this).parent().hide(); isok = true; if(isover === true)&#123; $('#createModal').remove(); $('.modal-backdrop.fade.in').remove(); &#125; &#125;);&#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是整个页面的内容，其实重要的几个点在这里：12345678910111213141516171819202122232425 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;);上边这个函数就是把实际的input file 标签隐藏，用其他的按钮来触发弹出选择文件的窗口，注意，不能直接用file.click()这种形式，要 (function()&#123; return file.click(); &#125;)();这样做才可以调出选择文件的窗口。再有一点，利用了h5的 var fd = new FormData(); 类，把需要上传的文件起个key值，直接放到fd实例里， fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file);之后用ajax直接把fd对象上传就可以了，以jquery为例 $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false,//不对数据进行处理，保持2进制 contentType: false,//不对数据进行处理，保持2进制 data: fd &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"javascript提高性能","slug":"javascript提高性能","date":"2018-09-01T07:00:22.000Z","updated":"2018-09-14T06:00:39.290Z","comments":true,"path":"2018/09/01/javascript提高性能/","link":"","permalink":"/2018/09/01/javascript提高性能/","excerpt":"javascript提高性能的方式总结","text":"javascript提高性能的方式总结 javascript提高性能&emsp;&emsp;javascript如何提高性能，这个在面试中被问到的几率也是蛮高的，之前我也就是想到哪里说到哪里，面试官估计也都是菜鸟（我面的也都是小公司），也觉得我说的对，但是，有空冷静下来，觉得自己说的每次都不是很全面，所以，我想把平时能想到的记录下来，这样再去面试的时候，呵呵，一定把面试官说蒙。 4种内存泄漏&emsp;&emsp;提高JavaScript性能，首先就是避免4种内存泄漏,这里只是简单列出。 1.意外的全局变量JavaScript的目标是开发一种看起来像Java但足够自由的被初学者使用的语言。JavaScript自由的其中一种方式是它可以处理没有声明的变量：一个未声明的变量的引用在全局对象中创建了一个新变量。在浏览器的环境中，全局对象是window。也就是说：1234567function foo(arg) &#123; bar = \"this is a hidden global variable\";&#125;实际上是：function foo(arg) &#123; window.bar = \"this is an explicit global variable\";&#125; 如果bar是仅在foo函数作用域内承载引用，并且你忘记用var来声明的变量，一个意外的全局变量就被创建了。在这个例子中，泄漏一个单一字符串不会有太大害处，但这的确是不好的。另一种意外全局变量被创建的方式是通过this：123456function foo() &#123; this.variable = \"potential accidental global\";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这种错误发生，在你的Javascript文件最前面添加’use strict;’。这开启了解析JavaScript的阻止意外全局的更严格的模式。全局变量的一个注意事项：即使我们谈了不明的全局变量，仍然存在很多代码被显式的全局变量填充的情况。这是通过定义不可收集的情况（除非清零或重新赋值）。特别的，用来临时存储和处理大量信息的全局变量会引起关注。如果必须用全局变量来存储很多数据，在处理完之后，确保对其清零或重新赋值。 一个在与全局连接上增加内存消耗常见的原因是缓存)。 缓存存储重复被使用的数据。为此，为了有效，缓存必须有其大小的上限。飙出限制的缓存可能会因为内容不可被回收，导致高内存消耗。 2.被遗忘的计时器或回调在JavaScript中setInterval的使用相当常见。其他库提供观察者和其他工具以回调。这些库中大多数，在引用的实例变成不可访问之后，负责让回调的任何引用也不可访问。在setInterval的情况下，这样的代码很常见：12345678var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource));&#125;&#125;, 1000); 这个例子表明了跳动的计时器可能发生什么：计时器使得节点或数据的引用不再被需要了。代表node的对象将来可能被移除，使得整个块在间隔中的处理不必要。然而，处理函数，由于间隔仍然是活跃的，不能被回收（间隔需要被停掉才能回收）。如果间隔处理不能被回收，它的依赖也不能被回收。那意味着可能存储着大量数据的someResource，也不能被回收。观察者情况下，一旦不被需要（或相关的对象快要访问不到）就创建明确移除他们的函数很重要。在过去，这由于特定浏览器（IE6）不能很好的管理循环引用（下面有更多相关信息），曾经尤为重要。现如今，一旦观察对象变成不可访问的，即使收听者没有明确的被移除，多数浏览器可以并会回收观察者处理函数。然而，它保持了在对象被处理前明确的移除这些观察者的好实践。例如：1234567891011var element = document.getElementById('button');function onClick(event) &#123; element.innerHtml = 'text';&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don't// handle cycles well. 一条关于对象观察者及循环引用的笔记观察者和循环引用曾经是JavaScript开发者的祸患。这是由于IE垃圾回收的一个bug(或者设计决议)出现的情况。IE的老版本不能检测到DOM节点和JavaScript代码间的循环引用。 这是一个通常为观察到的保留引用（如同上面的例子）的观察者的典型。 也就是说，每次在IE中对一个节点添加观察者的时候，会导致泄漏。这是开发者在节点或空引用之前开始明确的移除处理函数的原因。 现在，现代浏览器（包括IE和MS Edge）使用可以剪裁这些循环和正确处理的现代垃圾回收算法。换言之，在使一个节点不可访问前，调用removeEventLister不是严格意义上必须的。像Jquery一样的框架和库做了在处置一个节点前（当为其使用特定的API的时候）移除监听者的工作。这被在库内部处理，即使在像老版本IE一样有问题的浏览器里面跑，也会确保没有泄漏产生。 3. 超出DOM引用有时存储DOM节点到数据结构中可能有用。假设你想要迅速的更新一个表格几行内容。存储每个DOM行节点的引用到一个字典或数组会起作用。当这发生是，两个对于同个DOM元素的引用被留存：一个在DOM树中，另外一个在字典中。如果在将来的某些点你决定要移除这些行，需要让两个引用都不可用。123456789101112131415161718var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text')&#125;;function doStuff() &#123;image.src = 'http://some.url/image';button.click();console.log(text.innerHTML);// Much more logic&#125;function removeButton() &#123;// The button is a direct child of body.document.body.removeChild(document.getElementById('button'));// At this point, we still have a reference to #button in the global// elements dictionary. In other words, the button element is still in// memory and cannot be collected by the GC.&#125; 对此的额外考虑，必须处理DOM树内的内部节点或叶子节点。假设你在JavaScript代码中保留了一个对于特定的表格内节点（一个td标签）的引用。在将来的某个点决定从DOM中移除这个表格，但是保留对于那个节点的引用。直观的，会假设GC会回收除那个节点之外的每个节点。在实践中，这不会发生的：这个单节点是那个表格的子节点，子节点保留对父节点引用。换句话说，来自JavaScript代码的表格元素的引用会引起在内存里存整个表格。当保留DOM元素的引用的时候，仔细考虑下。 4.闭包一个JavaScript开发的关键点是闭包：从父级作用域捕获变量的匿名函数。很多开发者发现，由于JavaScript runtime的实现细节，有以一种微妙的方式泄漏的可能，这种特殊的情况：123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码片段做了一件事：每次replaceThing被调用的时候，theThing获取到一个包括一个大数组和新闭包(somMethod)的新对象。同时，变量unused保留了一个有originalThing（theThing从之前的对replaceThing的调用）引用的闭包。已经有点疑惑了，哈？重要的是一旦一个作用域被在同个父作用域下的闭包创建，那个作用域是共享的。这种情况下，为闭包somMethod创建的作用域被unused共享了。unused有一个对originalThing的引用。即使unused从来没被用过，someMethod可以通过theTing被使用。由于someMethod和unused共享了闭包作用域，即使unused从来没被用过，它对originalThing的引用迫使它停留在活跃状态（不能回收）。当这个代码片段重复运行的时候，可以看到内存使用稳步的增长。GC运行的时候，这并不会减轻。本质上，一组关联的闭包被创建（同unused变量在表单中的根节点一起），这些闭包作用域中每个带了大数组一个非直接的引用，导致了大型的泄漏。 垃圾回收的直观行为即使垃圾回收很方便，他们有自己的一套权衡方法。其中一个权衡是nondeterminism。也就是说，GC是不可预期的。通常不能确定什么时候回收器被执行。这意味着在一些情况下，需要比程序正在使用的更多的内存。其他情况下，短的暂停在特别敏感的应用中很明显。即使不确定性意味着不能确定回收什么时候执行，大多数GC实现共享在分配期间，普通的回收通行证模式。如果没有执行分配，大多数CG停留在休息状态。考虑下面的方案：1.执行一组大型的分配。2.多数元素（或所有）被标记为不可访问（假设我们置空了一个指向不再需要的缓存的引用）。3.没有进一步的分配执行了。在这个方案中，大多GC不会运行任何进一步的回收通行了。换言之，即使有可用于回收的，不可访问的引用，回收器不会要求他了。这不是严格的泄漏，但是也会导致比平常更高的内存使用率。Google在 JavaScript Memory Profiling docs, example #2.文章中，提供了一个优秀的例子。 编写javascript代码时的优化1.从JavaScript的作用域谈起当JavaScript代码执行时，JavaScript引擎会创建一个执行环境，又叫执行上下文。执行环境定义了变量或函数有权访问的其他数据，决定了它们的行为，每个执行环境都有一个与它关联的变量对象，环境中定义的所有函数、变量都保存在这个对象中。在页面加载的时候，JavaScript引擎会创建一个全局的执行环境，所有全局变量和函数都是作为window对象（浏览器中）的属性和方法创建的。在此之后，每执行一个函数，JavaScript引擎都会创建一个对应的执行环境，并将该环境放入环境栈中，所以当前正在执行的函数的执行环境是在环境栈的最顶部的，当函数执行完毕之后，其执行环境会弹出栈，并被销毁，保存在其中的变量和函数定义也会被销毁。当代码在一个执行环境中执行时，JavaScript引擎会创建变量对象的一个作用域链，它可以保证对执行环境有权访问的变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。全局环境的作用域链中只有一个变量对象，它定义了所有可用的全局变量和函数。当函数被创建时，JavaScript引擎会把创建时执行环境的作用域链赋给函数的内部属性[[scope]]；当函数被执行时，JavaScript引擎会创建一个活动对象，最开始时这个活动对象只有一个变量，即arguments对象。该活动对象会出现在执行环境作用域链的顶端，接下来是函数[[scope]]属性中的对象。当需要查找某个变量或函数时，JavaScript引擎会通过执行环境的作用域链来查找变量和函数，从作用域链的顶端开始，如果没找到，则向下寻找直至找到为止。若一直到全局作用域都没有找到,则该变量或函数为undefined。举个栗子：1234function add(a,b) &#123; return a + b;&#125;var result = add(2,3); 代码执行时，add函数有一个仅包含全局变量对象的[[scope]]属性，add函数执行时，JavaScript引擎创建新的执行环境以及一个包含this、arguments、a、b的活动对象，并将其添加到作用域链中。如下图所示： 2.使用局部变量了解了作用域链的概念，我们应该知道在查找变量会从作用域链的顶端开始一层一层的向下找。显然，查找的层数越多，花费的时间越多。所以为了提高查找的速度，我们应该尽量使用 局部变量（到目前为止，局部变量是JavaScript中读写最快的标识符）。例如：1234567function createEle() &#123; document.createElement(\"div\");&#125;function createEle() &#123; var doc = document; doc.createElement(\"div\");&#125; 当document使用次数比较少时，可能无所谓，可是如果在一个函数的循环中大量使用document，我们可以提前将document变成局部变量。来看看jquery怎么写的：12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery;&#125;)(window); 这样写的优势：1、window和undefined都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。（原来的window处于作用域链的最顶端，查找速度慢）2、在jquery压缩版本jquery.min.js中可以将局部变量window替换成单个字母，减小文件大小，提高加载速度3、undefined也是JavaScript中的全局属性。将undefined作为参数传递给闭包，因为没给它传递值，它的值就是undefined，这样闭包内部在使用它的时候就可以把它当做局部变量使用，从而提高查找速度。undefined并不是JavaScript的保留字或者关键字。4、undefined在某些低版本的浏览器（例如IE8、IE7）中值是可以被修改的（在ECMAScript3中，undefined是可读/写的变量，可以给它赋任意值，这个错误在ECMAScript5中做了修正），将undefined作为参数并且不给它传值可以防止因undefined的值被修改而产生的错误。 3.避免增长作用域链在JavaScript中，有两种语句可以临时增加作用域链：with、try-catchwith可以使对象的属性可以像全局变量来使用，它实际上是将一个新的变量对象添加到执行环境作用域的顶部，这个变量对象包含了指定对象的所有属性，因此可以直接访问。这样看似很方便，但是增长了作用域链，原来函数中的局部变量不在处于作用域链的顶端，因此在访问这些变量的时候要查找到第二层才能找到它。当with语句块之行结束后，作用域链将回到原来的状态。鉴于with的这个缺点，所以不推荐使用。try-catch中的catch从句和with类似，也是在作用域链的顶端增加了一个对象，该对象包含了由catch指定命名的异常对象。但是因为catch语句只有在放生错误的时候才执行，因此影响比较少。 4.字符串链接优化由于字符串是不可变的，所以在进行字符串连接时，需要创建临时字符串。频繁创建、销毁临时字符串会导致性能低下。当然，这个问题在新版本浏览器包括IE8+中都得到了优化，所以不需要担心在低版本浏览器（IE6、IE7）中，我们可以种数组的join方法来代替。123456var temp = [];var i = 0;temp[i++] = \"Hello\";temp[i++] = \" \";temp[i++] =\"everyone\";var outcome = temp.join(\"\"); 5.条件判断当出现条件判断时，我们采用什么样的结构才能使性能最优？1234567891011if(val == 0) &#123; return v0;&#125;else if(val == 1) &#123; return v1;&#125;else if(val == 2) &#123; return v2;&#125;else if(val == 3) &#123; return v3;&#125;else if(val == 4) &#123; return v4;&#125; 当条件分支比较多时，我们可以斟酌哪种条件出现的概率比较大，并将对应的语句放在最上面，这样可以减少判断次数。使用switch语句，新版的浏览器基本上都对switch做了优化，这样层数比较深时，性能比if会更好使用数组：12var v = [v0,v1,v2,v3,v4];return v[valeue]; 要求：对应的结果是单一值，而不是一系列操作另外，其他方面的优化，譬如1234567891011if(condition1) &#123; return v1;&#125;else &#123; return v2&#125;// 改成if(condition1) &#123; return v1;&#125;return v2; 6.快速循环1、循环总次数使用局部变量12345678for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125; 这样就避免了每次循环的属性查找。这点尤其重要，因为在进行dom操作时，很多人会这样写：1234var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125; 查找DOM元素的属性是相对耗时的，所以应该避免这种写法。2、如果可以，递减代替递增1234567891011121314151617for(var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成for(var i = arr.length - 1;i--;) &#123;&#125;var i = 0;while(i &lt; arr.length) &#123; i++;&#125;// 改成var i = arr.length - 1;while(i--) &#123;&#125; i=0的时候会直接跳出，循环次数比较多时还是很有用的。 7.展开循环1234var i = arr.length - 1;while(i--) &#123; dosomething(arr[i]);&#125; 遇到这样的情况时，执行一次循环的时候我们可以选择不止执行一次函数。12345678910111213141516171819var interations = Math.floor(arr.length / 8);var left = arr.length % 8;var i = 0;if(left) &#123; do &#123; dosomething(arr[i++]); &#125; while(--left);&#125;do &#123; dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]);&#125; while(--interations); 当遇到大数组，减少循环的开销，性能不就提上去了嘛。（至于为什么是每次循环，调8次函数，大牛测出来的，这样达到最佳） 8.高效存取数据JavaScript中4种地方可以存取数据：字面量值；变量；数组元素；对象属性字面量值和变量中存取数据是最快的，从数组元素和对象属性中存取数据相对较慢，并且随着深度增加，存取速度会越来越慢，譬如obj.item.value就比obj.item慢。某些情况下我们可以将对象、数组属性存成局部变量来提高速度，譬如：12345678910111213141516171819for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125;var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125;// 改成// var divList = document.getElementsByTagName(\"div\");for( var i = 0,len = divList.length;i &lt; len;i++) &#123;&#125; 9.事件委托事件委托就是利用冒泡的原理，将原本应该添加在某些元素身上的监听事件，添加到其父元素身上，来达到提高性能的效果。举个栗子：1234567891011121314151617181920212223242526&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); for(var i = 0,len = liList.length;i &lt; len;i++) &#123; liList[i].onclick = function() &#123; alert(this.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样我们就为每个li添加了监听事件了。显然，我们通过循环为每个li添加监听事件是不优化的。这样不仅浪费了内存，在新的li加入的时候我们还要重新为它添加监听事件。我们可以这样写：1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); ul.onclick = function(e) &#123; var e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName.toLowerCase() == \"li\") &#123; alert(target.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样写的好处：只添加一个监听事件，节省了内存；新加入li的时候我们也不用为它单独添加监听事件；在页面中添加事件处理程序所需的时候更少，因为我们只需要为一个DOM元素添加事件处理程序。 使用typescript使用typescript来提高性能我实在一本关于nodejs的书里看到的，主要还是用在chrome的V8引擎上，这本书里写的比如1234567// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; console.log(add(i + i*3));&#125; 书里说，如果V8引擎发现一个函数使用频率很高，而且参数传入的都是同一种类型的，好像是在内存寻址的时候书都很快，因为引擎认为传入的参数就是int型。再来看一个例子1234567891011// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; if(i % 8 === 0) &#123; console.log(add(i + i*0.3)); // 这里出现了浮点数 &#125;else &#123; console.log(add(i + i*3)); // 这里是整数 &#125;&#125; 上边的代码可以看到，在使用整形参数的时候突然传入浮点数，V8引擎寻址机制突然变化，丢弃之前的函数，使用新的来计算，性能下降。所以，如果使用typescript，类型固定，这样性能就会提高哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"vue双向绑定的简单实现","slug":"vue双向绑定的简单实现","date":"2018-08-30T03:13:39.000Z","updated":"2018-09-14T05:58:16.386Z","comments":true,"path":"2018/08/30/vue双向绑定的简单实现/","link":"","permalink":"/2018/08/30/vue双向绑定的简单实现/","excerpt":"参考网上vue实现教程简单整理","text":"参考网上vue实现教程简单整理 vue双向绑定的简单实现&emsp;&emsp;首先，这篇文章并非我的原创，在网上看到了很多写vue原理的文章，感觉这篇写的层次结构清晰，容易理解，所以留作收藏。废话不多说，开始。 1.原理&emsp;&emsp;Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过 Object对象的defineProperty属性，重写data的set和get函数来实现的,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。添加网上的一张图 2.实现页面结构很简单，如下：1234567&lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button ype=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt;&lt;/div&gt; 包含：1.一个input，使用v-model指令2.一个button，使用v-click指令3.一个h3，使用v-bind指令。我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释：1234567891011var app = new myVue(&#123; el:'#app', data:&#123; number:0 &#125;, methods:&#123; increment:function()&#123; this.number++; &#125;, &#125; &#125;) 首先我们需要定义一个myVue构造函数：123function myVue(options)&#123;&#125; 为了初始化这个构造函数，给它添加一 个_init属性123456789function myVue(options) &#123; this._init(options);&#125;myVue.prototype._init = function (options) &#123; this.$options = options; // options 为上面使用时传入的结构体，包括el,data,methods this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素 this.$data = options.data; // this.$data = &#123;number: 0&#125; this.$methods = options.methods; // this.$methods = &#123;increment: function()&#123;&#125;&#125; &#125; 接下来实现_obverse函数，对data进行处理，重写data的set和get函数并改造_init函数12345678910111213141516171819202122232425262728293031323334myVue.prototype._obverse = function (obj) &#123; // obj = &#123;number: 0&#125; var value; for (key in obj) &#123; //遍历obj对象 if (obj.hasOwnProperty(key)) &#123; value = obj[key]; if (typeof value === 'object') &#123; //如果值还是对象，则遍历处理 this._obverse(value); &#125; Object.defineProperty(this.$data, key, &#123; //关键 enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; &#125; &#125; &#125;) &#125; &#125; &#125;myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._obverse(this.$data); &#125; 接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新12345678910111213function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。 &#125; 更新_init函数以及_obverse函数1234567891011121314151617181920212223242526272829myVue.prototype._init = function (options) &#123; //... this._binding = &#123;&#125;; //_binding保存着model与view的映射关系，也就是我们前面定义的Watcher的实例。当model改变时，我们会触发其中的指令类更新，保证view也能实时更新 //... &#125; myVue.prototype._obverse = function (obj) &#123; //... if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; // 按照前面的数据，_binding = &#123;number: _directives: []&#125; _directives: [] &#125;; //... var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; //... set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; // 当number改变时，触发_binding[number]._directives 中的绑定的Watcher类的更新 item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; 那么如何将view与model进行绑定呢？接下来我们定义一个_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 myVue.prototype._init = function (options) &#123; //... this._complie(this.$el); &#125; myVue.prototype._complie = function (root) &#123; root 为 id为app的Element元素，也就是我们的根元素 var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; // 对所有元素进行遍历，并进行处理 this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++ node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); //bind是使data的作用域与method函数的作用域保持一致 &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件 node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); //_this._binding['number']._directives = [一个Watcher实例] // 其中Watcher.prototype.update = function () &#123; // node['vaule'] = _this.$data['number']; 这就将node的值保持与number一致 // &#125; _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定 &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可 var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; 至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图 附上全部代码，不到150行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 &lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;myVue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #app &#123; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button type=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function myVue(options) &#123; this._init(options); &#125; myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._binding = &#123;&#125;; this._obverse(this.$data); this._complie(this.$el); &#125; myVue.prototype._obverse = function (obj) &#123; var value; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; _directives: [] &#125;; value = obj[key]; if (typeof value === 'object') &#123; this._obverse(value); &#125; var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; myVue.prototype._complie = function (root) &#123; var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; &#125; window.onload = function() &#123; var app = new myVue(&#123; el:'#app', data: &#123; number: 0 &#125;, methods: &#123; increment: function() &#123; this.number ++; &#125;, &#125; &#125;) &#125;&lt;/script&gt; 以上就是所有内容，这个代码不是我创造的，我只是代码的搬运工。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"webSocket","slug":"webSocket项目中的使用","date":"2018-08-29T01:23:54.000Z","updated":"2018-09-14T05:52:25.058Z","comments":true,"path":"2018/08/29/webSocket项目中的使用/","link":"","permalink":"/2018/08/29/webSocket项目中的使用/","excerpt":"在项目中使用websocket的小心得","text":"在项目中使用websocket的小心得 webSocket在项目中的使用&emsp;&emsp;webSocket,这个技术相信大家都已经很熟悉了，就是前端浏览器与后端服务器一直保持连通状态，我们在项目中，经常会遇到这样的需求，一个数据图表展示页面，产品的需求是每隔5秒钟页面刷新一次，传统的做法是请求轮询机制，也就是setInterval这个定时器，一遍又一遍的请求后端接口，这个方法简单（特别是后端简单），但是如果前端页面有大量的这种需求，会影响性能，所以，webSocket是现在最好的选择。&emsp;&emsp;其实webSocket现在还是比较重要的，一般在面试的时候，被问到的几率还是很大的。我之前在项目中没有用到过，但是自己写过webSocket的demo，浏览器配合nodejs来写，也是参考了网上的代码，还是很简单的webSocket详细代码看这里。在面试时被问到的时候，也是实话实说，有可能面试官也是小白，基本上都没往下问，但是，确实是这么简单吗？答案显然不是，待我慢慢道来。&emsp;&emsp;首先，我在最近两个项目中，都用到了webSocket，所以还是有发言权的。如果，产品提出了webSocket的需求，对于我们前端来说，并不是直接写个原生的webSocket就可以，而是需要看后端小伙伴们的脸色，什么意思？就是说得看后端用的是什么webSocket库，我接触的有两种，第一个是stomp,说是webSocket的子协议，后端选了这个库之后，我们前端也得相应的选择与后端相配合的前端库，一般情况下，官网很明确的给出了后端和前端相配合写法，当然，写法也是很简单，跟原生差不多。第二个是，sockjs这个库，当然，也是后端小伙伴选好了之后，告诉我，我相应的在前端也用的跟后端一样库。&emsp;&emsp;最后总结一下，webSocket技术并不难（对于我们前端来说，当然，nodejs的后端也很简单，java就不知道了，每次调起来看他们都是一脸懵逼的样子），无论是面试还是在实际工作中，问道这个问题时，我们首先想到的应该是，后端选择的是什么库，我们前端应该跟后端小伙伴保持一致，可别需求以来，觉得简单直接开些，等联调的时候，我靠，为什么连不上呢？你们前后端不在一个频道上，怎么连接啊。所以，我们要说，我做过的项目是这样这样滴，不知道这次我们后端小伙伴用到的webSocket库是什么呢？","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"webSocket","slug":"webSocket","permalink":"/tags/webSocket/"}]},{"title":"nodejs代理服务器","slug":"nodejs代理服务器","date":"2018-08-27T06:51:52.000Z","updated":"2018-09-14T05:59:05.665Z","comments":true,"path":"2018/08/27/nodejs代理服务器/","link":"","permalink":"/2018/08/27/nodejs代理服务器/","excerpt":"nodejs代理服务器简单实现","text":"nodejs代理服务器简单实现 nodejs代理服务 最近在与后台同事联调的时候，出现了点故障，跨域，这个经常碰到很好解决的问题，但是一般情况下需要前后端一起配合来解决，比如jsonp，或者h5后端在返回头加上允许跨域的头设置，但是如果后台同事是个小白，问啥啥不明白，也是没招了。我之前还用过将chrome的跨域设置给禁掉的方法，但是这次不知道为啥，也不好使了。最后，只能是用代理这种方式，我现在用的是vue框架，其实vue的脚手架已经集成了跨域功能，只需要配置一下就可以，但是，现在框架这么多，前一阵子还react，angular的项目，最近有换成vue，配置的话，肯定要去查看api，记不住啊，而且，版本不同，设置方法也不同，不如自己写一个，这样多简单，需要的时候把代理服务开启就搞定了。于是乎，自己写一个，当然，稍微想一下就知道，代理的原理，就是利用nodejs在中间做一次请求以及数据返回，不过自己写还得思考，上网找一下多简单，baidu一搜索，哇靠，第一个映入眼帘的就是nodejs代理服务8行代码，嗯，就是这么简单，废话不多说，上代码,当然，自己还得加工一下哦。123456789101112131415161718192021var express = require('express');var request = require('request');var app = express();const proxyUrl = process.argv[2] || 'http://127.0.0.1:8888'; // 如果有传入的代理url，使用它app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") res.send(200); // 让options请求快速返回 else next();&#125;);app.use('/', function(req, res) &#123; var url = proxyUrl + req.url; req.pipe(request(url)).pipe(res);&#125;);app.listen(process.env.PORT || 3000, ()=&gt;&#123; console.log('代理服务器，在3000端口已经开启');&#125;); 再把package.json文件内容贴出来12345678910111213141516&#123; &quot;name&quot;: &quot;node-proxy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;node server http://127.0.0.1:9000&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.3&quot;, &quot;request&quot;: &quot;^2.88.0&quot; &#125;&#125; 源码在这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端代理服务","slug":"后端代理服务","permalink":"/tags/后端代理服务/"}]}]}