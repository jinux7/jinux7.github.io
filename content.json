{"meta":{"title":"jinux","subtitle":null,"description":"前端 学习 javascript","author":"jinux","url":""},"pages":[{"title":"categories","date":"2018-08-20T08:19:43.000Z","updated":"2018-09-14T06:07:56.459Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":"javascriptnodejs"},{"title":"tags-test","date":"2018-08-20T08:18:58.000Z","updated":"2018-08-27T06:24:35.212Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"tag-jquery"}],"posts":[{"title":"hexo中使用hexo-asset-image插件来加载本地图片","slug":"hexo中使用hexo-asset-image插件来加载本地图片","date":"2018-09-21T02:55:52.000Z","updated":"2018-09-21T03:34:34.812Z","comments":true,"path":"2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","link":"","permalink":"/2018/09/21/hexo中使用hexo-asset-image插件来加载本地图片/","excerpt":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。","text":"hexo中使用hexo-asset-image插件来加载本地图片,因为版本兼容问题不显示图片的解决办法。 hexo中使用hexo-asset-image插件来加载本地图片在使用hexo时，在md文件里加载图片一般都会用到网络上的图片，但是如果有些图片不允许使用，怎么办？当然可以用七牛云这种图床网站，如果想使用本地的图片怎么办呢？那就用到了hexo-asset-image这个插件，但是这个插件写的很早，与现在新版本的hexo不兼容，于是乎就有一些大牛进行了修改，这里贴出这位大牛的github地址，兼容新版本hexo的hexo-asset-image插件。使用方法就是替换掉npm安装的hexo-asset-image插件中的文件,代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 图片具体的引入方式：12345678MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.mdMake sure post_asset_folder: true in your _config.yml.Just use ![logo](logo.jpg) to insert logo.jpg.","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"HTTP缓存机制及原理","slug":"HTTP缓存机制及原理","date":"2018-09-19T02:14:58.000Z","updated":"2018-09-21T03:32:01.666Z","comments":true,"path":"2018/09/19/HTTP缓存机制及原理/","link":"","permalink":"/2018/09/19/HTTP缓存机制及原理/","excerpt":"HTTP缓存机制及原理的一些小总结","text":"HTTP缓存机制及原理的一些小总结 HTTP缓存机制及原理前言Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。 在介绍HTTP缓存之前，作为知识铺垫，先简单介绍一下HTTP报文HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分 缓存规则解析为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。已存在缓存数据时，仅基于强制缓存，请求数据的流程如下已存在缓存数据时，仅基于对比缓存，请求数据的流程如对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 ExpiresExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886）图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 对比缓存对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。第一次访问：再次访问：通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。 Last-Modified / If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。浏览器第一次请求：浏览器再次请求时：","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"/tags/网络基础/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"css省略号","slug":"css省略号","date":"2018-09-14T07:39:45.000Z","updated":"2018-09-14T08:09:22.697Z","comments":true,"path":"2018/09/14/css省略号/","link":"","permalink":"/2018/09/14/css省略号/","excerpt":"页面中文字溢出的省略号","text":"页面中文字溢出的省略号 css文本溢出省略号单行文本省略号1234overflow: hidden;text-overflow: ellipsis;white-space: nowrap;// 有些浏览器需要加上width 多行文本溢出省略号在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp ；注意：这是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 兼容其它浏览器的写法html:1&lt;p&gt;WebKit Browsers will clamp the number of lines in this paragraph to 2. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt; css:12345678910111213141516p &#123; position:relative; line-height:1.4em; /* 3 times the line-height to show 3 lines */ height:4.2em; overflow:hidden;&#125;p::after &#123; content:\"...\"; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; background:url(http://css88.b0.upaiyun.com/css88/2014/09/ellipsis_bg.png) repeat-y;&#125; 这里注意几点： height高度真好是line-height的3倍； 结束的省略好用了半透明的png做了减淡的效果，或者设置背景颜色； IE6-7不显示content内容，所以要兼容IE6-7可以是在内容中加入一个标签，比如用…去模拟； 要支持IE8，需要将::after替换成:after；","categories":[{"name":"css","slug":"css","permalink":"/categories/css/"}],"tags":[{"name":"样式","slug":"样式","permalink":"/tags/样式/"}]},{"title":"技术博客网站收集整理","slug":"技术博客网站收集整理","date":"2018-09-06T09:05:00.000Z","updated":"2018-09-27T04:53:46.921Z","comments":true,"path":"2018/09/06/技术博客网站收集整理/","link":"","permalink":"/2018/09/06/技术博客网站收集整理/","excerpt":"对一些大牛的blog或者github的收集。","text":"对一些大牛的blog或者github的收集。 技术博客列表 coco大神的github 大神些webpack 比较不错的面试题收集","categories":[],"tags":[{"name":"大牛分享","slug":"大牛分享","permalink":"/tags/大牛分享/"}]},{"title":"jquery上传文件","slug":"jquery上传文件","date":"2018-09-03T05:26:56.000Z","updated":"2018-09-14T06:00:01.826Z","comments":true,"path":"2018/09/03/jquery上传文件/","link":"","permalink":"/2018/09/03/jquery上传文件/","excerpt":"之前在项目中使用jquery，Formdata实现文件上传","text":"之前在项目中使用jquery，Formdata实现文件上传 jquery上传文件现在的上传文件插件非常的多，比如在一个表单中，上传身份证照片，点击上传按钮，选好图片，上传好了，一般都提交到了一个图片服务器上，这是常规做法，但是有遇到过，有的后端同事要求我在点击form的提交按钮时，图片和输入框，下拉信息一并提交，当然，直接用form来做都不用改什么就可以，但是，如果需要更灵活的话，我选择了FormData对象配合jquery来做，具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;upload file&lt;/title&gt; &lt;script src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt;.upload_area &gt; div, .userType_area &gt; div , .sendType_area &gt; div &#123; border: 1px solid #DAD5D5; padding: 10px 15px;&#125;#myUploadBtn&#123; background-color:#1874D5; border: none; color: #ffffff; padding: 5px 12px;&#125;h3 &#123; margin: 5px 0;&#125;.fileName &#123; margin-left: 15px;&#125;.userType_area &#123;&#125; .userType_area ul , .sendType_area ul &#123; overflow: hidden;&#125;.userType_area ul li , .sendType_area ul li &#123; position: relative; float: left; padding: 2px 5px; background-color:#1874D5; color: #ffffff; color: #ffffff; margin: 0 10px; cursor: pointer;&#125;span.checkMark &#123; position: absolute; top: 0; right: 0; width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0,0,0,.5); color: #fffff; text-align: center;&#125;.text_area &#123;&#125;.text_area textarea &#123; width: 100%; height: 120px;&#125;.mes_box &#123; display: none; position: absolute; top: 20%; left: 50%; margin:0 0 0 -150px; width: 300px; height: 200px; background-color: gray; border-radius: 5px; text-align: center;&#125;.mes_box &gt; .cancel &#123; position: absolute; width: 30px; height: 30px; border-radius: 20px; text-align: center; line-height:23px; color: #fff; font-size: 25px; right: 5px; top: 3px; border: 1px solid #fff; cursor: pointer;&#125;.mes_box &gt; strong &#123; color: #ffffff; display: inline-block; margin: 70px 0; font-size: 16px;&#125;&lt;/style&gt;&lt;div class=\"mes_box\"&gt; &lt;span class=\"cancel\"&gt;x&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;input type=\"file\" id=\"choosefile\" style=\"display:none;\" /&gt;&lt;div class=\"upload_area\"&gt; &lt;h3&gt;上传文件&lt;/h3&gt; &lt;div&gt; &lt;button id=\"myUploadBtn\"&gt;请选择您要上传的文件&lt;/button&gt; &lt;span class=\"fileName\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"userType_area\"&gt; &lt;h3&gt;选择用户类型&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;余额不足&lt;/li&gt; &lt;li data-code=\"2\"&gt;宽带到期&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"sendType_area\"&gt; &lt;h3&gt;选择推送触点&lt;/h3&gt; &lt;div&gt; &lt;ul&gt; &lt;li data-code=\"1\"&gt;辽宁联通为信号&lt;/li&gt; &lt;li data-code=\"2\"&gt;短信&lt;/li&gt; &lt;li data-code=\"3\"&gt;其它&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"text_area\"&gt; &lt;h3&gt;输入推送需求&lt;/h3&gt; &lt;div&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;button id=\"sendFile\" type=\"button\" class=\"btn btn-primary bsok\"&gt;提交&lt;/button&gt;&lt;script&gt;(function()&#123; var isok = true , isover = false; //选择文件点击事件 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;); //上传选择文件change事件 $('#choosefile').on('change',function()&#123; $('.fileName').text('上传的文件名：'+$(this)[0].files[0].name); &#125;); //被选中函数 function checkMark($el,isDan)&#123; var strNode = '&lt;span class=\"checkMark\"&gt;√&lt;/span&gt;' if(isDan)&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.siblings().data('checkMark', false).find('span').remove(); $el.data('checkMark', true).append(strNode); &#125; &#125;else&#123; if($el.data('checkMark'))&#123; $el.find('span').remove(); $el.data('checkMark', false); &#125;else&#123; $el.data('checkMark', true).append(strNode); &#125; &#125; &#125; //获取被选中的code function getCode($el)&#123; var arr = []; $el.find('li').each(function(index, el) &#123; if($(this).data('checkMark') == true)&#123; arr.push($(this).data('code')); &#125; &#125;); return arr; &#125; //选择用户类型添加事件 $('.userType_area li').on('click',function()&#123; checkMark($(this),true); &#125;); //推送触点添加事件 $('.sendType_area li').on('click',function()&#123; checkMark($(this),false); &#125;); //上传文件点击事件 $('#sendFile').on('click',function()&#123; var fd = new FormData(); var upload_file = $('#choosefile')[0].files[0]; var userType = getCode($('.userType_area')); var sendType = getCode($('.sendType_area')); var text = $('.text_area textarea').val(); if(upload_file)&#123; var houz = /\\.[^\\.]+$/.exec(upload_file.name); var size = upload_file.size; &#125; console.log(upload_file); if(!upload_file)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择一个要上传的文件'); isok = false; &#125;else if(userType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择用户类型'); isok = false; &#125;else if(sendType.length === 0)&#123; $('.mes_box').show(); $('.mes_box strong').text('请选择推送触点'); isok = false; &#125;else if(!text)&#123; $('.mes_box').show(); $('.mes_box strong').text('请输入推送需求'); isok = false; &#125;else if(houz[0] !== '.txt')&#123; $('.mes_box').show(); $('.mes_box strong').text('请上传以txt结尾的文件'); isok = false; &#125;else if(size &gt; 4194304)&#123; $('.mes_box').show(); $('.mes_box strong').text('您上传的文件过大，请上传小于4M的文件'); isok = false; &#125;; fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file); if(isok)&#123; $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false, contentType: false, data: fd, success:function(res)&#123; $(\".modal-content\").mask(\"hide\"); if(true)&#123; $('.mes_box').show(); $('.mes_box strong').text('数据提交成功'); isover = true; &#125;else&#123; $('.mes_box').show(); $('.mes_box strong').text('服务器问题，数据提交失败'); &#125; &#125;, error:function(err)&#123; $(\".modal-content\").mask(\"hide\"); $('.mes_box').show(); $('.mes_box strong').text('由于网络原因提交失败'); &#125; &#125;); $(\".modal-content\").mask(\"show\");//ajax提交数据出现loading蒙层 &#125; &#125;); //提示框关闭按钮点击事件 $('.mes_box .cancel').on('click',function()&#123; $(this).parent().hide(); isok = true; if(isover === true)&#123; $('#createModal').remove(); $('.modal-backdrop.fade.in').remove(); &#125; &#125;);&#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是整个页面的内容，其实重要的几个点在这里：12345678910111213141516171819202122232425 $('#myUploadBtn').on('click',function()&#123; (function()&#123; return $('#choosefile')[0].click(); &#125;)(); &#125;);上边这个函数就是把实际的input file 标签隐藏，用其他的按钮来触发弹出选择文件的窗口，注意，不能直接用file.click()这种形式，要 (function()&#123; return file.click(); &#125;)();这样做才可以调出选择文件的窗口。再有一点，利用了h5的 var fd = new FormData(); 类，把需要上传的文件起个key值，直接放到fd实例里， fd.append('userType',userType); fd.append('sendType',userType); fd.append('text',userType); fd.append('file',upload_file);之后用ajax直接把fd对象上传就可以了，以jquery为例 $.ajax(&#123; url: ajaxUrl + \"/module/channel/checkByWhere\", type: 'POST', cache: false, processData: false,//不对数据进行处理，保持2进制 contentType: false,//不对数据进行处理，保持2进制 data: fd &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"/tags/ajax/"}]},{"title":"javascript提高性能","slug":"javascript提高性能","date":"2018-09-01T07:00:22.000Z","updated":"2018-09-14T06:00:39.290Z","comments":true,"path":"2018/09/01/javascript提高性能/","link":"","permalink":"/2018/09/01/javascript提高性能/","excerpt":"javascript提高性能的方式总结","text":"javascript提高性能的方式总结 javascript提高性能&emsp;&emsp;javascript如何提高性能，这个在面试中被问到的几率也是蛮高的，之前我也就是想到哪里说到哪里，面试官估计也都是菜鸟（我面的也都是小公司），也觉得我说的对，但是，有空冷静下来，觉得自己说的每次都不是很全面，所以，我想把平时能想到的记录下来，这样再去面试的时候，呵呵，一定把面试官说蒙。 4种内存泄漏&emsp;&emsp;提高JavaScript性能，首先就是避免4种内存泄漏,这里只是简单列出。 1.意外的全局变量JavaScript的目标是开发一种看起来像Java但足够自由的被初学者使用的语言。JavaScript自由的其中一种方式是它可以处理没有声明的变量：一个未声明的变量的引用在全局对象中创建了一个新变量。在浏览器的环境中，全局对象是window。也就是说：1234567function foo(arg) &#123; bar = \"this is a hidden global variable\";&#125;实际上是：function foo(arg) &#123; window.bar = \"this is an explicit global variable\";&#125; 如果bar是仅在foo函数作用域内承载引用，并且你忘记用var来声明的变量，一个意外的全局变量就被创建了。在这个例子中，泄漏一个单一字符串不会有太大害处，但这的确是不好的。另一种意外全局变量被创建的方式是通过this：123456function foo() &#123; this.variable = \"potential accidental global\";&#125;// Foo called on its own, this points to the global object (window)// rather than being undefined.foo(); 为了阻止这种错误发生，在你的Javascript文件最前面添加’use strict;’。这开启了解析JavaScript的阻止意外全局的更严格的模式。全局变量的一个注意事项：即使我们谈了不明的全局变量，仍然存在很多代码被显式的全局变量填充的情况。这是通过定义不可收集的情况（除非清零或重新赋值）。特别的，用来临时存储和处理大量信息的全局变量会引起关注。如果必须用全局变量来存储很多数据，在处理完之后，确保对其清零或重新赋值。 一个在与全局连接上增加内存消耗常见的原因是缓存)。 缓存存储重复被使用的数据。为此，为了有效，缓存必须有其大小的上限。飙出限制的缓存可能会因为内容不可被回收，导致高内存消耗。 2.被遗忘的计时器或回调在JavaScript中setInterval的使用相当常见。其他库提供观察者和其他工具以回调。这些库中大多数，在引用的实例变成不可访问之后，负责让回调的任何引用也不可访问。在setInterval的情况下，这样的代码很常见：12345678var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource));&#125;&#125;, 1000); 这个例子表明了跳动的计时器可能发生什么：计时器使得节点或数据的引用不再被需要了。代表node的对象将来可能被移除，使得整个块在间隔中的处理不必要。然而，处理函数，由于间隔仍然是活跃的，不能被回收（间隔需要被停掉才能回收）。如果间隔处理不能被回收，它的依赖也不能被回收。那意味着可能存储着大量数据的someResource，也不能被回收。观察者情况下，一旦不被需要（或相关的对象快要访问不到）就创建明确移除他们的函数很重要。在过去，这由于特定浏览器（IE6）不能很好的管理循环引用（下面有更多相关信息），曾经尤为重要。现如今，一旦观察对象变成不可访问的，即使收听者没有明确的被移除，多数浏览器可以并会回收观察者处理函数。然而，它保持了在对象被处理前明确的移除这些观察者的好实践。例如：1234567891011var element = document.getElementById('button');function onClick(event) &#123; element.innerHtml = 'text';&#125;element.addEventListener('click', onClick);// Do stuffelement.removeEventListener('click', onClick);element.parentNode.removeChild(element);// Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don't// handle cycles well. 一条关于对象观察者及循环引用的笔记观察者和循环引用曾经是JavaScript开发者的祸患。这是由于IE垃圾回收的一个bug(或者设计决议)出现的情况。IE的老版本不能检测到DOM节点和JavaScript代码间的循环引用。 这是一个通常为观察到的保留引用（如同上面的例子）的观察者的典型。 也就是说，每次在IE中对一个节点添加观察者的时候，会导致泄漏。这是开发者在节点或空引用之前开始明确的移除处理函数的原因。 现在，现代浏览器（包括IE和MS Edge）使用可以剪裁这些循环和正确处理的现代垃圾回收算法。换言之，在使一个节点不可访问前，调用removeEventLister不是严格意义上必须的。像Jquery一样的框架和库做了在处置一个节点前（当为其使用特定的API的时候）移除监听者的工作。这被在库内部处理，即使在像老版本IE一样有问题的浏览器里面跑，也会确保没有泄漏产生。 3. 超出DOM引用有时存储DOM节点到数据结构中可能有用。假设你想要迅速的更新一个表格几行内容。存储每个DOM行节点的引用到一个字典或数组会起作用。当这发生是，两个对于同个DOM元素的引用被留存：一个在DOM树中，另外一个在字典中。如果在将来的某些点你决定要移除这些行，需要让两个引用都不可用。123456789101112131415161718var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text')&#125;;function doStuff() &#123;image.src = 'http://some.url/image';button.click();console.log(text.innerHTML);// Much more logic&#125;function removeButton() &#123;// The button is a direct child of body.document.body.removeChild(document.getElementById('button'));// At this point, we still have a reference to #button in the global// elements dictionary. In other words, the button element is still in// memory and cannot be collected by the GC.&#125; 对此的额外考虑，必须处理DOM树内的内部节点或叶子节点。假设你在JavaScript代码中保留了一个对于特定的表格内节点（一个td标签）的引用。在将来的某个点决定从DOM中移除这个表格，但是保留对于那个节点的引用。直观的，会假设GC会回收除那个节点之外的每个节点。在实践中，这不会发生的：这个单节点是那个表格的子节点，子节点保留对父节点引用。换句话说，来自JavaScript代码的表格元素的引用会引起在内存里存整个表格。当保留DOM元素的引用的时候，仔细考虑下。 4.闭包一个JavaScript开发的关键点是闭包：从父级作用域捕获变量的匿名函数。很多开发者发现，由于JavaScript runtime的实现细节，有以一种微妙的方式泄漏的可能，这种特殊的情况：123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(\"hi\"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 这个代码片段做了一件事：每次replaceThing被调用的时候，theThing获取到一个包括一个大数组和新闭包(somMethod)的新对象。同时，变量unused保留了一个有originalThing（theThing从之前的对replaceThing的调用）引用的闭包。已经有点疑惑了，哈？重要的是一旦一个作用域被在同个父作用域下的闭包创建，那个作用域是共享的。这种情况下，为闭包somMethod创建的作用域被unused共享了。unused有一个对originalThing的引用。即使unused从来没被用过，someMethod可以通过theTing被使用。由于someMethod和unused共享了闭包作用域，即使unused从来没被用过，它对originalThing的引用迫使它停留在活跃状态（不能回收）。当这个代码片段重复运行的时候，可以看到内存使用稳步的增长。GC运行的时候，这并不会减轻。本质上，一组关联的闭包被创建（同unused变量在表单中的根节点一起），这些闭包作用域中每个带了大数组一个非直接的引用，导致了大型的泄漏。 垃圾回收的直观行为即使垃圾回收很方便，他们有自己的一套权衡方法。其中一个权衡是nondeterminism。也就是说，GC是不可预期的。通常不能确定什么时候回收器被执行。这意味着在一些情况下，需要比程序正在使用的更多的内存。其他情况下，短的暂停在特别敏感的应用中很明显。即使不确定性意味着不能确定回收什么时候执行，大多数GC实现共享在分配期间，普通的回收通行证模式。如果没有执行分配，大多数CG停留在休息状态。考虑下面的方案：1.执行一组大型的分配。2.多数元素（或所有）被标记为不可访问（假设我们置空了一个指向不再需要的缓存的引用）。3.没有进一步的分配执行了。在这个方案中，大多GC不会运行任何进一步的回收通行了。换言之，即使有可用于回收的，不可访问的引用，回收器不会要求他了。这不是严格的泄漏，但是也会导致比平常更高的内存使用率。Google在 JavaScript Memory Profiling docs, example #2.文章中，提供了一个优秀的例子。 编写javascript代码时的优化1.从JavaScript的作用域谈起当JavaScript代码执行时，JavaScript引擎会创建一个执行环境，又叫执行上下文。执行环境定义了变量或函数有权访问的其他数据，决定了它们的行为，每个执行环境都有一个与它关联的变量对象，环境中定义的所有函数、变量都保存在这个对象中。在页面加载的时候，JavaScript引擎会创建一个全局的执行环境，所有全局变量和函数都是作为window对象（浏览器中）的属性和方法创建的。在此之后，每执行一个函数，JavaScript引擎都会创建一个对应的执行环境，并将该环境放入环境栈中，所以当前正在执行的函数的执行环境是在环境栈的最顶部的，当函数执行完毕之后，其执行环境会弹出栈，并被销毁，保存在其中的变量和函数定义也会被销毁。当代码在一个执行环境中执行时，JavaScript引擎会创建变量对象的一个作用域链，它可以保证对执行环境有权访问的变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。全局环境的作用域链中只有一个变量对象，它定义了所有可用的全局变量和函数。当函数被创建时，JavaScript引擎会把创建时执行环境的作用域链赋给函数的内部属性[[scope]]；当函数被执行时，JavaScript引擎会创建一个活动对象，最开始时这个活动对象只有一个变量，即arguments对象。该活动对象会出现在执行环境作用域链的顶端，接下来是函数[[scope]]属性中的对象。当需要查找某个变量或函数时，JavaScript引擎会通过执行环境的作用域链来查找变量和函数，从作用域链的顶端开始，如果没找到，则向下寻找直至找到为止。若一直到全局作用域都没有找到,则该变量或函数为undefined。举个栗子：1234function add(a,b) &#123; return a + b;&#125;var result = add(2,3); 代码执行时，add函数有一个仅包含全局变量对象的[[scope]]属性，add函数执行时，JavaScript引擎创建新的执行环境以及一个包含this、arguments、a、b的活动对象，并将其添加到作用域链中。如下图所示： 2.使用局部变量了解了作用域链的概念，我们应该知道在查找变量会从作用域链的顶端开始一层一层的向下找。显然，查找的层数越多，花费的时间越多。所以为了提高查找的速度，我们应该尽量使用 局部变量（到目前为止，局部变量是JavaScript中读写最快的标识符）。例如：1234567function createEle() &#123; document.createElement(\"div\");&#125;function createEle() &#123; var doc = document; doc.createElement(\"div\");&#125; 当document使用次数比较少时，可能无所谓，可是如果在一个函数的循环中大量使用document，我们可以提前将document变成局部变量。来看看jquery怎么写的：12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery;&#125;)(window); 这样写的优势：1、window和undefined都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。（原来的window处于作用域链的最顶端，查找速度慢）2、在jquery压缩版本jquery.min.js中可以将局部变量window替换成单个字母，减小文件大小，提高加载速度3、undefined也是JavaScript中的全局属性。将undefined作为参数传递给闭包，因为没给它传递值，它的值就是undefined，这样闭包内部在使用它的时候就可以把它当做局部变量使用，从而提高查找速度。undefined并不是JavaScript的保留字或者关键字。4、undefined在某些低版本的浏览器（例如IE8、IE7）中值是可以被修改的（在ECMAScript3中，undefined是可读/写的变量，可以给它赋任意值，这个错误在ECMAScript5中做了修正），将undefined作为参数并且不给它传值可以防止因undefined的值被修改而产生的错误。 3.避免增长作用域链在JavaScript中，有两种语句可以临时增加作用域链：with、try-catchwith可以使对象的属性可以像全局变量来使用，它实际上是将一个新的变量对象添加到执行环境作用域的顶部，这个变量对象包含了指定对象的所有属性，因此可以直接访问。这样看似很方便，但是增长了作用域链，原来函数中的局部变量不在处于作用域链的顶端，因此在访问这些变量的时候要查找到第二层才能找到它。当with语句块之行结束后，作用域链将回到原来的状态。鉴于with的这个缺点，所以不推荐使用。try-catch中的catch从句和with类似，也是在作用域链的顶端增加了一个对象，该对象包含了由catch指定命名的异常对象。但是因为catch语句只有在放生错误的时候才执行，因此影响比较少。 4.字符串链接优化由于字符串是不可变的，所以在进行字符串连接时，需要创建临时字符串。频繁创建、销毁临时字符串会导致性能低下。当然，这个问题在新版本浏览器包括IE8+中都得到了优化，所以不需要担心在低版本浏览器（IE6、IE7）中，我们可以种数组的join方法来代替。123456var temp = [];var i = 0;temp[i++] = \"Hello\";temp[i++] = \" \";temp[i++] =\"everyone\";var outcome = temp.join(\"\"); 5.条件判断当出现条件判断时，我们采用什么样的结构才能使性能最优？1234567891011if(val == 0) &#123; return v0;&#125;else if(val == 1) &#123; return v1;&#125;else if(val == 2) &#123; return v2;&#125;else if(val == 3) &#123; return v3;&#125;else if(val == 4) &#123; return v4;&#125; 当条件分支比较多时，我们可以斟酌哪种条件出现的概率比较大，并将对应的语句放在最上面，这样可以减少判断次数。使用switch语句，新版的浏览器基本上都对switch做了优化，这样层数比较深时，性能比if会更好使用数组：12var v = [v0,v1,v2,v3,v4];return v[valeue]; 要求：对应的结果是单一值，而不是一系列操作另外，其他方面的优化，譬如1234567891011if(condition1) &#123; return v1;&#125;else &#123; return v2&#125;// 改成if(condition1) &#123; return v1;&#125;return v2; 6.快速循环1、循环总次数使用局部变量12345678for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125; 这样就避免了每次循环的属性查找。这点尤其重要，因为在进行dom操作时，很多人会这样写：1234var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125; 查找DOM元素的属性是相对耗时的，所以应该避免这种写法。2、如果可以，递减代替递增1234567891011121314151617for(var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成for(var i = arr.length - 1;i--;) &#123;&#125;var i = 0;while(i &lt; arr.length) &#123; i++;&#125;// 改成var i = arr.length - 1;while(i--) &#123;&#125; i=0的时候会直接跳出，循环次数比较多时还是很有用的。 7.展开循环1234var i = arr.length - 1;while(i--) &#123; dosomething(arr[i]);&#125; 遇到这样的情况时，执行一次循环的时候我们可以选择不止执行一次函数。12345678910111213141516171819var interations = Math.floor(arr.length / 8);var left = arr.length % 8;var i = 0;if(left) &#123; do &#123; dosomething(arr[i++]); &#125; while(--left);&#125;do &#123; dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]); dosomething(arr[i++]);&#125; while(--interations); 当遇到大数组，减少循环的开销，性能不就提上去了嘛。（至于为什么是每次循环，调8次函数，大牛测出来的，这样达到最佳） 8.高效存取数据JavaScript中4种地方可以存取数据：字面量值；变量；数组元素；对象属性字面量值和变量中存取数据是最快的，从数组元素和对象属性中存取数据相对较慢，并且随着深度增加，存取速度会越来越慢，譬如obj.item.value就比obj.item慢。某些情况下我们可以将对象、数组属性存成局部变量来提高速度，譬如：12345678910111213141516171819for( var i = 0;i &lt; arr.length;i++) &#123;&#125;// 改成var len = arr.length;for( var i = 0;i &lt; len;i++) &#123;&#125;var divList = document.getElementsByTagName(\"div\");for( var i = 0;i &lt; divList.length;i++) &#123;&#125;// 改成// var divList = document.getElementsByTagName(\"div\");for( var i = 0,len = divList.length;i &lt; len;i++) &#123;&#125; 9.事件委托事件委托就是利用冒泡的原理，将原本应该添加在某些元素身上的监听事件，添加到其父元素身上，来达到提高性能的效果。举个栗子：1234567891011121314151617181920212223242526&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); for(var i = 0,len = liList.length;i &lt; len;i++) &#123; liList[i].onclick = function() &#123; alert(this.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样我们就为每个li添加了监听事件了。显然，我们通过循环为每个li添加监听事件是不优化的。这样不仅浪费了内存，在新的li加入的时候我们还要重新为它添加监听事件。我们可以这样写：1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;window.onload = function() &#123; var ul = document.getElementsByTagName('ul')[0]; var liList = document.getElementsByTagName('li'); ul.onclick = function(e) &#123; var e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName.toLowerCase() == \"li\") &#123; alert(target.innerHTML); &#125; &#125;&#125;&lt;/script&gt; 这样写的好处：只添加一个监听事件，节省了内存；新加入li的时候我们也不用为它单独添加监听事件；在页面中添加事件处理程序所需的时候更少，因为我们只需要为一个DOM元素添加事件处理程序。 使用typescript使用typescript来提高性能我实在一本关于nodejs的书里看到的，主要还是用在chrome的V8引擎上，这本书里写的比如1234567// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; console.log(add(i + i*3));&#125; 书里说，如果V8引擎发现一个函数使用频率很高，而且参数传入的都是同一种类型的，好像是在内存寻址的时候书都很快，因为引擎认为传入的参数就是int型。再来看一个例子1234567891011// 两个数相加的函数function add(a, b) &#123; return a + b;&#125;for(let i=0; i&lt;10000; i++) &#123; if(i % 8 === 0) &#123; console.log(add(i + i*0.3)); // 这里出现了浮点数 &#125;else &#123; console.log(add(i + i*3)); // 这里是整数 &#125;&#125; 上边的代码可以看到，在使用整形参数的时候突然传入浮点数，V8引擎寻址机制突然变化，丢弃之前的函数，使用新的来计算，性能下降。所以，如果使用typescript，类型固定，这样性能就会提高哦。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"vue双向绑定的简单实现","slug":"vue双向绑定的简单实现","date":"2018-08-30T03:13:39.000Z","updated":"2018-09-14T05:58:16.386Z","comments":true,"path":"2018/08/30/vue双向绑定的简单实现/","link":"","permalink":"/2018/08/30/vue双向绑定的简单实现/","excerpt":"参考网上vue实现教程简单整理","text":"参考网上vue实现教程简单整理 vue双向绑定的简单实现&emsp;&emsp;首先，这篇文章并非我的原创，在网上看到了很多写vue原理的文章，感觉这篇写的层次结构清晰，容易理解，所以留作收藏。废话不多说，开始。 1.原理&emsp;&emsp;Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过 Object对象的defineProperty属性，重写data的set和get函数来实现的,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。添加网上的一张图 2.实现页面结构很简单，如下：1234567&lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button ype=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt;&lt;/div&gt; 包含：1.一个input，使用v-model指令2.一个button，使用v-click指令3.一个h3，使用v-bind指令。我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释：1234567891011var app = new myVue(&#123; el:'#app', data:&#123; number:0 &#125;, methods:&#123; increment:function()&#123; this.number++; &#125;, &#125; &#125;) 首先我们需要定义一个myVue构造函数：123function myVue(options)&#123;&#125; 为了初始化这个构造函数，给它添加一 个_init属性123456789function myVue(options) &#123; this._init(options);&#125;myVue.prototype._init = function (options) &#123; this.$options = options; // options 为上面使用时传入的结构体，包括el,data,methods this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素 this.$data = options.data; // this.$data = &#123;number: 0&#125; this.$methods = options.methods; // this.$methods = &#123;increment: function()&#123;&#125;&#125; &#125; 接下来实现_obverse函数，对data进行处理，重写data的set和get函数并改造_init函数12345678910111213141516171819202122232425262728293031323334myVue.prototype._obverse = function (obj) &#123; // obj = &#123;number: 0&#125; var value; for (key in obj) &#123; //遍历obj对象 if (obj.hasOwnProperty(key)) &#123; value = obj[key]; if (typeof value === 'object') &#123; //如果值还是对象，则遍历处理 this._obverse(value); &#125; Object.defineProperty(this.$data, key, &#123; //关键 enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; &#125; &#125; &#125;) &#125; &#125; &#125;myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._obverse(this.$data); &#125; 接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新12345678910111213function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。 &#125; 更新_init函数以及_obverse函数1234567891011121314151617181920212223242526272829myVue.prototype._init = function (options) &#123; //... this._binding = &#123;&#125;; //_binding保存着model与view的映射关系，也就是我们前面定义的Watcher的实例。当model改变时，我们会触发其中的指令类更新，保证view也能实时更新 //... &#125; myVue.prototype._obverse = function (obj) &#123; //... if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; // 按照前面的数据，_binding = &#123;number: _directives: []&#125; _directives: [] &#125;; //... var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; //... set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; // 当number改变时，触发_binding[number]._directives 中的绑定的Watcher类的更新 item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; 那么如何将view与model进行绑定呢？接下来我们定义一个_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 myVue.prototype._init = function (options) &#123; //... this._complie(this.$el); &#125; myVue.prototype._complie = function (root) &#123; root 为 id为app的Element元素，也就是我们的根元素 var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; // 对所有元素进行遍历，并进行处理 this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++ node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); //bind是使data的作用域与method函数的作用域保持一致 &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件 node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); //_this._binding['number']._directives = [一个Watcher实例] // 其中Watcher.prototype.update = function () &#123; // node['vaule'] = _this.$data['number']; 这就将node的值保持与number一致 // &#125; _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定 &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可 var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; 至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图 附上全部代码，不到150行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 &lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;myVue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #app &#123; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" v-model=\"number\"&gt; &lt;button type=\"button\" v-click=\"increment\"&gt;增加&lt;/button&gt; &lt;/form&gt; &lt;h3 v-bind=\"number\"&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function myVue(options) &#123; this._init(options); &#125; myVue.prototype._init = function (options) &#123; this.$options = options; this.$el = document.querySelector(options.el); this.$data = options.data; this.$methods = options.methods; this._binding = &#123;&#125;; this._obverse(this.$data); this._complie(this.$el); &#125; myVue.prototype._obverse = function (obj) &#123; var value; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; this._binding[key] = &#123; _directives: [] &#125;; value = obj[key]; if (typeof value === 'object') &#123; this._obverse(value); &#125; var binding = this._binding[key]; Object.defineProperty(this.$data, key, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(`获取$&#123;value&#125;`); return value; &#125;, set: function (newVal) &#123; console.log(`更新$&#123;newVal&#125;`); if (value !== newVal) &#123; value = newVal; binding._directives.forEach(function (item) &#123; item.update(); &#125;) &#125; &#125; &#125;) &#125; &#125; &#125; myVue.prototype._complie = function (root) &#123; var _this = this; var nodes = root.children; for (var i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i]; if (node.children.length) &#123; this._complie(node); &#125; if (node.hasAttribute('v-click')) &#123; node.onclick = (function () &#123; var attrVal = nodes[i].getAttribute('v-click'); return _this.$methods[attrVal].bind(_this.$data); &#125;)(); &#125; if (node.hasAttribute('v-model') &amp;&amp; (node.tagName == 'INPUT' || node.tagName == 'TEXTAREA')) &#123; node.addEventListener('input', (function(key) &#123; var attrVal = node.getAttribute('v-model'); _this._binding[attrVal]._directives.push(new Watcher( 'input', node, _this, attrVal, 'value' )) return function() &#123; _this.$data[attrVal] = nodes[key].value; &#125; &#125;)(i)); &#125; if (node.hasAttribute('v-bind')) &#123; var attrVal = node.getAttribute('v-bind'); _this._binding[attrVal]._directives.push(new Watcher( 'text', node, _this, attrVal, 'innerHTML' )) &#125; &#125; &#125; function Watcher(name, el, vm, exp, attr) &#123; this.name = name; //指令名称，例如文本节点，该值设为\"text\" this.el = el; //指令对应的DOM元素 this.vm = vm; //指令所属myVue实例 this.exp = exp; //指令对应的值，本例如\"number\" this.attr = attr; //绑定的属性值，本例为\"innerHTML\" this.update(); &#125; Watcher.prototype.update = function () &#123; this.el[this.attr] = this.vm.$data[this.exp]; &#125; window.onload = function() &#123; var app = new myVue(&#123; el:'#app', data: &#123; number: 0 &#125;, methods: &#123; increment: function() &#123; this.number ++; &#125;, &#125; &#125;) &#125;&lt;/script&gt; 以上就是所有内容，这个代码不是我创造的，我只是代码的搬运工。","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}]},{"title":"webSocket","slug":"webSocket项目中的使用","date":"2018-08-29T01:23:54.000Z","updated":"2018-09-14T05:52:25.058Z","comments":true,"path":"2018/08/29/webSocket项目中的使用/","link":"","permalink":"/2018/08/29/webSocket项目中的使用/","excerpt":"在项目中使用websocket的小心得","text":"在项目中使用websocket的小心得 webSocket在项目中的使用&emsp;&emsp;webSocket,这个技术相信大家都已经很熟悉了，就是前端浏览器与后端服务器一直保持连通状态，我们在项目中，经常会遇到这样的需求，一个数据图表展示页面，产品的需求是每隔5秒钟页面刷新一次，传统的做法是请求轮询机制，也就是setInterval这个定时器，一遍又一遍的请求后端接口，这个方法简单（特别是后端简单），但是如果前端页面有大量的这种需求，会影响性能，所以，webSocket是现在最好的选择。&emsp;&emsp;其实webSocket现在还是比较重要的，一般在面试的时候，被问到的几率还是很大的。我之前在项目中没有用到过，但是自己写过webSocket的demo，浏览器配合nodejs来写，也是参考了网上的代码，还是很简单的webSocket详细代码看这里。在面试时被问到的时候，也是实话实说，有可能面试官也是小白，基本上都没往下问，但是，确实是这么简单吗？答案显然不是，待我慢慢道来。&emsp;&emsp;首先，我在最近两个项目中，都用到了webSocket，所以还是有发言权的。如果，产品提出了webSocket的需求，对于我们前端来说，并不是直接写个原生的webSocket就可以，而是需要看后端小伙伴们的脸色，什么意思？就是说得看后端用的是什么webSocket库，我接触的有两种，第一个是stomp,说是webSocket的子协议，后端选了这个库之后，我们前端也得相应的选择与后端相配合的前端库，一般情况下，官网很明确的给出了后端和前端相配合写法，当然，写法也是很简单，跟原生差不多。第二个是，sockjs这个库，当然，也是后端小伙伴选好了之后，告诉我，我相应的在前端也用的跟后端一样库。&emsp;&emsp;最后总结一下，webSocket技术并不难（对于我们前端来说，当然，nodejs的后端也很简单，java就不知道了，每次调起来看他们都是一脸懵逼的样子），无论是面试还是在实际工作中，问道这个问题时，我们首先想到的应该是，后端选择的是什么库，我们前端应该跟后端小伙伴保持一致，可别需求以来，觉得简单直接开些，等联调的时候，我靠，为什么连不上呢？你们前后端不在一个频道上，怎么连接啊。所以，我们要说，我做过的项目是这样这样滴，不知道这次我们后端小伙伴用到的webSocket库是什么呢？","categories":[{"name":"javascript","slug":"javascript","permalink":"/categories/javascript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"webSocket","slug":"webSocket","permalink":"/tags/webSocket/"}]},{"title":"nodejs代理服务器","slug":"nodejs代理服务器","date":"2018-08-27T06:51:52.000Z","updated":"2018-09-14T05:59:05.665Z","comments":true,"path":"2018/08/27/nodejs代理服务器/","link":"","permalink":"/2018/08/27/nodejs代理服务器/","excerpt":"nodejs代理服务器简单实现","text":"nodejs代理服务器简单实现 nodejs代理服务 最近在与后台同事联调的时候，出现了点故障，跨域，这个经常碰到很好解决的问题，但是一般情况下需要前后端一起配合来解决，比如jsonp，或者h5后端在返回头加上允许跨域的头设置，但是如果后台同事是个小白，问啥啥不明白，也是没招了。我之前还用过将chrome的跨域设置给禁掉的方法，但是这次不知道为啥，也不好使了。最后，只能是用代理这种方式，我现在用的是vue框架，其实vue的脚手架已经集成了跨域功能，只需要配置一下就可以，但是，现在框架这么多，前一阵子还react，angular的项目，最近有换成vue，配置的话，肯定要去查看api，记不住啊，而且，版本不同，设置方法也不同，不如自己写一个，这样多简单，需要的时候把代理服务开启就搞定了。于是乎，自己写一个，当然，稍微想一下就知道，代理的原理，就是利用nodejs在中间做一次请求以及数据返回，不过自己写还得思考，上网找一下多简单，baidu一搜索，哇靠，第一个映入眼帘的就是nodejs代理服务8行代码，嗯，就是这么简单，废话不多说，上代码,当然，自己还得加工一下哦。123456789101112131415161718192021var express = require('express');var request = require('request');var app = express();const proxyUrl = process.argv[2] || 'http://127.0.0.1:8888'; // 如果有传入的代理url，使用它app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") res.send(200); // 让options请求快速返回 else next();&#125;);app.use('/', function(req, res) &#123; var url = proxyUrl + req.url; req.pipe(request(url)).pipe(res);&#125;);app.listen(process.env.PORT || 3000, ()=&gt;&#123; console.log('代理服务器，在3000端口已经开启');&#125;); 再把package.json文件内容贴出来12345678910111213141516&#123; &quot;name&quot;: &quot;node-proxy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;node server http://127.0.0.1:9000&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.3&quot;, &quot;request&quot;: &quot;^2.88.0&quot; &#125;&#125; 源码在这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"/categories/nodejs/"}],"tags":[{"name":"后端代理服务","slug":"后端代理服务","permalink":"/tags/后端代理服务/"}]}]}