<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>使用 Rust 锈化前端工具链 | jinux</title>
  <meta name="description" content="前端 学习 javascript">
  <meta name="keywords" content>
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="jinux">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="使用Rust构建前端工具链">
<meta name="keywords" content="Rust">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 Rust 锈化前端工具链">
<meta property="og:url" content="/2025/06/03/使用-Rust-锈化前端工具链/index.html">
<meta property="og:site_name" content="jinux">
<meta property="og:description" content="使用Rust构建前端工具链">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2025-06-03T06:54:08.055Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 Rust 锈化前端工具链">
<meta name="twitter:description" content="使用Rust构建前端工具链">

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				<!-- <i class="fa fa-home"></i> -->
				jinux
			</a>

				<div class='menu'>
					<ul class='h-list'>
						
							<li>
								<a class='flat-box nav-home' href='/'>
									<i class="fa fa-home"></i>
									主页
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-cube' href='/categories'>
									<i class="fa fa-cube"></i>
									导航
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-github' href='https://github.com/jinux7'>
									<i class="fa fa-github"></i>
									github
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-archive' href='/archives'>
									<i class="fa fa-archive"></i>
									归档
								</a>
							</li>
						
					</ul>
					<div class='underline'></div>
				</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon"><i class="fa fa-search"></i></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><i class="fa fa-search flat-box"></i></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><i class="fa fa-navicon flat-box"></i></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				xaoxuu
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><i class="fa fa-comments flat-box"></i></a></li>
				<li class='s-top'><a href='javascript:void(0)'><i class="fa fa-arrow-up flat-box"></i></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><i class="fa fa-list-ul flat-box"></i></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
        <div class="header">jinux</div>
		<nav>
			
				<a href="/" class="nav-home nav">
					<i class="fa fa-home"></i>
					主页
				</a>
			
				<a href="/categories" class="nav-cube nav">
					<i class="fa fa-cube"></i>
					导航
				</a>
			
				<a href="https://github.com/jinux7" class="nav-github nav">
					<i class="fa fa-github"></i>
					github
				</a>
			
				<a href="/archives" class="nav-archive nav">
					<i class="fa fa-archive"></i>
					归档
				</a>
			
		</nav>
	</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-使用-Rust-锈化前端工具链" class="post white-box article-type-post" itemscope itemprop="blogPost">
    <section class='meta'>
        <h1 class="title">
            
                使用 Rust 锈化前端工具链
            
        </h1>
        <time>
            2025-06-03 Tuesday&nbsp;&nbsp;
            <i class="fa fa-eye" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
        </time>
        
    
    <div class='cats'>
        <a href="/categories/nodejs/">nodejs</a>
    </div>


    </section>
    
        <section class="toc-wrapper">
            <div class="header"><i class="fa fa-list" aria-hidden="true"></i>&nbsp;&nbsp;目录</div>
            <div class='content'>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锈化开发工具的方式"><span class="toc-number">2.</span> <span class="toc-text">锈化开发工具的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初识-NAPI-RS"><span class="toc-number">3.</span> <span class="toc-text">初识 NAPI-RS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于-NAPI-RS-开发-Node-扩展"><span class="toc-number">4.</span> <span class="toc-text">基于 NAPI-RS 开发 Node 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-调用-Rust"><span class="toc-number">4.1.</span> <span class="toc-text">JavaScript 调用 Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调用-Rust-函数"><span class="toc-number">4.1.1.</span> <span class="toc-text">调用 Rust 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#以-Object-作为参数"><span class="toc-number">4.1.2.</span> <span class="toc-text">以 Object 作为参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rust-调用-JavaScript"><span class="toc-number">4.2.</span> <span class="toc-text">Rust 调用 JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一个调用-JS-函数的简单例子"><span class="toc-number">4.2.1.</span> <span class="toc-text">一个调用 JS 函数的简单例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取-JS-函数的返回值"><span class="toc-number">4.2.2.</span> <span class="toc-text">获取 JS 函数的返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用call-async获取-JS-函数返回值"><span class="toc-number">4.2.3.</span> <span class="toc-text">使用call_async获取 JS 函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正确处理-JS-函数的返回值"><span class="toc-number">4.2.4.</span> <span class="toc-text">正确处理 JS 函数的返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-VSCode-进行调试"><span class="toc-number">5.</span> <span class="toc-text">使用 VSCode 进行调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建发布"><span class="toc-number">6.</span> <span class="toc-text">构建发布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol>
            </div>
        </section>
    

    <section class="article typo">

        <div class="article-entry" itemprop="articleBody">
            <p>使用Rust构建前端工具链<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来，Rust的受欢迎程度不断上升。首先，在操作系统领域，Rust 已成为 Linux 内核官方认可的开发语言之一，Windows 也宣布将使用 Rust 来重写内核，并重写部分驱动程序。此外，国内手机厂商 Vivo 也宣布使用 Rust 开发了名为“蓝河”的操作系统。除此之外，Rust 在图形渲染、游戏开发、中间件开发、边缘计算、计算安全等领域也是遍地开花，可以说，Rust 正在以惊人的速度重塑着各个领域的发展，让人不禁感叹 Rust 已经在重写万物了。</p>
<p>那回到前端领域，正在进行一场构建工具的革命，除了老牌的 Babel 竞争对手<a href="https://swc.rs/" target="_blank" rel="noopener">swc</a>，一些新兴的前端构建工具也都在使用 Rust 进行开发，例如<a href="https://turbo.build/pack" target="_blank" rel="noopener">Turbopack</a>、<a href="https://parceljs.org/" target="_blank" rel="noopener">Parcel</a>，对标 Webpack 的<a href="https://www.rspack.dev/" target="_blank" rel="noopener">Rspack</a>，对标 Vite 的<a href="https://farm-fe.github.io/" target="_blank" rel="noopener">Farm</a>等等。所以，对于广大前端同胞来说，C/C++ 太难，学习和掌握 Rust 是一个不错的选择，虽然 Rust 也不见得容易许多，它有着陡峭的学习曲线，但它或许是我们突破闭塞的前端区间的一把钥匙，帮助我们打开通往新世界的大门。</p>
<h2 id="锈化开发工具的方式"><a href="#锈化开发工具的方式" class="headerlink" title="锈化开发工具的方式"></a>锈化开发工具的方式</h2><p>虽说 Rust 的学习曲线可能相对陡峭，但笔者认为这是对于要全面掌握 Rust 这门语言而言的，而我们学习语言的目的最重要的是掌握一项可以帮我们解决问题的技能，因此，对于 Rust 不需要抱有太多的恐惧和敬畏之心，只需要摒除杂念立马开始学习 + 撸码，剩下的就交给时间来慢慢积累经验。此外，对于不是那么复杂应用来说，熟悉 Rust 基本语法和数据结构，翻过「所有权机制」和「生命周期」两座大山，基本也足以应付了。</p>
<p>本文建立在读者已经有一定的 Rust 知识基础上，对于 Rust 基本语法就不做赘述了。当前，大部分前端研发都是在 Node 环境下进行的，所以我们通过 Rust 来改造开发工具，主要有两种形式：</p>
<ul>
<li><p>使用 WASM 的方式，基于<a href="https://rustwasm.github.io/wasm-pack/" target="_blank" rel="noopener">wasm-pack</a>，将 Rust 代码编译成 WASM，以供 Node 调用</p>
</li>
<li><p>将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于napi-rs和neon来实现</p>
</li>
</ul>
<p>在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么此时就应该选择 Node addons 的方式了。而<a href="https://napi.rs/" target="_blank" rel="noopener">napi-rs</a>和<a href="https://neon-bindings.com/" target="_blank" rel="noopener">neon</a>的选择的话，napi-rs相对而言比较简单和轻量，而且针对不同版本的 Node 不需要重新编译，所以我们考虑选择napi-rs作为锈化开发工具的方式。</p>
<h2 id="初识-NAPI-RS"><a href="#初识-NAPI-RS" class="headerlink" title="初识 NAPI-RS"></a>初识 NAPI-RS</h2><p>我们可以通过 napi-rs 的开发工具 <strong>@napi-rs/cli</strong>以及<a href="https://github.com/napi-rs/package-template" target="_blank" rel="noopener">项目模板</a>来初始化一个应用，这里推荐使用项目模板，因为经过笔者的测试，开发工具创建的项目内容上相较于模板比较落后，对于后续深入使用上会造成一定的困惑。</p>
<p>从 napi-rs 项目模板内容上看，可以发现项目结构完善，工程化相关能力非常齐全，提供了构建工具、测试用例编写、Github CI 工作流等等必须的能力，我们只需要关注编码就可以了。</p>
<p>我们先来关注一下生成的 napi-rs 项目文件。从package.json和npm分析可以看出，一个 napi-rs 项目主要是由主包和 npm 下的针对不同平台的编译构建结果子包组成，napi-rs 会根据用户的配置，将用户的 Rust 代码构建为不同平台下的 Node 扩展 binding 文件，这些文件会放到 npm 下对应的平台目录中，再由 package.json 中 main 字段指定导出，用户在安装主包的时候，会根据用户电脑情况加载对应构建结果子包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@tarojs/parse-css-to-stylesheet-darwin-x64&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.25&quot;,</span><br><span class="line">  &quot;os&quot;: [</span><br><span class="line">    &quot;darwin&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;cpu&quot;: [</span><br><span class="line">    &quot;x64&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;main&quot;: &quot;parse-css-to-stylesheet.darwin-x64.node&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;parse-css-to-stylesheet.darwin-x64.node&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &quot;https://github.com/NervJS/parse-css-to-stylesheet&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在主包入口index.js中将根据用户宿主平台，加载对应的扩展文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">switch (platform) &#123;</span><br><span class="line">  case &apos;win32&apos;:</span><br><span class="line">    switch (arch) &#123;</span><br><span class="line">      case &apos;x64&apos;:</span><br><span class="line">        localFileExisted = existsSync(</span><br><span class="line">          join(__dirname, &apos;parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">        )</span><br><span class="line">        try &#123;</span><br><span class="line">          if (localFileExisted) &#123;</span><br><span class="line">            nativeBinding = require(&apos;./parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            nativeBinding = require(&apos;@tarojs/parse-css-to-stylesheet-win32-x64-msvc&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          loadError = e</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    break</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>从@napi-rs/triples这个包中可以看到所有支持的平台列表，而对于常规性的 Node 应用来说，我们不需要构建这么多平台，一般来说构建x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台也足够了，这样也能减少 CI 的构建时间。</p>
<p>napi-rs 默认构建的平台是x86_64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu，在<a href="https://github.com/napi-rs/napi-rs/blob/main/cli/src/utils/target.ts#L25" target="_blank" rel="noopener">这里</a>可以看到，所以为了增加 MAC Book M 系列电脑的支持，我们需要增加aarch64-apple-darwin的配置，可以在 package.json 中napi字段中添加，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;napi&quot;: &#123;</span><br><span class="line">  &quot;binaryName&quot;: &quot;taro&quot;,</span><br><span class="line">  &quot;triples&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: true,</span><br><span class="line">    &quot;additional&quot;: [</span><br><span class="line">      &quot;aarch64-apple-darwin&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以开始我们的编码之旅咯！</p>
<h2 id="基于-NAPI-RS-开发-Node-扩展"><a href="#基于-NAPI-RS-开发-Node-扩展" class="headerlink" title="基于 NAPI-RS 开发 Node 扩展"></a>基于 NAPI-RS 开发 Node 扩展</h2><p>基于 napi-rs 开发 Node 扩展，除了 Rust 编码本身外，无非需要关注两种情况，即 JavaScript 调用 Rust 和 Rust 调用 JavaScript。</p>
<h3 id="JavaScript-调用-Rust"><a href="#JavaScript-调用-Rust" class="headerlink" title="JavaScript 调用 Rust"></a>JavaScript 调用 Rust</h3><h4 id="调用-Rust-函数"><a href="#调用-Rust-函数" class="headerlink" title="调用 Rust 函数"></a>调用 Rust 函数</h4><p>这是最常见的用法，因为我们一般使用 Rust 开发 Node 扩展，也是为了将一些 CPU 密集型任务的任务使用 Rust 来实现，再暴露给 JS 来调用，从而达到提升应用性能的目的，最为常见的是 Rust 暴露方法给到 JS 调用，通过项目模板生成的 napi-rs 示例也可以看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/lib.rs </span><br><span class="line">use napi_derive::napi;</span><br><span class="line"></span><br><span class="line">#[napi]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码，通过给plus_100函数添加#[napi]属性宏，这样可以标记该函数，表示该函数可以通过 N-API 在 Node.js 中调用，在项目编译后的 typing 文件中，我们能看到对应生成了 JS 函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function plus100(input: number): number</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里生成 JS 函数名是 napi-rs 自己的规则，我们也可以自定义暴露的函数名，通过js_name属性可以指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#[napi(js_name = &quot;plus_100&quot;)]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，除了暴露函数这一基本操作之外，我们还可以暴露常量、对象、类、enum 等等给到 JS 侧去调用，这些可以通过 napi-rs 的<a href="https://napi.rs/docs/concepts/values" target="_blank" rel="noopener">官方文档</a>可以查阅到。</p>
<h4 id="以-Object-作为参数"><a href="#以-Object-作为参数" class="headerlink" title="以 Object 作为参数"></a>以 Object 作为参数</h4><p>而在 JS 调用 Rust 编码中，最需要关注的是调用函数时，JS 侧给 Rust 传对象作为参数，这里为了提升性能，建议提前在 Rust 中定义好传递对象的数据结构，在 JS 中以引入该数据结构定义，规范数据传递即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 定义好数据结构</span><br><span class="line">// napi(object) 表示紧随其后的 struct （结构体）将通过 N-API 以 JavaScript 对象的形式暴露出去</span><br><span class="line">#[napi(object)]</span><br><span class="line">pub struct Project &#123;</span><br><span class="line">  pub project_root: String,</span><br><span class="line">  pub project_name: String,</span><br><span class="line">  pub npm: NpmType,</span><br><span class="line">  pub description: Option,</span><br><span class="line">  pub typescript: Option,</span><br><span class="line">  pub template: String,</span><br><span class="line">  pub css: CSSType,</span><br><span class="line">  pub auto_install: Option,</span><br><span class="line">  pub framework: FrameworkType,</span><br><span class="line">  pub template_root: String,</span><br><span class="line">  pub version: String,</span><br><span class="line">  pub date: Option,</span><br><span class="line">  pub compiler: Option,</span><br><span class="line">  pub period: PeriodType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JS 中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义，其中 Project 由 Rust binding 中暴露</span><br><span class="line">export function createProject(conf: Project)</span><br><span class="line"></span><br><span class="line">// 函数调用</span><br><span class="line">createProject(&#123;</span><br><span class="line">  projectRoot: projectDir,</span><br><span class="line">  projectName,</span><br><span class="line">  template,</span><br><span class="line">  npm,</span><br><span class="line">  framework,</span><br><span class="line">  css: this.conf.css || CSSType.None,</span><br><span class="line">  autoInstall: autoInstall,</span><br><span class="line">  templateRoot: getRootPath(),</span><br><span class="line">  version: getPkgVersion(),</span><br><span class="line">  typescript: this.conf.typescript,</span><br><span class="line">  date: this.conf.date,</span><br><span class="line">  description: this.conf.description,</span><br><span class="line">  compiler: this.conf.compiler,</span><br><span class="line">  period: PeriodType.CreateAPP,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="Rust-调用-JavaScript"><a href="#Rust-调用-JavaScript" class="headerlink" title="Rust 调用 JavaScript"></a>Rust 调用 JavaScript</h3><p>而 Rust 中也可以调用 JS 提供的方法，这在做 Node 开发工具的时候非常有用，因为有时候我们需要读取开发人员的配置代码给到 Rust 调用，其中就可能会遇到 Rust 调用 JavaScript 中函数的情况。</p>
<h4 id="一个调用-JS-函数的简单例子"><a href="#一个调用-JS-函数的简单例子" class="headerlink" title="一个调用 JS 函数的简单例子"></a>一个调用 JS 函数的简单例子</h4><p>在 napi-rs 中调用 JS 函数主要通过ThreadsafeFunction来实现，请看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  for n in 0..100 &#123;</span><br><span class="line">    let tsfn = callback.clone();</span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，call_threadsafe_function函数接受了一个类型为ThreadsafeFunction<u32>的参数，这表明call_threadsafe_function被编译为 JS 函数后将接受一个回调函数作为参数，而该回调函数的有效参数为u32即number类型，而在call_threadsafe_function函数体中，通过thread::spawn开辟子线程，以阻塞的方式调用这个传入的回调函数。</u32></p>
<p>通过ThreadsafeFunction的call方法可以调用到传入的 JS 回调函数，但是我们会发现它拿不到返回值，如果我们需要获取到 JS 回调函数的返回值时，我们需要使用call_with_return_value和call_async两个方法。</p>
<h4 id="获取-JS-函数的返回值"><a href="#获取-JS-函数的返回值" class="headerlink" title="获取 JS 函数的返回值"></a>获取 JS 函数的返回值</h4><p>对比call与call_with_return_value的实现可以看出，call_with_return_value比call多一个回调函数参数，并且可以指定 JS 回调函数返回值的类型，并且该类型需要满足FromNapiValue这个 trait，因为call_with_return_value在处理 JS 回调函数时会调用它的from_napi_value方法将 JS 数据转为 Rust 的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/napi-rs/napi-rs/blob/main/crates/napi/src/threadsafe_function.rs#L428</span><br><span class="line">pub fn call(&amp;self, value: Result, mode: ThreadsafeFunctionCallMode) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::Direct,</span><br><span class="line">            callback: Box::new(|_d: Result| Ok(())),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn call_with_return_value Result&lt;()&gt;&gt;(</span><br><span class="line">  &amp;self,</span><br><span class="line">  value: Result,</span><br><span class="line">  mode: ThreadsafeFunctionCallMode,</span><br><span class="line">  cb: F,</span><br><span class="line">) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">            callback: Box::new(move |d: Result| &#123;</span><br><span class="line">              d.and_then(|d| D::from_napi_value(d.0.env, d.0.value).and_then(cb))</span><br><span class="line">            &#125;),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>call_with_return_value的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  callback.call_with_return_value(Ok(1), ThreadsafeFunctionCallMode::Blocking, move |result: u32| &#123;</span><br><span class="line">    println!(&quot;callback: &#123;result:?&#125;&quot;);</span><br><span class="line">    Ok(())</span><br><span class="line">  &#125;);</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，JS 回调函数的返回值是在call_with_return_value的第三个回调函数参数中获取到的，这就导致如果我们需要依赖这个 JS 函数返回值的话，我们后续的逻辑代码只能写在call_with_return_value的第三个回调函数参数中，对我们的代码逻辑书写造成诸多不便，代码可读性降低，所以推荐使用call_async方法来执行 JS 函数，并获取参数。</p>
<h4 id="使用call-async获取-JS-函数返回值"><a href="#使用call-async获取-JS-函数返回值" class="headerlink" title="使用call_async获取 JS 函数返回值"></a>使用call_async获取 JS 函数返回值</h4><p>从call_async的实现可以看出，它首先使用了tokio创建了一个 one-shot 通道，让 JS 函数以不阻塞的方式异步运行，并在执行完成后通过sender 发送操作结果，而使用receiver进行等待执行结果，并将结果返回，同时要使用call_async方法，需要在Cargo.toml中为napi依赖打开tokio_rt特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(feature = &quot;tokio_rt&quot;)]</span><br><span class="line">pub async fn call_async(&amp;self, value: Result) -&gt; Result &#123;</span><br><span class="line">  let (sender, receiver) = tokio::sync::oneshot::channel::&gt;();</span><br><span class="line"></span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Err(crate::Error::from_status(Status::Closing));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_status!(</span><br><span class="line">      unsafe &#123;</span><br><span class="line">        sys::napi_call_threadsafe_function(</span><br><span class="line">          self.handle.get_raw(),</span><br><span class="line">          Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">            ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">              data,</span><br><span class="line">              call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">              callback: Box::new(move |d: Result| &#123;</span><br><span class="line">                sender</span><br><span class="line">                  .send(d.and_then(|d| D::from_napi_value(d.0.env, d.0.value)))</span><br><span class="line">                  .map_err(|_| &#123;</span><br><span class="line">                    crate::Error::from_reason(&quot;Failed to send return value to tokio sender&quot;)</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)))</span><br><span class="line">          .cast(),</span><br><span class="line">          ThreadsafeFunctionCallMode::NonBlocking.into(),</span><br><span class="line">        )</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Threadsafe function call_async failed&quot;</span><br><span class="line">    )</span><br><span class="line">  &#125;)?;</span><br><span class="line">  receiver</span><br><span class="line">    .await</span><br><span class="line">    .map_err(|_| &#123;</span><br><span class="line">      crate::Error::new(</span><br><span class="line">        Status::GenericFailure,</span><br><span class="line">        &quot;Receive value from threadsafe function sender failed&quot;,</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">    .and_then(|ret| ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见call_async使用时将引入 Rust 的异步编程，我们可以使用async/await关键字来进行调用，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub async fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result &#123;</span><br><span class="line">  let result = match callback.call_async::(Ok(1)).await &#123;</span><br><span class="line">    Ok(res) =&gt; res,</span><br><span class="line">    Err(e) =&gt; &#123;</span><br><span class="line">      println!(&quot;Error: &#123;&#125;&quot;, e);</span><br><span class="line">      0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  println!(&quot;result: &#123;result:?&#125;&quot;);</span><br><span class="line">  Ok(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时生成的 JS 函数定义为如下，可以看出callThreadsafeFunction变成了一个异步函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function callThreadsafeFunction(callback: (err: Error | null, value: number) =&gt; any): Promise&lt;number&gt;</span><br></pre></td></tr></table></figure></p>
<p>所以在 JS 中调用方式及输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const result = await callThreadsafeFunction((err, value) =&gt; &#123;</span><br><span class="line">  return value + 1</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// result: 2</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p>
<h4 id="正确处理-JS-函数的返回值"><a href="#正确处理-JS-函数的返回值" class="headerlink" title="正确处理 JS 函数的返回值"></a>正确处理 JS 函数的返回值</h4><p>从前面call_async的实现可以看出，call_async返回的数据，也即 JS 函数返回值需要满足如下泛型约束D: ‘static + FromNapiValue，而 napi-rs 默认会为数值、字符串、布尔等基本 JS 数据类型实现FromNpiValuetrait，但是如果我们的 JS 回调想要返回一个对象时，则需要自己手动实现FromNpiValuetrait，这样可以让call_async获取到 JS 返回数据时自动调用FromNpiValuetrait 的from_napi_value方法将 JS 返回数据转换为 Rust 的数据格式，以下是一个简单的示例。</p>
<p>假如需要在 Rust 调用一个 JS 函数，JS 函数会返回一个对象，包含三个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  setPageName?: string,</span><br><span class="line">  changeExt?: boolean,</span><br><span class="line">  setSubPkgName?: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在 Rust 中获取到返回的对象，并转为 Rust 数据，那么首先我们可以定义一个类似的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">pub struct JSReturnObject &#123;</span><br><span class="line">  pub set_page_name: Option,</span><br><span class="line">  pub change_ext: Option,</span><br><span class="line">  pub set_sub_pkg_page_name: Option,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时为它实现FromNpiValuetrait 就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">impl FromNapiValue for JSReturnObject &#123;</span><br><span class="line">  unsafe fn from_napi_value(env: napi_env, napi_val: napi_value) -&gt; Result &#123;</span><br><span class="line">    let obj = JsObject::from_napi_value(env, napi_val)?;</span><br><span class="line">    let mut js_return_object = JSReturnObject &#123;</span><br><span class="line">      set_page_name: None,</span><br><span class="line">      change_ext: None,</span><br><span class="line">      set_sub_pkg_page_name: None,</span><br><span class="line">    &#125;;</span><br><span class="line">    let has_set_page_name = obj.has_named_property(&quot;setPageName&quot;)?;</span><br><span class="line">    let has_change_ext = obj.has_named_property(&quot;changeExt&quot;)?;</span><br><span class="line">    let has_set_sub_pkg_page_name = obj.has_named_property(&quot;setSubPkgName&quot;)?;</span><br><span class="line">    if has_set_page_name &#123;</span><br><span class="line">      js_return_object.set_page_name = Some(obj.get_named_property::(&quot;setPageName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_set_sub_pkg_page_name &#123;</span><br><span class="line">      js_return_object.set_sub_pkg_page_name = Some(obj.get_named_property::(&quot;setSubPkgName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_change_ext &#123;</span><br><span class="line">      js_return_object.change_ext = Some(obj.get_named_property::(&quot;changeExt&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(js_return_object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，先调用JsObject::from_napi_value方法将传入数据转为JsObject，然后调用</p>
<p>JsObject的has_named_property方法获取到对应的属性值，经过处理后可以构建出JSReturnObject结构体数据，并进行返回。而使用的时候，为call_async指定泛型参数类型为JSReturnObject，接下来就可以获取到 JS 返回值进行处理了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result: JSReturnObject = js_handler</span><br><span class="line">  .call_async(Ok(options.clone()))</span><br><span class="line">  .await</span><br><span class="line">  .with_context(|| format!(&quot;模板自定义函数调用失败: &#123;&#125;&quot;, file_relative_path))?;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-VSCode-进行调试"><a href="#使用-VSCode-进行调试" class="headerlink" title="使用 VSCode 进行调试"></a>使用 VSCode 进行调试</h2><p>我们可以使用 VSCode 来调试我们的 napi-rs 应用，我们可以参考Taro 项目，在项目的 .vscode 目录下新增 launch.json 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;lldb&quot;, // 调试器类型，这里指定为lldb，通常用于C/C++/Rust等语言</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;, // 请求类型，可以是&apos;launch&apos;或&apos;attach&apos;，&apos;launch&apos;表示启动一个新的调试会话</span><br><span class="line">      &quot;name&quot;: &quot;debug-init&quot;, // 配置名称，显示在VS Code的启动配置下拉菜单中</span><br><span class="line">      &quot;sourceLanguages&quot;: [&quot;rust&quot;], // 指定源码语言，此处为Rust</span><br><span class="line">      &quot;program&quot;: &quot;node&quot;, // 要调试的程序，这里是指Node.js的可执行文件</span><br><span class="line">      &quot;args&quot;: [</span><br><span class="line">        // 程序参数，这里指定了使用node运行taro-cli包的初始化命令，创建一个名为test_pro的新项目</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/packages/taro-cli/bin/taro&quot;,</span><br><span class="line">        &quot;init&quot;,</span><br><span class="line">        &quot;test_pro&quot;</span><br><span class="line">	  ],</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 当前工作目录，这里指工作区根目录</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;build binding debug&quot;, // 调试前需要执行的任务的名称，这里指定了一个任务以在调试前构建项目</span><br><span class="line">      &quot;postDebugTask&quot;: &quot;remove test_pro&quot; // 调试后需要执行的任务的名称，此处指定了一个任务以在调试后清理或删除test_pro项目</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述配置中，指定调试器类型为lldb，启动一个新的调试会话来调试我们用 Rust 编写的程序，该程序主要通过 Node.js 来执行一个初始化新项目 test_pro 的命令，在调试开始前后会飞别执行 Rust binding 的构建以及 test_pro 项目的删除。</p>
<p>然后在要调试的代码处添加断点，然后执行调试即可。</p>
<h2 id="构建发布"><a href="#构建发布" class="headerlink" title="构建发布"></a>构建发布</h2><p>napi-rs 的项目模板默认基于 <a href="https://github.com/napi-rs/package-template/blob/main/.github/workflows/CI.yml" target="_blank" rel="noopener">Github Action</a> 来实现自动构建产物及发布，并且已经有相当完整的配置了，从Github Action配置文件中可以看到 CI 具体执行的任务，CI 任务首先会执行 package.json 中的构建命令，构建出各个端的 binding，并会actions/upload-artifact@v3action 将构建产物上传，然后会对构建产物执行相关测试，测试通过后会将构建产物下载下来，并执行artifacts命令将构建产物移动到目的文件夹下，最后会进行发布，当 git 提交信息为semver规范版本号时，将会触发 CI 发布，将包发到 NPM 中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;0.0.1&apos;</span><br></pre></td></tr></table></figure></p>
<p>前面提到我们一般只需要针对x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台进行构建，所以我们可以调整 Github Action 配置，去掉不需要构建的平台以提升 CI 速度。</p>
<p>此外，当我们有特殊需求的时候，例如不需要重新生成胶水 JS 代码、需要将构建产物移动到其他目录（默认是当前目录下的 npm 目录）下等等，可以查看<a href="https://github.com/napi-rs/napi-rs/tree/main/cli" target="_blank" rel="noopener">@napi-rs/cli</a>的文档进行相应调整。</p>
<p>不需要重新生成胶水 JS 代码，可以通过在napi build命令下添加–no-js实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">	...</span><br><span class="line">  &quot;build&quot;: &quot;napi build --platform --release --no-js --dts binding.d.ts&quot;,</span><br><span class="line">  &quot;build:debug&quot;: &quot;napi build --platform --no-js --dts binding.d.ts&quot;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要将构建产物移动到其他目录，可以通过在napi artifacts命令下添加 –cwd 和 –npm-dir 参数来实现，前者指定工作目录，后者指定要移动的目录的相对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">	...</span><br><span class="line">  &quot;artifacts&quot;: &quot;napi artifacts --npm-dir ../../npm2 --cwd ./&quot;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 在前端领域的应用无疑将成为未来的重要发展趋势，随着越来越多的公司和团队开始投入到这一领域，我们看到了 Rust 在前端研发生态构建中的独特优势和潜力，Rust 的高效性和安全性使其成为优化 Node 工具的理想选择。本文简单介绍了如何使用 NAPI-RS 来开发、调试和发布 Node 扩展，可以有效地优化我们的开发工具，并提升其性能。</p>
<p>在未来，我们可以预见 Rust 与前端结合的可能性将会更加广泛。随着 WebAssembly（WASM）的发展，我们可以期待 Rust 将在前端应用的性能优化、复杂应用的开发以及多线程等领域发挥更大的作用。同时，Rust 的出色的内存管理和错误处理机制也将帮助前端开发者构建更加健壮、安全的应用。</p>
<p>当然，Rust 与前端的结合并不仅仅限于性能优化，Rust 的优秀特性，如模式匹配、类型推断和零成本抽象，也为前端开发带来了新的编程范式和思维方式，这将有助于提升前端代码的可读性和可维护性，为前端开发提供了新的思考角度和工具，并可能引领前端开发进入一个全新的阶段。</p>
<p><a href="https://juejin.cn/post/7321410906426998810#heading-13" target="_blank" rel="noopener">来自</a></p>

        </div>

        
            <div class="article-tags tags">
                
                    <a href="/tags/Rust/"><i class="fa fa-tag"></i>&nbsp;&nbsp;Rust</a>
                
            </div>
        

        
            <div class="art-item-footer">
                
                    <span class="art-item-left">
                        <i class="fa fa-chevron-left" aria-hidden="true"></i>&nbsp;
                        <a href="/2025/06/04/Tensorflow-js入门/" rel="prev" title="Tensorflow.js入门">
                            Tensorflow.js入门
                        </a>
                    </span>
                
                
                    <span class="art-item-right">
                        <a href="/2025/03/11/solidity进阶/" rel="next" title="solidity进阶">
                            solidity进阶
                        </a>&nbsp;
                        <i class="fa fa-chevron-right" aria-hidden="true"></i>
                    </span>
                
            </div>
        

    </section>

</article>

<br>

<!-- 显示推荐文章和评论 -->


<script>
    window.subData = {
        title: '使用 Rust 锈化前端工具链',
        tools: true
    }
</script>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>
    
        <img class='avatar waves-image' src='https://avatars2.githubusercontent.com/u/20313228?s=400&u=81b6a332e9a0f8c63e4841766106f3c8f881cfb5&v=4' />
    
</section>


  <section class='m_widget categories'>
<div class='header'><i class="fa fa-sitemap" aria-hidden="true"></i>&nbsp;&nbsp;分类</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/css/"><div class='name'>css</div><div class='badge'>11</div></a></li>
    
        <li><a class="flat-box" href="/categories/javascript/"><div class='name'>javascript</div><div class='badge'>190</div></a></li>
    
        <li><a class="flat-box" href="/categories/nodejs/"><div class='name'>nodejs</div><div class='badge'>23</div></a></li>
    
        <li><a class="flat-box" href="/categories/python-rust/"><div class='name'>python&amp;rust</div><div class='badge'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/服务器/"><div class='name'>服务器</div><div class='badge'>17</div></a></li>
    
        <li><a class="flat-box" href="/categories/计算机原理/"><div class='name'>计算机原理</div><div class='badge'>21</div></a></li>
    
    </ul>
    
</div>
</section>


  
<div class="m_widget tagcloud">
    <div class="header"><i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;标签</div>
    <div class='content'>
        <a href="/tags/3D/" style="font-size: 14.83px; color: #939393">3D</a> <a href="/tags/AI/" style="font-size: 18.17px; color: #7d7d7d">AI</a> <a href="/tags/MYSQL笔记/" style="font-size: 20.67px; color: #6c6c6c">MYSQL笔记</a> <a href="/tags/Rust/" style="font-size: 14px; color: #999">Rust</a> <a href="/tags/Tensorflow-js/" style="font-size: 16.5px; color: #888">Tensorflow.js</a> <a href="/tags/Threejs/" style="font-size: 15.67px; color: #8e8e8e">Threejs</a> <a href="/tags/WEB3/" style="font-size: 15.67px; color: #8e8e8e">WEB3</a> <a href="/tags/ajax/" style="font-size: 18.17px; color: #7d7d7d">ajax</a> <a href="/tags/canvas/" style="font-size: 14.83px; color: #939393">canvas</a> <a href="/tags/cordova/" style="font-size: 14px; color: #999">cordova</a> <a href="/tags/docker/" style="font-size: 14px; color: #999">docker</a> <a href="/tags/electron/" style="font-size: 14px; color: #999">electron</a> <a href="/tags/github/" style="font-size: 18.17px; color: #7d7d7d">github</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/html/" style="font-size: 17.33px; color: #828282">html</a> <a href="/tags/jquery/" style="font-size: 15.67px; color: #8e8e8e">jquery</a> <a href="/tags/linux/" style="font-size: 14.83px; color: #939393">linux</a> <a href="/tags/nodejs/" style="font-size: 15.67px; color: #8e8e8e">nodejs</a> <a href="/tags/npm/" style="font-size: 14px; color: #999">npm</a> <a href="/tags/typescript/" style="font-size: 15.67px; color: #8e8e8e">typescript</a> <a href="/tags/uniapp/" style="font-size: 14px; color: #999">uniapp</a> <a href="/tags/vue/" style="font-size: 21.5px; color: #666">vue</a> <a href="/tags/webSocket/" style="font-size: 14px; color: #999">webSocket</a> <a href="/tags/webpack/" style="font-size: 18.17px; color: #7d7d7d">webpack</a> <a href="/tags/web图形/" style="font-size: 18.17px; color: #7d7d7d">web图形</a> <a href="/tags/web安全/" style="font-size: 18.17px; color: #7d7d7d">web安全</a> <a href="/tags/web性能/" style="font-size: 19px; color: #777">web性能</a> <a href="/tags/worker/" style="font-size: 14.83px; color: #939393">worker</a> <a href="/tags/兼容性/" style="font-size: 15.67px; color: #8e8e8e">兼容性</a> <a href="/tags/后端/" style="font-size: 17.33px; color: #828282">后端</a> <a href="/tags/后端代理服务/" style="font-size: 14px; color: #999">后端代理服务</a> <a href="/tags/图片处理/" style="font-size: 18.17px; color: #7d7d7d">图片处理</a> <a href="/tags/基础知识/" style="font-size: 24px; color: #555">基础知识</a> <a href="/tags/少儿编程/" style="font-size: 14px; color: #999">少儿编程</a> <a href="/tags/工具库/" style="font-size: 23.17px; color: #5b5b5b">工具库</a> <a href="/tags/微信/" style="font-size: 14.83px; color: #939393">微信</a> <a href="/tags/手写/" style="font-size: 19.83px; color: #717171">手写</a> <a href="/tags/打印/" style="font-size: 14px; color: #999">打印</a> <a href="/tags/文章收集/" style="font-size: 14px; color: #999">文章收集</a> <a href="/tags/日语/" style="font-size: 18.17px; color: #7d7d7d">日语</a> <a href="/tags/样式/" style="font-size: 18.17px; color: #7d7d7d">样式</a> <a href="/tags/正则/" style="font-size: 14px; color: #999">正则</a> <a href="/tags/浏览器/" style="font-size: 18.17px; color: #7d7d7d">浏览器</a> <a href="/tags/爬虫/" style="font-size: 14px; color: #999">爬虫</a> <a href="/tags/移动端/" style="font-size: 21.5px; color: #666">移动端</a> <a href="/tags/算法/" style="font-size: 15.67px; color: #8e8e8e">算法</a> <a href="/tags/编译/" style="font-size: 17.33px; color: #828282">编译</a> <a href="/tags/网络基础/" style="font-size: 20.67px; color: #6c6c6c">网络基础</a> <a href="/tags/调试/" style="font-size: 14.83px; color: #939393">调试</a> <a href="/tags/资源导航/" style="font-size: 14.83px; color: #939393">资源导航</a> <a href="/tags/软考/" style="font-size: 14px; color: #999">软考</a> <a href="/tags/面试题/" style="font-size: 22.33px; color: #606060">面试题</a> <a href="/tags/面试题系列/" style="font-size: 18.17px; color: #7d7d7d">面试题系列</a>
    </div>
</div>




      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
    <div class="social-wrapper">
      
    </div>
    <br>
    <div>博客内容遵循 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="licenses">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div>
    <div>本站使用 <a href="https://github.com/xaoxuu/hexo-theme-material-x" target="_blank" class="codename">Material-X</a> 作为主题，
		总访问量为 <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
    </div>

</footer>

  <script>setLoadingBarProgress(80);</script>
  <!-- <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script> -->
<script src="/js/jquery.min.js"></script>
<!-- <script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script> -->
<script src="/js/waves.min.js"></script>
<!-- <script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script> -->
<script src="/js/scrollreveal.min.js"></script>
<!-- 访问统计 -->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- 推荐文章 -->
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<!-- <script src="//unpkg.com/valine/dist/Valine.min.js"></script> -->
<script src="/js/jquery.fitvids.js"></script>
<script>
var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
var ALGOLIA_API_KEY = "";
var ALGOLIA_APP_ID = "";
var ALGOLIA_INDEX_NAME = "";
var AZURE_SERVICE_NAME = "";
var AZURE_INDEX_NAME = "";
var AZURE_QUERY_KEY = "";
var BAIDU_API_ID = "";
var SEARCH_SERVICE = "hexo";
var ROOT = "/"||"/";
if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


    
    
    


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
