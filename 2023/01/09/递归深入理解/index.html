<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>递归深入理解 | jinux</title>
  <meta name="description" content="前端 学习 javascript">
  <meta name="keywords" content>
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="jinux">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="深入的理解递归算法">
<meta name="keywords" content="基础知识,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="递归深入理解">
<meta property="og:url" content="/2023/01/09/递归深入理解/index.html">
<meta property="og:site_name" content="jinux">
<meta property="og:description" content="深入的理解递归算法">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2023/01/09/递归深入理解/1.gif">
<meta property="og:image" content="/2023/01/09/递归深入理解/2.gif">
<meta property="og:image" content="/2023/01/09/递归深入理解/3.webp">
<meta property="og:image" content="/2023/01/09/递归深入理解/4.webp">
<meta property="og:image" content="/2023/01/09/递归深入理解/5.webp">
<meta property="og:image" content="/2023/01/09/递归深入理解/1.gif">
<meta property="og:updated_time" content="2023-01-11T06:08:35.997Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="递归深入理解">
<meta name="twitter:description" content="深入的理解递归算法">
<meta name="twitter:image" content="/2023/01/09/递归深入理解/1.gif">

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				<!-- <i class="fa fa-home"></i> -->
				jinux
			</a>

				<div class='menu'>
					<ul class='h-list'>
						
							<li>
								<a class='flat-box nav-home' href='/'>
									<i class="fa fa-home"></i>
									主页
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-cube' href='/categories'>
									<i class="fa fa-cube"></i>
									导航
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-github' href='https://github.com/jinux7'>
									<i class="fa fa-github"></i>
									github
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-archive' href='/archives'>
									<i class="fa fa-archive"></i>
									归档
								</a>
							</li>
						
					</ul>
					<div class='underline'></div>
				</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon"><i class="fa fa-search"></i></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><i class="fa fa-search flat-box"></i></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><i class="fa fa-navicon flat-box"></i></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				xaoxuu
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><i class="fa fa-comments flat-box"></i></a></li>
				<li class='s-top'><a href='javascript:void(0)'><i class="fa fa-arrow-up flat-box"></i></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><i class="fa fa-list-ul flat-box"></i></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
        <div class="header">jinux</div>
		<nav>
			
				<a href="/" class="nav-home nav">
					<i class="fa fa-home"></i>
					主页
				</a>
			
				<a href="/categories" class="nav-cube nav">
					<i class="fa fa-cube"></i>
					导航
				</a>
			
				<a href="https://github.com/jinux7" class="nav-github nav">
					<i class="fa fa-github"></i>
					github
				</a>
			
				<a href="/archives" class="nav-archive nav">
					<i class="fa fa-archive"></i>
					归档
				</a>
			
		</nav>
	</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-递归深入理解" class="post white-box article-type-post" itemscope itemprop="blogPost">
    <section class='meta'>
        <h1 class="title">
            
                递归深入理解
            
        </h1>
        <time>
            2023-01-09 Monday&nbsp;&nbsp;
            <i class="fa fa-eye" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
        </time>
        
    
    <div class='cats'>
        <a href="/categories/javascript/">javascript</a>
    </div>


    </section>
    
        <section class="toc-wrapper">
            <div class="header"><i class="fa fa-list" aria-hidden="true"></i>&nbsp;&nbsp;目录</div>
            <div class='content'>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#递归原理"><span class="toc-number">1.</span> <span class="toc-text">递归原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是递归，它是如何工作的？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是递归，它是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归的程序特征"><span class="toc-number">1.2.</span> <span class="toc-text">递归的程序特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候考虑递归"><span class="toc-number">1.3.</span> <span class="toc-text">什么时候考虑递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归的递推性质"><span class="toc-number">2.</span> <span class="toc-text">递归的递推性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#帕斯卡三角"><span class="toc-number">2.1.</span> <span class="toc-text">帕斯卡三角</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递推关系"><span class="toc-number">2.1.1.</span> <span class="toc-text">递推关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本情况"><span class="toc-number">2.1.2.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#演示"><span class="toc-number">2.1.3.</span> <span class="toc-text">演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归复杂性分析"><span class="toc-number">3.</span> <span class="toc-text">递归复杂性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#递归时间复杂度计算"><span class="toc-number">3.1.</span> <span class="toc-text">递归时间复杂度计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#示例"><span class="toc-number">3.1.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行树分析递归调用数量"><span class="toc-number">3.1.2.</span> <span class="toc-text">执行树分析递归调用数量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归空间复杂性分析"><span class="toc-number">3.2.</span> <span class="toc-text">递归空间复杂性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归相关空间"><span class="toc-number">3.2.1.</span> <span class="toc-text">递归相关空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非递归相关空间"><span class="toc-number">3.2.2.</span> <span class="toc-text">非递归相关空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归的优化策略"><span class="toc-number">4.</span> <span class="toc-text">递归的优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时间优化策略：记忆化"><span class="toc-number">4.1.</span> <span class="toc-text">时间优化策略：记忆化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间优化策略：尾递归"><span class="toc-number">4.2.</span> <span class="toc-text">空间优化策略：尾递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#采用递归解法的几个经典问题"><span class="toc-number">5.</span> <span class="toc-text">采用递归解法的几个经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反转字符串"><span class="toc-number">5.1.</span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两两交换链表中的节点"><span class="toc-number">5.2.</span> <span class="toc-text">两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#杨辉三角"><span class="toc-number">5.3.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数"><span class="toc-number">5.4.</span> <span class="toc-text">斐波那契数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#爬楼梯"><span class="toc-number">5.5.</span> <span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的最大深度"><span class="toc-number">5.6.</span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算-x-的-n-次幂函数"><span class="toc-number">5.7.</span> <span class="toc-text">计算 x 的 n 次幂函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第K个语法符号"><span class="toc-number">5.8.</span> <span class="toc-text">第K个语法符号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
            </div>
        </section>
    

    <section class="article typo">

        <div class="article-entry" itemprop="articleBody">
            <p>深入的理解递归算法<br><a id="more"></a><br>【<a href="/2019/07/02/js中的递归总结/">递归浅析</a>】这篇文章简单的介绍了递归算法，本编会对递归进行深入的理解。</p>
<h2 id="递归原理"><a href="#递归原理" class="headerlink" title="递归原理"></a>递归原理</h2><h3 id="什么是递归，它是如何工作的？"><a href="#什么是递归，它是如何工作的？" class="headerlink" title="什么是递归，它是如何工作的？"></a>什么是递归，它是如何工作的？</h3><blockquote>
<p>递归(recursion)是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。<br>简单说程序调用自身的编程技巧叫递归。递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。</p>
</blockquote>
<p>使用递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含2个属性：</p>
<ul>
<li>基本情况（bottom cases），基本情况用于保证程序调用及时返回，不在继续递归，保证了程序可终止。</li>
<li>递推关系（recurrentce relation），可将所有其他情况拆分到基本案例。</li>
</ul>
<p>简单的示例：以相反的顺序打印字符串。<br>可以使用迭代的办法轻而易举地解决这个问题，即从字符串的最后一个字符开始遍历字符串。但是如何递归地解决它呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  helper(<span class="number">0</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">index, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!str || index&gt;str.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  helper(index+<span class="number">1</span>, str);</span><br><span class="line">  <span class="built_in">console</span>.log(str[index]);</span><br><span class="line">&#125;</span><br><span class="line">printReverse(<span class="string">'abcdefg'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="递归的程序特征"><a href="#递归的程序特征" class="headerlink" title="递归的程序特征"></a>递归的程序特征</h3><p>优雅性</p>
<blockquote>
<p>相比其他解法（比如迭代法），使用递归法，会发现只需少量程序就可描述出解题过程，大大减少了程序的代码量，而且很好理解。递归的能力在于用有限的语句来定义对象的无限集合。</p>
</blockquote>
<p>反向性</p>
<blockquote>
<p>由于递归调用程序需要维护调用栈，而栈具有后进先出的特征，因此递归程序适合满足取反类需求。</p>
</blockquote>
<p>递推关系</p>
<blockquote>
<p>递归程序可以较明显的发现递推关系，反过来也可以这么说，具有递推关系的问题基本都可以通过递归求解（当然也许有性能更佳的解法，但递归绝对是一种选择）。递推关系常见问题有杨辉三角、阶乘计算等。</p>
</blockquote>
<h3 id="什么时候考虑递归"><a href="#什么时候考虑递归" class="headerlink" title="什么时候考虑递归"></a>什么时候考虑递归</h3><p>具有以下特征的问题可考虑递归求解：</p>
<ul>
<li>当问题和子问题具有递推关系，比如杨辉三角、计算阶乘。</li>
<li>具有递归性质的数据结构，比如链表、树、图。</li>
<li>反向性问题，比如取反。</li>
</ul>
<p>总结下来，最根本的还是要抓住问题本身是否可以通过层层拆解到最小粒度来得解。</p>
<h2 id="递归的递推性质"><a href="#递归的递推性质" class="headerlink" title="递归的递推性质"></a>递归的递推性质</h2><p>上一节说了，在实现递归函数之前，需要弄明白2件事：</p>
<ul>
<li>​递推关系​： 一个问题的结果与其子问题的结果之间的关系。</li>
<li>​基本情况​: 不需要进一步的递归调用就可以直接计算答案的情况。 它们往往是问题被减少到最小规模的情况，也就是如果将问题划分为子问题是一种自上而下的方式的最下层。</li>
</ul>
<p>一旦计算出以上两个元素，再想要实现一个递归函数，就只需要根据​递推关系​调用函数本身，直到其抵达​基本情况​。<br>为了解释以上几点，来看一个经典问题：杨辉三角（也叫帕斯卡三角）。</p>
<h3 id="帕斯卡三角"><a href="#帕斯卡三角" class="headerlink" title="帕斯卡三角"></a>帕斯卡三角</h3><blockquote>
<p>帕斯卡三角形是排列成三角形的一系列数字。 在帕斯卡三角形中，每一行的最左边和最右边的数字总是 <code>1</code>。 对于其余的每个数字都是前一行中直接位于它上面的两个数字之和。</p>
</blockquote>
<p>下面的插图给出了一个 <code>5</code> 行的帕斯卡三角：<br><img src="/2023/01/09/递归深入理解/1.gif" alt="img"></p>
<h4 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h4><p>从帕斯卡三角形内的递推关系开始。<br>首先，定义一个函数 <code>f(i,j)</code>，它将会返回帕斯卡三角形​第 <code>i</code> 行​、​第 <code>j</code> 列​的数字。<br>可以用下面的公式来表示这一递推关系：<br><code>f(i,j)=f(i−1,j−1)+f(i−1,j)</code></p>
<h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>可以看到，每行的最左边和最右边的数字是​基本情况​，在这个问题中，它总是等于 1。<br>因此，可以将基本情况定义如下:<br><code>f(i,j)=1wherej=1orj=i</code></p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>一旦定义了 ​递推关系​ 和 ​基本情况​，递归函数的实现变得更加直观，特别是在用数学公式表示出这两个元素之后。<br>下面给出一个例子，展示如何用这个公式递归地计算 <code>f(5,3)</code>, 也就是 帕斯卡三角形​第 <code>5</code> 行​中的​第 <code>3</code> 个​数。<br><img src="/2023/01/09/递归深入理解/2.gif" alt="img"><br>可以将 <code>f(5,3)</code> 分解为 <code>f(5,3)=f(4,2)+f(4,3)</code>，然后递归地调用 <code>f(4,2)</code> 和 <code>f(4,3)</code>：<br>对于调用的 <code>f(4,2)</code>，可以进一步展开它，直到到达基本情况，正如下面所描述的：<br><code>f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3</code><br>对于调用的 <code>f(4,3)</code>，类似地，可以将其分解为：<br><code>f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3</code><br>最后，结合上述子问题的结果：<br><code>f(5,3)=f(4,2)+f(4,3)=3+3=6</code><br>可能已经注意到递归解决方案可能会导致一些重复的计算，​例如​，重复计算相同的中间数以获得最后一行中的数字。 举例说明，为了得到 <code>f(5,3)</code> 的结果，在 <code>f(4,2)</code> 和 <code>f(4,3)</code> 的调用中计算了 <code>f(3,2)</code> 两次，这样重复计算效率肯定不高，下一节会给出优化方案来避免重复计算（即记忆术）。</p>
<h2 id="递归复杂性分析"><a href="#递归复杂性分析" class="headerlink" title="递归复杂性分析"></a>递归复杂性分析</h2><h3 id="递归时间复杂度计算"><a href="#递归时间复杂度计算" class="headerlink" title="递归时间复杂度计算"></a>递归时间复杂度计算</h3><p>给出一个递归算法，其时间复杂度 <code>O(T)</code> 通常是递归调用的数量（记作 <code>R</code>）和计算的时间复杂度的乘积（表示为 <code>O(s)</code>）的乘积：<br><code>O(T)=R∗O(s)</code></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在反转字符串问题中，需要以相反的顺序打印字符串，解决问题的递归关系可以表示如下：<br><code>​printReverse(str) = printReverse(str[1...n]) + print(str[0])</code><br>​其中 <code>​str[1...n]</code>​ 是输入字符串 ​str​ 的子串，仅不含前导字符 ​<code>str[0]​</code>。<br>该函数将被递归调用 n 次，其中 n 是输入字符串的大小。在每次递归结束时，只是打印前导字符，因此该特定操作的时间复杂度是恒定的，即 <code>O(1)</code>。<br>总而言之，递归函数 <code>​printReverse(str)</code>​ 的总体时间复杂度为 <code>O(printReverse)=n∗O(1)=O(n)</code>。</p>
<h4 id="执行树分析递归调用数量"><a href="#执行树分析递归调用数量" class="headerlink" title="执行树分析递归调用数量"></a>执行树分析递归调用数量</h4><p>在分析递归的时间复杂度时，递归调用的数量不一定和N成线性关系，比如斐波那契数的计算（见第五部分），其递推关系被定义为​<code>f(n) = f(n-1) + f(n-2)</code>​。乍一看，在执行斐波那契函数期间计算递归调用的数量似乎并不简单。<br>执行树定义</p>
<blockquote>
<p>执行树是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。</p>
</blockquote>
<p>递归函数的执行树将形成 <code>​n</code> 叉树​，其中 ​<code>n</code>​ 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 <code>​f(4)</code>​ 的执行树。<br><img src="/2023/01/09/递归深入理解/3.webp" alt="img"><br>在 n 层的完全二叉树中，节点的总数为 <code>2n−1</code>。因此 <code>​f(n)</code>​ 中递归数目的上限（尽管不严格）也是 <code>2n−1</code>。那么我们可以估计 ​<code>f(n)</code>​ 的时间复杂度为 <code>O(2n)</code>。</p>
<h3 id="递归空间复杂性分析"><a href="#递归空间复杂性分析" class="headerlink" title="递归空间复杂性分析"></a>递归空间复杂性分析</h3><p>在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：递归相关空间（​recursion related space）和非递归相关空间​（​non-recursion related space​）。</p>
<h4 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h4><p>递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。为了完成典型的函数调用，系统应该在栈中分配一些空间来保存三个重要信息：</p>
<ul>
<li>函数调用的返回地址。一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点。</li>
<li>传递给函数调用的参数。</li>
<li>函数调用中的局部变量。</li>
</ul>
<p>栈中的这个空间是函数调用期间产生的最小成本。然而，一旦完成函数调用，就会释放该空间。<br>对于递归算法，函数调用将连续链接直到它们到达基本情况（也称为 底层情况）。这意味着用于每个函数调用的空间也会累积。<br>对于递归算法，如果没有产生其他内存消耗，则此递归引起的空间将是算法的空间上限。<br>例如，在本文一开始提到了反转字符串示例中，没有使用额外的内存，因为仅仅是打印一个字符。对于每个递归调用，假设它可能需要一个最大为某一常量值的空间。并且递归调用最多可以链接 <code>​n</code>​ 次，其中 ​<code>n</code>​ 是输入字符串的大小。因此，该递归算法的空间复杂度就是 <code>O(n)</code>。<br>为了更好地说明这一点，接下来将会展示递归调用​ <code>f(x1) -&gt; f(x2) -&gt; f(x3)</code>​ 的执行顺序以及栈空间的分配情况。<br><img src="/2023/01/09/递归深入理解/4.webp" alt="img"><br>栈中的空间将会分配给 ​<code>f(x1)</code>​ 来调用 ​<code>f(x2)</code>​。类似的情况也同样发生在 <code>​f(x2)</code>​ 中，系统会为 <code>​f(x3)</code> 的调用分配另一个空间，最后在​ ​<code>f(x3)</code>​ 中，我们到达基本情况，因此在 ​<code>f(x3)</code>​ 中没有进行进一步的递归调用。<br>正是由于这些与递归相关的空间消耗，有时可能会遇到称为堆栈溢出的情况，其中为程序分配的堆栈达到其最大空间限制并导致程序最终失败。在设计递归算法时，应该仔细评估在输入规模扩大时是否存在堆栈溢出的可能性，栈溢出是非常容易出错的点，在下一节将讨论优化策略。</p>
<h4 id="非递归相关空间"><a href="#非递归相关空间" class="headerlink" title="非递归相关空间"></a>非递归相关空间</h4><p>正如名称所示，非递归相关空间指的是与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间（通常在堆中）。<br>不管是否递归，都可能需要在任何函数调用之前将问题的输入存储为全局变量。可能还需要保存递归调用的中间结果（也就是即将讨论的记忆化技术）。例如，在使用带有记忆化技术的递归算法解决斐波那契数问题时,使用映射<code>（map）</code>来跟踪在递归调用期间产生的所有中间斐波那契数。因此，在分析空间复杂度时，应该考虑到因采用记忆化技术所导致的空间成本。</p>
<h2 id="递归的优化策略"><a href="#递归的优化策略" class="headerlink" title="递归的优化策略"></a>递归的优化策略</h2><h3 id="时间优化策略：记忆化"><a href="#时间优化策略：记忆化" class="headerlink" title="时间优化策略：记忆化"></a>时间优化策略：记忆化</h3><p>递归是一种直观而有效的实现算法的方法。 但是，如果不明智地使用它，可能会给性能带来一些不希望的损失，例如重复计算。 在前面提到了帕斯卡三角的重复计算问题，其中一些中间结果被多次计算。<br>在本文中，将进一步研究递归可能出现的重复计算问题。 然后将提出一种常用的技术，称为​记忆化（memoization）​，可以用来避免这个问题。<br>为了演示重复计算的另一个问题，看一个大多数人可能都很熟悉的例子，斐波那契数。 如果定义函数 <code>​F(n)</code>​ 表示在索引 <code>​n</code>​ 处的斐波那契数，那么可以推导出如下的递推关系：<br>​<code>F(n) = F(n - 1) + F(n - 2)</code>​<br>基本情况：<br>​<code>F(0) = 0, F(1) = 1</code><br>​根据斐波那契数列的定义，可以实现下面的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，如果想知道 ​<code>F(4)</code>​ 是多少，可以应用上面的公式并进行展开：<br>​<code>F(4) = F(3) + F(2) = (F(2) + F(1)) + F(2)</code><br>为了得到 <code>f(4)</code> 的结果，需要在上述推导之后计算两次数 <code>​F(2)</code>​ : 第一次在 <code>​F(4)</code>​ 的第一次展开中，第二次在中间结果 ​<code>F(3)</code>​ 中。<br>下面的树显示了在计算 ​<code>F(4)</code>​ 时发生的所有重复计算（按颜色分组）。<br><img src="/2023/01/09/递归深入理解/5.webp" alt="img"><br>为了消除上述情况中的重复计算，正如许多人已经指出的那样，其中一个想法是将中间结果存储在缓存中，以便以后可以重用它们，而不需要重新计算。<br>这个想法也被称为记忆化，这是一种经常与递归一起使用的技术。​<br><strong>记忆化定义</strong></p>
<blockquote>
<p>记忆化是一种优化技术，主要用于加快计算机程序的速度，方法是存储昂贵的函数调用的结果，并在相同的输入再次出现时返回缓存的结果。</p>
</blockquote>
<p>回到斐波那契函数 <code>​F(n)</code>​。 可以使用哈希表来跟踪每个以 ​<code>n​</code> 为键的 <code>​F(n)</code>​ 的结果。 散列表作为一个缓存，可以避免重复计算。 记忆化技术是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。<br>为了便于比较，下面提供了带有记忆化功能的斐波那契数列解决方案的实现。<br>作为一种练习，可以尝试使记忆化更加通用和非侵入性，即应用记忆化技术而不改变原来的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cache.has(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    result = n;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    result = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  cache.set(n, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>斐波那契数应用的一个经典问题是爬楼梯，在第五节再分析。<br>通过记忆化技术，保存每个索引 <code>​n</code>​ 对应的的斐波那契数的结果。确信每个斐波那契数的计算只会发生一次。而从递推关系来看，斐波纳契数 ​<code>f(n)</code>​ 将取决于其所有 <code>​n-1</code>​ 个先验斐波纳契数。结果，计算 <code>​f(n)</code>​ 的递归将被调用 ​<code>n-1</code>​ 次以计算它所依赖的所有先验数字。<br>现在，可以计算一下采用了记忆化技术优化后的时间复杂度，即 <code>O(1)∗n=O(n)</code>。可以得出记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。</p>
<h3 id="空间优化策略：尾递归"><a href="#空间优化策略：尾递归" class="headerlink" title="空间优化策略：尾递归"></a>空间优化策略：尾递归</h3><p>上一节讨论了递归空间复杂性分析话题，从中了解到递归调用在系统调用栈上会产生额外空间，如果递归调用层级很深，程序执行过程中很可能导致栈溢出。针对这种情况，有一种称为尾递归的特殊递归，它可以控制递归导致空间开销的影响。<br><strong>尾递归定义</strong></p>
<blockquote>
<p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。</p>
</blockquote>
<p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）。<br>第五部分将看到尾递归优化阶乘运算的例子。</p>
<h2 id="采用递归解法的几个经典问题"><a href="#采用递归解法的几个经典问题" class="headerlink" title="采用递归解法的几个经典问题"></a>采用递归解法的几个经典问题</h2><blockquote>
<p>递归在递推关系的数学问题上应用广泛，使用递归法可以解决很多趣味问题，下面来看看都有哪些经典问题。</p>
</blockquote>
<h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 ​<code>char[]</code>​ 的形式给出。<br>不要给另外的数组分配额外的空间，必须原地修改输入数组、使用 <code>O(1)</code> 的额外空间解决这一问题。<br>可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入：[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line">输出：[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入：[<span class="string">"H"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"h"</span>]</span><br><span class="line">输出：[<span class="string">"h"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"H"</span>]</span><br></pre></td></tr></table></figure></p>
<p>分析：此问题是根据递归调用栈的特性做后进先出反转。<br>code:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">arrStr</span>) </span>&#123;</span><br><span class="line">  help(arrStr, <span class="number">0</span>, arrStr.length<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> arrStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">arrStr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">let</span> temp = arrStr[left];</span><br><span class="line">      arrStr[left] = arrStr[right];</span><br><span class="line">      arrStr[right] = temp;</span><br><span class="line">  help(arrStr, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">reverseString([<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'0'</span>]);</span><br></pre></td></tr></table></figure></p>
<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="comment">// 你应该返回</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link5 = &#123;<span class="attr">val</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="number">5</span>, <span class="attr">next</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> link4 = &#123;<span class="attr">val</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="number">4</span>, <span class="attr">next</span>: link5&#125;;</span><br><span class="line"><span class="keyword">const</span> link3 = &#123;<span class="attr">val</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="number">3</span>, <span class="attr">next</span>: link4&#125;;</span><br><span class="line"><span class="keyword">const</span> link2 = &#123;<span class="attr">val</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="number">2</span>, <span class="attr">next</span>: link3&#125;;</span><br><span class="line"><span class="keyword">const</span> link1 = &#123;<span class="attr">val</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">next</span>: link2&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapPairs</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> temp = head.val;</span><br><span class="line">  head.val = head.next.val;</span><br><span class="line">  head.next.val = temp;</span><br><span class="line">  swapPairs(head.next.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swapPairs(link1);</span><br><span class="line"><span class="built_in">console</span>.log(link1);</span><br><span class="line"><span class="built_in">console</span>.log(link2);</span><br><span class="line"><span class="built_in">console</span>.log(link3);</span><br><span class="line"><span class="built_in">console</span>.log(link4);</span><br><span class="line"><span class="built_in">console</span>.log(link5);</span><br></pre></td></tr></table></figure></p>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><img src="/2023/01/09/递归深入理解/1.gif" alt="img"><br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>分析：典型的具有递推关系的数据问题，注意通过记忆化优化。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = []; <span class="comment">// 缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传入数字不是整数，返回空数组</span></span><br><span class="line">  <span class="keyword">if</span>(numRows&lt;=<span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=numRows; i++) &#123;</span><br><span class="line">    arr[i<span class="number">-1</span>] = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">      arr[i<span class="number">-1</span>].push(makeNum(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNum</span>(<span class="params">row, column</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!cache[row]) &#123;</span><br><span class="line">    cache[row]=[];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有缓存，直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(cache[row][column]) <span class="keyword">return</span> cache[row][column]; </span><br><span class="line">  <span class="comment">// 这里是递归的基本情况</span></span><br><span class="line">  <span class="keyword">if</span>(row===column||column==<span class="number">1</span>) &#123;</span><br><span class="line">    cache[row][column] = <span class="number">1</span>; <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记忆化</span></span><br><span class="line">  cache[row][column] = makeNum(row<span class="number">-1</span>, column<span class="number">-1</span>) + makeNum(row<span class="number">-1</span>, column); </span><br><span class="line">  <span class="keyword">return</span> cache[row][column];</span><br><span class="line">&#125;</span><br><span class="line">generate(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数，通常用 ​<code>F(n)</code>​ 表示，形成的序列称为斐波那契数列。该数列由 ​<code>0</code>​ 和 <code>​1</code>​ 开始，后面的每一项数字都是前面两项数字的和。也就是：<br><code>F(0) = 0, F(1) = 1</code><br><code>F(N) = F(N - 1) + F(N - 2)</code>, 其中 <code>N &gt; 1</code><br>给定 ​<code>N</code>​，计算 ​<code>F(N)</code>​。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入：<span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：F(<span class="number">2</span>) = F(<span class="number">1</span>) + F(<span class="number">0</span>) = <span class="number">1</span> + <span class="number">0</span> = <span class="number">1.</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：F(<span class="number">3</span>) = F(<span class="number">2</span>) + F(<span class="number">1</span>) = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2.</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：F(<span class="number">4</span>) = F(<span class="number">3</span>) + F(<span class="number">2</span>) = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure></p>
<p>分析：递归考虑记忆化优化<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用记忆化版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">return</span> fib(num<span class="number">-1</span>) + fib(num<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">50</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用记忆化版本</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 记忆化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(cache.has(num)) <span class="keyword">return</span> cache.get(num);</span><br><span class="line">  <span class="keyword">let</span> result = fib(num<span class="number">-1</span>) + fib(num<span class="number">-2</span>);</span><br><span class="line">  cache.set(num, result);</span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面两个版本，一个做了记忆化，一个没有，求50的斐波那契数，没做记忆化的用浏览器运行直接卡死，而做了记忆化的瞬间出结果。</p>
</blockquote>
<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设爬楼梯。需要 <code>n</code> 阶才能到达楼顶。<br>每次可以爬 <code>1</code> 或 <code>2</code> 个台阶。有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 <code>n</code> 是一个正整数。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>) <span class="number">2</span> 阶</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3</span>) <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure></p>
<p>分析：该问题通过规律发现递推关系就是斐波那契数。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">stepNum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="keyword">return</span> help(stepNum, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">stepNum, cache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(stepNum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(cache[stepNum]) <span class="keyword">return</span> cache[stepNum];</span><br><span class="line">  <span class="keyword">if</span>(stepNum &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    cache[stepNum] = stepNum;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    cache[stepNum] = help(stepNum<span class="number">-1</span>, cache) + help(stepNum<span class="number">-2</span>, cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[stepNum];</span><br><span class="line">&#125;</span><br><span class="line">climbStairs(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binTree = &#123;</span><br><span class="line">  left: &#123;</span><br><span class="line">    left: &#123;</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: &#123; <span class="attr">left</span>: <span class="literal">null</span>, <span class="attr">right</span>: <span class="literal">null</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: &#123;</span><br><span class="line">      left: &#123;</span><br><span class="line">        left: <span class="literal">null</span>,</span><br><span class="line">        right: &#123;</span><br><span class="line">          left: &#123;</span><br><span class="line">            left: <span class="literal">null</span>,</span><br><span class="line">            right: &#123;</span><br><span class="line">              left: <span class="literal">null</span>,</span><br><span class="line">              right: &#123;</span><br><span class="line">                left: <span class="literal">null</span>,</span><br><span class="line">                right: <span class="literal">null</span>,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          right: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">返回的最大深度是<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>分析：二叉树是典型的具有递归属性的数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">binTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!binTree) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(!binTree.left &amp;&amp; !binTree.right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(binTree.left), maxDepth(binTree.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxDepth(binTree);</span><br></pre></td></tr></table></figure></p>
<h3 id="计算-x-的-n-次幂函数"><a href="#计算-x-的-n-次幂函数" class="headerlink" title="计算 x 的 n 次幂函数"></a>计算 x 的 n 次幂函数</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">输入: 2, 10</span><br><span class="line">输出: 1024</span><br><span class="line">// 2</span><br><span class="line">输入: 2.1, 3</span><br><span class="line">输出: 9.261</span><br></pre></td></tr></table></figure></p>
<p>说明：<br><code>-100.0 &lt; x &lt; 100.0</code><br><code>n</code> 是 <code>32</code> 位有符号整数，其数值范围是 <code>[−231, 231 − 1]</code><br>分析：n可能很大，需要防止栈溢出，可思考尾递归实现。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n&gt;<span class="number">0</span> ? help(x, n) : <span class="number">1</span>/help(x, -n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x * help(x, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">myPow(<span class="number">2</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="第K个语法符号"><a href="#第K个语法符号" class="headerlink" title="第K个语法符号"></a>第K个语法符号</h3><p>在第一行写上一个<code>0</code>​。接下来的每一行，将前一行中的​<code>0</code>​替换为​<code>01</code>​，<code>​1</code>​替换为​<code>10</code>​。<br>给定行数<code>N</code>和序数<code>​K</code>​，返回第<code>​N</code>行中第<code>​K</code>​个字符。（<code>​K</code>​从<code>1</code>开始）<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入: N = <span class="number">1</span>, K = <span class="number">1</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入: N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">输入: N = <span class="number">2</span>, K = <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">输入: N = <span class="number">4</span>, K = <span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">第一行: <span class="number">0</span></span><br><span class="line">第二行: <span class="number">01</span></span><br><span class="line">第三行: <span class="number">0110</span></span><br><span class="line">第四行: <span class="number">0110100</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<br>​N​ 的范围 ​[1, 30]​.<br>​K​ 的范围 ​[1, 2^(N-1)]​.<br>分析：识别具有递归关系问题<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNStr</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">return</span> getNStr(n<span class="number">-1</span>).replace(<span class="regexp">/0|1/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">'01'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'1'</span>) <span class="keyword">return</span> <span class="string">'10'</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKChar</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getNStr(n).charAt(k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getKChar(<span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，更加相信递归是一种强大的技术，它能够以一种优雅而有效的方式解决许多问题。同时，它也不是解决任务问题的灵丹妙药。由于时间或空间的限制，并不是所有的问题都可以用递归来解决。递归本身可能会带来一些不希望看到的副作用，如栈溢出。<br>有时，在解决实际问题时乍一看，并不清楚是否可以应用递归算法来解决问题。然而，由于递归的递推性质与所熟悉的数学非常接近，用数学公式来推导某些关系总是有帮助的，也就是说写出递推关系和基本情况是使用递归算法的前置条件。<br>只要有可能，就应用记忆化。在起草递归算法时，可以从最简单的策略开始。有时，在递归过程中，可能会出现重复计算的情况，例如斐波纳契数（Fibonacci）。在这种情况下，可以尝试应用 Memoization 技术，它将中间结果存储在缓存中供以后重用，它可以在空间复杂性上稍加折中，从而极大地提高时间复杂性，因为它可以避免代价较高的重复计算。<br>当堆栈溢出时，尾递归可能会有所帮助。<br>使用递归实现算法通常有几种方法。尾递归是实现递归的一种特殊形式。与记忆化技术不同的是，尾递归通过消除递归带来的堆栈开销，优化了算法的空间复杂度。更重要的是，有了尾递归，就可以避免经常伴随一般递归而来的堆栈溢出问题，而尾递归的另一个优点是，与非尾递归相比，尾部递归更容易阅读和理解。这是由于尾递归不存在调用后依赖（即递归调用是函数中的最后一个动作），这一点不同于非尾递归，因此，只要有可能，就应该尽量运用尾递归。</p>

        </div>

        
            <div class="article-tags tags">
                
                    <a href="/tags/基础知识/"><i class="fa fa-tag"></i>&nbsp;&nbsp;基础知识</a>
                
                    <a href="/tags/算法/"><i class="fa fa-tag"></i>&nbsp;&nbsp;算法</a>
                
            </div>
        

        
            <div class="art-item-footer">
                
                    <span class="art-item-left">
                        <i class="fa fa-chevron-left" aria-hidden="true"></i>&nbsp;
                        <a href="/2023/03/15/for循环中var与let深入理解/" rel="prev" title="for循环中var与let深入理解">
                            for循环中var与let深入理解
                        </a>
                    </span>
                
                
                    <span class="art-item-right">
                        <a href="/2023/01/04/前端编译原理-VUE模板编译概览/" rel="next" title="前端编译原理-VUE模板编译概览">
                            前端编译原理-VUE模板编译概览
                        </a>&nbsp;
                        <i class="fa fa-chevron-right" aria-hidden="true"></i>
                    </span>
                
            </div>
        

    </section>

</article>

<br>

<!-- 显示推荐文章和评论 -->


<script>
    window.subData = {
        title: '递归深入理解',
        tools: true
    }
</script>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>
    
        <img class='avatar waves-image' src='https://avatars2.githubusercontent.com/u/20313228?s=400&u=81b6a332e9a0f8c63e4841766106f3c8f881cfb5&v=4' />
    
</section>


  <section class='m_widget categories'>
<div class='header'><i class="fa fa-sitemap" aria-hidden="true"></i>&nbsp;&nbsp;分类</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/css/"><div class='name'>css</div><div class='badge'>10</div></a></li>
    
        <li><a class="flat-box" href="/categories/javascript/"><div class='name'>javascript</div><div class='badge'>163</div></a></li>
    
        <li><a class="flat-box" href="/categories/nodejs/"><div class='name'>nodejs</div><div class='badge'>17</div></a></li>
    
        <li><a class="flat-box" href="/categories/服务器/"><div class='name'>服务器</div><div class='badge'>14</div></a></li>
    
        <li><a class="flat-box" href="/categories/计算机原理/"><div class='name'>计算机原理</div><div class='badge'>12</div></a></li>
    
    </ul>
    
</div>
</section>


  
<div class="m_widget tagcloud">
    <div class="header"><i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;标签</div>
    <div class='content'>
        <a href="/tags/3D/" style="font-size: 14.91px; color: #939393">3D</a> <a href="/tags/AI/" style="font-size: 14px; color: #999">AI</a> <a href="/tags/MYSQL笔记/" style="font-size: 21.27px; color: #686868">MYSQL笔记</a> <a href="/tags/ajax/" style="font-size: 18.55px; color: #7a7a7a">ajax</a> <a href="/tags/canvas/" style="font-size: 14px; color: #999">canvas</a> <a href="/tags/cordova/" style="font-size: 14px; color: #999">cordova</a> <a href="/tags/docker/" style="font-size: 14px; color: #999">docker</a> <a href="/tags/github/" style="font-size: 18.55px; color: #7a7a7a">github</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/html/" style="font-size: 15.82px; color: #8d8d8d">html</a> <a href="/tags/jquery/" style="font-size: 15.82px; color: #8d8d8d">jquery</a> <a href="/tags/js工具库/" style="font-size: 19.45px; color: #747474">js工具库</a> <a href="/tags/linux/" style="font-size: 14.91px; color: #939393">linux</a> <a href="/tags/nodejs/" style="font-size: 14.91px; color: #939393">nodejs</a> <a href="/tags/threejs/" style="font-size: 14px; color: #999">threejs</a> <a href="/tags/typescript/" style="font-size: 14px; color: #999">typescript</a> <a href="/tags/vue/" style="font-size: 21.27px; color: #686868">vue</a> <a href="/tags/webSocket/" style="font-size: 14px; color: #999">webSocket</a> <a href="/tags/webpack/" style="font-size: 18.55px; color: #7a7a7a">webpack</a> <a href="/tags/web图形/" style="font-size: 16.73px; color: #868686">web图形</a> <a href="/tags/web安全/" style="font-size: 18.55px; color: #7a7a7a">web安全</a> <a href="/tags/web性能/" style="font-size: 20.36px; color: #6e6e6e">web性能</a> <a href="/tags/worker/" style="font-size: 14.91px; color: #939393">worker</a> <a href="/tags/兼容性/" style="font-size: 15.82px; color: #8d8d8d">兼容性</a> <a href="/tags/后端/" style="font-size: 14.91px; color: #939393">后端</a> <a href="/tags/后端代理服务/" style="font-size: 14px; color: #999">后端代理服务</a> <a href="/tags/图片处理/" style="font-size: 18.55px; color: #7a7a7a">图片处理</a> <a href="/tags/基础知识/" style="font-size: 24px; color: #555">基础知识</a> <a href="/tags/少儿编程/" style="font-size: 14px; color: #999">少儿编程</a> <a href="/tags/工具库/" style="font-size: 23.09px; color: #5b5b5b">工具库</a> <a href="/tags/微信/" style="font-size: 14.91px; color: #939393">微信</a> <a href="/tags/手写/" style="font-size: 20.36px; color: #6e6e6e">手写</a> <a href="/tags/文章收集/" style="font-size: 14px; color: #999">文章收集</a> <a href="/tags/样式/" style="font-size: 18.55px; color: #7a7a7a">样式</a> <a href="/tags/正则/" style="font-size: 14px; color: #999">正则</a> <a href="/tags/浏览器/" style="font-size: 16.73px; color: #868686">浏览器</a> <a href="/tags/爬虫/" style="font-size: 14px; color: #999">爬虫</a> <a href="/tags/移动端/" style="font-size: 22.18px; color: #616161">移动端</a> <a href="/tags/算法/" style="font-size: 15.82px; color: #8d8d8d">算法</a> <a href="/tags/编译/" style="font-size: 17.64px; color: #808080">编译</a> <a href="/tags/网络基础/" style="font-size: 21.27px; color: #686868">网络基础</a> <a href="/tags/调试/" style="font-size: 14px; color: #999">调试</a> <a href="/tags/资源导航/" style="font-size: 14px; color: #999">资源导航</a> <a href="/tags/软考/" style="font-size: 14px; color: #999">软考</a> <a href="/tags/面试题/" style="font-size: 23.09px; color: #5b5b5b">面试题</a>
    </div>
</div>




      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
    <div class="social-wrapper">
      
    </div>
    <br>
    <div>博客内容遵循 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="licenses">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div>
    <div>本站使用 <a href="https://github.com/xaoxuu/hexo-theme-material-x" target="_blank" class="codename">Material-X</a> 作为主题，
		总访问量为 <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
    </div>

</footer>

  <script>setLoadingBarProgress(80);</script>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<!-- 访问统计 -->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- 推荐文章 -->
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
var ALGOLIA_API_KEY = "";
var ALGOLIA_APP_ID = "";
var ALGOLIA_INDEX_NAME = "";
var AZURE_SERVICE_NAME = "";
var AZURE_INDEX_NAME = "";
var AZURE_QUERY_KEY = "";
var BAIDU_API_ID = "";
var SEARCH_SERVICE = "hexo";
var ROOT = "/"||"/";
if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


    
    
    


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
