<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>《Vue.js 设计与实现》速读 | jinux</title>
  <meta name="description" content="前端 学习 javascript">
  <meta name="keywords" content>
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="jinux">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="《Vue.js 设计与实现》概要总结">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="《Vue.js 设计与实现》速读">
<meta property="og:url" content="/2024/06/21/《Vue-js-设计与实现》速读/index.html">
<meta property="og:site_name" content="jinux">
<meta property="og:description" content="《Vue.js 设计与实现》概要总结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231540415.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231536123.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207233547097.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170232727.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170236795.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208190429676.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191120105.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191257788.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208192343242.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208194352049.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209085155034.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209093545078.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209105953064.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110548502.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110919710.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113241592.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113421705.png">
<meta property="og:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209121227934.png">
<meta property="og:updated_time" content="2024-06-21T05:46:30.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Vue.js 设计与实现》速读">
<meta name="twitter:description" content="《Vue.js 设计与实现》概要总结">
<meta name="twitter:image" content="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231540415.png">

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				<!-- <i class="fa fa-home"></i> -->
				jinux
			</a>

				<div class='menu'>
					<ul class='h-list'>
						
							<li>
								<a class='flat-box nav-home' href='/'>
									<i class="fa fa-home"></i>
									主页
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-cube' href='/categories'>
									<i class="fa fa-cube"></i>
									导航
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-github' href='https://github.com/jinux7'>
									<i class="fa fa-github"></i>
									github
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-archive' href='/archives'>
									<i class="fa fa-archive"></i>
									归档
								</a>
							</li>
						
					</ul>
					<div class='underline'></div>
				</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon"><i class="fa fa-search"></i></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><i class="fa fa-search flat-box"></i></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><i class="fa fa-navicon flat-box"></i></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				xaoxuu
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><i class="fa fa-comments flat-box"></i></a></li>
				<li class='s-top'><a href='javascript:void(0)'><i class="fa fa-arrow-up flat-box"></i></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><i class="fa fa-list-ul flat-box"></i></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
        <div class="header">jinux</div>
		<nav>
			
				<a href="/" class="nav-home nav">
					<i class="fa fa-home"></i>
					主页
				</a>
			
				<a href="/categories" class="nav-cube nav">
					<i class="fa fa-cube"></i>
					导航
				</a>
			
				<a href="https://github.com/jinux7" class="nav-github nav">
					<i class="fa fa-github"></i>
					github
				</a>
			
				<a href="/archives" class="nav-archive nav">
					<i class="fa fa-archive"></i>
					归档
				</a>
			
		</nav>
	</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-《Vue-js-设计与实现》速读" class="post white-box article-type-post" itemscope itemprop="blogPost">
    <section class='meta'>
        <h1 class="title">
            
                《Vue.js 设计与实现》速读
            
        </h1>
        <time>
            2024-06-21 Friday&nbsp;&nbsp;
            <i class="fa fa-eye" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
        </time>
        
    
    <div class='cats'>
        <a href="/categories/javascript/">javascript</a>
    </div>


    </section>
    
        <section class="toc-wrapper">
            <div class="header"><i class="fa fa-list" aria-hidden="true"></i>&nbsp;&nbsp;目录</div>
            <div class='content'>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序"><span class="toc-number">1.</span> <span class="toc-text">序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大纲"><span class="toc-number">3.</span> <span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一篇：框架设计概览"><span class="toc-number">4.</span> <span class="toc-text">第一篇：框架设计概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一章：权衡的艺术"><span class="toc-number">4.1.</span> <span class="toc-text">第一章：权衡的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#命令式和声明式"><span class="toc-number">4.1.1.</span> <span class="toc-text">命令式和声明式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能与可维护性的权衡"><span class="toc-number">4.1.2.</span> <span class="toc-text">性能与可维护性的权衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时和编译时"><span class="toc-number">4.1.3.</span> <span class="toc-text">运行时和编译时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章：框架设计的核心要素"><span class="toc-number">4.2.</span> <span class="toc-text">第二章：框架设计的核心要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章：Vue-js-3-的设计思路"><span class="toc-number">4.3.</span> <span class="toc-text">第三章：Vue.js 3 的设计思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一篇总结"><span class="toc-number">4.4.</span> <span class="toc-text">第一篇总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二篇：响应式系统"><span class="toc-number">5.</span> <span class="toc-text">第二篇：响应式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章：响应系统的作用与实现"><span class="toc-number">5.1.</span> <span class="toc-text">第四章：响应系统的作用与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#响应式数据"><span class="toc-number">5.1.1.</span> <span class="toc-text">响应式数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度系统（scheduler）"><span class="toc-number">5.1.2.</span> <span class="toc-text">调度系统（scheduler）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算属性（computed）"><span class="toc-number">5.1.3.</span> <span class="toc-text">计算属性（computed）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#惰性执行（lazy）"><span class="toc-number">5.1.4.</span> <span class="toc-text">惰性执行（lazy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch-的实现原理"><span class="toc-number">5.1.5.</span> <span class="toc-text">watch 的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#过期的副作用"><span class="toc-number">5.1.6.</span> <span class="toc-text">过期的副作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第四章总结"><span class="toc-number">5.1.7.</span> <span class="toc-text">第四章总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五章：非原始值（对象）的响应性方案"><span class="toc-number">5.2.</span> <span class="toc-text">第五章：非原始值（对象）的响应性方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六章：原始值（非对象）的响应性方案"><span class="toc-number">5.3.</span> <span class="toc-text">第六章：原始值（非对象）的响应性方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二篇总结"><span class="toc-number">5.4.</span> <span class="toc-text">第二篇总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三篇：渲染器"><span class="toc-number">6.</span> <span class="toc-text">第三篇：渲染器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第七章：渲染器的设计"><span class="toc-number">6.1.</span> <span class="toc-text">第七章：渲染器的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八章：挂载与更新"><span class="toc-number">6.2.</span> <span class="toc-text">第八章：挂载与更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM-节点操作"><span class="toc-number">6.2.1.</span> <span class="toc-text">DOM 节点操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性节点操作"><span class="toc-number">6.2.2.</span> <span class="toc-text">属性节点操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件"><span class="toc-number">6.2.3.</span> <span class="toc-text">事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第九、十、十一章：Diff-算法"><span class="toc-number">6.3.</span> <span class="toc-text">第九、十、十一章：Diff 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三篇总结"><span class="toc-number">6.4.</span> <span class="toc-text">第三篇总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四篇：组件化"><span class="toc-number">7.</span> <span class="toc-text">第四篇：组件化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第十二章：组件的实现原理"><span class="toc-number">7.1.</span> <span class="toc-text">第十二章：组件的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十三章：异步组件与函数式组件"><span class="toc-number">7.2.</span> <span class="toc-text">第十三章：异步组件与函数式组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十四章：内建组件和模块"><span class="toc-number">7.3.</span> <span class="toc-text">第十四章：内建组件和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keepAlive"><span class="toc-number">7.3.1.</span> <span class="toc-text">keepAlive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Teleport"><span class="toc-number">7.3.2.</span> <span class="toc-text">Teleport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transition"><span class="toc-number">7.3.3.</span> <span class="toc-text">Transition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四篇总结"><span class="toc-number">7.4.</span> <span class="toc-text">第四篇总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五篇：编译器"><span class="toc-number">8.</span> <span class="toc-text">第五篇：编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第十五章：编译器核心技术概述"><span class="toc-number">8.1.</span> <span class="toc-text">第十五章：编译器核心技术概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模板-DSL-的编译器"><span class="toc-number">8.1.1.</span> <span class="toc-text">模板 DSL 的编译器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第十六章：解析器（parse）"><span class="toc-number">8.1.2.</span> <span class="toc-text">第十六章：解析器（parse）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第十七章：编译优化"><span class="toc-number">8.1.3.</span> <span class="toc-text">第十七章：编译优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五篇总结"><span class="toc-number">8.2.</span> <span class="toc-text">第五篇总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六篇：服务端渲染"><span class="toc-number">9.</span> <span class="toc-text">第六篇：服务端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol>
            </div>
        </section>
    

    <section class="article typo">

        <div class="article-entry" itemprop="articleBody">
            <p>《Vue.js 设计与实现》概要总结<br><a id="more"></a></p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这是一本没有带你阅读一行源码，却可以让你在阅读完成之后，对 <code>vue 3</code> 所有的核心逻辑 <strong>了如指掌</strong> 的书籍。</p>
<p>无论是 <strong>响应性、调度系统、惰性执行</strong> ，还是 <strong>渲染器、diff 算法、编辑器三大步 </strong>  ，甚至是 <strong>有限自动状态机</strong> 等所有你能想到知识，本书都可以给你答案。</p>
<p>它就是  <strong>尤雨溪亲自做序</strong> ，<strong>Vue 官方团队成员：霍春阳</strong> 编写的  <strong>Vue.js 设计与实现</strong>。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当前这个时间段下，关于 <code>vue 3</code> 源码的书籍，主要有两本。</p>
<p>第一本就是，咱们本次要讲的  <strong>《Vue.js 设计与实现》</strong>。</p>
<p>第二本是，<strong>《vue.js 技术内幕》</strong>，作者是黄轶。</p>
<p>正巧，两本书我都买来了。</p>
<p>这两本书，虽然都是讲解 <code>vue 3</code> 源码的，但是在讲解的方式上，有非常大的区别。</p>
<p>首先是 《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 <strong>从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序）</strong>，以 <strong>提出问题 - 分析思路 - 解决问题</strong> 的方式，来讲解 <code>vue 3</code> 的核心设计。其内部，没有读一行 <code>vue3</code> 的源码，但却可以让我们对整个 <code>vue 3</code> 的核心，拥有一个非常清楚的认知。</p>
<p>其次是 《vue.js 技术内幕》：它是一个标准的 “源码分析” 书籍，内部对 <code>vue 3</code> 的很多源码，进行了逐一的解读。</p>
<p>如果大家想要学习 <code>vue 3</code> 的设计思路，掌握框架设计的思维方式。那么我强烈推荐你看一看《Vue.js 设计与实现》。</p>
<p>如果你想要对 <code>vue</code> 源码进行逐一解读，那么可以看一下《vue.js 技术内幕》。</p>
<p>那么明确好了现在市面上学习 <code>vue 3</code> 源码的方式之后，下面就让我们进入到 《Vue.js 设计与实现》的学习中去吧！</p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>《Vue.js 设计与实现》的内容一共分为 6 篇， <code>18</code> 个章节：</p>
<ul>
<li>首先第一篇：对 <code>vue</code> 的整个框架设计，进行了概述</li>
<li>第二篇：主要讲解了 <code>vue</code> 中的响应式系统，除了大家所熟悉的 <code>proxy</code> 之外，额外还包含了：调度系统 <code>scheduler</code>、惰性执行 <code>lazy</code>、<code>ref</code> 的实现原理</li>
<li>第三篇：主要针对 <code>vue</code> 的渲染器（<code>renderer</code>）进行了讲解，额外还包含了 <code>diff</code> 算法的详细讲解</li>
<li>第四篇：是组件化。包含了 组件的渲染机制，以及对 <code>vue</code> 官方组件 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 的实现原理，进行了剖析</li>
<li>第五篇：是编译器（<code>compiler</code>）。在这一篇中，把编译器的三大步：<code>parse</code>、<code>transform</code>、<code>generate</code> 进行了分步的讲解。</li>
<li>最后：是服务端渲染。主要是 <code>CSR</code>、<code>SSR</code> 以及 同构渲染。</li>
</ul>
<h2 id="第一篇：框架设计概览"><a href="#第一篇：框架设计概览" class="headerlink" title="第一篇：框架设计概览"></a>第一篇：框架设计概览</h2><p>整个第一篇分为三个章节：</p>
<ol>
<li>权衡的艺术：这里主要涉及到了 <code>vue</code> 框架设计的一些基本概念，也是咱们讲解的重点</li>
<li>框架设计的核心要素：相对比较杂，都是一些零碎的知识点</li>
<li>Vue.js 3 的设计思路：这一章包含了 <code>vue</code> 框架设计的逻辑主线，也非常重要，但是内容并不多</li>
</ol>
<p>那么首先咱们先来看第一章。</p>
<h3 id="第一章：权衡的艺术"><a href="#第一章：权衡的艺术" class="headerlink" title="第一章：权衡的艺术"></a>第一章：权衡的艺术</h3><p>在这一章中，开头的一句话，描述了框架设计的精髓，这句话也是尤雨溪在多个开发者大会中经常提到的，那就是：<strong>框架的设计，本身就是一种权衡的艺术</strong>。</p>
<p>在这一章中，书中分别从三个方面来去分析了所谓权衡的艺术，到底是什么意思。</p>
<h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>首先第一个方面就是：<strong>命令式和声明式</strong> 的概念。</p>
<p>所谓 <strong>命令式</strong> 指的就是：<strong>关注过程</strong> 的范式。</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231540415.png" alt="image-20230207231540415"></p>
<p>而 <strong>声明式</strong> 指的就是： <strong>关注结果</strong> 的范式。</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231536123.png" alt="image-20230207231536123"></p>
<p>什么意思呢？我们来举一个小例子：</p>
<blockquote>
<p>张三的妈妈，让张三去买酱油。</p>
<p>那么对于张三而言，他就需要：拿钱、出门、下楼、进超市、拿酱油、付钱、回家。</p>
<p>而对于张三的妈妈来说，她完全不需要关心张三做了什么，只需要对张三说一声就可以了。</p>
</blockquote>
<p>那么在这个例子中，张三就是一个典型的命令式，他需要完成整件事情的所有过程。</p>
<p>而张三的妈妈，就是典型的声明式，她不关心过程只关心结果。</p>
<p>那么这里大家来想一下，<code>vue</code> 是声明式的？还是命令式的？</p>
<p>对于 <code>vue</code> 而言，它的内部实现一定是 <strong>命令式</strong> 的，而我们在使用 <code>vue</code> 的时候，则是通过 <strong>声明式</strong> 来使用的。</p>
<p>也就是说： <strong>vue 封装了命令式的过程，对外暴露出了声明式的结果</strong></p>
<h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>在明确好了命令式和声明式的概念之后。接下来咱们来看下从 <strong>性能</strong> 层面，<code>vue</code> 所体现出来的一种权衡的方式。</p>
<p>针对于性能的分析，主要从两个方面去说。</p>
<p>首先第一个方面：大家觉得 <strong>是命令式的性能更强，还是声明式的性能更强呢？</strong></p>
<p>答案是：<strong>命令式的性能 &gt; 声明式的性能</strong>。</p>
<p>其实原因非常简单，对于 <strong>命令式</strong> 的代码而言，它直接通过 <strong>原生的 <code>JavaScript</code> 进行实现</strong>，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 <code>1</code>。</p>
<p>而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 <code>1 + N</code> 的。</p>
<p>那么既然如此，<code>vue</code> 为什么还要对外暴露出声明式的接口呢？</p>
<p>这其实是因为：<strong>声明式的可维护性，要远远大于命令式的可维护性</strong>。</p>
<blockquote>
<p>大家从这两段代码（命令式和声明式代码）中就可以发现，声明式代码比命令式代码要简单的多。</p>
<p>越简单的代码，可维护性就越强</p>
</blockquote>
<p>当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 <code>vue</code> 的性能优化之下，它并不会比纯命令式的性能差太多）</p>
<p>而这样的一种权衡，在 <code>template</code> 模板中，更是体现的淋漓尽致。</p>
<p>在前端领域，想要使用 <code>JavaScript</code> 修改 <code>html</code> 的方式，主要有三种：<strong><code>原生 JavaScript、innerHTML、虚拟 DOM</code></strong></p>
<p>很多小伙伴都会认为 <code>虚拟 DOM</code> 的性能是最高的，其实不是。</p>
<p>我们来看这个对比。</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207233547097.png" alt="image-20230207233547097" style="zoom:50%;"></p>
<p>从这个对比我们可以发现，<code>虚拟 DOM</code> 的性能，并不是最高的。</p>
<p>但是它的 <strong>心智负担（书写难度）最小</strong>， 从而带来了 <strong>可维护性最高</strong>。所以哪怕它的性能并不是最高的。<code>vue</code> 依然选择了 <code>虚拟 DOM</code> 来进行了渲染层的构建。</p>
<p>这个也是一种性能与可维护性的权衡。</p>
<h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>第一章的最后一部分，主要讲解的就是 <strong>运行时和编译时</strong>。</p>
<p>这两个名词，各位小伙伴在日常开发中，应该是经常听到的。</p>
<p>它们两个都是框架设计的一种方式，可单独出现，也可组合使用。</p>
<p>那么下面咱们就分别来介绍一下它们。</p>
<p>首先是 <strong>运行时：<code>runtime</code></strong>。</p>
<blockquote>
<p>它指的是：<strong>利用 render 函数，直接把 虚拟 <code>DOM</code>  转化为 真实 <code>DOM</code> 元素</strong> 的一种方式。</p>
<p>在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。</p>
</blockquote>
<p>其次是 <strong>编译时：compiler</strong>：</p>
<blockquote>
<p>它指的是：<strong>直接把 <code>template</code> 模板中的内容，转化为 真实 <code>DOM</code> 元素</strong>。</p>
<p>因为存在编译的过程，所以可以分析用户提供的内容。</p>
<p>同时，没有运行时理论上性能会更好。</p>
<p>目前该方式，有具体的实现库，那就是现在也非常火的 <code>Svelte</code></p>
<p>但是这里要注意： <strong>它的真实性能，没有办法达到理论数据。</strong></p>
</blockquote>
<p>最后是 <strong>运行时 + 编译时</strong>：</p>
<blockquote>
<p>它的过程被分为两步：</p>
<ol>
<li>先把 <code>template</code> 模板转化为 <code>render</code> 函数。也就是 <strong>编译时</strong></li>
<li>再利用 <code>render</code> 函数，把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code>。也就是 <strong>运行时</strong></li>
</ol>
<p>两者的结合，可以：</p>
<p>在 编译时，分析用户提供的内容<br>在 运行时，提供足够的灵活性</p>
<p>这也是 <code>vue</code> 的主要实现方式。</p>
</blockquote>
<h3 id="第二章：框架设计的核心要素"><a href="#第二章：框架设计的核心要素" class="headerlink" title="第二章：框架设计的核心要素"></a>第二章：框架设计的核心要素</h3><p>这一章主要讲解了，框架设计时一些凌乱的注意点。</p>
<p>比如：</p>
<ol>
<li>通过 环境变量 和 <code>TreeShanking</code> 控制打包之后的体积</li>
<li>构建不同的打包产物，以应用不同的场景</li>
<li>提供了 <code>callWithErrorHandling</code> 接口函数，来对错误进行统一处理</li>
<li>源码通过 <code>TypeScript</code> 开发，以保证可维护性。</li>
<li>内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。</li>
</ol>
<p>这些东西都是基于一个个的小点单独去说的，整体之间并没有一个完成的线性逻辑。</p>
<p>所以大家可以根据具体感兴趣或者不了解的点，单独去看就可以。</p>
<h3 id="第三章：Vue-js-3-的设计思路"><a href="#第三章：Vue-js-3-的设计思路" class="headerlink" title="第三章：Vue.js 3 的设计思路"></a>第三章：Vue.js 3 的设计思路</h3><p>在这一章中，作者站在一个高层的角度，以 <strong><code>UI</code> 形式、渲染器、组件、编辑器</strong> 为逻辑主线进行的讲解。</p>
<p>下面咱们就来捋一捋这条线。</p>
<p>在 <code>Vue</code> 中 <code>UI</code> 形式主要分为两种：</p>
<ul>
<li>声明式的模板描述<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170232727.png" alt="image-20230208170232727"></li>
<li>命令式的 render 函数<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170236795.png" alt="image-20230208170236795"></li>
</ul>
<p>而针对于 <strong>声明式的模板描述</strong> 而言，本质上就是咱们常用的 <code>tempalte</code> 模板。它会被 <strong>编辑器</strong> 编译，得到 <strong>渲染函数 <code>render</code></strong> 。</p>
<p>渲染器与渲染函数，并 <strong>不是</strong> 一个东西。</p>
<p>渲染器是 <strong>函数 <code>createRenderer</code> 的返回值，是一个对象。被叫做 <code>renderer</code></strong>。 <strong><code>renderer</code> 对象中有一个方法 <code>render</code></strong>，这个 <code>render</code> ，就是我们常说的<strong>渲染函数</strong>。</p>
<p>渲染函数接收两个参数 <code>VNode</code> 和 <code>container</code>。</p>
<p>其中 <code>VNode</code> 表示 <strong>虚拟 DOM</strong>，本质上是一个 <code>JS</code> 对象。<code>container</code> 是一个容器，表示被挂载的位置。而 <code>render</code> 函数的作用，就是： <strong>把 <code>vnode</code> 挂载到 <code>container</code> 上</strong>。</p>
<p>同时，因为 <code>Vue</code> 以组件代表最小颗粒度，所以 <code>vue</code> 内部的渲染，本质上是：<strong>大量的组件渲染</strong>。</p>
<p>而组件本质上是一组 <code>DOM</code> 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 <code>DOM</code>。也就是说，<code>Vue</code> 本质上是： <strong>以组件作为介质，来完成针对于一组、一组的 <code>DOM</code> 渲染。</strong></p>
<h3 id="第一篇总结"><a href="#第一篇总结" class="headerlink" title="第一篇总结"></a>第一篇总结</h3><p>在整个第一篇中，作者主要就是通过这三章的内容， <strong>自顶向下</strong> 的为我们介绍了 <code>vue</code> 的框架设计逻辑。其目的主要就是为了让我们了解， <code>Vue</code> 框架的运行逻辑和一些关键概念。</p>
<h2 id="第二篇：响应式系统"><a href="#第二篇：响应式系统" class="headerlink" title="第二篇：响应式系统"></a>第二篇：响应式系统</h2><p>第二篇主要是针对 <strong>响应式系统</strong> 的讲解。</p>
<p>同样也是被分为三章：</p>
<ul>
<li>首先第一章，也是最重要的一章，就是 <strong>响应系统的作用与实现</strong></li>
<li>第二章，主要针对 <strong>对象的响应性实现原理</strong> 进行了讲解</li>
<li>第三章，主要针对 <strong>非对象的响应性实现原理</strong> 进行了讲解</li>
</ul>
<h3 id="第四章：响应系统的作用与实现"><a href="#第四章：响应系统的作用与实现" class="headerlink" title="第四章：响应系统的作用与实现"></a>第四章：响应系统的作用与实现</h3><p>在这一章中，作者从 <strong>响应式数据的概念开始，讲解了响应式系统的实现。</strong> 然后针对于 <strong>计算属性与 <code>watch</code>  的实现原理，进行了分析。</strong> 在分析的过程中，也对其所设计到的 <strong><code>调度系统（scheduler）</code> 和  <code>惰性执行（lazy）</code> 的原理进行了明确。</strong> 最后讲解了在 <strong>竞态问题下，关于过期的副作用的处理逻辑。</strong> </p>
<h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><p>那么首先咱们先来看基本概念 <strong>副作用函数 与 响应式数据</strong>。</p>
<p>所谓 <strong>副作用函数</strong> 指的是 <strong>会产生副作用的函数</strong>，这样的函数非常的多。比如</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208190429676.png" alt="image-20230208190429676"></p>
<p>在这段代码中， <code>effect</code> 的触发会导致全局变化 <code>val</code> 发生变化，那么 <code>effect</code> 就可以被叫做<strong>副作用函数</strong>。而如果 <code>val</code> 这个数据的变化，导致了视图的变化，那么 <code>val</code> 就被叫做 <strong>响应式数据</strong>。</p>
<p>那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为：</p>
<ul>
<li>第一个是 <code>getter</code> 行为，也就是 <strong>数据读取</strong></li>
<li>第二个是 <code>setter</code> 行为，也就是 <strong>数据修改</strong></li>
</ul>
<p>在 <code>vue 2</code> 中，这样的两个行为通过 <code>Object.defineProperty</code> 进行的实现。</p>
<p>在 <code>vue 3</code> 中，这样的两个行为通过 <code>Proxy</code> 进行的实现。</p>
<p>那么具体的实现逻辑是什么呢？咱们来看下面的图示：</p>
<blockquote>
<p>首先是 <code>getter</code> 形式：</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191120105.png" alt="image-20230208191120105" style="zoom:20%;"></p>
<p>在该函数中，存在一个 <code>effect</code> 方法，方法内部触发了 <code>getter</code> 行为。一旦 <code>getter</code> 行为被触发，则把对应的 <code>effect</code> 方法保存到一个 “桶（数据对象）” 中</p>
<p>当触发 <code>setter</code> 行为时：</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191257788.png" alt="image-20230208191257788" style="zoom:23%;"></p>
<p>则会从 “桶” 中取出 <code>effect</code> 方法，并执行。</p>
<p>那么此时因为 <code>obj.text</code> 的值发生了变化，所以 <code>effect</code> 被执行时 <code>document.body.innerText</code> 会被赋上新的值。从而导致视图发生变化。</p>
</blockquote>
<p>这是一套构建响应式系统的基础逻辑。这一套逻辑足够应对大家在日常的 <strong>面试</strong> 或者 <strong>工作</strong> 中的基本需求。</p>
<p>而这套逻辑说起来简单，做起来还是有一些难度的。</p>
<h4 id="调度系统（scheduler）"><a href="#调度系统（scheduler）" class="headerlink" title="调度系统（scheduler）"></a>调度系统（scheduler）</h4><p>那么说完了基本的响应性之后，接下来咱们来看 <strong>调度系统（<code>scheduler</code>）</strong></p>
<p>所谓调度系统，指的就是 <strong>响应性的可调度性</strong>。</p>
<p>而所谓的可调度，指的就是 <strong>当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式</strong></p>
<p>比如，在这段打印中，决定打印的顺序</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208192343242.png" alt="image-20230208192343242" style="zoom:50%;"></p>
<p>而想要实现一个调度系统，则需要依赖 <strong><code>异步：Promise</code> 和 <code>队列：jobQueue</code></strong> 来进行实现。咱们需要 <strong>基于 <code>Set</code> 构建出一个基本的队列数组 <code>jobQueue</code>，利用 <code>Promise</code> 的异步特性，来控制执行的顺序</strong></p>
<h4 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h4><p>当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 <strong>计算属性（computed）</strong> 的实现了。</p>
<p>计算属性本质上是： <strong>一个属性值，当依赖的响应式数据发生变化时，重新计算</strong></p>
<p>那么它的实现就需要彻底依赖于 <strong>调度系统（scheduler）</strong> 来进行实现。</p>
<h4 id="惰性执行（lazy）"><a href="#惰性执行（lazy）" class="headerlink" title="惰性执行（lazy）"></a>惰性执行（lazy）</h4><p>说完计算属性，那么下面我们来看下 <code>watch</code> 监听器。</p>
<p><code>watch</code> 监听器本质上是 <strong>观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数</strong></p>
<p>这也就意味着，<code>watch</code> 很多时候并不需要立刻执行。</p>
<p>那么此时，就需要使用到 <strong>惰性执行（<code>lazy</code>）</strong> 来进行控制。</p>
<p>惰性执行的实现要比调度系统简单。它本质上 <strong>是一个 <code>boolean</code> 型的值，可以被添加到 <code>effect</code> 函数中，用来控制副作用的执行</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!lazy) &#123;</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="watch-的实现原理"><a href="#watch-的实现原理" class="headerlink" title="watch 的实现原理"></a>watch 的实现原理</h4><p>基于 调度系统 与 惰性执行，那么就可以实现 <code>watch</code> 监听器了。</p>
<h4 id="过期的副作用"><a href="#过期的副作用" class="headerlink" title="过期的副作用"></a>过期的副作用</h4><p><code>watch</code> 监听器的实现非常广泛，有时候我们甚至可以在 <strong><code>watch</code> 中完成一些异步操作。</strong></p>
<p>但是大量的异步操作，极有可能会导致 <strong>竞态问题</strong>。</p>
<p>所谓的竞态问题，指的是 <strong>在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机</strong>。比如咱们来看这段代码</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208194352049.png" alt="image-20230208194352049" style="zoom:33%;"></p>
<blockquote>
<p>这段代码完成的是一个异步操作。</p>
<p>如果 <code>obj</code> 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 <code>data</code> 被赋值为 请求B 的结果。</p>
<p>但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 <code>data</code> 的值就会变为 请求 A 的返回值。</p>
<p>这个咱们的期望是不一样的。</p>
<p>那么这样的问题，就是 <strong>竞态问题</strong></p>
</blockquote>
<p>而如果想要解决这问题，那么就需要使用到 <code>watch</code> 回调函数的第三个参数 <code>onInvalidate</code>，它本身也是一个回调函数。并且 <strong>该回调函数（<code>onInvalidate</code>）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</strong></p>
<p>而 <code>onInvalidate</code> 的实现原理也非常简单，只需要 <strong>在副作用函数（effct）重新执行前，先触发 <code>onInvalidate</code></strong> 即可。</p>
<h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><p>那么到这里，咱们就把 <strong>响应性系统的大致核心逻辑</strong> 明确完成了。从这个逻辑中，我们知道想要实现响应性数据，那么核心就是通过 <code>Proxy</code> 实现。</p>
<p>那么这个 <code>proxy</code> 具体怎么做呢？</p>
<p>接下来，咱们来看第五章。</p>
<h3 id="第五章：非原始值（对象）的响应性方案"><a href="#第五章：非原始值（对象）的响应性方案" class="headerlink" title="第五章：非原始值（对象）的响应性方案"></a>第五章：非原始值（对象）的响应性方案</h3><p>书中的第五章整体而言非常简单，主要就介绍了两个接口，<code>Proxy</code> 和 <code>Reflect</code>。</p>
<p>这两个接口通常会一起进行使用，其中：</p>
<ul>
<li><code>Proxy</code> 可以 <strong>代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象）</strong></li>
<li><code>Reflect</code> 可以 <strong>在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用</strong></li>
</ul>
<h3 id="第六章：原始值（非对象）的响应性方案"><a href="#第六章：原始值（非对象）的响应性方案" class="headerlink" title="第六章：原始值（非对象）的响应性方案"></a>第六章：原始值（非对象）的响应性方案</h3><p>如果大家熟悉 <code>proxy</code> 的话，那么可以知道，针对于 <code>proxy</code> 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。</p>
<p>但是，在 <code>vue</code> 中，我们可以通过 <code>ref</code> 构建简单数据类型的响应。</p>
<p>那么 <code>ref</code> 是如何进行实现的呢？</p>
<p>这里大家要注意：<strong>针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献</strong></p>
<p>在最新的 <code>vue 3.2</code> 代码中，<code>vue</code> 通过 <strong><code>get</code> 、<code>set</code>  函数标记符，让函数以属性调用的形式被触发。</strong>这两个修饰符，可以让我们 <strong>像调用属性一样，调用方法</strong>。 所以当我们平时 <strong>访问 ref.value 属性时，本质上是  value() 函数的执行</strong>。</p>
<h3 id="第二篇总结"><a href="#第二篇总结" class="headerlink" title="第二篇总结"></a>第二篇总结</h3><p>那么到这里咱们整个响应式系统的大概流程，就已经描述完成了。其核心逻辑主要就是在第四章中。</p>
<p>至于第五章和第六章，更多的偏向于具体的细节和代码逻辑。</p>
<h2 id="第三篇：渲染器"><a href="#第三篇：渲染器" class="headerlink" title="第三篇：渲染器"></a>第三篇：渲染器</h2><p>那么下面咱们来看 <strong>第三篇：渲染器</strong> 。</p>
<p>第三篇一共被分为 5 个章节。但是只讲解了三部分内容。</p>
<ul>
<li>首先第七章，主要讲解了<strong>渲染器的设计</strong>。</li>
<li>第八章，主要讲解了 <strong><code>DOM</code> 的挂载和更新的逻辑</strong>。</li>
<li>而 第九、十、十一 这三章，主要讲解了 <strong>Diff 算法</strong></li>
</ul>
<h3 id="第七章：渲染器的设计"><a href="#第七章：渲染器的设计" class="headerlink" title="第七章：渲染器的设计"></a>第七章：渲染器的设计</h3><p>在之前咱们说过 <strong>渲染器与渲染函数不是一个东西</strong></p>
<ul>
<li><strong>渲染器</strong> 是 <code>createRenderer</code> 的返回值，是一个对象。</li>
<li><strong>渲染函数</strong> 是渲染器对象中的 <code>render</code> 方法</li>
</ul>
<p>在 <code>vue 3.2.37</code> 的源码内部，<code>createRenderer</code> 函数的具体实现是通过 <code>baseCreateRenderer</code> 进行的。它的代码量非常庞大，涉及到了 <code>2000</code> 多行的代码。</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209085155034.png" alt="image-20230209085155034" style="zoom:33%;"></p>
<p>代码量虽多，但是核心思路并不是特别复杂。总体可以被分为两部分：</p>
<ol>
<li><strong>在浏览器端渲染时，利用 <code>DOM API</code> 完成 <code>DOM</code> 操作</strong>：比如，如果渲染 <code>DOM</code> 那么就使用 <code>createElement</code>，如果要删除 <code>DOM</code> 那么就使用 <code>removeChild</code>。</li>
<li><strong>渲染器不能与宿主环境（浏览器）产生强耦合</strong>：因为 <code>vue</code> 不光有浏览器渲染，还包括了 <code>服务端</code> 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。</li>
</ol>
<p>在渲染的过程中，还有一个非常重要的概念 <code>vnode</code>。书中并没有专门的章节来介绍 <code>vnode</code>。所以为了避免各位小伙伴对 <code>vnode</code> 不了解，咱们单独把 <code>vnode</code> 说一下。</p>
<p>所谓 <code>vnode</code> 本身是 <strong>一个普通的 JavaScript 对象，代表了渲染的内容</strong>。对象中通过 <code>type</code> 表示渲染的 <code>DOM</code>。比如 <code>type === div</code>：则表示 <code>div</code> 标签、<code>type === Framgnet</code> 则表示渲染片段（vue 3 新增）、<code>type === Text</code> 则表示渲染文本节点。</p>
<h3 id="第八章：挂载与更新"><a href="#第八章：挂载与更新" class="headerlink" title="第八章：挂载与更新"></a>第八章：挂载与更新</h3><p>对于渲染器而言，它做的最核心的事情就是 <strong>对节点进行挂载、更新的操作</strong>。作者在第八章中，详细的介绍了对应的逻辑。</p>
<p>整个第八章分为两部分来讲解了这个事情：</p>
<ol>
<li><code>DOM</code> 节点操作</li>
<li>属性节点操作</li>
</ol>
<h4 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a><code>DOM</code> 节点操作</h4><p>首先先来看 <code>DOM</code> 节点操作。<code>DOM</code> 节点的操作可以分为三部分：</p>
<ul>
<li><strong>挂载</strong>：所谓挂载表示节点的初次渲染。比如，可以直接通过 <code>createElement</code> 方法新建一个 <code>DOM</code> 节点，再利用 <code>parentEl.insertBefore</code> 方法插入节点。</li>
<li><strong>更新</strong>：当响应性数据发生变化时，可能会涉及到 <code>DOM</code> 的更新。此时的更新本质上是属于 <strong>属性的更新</strong>。咱们等到属性节点操作那里再去说。</li>
<li><strong>卸载</strong>：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 <code>parentEl.removeChild</code> 进行。</li>
</ul>
<p>以上三种类型，是 <code>vue</code> 在进行 <code>DOM</code> 操作时的常见逻辑。基本上覆盖了 <code>DOM</code> 操作 <code>90% 以上</code> 的常见场景</p>
<h4 id="属性节点操作"><a href="#属性节点操作" class="headerlink" title="属性节点操作"></a>属性节点操作</h4><p>看完了 <code>DOM</code> 操作之后，接下来咱们来看属性节点操作。</p>
<p>针对于属性而言，大体可以分为两类：</p>
<ol>
<li><strong>属性</strong>：比如 <code>class</code>、<code>id</code>、<code>value</code>、<code>src</code>…</li>
<li><strong>事件</strong>：比如 <code>click</code>、<code>input</code>….</li>
</ol>
<p>那么咱们就先来看 <strong>非事件的属性部分</strong>。</p>
<p>想要了解 <code>vue</code> 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 <strong>浏览器中的属性分类</strong>。</p>
<p>在浏览器中 <code>DOM</code> 属性其实被分为了两类：</p>
<ul>
<li>第一类叫做 <code>HTML Attributes</code>：直接定义在 <code>HTML 标签</code> 上的属性，都属于这一类。</li>
<li><p>第二类叫做 <code>DOM Properties</code>：它是拿到 <code>DOM</code> 对象后定义的属性。咱们接下来主要要说的就是它。</p>
<p><code>HTML Attributes</code> 的定义相对而言比较简单和直观，但是问题在于 <strong>它只能在 <code>html</code> 中进行操作</strong>。</p>
</li>
</ul>
<p>而如果想要在 <code>JS</code> 中操作 <code>DOM</code> 属性，就必须要通过  <code>DOM Properties</code> 来进行实现。但是因为 <code>JS</code> 本身特性的问题，会导致某些 <code>DOM Properties</code> 的设置存在特殊性。比如 <code>class、type、value</code> 这三个。</p>
<p>所以为了保证 <code>DOM Properties</code> 的成功设置，那么我们就必须要知道 <strong>不同属性的 <code>DOM Properties</code> 定义方式 </strong>。</p>
<p>下面咱们来看一下。</p>
<p><code>DOM Properties</code> 的设置一共被分为两种：</p>
<ol>
<li><code>el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;)</code></li>
<li><code>. 属性赋值</code> ： <code>el.属性名 = 属性值</code> 或者 <code>el[属性名] = 属性值</code> 都属于 <code>.属性赋值</code>  </li>
</ol>
<p>我们来看这段代码：</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209093545078.png" alt="image-20230209093545078" style="zoom:50%;"></p>
<blockquote>
<p>在这段代码中，我们为 <code>textarea</code> 利用 <code>DOM Properties</code> 的方式设置了三个不同的属性：</p>
<ul>
<li>首先是 <code>class</code>： <code>class</code> 在属性操作中是一个非常特殊的存在。它有两个名字 <code>class</code> 和 <code>className</code>。如果我们直接通过 <code>el.setAttribute</code> 的话，那么必须要用 <code>class</code> 才可以成功，而如果是通过 <code>. 属性</code> 的形式，那么必须要使用 <code>className</code> 才可以成功。</li>
<li>第二个是 <code>type</code>： <code>type</code> 仅支持 <code>el.setAttribute</code>  的方式，不支持 <code>.属性的方式</code></li>
<li>第三个是 <code>value</code>：<code>value</code> 不支持直接使用 <code>el.setAttribute</code>  设置，但是支持 <code>.属性</code> 的设置方式</li>
</ul>
</blockquote>
<p>除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>接下来，咱们来看 <code>vue</code> 对事件的处理操作。</p>
<p>事件的处理和属性、<code>DOM</code> 一样，也是分为 <strong>添加、删除、更新</strong> 三类。</p>
<ul>
<li>添加：添加比较简单，主要利用 <code>el.addEventListener</code> 进行实现即可。</li>
<li>删除：主要利用 <code>el.removeEventListener</code> 进行处理。</li>
<li>更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。</li>
</ul>
<p>通常情况下，我们所认知的事件更新应该是 <strong>删除旧事件、添加新事件</strong> 的过程。但是如果利用 <code>el.addEventListener</code> 和 <code>el.removeEventListener</code> 来完成这件事情，是一件非常消耗性能的事。</p>
<p>那么怎么能够节省性能，同时完成事件的更新呢？</p>
<p>这时，<code>vue</code> 对事件的更新提出了一个叫做 <code>vei</code> 的概念，这个概念的意思是： <strong>为 <code>addEventListener</code> 回调函数，设置了一个 <code>value</code> 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。</strong></p>
<p>这个代码比较多，大家如果想要查看具体代码的话，可以 <a href="https://github.com/lgd8981289/vue-next-mini" target="_blank" rel="noopener">在 github 搜索 vue-next-mini</a>，进入到 <code>packages/runtime-dom/src/modules/events.ts</code> 路径下查看。</p>
<h3 id="第九、十、十一章：Diff-算法"><a href="#第九、十、十一章：Diff-算法" class="headerlink" title="第九、十、十一章：Diff 算法"></a>第九、十、十一章：Diff 算法</h3><p>整个渲染器最后的三个章节全部都用来讲解了 <code>diff</code> 算法。</p>
<p>针对于 <code>diff</code> 而言，它的本质其实就是一个对比的方法，其描述的核心就是： <strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p>
<p>目前针对于 <code>vue 3.2.37</code> 的版本来说，整个的 <code>diff</code> 算法被分为 5 步（<strong>这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助</strong>）：</p>
<ol>
<li><code>sync from start</code>：自前向后的对比</li>
<li><code>sync from end</code>：自后向前的对比</li>
<li><code>common sequence + mount</code>：新节点多于旧节点，需要挂载</li>
<li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li>
<li><code>unknown sequence</code>：乱序</li>
</ol>
<p>而，针对于书中的这三章来说，本质上是按照 <strong>简单 diff 算法、双端 diff 算法、快速 diff 算法</strong> 的顺序把整个 <code>diff</code> 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。</p>
<p>所以说咱们在当前的这个分享中，肯定是没有办法为大家讲解具体算法逻辑的。</p>
<p>针对于这一块，我同样也是准备了另外的博客。</p>
<h3 id="第三篇总结"><a href="#第三篇总结" class="headerlink" title="第三篇总结"></a>第三篇总结</h3><p>针对于第三篇渲染器来说，咱们所描述的重点主要是围绕  <strong>渲染器的设计</strong> 和  <strong><code>DOM</code> 的挂载和更新的逻辑</strong> 来去说的。</p>
<p>针对于这两部分而言，大家要明确 <strong>渲染器与渲染函数的区别</strong>，同时要知道 <code>HTML Attributes</code> 和 <code>DOM Properties</code> 在行为上的差异性。另外关于事件更新的 <code>vei</code> 概念，应该也可以给大家带来一些新的思路。</p>
<p>而针对于 <code>diff</code>，咱们没有放在当前分享中去说，主要还是因为时长不够的原因。但是我为大家准备了额外的博客和视频，大家可以根据自己需要去进行查看。</p>
<h2 id="第四篇：组件化"><a href="#第四篇：组件化" class="headerlink" title="第四篇：组件化"></a>第四篇：组件化</h2><p>第四篇组件化，它应该算是比较简单的一个篇章，也是分为三部分来去讲解：</p>
<ol>
<li>组件的实现原理：这是咱们讲解的重心，但是不用担心，它并不复杂。</li>
<li>异步组件与函数式组件：这个比较冷僻，在实际开发中的使用场景有限</li>
<li>内建组件和模块：里面主要讲解了 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 这三个内置组件的实现逻辑</li>
</ol>
<h3 id="第十二章：组件的实现原理"><a href="#第十二章：组件的实现原理" class="headerlink" title="第十二章：组件的实现原理"></a>第十二章：组件的实现原理</h3><p>想要了解 <code>vue</code> 中组件的实现，那么首先我们需要知道什么是组件。</p>
<p>组件本质上就是一个 <code>JavaScript</code> 对象，比如，以下对象就是一个基本的组件</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209105953064.png" alt="image-20230209105953064" style="zoom:33%;"></p>
<p>而对于组件而言，同样需要使用 <code>vnode</code> 来进行表示，当 <code>vnode</code> 的 <code>type</code> 属性是一个 <strong>自定义对象</strong> 时，那么这个 <code>vnode</code> 就表示组件的 <code>vnode</code></p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110548502.png" alt="image-20230209110548502" style="zoom:33%;"></p>
<p>而组件的渲染，本质上是 <strong>组件包含的 <code>DOM</code> 的渲染。</strong> 对于组件而言，必然会包含一个 <code>render</code> 渲染函数。如果没有 <code>render</code> 函数，那么 <code>vue</code> 会把 <code>template</code> 模板编译为 <code>render</code> 函数。而组件渲染的内容，其实就是 <code>render</code> 函数返回的 <code>vnode</code>。具体的渲染逻辑，全部都通过渲染器执行。</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110919710.png" alt="image-20230209110919710" style="zoom:33%;"></p>
<p><code>vue 3</code> 之后提出了 <code>composition API</code>，<code>composition API</code> 包含一个入口函数，也就是 <code>setup</code> 函数。 <code>setup</code> 函数包含两种类型的返回值：</p>
<ol>
<li><strong>返回一个函数</strong>：当 <code>setup</code> 返回一个函数时，那么该函数会被作为 <code>render</code> 函数直接渲染。</li>
<li><strong>返回一个对象</strong>：当 <code>setup</code> 返回一个对象时，那么 <code>vue</code> 会直接把该对象的属性，作为 <code>render</code> 渲染时的依赖数据</li>
</ol>
<p>同时，对于组件来说还有一个 <strong>插槽</strong> 的概念。插槽的实现并不神奇。插槽本质上 <strong>是一段 <code>innerHTML</code> 的内容，在 <code>vnode</code> 中以 <code>children</code> 属性进行呈现</strong>。当插槽被渲染时，只需要渲染 <code>children</code> 即可。</p>
<p>对于组件来说，除了咱们常用的 <strong>对象组件</strong> 之外，<code>vue</code> 还提供了额外的两种组件，也就是 <strong>异步组件与函数式组件</strong>。</p>
<h3 id="第十三章：异步组件与函数式组件"><a href="#第十三章：异步组件与函数式组件" class="headerlink" title="第十三章：异步组件与函数式组件"></a>第十三章：异步组件与函数式组件</h3><p>所谓异步组件，指的是： <strong>异步加载的组件</strong> 。</p>
<p>比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。</p>
<p>异步组件在 <strong>优化页面性能、拆包、服务端下发组件</strong> 时，会比较有用。</p>
<p>而对于 <strong>函数式组件</strong> 来说，相对就比较冷僻了。函数式组件指的是 <strong>没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 <code>props</code> 属性</strong> 。在实际开发中，并不常见。</p>
<h3 id="第十四章：内建组件和模块"><a href="#第十四章：内建组件和模块" class="headerlink" title="第十四章：内建组件和模块"></a>第十四章：内建组件和模块</h3><p>这一章中，主要描述了 <code>vue</code> 的三个内置组件。</p>
<h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>首先第一个是 <code>KeepAlive</code>。</p>
<p>这是我们在日常开发中，非常常用的内置组件。它可以 <strong>缓存一个组件，避免该组件不断地销毁和创建</strong>。</p>
<p>看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 <strong>组件卸载</strong> 和 <strong>组件挂载</strong> 两个方面：</p>
<ul>
<li><strong>组件卸载</strong>：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中</li>
<li><strong>组件挂载</strong>：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。</li>
</ul>
<h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code> 是 <code>vue 3</code> 新增的组件，作用是 <strong>将 <code>Teleport</code> 插槽的内容渲染到其他的位置</strong>。比如我们可以把 <code>dialog</code> 渲染到 <code>body</code> 根标签之下。</p>
<p>它的实现原理，主要也是分为两部分：</p>
<ol>
<li>把 Teleport 组件的渲染逻辑，从渲染器中抽离</li>
<li>在指定的位置进行独立渲染</li>
</ol>
<h4 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h4><p><code>Transition</code> 是咱们常用的动画组件，作用是 <strong>实现动画逻辑</strong>。</p>
<p>其核心原理同样被总结为两点：</p>
<ol>
<li><code>DOM</code> 元素被挂载时，将动效附加到该 <code>DOM</code> 元素上</li>
<li><code>DOM</code> 元素被卸载时，等在 <code>DOM</code> 元素动效执行完成后，执行卸载 <code>DOM</code> 操作</li>
</ol>
<h3 id="第四篇总结"><a href="#第四篇总结" class="headerlink" title="第四篇总结"></a>第四篇总结</h3><p>整个第四篇，主要围绕着组件来去讲。所以内容并不复杂。</p>
<p>对于咱们的日常的开发与面试而言，其实只需要搞清楚 <strong>组件的原理</strong> 与 <strong>内建组件原理</strong> 即可。</p>
<h2 id="第五篇：编译器"><a href="#第五篇：编译器" class="headerlink" title="第五篇：编译器"></a>第五篇：编译器</h2><p>编译器是一个非常复杂的环节。作者主要通过 <strong>编辑器核心逻辑、解析器、编译优化</strong> 这三个方向进行了说明。</p>
<p>其中对于我们日常开发与面试来说，最核心的就是 <strong>第十五章：编译器核心技术概述</strong> 。这也是咱们在这一篇中的主要章节。</p>
<h3 id="第十五章：编译器核心技术概述"><a href="#第十五章：编译器核心技术概述" class="headerlink" title="第十五章：编译器核心技术概述"></a>第十五章：编译器核心技术概述</h3><p>在编译器核心技术概述，主要包含两个核心内容：</p>
<ol>
<li>模板 <code>DSL</code> 的编译器</li>
<li><code>Vue</code> 编译流程三大步</li>
</ol>
<h4 id="模板-DSL-的编译器"><a href="#模板-DSL-的编译器" class="headerlink" title="模板 DSL 的编译器"></a>模板 <code>DSL</code> 的编译器</h4><p>在任何一个编程语言中，都存在编译器的概念。 <code>vue</code> 的编译器是在 <strong>一种领域下，特定语言的编译器</strong> ，那么这种编译器被叫做 <code>DSL</code> 编译器。</p>
<p>而编译器的本质是 <strong>通过一段程序，可以把 A 语言翻译成 B 语言</strong>。在 <code>vue</code> 中的体现就是 <strong>把 <code>tempalte</code> 模板，编译成 <code>render</code> 渲染函数</strong></p>
<p>一个完整的编译器，一个分为 <strong>两个阶段、六个流程</strong>：</p>
<ul>
<li>编译前端：<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
</ul>
</li>
<li>编译后端：<ul>
<li>中间代码生成</li>
<li>优化</li>
<li>目标代码生成</li>
</ul>
</li>
</ul>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113241592.png" alt="image-20230209113241592"></p>
<p>而对于 <code>vue</code> 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113421705.png" alt="image-20230209113421705"></p>
<ol>
<li><code>parse</code>：通过 <code>parse</code> 函数，把模板编译成 <code>AST</code> 对象</li>
<li><code>transform</code>：通过 <code>transform</code> 函数，把 <code>AST</code> 转化为 <code>JavaScript AST</code></li>
<li><code>generate</code>：通过 <code>generate</code> 函数，把 <code>JavaScript AST</code> 转化为 渲染函数（<code>render</code>）</li>
</ol>
<p>这三大步中，每一步都包含非常复杂的逻辑实现。</p>
<p>和之前一样，因为篇幅的问题，我们没有办法这里去详细讲解三大步的流程。</p>
<p>我依然为大家提供了 <a href="https://juejin.cn/post/7197977396603256890/42118200" target="_blank" rel="noopener">博客版</a></p>
<h4 id="第十六章：解析器（parse）"><a href="#第十六章：解析器（parse）" class="headerlink" title="第十六章：解析器（parse）"></a>第十六章：解析器（parse）</h4><p>这一章，主要详细讲解了 <strong>parse 解析逻辑</strong>。是在三大步中的 <code>parse</code> 逻辑的基础上，进行了一个加强。</p>
<p>所以这里咱们也按下不表</p>
<h4 id="第十七章：编译优化"><a href="#第十七章：编译优化" class="headerlink" title="第十七章：编译优化"></a>第十七章：编译优化</h4><p>最后就是编译优化。</p>
<p>编译优化也是一个非常大的概念，其核心就是 <strong>通过编译的手段提取关键信息，并以此知道生成最优代码的过程</strong>。</p>
<p>它的核心优化逻辑，主要是 <strong>把节点分为两类</strong>：</p>
<ul>
<li>第一类是 <strong>动态节点</strong>：也就是会 <strong>受数据变化影响</strong> 的节点</li>
<li>第二类是 <strong>静态节点</strong>：也就是 <strong>不受数据变化影响</strong> 的节点</li>
</ul>
<p>优化主要的点，就是 <strong>动态节点</strong>。</p>
<p>优化的方式主要是通过 <code>Block 树</code> 进行优化。</p>
<p><code>Block 树</code> 本质上就是一个 <strong>虚拟节点数对象</strong>，内部包含一个 <code>dynamicChildren</code> 属性，用来 <strong>收集所有的动态子节点</strong>，以达到提取关键点进行优化的目的。</p>
<p>除此之外，还有一些小的优化手段，比如：</p>
<ul>
<li>静态提升</li>
<li>预字符串化</li>
<li>缓存内联事件处理函数</li>
<li><code>v-once</code> 指令</li>
<li>…</li>
</ul>
<h3 id="第五篇总结"><a href="#第五篇总结" class="headerlink" title="第五篇总结"></a>第五篇总结</h3><p>其实第五篇编译器应该是整本书中，逻辑最复杂的一篇了。内部包含了特别多的代码实现。</p>
<p>但是因为篇幅问题，所以我们没有办法给大家进行详细介绍。只能是把大致的核心流程为大家进行明确。希望大家见谅。</p>
<h2 id="第六篇：服务端渲染"><a href="#第六篇：服务端渲染" class="headerlink" title="第六篇：服务端渲染"></a>第六篇：服务端渲染</h2><p>最后一篇只有一个章节，就是 <strong>同构渲染</strong>。</p>
<p>想要了解同构渲染，那么需要先搞明白 <code>CSR、SSR</code> 的概念。</p>
<ul>
<li><code>CSR</code>：所谓 <code>CSR</code> 指的是 <strong>客户端渲染</strong>。<ul>
<li>浏览器向服务器发起请求</li>
<li>服务器查询数据库，返回数据</li>
<li>浏览器得到数据，进行页面构建</li>
</ul>
</li>
<li><code>SSR</code>：表示 <strong>服务端渲染</strong><ul>
<li>览器向服务器发起请求</li>
<li>服务器查询数据库，根据数据，生成 <code>HTML</code> ，并进行返回</li>
<li>浏览器直接渲染 <code>HTML</code></li>
</ul>
</li>
</ul>
<p>两种方式各有利弊，所以同构渲染，指的就是 <strong>把 <code>CSR</code> 和 <code>SSR</code> 进行合并</strong>。既可以单独 <code>CSR</code> ，也可以单独 <code>SSR</code>，同时还可以 <strong>结合两者，在首次渲染时，通过 <code>SSR</code>，在非首次渲染时，通过 <code>CSR</code></strong>。</p>
<p>以下是三者的对比图</p>
<p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209121227934.png" alt="image-20230209121227934" style="zoom:50%;"></p>
<p>而针对 <code>vue</code> 的服务端渲染来说，它是 <strong>将虚拟 <code>DOM</code>  渲染为 <code>HTML</code> 字符串</strong>，本质上是 <strong>解析的 <code>vnode</code> 对象，然后进行的 <code>html</code> 的字符串拼接</strong></p>
<p>最后又讲解了客户端激活的原理，大致分为两步：</p>
<ol>
<li>为页面中的 <code>DOM</code> 元素与虚拟节点对象之间建立联系</li>
<li>为页面中的 <code>DOM</code> 元素添加事件绑定</li>
</ol>
<p>这两步主要是通过 <code>renderer.hydrate()</code> 方法进行实现了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 那么到这里，整个 《Vue.js 设计与实现》就已经全部说完了。</p>
<p>整本书中，涉及到的内容是非常全面的，就像咱们开头所说的一样，它是一个 <strong>从高层的设计角度，来探讨框架需要关注的问题。</strong></p>
<hr>

        </div>

        
            <div class="article-tags tags">
                
                    <a href="/tags/vue/"><i class="fa fa-tag"></i>&nbsp;&nbsp;vue</a>
                
            </div>
        

        
            <div class="art-item-footer">
                
                    <span class="art-item-left">
                        <i class="fa fa-chevron-left" aria-hidden="true"></i>&nbsp;
                        <a href="/2024/07/03/从零打造一个Web地图引擎/" rel="prev" title="从零打造一个Web地图引擎">
                            从零打造一个Web地图引擎
                        </a>
                    </span>
                
                
                    <span class="art-item-right">
                        <a href="/2024/06/11/日语-N2文法/" rel="next" title="日语-N2文法">
                            日语-N2文法
                        </a>&nbsp;
                        <i class="fa fa-chevron-right" aria-hidden="true"></i>
                    </span>
                
            </div>
        

    </section>

</article>

<br>

<!-- 显示推荐文章和评论 -->


<script>
    window.subData = {
        title: '《Vue.js 设计与实现》速读',
        tools: true
    }
</script>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>
    
        <img class='avatar waves-image' src='https://avatars2.githubusercontent.com/u/20313228?s=400&u=81b6a332e9a0f8c63e4841766106f3c8f881cfb5&v=4' />
    
</section>


  <section class='m_widget categories'>
<div class='header'><i class="fa fa-sitemap" aria-hidden="true"></i>&nbsp;&nbsp;分类</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/css/"><div class='name'>css</div><div class='badge'>11</div></a></li>
    
        <li><a class="flat-box" href="/categories/javascript/"><div class='name'>javascript</div><div class='badge'>180</div></a></li>
    
        <li><a class="flat-box" href="/categories/nodejs/"><div class='name'>nodejs</div><div class='badge'>21</div></a></li>
    
        <li><a class="flat-box" href="/categories/服务器/"><div class='name'>服务器</div><div class='badge'>15</div></a></li>
    
        <li><a class="flat-box" href="/categories/计算机原理/"><div class='name'>计算机原理</div><div class='badge'>21</div></a></li>
    
    </ul>
    
</div>
</section>


  
<div class="m_widget tagcloud">
    <div class="header"><i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;标签</div>
    <div class='content'>
        <a href="/tags/3D/" style="font-size: 14.77px; color: #949494">3D</a> <a href="/tags/AI/" style="font-size: 14px; color: #999">AI</a> <a href="/tags/MYSQL笔记/" style="font-size: 20.15px; color: #6f6f6f">MYSQL笔记</a> <a href="/tags/Threejs/" style="font-size: 15.54px; color: #8f8f8f">Threejs</a> <a href="/tags/ajax/" style="font-size: 17.85px; color: #7f7f7f">ajax</a> <a href="/tags/canvas/" style="font-size: 14.77px; color: #949494">canvas</a> <a href="/tags/cordova/" style="font-size: 14px; color: #999">cordova</a> <a href="/tags/docker/" style="font-size: 14px; color: #999">docker</a> <a href="/tags/electron/" style="font-size: 14px; color: #999">electron</a> <a href="/tags/github/" style="font-size: 17.85px; color: #7f7f7f">github</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/html/" style="font-size: 17.08px; color: #848484">html</a> <a href="/tags/jquery/" style="font-size: 15.54px; color: #8f8f8f">jquery</a> <a href="/tags/linux/" style="font-size: 14.77px; color: #949494">linux</a> <a href="/tags/nodejs/" style="font-size: 15.54px; color: #8f8f8f">nodejs</a> <a href="/tags/npm/" style="font-size: 14px; color: #999">npm</a> <a href="/tags/typescript/" style="font-size: 15.54px; color: #8f8f8f">typescript</a> <a href="/tags/vue/" style="font-size: 20.92px; color: #6a6a6a">vue</a> <a href="/tags/webSocket/" style="font-size: 14px; color: #999">webSocket</a> <a href="/tags/webpack/" style="font-size: 17.85px; color: #7f7f7f">webpack</a> <a href="/tags/web图形/" style="font-size: 17.85px; color: #7f7f7f">web图形</a> <a href="/tags/web安全/" style="font-size: 17.85px; color: #7f7f7f">web安全</a> <a href="/tags/web性能/" style="font-size: 18.62px; color: #7a7a7a">web性能</a> <a href="/tags/worker/" style="font-size: 14.77px; color: #949494">worker</a> <a href="/tags/兼容性/" style="font-size: 15.54px; color: #8f8f8f">兼容性</a> <a href="/tags/后端/" style="font-size: 15.54px; color: #8f8f8f">后端</a> <a href="/tags/后端代理服务/" style="font-size: 14px; color: #999">后端代理服务</a> <a href="/tags/图片处理/" style="font-size: 17.85px; color: #7f7f7f">图片处理</a> <a href="/tags/基础知识/" style="font-size: 24px; color: #555">基础知识</a> <a href="/tags/少儿编程/" style="font-size: 14px; color: #999">少儿编程</a> <a href="/tags/工具库/" style="font-size: 23.23px; color: #5a5a5a">工具库</a> <a href="/tags/微信/" style="font-size: 14.77px; color: #949494">微信</a> <a href="/tags/手写/" style="font-size: 19.38px; color: #747474">手写</a> <a href="/tags/打印/" style="font-size: 14px; color: #999">打印</a> <a href="/tags/文章收集/" style="font-size: 14px; color: #999">文章收集</a> <a href="/tags/日语/" style="font-size: 17.85px; color: #7f7f7f">日语</a> <a href="/tags/样式/" style="font-size: 17.85px; color: #7f7f7f">样式</a> <a href="/tags/正则/" style="font-size: 14px; color: #999">正则</a> <a href="/tags/浏览器/" style="font-size: 16.31px; color: #898989">浏览器</a> <a href="/tags/爬虫/" style="font-size: 14px; color: #999">爬虫</a> <a href="/tags/移动端/" style="font-size: 21.69px; color: #656565">移动端</a> <a href="/tags/算法/" style="font-size: 15.54px; color: #8f8f8f">算法</a> <a href="/tags/编译/" style="font-size: 17.08px; color: #848484">编译</a> <a href="/tags/网络基础/" style="font-size: 20.15px; color: #6f6f6f">网络基础</a> <a href="/tags/调试/" style="font-size: 14.77px; color: #949494">调试</a> <a href="/tags/资源导航/" style="font-size: 14.77px; color: #949494">资源导航</a> <a href="/tags/软考/" style="font-size: 14px; color: #999">软考</a> <a href="/tags/面试题/" style="font-size: 22.46px; color: #5f5f5f">面试题</a> <a href="/tags/面试题系列/" style="font-size: 17.85px; color: #7f7f7f">面试题系列</a>
    </div>
</div>




      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
    <div class="social-wrapper">
      
    </div>
    <br>
    <div>博客内容遵循 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="licenses">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div>
    <div>本站使用 <a href="https://github.com/xaoxuu/hexo-theme-material-x" target="_blank" class="codename">Material-X</a> 作为主题，
		总访问量为 <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
    </div>

</footer>

  <script>setLoadingBarProgress(80);</script>
  <!-- <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script> -->
<script src="/js/jquery.min.js"></script>
<!-- <script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script> -->
<script src="/js/waves.min.js"></script>
<!-- <script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script> -->
<script src="/js/scrollreveal.min.js"></script>
<!-- 访问统计 -->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- 推荐文章 -->
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<!-- <script src="//unpkg.com/valine/dist/Valine.min.js"></script> -->
<script src="/js/jquery.fitvids.js"></script>
<script>
var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
var ALGOLIA_API_KEY = "";
var ALGOLIA_APP_ID = "";
var ALGOLIA_INDEX_NAME = "";
var AZURE_SERVICE_NAME = "";
var AZURE_INDEX_NAME = "";
var AZURE_QUERY_KEY = "";
var BAIDU_API_ID = "";
var SEARCH_SERVICE = "hexo";
var ROOT = "/"||"/";
if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


    
    
    


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
