<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>TypeScript教程(二) | jinux</title>
  <meta name="description" content="前端 学习 javascript">
  <meta name="keywords" content>
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="jinux">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TypeScript进阶教程">
<meta name="keywords" content="typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript教程(二)">
<meta property="og:url" content="/2024/08/01/TypeScript教程-二/index.html">
<meta property="og:site_name" content="jinux">
<meta property="og:description" content="TypeScript进阶教程">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2024-08-02T02:52:25.948Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript教程(二)">
<meta name="twitter:description" content="TypeScript进阶教程">

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				<!-- <i class="fa fa-home"></i> -->
				jinux
			</a>

				<div class='menu'>
					<ul class='h-list'>
						
							<li>
								<a class='flat-box nav-home' href='/'>
									<i class="fa fa-home"></i>
									主页
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-cube' href='/categories'>
									<i class="fa fa-cube"></i>
									导航
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-github' href='https://github.com/jinux7'>
									<i class="fa fa-github"></i>
									github
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-archive' href='/archives'>
									<i class="fa fa-archive"></i>
									归档
								</a>
							</li>
						
					</ul>
					<div class='underline'></div>
				</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon"><i class="fa fa-search"></i></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><i class="fa fa-search flat-box"></i></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><i class="fa fa-navicon flat-box"></i></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				xaoxuu
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><i class="fa fa-comments flat-box"></i></a></li>
				<li class='s-top'><a href='javascript:void(0)'><i class="fa fa-arrow-up flat-box"></i></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><i class="fa fa-list-ul flat-box"></i></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
        <div class="header">jinux</div>
		<nav>
			
				<a href="/" class="nav-home nav">
					<i class="fa fa-home"></i>
					主页
				</a>
			
				<a href="/categories" class="nav-cube nav">
					<i class="fa fa-cube"></i>
					导航
				</a>
			
				<a href="https://github.com/jinux7" class="nav-github nav">
					<i class="fa fa-github"></i>
					github
				</a>
			
				<a href="/archives" class="nav-archive nav">
					<i class="fa fa-archive"></i>
					归档
				</a>
			
		</nav>
	</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-TypeScript教程-二" class="post white-box article-type-post" itemscope itemprop="blogPost">
    <section class='meta'>
        <h1 class="title">
            
                TypeScript教程(二)
            
        </h1>
        <time>
            2024-08-01 Thursday&nbsp;&nbsp;
            <i class="fa fa-eye" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
        </time>
        
    
    <div class='cats'>
        <a href="/categories/javascript/">javascript</a>
    </div>


    </section>
    
        <section class="toc-wrapper">
            <div class="header"><i class="fa fa-list" aria-hidden="true"></i>&nbsp;&nbsp;目录</div>
            <div class='content'>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Type-Challenges"><span class="toc-number">1.</span> <span class="toc-text">Type-Challenges</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心知识点"><span class="toc-number">1.2.</span> <span class="toc-text">核心知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加号和减号"><span class="toc-number">1.2.1.</span> <span class="toc-text">加号和减号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyof-和-in"><span class="toc-number">1.2.2.</span> <span class="toc-text">keyof 和 in</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyof"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">keyof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#in"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">in</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">1.2.3.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never"><span class="toc-number">1.2.4.</span> <span class="toc-text">never</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends"><span class="toc-number">1.2.5.</span> <span class="toc-text">extends</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型约束"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">类型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件类型"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">条件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#infer"><span class="toc-number">1.2.6.</span> <span class="toc-text">infer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-符号"><span class="toc-number">1.2.7.</span> <span class="toc-text">&amp; 符号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初级"><span class="toc-number">1.3.</span> <span class="toc-text">初级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Pick-选取"><span class="toc-number">1.3.1.</span> <span class="toc-text">内置Pick(选取)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Readonly-只读"><span class="toc-number">1.3.2.</span> <span class="toc-text">内置Readonly(只读)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-1"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TupleToObject-元组转对象"><span class="toc-number">1.3.3.</span> <span class="toc-text">TupleToObject(元组转对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-2"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#First-数组第一个元素"><span class="toc-number">1.3.4.</span> <span class="toc-text">First(数组第一个元素)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-3"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-3"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Length-元组的长度"><span class="toc-number">1.3.5.</span> <span class="toc-text">Length(元组的长度)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-4"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-4"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Exclude-排除"><span class="toc-number">1.3.6.</span> <span class="toc-text">内置Exclude(排除)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-5"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-5"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PromiseType-promise包裹类型"><span class="toc-number">1.3.7.</span> <span class="toc-text">PromiseType(promise包裹类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-6"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-6"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#If-判断"><span class="toc-number">1.3.8.</span> <span class="toc-text">If(判断)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-7"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-7"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concat-数组concat方法"><span class="toc-number">1.3.9.</span> <span class="toc-text">Concat(数组concat方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-8"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-8"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Includes-数组includes方法"><span class="toc-number">1.3.10.</span> <span class="toc-text">Includes(数组includes方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-9"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-9"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Push-数组push方法"><span class="toc-number">1.3.11.</span> <span class="toc-text">Push(数组push方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-10"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-10"><span class="toc-number">1.3.11.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unshift-数组unshift方法"><span class="toc-number">1.3.12.</span> <span class="toc-text">Unshift(数组unshift方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-11"><span class="toc-number">1.3.12.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-11"><span class="toc-number">1.3.12.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Parameters-函数的参数类型"><span class="toc-number">1.3.13.</span> <span class="toc-text">内置Parameters(函数的参数类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-12"><span class="toc-number">1.3.13.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-12"><span class="toc-number">1.3.13.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Partial-可填-和内置Required-必填"><span class="toc-number">1.3.14.</span> <span class="toc-text">内置Partial(可填)和内置Required(必填)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-13"><span class="toc-number">1.3.14.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-13"><span class="toc-number">1.3.14.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Record-构造"><span class="toc-number">1.3.15.</span> <span class="toc-text">内置Record(构造)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-14"><span class="toc-number">1.3.15.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-14"><span class="toc-number">1.3.15.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Extract-交集"><span class="toc-number">1.3.16.</span> <span class="toc-text">内置Extract(交集)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-15"><span class="toc-number">1.3.16.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-15"><span class="toc-number">1.3.16.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中级"><span class="toc-number">1.4.</span> <span class="toc-text">中级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内置ReturnType-函数返回类型"><span class="toc-number">1.4.1.</span> <span class="toc-text">内置ReturnType(函数返回类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-16"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-16"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置Omit-移除"><span class="toc-number">1.4.2.</span> <span class="toc-text">内置Omit(移除)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-17"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-17"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Readonly-按需Readonly"><span class="toc-number">1.4.3.</span> <span class="toc-text">Readonly(按需Readonly)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-18"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-18"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepReadonly-深度Readonly"><span class="toc-number">1.4.4.</span> <span class="toc-text">DeepReadonly(深度Readonly)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-19"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-19"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TupleToUnion-元组转联合类型"><span class="toc-number">1.4.5.</span> <span class="toc-text">TupleToUnion(元组转联合类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-20"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-20"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chainable-可串联构造器"><span class="toc-number">1.4.6.</span> <span class="toc-text">Chainable(可串联构造器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-21"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-21"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Last-数组最后一个元素"><span class="toc-number">1.4.7.</span> <span class="toc-text">Last(数组最后一个元素)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-22"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-22"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pop-数组Pop方法"><span class="toc-number">1.4.8.</span> <span class="toc-text">Pop(数组Pop方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-23"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-23"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PromiseAll返回类型"><span class="toc-number">1.4.9.</span> <span class="toc-text">PromiseAll返回类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-24"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-24"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LookUp-查找"><span class="toc-number">1.4.10.</span> <span class="toc-text">LookUp(查找)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-25"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-25"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trim、TrimLeft以及TrimRight"><span class="toc-number">1.4.11.</span> <span class="toc-text">Trim、TrimLeft以及TrimRight</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-26"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-26"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Capitalize-首字母大写-和UnCapitalize-首字母小写"><span class="toc-number">1.4.12.</span> <span class="toc-text">Capitalize(首字母大写)和UnCapitalize(首字母小写)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-27"><span class="toc-number">1.4.12.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-27"><span class="toc-number">1.4.12.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replace"><span class="toc-number">1.4.13.</span> <span class="toc-text">Replace</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-28"><span class="toc-number">1.4.13.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-28"><span class="toc-number">1.4.13.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReplaceAll"><span class="toc-number">1.4.14.</span> <span class="toc-text">ReplaceAll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-29"><span class="toc-number">1.4.14.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-29"><span class="toc-number">1.4.14.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppendArgument-追加参数"><span class="toc-number">1.4.15.</span> <span class="toc-text">AppendArgument(追加参数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-30"><span class="toc-number">1.4.15.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-30"><span class="toc-number">1.4.15.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Permutation-排列组合"><span class="toc-number">1.4.16.</span> <span class="toc-text">Permutation(排列组合)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-31"><span class="toc-number">1.4.16.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-31"><span class="toc-number">1.4.16.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LengthOfString-字符串的长度"><span class="toc-number">1.4.17.</span> <span class="toc-text">LengthOfString(字符串的长度)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-32"><span class="toc-number">1.4.17.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-32"><span class="toc-number">1.4.17.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flatten-数组降维"><span class="toc-number">1.4.18.</span> <span class="toc-text">Flatten(数组降维)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-33"><span class="toc-number">1.4.18.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-33"><span class="toc-number">1.4.18.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppendToObject-对象添加新属性"><span class="toc-number">1.4.19.</span> <span class="toc-text">AppendToObject(对象添加新属性)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-34"><span class="toc-number">1.4.19.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-34"><span class="toc-number">1.4.19.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Absolute-绝对值"><span class="toc-number">1.4.20.</span> <span class="toc-text">Absolute(绝对值)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-35"><span class="toc-number">1.4.20.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-35"><span class="toc-number">1.4.20.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringToArray-字符串转数组"><span class="toc-number">1.4.21.</span> <span class="toc-text">StringToArray(字符串转数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-36"><span class="toc-number">1.4.21.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-36"><span class="toc-number">1.4.21.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringToUnion-字符串转联合类型"><span class="toc-number">1.4.22.</span> <span class="toc-text">StringToUnion(字符串转联合类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-37"><span class="toc-number">1.4.22.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-37"><span class="toc-number">1.4.22.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-类型合并"><span class="toc-number">1.4.23.</span> <span class="toc-text">Merge(类型合并)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-38"><span class="toc-number">1.4.23.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-38"><span class="toc-number">1.4.23.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KebabCase-字符串转连字符"><span class="toc-number">1.4.24.</span> <span class="toc-text">KebabCase(字符串转连字符)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-39"><span class="toc-number">1.4.24.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-39"><span class="toc-number">1.4.24.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diff-类型差异部分"><span class="toc-number">1.4.25.</span> <span class="toc-text">Diff(类型差异部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-40"><span class="toc-number">1.4.25.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-40"><span class="toc-number">1.4.25.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AnyOf-数组元素真值判断"><span class="toc-number">1.4.26.</span> <span class="toc-text">AnyOf(数组元素真值判断)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-41"><span class="toc-number">1.4.26.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-41"><span class="toc-number">1.4.26.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsNever-是否是Never类型"><span class="toc-number">1.4.27.</span> <span class="toc-text">IsNever(是否是Never类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-42"><span class="toc-number">1.4.27.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-42"><span class="toc-number">1.4.27.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsUnion-是否联合类型"><span class="toc-number">1.4.28.</span> <span class="toc-text">IsUnion(是否联合类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-43"><span class="toc-number">1.4.28.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-43"><span class="toc-number">1.4.28.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReplaceKeys-类型替换"><span class="toc-number">1.4.29.</span> <span class="toc-text">ReplaceKeys(类型替换)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-44"><span class="toc-number">1.4.29.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-44"><span class="toc-number">1.4.29.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RemoveIndexSignature-移除索引签名"><span class="toc-number">1.4.30.</span> <span class="toc-text">RemoveIndexSignature(移除索引签名)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-45"><span class="toc-number">1.4.30.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-45"><span class="toc-number">1.4.30.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PercentageParser-百分比解析"><span class="toc-number">1.4.31.</span> <span class="toc-text">PercentageParser(百分比解析)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-46"><span class="toc-number">1.4.31.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-46"><span class="toc-number">1.4.31.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DropChar-移除字符"><span class="toc-number">1.4.32.</span> <span class="toc-text">DropChar(移除字符)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-47"><span class="toc-number">1.4.32.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-47"><span class="toc-number">1.4.32.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MinusOne-减一"><span class="toc-number">1.4.33.</span> <span class="toc-text">MinusOne(减一)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-48"><span class="toc-number">1.4.33.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-48"><span class="toc-number">1.4.33.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PickByType-根据类型选取"><span class="toc-number">1.4.34.</span> <span class="toc-text">PickByType(根据类型选取)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-49"><span class="toc-number">1.4.34.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-49"><span class="toc-number">1.4.34.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StartsWith-字符串startsWith方法"><span class="toc-number">1.4.35.</span> <span class="toc-text">StartsWith(字符串startsWith方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-50"><span class="toc-number">1.4.35.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-50"><span class="toc-number">1.4.35.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EndsWith-字符串endsWith方法"><span class="toc-number">1.4.36.</span> <span class="toc-text">EndsWith(字符串endsWith方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-51"><span class="toc-number">1.4.36.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-51"><span class="toc-number">1.4.36.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PartialByKeys-按需可选"><span class="toc-number">1.4.37.</span> <span class="toc-text">PartialByKeys(按需可选)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-52"><span class="toc-number">1.4.37.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-52"><span class="toc-number">1.4.37.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequiredByKeys-按需必填"><span class="toc-number">1.4.38.</span> <span class="toc-text">RequiredByKeys(按需必填)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-53"><span class="toc-number">1.4.38.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-53"><span class="toc-number">1.4.38.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutable-可改"><span class="toc-number">1.4.39.</span> <span class="toc-text">Mutable(可改)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-54"><span class="toc-number">1.4.39.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-54"><span class="toc-number">1.4.39.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OmitByType-按类型移除"><span class="toc-number">1.4.40.</span> <span class="toc-text">OmitByType(按类型移除)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-55"><span class="toc-number">1.4.40.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-55"><span class="toc-number">1.4.40.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectEntries"><span class="toc-number">1.4.41.</span> <span class="toc-text">ObjectEntries</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-56"><span class="toc-number">1.4.41.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-56"><span class="toc-number">1.4.41.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shift-数组shift方法"><span class="toc-number">1.4.42.</span> <span class="toc-text">Shift(数组shift方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-57"><span class="toc-number">1.4.42.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-57"><span class="toc-number">1.4.42.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TupleToNestedObject-元组转嵌套对象"><span class="toc-number">1.4.43.</span> <span class="toc-text">TupleToNestedObject(元组转嵌套对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-58"><span class="toc-number">1.4.43.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-58"><span class="toc-number">1.4.43.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse"><span class="toc-number">1.4.44.</span> <span class="toc-text">Reverse</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-59"><span class="toc-number">1.4.44.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-59"><span class="toc-number">1.4.44.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlipArguments-反转函数参数类型"><span class="toc-number">1.4.45.</span> <span class="toc-text">FlipArguments(反转函数参数类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-60"><span class="toc-number">1.4.45.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-60"><span class="toc-number">1.4.45.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlattenDepth-数组按深度降维"><span class="toc-number">1.4.46.</span> <span class="toc-text">FlattenDepth(数组按深度降维)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-61"><span class="toc-number">1.4.46.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-61"><span class="toc-number">1.4.46.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BEM"><span class="toc-number">1.4.47.</span> <span class="toc-text">BEM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-62"><span class="toc-number">1.4.47.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-62"><span class="toc-number">1.4.47.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InOrderTraversal-中序遍历"><span class="toc-number">1.4.48.</span> <span class="toc-text">InOrderTraversal(中序遍历)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-63"><span class="toc-number">1.4.48.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-63"><span class="toc-number">1.4.48.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlipObject-对象键值交换"><span class="toc-number">1.4.49.</span> <span class="toc-text">FlipObject(对象键值交换)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-64"><span class="toc-number">1.4.49.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-64"><span class="toc-number">1.4.49.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fibonacci-斐波那契数列"><span class="toc-number">1.4.50.</span> <span class="toc-text">Fibonacci(斐波那契数列)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-65"><span class="toc-number">1.4.50.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-65"><span class="toc-number">1.4.50.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AllCombinations-全排列"><span class="toc-number">1.4.51.</span> <span class="toc-text">AllCombinations(全排列)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-66"><span class="toc-number">1.4.51.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-66"><span class="toc-number">1.4.51.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GreaterThan-大于"><span class="toc-number">1.4.52.</span> <span class="toc-text">GreaterThan(大于)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-67"><span class="toc-number">1.4.52.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-67"><span class="toc-number">1.4.52.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zip-按位置匹配"><span class="toc-number">1.4.53.</span> <span class="toc-text">Zip(按位置匹配)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-68"><span class="toc-number">1.4.53.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-68"><span class="toc-number">1.4.53.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsTuple-是否为元组"><span class="toc-number">1.4.54.</span> <span class="toc-text">IsTuple(是否为元组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-69"><span class="toc-number">1.4.54.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-69"><span class="toc-number">1.4.54.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chunk-lodash分割数组"><span class="toc-number">1.4.55.</span> <span class="toc-text">Chunk(lodash分割数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-70"><span class="toc-number">1.4.55.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-70"><span class="toc-number">1.4.55.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fill-数组fill方法"><span class="toc-number">1.4.56.</span> <span class="toc-text">Fill(数组fill方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-71"><span class="toc-number">1.4.56.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-71"><span class="toc-number">1.4.56.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Without-移除"><span class="toc-number">1.4.57.</span> <span class="toc-text">Without(移除)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-72"><span class="toc-number">1.4.57.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-72"><span class="toc-number">1.4.57.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trunc-Math-trunc取整"><span class="toc-number">1.4.58.</span> <span class="toc-text">Trunc(Math.trunc取整)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-73"><span class="toc-number">1.4.58.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-73"><span class="toc-number">1.4.58.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexOf-数组indexOf方法"><span class="toc-number">1.4.59.</span> <span class="toc-text">IndexOf(数组indexOf方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-74"><span class="toc-number">1.4.59.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-74"><span class="toc-number">1.4.59.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-数组join方法"><span class="toc-number">1.4.60.</span> <span class="toc-text">Join(数组join方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-75"><span class="toc-number">1.4.60.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-75"><span class="toc-number">1.4.60.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LastIndexOf-数组lastIndexOf方法"><span class="toc-number">1.4.61.</span> <span class="toc-text">LastIndexOf(数组lastIndexOf方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-76"><span class="toc-number">1.4.61.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-76"><span class="toc-number">1.4.61.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-数组去重"><span class="toc-number">1.4.62.</span> <span class="toc-text">Unique(数组去重)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-77"><span class="toc-number">1.4.62.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-77"><span class="toc-number">1.4.62.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapTypes-类型转换"><span class="toc-number">1.4.63.</span> <span class="toc-text">MapTypes(类型转换)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-78"><span class="toc-number">1.4.63.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-78"><span class="toc-number">1.4.63.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConstructTuple-构造元组"><span class="toc-number">1.4.64.</span> <span class="toc-text">ConstructTuple(构造元组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-79"><span class="toc-number">1.4.64.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-79"><span class="toc-number">1.4.64.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NumberRange-限定范围数字"><span class="toc-number">1.4.65.</span> <span class="toc-text">NumberRange(限定范围数字)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-80"><span class="toc-number">1.4.65.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-80"><span class="toc-number">1.4.65.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subsequence-元组子序列"><span class="toc-number">1.4.66.</span> <span class="toc-text">Subsequence(元组子序列)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-81"><span class="toc-number">1.4.66.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-81"><span class="toc-number">1.4.66.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CheckRepeatedChars-是否包含相同字符"><span class="toc-number">1.4.67.</span> <span class="toc-text">CheckRepeatedChars(是否包含相同字符)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-82"><span class="toc-number">1.4.67.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-82"><span class="toc-number">1.4.67.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FirstUniqueCharIndex-字符串中第一个唯一字符"><span class="toc-number">1.4.68.</span> <span class="toc-text">FirstUniqueCharIndex(字符串中第一个唯一字符)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-83"><span class="toc-number">1.4.68.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-83"><span class="toc-number">1.4.68.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParseUrlParams-解析url路径参数"><span class="toc-number">1.4.69.</span> <span class="toc-text">ParseUrlParams(解析url路径参数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-84"><span class="toc-number">1.4.69.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-84"><span class="toc-number">1.4.69.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetMiddleElement-数组中位数"><span class="toc-number">1.4.70.</span> <span class="toc-text">GetMiddleElement(数组中位数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-85"><span class="toc-number">1.4.70.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-85"><span class="toc-number">1.4.70.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FindOnlyElements-数组只出现一次的元素"><span class="toc-number">1.4.71.</span> <span class="toc-text">FindOnlyElements(数组只出现一次的元素)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-86"><span class="toc-number">1.4.71.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-86"><span class="toc-number">1.4.71.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountArrayElement-计数数组中元素出现的次数"><span class="toc-number">1.4.72.</span> <span class="toc-text">CountArrayElement(计数数组中元素出现的次数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-87"><span class="toc-number">1.4.72.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-87"><span class="toc-number">1.4.72.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-数字整数"><span class="toc-number">1.4.73.</span> <span class="toc-text">Integer(数字整数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-88"><span class="toc-number">1.4.73.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-88"><span class="toc-number">1.4.73.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToPrimitive-转化基本类型"><span class="toc-number">1.4.74.</span> <span class="toc-text">ToPrimitive(转化基本类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-89"><span class="toc-number">1.4.74.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-89"><span class="toc-number">1.4.74.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepMutable-深度Mutable"><span class="toc-number">1.4.75.</span> <span class="toc-text">DeepMutable(深度Mutable)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-90"><span class="toc-number">1.4.75.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-90"><span class="toc-number">1.4.75.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AllMatch-数组元素是否与给定元素完全相同"><span class="toc-number">1.4.76.</span> <span class="toc-text">AllMatch(数组元素是否与给定元素完全相同)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-91"><span class="toc-number">1.4.76.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-91"><span class="toc-number">1.4.76.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter-数组过滤"><span class="toc-number">1.4.77.</span> <span class="toc-text">Filter(数组过滤)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-92"><span class="toc-number">1.4.77.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-92"><span class="toc-number">1.4.77.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FindAllIndex-查找数组中给定元素所有索引"><span class="toc-number">1.4.78.</span> <span class="toc-text">FindAllIndex(查找数组中给定元素所有索引)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-93"><span class="toc-number">1.4.78.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-93"><span class="toc-number">1.4.78.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CombKeys-组合键"><span class="toc-number">1.4.79.</span> <span class="toc-text">CombKeys(组合键)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-94"><span class="toc-number">1.4.79.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-94"><span class="toc-number">1.4.79.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReplaceFirst-替换元组中第一个匹配项"><span class="toc-number">1.4.80.</span> <span class="toc-text">ReplaceFirst(替换元组中第一个匹配项)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-95"><span class="toc-number">1.4.80.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-95"><span class="toc-number">1.4.80.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#困难"><span class="toc-number">1.5.</span> <span class="toc-text">困难</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleVue-简单Vue类型"><span class="toc-number">1.5.1.</span> <span class="toc-text">SimpleVue(简单Vue类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-96"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-96"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Currying-柯里化"><span class="toc-number">1.5.2.</span> <span class="toc-text">Currying(柯里化)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-97"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-97"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionToIntersection-元组取交集"><span class="toc-number">1.5.3.</span> <span class="toc-text">UnionToIntersection(元组取交集)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-98"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-98"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequiredKeys-所有必填字段"><span class="toc-number">1.5.4.</span> <span class="toc-text">RequiredKeys(所有必填字段)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-99"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-99"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetRequired-必填字段组成的类型"><span class="toc-number">1.5.5.</span> <span class="toc-text">GetRequired(必填字段组成的类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-100"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-100"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OptionalKeys-所有可选字段"><span class="toc-number">1.5.6.</span> <span class="toc-text">OptionalKeys(所有可选字段)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-101"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-101"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetOptional-可选字段组成的类型"><span class="toc-number">1.5.7.</span> <span class="toc-text">GetOptional(可选字段组成的类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-102"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-102"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CapitalizeWords-所有单词首字母大写"><span class="toc-number">1.5.8.</span> <span class="toc-text">CapitalizeWords(所有单词首字母大写)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-103"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-103"><span class="toc-number">1.5.8.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CamelCase-下划线字符串转小驼峰"><span class="toc-number">1.5.9.</span> <span class="toc-text">CamelCase(下划线字符串转小驼峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-104"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-104"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParsePrintFormat-获取字符串格式化参数"><span class="toc-number">1.5.10.</span> <span class="toc-text">ParsePrintFormat(获取字符串格式化参数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-105"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-105"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VueBasicProps-Vue的Props类型"><span class="toc-number">1.5.11.</span> <span class="toc-text">VueBasicProps(Vue的Props类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-106"><span class="toc-number">1.5.11.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-106"><span class="toc-number">1.5.11.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsAny和NotAny"><span class="toc-number">1.5.12.</span> <span class="toc-text">IsAny和NotAny</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-107"><span class="toc-number">1.5.12.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-107"><span class="toc-number">1.5.12.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get-字符串路径取值"><span class="toc-number">1.5.13.</span> <span class="toc-text">Get(字符串路径取值)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-108"><span class="toc-number">1.5.13.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-108"><span class="toc-number">1.5.13.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringToNumber-字符串数字转数字"><span class="toc-number">1.5.14.</span> <span class="toc-text">StringToNumber(字符串数字转数字)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-109"><span class="toc-number">1.5.14.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-109"><span class="toc-number">1.5.14.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FilterOut-数组元素过滤"><span class="toc-number">1.5.15.</span> <span class="toc-text">FilterOut(数组元素过滤)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-110"><span class="toc-number">1.5.15.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-110"><span class="toc-number">1.5.15.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TupleToEnum-元组转枚举"><span class="toc-number">1.5.16.</span> <span class="toc-text">TupleToEnum(元组转枚举)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-111"><span class="toc-number">1.5.16.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-111"><span class="toc-number">1.5.16.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Format-字符串格式化函数类型"><span class="toc-number">1.5.17.</span> <span class="toc-text">Format(字符串格式化函数类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-112"><span class="toc-number">1.5.17.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-112"><span class="toc-number">1.5.17.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LengthOfString-字符串的长度-1"><span class="toc-number">1.5.18.</span> <span class="toc-text">LengthOfString(字符串的长度)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-113"><span class="toc-number">1.5.18.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-113"><span class="toc-number">1.5.18.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionToTuple-联合类型转元组"><span class="toc-number">1.5.19.</span> <span class="toc-text">UnionToTuple(联合类型转元组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-114"><span class="toc-number">1.5.19.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-114"><span class="toc-number">1.5.19.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-字符串拼接"><span class="toc-number">1.5.20.</span> <span class="toc-text">Join(字符串拼接)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-115"><span class="toc-number">1.5.20.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-115"><span class="toc-number">1.5.20.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepPick-深层次Pick"><span class="toc-number">1.5.21.</span> <span class="toc-text">DeepPick(深层次Pick)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-116"><span class="toc-number">1.5.21.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-116"><span class="toc-number">1.5.21.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Camelize-对象属性键转小驼峰"><span class="toc-number">1.5.22.</span> <span class="toc-text">Camelize(对象属性键转小驼峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-117"><span class="toc-number">1.5.22.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-117"><span class="toc-number">1.5.22.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DropString-移除全部字符"><span class="toc-number">1.5.23.</span> <span class="toc-text">DropString(移除全部字符)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-118"><span class="toc-number">1.5.23.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-118"><span class="toc-number">1.5.23.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Split-字符串Split方法"><span class="toc-number">1.5.24.</span> <span class="toc-text">Split(字符串Split方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-119"><span class="toc-number">1.5.24.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-119"><span class="toc-number">1.5.24.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassPublicKeys-类的公共键"><span class="toc-number">1.5.25.</span> <span class="toc-text">ClassPublicKeys(类的公共键)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-120"><span class="toc-number">1.5.25.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-120"><span class="toc-number">1.5.25.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsRequiredKeys-是否为必填key"><span class="toc-number">1.5.26.</span> <span class="toc-text">IsRequiredKeys(是否为必填key)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-121"><span class="toc-number">1.5.26.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-121"><span class="toc-number">1.5.26.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectEntries-对象Object-entries方法"><span class="toc-number">1.5.27.</span> <span class="toc-text">ObjectEntries(对象Object.entries方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-122"><span class="toc-number">1.5.27.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-122"><span class="toc-number">1.5.27.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsPalindrome-是否为回文"><span class="toc-number">1.5.28.</span> <span class="toc-text">IsPalindrome(是否为回文)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-123"><span class="toc-number">1.5.28.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-123"><span class="toc-number">1.5.28.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutableKeys-所有可写键"><span class="toc-number">1.5.29.</span> <span class="toc-text">MutableKeys(所有可写键)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-124"><span class="toc-number">1.5.29.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-124"><span class="toc-number">1.5.29.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intersection-交集"><span class="toc-number">1.5.30.</span> <span class="toc-text">Intersection(交集)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-125"><span class="toc-number">1.5.30.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-125"><span class="toc-number">1.5.30.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BinaryToDecimal-二进制转十进制"><span class="toc-number">1.5.31.</span> <span class="toc-text">BinaryToDecimal(二进制转十进制)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-126"><span class="toc-number">1.5.31.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-126"><span class="toc-number">1.5.31.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectKeyPaths-对象属性键路径"><span class="toc-number">1.5.32.</span> <span class="toc-text">ObjectKeyPaths(对象属性键路径)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-127"><span class="toc-number">1.5.32.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-127"><span class="toc-number">1.5.32.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TwoSum-LeetCode两数之和"><span class="toc-number">1.5.33.</span> <span class="toc-text">TwoSum(LeetCode两数之和)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-128"><span class="toc-number">1.5.33.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-128"><span class="toc-number">1.5.33.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ValidDate-校验是否为合法日期"><span class="toc-number">1.5.34.</span> <span class="toc-text">ValidDate(校验是否为合法日期)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-129"><span class="toc-number">1.5.34.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-129"><span class="toc-number">1.5.34.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assign-对象Object-assign方法"><span class="toc-number">1.5.35.</span> <span class="toc-text">Assign(对象Object.assign方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-130"><span class="toc-number">1.5.35.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-130"><span class="toc-number">1.5.35.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-数字中的最大值"><span class="toc-number">1.5.36.</span> <span class="toc-text">Maximum(数字中的最大值)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-131"><span class="toc-number">1.5.36.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-131"><span class="toc-number">1.5.36.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepCapitalize-深度首字母大写"><span class="toc-number">1.5.37.</span> <span class="toc-text">DeepCapitalize(深度首字母大写)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-132"><span class="toc-number">1.5.37.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-132"><span class="toc-number">1.5.37.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionReplace-联合类型替换"><span class="toc-number">1.5.38.</span> <span class="toc-text">UnionReplace(联合类型替换)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-133"><span class="toc-number">1.5.38.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-133"><span class="toc-number">1.5.38.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FizzBuzz-Fizz和Buzz输出问题"><span class="toc-number">1.5.39.</span> <span class="toc-text">FizzBuzz(Fizz和Buzz输出问题)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-134"><span class="toc-number">1.5.39.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-134"><span class="toc-number">1.5.39.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RLE-运行长度编码"><span class="toc-number">1.5.40.</span> <span class="toc-text">RLE(运行长度编码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-135"><span class="toc-number">1.5.40.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-135"><span class="toc-number">1.5.40.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectPathArray-对象键路径数组"><span class="toc-number">1.5.41.</span> <span class="toc-text">ObjectPathArray(对象键路径数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-136"><span class="toc-number">1.5.41.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-136"><span class="toc-number">1.5.41.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SnakeCase-字符串下划线连接"><span class="toc-number">1.5.42.</span> <span class="toc-text">SnakeCase(字符串下划线连接)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-137"><span class="toc-number">1.5.42.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-137"><span class="toc-number">1.5.42.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IsNegativeNumber-是否为负数"><span class="toc-number">1.5.43.</span> <span class="toc-text">IsNegativeNumber(是否为负数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-138"><span class="toc-number">1.5.43.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-138"><span class="toc-number">1.5.43.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OptionalUndefined-按需转换为可选属性"><span class="toc-number">1.5.44.</span> <span class="toc-text">OptionalUndefined(按需转换为可选属性)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用法-139"><span class="toc-number">1.5.44.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方式-139"><span class="toc-number">1.5.44.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地狱"><span class="toc-number">1.6.</span> <span class="toc-text">地狱</span></a></li></ol></li></ol>
            </div>
        </section>
    

    <section class="article typo">

        <div class="article-entry" itemprop="articleBody">
            <p>TypeScript进阶教程<br><a id="more"></a></p>
<h1 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type-Challenges"></a>Type-Challenges</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学习完<code>TypeScript</code>一些基础知识后，已经可以熟练使用一些基本类型定义了，但对于<code>TypeScript</code>的高级用法却依旧无法入门，为了更有趣的学习<code>TypeScript</code>高级用法，选择<a href="https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md" target="_blank" rel="noopener">Type-Challenges</a>类型挑战来作为我们学习的目标。</p>
<p>在<code>Type-Challenges</code>中，可以从简单(<code>easy</code>)、中等(<code>medium</code>)、困难(<code>hard</code>)以及地狱(<code>extreme</code>)难度，循序渐进的学习<code>TypeScript</code>高级技巧。</p>
<p>如果你需要选择其它的方向来深入学习<code>TypeScript</code>高级技巧，这里也有一些推荐的开源项目：</p>
<ul>
<li>官方内置：在<code>lib.es5.d.ts</code>文件中，<code>TypeScript</code>官方默认内置了一些辅助工具函数，例如：<code>Partial</code>、<code>Required</code>、<code>Pick</code>以及<code>Record</code>等等。</li>
<li>其它开源库：<a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="noopener">utility-types</a>、<a href="https://github.com/millsp/ts-toolbelt" target="_blank" rel="noopener">ts-toolbelt</a>、<a href="https://github.com/andnp/SimplyTyped" target="_blank" rel="noopener">SimplyTyped</a></li>
</ul>
<h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="加号和减号"><a href="#加号和减号" class="headerlink" title="加号和减号"></a>加号和减号</h3><blockquote>
<p>tip<br>加号和减号的用法类似。</p>
</blockquote>
<p>在一些内置工具中，可能会出现<code>+</code>或者<code>-</code>这些符号，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Required&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<p>观察以上结果可以得出结论：<code>-?</code>是去掉类型中属性后面的<code>?</code>，整个<code>Required</code>的实际效果是去掉<code>T</code>类型中所有属性键后面的<code>?</code>，让所有属性变成必填的。</p>
<h3 id="keyof-和-in"><a href="#keyof-和-in" class="headerlink" title="keyof 和 in"></a>keyof 和 in</h3><p><code>keyof</code>和<code>in</code>经常会连在一起使用，当它们连在一起使用时，通常表示一个迭代的过程。</p>
<h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>在<code>TS</code>中，<code>keyof T</code>这段代码表示获取<code>T</code>类型中所有属性键，这些属性键组合成一个联合类型，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = keyof Person</span><br></pre></td></tr></table></figure></p>
<p><code>TS</code>中的<code>keyof T</code>，它有点类似<code>JavaScript</code>中的<code>Object.keys()</code>，它们的共同点都是获取属性键的集合，只不过<code>keyof T</code>得到的结果是一个联合类型，而<code>Object.keys()</code>得到的是一个数组。</p>
<h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p><code>in</code>操作符的右侧通常跟一个联合类型，可以使用<code>in</code>来迭代这个联合类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅演示使用, K为每次迭代的项</span></span><br><span class="line">K <span class="keyword">in</span> <span class="string">'name'</span> | <span class="string">'age'</span> | <span class="string">'sex'</span></span><br><span class="line">K = <span class="string">'name'</span> <span class="comment">// 第一次迭代结果</span></span><br><span class="line">K = <span class="string">'age'</span>  <span class="comment">// 第二次迭代结果</span></span><br><span class="line">K = <span class="string">'sex'</span>  <span class="comment">// 第三次迭代结果</span></span><br></pre></td></tr></table></figure></p>
<p>根据<code>keyof</code>和<code>in</code>的特点，我们可以撰写一些辅助工具，这里以<code>Readonly</code>为例。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; readony name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Readonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li><code>[P in keyof T]</code>：这段代码表示遍历<code>T</code>中的每一个属性键，每次遍历时属性键取名为<code>P</code>，这和<code>JavaScript</code>中的<code>for in</code>非常类似：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的迭代</span></span><br><span class="line">P <span class="keyword">in</span> keyof T</span><br><span class="line"></span><br><span class="line"><span class="comment">// js中的迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>TS</code>中的<code>typeof</code>，可以用来获取一个<code>JavaScript</code>变量的类型，经常用于获取一个普通对象或者一个函数的类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'AAA'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：(a: number, b:number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> t1  = <span class="keyword">typeof</span> add</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> obj</span><br></pre></td></tr></table></figure></p>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>类型表示永远不会有值的一种类型。</p>
<p>例如，如果一个函数抛出一个错误，那么这个函数就可以用<code>never</code>或者<code>void</code>来表示其返回值，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never更适合用来表示永远没有返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void适合用来表示返回值为空的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>never</code>的另外一个知识点是：如果一个联合类型中存在<code>never</code>，那么实际的联合类型并不会包含<code>never</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span> | never</span><br><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><code>extends</code>关键词，一般有两种用法：<strong>类型约束</strong>和<strong>条件类型</strong>。</p>
<h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>类型约束经常和泛型一起使用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型约束</span></span><br><span class="line">U <span class="keyword">extends</span> keyof T</span><br></pre></td></tr></table></figure></p>
<p><code>keyof T</code>是一个整体，它表示一个联合类型。<code>U extends Union</code>这一整段表示<code>U</code>的类型被收缩在一个联合类型的范围内。例如： <code>U extends &#39;name&#39; | &#39;age&#39;</code>，则表示<code>U</code>只能为<code>name</code>或者<code>age</code>二者其中之一。</p>
<h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>常见的条件类型表现形式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? <span class="string">'Y'</span> : <span class="string">'N'</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现条件类型有点像<code>JavaScript</code>中的三元表达式，事实上它们的工作原理是类似的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = <span class="literal">true</span> <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="literal">true</span> : <span class="literal">false</span>                    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span> | <span class="string">'age'</span> ? <span class="literal">true</span> : <span class="literal">false</span>           <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? <span class="literal">true</span> : <span class="literal">false</span>   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; ? <span class="literal">true</span> : <span class="literal">false</span>         <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>在条件类型中，有一个特别需要注意的东西就是：<strong>分布式条件类型</strong>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置工具：交集</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br><span class="line"><span class="keyword">type</span> type1 = <span class="string">'name'</span>|<span class="string">'age'</span></span><br><span class="line"><span class="keyword">type</span> type2 = <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集结果：'name'</span></span><br><span class="line"><span class="keyword">type</span> result = Extract&lt;type1, type2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推理步骤</span></span><br><span class="line"><span class="string">'name'</span>|<span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">step1： (<span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never) =&gt; <span class="string">'name'</span></span><br><span class="line">step2:  <span class="function">(<span class="params">'age' <span class="keyword">extends</span> 'name'|'address'|'sex' ? 'age' : never</span>)   =&gt;</span> never</span><br><span class="line">result: <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li><p><code>T extends U ? T : never</code>：因为<code>T</code>是一个联合类型，所以这里适用于<strong>分布式条件类型</strong>的概念。根据其概念，在实际的过程中会把<code>T</code>类型中的每一个子类型进行迭代，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代：</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never</span><br><span class="line"><span class="comment">// 第二次迭代：</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure>
</li>
<li><p>在迭代完成之后，会把每次迭代的结果组合成一个新的联合类型(根据<code>never</code>类型的特点，最后的结果会剔除掉<code>never</code>)，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p><code>infer</code>关键词的作用是延时推导，它会在类型未推导时进行占位，等到真正推导成功后，它能准确的返回正确的类型。</p>
<p>为了更好的理解<code>infer</code>关键词的用法，我们使用<code>ReturnType</code>这个例子来说明，<code>ReturnType</code>是一个用来获取函数返回类型的工具。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: number</span></span><br><span class="line"><span class="keyword">type</span> result = ReturnType&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends (...args: any) =&gt; infer R</code>：如果不看<code>infer R</code>，这段代码实际表示：<code>T</code>是不是一个函数类型。</li>
<li><code>(...args: any) =&gt; infer R</code>：这段代码实际表示一个函数类型，其中把它的参数使用<code>args</code>来表示，把它的返回类型用<code>R</code>来进行占位。<br>如果<code>T</code>满足是一个函数类型，那么我们返回其函数的返回类型，也就是<code>R</code>；如果不是一个函数类型，就返回<code>never</code>。</li>
</ul>
<p><code>TS</code>中的<code>infer</code>占位更像<code>JavaScript</code>中的模板字符串：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的返回类型使用R占位表示</span></span><br><span class="line">(...args: <span class="built_in">any</span>) =&gt; info R</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串中的值，使用变量name占位表示</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure></p>
<h3 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp; 符号"></a>&amp; 符号</h3><p>在<code>TS</code>中有两种类型值得我们重点关注：<strong>联合类型</strong>和<strong>交叉类型</strong>。</p>
<p>联合类型一般适用于基本类型的<strong>合并</strong>，它使用<code>|</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="number">1</span> | <span class="literal">true</span> | <span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
<p>而交叉类型则适用于对象或者函数的<strong>合并</strong>，它使用<code>&amp;</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = T &amp; U</span><br></pre></td></tr></table></figure></p>
<p><code>T &amp; U</code>表示一个新的类型，其中这个类型包含<code>T</code>和<code>U</code>中所有的键，这和<code>JavaScript</code>中的<code>Object.assign()</code>函数的作用非常类似。</p>
<p>根据交叉类型的概念，我们可以封装一个合并对象的<code>merge</code>函数，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.8.4以上版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> unknown <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> unknown <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts v4.8.4以下版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; name: <span class="string">'AAA'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; age: <span class="number">23</span> &#125;</span><br><span class="line"><span class="comment">// js结果：&#123; name：'AAA'; age: 23; &#125;</span></span><br><span class="line"><span class="comment">// ts结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">const</span> result = merge(obj1, obj2)</span><br></pre></td></tr></table></figure></p>
<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="内置Pick-选取"><a href="#内置Pick-选取" class="headerlink" title="内置Pick(选取)"></a>内置Pick(选取)</h3><p><link-and-solution num="4"></link-and-solution></p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>Pick</code>表示从一个类型中选取指定的几个字段组合成一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: &#123; name: string; address: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PickResult = Pick&lt;Person, <span class="string">'name'</span> | <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>K extends keyof T</code>：表示<code>K</code>只能是<code>keyof T</code>的子类型，如果我们在使用<code>Pick</code>的时候传递了不存在于<code>T</code>的字段，会报错：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：phone无法分配给keyof T</span></span><br><span class="line"><span class="keyword">type</span> result = MyPick&lt;Person, <span class="string">'name'</span> | <span class="string">'phone'</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内置Readonly-只读"><a href="#内置Readonly-只读" class="headerlink" title="内置Readonly(只读)"></a>内置Readonly(只读)</h3><p><link-and-solution num="7"></link-and-solution></p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p><code>Readonly</code>是用来让所有属性变为只读，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; readonly name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MyReadonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TupleToObject-元组转对象"><a href="#TupleToObject-元组转对象" class="headerlink" title="TupleToObject(元组转对象)"></a>TupleToObject(元组转对象)</h3><p><link-and-solution num="11"></link-and-solution></p>
<h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToObject&lt;T&gt;</code>是用来把一个元组转换成一个<code>key/value</code>相同的对象，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：readonly ['msg', 'name']</span></span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="string">'msg'</span>, <span class="string">'name'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 结果：&#123; msg: 'msg'; name: 'name'; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToObject&lt;<span class="keyword">typeof</span> tuple&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>as const</code>：常用来进行常量断言，在此处表示将<code>[&#39;msg&#39;,&#39;name&#39;]</code>推导常量元组，表示其不能新增、删除、修改元素，可以使用<code>as readonly</code>来辅助理解。</li>
<li><code>T[number]</code>：表示返回数组中所有数字型索引的元素，形成一个联合类型，例如：<code>&#39;msg&#39;|&#39;name&#39;</code>。</li>
</ul>
<h3 id="First-数组第一个元素"><a href="#First-数组第一个元素" class="headerlink" title="First(数组第一个元素)"></a>First(数组第一个元素)</h3><p><link-and-solution num="14"></link-and-solution></p>
<h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>First&lt;T&gt;</code>用来返回数组的第一个元素，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = First&lt;[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result2 = First&lt;[]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? never : T[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 占位实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer R, ...infer L] ? R : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends []</code>：用来判断<code>T</code>是否是一个空数组。</li>
<li><code>T[0]</code>：根据下标取数组第一个元素。</li>
<li><code>infer R</code>： 表示数组第一个元素的占位。</li>
<li><code>...infer L</code>: 表示数组剩余元素的占位。</li>
</ul>
<h3 id="Length-元组的长度"><a href="#Length-元组的长度" class="headerlink" title="Length(元组的长度)"></a>Length(元组的长度)</h3><p><link-and-solution num="18"></link-and-solution></p>
<h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>Length&lt;T&gt;</code>用来获取一个数组(包括类数组)的长度，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = Length&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：10</span></span><br><span class="line"><span class="keyword">type</span> result2 = Length&lt;&#123; <span class="number">5</span>: <span class="string">'5'</span>, length: <span class="number">10</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? T[<span class="string">'length'</span>] : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends { length: number; }</code>：判断<code>T</code>是否是<code>{ length: number; }</code>的子类型，如果是则代表<code>T</code>为数组或者类数组。</li>
<li><code>T[&#39;length&#39;]</code>：取<code>T</code>对象的<code>length</code>属性的值(注意，在<code>TypeScript</code>中不能使用<code>T.length</code>来取值，而应该使用<code>T[&#39;length&#39;]</code>)。</li>
</ul>
<h3 id="内置Exclude-排除"><a href="#内置Exclude-排除" class="headerlink" title="内置Exclude(排除)"></a>内置Exclude(排除)</h3><p><link-and-solution num="43"></link-and-solution></p>
<h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><p><code>Exclude</code>是排除的意思，它从<code>T</code>类型中排除属于<code>U</code>类型的子集，可以理解成取<code>T</code>对于<code>U</code>的差集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> ExcludeResult = Exclude&lt;<span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span>, <span class="string">'sex'</span>|<span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T extends U</code>：这段代码会从<code>T</code>的子类型开始分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U </span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span></span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'name'</span> |</span><br><span class="line">  <span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'age'</span> |</span><br><span class="line">  <span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'sex'</span></span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PromiseType-promise包裹类型"><a href="#PromiseType-promise包裹类型" class="headerlink" title="PromiseType(promise包裹类型)"></a>PromiseType(promise包裹类型)</h3><p><link-and-solution num="189"></link-and-solution></p>
<h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseType</code>是用来获取<code>Promise</code>包裹类型的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span> (<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>|<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：(） =&gt; Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> getInfo</span><br><span class="line"><span class="comment">// 结果：Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> returnResult = ReturnType&lt;funcType&gt;</span><br><span class="line"><span class="comment">// 结果：string|number</span></span><br><span class="line"><span class="keyword">type</span> PromiseResult = PromiseType&lt;returnResult&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PromiseType&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer R&gt;</span><br><span class="line">    ? R <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">      ? PromiseType&lt;R&gt;</span><br><span class="line">      : R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends Promise&lt;infer R&gt;</code>：判断<code>T</code>是否是<code>Promise&lt;infer R&gt;</code>的子类型，也就是说<code>T</code>必须满足<code>Promise&lt;any&gt;</code>的形式。</li>
</ul>
<h3 id="If-判断"><a href="#If-判断" class="headerlink" title="If(判断)"></a>If(判断)</h3><p><link-and-solution num="268"></link-and-solution></p>
<h4 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h4><p><code>If&lt;C, T, F&gt;</code>用来表示根据<code>C</code>的值来返回<code>T</code>或者<code>F</code>，如果<code>C</code>为<code>true</code>，则返回<code>T</code>；如果<code>C</code>为<code>false</code>，则返回<code>F</code>，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a'</span></span><br><span class="line"><span class="keyword">type</span> result1 = If&lt;<span class="literal">true</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'b'</span></span><br><span class="line"><span class="keyword">type</span> result2 = If&lt;<span class="literal">false</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>根据上案例，我们可以直观的发现<code>If&lt;C, T, F&gt;</code>的作用有点类似<code>JavaScript</code>中的三元表达式：<code>C ? T : F</code>。</p>
<h4 id="实现方式-7"><a href="#实现方式-7" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> If&lt;C <span class="keyword">extends</span> <span class="built_in">boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>C extends boolean</code>：表示<code>C</code>为<code>boolean</code>类型的子类型，既<code>C</code>只能为<code>true</code>或者<code>false</code>，传递其它值报错。</li>
<li><code>C extends true</code>：如果用<code>JavaScript</code>来表示的话，相当于<code>C===true</code>.</li>
</ul>
<h3 id="Concat-数组concat方法"><a href="#Concat-数组concat方法" class="headerlink" title="Concat(数组concat方法)"></a>Concat(数组concat方法)</h3><p><link-and-solution num="533"></link-and-solution></p>
<h4 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h4><p><code>Concat&lt;T, U&gt;</code>用来将两个数组合并起来，类似实现数组的<code>concat</code>方法，使用方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Concat&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-8"><a href="#实现方式-8" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...U]</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends any[]</code>：用来限制<code>T</code>是一个数组，如果传递非数组会报错，<code>U</code>也是一样的道理。</li>
<li><code>[...T, ...U]</code>：可以理解成<code>JavaScript</code>的扩展运算符<code>...</code>。</li>
</ul>
<h3 id="Includes-数组includes方法"><a href="#Includes-数组includes方法" class="headerlink" title="Includes(数组includes方法)"></a>Includes(数组includes方法)</h3><p><link-and-solution num="898"></link-and-solution></p>
<h4 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h4><p><code>Includes&lt;T, U&gt;</code>用来判断<code>U</code>是否在数组<code>T</code>中，类似实现数组的<code>includes</code>方法，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'1'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-9"><a href="#实现方式-9" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = U <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 完善版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> [infer R, ...infer L]</span><br><span class="line">    ? Equal&lt;R, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : MyIncludes&lt;L, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T[number]</code>：它返回数组中所有数字类型键对应的值，将这些值构造成一个联合类型，例如：<code>1 | 2 | 3</code>。</li>
<li><code>U extends T[number]</code>：判断<code>U</code>是否是某个联合类型的子类型，例如：<code>1 extends 1 | 2 | 3</code>。</li>
<li><code>Equal</code>：是用来判断两个值是否相等的辅助方法。</li>
</ul>
<h3 id="Push-数组push方法"><a href="#Push-数组push方法" class="headerlink" title="Push(数组push方法)"></a>Push(数组push方法)</h3><p><link-and-solution num="3057"></link-and-solution></p>
<h4 id="用法-10"><a href="#用法-10" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Push&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-10"><a href="#实现方式-10" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push实现</span></span><br><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [...T, K]</span><br></pre></td></tr></table></figure>
<h3 id="Unshift-数组unshift方法"><a href="#Unshift-数组unshift方法" class="headerlink" title="Unshift(数组unshift方法)"></a>Unshift(数组unshift方法)</h3><p><link-and-solution num="3060"></link-and-solution></p>
<p>与<code>pop</code>和<code>push</code>方法相似的另外一对方法叫<code>shift</code>和<code>unshift</code>，它们的实现思路是一样的。</p>
<h4 id="用法-11"><a href="#用法-11" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[0, 1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unshift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-11"><a href="#实现方式-11" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unshift实现</span></span><br><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [K, ...T]</span><br></pre></td></tr></table></figure>
<h3 id="内置Parameters-函数的参数类型"><a href="#内置Parameters-函数的参数类型" class="headerlink" title="内置Parameters(函数的参数类型)"></a>内置Parameters(函数的参数类型)</h3><p><link-and-solution num="3312"></link-and-solution></p>
<h4 id="用法-12"><a href="#用法-12" class="headerlink" title="用法"></a>用法</h4><p><code>Parameters</code>是用来获取一个函数的参数类型的，其中获取的结果是一个元组，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// [number, string]</span></span><br><span class="line"><span class="keyword">type</span> result = MyParameters&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-12"><a href="#实现方式-12" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyParameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span> ? R : never</span><br></pre></td></tr></table></figure>
<h3 id="内置Partial-可填-和内置Required-必填"><a href="#内置Partial-可填-和内置Required-必填" class="headerlink" title="内置Partial(可填)和内置Required(必填)"></a>内置Partial(可填)和内置Required(必填)</h3><blockquote>
<p>tip<br>此题不属于type-challenges类型挑战题</p>
</blockquote>
<h4 id="用法-13"><a href="#用法-13" class="headerlink" title="用法"></a>用法</h4><p><code>Partial</code>和<code>Required</code>一个是让所有属性可填、另外一个是让所有属性必填，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name?: string; age?: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PartialResult = MyPartial&lt;Person&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> RequiredResult = MyRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-13"><a href="#实现方式-13" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPartial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内置Record-构造"><a href="#内置Record-构造" class="headerlink" title="内置Record(构造)"></a>内置Record(构造)</h3><blockquote>
<p>tip<br>此题不属于type-challenges类型挑战题</p>
</blockquote>
<h4 id="用法-14"><a href="#用法-14" class="headerlink" title="用法"></a>用法</h4><p><code>Record&lt;K, T&gt;</code>用来将<code>K</code>的每一个键(<code>k</code>)指定为<code>T</code>类型，这样由多个<code>k/T</code>组合成了一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keys = <span class="string">'Cat'</span>|<span class="string">'Dot'</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  Cat: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  Dog: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> RecordResult = Record&lt;keys, Animal&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-14"><a href="#实现方式-14" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRecord&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>K extends keyof any</code>：此代码表示<code>K</code>是<code>keyof any</code>任意类型其所有键的子类型，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K为 'Dog'|'cat'</span></span><br><span class="line"><span class="keyword">type</span> UnionKeys = <span class="string">'Dog'</span> | <span class="string">'Cat'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K为'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TypeKeys = keyof Person</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内置Extract-交集"><a href="#内置Extract-交集" class="headerlink" title="内置Extract(交集)"></a>内置Extract(交集)</h3><blockquote>
<p>tip<br>此题不属于type-challenges类型挑战题</p>
</blockquote>
<h4 id="用法-15"><a href="#用法-15" class="headerlink" title="用法"></a>用法</h4><p><code>Extract&lt;T, U&gt;</code>用来取联合类型<code>T</code>和<code>U</code>的交集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'age'|'address'</span></span><br><span class="line"><span class="keyword">type</span> ExtractResult = Extract&lt;keyof Person, <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-15"><a href="#实现方式-15" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExtract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends U</code>：此代码会自动将<code>T</code>的子类型进行分发，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T extends U</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never |</span><br><span class="line">  <span class="string">'age'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never |</span><br><span class="line">  <span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'address'</span> ? <span class="string">'age'</span> : never</span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'age'</span>|<span class="string">'address'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="内置ReturnType-函数返回类型"><a href="#内置ReturnType-函数返回类型" class="headerlink" title="内置ReturnType(函数返回类型)"></a>内置ReturnType(函数返回类型)</h3><p><link-and-solution num="2"></link-and-solution></p>
<h4 id="用法-16"><a href="#用法-16" class="headerlink" title="用法"></a>用法</h4><p><code>ReturnType&lt;T&gt;</code>是用来获取一个函数的返回类型的，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span> (<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：number</span></span><br><span class="line">type result = ReturnType&lt;<span class="keyword">typeof</span> getRandom&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-16"><a href="#实现方式-16" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T extends (...args: any) =&gt; infer R</code>：判断<code>T</code>类型是否是一个函数的子类型，既<code>T</code>是不是一个函数。</li>
<li><code>infer R</code>：表示待推导的函数返回类型为<code>R</code>，后续可以在表达式中使用<code>R</code>来代替真正的返回类型。</li>
</ul>
<h3 id="内置Omit-移除"><a href="#内置Omit-移除" class="headerlink" title="内置Omit(移除)"></a>内置Omit(移除)</h3><p><link-and-solution num="3"></link-and-solution></p>
<h4 id="用法-17"><a href="#用法-17" class="headerlink" title="用法"></a>用法</h4><p><code>Omit</code>是移除的意思，它用来在<code>T</code>类型中移除指定的字段，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name？: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> OmitResult = Omit&lt;Person, <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-17"><a href="#实现方式-17" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Omit</code>可以借助在上面已经实现过的<code>Pick</code>和<code>Exclude</code>配合来实现，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Omit实现</span></span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K&gt; = MyPick&lt;T, MyExclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li>使用<code>MyExclude&lt;keyof T, K&gt;</code>，可以从<code>T</code>中移除指定的字段，移除后得到一个新的联合类型：<code>&#39;name&#39;|&#39;age&#39;</code></li>
<li>使用<code>MyPick&lt;T, &#39;name&#39;|&#39;age&#39;&gt;</code>，可以从<code>T</code>中选取这两个字段，组合成一个新的类型。</li>
</ul>
<h3 id="Readonly-按需Readonly"><a href="#Readonly-按需Readonly" class="headerlink" title="Readonly(按需Readonly)"></a>Readonly(按需Readonly)</h3><p><link-and-solution num="8"></link-and-solution></p>
<h4 id="用法-18"><a href="#用法-18" class="headerlink" title="用法"></a>用法</h4><p>不同于初级实现中的<code>Readonly</code>，在中级实现的<code>Readonly</code>中，如果我们传递了指定的字段，那么<code>Readonly</code>会表现为按需实现<code>readonly</code>，用法如下。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected1 &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected2 &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult1 = Readonly&lt;Todo&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult2 = Readonly&lt;Todo, <span class="string">'desc'</span>|<span class="string">'completed'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line"><span class="keyword">const</span> obj: ReadonlyResult2 = &#123;</span><br><span class="line">  title: <span class="string">'AAA'</span>,</span><br><span class="line">  desc: <span class="string">'23'</span>,</span><br><span class="line">  completed: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">obj.title = <span class="string">'aaa'</span></span><br><span class="line">obj.desc = <span class="string">'32'</span> <span class="comment">// error</span></span><br><span class="line">obj.completed = <span class="literal">false</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-18"><a href="#实现方式-18" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.4+版本可直接用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = T &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts v4.5+版本必须用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>K extends keyof T = keyof T</code>：如要传递了<code>K</code>，那么只能是<code>T</code>中已经存在的属性，不存在则报错；如果不传递，则默认值为<code>keyof T</code>，意味着全部属性都添加<code>readonly</code>。</li>
<li><code>T &amp; U</code>：在本例中表示将<code>T</code>和<code>U</code>中的字段结合起来，如果没有<code>&amp;</code>会丢失一些属性，例如<code>title</code>。</li>
</ul>
<h3 id="DeepReadonly-深度Readonly"><a href="#DeepReadonly-深度Readonly" class="headerlink" title="DeepReadonly(深度Readonly)"></a>DeepReadonly(深度Readonly)</h3><p><link-and-solution num="9"></link-and-solution></p>
<h4 id="用法-19"><a href="#用法-19" class="headerlink" title="用法"></a>用法</h4><p><code>DeepReadonly</code>用来将一个嵌套对象类型中所有字段全部添加<code>readonly</code>关键词，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：</span></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">  b: <span class="built_in">string</span></span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="built_in">boolean</span></span><br><span class="line">    e: <span class="literal">undefined</span>,</span><br><span class="line">    f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> Y = &#123;</span><br><span class="line">  readonly b: <span class="built_in">string</span></span><br><span class="line">  readonly c: &#123;</span><br><span class="line">    readonly d: <span class="built_in">boolean</span></span><br><span class="line">    readonly e: <span class="literal">undefined</span>,</span><br><span class="line">    readonly f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-19"><a href="#实现方式-19" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; ? DeepReadonly&lt;T[P]&gt; : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T[P] extends { [key: string]: any }</code>：这段表示<code>T[P]</code>是否是一个包含索引签名的字段，如果包含我们认为它是一个嵌套对象，就可以递归调用<code>DeepReadonly</code>。</li>
</ul>
<h3 id="TupleToUnion-元组转联合类型"><a href="#TupleToUnion-元组转联合类型" class="headerlink" title="TupleToUnion(元组转联合类型)"></a>TupleToUnion(元组转联合类型)</h3><p><link-and-solution num="10"></link-and-solution></p>
<h4 id="用法-20"><a href="#用法-20" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToUnion</code>是用来将一个元组转换成联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'1' | '2' | '3'</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToUnion&lt;[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-20"><a href="#实现方式-20" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: T[number]</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>]</span><br><span class="line"><span class="comment">// way2: 递归</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">    ? R | TupleToUnion&lt;args&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T[number]</code>：它会自动迭代元组的数字型索引，然后将所有元素组合成一个联合类型。</li>
<li><code>R | TupleToUnion&lt;args&gt;</code>：<code>R</code>表示每一次迭代中的第一个元素，它的迭代过程可以用下面伪代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'3'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">''</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | <span class="string">'3'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Chainable-可串联构造器"><a href="#Chainable-可串联构造器" class="headerlink" title="Chainable(可串联构造器)"></a>Chainable(可串联构造器)</h3><p><link-and-solution num="12"></link-and-solution></p>
<h4 id="用法-21"><a href="#用法-21" class="headerlink" title="用法"></a>用法</h4><p><code>Chainable</code>是用来让一个对象可以进行链式调用的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  foo: <span class="built_in">number</span></span><br><span class="line">  bar: &#123;</span><br><span class="line">    value: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> obj: Chainable&lt;&#123;&#125;&gt;</span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">const</span> result = obj</span><br><span class="line">  .options(<span class="string">'foo'</span>, <span class="number">123</span>)</span><br><span class="line">  .options(<span class="string">'bar'</span>, &#123; value: <span class="string">'Hello'</span> &#125;)</span><br><span class="line">  .options(<span class="string">'name'</span>, <span class="string">'TypeScript'</span>)</span><br><span class="line">  .get()</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-21"><a href="#实现方式-21" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chainable&lt;T&gt; = &#123;</span><br><span class="line">  options&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, V&gt;(key: K, value: V): Chainable&lt;T &amp; &#123;[k <span class="keyword">in</span> K]: V&#125;&gt;</span><br><span class="line">  <span class="keyword">get</span>(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>{[k in K]: V}</code>：每次调用<code>options</code>时，把<code>key/value</code>构造成一个对象，例如：<code>{ foo: 123 }</code>。</li>
<li><code>T &amp; U</code>：此处使用到<code>&amp;</code>关键词，用来合并<code>T</code>和<code>U</code>两个对象中的所有<code>key</code>。</li>
<li><code>Chainable&lt;&gt;</code>：递归调用<code>Chainable</code>，赋予新对象以链式调用的能力。</li>
</ul>
<h3 id="Last-数组最后一个元素"><a href="#Last-数组最后一个元素" class="headerlink" title="Last(数组最后一个元素)"></a>Last(数组最后一个元素)</h3><p><link-and-solution num="15"></link-and-solution></p>
<h4 id="用法-22"><a href="#用法-22" class="headerlink" title="用法"></a>用法</h4><p><code>Last</code>是用来获取数组中最后一个元素的，它和我们之前已经实现的<code>First</code>思路很相似。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = Last&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-22"><a href="#实现方式-22" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Last</code>的实现方式很巧妙，因为它既可以在索引上做文章来实现，也可以用占位的思想来实现。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1：索引思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [<span class="built_in">any</span>, ...T][T[<span class="string">'length'</span>]]</span><br><span class="line"><span class="comment">// way2: 后占位思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer R, infer L] ? L : never</span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li><p><code>[any, ...T]</code>：此代码表示我们构建了一个新数组，并添加了一个新元素到第一个位置，然后把原数组<code>T</code>中的元素依次扩展到新数组中，可以用以下伪代码表示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 新数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="built_in">any</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 结果: 3</span></span><br><span class="line"><span class="keyword">const</span> result = arr[T[<span class="string">'length'</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>T[&#39;length&#39;]</code>：这里我们获取到的是原始<code>T</code>数组的长度，例如<code>[1, 2, 3]</code>，长度值为<code>3</code>。而在新数组中，索引为<code>3</code>的位置正好是最后一个元素的索引，通过这种方式就能达到我们的目的。</p>
</li>
<li><code>T extends [...infer R, infer L]</code>：这段代码表示，我们将原数组中最后一个元素使用<code>L</code>进行占位，而其它元素我们用一个<code>R</code>数组表示。这样，如果数组满足这种格式，就能正确返回最后一个元素的值。</li>
</ul>
<h3 id="Pop-数组Pop方法"><a href="#Pop-数组Pop方法" class="headerlink" title="Pop(数组Pop方法)"></a>Pop(数组Pop方法)</h3><p><link-and-solution num="16"></link-and-solution></p>
<p>继续沿用以上处理索引思想或占位的思想，我们能快速实现数组<code>pop</code>方法。</p>
<h4 id="用法-23"><a href="#用法-23" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Pop&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2：[]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Pop&lt;[]&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-23"><a href="#实现方式-23" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop实现</span></span><br><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> []</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> [...infer Rest, infer L]</span><br><span class="line">      ? Rest</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure>
<h3 id="PromiseAll返回类型"><a href="#PromiseAll返回类型" class="headerlink" title="PromiseAll返回类型"></a>PromiseAll返回类型</h3><p><link-and-solution num="20"></link-and-solution></p>
<h4 id="用法-24"><a href="#用法-24" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseAll</code>是用来取<code>Promise.all()</code>函数所有返回的类型，其用法如下<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result1 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result2 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result3 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)])</span><br><span class="line"><span class="keyword">const</span> result4 = PromiseAll&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1： Promise&lt;[1, 2, 3]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">typeof</span> result1</span><br><span class="line"><span class="comment">// 结果2： Promise&lt;[1, 2, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> result2</span><br><span class="line"><span class="comment">// 结果3： Promise&lt;[number, number, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="keyword">typeof</span> result3</span><br><span class="line"><span class="comment">// 结果4： Promise&lt;number[]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t4 = <span class="keyword">typeof</span> result4</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-24"><a href="#实现方式-24" class="headerlink" title="实现方式"></a>实现方式</h4><p>与之前的例子不同，<code>PromiseAll</code>我们声明的是一个<code>function</code>而不是<code>type</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Awaited为内置类型</span></span><br><span class="line"><span class="keyword">type</span> PromiseAllType&lt;T&gt; = <span class="built_in">Promise</span>&lt;&#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: Awaited&lt;T[P]&gt;</span><br><span class="line">&#125;&gt;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">values: readonly [...T]</span>): <span class="title">PromiseAllType</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li>因为<code>Promise.all()</code>函数接受的是一个数组，因此泛型<code>T</code>限制为一个<code>any[]</code>类型的数组。</li>
<li><code>PromiseAllType</code>的实现思路有点像之前的<code>PromiseType</code>，只不过这里多了一层<code>Promise</code>的包裹，因为<code>Promise.all()</code>的返回类型也是一个<code>Promise</code>。</li>
</ul>
<h3 id="LookUp-查找"><a href="#LookUp-查找" class="headerlink" title="LookUp(查找)"></a>LookUp(查找)</h3><p><link-and-solution num="62"></link-and-solution></p>
<h4 id="用法-25"><a href="#用法-25" class="headerlink" title="用法"></a>用法</h4><p><code>LookUp</code>是用来根据类型值查<code>type</code>找类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'cat'</span></span><br><span class="line">  color: <span class="string">'black'</span> | <span class="string">'orange'</span> | <span class="string">'gray'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'dog'</span></span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">  name: <span class="string">'wang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Dog</span></span><br><span class="line"><span class="keyword">type</span> result = LookUp&lt;Cat | Dog, <span class="string">'dog'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-25"><a href="#实现方式-25" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LookUp&lt;</span><br><span class="line">  U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: <span class="built_in">string</span>; &#125;,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: T &#125; ? U : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>U extends { type: string; }</code>：这段代码限制<code>U</code>的类型必须是具有属性为<code>type</code>的对象。</li>
<li><code>U extends { type: T }</code>：如果把<code>T</code>的值实际带入，为<code>U extends { type: &#39;dog&#39; }</code>，表示判断<code>U</code>中的<code>type</code>值是不是<code>dog</code>，是则返回<code>U</code>。</li>
</ul>
<h3 id="Trim、TrimLeft以及TrimRight"><a href="#Trim、TrimLeft以及TrimRight" class="headerlink" title="Trim、TrimLeft以及TrimRight"></a>Trim、TrimLeft以及TrimRight</h3><p>TrimLeft：<link-and-solution num="106"><br>TrimRight：<link-and-solution num="4803"><br>Trim：<link-and-solution num="108"></link-and-solution></link-and-solution></link-and-solution></p>
<h4 id="用法-26"><a href="#用法-26" class="headerlink" title="用法"></a>用法</h4><p><code>Trim</code>、<code>TrimLeft</code>以及<code>TrimRight</code>这几个工具比较好理解，它们都是用来移除字符串中的空白符的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = TrimLeft&lt;<span class="string">' str'</span>&gt;  <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t2 = Trim&lt;<span class="string">' str '</span>&gt;     <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t3 = TrimRight&lt;<span class="string">'str '</span>&gt; <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-26"><a href="#实现方式-26" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">' '</span> | <span class="string">'\n'</span> | <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? TrimLeft&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> (<span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> | <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span>) ? Trim&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> TrimRight&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span> ? TrimRight&lt;R&gt; : S</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>TrimLeft</code>和<code>TrimRight</code>的实现思路是相同的，区别在于空白符的占位出现在左侧还是右侧。</li>
<li><code>Trim</code>的实现就是把<code>TrimLeft</code>和<code>TrimRight</code>所做的事情结合起来。</li>
</ul>
<h3 id="Capitalize-首字母大写-和UnCapitalize-首字母小写"><a href="#Capitalize-首字母大写-和UnCapitalize-首字母小写" class="headerlink" title="Capitalize(首字母大写)和UnCapitalize(首字母小写)"></a>Capitalize(首字母大写)和UnCapitalize(首字母小写)</h3><p><link-and-solution num="110"></link-and-solution></p>
<h4 id="用法-27"><a href="#用法-27" class="headerlink" title="用法"></a>用法</h4><p><code>Capitalize</code>是用来将一个字符串的首字母变成大写的，而<code>UnCapitalize</code>所做的事情跟它相反，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = Capitalize&lt;<span class="string">'hello'</span>&gt;   <span class="comment">// 'Hello'</span></span><br><span class="line"><span class="keyword">type</span> t2 = UnCapitalize&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-27"><a href="#实现方式-27" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br><span class="line"><span class="keyword">type</span> UnCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li>无论是<code>Capitalize</code>还是<code>UnCapitalize</code>，它们都依赖内置的工具函数<code>Uppercase</code>或者<code>Lowercase</code>。对于<code>Capitalize</code>而言，我们只需要把首字母隔离出来，然后调用<code>Uppercase</code>即可。对于<code>UnCapitalize</code>而言，我们把首字母调用<code>Lowercase</code>即可。</li>
</ul>
<h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><p><link-and-solution num="116"></link-and-solution></p>
<h4 id="用法-28"><a href="#用法-28" class="headerlink" title="用法"></a>用法</h4><p><code>Replace</code>是用来将字符串中第一次出现的某段内容，使用指定的字符串进行替换，而<code>ReplaceAll</code>是全部替换，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：'foofoobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： foobarbar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">''</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-28"><a href="#实现方式-28" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure>
<h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><p><link-and-solution num="119"></link-and-solution></p>
<h4 id="用法-29"><a href="#用法-29" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceAll</code>是用来将字符串中指定字符全部替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'foofoofoo'</span></span><br><span class="line"><span class="keyword">type</span> t = ReplaceAll&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-29"><a href="#实现方式-29" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceAll&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;ReplaceAll&lt;L, <span class="keyword">from</span>, to&gt;&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;ReplaceAll&lt;R, <span class="keyword">from</span>, to&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure>
<h3 id="AppendArgument-追加参数"><a href="#AppendArgument-追加参数" class="headerlink" title="AppendArgument(追加参数)"></a>AppendArgument(追加参数)</h3><p><link-and-solution num="191"></link-and-solution></p>
<h4 id="用法-30"><a href="#用法-30" class="headerlink" title="用法"></a>用法</h4><p><code>AppendArgument</code>是用来向一个函数追加一个参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结果：(a: number, b: number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> result = AppendArgument&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-30"><a href="#实现方式-30" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendArgument&lt;Fn, A&gt; = Fn <span class="keyword">extends</span> (...args: infer R) =&gt; infer T ? <span class="function">(<span class="params">...args: [...R, A]</span>) =&gt;</span> T : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li>我们首先利用<code>infer</code>关键词得到了<code>Fn</code>函数的参数类型以及返回类型，然后把新的参数添加到参数列表，并原样返回其函数类型。</li>
</ul>
<h3 id="Permutation-排列组合"><a href="#Permutation-排列组合" class="headerlink" title="Permutation(排列组合)"></a>Permutation(排列组合)</h3><p><link-and-solution num="296"></link-and-solution></p>
<h4 id="用法-31"><a href="#用法-31" class="headerlink" title="用法"></a>用法</h4><p><code>Permutation</code>是用来将联合类型中的每一个类型进行排列组合，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['A', 'B'] | ['B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result1 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result2 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-31"><a href="#实现方式-31" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Permutation&lt;T, U = T&gt; = </span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [T, ...Permutation&lt;Exclude&lt;U, T&gt;&gt;]</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>[T] extends [never]</code>：这段代码主要是为了处理联合类型为空的情况。</li>
<li><code>T extends U</code>：这段代码主要是需要使用<strong>分布式条件类型</strong>这个知识点，当<code>T extends U</code>成立时，在其后的判断语句中，<code>T</code>代表当前迭代的类型。</li>
<li><code>&lt;Exclude&lt;U, T&gt;</code>：因为此时的<code>T</code>代表当前迭代的类型，所以我们从原始联合类型中排除当前类型，然后递归调用<code>Permutation</code>。当<code>T</code>为<code>A</code>时，递归调用<code>Permutation&lt;&#39;B&#39; | &#39;C&#39;&gt;</code>, 此时结果为<code>[&#39;A&#39;]</code> + <code>[&#39;B&#39;, &#39;C&#39;]</code> 或 <code>[&#39;A&#39;]</code> + <code>[&#39;C&#39;, &#39;B&#39;]</code>。</li>
</ul>
<h3 id="LengthOfString-字符串的长度"><a href="#LengthOfString-字符串的长度" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="298"></link-and-solution></p>
<h4 id="用法-32"><a href="#用法-32" class="headerlink" title="用法"></a>用法</h4><p><code>LengthOfString</code>是用来计算一个字符串长度的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-32"><a href="#实现方式-32" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;R, [...T, Char]&gt;</span><br><span class="line">      : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li>我们通过一个泛型的辅助数组来帮计算字符串的长度，在第一次符合条件时，将其第一个字符添加到数组中，在后续的递归过程中，如果不符合条件，直接返回<code>T[&#39;length&#39;]</code>，这个过程可以用如下代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>], S = <span class="string">'hello'</span>, R = <span class="string">'ello'</span></span><br><span class="line"><span class="comment">// 第二次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>], S = <span class="string">'ello'</span>, R = <span class="string">'llo'</span></span><br><span class="line"><span class="comment">// 第三次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>], S = <span class="string">'llo'</span>, R = <span class="string">'lo'</span></span><br><span class="line"><span class="comment">// 第四次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>], S = <span class="string">'lo'</span>, R = <span class="string">'o'</span></span><br><span class="line"><span class="comment">// 第五次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>, <span class="string">'o'</span>], S = <span class="string">'o'</span>, R = <span class="string">''</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Flatten-数组降维"><a href="#Flatten-数组降维" class="headerlink" title="Flatten(数组降维)"></a>Flatten(数组降维)</h3><p><link-and-solution num="459"></link-and-solution></p>
<h4 id="用法-33"><a href="#用法-33" class="headerlink" title="用法"></a>用法</h4><p><code>Flatten</code>是用来将多维数组进行降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Flatten&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>]]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-33"><a href="#实现方式-33" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer L, ...infer R]</span><br><span class="line">      ? L <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">        ? [...Flatten&lt;L&gt;, ...Flatten&lt;R&gt;]</span><br><span class="line">        : [L, ...Flatten&lt;R&gt;]</span><br><span class="line">      : []</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>Flatten</code>数组降维的主要思路是，遍历数组中的每一个元素，判断其是否为一个数组，如果是，则递归调用<code>Flatten</code>，进行降维。</p>
<h3 id="AppendToObject-对象添加新属性"><a href="#AppendToObject-对象添加新属性" class="headerlink" title="AppendToObject(对象添加新属性)"></a>AppendToObject(对象添加新属性)</h3><p><link-and-solution num="527"></link-and-solution></p>
<h4 id="用法-34"><a href="#用法-34" class="headerlink" title="用法"></a>用法</h4><p><code>AppendToObject</code>是用来向指定对象添加一个额外的属性(<code>key/value</code>)，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = AppendToObject&lt;&#123; id: <span class="built_in">number</span>; &#125;, <span class="string">'name'</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-34"><a href="#实现方式-34" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> basicKeyType = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line"><span class="keyword">type</span> AppendToObject&lt;T, K <span class="keyword">extends</span> basicKeyType, V&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T | K]: P <span class="keyword">extends</span> keyof T ? T[P] : V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>basicKeyType</code>：在<code>JavaScript</code>中，因为一个对象的属性只能是<code>string</code>、<code>number</code>或者<code>symbol</code>这三种类型，所以我们限定<code>K</code>必须满足此条件。</li>
<li><code>keyof T | K</code>：这里表示<code>keyof T</code>的联合类型和<code>K</code>，组合成一个新的联合类型。</li>
</ul>
<h3 id="Absolute-绝对值"><a href="#Absolute-绝对值" class="headerlink" title="Absolute(绝对值)"></a>Absolute(绝对值)</h3><p><link-and-solution num="529"></link-and-solution></p>
<h4 id="用法-35"><a href="#用法-35" class="headerlink" title="用法"></a>用法</h4><p><code>Absolute</code>是用来取一个数的绝对值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1："531"</span></span><br><span class="line"><span class="keyword">type</span> result1 = Absolute&lt;<span class="number">-531</span>&gt;</span><br><span class="line"><span class="comment">// 结果2："9999"</span></span><br><span class="line"><span class="keyword">type</span> result2 = Absolute&lt;<span class="number">9</span>_999n&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-35"><a href="#实现方式-35" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberLike = <span class="built_in">number</span> | <span class="built_in">string</span> | bigint</span><br><span class="line"><span class="keyword">type</span> Absolute&lt;T <span class="keyword">extends</span> NumberLike&gt; =  <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`-<span class="subst">$&#123;infer N&#125;</span>`</span> ? N : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>NumberLike</code>：我们认为<code>&#39;1&#39;</code>和<code>1</code>都是一个合法的数字，所以定义一个辅助的<code>NumberList</code>联合类型。</li>
<li><code>${T}</code> extends <code>-${infer N}</code>：这里判断我们传递的数字是否为负数，如果是则直接取其正数部分，否则直接返回。</li>
</ul>
<p><strong>注意</strong>：这里说到的取绝对值，最后的结果之所以是一个字符串类型，是因为<code>TS</code>对递归次数有限制。如果你想要真正的数字类型，可以考虑实现一个<code>MakeArray</code>辅助方法，使用此方法可以将字符串类型的数字，转换成一个真正的数字类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; =</span><br><span class="line">  N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span></span><br><span class="line">  ? T</span><br><span class="line">  : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = MakeArray&lt;<span class="string">'3'</span>&gt;[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="StringToArray-字符串转数组"><a href="#StringToArray-字符串转数组" class="headerlink" title="StringToArray(字符串转数组)"></a>StringToArray(字符串转数组)</h3><blockquote>
<p>tip<br>此题不属于type-challenges类型挑战题</p>
</blockquote>
<h4 id="用法-36"><a href="#用法-36" class="headerlink" title="用法"></a>用法</h4><p><code>StringToArray</code>是用来将一个字符串转换成一个数组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToArray&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-36"><a href="#实现方式-36" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToArray&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? StringToArray&lt;R, [...U, Char]&gt;</span><br><span class="line">      : U</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>StringToArray</code>的实现主要是使用了递归的思想，它每次拿到字符串中一个字符，然后存入一个辅助数组中，当字符串为空时，直接返回这个辅助数组。</p>
<h3 id="StringToUnion-字符串转联合类型"><a href="#StringToUnion-字符串转联合类型" class="headerlink" title="StringToUnion(字符串转联合类型)"></a>StringToUnion(字符串转联合类型)</h3><p><link-and-solution num="531"></link-and-solution></p>
<h4 id="用法-37"><a href="#用法-37" class="headerlink" title="用法"></a>用法</h4><p>在实现<code>StringToArray</code>后，我们能够很容易实现<code>StringToUnion</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'h' | 'e' | 'l' | 'l' | 'o'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-37"><a href="#实现方式-37" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 递归思想</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? Char | StringToUnion&lt;R&gt;</span><br><span class="line">      : never</span><br><span class="line"><span class="comment">// way2: 借用StringToArray</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = StringToArray&lt;S&gt;[<span class="built_in">number</span>]</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>StringToArray&lt;S&gt;</code>返回的是一个数组，<code>T[number]</code>表示对一个数组进行数字类型索引迭代，其迭代结果是每个元素组合成的一个联合类型。</p>
<h3 id="Merge-类型合并"><a href="#Merge-类型合并" class="headerlink" title="Merge(类型合并)"></a>Merge(类型合并)</h3><p><link-and-solution num="599"></link-and-solution></p>
<h4 id="用法-38"><a href="#用法-38" class="headerlink" title="用法"></a>用法</h4><p><code>Merge</code>是用来合并两个类型，如果有重复的字段类型，则第二个的字段类型覆盖第一个的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">  c: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Merge&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-38"><a href="#实现方式-38" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Merge&lt;F, S&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof F | keyof S]: P <span class="keyword">extends</span> keyof S ? S[P] : P <span class="keyword">extends</span> keyof F ? F[P] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>keyof F | keyof S</code>：这段代码的含义是将<code>F</code>和<code>S</code>这两个对象的键组合成一个新的联合类型。</li>
<li><code>P extends</code>：这里进行了两次<code>extends</code>判断，其中第二次不能直接写成<code>F[P]</code>，而应该多判断一次，当满足条件时才使用<code>F[P]</code>，这是因为<code>P</code>的类型判断无法作用于<code>:</code>符号后面。</li>
</ul>
<h3 id="KebabCase-字符串转连字符"><a href="#KebabCase-字符串转连字符" class="headerlink" title="KebabCase(字符串转连字符)"></a>KebabCase(字符串转连字符)</h3><p><link-and-solution num="612"></link-and-solution></p>
<h4 id="用法-39"><a href="#用法-39" class="headerlink" title="用法"></a>用法</h4><p><code>KebabCase</code>是用来将驼峰形式字符串，转成连字符形式字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：foo-bar-baz</span></span><br><span class="line"><span class="keyword">type</span> result = KebabCase&lt;<span class="string">'FooBarBaz'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-39"><a href="#实现方式-39" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KebabCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? S2 <span class="keyword">extends</span> Uncapitalize&lt;S2&gt;</span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span><span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span>-<span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure>
<h3 id="Diff-类型差异部分"><a href="#Diff-类型差异部分" class="headerlink" title="Diff(类型差异部分)"></a>Diff(类型差异部分)</h3><p><link-and-solution num="645"></link-and-solution></p>
<h4 id="用法-40"><a href="#用法-40" class="headerlink" title="用法"></a>用法</h4><p><code>Diff</code>是用来获取两个类型的不同部分的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; id: number; gender: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Diff&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-40"><a href="#实现方式-40" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiffKeys&lt;T, U&gt; = Exclude&lt;keyof T | keyof U, keyof (T | U)&gt;</span><br><span class="line"><span class="keyword">type</span> Diff&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> DiffKeys&lt;T, U&gt;]: K <span class="keyword">extends</span> keyof T ? T[K] : K <span class="keyword">extends</span> keyof U ? U[K] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>keyof Foo | keyof Bar</code>：这段代码是把<code>T</code>和<code>U</code>中的所有属性组合成一个新的联合类型。</li>
<li><code>keyof (T | U)</code>：这段代码是取<code>T</code>和<code>U</code>的公共属性。</li>
<li><code>Exclude&lt;K1, K2&gt;</code>：这段代码主要是用来从<code>K1</code>中排除<code>K2</code>，带入以上例子也就是排除掉所有公共属性。</li>
<li><code>Diff&lt;T, U&gt;</code>：在获取到<code>DiffKeys</code>后，就可以迭代的方式获取到每个属性<code>key</code>，它所对应的类型了。</li>
<li><code>K extends keyof U</code>：额外再判断一次，是因为<code>K</code>不能在三元表达式右侧使用。</li>
</ul>
<h3 id="AnyOf-数组元素真值判断"><a href="#AnyOf-数组元素真值判断" class="headerlink" title="AnyOf(数组元素真值判断)"></a>AnyOf(数组元素真值判断)</h3><p><link-and-solution num="949"></link-and-solution></p>
<h4 id="用法-41"><a href="#用法-41" class="headerlink" title="用法"></a>用法</h4><p><code>AnyOf</code>用来判断数组元素真假值的，如果任一值为真，返回<code>true</code>；数组为空或者全部为<code>false</code>，才返回<code>false</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AnyOf&lt;[<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>, &#123; name: <span class="string">'name'</span> &#125;]&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AnyOf&lt;[<span class="number">0</span>, <span class="string">''</span>, <span class="literal">false</span>, [], &#123;&#125;]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-41"><a href="#实现方式-41" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FalsyType = <span class="number">0</span> | <span class="string">''</span> | <span class="literal">false</span> | <span class="literal">undefined</span> | <span class="literal">null</span> | [] | &#123; [key: <span class="built_in">string</span>]: never &#125;</span><br><span class="line"><span class="keyword">type</span> AnyOf&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> FalsyType ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>代码详解：因为我们就是要区分<code>true/false</code>，所以我们把所有为<code>false</code>的值全部列举出来，然后使用<code>T[number]</code>索引迭代，依次去跟<code>FalsyType</code>比较，其中<code>{ [key: string]: never }</code>表示空对象<code>{}</code>。</p>
<h3 id="IsNever-是否是Never类型"><a href="#IsNever-是否是Never类型" class="headerlink" title="IsNever(是否是Never类型)"></a>IsNever(是否是Never类型)</h3><p><link-and-solution num="1042"></link-and-solution></p>
<h4 id="用法-42"><a href="#用法-42" class="headerlink" title="用法"></a>用法</h4><p><code>IsNever</code>是用来判断是否为<code>never</code>类型，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsNever&lt;<span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsNever&lt;never&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result3 = IsNever&lt;never | <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-42"><a href="#实现方式-42" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 类型数组</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = T[] <span class="keyword">extends</span> never[] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 数组值</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way3: 值比较</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = Equal&lt;T, never&gt;</span><br></pre></td></tr></table></figure>
<h3 id="IsUnion-是否联合类型"><a href="#IsUnion-是否联合类型" class="headerlink" title="IsUnion(是否联合类型)"></a>IsUnion(是否联合类型)</h3><p><link-and-solution num="1097"></link-and-solution></p>
<h4 id="用法-43"><a href="#用法-43" class="headerlink" title="用法"></a>用法</h4><p><code>IsUnion</code>是用来判断一个类型是否为联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsUnion&lt;<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;never&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-43"><a href="#实现方式-43" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 排除法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [Exclude&lt;U, T&gt;] <span class="keyword">extends</span> [never]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 正反对比法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; = </span><br><span class="line">  (T <span class="keyword">extends</span> U</span><br><span class="line">    ? U <span class="keyword">extends</span> T</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : unknown</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  ) <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>代码详解：上面的实现虽然代码不多，但可能无法一下子就弄明白，为了更好的理解这种实现方式，我们来看如下两个案例分析：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例一</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step1: <span class="built_in">string</span> | <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step2: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">number</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step3: <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">string</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">true</span></span><br><span class="line">result: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例二</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span></span><br><span class="line">step1: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">step2: [never] <span class="keyword">extends</span> [never] =&gt; <span class="literal">false</span></span><br><span class="line">result: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>根据之前我们学到的<strong>分布式条件类型</strong>知识，<code>T extends U</code>的时候，会把<code>T</code>进行子类型分发。</p>
<p>如案例一的<code>step3</code>、<code>step4</code>，在分发后会把每次迭代的结果联合起来，组合成最终的结果。</p>
<h3 id="ReplaceKeys-类型替换"><a href="#ReplaceKeys-类型替换" class="headerlink" title="ReplaceKeys(类型替换)"></a>ReplaceKeys(类型替换)</h3><p><link-and-solution num="1130"></link-and-solution></p>
<h4 id="用法-44"><a href="#用法-44" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceKeys</code>是用来在一个类型中，使用指定的Y类型来替换已经存在的T类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceKeys&lt;&#123; id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125;, <span class="string">'name'</span>, &#123; name: <span class="built_in">boolean</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-44"><a href="#实现方式-44" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceKeys&lt;U, T, Y&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof U]:</span><br><span class="line">    P <span class="keyword">extends</span> T</span><br><span class="line">      ? P <span class="keyword">extends</span> keyof Y</span><br><span class="line">        ? Y[P]</span><br><span class="line">        : never</span><br><span class="line">      : U[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RemoveIndexSignature-移除索引签名"><a href="#RemoveIndexSignature-移除索引签名" class="headerlink" title="RemoveIndexSignature(移除索引签名)"></a>RemoveIndexSignature(移除索引签名)</h3><p><link-and-solution num="1367"></link-and-solution></p>
<h4 id="用法-45"><a href="#用法-45" class="headerlink" title="用法"></a>用法</h4><p><code>RemoveIndexSignature</code>是用来移除一个类型中的索引签名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  foo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; foo(): void; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = RemoveIndexSignature&lt;Foo&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-45"><a href="#实现方式-45" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckIndexSignature&lt;T, P&gt; = P <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> RemoveIndexSignature&lt;T, K = PropertyKey&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never)] : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><p><code>CheckIndexSignature</code>：因为索引签名有一个特点，为<code>string | number | symbol</code>，所以我们通过<code>P extends T ? true : false</code>形式排除此索引签名。其原理如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooKeys = <span class="built_in">string</span> | <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">example1: T = <span class="string">'foo'</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">false</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">example2: T = <span class="built_in">string</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">true</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">step5: <span class="built_in">boolean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>as xxx</code>：在之前的案例中，我们介绍过<code>as</code>的用法，在这里有<strong>加工</strong>或<strong>再次断言</strong>的意思。在使用<code>in</code>操作符进行迭代时，对每一个<code>P</code>再使用<code>CheckIndexSignature</code>加工一下，如果是索引签名，这里的结果为<code>never</code>，为<code>never</code>时表示跳过当前迭代，进而达到排除索引签名的目的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代 P = 'foo'</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="literal">false</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; P</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代 P = string</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="built_in">boolean</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终结果</span></span><br><span class="line"><span class="keyword">type</span> result = &#123; foo(): <span class="built_in">void</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PercentageParser-百分比解析"><a href="#PercentageParser-百分比解析" class="headerlink" title="PercentageParser(百分比解析)"></a>PercentageParser(百分比解析)</h3><p><link-and-solution num="1978"></link-and-solution></p>
<h4 id="用法-46"><a href="#用法-46" class="headerlink" title="用法"></a>用法</h4><p><code>PercentageParser</code>是用来解析百分比字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = PercentageParser&lt;<span class="string">'+85%'</span>&gt; <span class="comment">// ['+', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result2 = PercentageParser&lt;<span class="string">'-85%'</span>&gt; <span class="comment">// ['-', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result3 = PercentageParser&lt;<span class="string">'85'</span>&gt;   <span class="comment">// ['', '85', '']</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-46"><a href="#实现方式-46" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckPrefix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">'+'</span> | <span class="string">'-'</span> ? S : never</span><br><span class="line"><span class="keyword">type</span> CheckSuffix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>%`</span> ? [L, <span class="string">'%'</span>] : [S, <span class="string">''</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PercentageParser&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;CheckPrefix&lt;infer L&gt;&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? [L, ...CheckSuffix&lt;R&gt;]</span><br><span class="line">    : [<span class="string">''</span>, ...CheckSuffix&lt;S&gt;]</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>CheckPrefix</code>是用来处理百分比字符串前面的符号的，如果存在<code>+</code>或者<code>-</code>，则原样返回，如果不存在则返回<code>never</code>，表示没有符号。</li>
<li><code>CheckSuffix</code>是用来处理百分比字符串后面的百分比符号的，如果存在，则返回一个数组(最后一项固定为百分比符号)；如果不存在，则返回的数组最后一个元素固定为空字符串。</li>
</ul>
<h3 id="DropChar-移除字符"><a href="#DropChar-移除字符" class="headerlink" title="DropChar(移除字符)"></a>DropChar(移除字符)</h3><p><link-and-solution num="2070"></link-and-solution></p>
<h4 id="用法-47"><a href="#用法-47" class="headerlink" title="用法"></a>用法</h4><p><code>DropChar</code>是用来在字符串中移除指定字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：butterfly!</span></span><br><span class="line"><span class="keyword">type</span> result = DropChar&lt;<span class="string">' b u t t e r f l y ! '</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-47"><a href="#实现方式-47" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropChar&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = C <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? DropChar&lt;<span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;R&#125;</span>`</span>, C&gt;</span><br><span class="line">    : S</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>DropChar</code>和<code>ReplaceAll</code>的实现思路非常相似，首先需要判断待移除的字符是不是空字符串，如果是，则直接返回原始字符串；如果不是，先判断字符串中是否包含待移除的字符，包含则递归调用；不包含则直接返回原始字符串。</p>
<h3 id="MinusOne-减一"><a href="#MinusOne-减一" class="headerlink" title="MinusOne(减一)"></a>MinusOne(减一)</h3><p><link-and-solution num="2257"></link-and-solution></p>
<p><code>MinusOne</code>是用来实现数字减一的，其用法如下：</p>
<h4 id="用法-48"><a href="#用法-48" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：99</span></span><br><span class="line"><span class="keyword">type</span> result = MinusOne&lt;<span class="number">100</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-48"><a href="#实现方式-48" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinusOne&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = N <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">  ? T <span class="keyword">extends</span> [infer F, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : never</span><br><span class="line">  : MinusOne&lt;N, [<span class="number">0</span>, ...T]&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：在实现<code>MinusOne</code>的时候，借用了一个空数组，首先判断数组的长度是否等于传递的数字<code>N</code>，如果相等则从数组中随意移除一位，然后返回剩下数组的长度即可；如果不相等，则往数组中添加一个元素，再递归调用<code>MinusOne</code>。</p>
<p><strong>注意</strong>：由于<code>TS</code>在递归调用时存在最大递归调用次数，所以对于比较大的数字会提示错误。</p>
<h3 id="PickByType-根据类型选取"><a href="#PickByType-根据类型选取" class="headerlink" title="PickByType(根据类型选取)"></a>PickByType(根据类型选取)</h3><p><link-and-solution num="2595"></link-and-solution></p>
<h4 id="用法-49"><a href="#用法-49" class="headerlink" title="用法"></a>用法</h4><p><code>PickByType</code>是用来根据类型选取属性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; isReadonly: boolean, isEnable: boolean &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = PickByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-49"><a href="#实现方式-49" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PickByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> U ? P : never]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>PickByType</code>的实现，可以使用<code>as</code>进行第二次断言，当类型满足时就返回当前迭代的<code>P</code>，不满足类型时就返回<code>never</code>，因为<code>never</code>最后会被排除，所以最后的迭代结果只有满足类型的键。</p>
<h3 id="StartsWith-字符串startsWith方法"><a href="#StartsWith-字符串startsWith方法" class="headerlink" title="StartsWith(字符串startsWith方法)"></a>StartsWith(字符串startsWith方法)</h3><p><link-and-solution num="2688"></link-and-solution></p>
<h4 id="用法-50"><a href="#用法-50" class="headerlink" title="用法"></a>用法</h4><p><code>StartsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>startsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = StartsWith&lt;<span class="string">'abc'</span>, <span class="string">'ab'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-50"><a href="#实现方式-50" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StartsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="EndsWith-字符串endsWith方法"><a href="#EndsWith-字符串endsWith方法" class="headerlink" title="EndsWith(字符串endsWith方法)"></a>EndsWith(字符串endsWith方法)</h3><p><link-and-solution num="2693"></link-and-solution></p>
<h4 id="用法-51"><a href="#用法-51" class="headerlink" title="用法"></a>用法</h4><p><code>EndsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>endsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = endsWith&lt;<span class="string">'abc'</span>, <span class="string">'bc'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-51"><a href="#实现方式-51" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EndsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;C&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="PartialByKeys-按需可选"><a href="#PartialByKeys-按需可选" class="headerlink" title="PartialByKeys(按需可选)"></a>PartialByKeys(按需可选)</h3><p><link-and-solution num="2757"></link-and-solution></p>
<h4 id="用法-52"><a href="#用法-52" class="headerlink" title="用法"></a>用法</h4><p><code>PartialByKeys</code>是用来实现按需可选的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> UserPartialName &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserPartialName</span></span><br><span class="line"><span class="keyword">type</span> result = PartialByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-52"><a href="#实现方式-52" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PartialByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>Omit</code>部分：根据之前介绍的<code>Omit</code>的知识，<code>Omit&lt;T, K&gt;</code>表示从<code>T</code>中剔除含有<code>K</code>的类型。</li>
<li><code>CopyKeys</code>部分：如果不使用<code>CopyKeys</code>，最后的结果为<code>T &amp; U</code>形式，它实际上与使用<code>CopyKeys</code>的结果是一样的。这里使用<code>CopyKeys</code>，很大程度上是为了测试。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用CopyKeys，结果为true；不使用，结果为false</span></span><br><span class="line"><span class="keyword">type</span> result1 = Equal&lt;PartialByKeys&lt;User, <span class="string">'name'</span>&gt;, UserPartialName&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RequiredByKeys-按需必填"><a href="#RequiredByKeys-按需必填" class="headerlink" title="RequiredByKeys(按需必填)"></a>RequiredByKeys(按需必填)</h3><p><link-and-solution num="2759"></link-and-solution></p>
<p>在实现<code>PartialByKeys</code>后，很容易按照相同的思路去实现<code>RequiredByKeys</code>。</p>
<h4 id="用法-53"><a href="#用法-53" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredByKeys</code>是用来实现按需必填的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UserRequiredName &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserRequiredName</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-53"><a href="#实现方式-53" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequiredByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]-?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：实现思路参考<code>PartialByKeys</code>。</p>
<h3 id="Mutable-可改"><a href="#Mutable-可改" class="headerlink" title="Mutable(可改)"></a>Mutable(可改)</h3><p><link-and-solution num="2793"></link-and-solution></p>
<h4 id="用法-54"><a href="#用法-54" class="headerlink" title="用法"></a>用法</h4><p><code>Mutable</code>是用来让所有属性变为可改的(移除<code>readonly</code>关键词)，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> MutableResult = MyMutable&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-54"><a href="#实现方式-54" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMutable&lt;T&gt; = &#123;</span><br><span class="line">  -readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解读：</p>
<ul>
<li><code>-readonly</code>：表示把<code>readonly</code>关键词去掉，去掉之后此字段变为可改的。</li>
</ul>
<h3 id="OmitByType-按类型移除"><a href="#OmitByType-按类型移除" class="headerlink" title="OmitByType(按类型移除)"></a>OmitByType(按类型移除)</h3><p><link-and-solution num="2852"></link-and-solution></p>
<p><code>OmitByType</code>的实现思路和<code>PickByType</code>类似。</p>
<h4 id="用法-55"><a href="#用法-55" class="headerlink" title="用法"></a>用法</h4><p><code>OmitByType</code>是用来按照类型移除的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ModelOmitBoolean &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelOmitBoolean</span></span><br><span class="line"><span class="keyword">type</span> result = OmitByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-55"><a href="#实现方式-55" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OmitByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> U <span class="keyword">extends</span> T[P] ? never : P]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解析：实现思路参考<code>PickByType</code>。</p>
<h3 id="ObjectEntries"><a href="#ObjectEntries" class="headerlink" title="ObjectEntries"></a>ObjectEntries</h3><p><link-and-solution num="2946"></link-and-solution></p>
<h4 id="用法-56"><a href="#用法-56" class="headerlink" title="用法"></a>用法</h4><p><code>ObjectEntries</code>是用来实现<code>JavaScript</code>中的<code>Object.entries()</code>方法，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  locations?: <span class="built_in">string</span>[] | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ModelEntries = [<span class="string">'name'</span>, <span class="built_in">string</span>] | [<span class="string">'age'</span>, <span class="built_in">number</span>] | [<span class="string">'locations'</span>, <span class="built_in">string</span>[] | <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelEntries</span></span><br><span class="line"><span class="keyword">type</span> result = ObjectEntries&lt;Model&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-56"><a href="#实现方式-56" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RemoveUndefined&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="literal">undefined</span>] ? T : Exclude&lt;T, <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">type</span> ObjectEntries&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: &#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? [P, RemoveUndefined&lt;T[P]&gt;] : [P, T[P]]</span><br><span class="line">&#125;[keyof T]</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>RemoveUndefined</code>：当<code>T</code>仅为<code>undefined</code>，表示原始类型就是<code>undefined</code>; 当<code>T</code>为联合类型时，移除联合类型中的<code>undefined</code>。</li>
<li><code>[P in keyof T]-?</code>:  表示移除可选属性。</li>
<li><code>{} extends Pick&lt;T, P&gt;</code>: 判断当前的<code>P</code>是否为可选属性，是的话就是使用<code>RemoveUndefined</code>移除其中的<code>undefined</code>，否则取原始类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果都为true</span></span><br><span class="line"><span class="keyword">type</span> result1 = &#123;&#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; name: <span class="built_in">string</span>; &#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Shift-数组shift方法"><a href="#Shift-数组shift方法" class="headerlink" title="Shift(数组shift方法)"></a>Shift(数组shift方法)</h3><p><link-and-solution num="3062"></link-and-solution></p>
<h4 id="用法-57"><a href="#用法-57" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift结果：[2, 3]</span></span><br><span class="line"><span class="keyword">type</span> shiftResult = Shift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-57"><a href="#实现方式-57" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift实现</span></span><br><span class="line"><span class="keyword">type</span> Shift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer F, ...infer R] ? R : []</span><br></pre></td></tr></table></figure>
<h3 id="TupleToNestedObject-元组转嵌套对象"><a href="#TupleToNestedObject-元组转嵌套对象" class="headerlink" title="TupleToNestedObject(元组转嵌套对象)"></a>TupleToNestedObject(元组转嵌套对象)</h3><p><link-and-solution num="3188"></link-and-solution></p>
<h4 id="用法-58"><a href="#用法-58" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToNestedObject</code>是用来将元组转成嵌套对象的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; a: &#123; b: string; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToNestedObject&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-58"><a href="#实现方式-58" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToNestedObject&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">    ? &#123; [P <span class="keyword">in</span> F &amp; <span class="built_in">string</span>]: TupleToNestedObject&lt;R, U&gt; &#125;</span><br><span class="line">    : U</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>F &amp; string</code>: 等价于如下代码：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &amp; <span class="built_in">string</span> = F <span class="keyword">extends</span> <span class="built_in">string</span> ? F : never</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p><link-and-solution num="3192"></link-and-solution></p>
<h4 id="用法-59"><a href="#用法-59" class="headerlink" title="用法"></a>用法</h4><p><code>Reverse</code>是用来实现数组的<code>reverse()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['b', 'a']</span></span><br><span class="line"><span class="keyword">type</span> result = Reverse&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-59"><a href="#实现方式-59" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reverse&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [...infer R, infer L]</span><br><span class="line">    ? [L, ...Reverse&lt;R&gt;]</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure>
<h3 id="FlipArguments-反转函数参数类型"><a href="#FlipArguments-反转函数参数类型" class="headerlink" title="FlipArguments(反转函数参数类型)"></a>FlipArguments(反转函数参数类型)</h3><p><link-and-solution num="3196"></link-and-solution></p>
<p>借助上面的<code>Reverse</code>方法，可以很容易实现函数参数的反转。</p>
<h4 id="用法-60"><a href="#用法-60" class="headerlink" title="用法"></a>用法</h4><p><code>FlipArguments</code>是用来实现反转函数参数类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：(a: number, b: string) =&gt; string | number</span></span><br><span class="line"><span class="keyword">type</span> result = FlipArguments&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-60"><a href="#实现方式-60" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlipArguments&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> (...args: infer A) =&gt; infer R</span><br><span class="line">    ? <span class="function">(<span class="params">...args: Reverse&lt;A&gt;</span>) =&gt;</span> R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure>
<h3 id="FlattenDepth-数组按深度降维"><a href="#FlattenDepth-数组按深度降维" class="headerlink" title="FlattenDepth(数组按深度降维)"></a>FlattenDepth(数组按深度降维)</h3><p><link-and-solution num="3243"></link-and-solution></p>
<h4 id="用法-61"><a href="#用法-61" class="headerlink" title="用法"></a>用法</h4><p><code>FlattenDepth</code>是用来按深度进行数组降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4, [5]]</span></span><br><span class="line"><span class="keyword">type</span> result = FlattenDepth&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[[<span class="number">5</span>]]]], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-61"><a href="#实现方式-61" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlattenDepth&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">1</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? U[<span class="string">'length'</span>] <span class="keyword">extends</span> D</span><br><span class="line">    ? T</span><br><span class="line">    : F <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? [...FlattenDepth&lt;F, D, [<span class="number">0</span>, ...U]&gt;, ...FlattenDepth&lt;R, D&gt;]</span><br><span class="line">      : [F, ...FlattenDepth&lt;R, D, U&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>FlattenDepth</code>的实现思路和<code>Flatten</code>基本一致，区别是按深度降维时需要一个数组去记录降维的次数(深度)。</p>
<h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><link-and-solution num="3326"></link-and-solution></p>
<h4 id="用法-62"><a href="#用法-62" class="headerlink" title="用法"></a>用法</h4><p><code>BEM</code>是用来将字符串连接成CSS BEM格式的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'btn__primary--small' | 'btn__primary--mini' </span></span><br><span class="line"><span class="keyword">type</span> result = BEM&lt;<span class="string">'btn'</span>, [<span class="string">'primary'</span>], [<span class="string">'small'</span>, <span class="string">'mini'</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-62"><a href="#实现方式-62" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArrayToString&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [] ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;T[<span class="built_in">number</span>]&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BEM&lt;</span><br><span class="line">  B <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="built_in">string</span>[],</span><br><span class="line">  M <span class="keyword">extends</span> <span class="built_in">string</span>[]</span><br><span class="line">&gt; = <span class="string">`<span class="subst">$&#123;B&#125;</span><span class="subst">$&#123;ArrayToString&lt;E, <span class="string">'--'</span>&gt;&#125;</span><span class="subst">$&#123;ArrayToString&lt;M, <span class="string">'__'</span>&gt;&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<p>代码详解：实现<code>BEM</code>的思路并不复杂，只需要记住如下两个知识点：</p>
<ul>
<li>判断是一个空数组，可以使用<code>T extends []</code>或者<code>T[&#39;length&#39;] extends 0</code>。</li>
<li><code>T[number]</code>会自动迭代数组，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果: 'A__B' | 'A__C' | 'A__D'</span></span><br><span class="line"><span class="keyword">type</span> result = <span class="string">`A__<span class="subst">$&#123;[<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>][<span class="built_in">number</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="InOrderTraversal-中序遍历"><a href="#InOrderTraversal-中序遍历" class="headerlink" title="InOrderTraversal(中序遍历)"></a>InOrderTraversal(中序遍历)</h3><p><link-and-solution num="3376"></link-and-solution></p>
<p><strong>先序遍历</strong>：<code>PreOrderTraversal</code>先访问根节点，然后访问左节点，最后访问右节点。<br><br><strong>中序遍历</strong>：<code>InOrderTraversal</code>先访问左节点，然后访问根节点，最后访问右节点。<br><br><strong>后序遍历</strong>：<code>PostOrderTraversal</code>先访问左节点，然后访问右节点，最后访问根节点。</p>
<h4 id="用法-63"><a href="#用法-63" class="headerlink" title="用法"></a>用法</h4><p><code>InOrderTraversal</code>是用来实现二叉树中序遍历的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  left: <span class="literal">null</span>,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: <span class="number">3</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: [1, 3, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = InOrderTraversal&lt;<span class="keyword">typeof</span> tree&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-63"><a href="#实现方式-63" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个二叉树节点</span></span><br><span class="line"><span class="keyword">interface</span> TreeNode &#123;</span><br><span class="line">  val: <span class="built_in">number</span>;</span><br><span class="line">  left: TreeNode | <span class="literal">null</span>;</span><br><span class="line">  right: TreeNode | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PreOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [T[<span class="string">'val'</span>], ...PreOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PreOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 中序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> InOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...InOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, T[<span class="string">'val'</span>], ...InOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 后序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PostOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...PostOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PostOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;, T[<span class="string">'val'</span>]]</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><p><code>[T] extends [TreeNode]</code>: 使用此形式而不用<code>T extends TreeNode</code>，这是因为<code>T</code>是一个<code>TreeNode | null</code>，在左侧会进行分布式条件类型，判断两次：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果Tree嵌套比较深的话，ts会报错</span></span><br><span class="line">TreeNode <span class="keyword">extends</span> TreeNode |</span><br><span class="line"><span class="literal">null</span> <span class="keyword">extends</span> TreeNode</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历方式：根据先序遍历<code>PreOrderTraversal</code>、中序遍历<code>InOrderTraversal</code>、后序遍历<code>PostOrderTraversal</code>的定义，只需要在递归的时候处理其访问顺序即可。</p>
</li>
</ul>
<h3 id="FlipObject-对象键值交换"><a href="#FlipObject-对象键值交换" class="headerlink" title="FlipObject(对象键值交换)"></a>FlipObject(对象键值交换)</h3><p><link-and-solution num="4179"></link-and-solution></p>
<h4 id="用法-64"><a href="#用法-64" class="headerlink" title="用法"></a>用法</h4><p><code>FlipObject</code>是用来将对象的键值交换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; pi: 'a' &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = FlipObject&lt;&#123; a: <span class="string">'pi'</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-64"><a href="#实现方式-64" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> FlipObject&lt;T <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, BasicType&gt;&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;T[P]&#125;</span>`</span>]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fibonacci-斐波那契数列"><a href="#Fibonacci-斐波那契数列" class="headerlink" title="Fibonacci(斐波那契数列)"></a>Fibonacci(斐波那契数列)</h3><p><link-and-solution num="4182"></link-and-solution></p>
<p><strong>菲波那切数列</strong>：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…</p>
<h4 id="用法-65"><a href="#用法-65" class="headerlink" title="用法"></a>用法</h4><p><code>Fibonacci</code>是用来实现斐波那契数列的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = Fibonacci&lt;<span class="number">5</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-65"><a href="#实现方式-65" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fibonacci&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>],</span><br><span class="line">  Prev <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Current <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>]</span><br><span class="line">&gt; = Index[<span class="string">'length'</span>] <span class="keyword">extends</span> N</span><br><span class="line">  ? Current[<span class="string">'length'</span>]</span><br><span class="line">  : Fibonacci&lt;N, [...Index, <span class="number">1</span>], Current, [...Prev, ...Current]&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>Index</code>：标记当前数列是第几项，从1开始。</li>
<li><code>Prev</code>：存储数列上一次计算的值，从0开始。</li>
<li><code>Current</code>: 标记当前数列的值，根据数列的特点，第N项的值，等于<code>N - 1</code>项 + <code>N - 2</code>项的值，即：<code>Current = [...Prev, ...Current]</code></li>
</ul>
<h3 id="AllCombinations-全排列"><a href="#AllCombinations-全排列" class="headerlink" title="AllCombinations(全排列)"></a>AllCombinations(全排列)</h3><p><link-and-solution num="4260"></link-and-solution></p>
<h4 id="用法-66"><a href="#用法-66" class="headerlink" title="用法"></a>用法</h4><p><code>AllCombinations</code>是用来列举全部排列组合可能性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'' | 'A' | 'AB' | 'B' | 'BA'</span></span><br><span class="line"><span class="keyword">type</span> result = AllCombinations&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-66"><a href="#实现方式-66" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? F | StringToUnion&lt;R&gt;</span><br><span class="line">    : never</span><br><span class="line"><span class="keyword">type</span> Combination&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span>,</span><br><span class="line">  K = S</span><br><span class="line">&gt; = [S] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? U</span><br><span class="line">  : K <span class="keyword">extends</span> S</span><br><span class="line">    ? Combination&lt;Exclude&lt;S, K&gt;, U | <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;K&#125;</span>`</span>&gt;</span><br><span class="line">    : U</span><br><span class="line"><span class="keyword">type</span> AllCombinations&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Combination&lt;StringToUnion&lt;S&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><p><code>StringToUnion</code>是用来将字符串变成一个联合类型的，例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 'A' | 'B'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Combination</code>是用来将联合类型进行排列组合的，以以上<code>&#39;A&#39; | &#39;B&#39;</code>这个联合类型为例，步骤如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：从'A' | 'B这个联合类型中排除当前迭代的字符'A'</span></span><br><span class="line">K = <span class="string">'A'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span>  =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'A'</span>&gt;</span><br><span class="line"><span class="comment">// 第一步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'B'</span>, <span class="string">''</span> | <span class="string">'A'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'A'</span>&#125;</span>B`</span> =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'AB'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：从'A' | 'B'这个联合类型中排除当前迭代的字符'B'</span></span><br><span class="line">K = <span class="string">'B'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span> =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 第二步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'A'</span>, <span class="string">''</span> | <span class="string">'B'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'B'</span>&#125;</span>A`</span> =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">'A'</span> | <span class="string">'BA'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：剔除相同元素</span></span><br><span class="line">result = <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'AB'</span> | <span class="string">'B'</span> | <span class="string">'BA'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GreaterThan-大于"><a href="#GreaterThan-大于" class="headerlink" title="GreaterThan(大于)"></a>GreaterThan(大于)</h3><p><link-and-solution num="4425"></link-and-solution></p>
<h4 id="用法-67"><a href="#用法-67" class="headerlink" title="用法"></a>用法</h4><p><code>GreaterThan&lt;T, N&gt;</code>是来用判断正整数T是否大于正整数N的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = GreaterThan&lt;<span class="number">2</span>, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-67"><a href="#实现方式-67" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果比较的数比较大，会提示：Type instantiation is excessively deep and possibly infinite</span></span><br><span class="line"><span class="keyword">type</span> GreaterThan&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : N <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : GreaterThan&lt;T, N, [...R, <span class="number">0</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：使用一个空数组来辅助，每次递归添加一个元素，如果正整数<code>T</code>先等于这个数组的长度，则为<code>false</code>；如果正整数<code>N</code>先等于这个数组的长度，则为<code>true</code>。</p>
<h3 id="Zip-按位置匹配"><a href="#Zip-按位置匹配" class="headerlink" title="Zip(按位置匹配)"></a>Zip(按位置匹配)</h3><p><link-and-solution num="4471"></link-and-solution></p>
<h4 id="用法-68"><a href="#用法-68" class="headerlink" title="用法"></a>用法</h4><p><code>Zip</code>是用来将两个元组按照相同索引位置组合成一个新数组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, true], [2, false]]</span></span><br><span class="line"><span class="keyword">type</span> result = Zip&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="literal">true</span>, <span class="literal">false</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-68"><a href="#实现方式-68" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zip&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? U <span class="keyword">extends</span> [infer Head, ...infer Tail]</span><br><span class="line">      ? [[First, Head], ...Zip&lt;Rest, Tail&gt;]</span><br><span class="line">      : []</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure>
<h3 id="IsTuple-是否为元组"><a href="#IsTuple-是否为元组" class="headerlink" title="IsTuple(是否为元组)"></a>IsTuple(是否为元组)</h3><p><link-and-solution num="4484"></link-and-solution></p>
<h4 id="用法-69"><a href="#用法-69" class="headerlink" title="用法"></a>用法</h4><p><code>IsTuple</code>是用来判断是否为一个元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = IsTuple&lt;[<span class="built_in">number</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-69"><a href="#实现方式-69" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsTuple&lt;T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">      ? <span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>代码解析：以上代码中，比较关键的代码是<code>number extends T[&#39;length&#39;]</code>，这里不能写成<code>T[&#39;length&#39;] extends number</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1：需要返回false，因为它不定长，违反了元组的定义</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsTuple&lt;<span class="built_in">number</span>[]&gt;</span><br><span class="line"><span class="comment">// case2：需要返回true，因为它定长，只不过长度为0</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsTuple&lt;[]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case1计算逻辑，T['length']返回的是number，不是一个确定的值</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2计算逻辑，T['length']返回的是0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">=&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Chunk-lodash分割数组"><a href="#Chunk-lodash分割数组" class="headerlink" title="Chunk(lodash分割数组)"></a>Chunk(lodash分割数组)</h3><p><link-and-solution num="4499"></link-and-solution></p>
<p><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash Chunk</a>: 将一个数组分割成长度为N的多个小数组。</p>
<h4 id="用法-70"><a href="#用法-70" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, 2], [3, 4]]</span></span><br><span class="line"><span class="keyword">type</span> result = Chunk&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-70"><a href="#实现方式-70" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chunk&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  Size <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> Size</span><br><span class="line">  ? [R, ...Chunk&lt;T, Size&gt;]</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Chunk&lt;L, Size, [...R, F]&gt;</span><br><span class="line">    : R[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? []</span><br><span class="line">      : [R]</span><br></pre></td></tr></table></figure>
<p>代码详解：实现<code>Chunk</code>大体思路是：借助一个辅助空数组，在遍历数组时往这个辅助数组中添加元素，一直到等于指定长度，然后进行下一次相同操作。</p>
<h3 id="Fill-数组fill方法"><a href="#Fill-数组fill方法" class="headerlink" title="Fill(数组fill方法)"></a>Fill(数组fill方法)</h3><p><link-and-solution num="4518"></link-and-solution></p>
<h4 id="用法-71"><a href="#用法-71" class="headerlink" title="用法"></a>用法</h4><p><code>Fill</code>是用来在一个数组中，用指定元素，替换开始索引和结束索引元素的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-71"><a href="#实现方式-71" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fill&lt;</span><br><span class="line">  T <span class="keyword">extends</span> unknown[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Start <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">0</span>,</span><br><span class="line">  End <span class="keyword">extends</span> <span class="built_in">number</span> = T[<span class="string">'length'</span>],</span><br><span class="line">  Count <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Flag <span class="keyword">extends</span> <span class="built_in">boolean</span> = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> Start ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> End</span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Flag <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">      ? [F, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>]&gt;]</span><br><span class="line">      : [N, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>], <span class="literal">true</span>&gt;]</span><br><span class="line">    : T</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>Count</code>: 遍历标志位，从数组第一项开始，当等于<code>End</code>时，结束替换。</li>
<li><code>Flag</code>：遍历标志位，从数组第一项开始，当等于<code>Start</code>是，开始替换。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次遍历 Count = [], Flag = false, T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 满足Flag extends false条件，Count = [0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次遍历 Count = [0], Flag = true(计算而言)，T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0], T = [1, true, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次遍历 Count = [0, 0], Flag = true(主动传递), T =[1, true, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0, 0], T = [1, true, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次判断 Count = [0, 0, 0]，长度等于End，结束，T = [1, true, true]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Without-移除"><a href="#Without-移除" class="headerlink" title="Without(移除)"></a>Without(移除)</h3><p><link-and-solution num="5117"></link-and-solution></p>
<h4 id="用法-72"><a href="#用法-72" class="headerlink" title="用法"></a>用法</h4><p><code>Without</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[3]</span></span><br><span class="line"><span class="keyword">type</span> result = Without&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-72"><a href="#实现方式-72" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToUnion&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T</span><br><span class="line"><span class="keyword">type</span> Without&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  U = ToUnion&lt;F&gt;,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? First <span class="keyword">extends</span> U</span><br><span class="line">      ? Without&lt;Rest, F, U, [...R]&gt;</span><br><span class="line">      : Without&lt;Rest, F, U, [...R, First]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure>
<p>代码详解：因为<code>F</code>支持单数字和数组，所以定义一个<code>ToUion</code>来统一处理成联合类型。随后直接遍历数组，如果当前迭代的元素在联合类型中，则直接跳过进行下一次迭代；否则，把当前迭代元素添加到<code>R</code>辅助数组中。</p>
<h3 id="Trunc-Math-trunc取整"><a href="#Trunc-Math-trunc取整" class="headerlink" title="Trunc(Math.trunc取整)"></a>Trunc(Math.trunc取整)</h3><p><link-and-solution num="5140"></link-and-solution></p>
<h4 id="用法-73"><a href="#用法-73" class="headerlink" title="用法"></a>用法</h4><p><code>Trunc</code>是用来实现<code>Math.trunc()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：100</span></span><br><span class="line"><span class="keyword">type</span> result1 = Trunc&lt;<span class="number">100.32</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：0</span></span><br><span class="line"><span class="keyword">type</span> result2 = Trunc&lt;<span class="number">.3</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-73"><a href="#实现方式-73" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trunc&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">&gt; =<span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>.<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">  ? L <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">    ? <span class="string">'0'</span></span><br><span class="line">    : L</span><br><span class="line">  : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h3 id="IndexOf-数组indexOf方法"><a href="#IndexOf-数组indexOf方法" class="headerlink" title="IndexOf(数组indexOf方法)"></a>IndexOf(数组indexOf方法)</h3><p><link-and-solution num="5153"></link-and-solution></p>
<h4 id="用法-74"><a href="#用法-74" class="headerlink" title="用法"></a>用法</h4><p><code>IndexOf</code>是用来实现数组<code>indexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2</span></span><br><span class="line"><span class="keyword">type</span> result = IndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-74"><a href="#实现方式-74" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;U, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Index[<span class="string">'length'</span>]</span><br><span class="line">    : IndexOf&lt;Rest, U, [...Index, <span class="number">0</span>]&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>代码详解：需要借助<code>IsEqual</code>来判断两个值是否相等，原因考虑如下案例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsEqual&lt;<span class="number">1</span>, <span class="built_in">number</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsEqual&lt;<span class="string">'a'</span>, <span class="built_in">string</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Join-数组join方法"><a href="#Join-数组join方法" class="headerlink" title="Join(数组join方法)"></a>Join(数组join方法)</h3><p><link-and-solution num="5310"></link-and-solution></p>
<h4 id="用法-75"><a href="#用法-75" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现数组<code>join</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a-p-p-l-e'</span></span><br><span class="line"><span class="keyword">type</span> result = Join&lt;[<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'p'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>], <span class="string">'-'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-75"><a href="#实现方式-75" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Join&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      : Join&lt;Rest, U, <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span>&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure>
<h3 id="LastIndexOf-数组lastIndexOf方法"><a href="#LastIndexOf-数组lastIndexOf方法" class="headerlink" title="LastIndexOf(数组lastIndexOf方法)"></a>LastIndexOf(数组lastIndexOf方法)</h3><p><link-and-solution num="5317"></link-and-solution></p>
<p>借助<code>IndexOf</code>的实现思路，很容易实现<code>lastIndexOf</code>方法。</p>
<h4 id="用法-76"><a href="#用法-76" class="headerlink" title="用法"></a>用法</h4><p><code>LastIndexOf</code>是用来实现数组<code>lastIndexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = LastIndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-76"><a href="#实现方式-76" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> LastIndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[], </span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [...infer Rest, infer Last]</span><br><span class="line">  ? IsEqual&lt;Last, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : LastIndexOf&lt;Rest, U&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Unique-数组去重"><a href="#Unique-数组去重" class="headerlink" title="Unique(数组去重)"></a>Unique(数组去重)</h3><p><link-and-solution num="5360"></link-and-solution></p>
<h4 id="用法-77"><a href="#用法-77" class="headerlink" title="用法"></a>用法</h4><p><code>Unique</code>是用来实现数组去重的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unique&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-77"><a href="#实现方式-77" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>IsEqual</code>和<code>Includes</code>，很容易实现<code>Unique</code>数组去重。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> Includes&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;Last, U&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unique&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Includes&lt;R, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Unique&lt;Last, R&gt;</span><br><span class="line">    : Unique&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure></p>
<h3 id="MapTypes-类型转换"><a href="#MapTypes-类型转换" class="headerlink" title="MapTypes(类型转换)"></a>MapTypes(类型转换)</h3><p><link-and-solution num="5821"></link-and-solution></p>
<h4 id="用法-78"><a href="#用法-78" class="headerlink" title="用法"></a>用法</h4><p><code>MapTypes</code>是用来根据指定类型进行替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; type: number; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MapTypes&lt;&#123; <span class="keyword">type</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;, &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-78"><a href="#实现方式-78" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMapType&lt;</span><br><span class="line">  T, </span><br><span class="line">  R,</span><br><span class="line">  Type = R <span class="keyword">extends</span> &#123; mapFrom: T, mapTo: infer To &#125; ? To : never</span><br><span class="line">&gt; = [Type] <span class="keyword">extends</span> [never] ? T : Type</span><br><span class="line"><span class="keyword">type</span> MapTypes&lt;T, R&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: GetMapType&lt;T[P], R&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：在以上的实现中，最核心的代码是获取<code>Type</code>类型。</p>
<ul>
<li><code>R extends { mapFrom: T, mapTo: infer To }</code>：这段代码表示，<code>R</code>是不是右边的子类型，我们以以上案例来说明：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当P = 'type'时，</span></span><br><span class="line">T[P] = <span class="built_in">string</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">string</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; To = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; <span class="keyword">type</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当P = 'age'时</span></span><br><span class="line">T[P] = <span class="built_in">number</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">number</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; never</span><br><span class="line">=&gt; GetMapType&lt;T[P], R&gt; = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; age: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ConstructTuple-构造元组"><a href="#ConstructTuple-构造元组" class="headerlink" title="ConstructTuple(构造元组)"></a>ConstructTuple(构造元组)</h3><p><link-and-solution num="7544"></link-and-solution></p>
<h4 id="用法-79"><a href="#用法-79" class="headerlink" title="用法"></a>用法</h4><p><code>ConstructTuple</code>是用来构造指定长度的元组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[unknown, unknown]</span></span><br><span class="line"><span class="keyword">type</span> result = ConstructTuple&lt;<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-79"><a href="#实现方式-79" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConstructTuple&lt;</span><br><span class="line">  L <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> L</span><br><span class="line">  ? R</span><br><span class="line">  : ConstructTuple&lt;L, [...R, unknown]&gt;</span><br></pre></td></tr></table></figure>
<h3 id="NumberRange-限定范围数字"><a href="#NumberRange-限定范围数字" class="headerlink" title="NumberRange(限定范围数字)"></a>NumberRange(限定范围数字)</h3><p><link-and-solution num="8640"></link-and-solution></p>
<h4 id="用法-80"><a href="#用法-80" class="headerlink" title="用法"></a>用法</h4><p><code>NumberRange</code>是用来返回指定范围内的数字的，其返回的是一个联合类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"><span class="keyword">type</span> result = NumberRange&lt;<span class="number">2</span>, <span class="number">9</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-80"><a href="#实现方式-80" class="headerlink" title="实现方式"></a>实现方式</h4><p>实现思路参考：数组<code>Fill</code>方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberRange&lt;</span><br><span class="line">  L, </span><br><span class="line">  H,</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  F = I[<span class="string">'length'</span>] <span class="keyword">extends</span> L ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = I[<span class="string">'length'</span>] <span class="keyword">extends</span> H</span><br><span class="line">  ? I[<span class="built_in">number</span>] | H</span><br><span class="line">  : F <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">    ? NumberRange&lt;L, H, [...I, never]&gt;</span><br><span class="line">    : NumberRange&lt;L, H, [...I, I[<span class="string">'length'</span>]], <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Subsequence-元组子序列"><a href="#Subsequence-元组子序列" class="headerlink" title="Subsequence(元组子序列)"></a>Subsequence(元组子序列)</h3><p><link-and-solution num="8987"></link-and-solution></p>
<h4 id="用法-81"><a href="#用法-81" class="headerlink" title="用法"></a>用法</h4><p><code>Subsequence</code>是用来根据指定数组生成元组子序列的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[] | [1] | [2] | [1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = Subsequence&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-81"><a href="#实现方式-81" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subsequence&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Subsequence&lt;Last, R | [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>R | [...R, First]</code>: 在一个数组中，对一个联合类型的数组使用<code>...</code>扩展时，会自动进行元素分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['a', 'b'] | ['a', 'c']</span></span><br><span class="line"><span class="keyword">type</span> result = [<span class="string">'a'</span>, ...([<span class="string">'b'</span>] | [<span class="string">'c'</span>])]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CheckRepeatedChars-是否包含相同字符"><a href="#CheckRepeatedChars-是否包含相同字符" class="headerlink" title="CheckRepeatedChars(是否包含相同字符)"></a>CheckRepeatedChars(是否包含相同字符)</h3><p><link-and-solution num="9142"></link-and-solution></p>
<h4 id="用法-82"><a href="#用法-82" class="headerlink" title="用法"></a>用法</h4><p><code>CheckRepeatedChars</code>是用来检查字符串中是否存在重复字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false </span></span><br><span class="line"><span class="keyword">type</span> result1 = CheckRepeatedChars&lt;<span class="string">'abc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = CheckRepeatedChars&lt;<span class="string">'abb'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-82"><a href="#实现方式-82" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckRepeatedChars&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : CheckRepeatedChars&lt;Last&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>${string}${First}${string}</code>：表示字符串包含<code>First</code>，也可以用<code>infer</code>来代替：<code>${infer Left}${First}${infer Right}</code>。</li>
</ul>
<h3 id="FirstUniqueCharIndex-字符串中第一个唯一字符"><a href="#FirstUniqueCharIndex-字符串中第一个唯一字符" class="headerlink" title="FirstUniqueCharIndex(字符串中第一个唯一字符)"></a>FirstUniqueCharIndex(字符串中第一个唯一字符)</h3><p><link-and-solution num="9286"></link-and-solution></p>
<h4 id="用法-83"><a href="#用法-83" class="headerlink" title="用法"></a>用法</h4><p><code>FirstUniqueCharIndex</code>是用来获取字符串中第一个唯一字符的索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： 0(字符l)</span></span><br><span class="line"><span class="keyword">type</span> result1 = FirstUniqueCharIndex&lt;<span class="string">'leetcode'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result2 = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-83"><a href="#实现方式-83" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>CheckRepeatedChars</code>的实现思路，很容易实现<code>FirstUniqueCharIndex</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FirstUniqueCharIndex&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? <span class="number">-1</span></span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? First <span class="keyword">extends</span> R[<span class="built_in">number</span>]</span><br><span class="line">      ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">      : Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">        ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">        : R[<span class="string">'length'</span>]</span><br><span class="line">    : <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>代码详解：此题的实现思路和<code>FirstUniqueCharIndex</code>类似，只是多了一层判断，以上面案例为例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代时：S = loveleetcode R = [] R[number] = never First = l</span></span><br><span class="line">=&gt; <span class="string">'l'</span> <span class="keyword">extends</span> never 不满足，<span class="string">'oveleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>l<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代时：S = oveleetcode R = ['l'] R[number] = 'l' First = o</span></span><br><span class="line">=&gt; <span class="string">'o'</span> <span class="keyword">extends</span> <span class="string">'l'</span> 不满足，<span class="string">'veleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>o<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代时：S = veleetcode R = ['l', '0'] R[number] = 'l' | 'o' First = v</span></span><br><span class="line">=&gt; <span class="string">'v'</span> <span class="keyword">extends</span> <span class="string">'l'</span> | <span class="string">'o'</span> 不满足，<span class="string">'eleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>v<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>不满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：R['length']</span></span><br><span class="line">=&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ParseUrlParams-解析url路径参数"><a href="#ParseUrlParams-解析url路径参数" class="headerlink" title="ParseUrlParams(解析url路径参数)"></a>ParseUrlParams(解析url路径参数)</h3><p><link-and-solution num="9616"></link-and-solution></p>
<h4 id="用法-84"><a href="#用法-84" class="headerlink" title="用法"></a>用法</h4><p><code>ParseUrlParams</code>是用来解析<code>url</code>上参数名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'id' | 'user'</span></span><br><span class="line"><span class="keyword">type</span> result = ParseUrlParams&lt;<span class="string">'posts/:id/:user'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-84"><a href="#实现方式-84" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseUrlParams&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>:<span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span>/<span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">    ? Left | ParseUrlParams&lt;Right&gt;</span><br><span class="line">    : Last</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure>
<h3 id="GetMiddleElement-数组中位数"><a href="#GetMiddleElement-数组中位数" class="headerlink" title="GetMiddleElement(数组中位数)"></a>GetMiddleElement(数组中位数)</h3><p><link-and-solution num="9896"></link-and-solution></p>
<h4 id="用法-85"><a href="#用法-85" class="headerlink" title="用法"></a>用法</h4><p><code>GetMiddleElement</code>是用来取数组中位数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result2 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-85"><a href="#实现方式-85" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMiddleElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Middle, <span class="built_in">any</span>]</span><br><span class="line">    ? GetMiddleElement&lt;Middle&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>T[&#39;length&#39;] extends 0 | 1 | 2</code>：当数组长度小于等于而时，其中位数就是自身。</li>
<li><code>T extends [any, ...infer Middle, any]</code>: 当长度大于2时，每次迭代去掉首、尾元素，直至数组长度小于等于2，返回。</li>
</ul>
<h3 id="FindOnlyElements-数组只出现一次的元素"><a href="#FindOnlyElements-数组只出现一次的元素" class="headerlink" title="FindOnlyElements(数组只出现一次的元素)"></a>FindOnlyElements(数组只出现一次的元素)</h3><p><link-and-solution num="9898"></link-and-solution></p>
<h4 id="用法-86"><a href="#用法-86" class="headerlink" title="用法"></a>用法</h4><p><code>FindOnlyElements</code>是用来获取数组中只出现一次的元素，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [1]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-86"><a href="#实现方式-86" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindOnlyElements&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> [...U, ...Last][<span class="built_in">number</span>]</span><br><span class="line">    ? FindOnlyElements&lt;Last, [...U, First], R&gt;</span><br><span class="line">    : FindOnlyElements&lt;Last, [...U, First], [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure>
<h3 id="CountArrayElement-计数数组中元素出现的次数"><a href="#CountArrayElement-计数数组中元素出现的次数" class="headerlink" title="CountArrayElement(计数数组中元素出现的次数)"></a>CountArrayElement(计数数组中元素出现的次数)</h3><p><link-and-solution num="9989"></link-and-solution></p>
<h4 id="用法-87"><a href="#用法-87" class="headerlink" title="用法"></a>用法</h4><p><code>CountArrayElement</code>是用来实现计算数组中元素出现次数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1: &#123; 1: 1, 2: 1, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result1 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2: &#123; 1: 2, 2: 2, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-87"><a href="#实现方式-87" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? [First] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? Flatten&lt;Last, R&gt; </span><br><span class="line">    : First <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? Flatten&lt;Last, [...R, ...Flatten&lt;First&gt;]&gt;</span><br><span class="line">      : Flatten&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjectCount&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">any</span>[]&gt; = &#123;&#125;</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> keyof R</span><br><span class="line">    ? ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [...R[First], <span class="number">0</span>]&gt;&gt;</span><br><span class="line">    : ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [<span class="number">0</span>]&gt;&gt;</span><br><span class="line">  : &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof R]: R[P][<span class="string">'length'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountArrayElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = ObjectCount&lt;Flatten&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>Flatten</code>：实现<code>Flatten</code>，用来处理传递多维数组的情况，例如：<code>CountArrayElement&lt;[1, [1, 2], 3, [4, [5]]]&gt;</code></li>
<li><code>First extends keyof R</code>: 如果当前数组的遍历项是<code>R</code>对象中的一个键，则表明需要计数加一；如果不是，则代表是新项，需要计数为1；</li>
<li><code>[P in keyof R]: R[P][&#39;length&#39;]</code>: 因为最后结果需要返回数组，而非数组，所以迭代<code>R</code>对象，返回其每个属性的数组长度即可。</li>
</ul>
<h3 id="Integer-数字整数"><a href="#Integer-数字整数" class="headerlink" title="Integer(数字整数)"></a>Integer(数字整数)</h3><p><link-and-solution num="10969"></link-and-solution></p>
<h4 id="用法-88"><a href="#用法-88" class="headerlink" title="用法"></a>用法</h4><p><code>Integer</code>是用来返回数字的整数部分的，如果传入的数子包含小数，则返回<code>never</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：1</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1.1</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-88"><a href="#实现方式-88" class="headerlink" title="实现方式"></a>实现方式</h4><p>根据<code>JavaScript</code>中<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">BigInt</a>的用法，其不能包含小数。所以实现方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;bigint&#125;</span>`</span> ? T : never</span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li><code>${T}</code> extends <code>${bigint}</code>：这里转成字符串形式比较，不能直接比较，因为<code>number</code>和<code>bigint</code>是两个不同的类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：都是false</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">number</span> <span class="keyword">extends</span> bigint ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = bigint <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ToPrimitive-转化基本类型"><a href="#ToPrimitive-转化基本类型" class="headerlink" title="ToPrimitive(转化基本类型)"></a>ToPrimitive(转化基本类型)</h3><p><link-and-solution num="16259"></link-and-solution></p>
<h4 id="用法-89"><a href="#用法-89" class="headerlink" title="用法"></a>用法</h4><p><code>ToPrimitive</code>是用来返回一个对象的类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonInfo = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">  married: <span class="literal">false</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="string">'123456'</span></span><br><span class="line">    phone: <span class="string">'13111111111'</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="string">'sing'</span>, <span class="string">'dance'</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="string">'test'</span>]</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  married: <span class="built_in">boolean</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="built_in">string</span></span><br><span class="line">    phone: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="built_in">string</span>]</span><br><span class="line">  fn: <span class="built_in">Function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = ToPrimitive&lt;PersonInfo&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-89"><a href="#实现方式-89" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToPrimitive&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> object</span><br><span class="line">  ? T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">    ? <span class="built_in">Function</span></span><br><span class="line">    : &#123; [P <span class="keyword">in</span> keyof T]: ToPrimitive&lt;T[P]&gt; &#125;</span><br><span class="line">  : T <span class="keyword">extends</span> &#123; valueOf: <span class="function"><span class="params">()</span> =&gt;</span> infer R &#125; ? R : T</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li>对于函数来说：当满足<code>T extends (...args: any[]) =&gt; any</code>条件时，直接返回<code>Function</code>。</li>
<li>对于嵌套对象来说，递归调用<code>ToPrimitive</code>即可。</li>
<li>对于普通类型来说，判断其是否满足<code>T extends { valueOf: () =&gt; infer R }</code>，是则返回其类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的valueOf是js中的valueOf一样</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(num.valueOf()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="DeepMutable-深度Mutable"><a href="#DeepMutable-深度Mutable" class="headerlink" title="DeepMutable(深度Mutable)"></a>DeepMutable(深度Mutable)</h3><p><link-and-solution num="17973"></link-and-solution></p>
<h4 id="用法-90"><a href="#用法-90" class="headerlink" title="用法"></a>用法</h4><p><code>DeepMutable</code>是用来深度移除属性<code>readonly</code>修饰符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Test &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span></span><br><span class="line">  readonly description: <span class="built_in">string</span></span><br><span class="line">  readonly completed: <span class="built_in">boolean</span></span><br><span class="line">  readonly meta: &#123;</span><br><span class="line">    readonly author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Expected &#123;</span><br><span class="line">  title: <span class="built_in">string</span></span><br><span class="line">  description: <span class="built_in">string</span></span><br><span class="line">  completed: <span class="built_in">boolean</span></span><br><span class="line">  meta: &#123;</span><br><span class="line">    author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = DeepMutable&lt;Test&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-90"><a href="#实现方式-90" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepMutable&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; - readonly [P <span class="keyword">in</span> keyof T]: DeepMutable&lt;T[P]&gt; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="AllMatch-数组元素是否与给定元素完全相同"><a href="#AllMatch-数组元素是否与给定元素完全相同" class="headerlink" title="AllMatch(数组元素是否与给定元素完全相同)"></a>AllMatch(数组元素是否与给定元素完全相同)</h3><p><link-and-solution num="18142"></link-and-solution></p>
<h4 id="用法-91"><a href="#用法-91" class="headerlink" title="用法"></a>用法</h4><p><code>AllMatch</code>是用来判断，数组元素是否与给定元素完全相同的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-91"><a href="#实现方式-91" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑边界情况，简易实现方法</span></span><br><span class="line"><span class="keyword">type</span> errTest1 = AllMatch&lt;[<span class="built_in">any</span>], unknown&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest2 = AllMatch&lt;[unknown], <span class="built_in">any</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest3 = AllMatch&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> U</span><br><span class="line">? <span class="literal">true</span></span><br><span class="line">: <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑边界情况：完整实现</span></span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? AllMatch&lt;Rest, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  : <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="Filter-数组过滤"><a href="#Filter-数组过滤" class="headerlink" title="Filter(数组过滤)"></a>Filter(数组过滤)</h3><p><link-and-solution num="18220"></link-and-solution></p>
<h4 id="用法-92"><a href="#用法-92" class="headerlink" title="用法"></a>用法</h4><p><code>Filter</code>是用来实现数组过滤方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-92"><a href="#实现方式-92" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Filter&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> P</span><br><span class="line">    ? [First, ...Filter&lt;Rest, P&gt;]</span><br><span class="line">    : Filter&lt;Rest, P&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure>
<h3 id="FindAllIndex-查找数组中给定元素所有索引"><a href="#FindAllIndex-查找数组中给定元素所有索引" class="headerlink" title="FindAllIndex(查找数组中给定元素所有索引)"></a>FindAllIndex(查找数组中给定元素所有索引)</h3><p><link-and-solution num="21104"></link-and-solution></p>
<h4 id="用法-93"><a href="#用法-93" class="headerlink" title="用法"></a>用法</h4><p><code>FindAllIndex</code>是用来返回字符串中所有匹配索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[11]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[2, 13]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'pe'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：[]</span></span><br><span class="line"><span class="keyword">type</span> result3 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">''</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-93"><a href="#实现方式-93" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindAll&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? []</span><br><span class="line">  : T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      ? FindAll&lt;Last, P, [...R, I[<span class="string">'length'</span>]], [...I, <span class="number">0</span>]&gt;</span><br><span class="line">      : FindAll&lt;Last, P, R, [...I, <span class="number">0</span>]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>I extends any[] = []</code>: 设置索引，字符串每迭代移除，<code>I</code>数组长度增加一。</li>
<li><code>T extends ${P}${string}</code>: 当满足条件时，向结果数组<code>R</code>中添加当前索引即可。</li>
</ul>
<h3 id="CombKeys-组合键"><a href="#CombKeys-组合键" class="headerlink" title="CombKeys(组合键)"></a>CombKeys(组合键)</h3><p><link-and-solution num="21106"></link-and-solution></p>
<h4 id="用法-94"><a href="#用法-94" class="headerlink" title="用法"></a>用法</h4><p><code>CombKeys</code>是用来实现组合键的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'cmd ctrl' | 'cmd opt' | 'cmd fn' | 'ctrl opt' | 'ctrl fn' | 'opt fn'</span></span><br><span class="line"><span class="keyword">type</span> result = CombKeys&lt;[<span class="string">'cmd'</span>, <span class="string">'ctrl'</span>, <span class="string">'opt'</span>, <span class="string">'fn'</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-94"><a href="#实现方式-94" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CombKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span>, ...infer Last <span class="keyword">extends</span> <span class="built_in">string</span>[]]</span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;First&#125;</span> <span class="subst">$&#123;Last[<span class="built_in">number</span>]&#125;</span>`</span> | CombKeys&lt;Last&gt;</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure>
<h3 id="ReplaceFirst-替换元组中第一个匹配项"><a href="#ReplaceFirst-替换元组中第一个匹配项" class="headerlink" title="ReplaceFirst(替换元组中第一个匹配项)"></a>ReplaceFirst(替换元组中第一个匹配项)</h3><p><link-and-solution num="25170"></link-and-solution></p>
<h4 id="用法-95"><a href="#用法-95" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceFirst</code>是用来替换元组中第一个匹配项，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceFirst&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-95"><a href="#实现方式-95" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceFirst&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly unknown[],</span><br><span class="line">  From,</span><br><span class="line">  To</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> From</span><br><span class="line">    ? [To, ...Rest]</span><br><span class="line">    : [First, ...ReplaceFirst&lt;Rest, From, To&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure>
<h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><h3 id="SimpleVue-简单Vue类型"><a href="#SimpleVue-简单Vue类型" class="headerlink" title="SimpleVue(简单Vue类型)"></a>SimpleVue(简单Vue类型)</h3><p><link-and-solution num="6"></link-and-solution></p>
<h4 id="用法-96"><a href="#用法-96" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-96"><a href="#实现方式-96" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Currying-柯里化"><a href="#Currying-柯里化" class="headerlink" title="Currying(柯里化)"></a>Currying(柯里化)</h3><p><link-and-solution num="17"></link-and-solution></p>
<p>在<code>JavaScript</code>中<code>Currying</code>是用来实现函数柯里化的，其用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> three = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = Currying(add)</span><br><span class="line"><span class="keyword">const</span> five = curriedAdd(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="用法-97"><a href="#用法-97" class="headerlink" title="用法"></a>用法</h4><p><code>Currying</code>是用来实现<code>JavaScript</code>中的柯里化的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = Currying(<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span>, c: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 结果：(a: string) =&gt; (a: number) =&gt; (a: boolean) =&gt; true</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> func</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-97"><a href="#实现方式-97" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CurryFunction&lt;</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">  ? <span class="function"><span class="params">()</span> =&gt;</span> R</span><br><span class="line">  : P <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="function">(<span class="params">a: First</span>) =&gt;</span> R</span><br><span class="line">      : <span class="function">(<span class="params">a: First</span>) =&gt;</span> CurryFunction&lt;Rest, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Currying</span>&lt;<span class="title">F</span>&gt;(<span class="params">fn: F</span>):</span></span><br><span class="line"><span class="function">  <span class="title">F</span> <span class="title">extends</span> (<span class="params">...args: infer P</span>) =&gt; <span class="title">infer</span> <span class="title">R</span></span></span><br><span class="line"><span class="function">  ? <span class="title">CurryFunction</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="function">  : <span class="title">never</span></span></span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>P</code>：<code>P</code>为调用<code>Currying</code>函数时传递函数参数的参数数组，以上面为例，其值为：<code>[number, string, boolean]</code>。</li>
<li><code>P extends [infer First, ...infer Rest]</code>: 遍历参数列表，依次返回一个函数即可。</li>
</ul>
<h3 id="UnionToIntersection-元组取交集"><a href="#UnionToIntersection-元组取交集" class="headerlink" title="UnionToIntersection(元组取交集)"></a>UnionToIntersection(元组取交集)</h3><p><link-and-solution num="55"></link-and-solution></p>
<p>在实现<code>UnionToIntersection</code>之前，我们先来回顾一下<code>TS</code>中<code>&amp;</code>符号的作用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="number">1</span> &amp; <span class="string">'foo'</span> &amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; &amp; &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = <span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) &amp; (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)</span></span><br></pre></td></tr></table></figure></p>
<p>案例解析：</p>
<ul>
<li>案例一：因为<code>1</code>、<code>foo</code>以及<code>true</code>，没有交集部分，所以这里结果为<code>never</code>。</li>
<li>案例二：对于<code>a</code>和<code>c</code>属性而言，它们只存在于自身类型，所以交集部分是自身；对于<code>b</code>属性而言，它在两个类型中都存在，且其属性的类型存在交集部分，既：<code>number</code>。</li>
<li>案例三：对于函数的交叉类型，我们从函数参数、函数返回值这两个部分来说明。对于函数参数而言，取其联合类型；对于函数返回值而言，取其交叉类型。</li>
</ul>
<p>从以上几个案例中可以看出，<code>TS</code>中的<code>&amp;</code>符号是取交集的意思，也叫<strong>交叉类型</strong>。</p>
<h4 id="用法-98"><a href="#用法-98" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToIntersection</code>所做的事情和<code>&amp;</code>符号是一样的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToIntersection&lt;<span class="number">1</span> | <span class="string">'foo'</span> | <span class="literal">true</span>&gt;</span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToIntersection&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; | &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;&gt;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToIntersection&lt;<span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) | (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-98"><a href="#实现方式-98" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>U extends any ? X : Y</code>： 这里把<code>U</code>类型处理成<code>(x: U) =&gt; any</code>的函数类型。</li>
<li><code>T extends (x: infer V) =&gt; any ? V : never</code>：这里的<code>T</code>就是上一步的函数类型，如果<code>extends</code>成立，则返回<code>V</code>，此时的<code>V</code>必然满足<code>U &amp; V</code>。</li>
</ul>
<h3 id="RequiredKeys-所有必填字段"><a href="#RequiredKeys-所有必填字段" class="headerlink" title="RequiredKeys(所有必填字段)"></a>RequiredKeys(所有必填字段)</h3><p><link-and-solution num="89"></link-and-solution></p>
<h4 id="用法-99"><a href="#用法-99" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredKeys</code>是用来返回一个类型中所有必填字段，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-99"><a href="#实现方式-99" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequiredKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? never : P)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>{} extends Pick&lt;T, P&gt; ? never : P</code>：是用来判断当前遍历键是否可选键的。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> result = &#123;&#125; <span class="keyword">extends</span> &#123;&#125; | &#123; sex: <span class="literal">undefined</span> &#125; ? never : <span class="string">'sex'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GetRequired-必填字段组成的类型"><a href="#GetRequired-必填字段组成的类型" class="headerlink" title="GetRequired(必填字段组成的类型)"></a>GetRequired(必填字段组成的类型)</h3><p><link-and-solution num="57"></link-and-solution></p>
<h4 id="用法-100"><a href="#用法-100" class="headerlink" title="用法"></a>用法</h4><p><code>GetRequired</code>是用来取一个类型中那些由必填字段组成的一个新类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; age: number; sex: undefined; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-100"><a href="#实现方式-100" class="headerlink" title="实现方式"></a>实现方式</h4><p>按照<code>RequiredKeys</code>的实现思路，能够很容易的实现<code>GetRequired</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? P : never)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码详解：</p>
<ul>
<li><code>T[P] extends Required&lt;T&gt;[P] ? P : never</code>：用来判断当前遍历键的类型是否一致，一致则是必填类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P为name时</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">string</span> | <span class="literal">undefined</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">'name'</span> : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// P为age时</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="OptionalKeys-所有可选字段"><a href="#OptionalKeys-所有可选字段" class="headerlink" title="OptionalKeys(所有可选字段)"></a>OptionalKeys(所有可选字段)</h3><p><link-and-solution num="90"></link-and-solution></p>
<p><code>OptionalKeys</code>和<code>RequiredKeys</code>所做的事情相反，其获取的是所有可选字段。</p>
<h4 id="用法-101"><a href="#用法-101" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'sex' | 'address'</span></span><br><span class="line"><span class="keyword">type</span> result = OptionalKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-101"><a href="#实现方式-101" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionalKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? P : never)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：从上面代码中可以看出，它和<code>RequiredKeys</code>实现思路是一样的，区别只是在<code>extends</code>关键词后面的处理不同。</p>
<h3 id="GetOptional-可选字段组成的类型"><a href="#GetOptional-可选字段组成的类型" class="headerlink" title="GetOptional(可选字段组成的类型)"></a>GetOptional(可选字段组成的类型)</h3><p><link-and-solution num="59"></link-and-solution></p>
<h4 id="用法-102"><a href="#用法-102" class="headerlink" title="用法"></a>用法</h4><p>按照<code>OptionalKeys</code>的实现思路，能够很容易的实现<code>GetOptional</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; sex?: undefined; address?: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetOptional&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-102"><a href="#实现方式-102" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetOptional&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? never : P)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CapitalizeWords-所有单词首字母大写"><a href="#CapitalizeWords-所有单词首字母大写" class="headerlink" title="CapitalizeWords(所有单词首字母大写)"></a>CapitalizeWords(所有单词首字母大写)</h3><p><link-and-solution num="112"></link-and-solution></p>
<h4 id="用法-103"><a href="#用法-103" class="headerlink" title="用法"></a>用法</h4><p><code>CapitalizeWords</code>是用来把一个字符串中所有单词，变为大写字母的，其中这个字符串以固定的分隔符分割，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'Foobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = CapitalizeWords&lt;<span class="string">'foobar'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'Foo Bar.Hello,World'</span></span><br><span class="line"><span class="keyword">type</span> t2 = CapitalizeWords&lt;<span class="string">'foo bar.hello,world'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-103"><a href="#实现方式-103" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CapitalizeWords&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Uppercase&lt;First&gt; <span class="keyword">extends</span> Lowercase&lt;First&gt;</span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;Rest&gt;&#125;</span>`</span></span><br><span class="line">    : CapitalizeWords&lt;Rest, <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;</span><br><span class="line">  : Capitalize&lt;R&gt;</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>Uppercase&lt;First&gt; extends Lowercase&lt;First&gt;</code>：为了找到连串的大写字符串，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S = foo bar.hello,world</span></span><br><span class="line">R = <span class="string">'foo'</span> First = <span class="string">' '</span> Rest = <span class="string">'bar.hello,world'</span></span><br><span class="line">=&gt; <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`foo `</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&gt;&#125;</span>`</span></span><br><span class="line">=&gt; <span class="string">`Foo <span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&#125;</span>`</span></span><br><span class="line">=&gt; ...</span><br><span class="line">=&gt; <span class="string">'Foo Bar.Hello,World'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CamelCase-下划线字符串转小驼峰"><a href="#CamelCase-下划线字符串转小驼峰" class="headerlink" title="CamelCase(下划线字符串转小驼峰)"></a>CamelCase(下划线字符串转小驼峰)</h3><p><link-and-solution num="114"></link-and-solution></p>
<h4 id="用法-104"><a href="#用法-104" class="headerlink" title="用法"></a>用法</h4><p>与<strong>中级</strong>章节实现不同，此章节中<code>CamelCase</code>是用来将下划线字符串转小驼峰的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'fooBarHelloWorld'</span></span><br><span class="line"><span class="keyword">type</span> result = CamelCase&lt;<span class="string">'foo_bar_hello_world'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-104"><a href="#实现方式-104" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsLetter&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Uppercase&lt;S&gt; <span class="keyword">extends</span> Lowercase&lt;S&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> CamelCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? CamelCase&lt;</span><br><span class="line">      Rest,</span><br><span class="line">      IsLetter&lt;First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? R <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer P&#125;</span>_`</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;Uppercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;Lowercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span></span><br><span class="line">    &gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><p><code>IsLetter</code>: 用来判断是否为字母的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsLetter&lt;<span class="string">'$'</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsLetter&lt;<span class="string">'A'</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>IsLetter&lt;L&gt; extends true</code>: 如果是字母的话，则根据是否以下划线结尾，如果是，则只需要紧邻下划线的字母<code>L</code>大写即可，否小写。</p>
</li>
</ul>
<h3 id="ParsePrintFormat-获取字符串格式化参数"><a href="#ParsePrintFormat-获取字符串格式化参数" class="headerlink" title="ParsePrintFormat(获取字符串格式化参数)"></a>ParsePrintFormat(获取字符串格式化参数)</h3><p><link-and-solution num="147"></link-and-solution></p>
<h4 id="用法-105"><a href="#用法-105" class="headerlink" title="用法"></a>用法</h4><p><code>ParsePrintFormat</code>是用来获取字符串格式化参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数映射表</span></span><br><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['string', 'dec']</span></span><br><span class="line"><span class="keyword">type</span> result = ParsePrintFormat&lt;<span class="string">'Hello %s: score is %d'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-105"><a href="#实现方式-105" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Char <span class="keyword">extends</span> keyof ControlMap</span><br><span class="line">      ? ParsePrintFormat&lt;S2, [...R, ControlMap[Char]]&gt;</span><br><span class="line">      : ParsePrintFormat&lt;S2, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="comment">// way2: 不借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Char <span class="keyword">extends</span> keyof ControlsMap</span><br><span class="line">    ? [ControlsMap[Char], ...ParsePrintFormat&lt;Rest&gt;]</span><br><span class="line">    : ParsePrintFormat&lt;Rest&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure>
<p>代码详解：在以上实现方法中，借用了辅助数组的思想，拿上面案例来说，具体迭代分析如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">S满足条件 R = [] S1 = <span class="string">'Hello '</span> Char = <span class="string">'s'</span> S2 = <span class="string">': score is %d'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">S满足条件 R = [<span class="string">'string'</span>]  S1 = <span class="string">': score is '</span> Char = <span class="string">'d'</span> S2 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次迭代</span></span><br><span class="line">S不满足条件 R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">result = R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="VueBasicProps-Vue的Props类型"><a href="#VueBasicProps-Vue的Props类型" class="headerlink" title="VueBasicProps(Vue的Props类型)"></a>VueBasicProps(Vue的Props类型)</h3><p><link-and-solution num="213"></link-and-solution></p>
<h4 id="用法-106"><a href="#用法-106" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-106"><a href="#实现方式-106" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsAny和NotAny"><a href="#IsAny和NotAny" class="headerlink" title="IsAny和NotAny"></a>IsAny和NotAny</h3><p><link-and-solution num="223"></link-and-solution></p>
<h4 id="用法-107"><a href="#用法-107" class="headerlink" title="用法"></a>用法</h4><p><code>IsAny</code>是用来判断一个类型是否为<code>any</code>的，<code>NotAny</code>和它做的事情相反。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = IsAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t2 = IsAny&lt;never&gt;     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t3 = IsAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t4 = NotAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t5 = NotAny&lt;never&gt;     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t6 = NotAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-107"><a href="#实现方式-107" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsAny&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> (<span class="number">1</span> &amp; T) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> NotAny&lt;T&gt; = <span class="literal">true</span> <span class="keyword">extends</span> IsAny&lt;T&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>代码详解：<code>1 &amp; T</code>的结果只能是：<code>1</code>、<code>never</code>或者<code>any</code>。当使用<code>0 extends</code>这三个结果的时候，只有<code>any</code>判断为真。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="number">0</span> <span class="keyword">extends</span> never ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="number">0</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Get-字符串路径取值"><a href="#Get-字符串路径取值" class="headerlink" title="Get(字符串路径取值)"></a>Get(字符串路径取值)</h3><p><link-and-solution num="270"></link-and-solution></p>
<h4 id="用法-108"><a href="#用法-108" class="headerlink" title="用法"></a>用法</h4><p><code>Get</code>是用来进行字符串路径取值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      value: <span class="string">'foobar'</span>,</span><br><span class="line">      count: <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    include: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'foo.baz'</span>: <span class="literal">false</span></span><br><span class="line">  hello: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：world</span></span><br><span class="line"><span class="keyword">type</span> t1 = Get&lt;Data, <span class="string">'hello'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：foobar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Get&lt;Data, <span class="string">'foo.bar.value'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t3 = Get&lt;Data, <span class="string">'foo.baz'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> t4 = Get&lt;Data, <span class="string">'no.exits'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-108"><a href="#实现方式-108" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Get&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = K <span class="keyword">extends</span> keyof T</span><br><span class="line">  ? T[K]</span><br><span class="line">  : K <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line">    : T[K &amp; keyof T]</span><br></pre></td></tr></table></figure>
<p>代码详解：对于<code>Get</code>的实现，主要分为两部分：含有<code>.</code>符号的字符串和不含<code>.</code>符号的字符串。</p>
<ul>
<li><p>含有<code>.</code>符号的字符串：对于这种情况，我们先判断<code>.</code>符号左侧部分是否满足为<code>T</code>类型的某个<code>key</code>，如果满足，则递归调用<code>Get</code>；如果不满足，则直接返回<code>never</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1如果是T的属性键，则返回S1；如果不是，则返回never</span></span><br><span class="line">Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S1 <span class="keyword">extends</span> keyof T ? Get&lt;T[S1], S2&gt; : never</span><br></pre></td></tr></table></figure>
</li>
<li><p>不含有<code>.</code>符号的字符串：对于这种情况，我们只需要判断它是否为<code>T</code>类型中的某个<code>key</code>，如果是，则直接取值；如果不是，则返回<code>never</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K如果是T的属性键，则返回K；如果不是，则返回never</span></span><br><span class="line">T[K &amp; keyof T]</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S <span class="keyword">extends</span> keyof T ? T[S] : never</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="StringToNumber-字符串数字转数字"><a href="#StringToNumber-字符串数字转数字" class="headerlink" title="StringToNumber(字符串数字转数字)"></a>StringToNumber(字符串数字转数字)</h3><p><link-and-solution num="300"></link-and-solution></p>
<h4 id="用法-109"><a href="#用法-109" class="headerlink" title="用法"></a>用法</h4><p><code>StringToNumber</code>是用来将字符串形式的数字转换成真正数字类型数字的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：123</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-109"><a href="#实现方式-109" class="headerlink" title="实现方式"></a>实现方式</h4><p>在<code>JavaScript</code>中，我们可以很方便的调用<code>Number()</code>方法或者<code>parseInt()</code>方法来将字符串类型的数字，转换成数字类型的数字。但在<code>TS</code>中，并没有这样的方法，需要我们来手动实现。</p>
<p><code>StringToNumber</code>的实现并不容易理解，我们需要将其进行拆分，一步步来完善，其实现思路如下：</p>
<ul>
<li><p>第一步：可以很容易获取字符串<code>&#39;123&#39;</code>中每一位字符，我们将其存储在辅助数组<code>T</code>中，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? StringToNumber&lt;S2, [...T, S1]&gt;</span><br><span class="line">    : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['1', '2', '3']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：我们需要将单个字符串类型的数字，转换成真正数字类型的数字，可以借助中间数组来帮忙，例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> =&gt; [<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">1</span></span><br><span class="line"><span class="string">'2'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">2</span></span><br><span class="line"><span class="string">'3'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'9'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据以上规律，我们封装一个<code>MakeArray</code>方法，它的实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t1 = MakeArray&lt;<span class="string">'1'</span>&gt; <span class="comment">// [0]</span></span><br><span class="line"><span class="keyword">type</span> t2 = MakeArray&lt;<span class="string">'2'</span>&gt; <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="keyword">type</span> t3 = MakeArray&lt;<span class="string">'3'</span>&gt; <span class="comment">// [0, 0, 0]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>第三步：现在有了百位，十位和个位的数字，我们应该运用算术把它们按照一定的规律累加起来，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> target = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">1</span> + <span class="number">2</span> = <span class="number">12</span></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">12</span> + <span class="number">3</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">// 迭代规律</span></span><br><span class="line">target = <span class="number">10</span> * target + N</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据以上思路，我们还需要一个乘十的工具函数，对应到实际需求，就是需要把一个数组<code>copy</code>十次，因此我们封装一个<code>Multiply10</code>工具，其实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result = Multiply10&lt;[<span class="number">1</span>]&gt; <span class="comment">// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>第四步：根据前几步的分析，把所有东西串联起来，<code>StringToNumber</code>完整实现代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Digital = <span class="string">'0'</span>|<span class="string">'1'</span>|<span class="string">'2'</span>|<span class="string">'3'</span>|<span class="string">'4'</span>|<span class="string">'5'</span>|<span class="string">'6'</span>|<span class="string">'7'</span>|<span class="string">'8'</span>|<span class="string">'9'</span></span><br><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> Digital</span><br><span class="line">      ? StringToNumber&lt;S2, [...Multiply10&lt;T&gt;, ...MakeArray&lt;S1&gt;]&gt;</span><br><span class="line">      : never</span><br><span class="line">    : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>第五步：为了更好的理解递归的过程，我们拆解成如下步骤来说明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'123'</span> S1 = <span class="string">'1'</span> S2 = <span class="string">'23'</span> T = [<span class="number">0</span>] T[<span class="string">'length'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'23'</span>  S1 = <span class="string">'2'</span> S2 = <span class="string">'3'</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'3'</span>  S1 = <span class="string">'3'</span> S2 = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次递归，S不满足$&#123;infer S1&#125;$&#123;infer S2&#125; T['length']取值</span></span><br><span class="line">S = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="FilterOut-数组元素过滤"><a href="#FilterOut-数组元素过滤" class="headerlink" title="FilterOut(数组元素过滤)"></a>FilterOut(数组元素过滤)</h3><p><link-and-solution num="399"></link-and-solution></p>
<h4 id="用法-110"><a href="#用法-110" class="headerlink" title="用法"></a>用法</h4><p><code>FilterOut</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[2]</span></span><br><span class="line"><span class="keyword">type</span> result = FilterOut&lt;[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>], <span class="string">'a'</span> | <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-110"><a href="#实现方式-110" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterOut&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer R, ...infer args]</span><br><span class="line">      ? [R] <span class="keyword">extends</span> [F]</span><br><span class="line">        ? FilterOut&lt;args, F, [...K]&gt;</span><br><span class="line">        : FilterOut&lt;args, F, [...K, R]&gt;</span><br><span class="line">      : K</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li>第一步：我们借用赋值函数来存放最后的结果。</li>
<li>第二步：迭代数组<code>T</code>，拿每一个元素去和指定的<code>F</code>进行判断，如果<code>R</code>是<code>F</code>的子类型，则不添加此元素到结果数组中，反之添加。</li>
<li>第三步：当迭代完毕时，直接返回结果数组<code>K</code>。</li>
</ul>
<h3 id="TupleToEnum-元组转枚举"><a href="#TupleToEnum-元组转枚举" class="headerlink" title="TupleToEnum(元组转枚举)"></a>TupleToEnum(元组转枚举)</h3><p><link-and-solution num="472"></link-and-solution></p>
<h4 id="用法-111"><a href="#用法-111" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToEnum</code>是用来将元组转换为枚举的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OperatingSystem = [<span class="string">'macOs'</span>, <span class="string">'Windows'</span>, <span class="string">'Linux'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> Expected1 = &#123;</span><br><span class="line">  readonly MacOs: <span class="string">'macOs'</span>;</span><br><span class="line">  readonly Windows: <span class="string">'Windows'</span>;</span><br><span class="line">  readonly Linux: <span class="string">'Linux'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected2 = &#123;</span><br><span class="line">  readonly MacOs: <span class="number">0</span>;</span><br><span class="line">  readonly Windows: <span class="number">1</span>;</span><br><span class="line">  readonly Linux: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> result1 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> result2 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem, <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-111"><a href="#实现方式-111" class="headerlink" title="实现方式"></a>实现方式</h4><p>在实现<code>TupleToEnum</code>之前，我们先来实现<code>TupleKeys</code>，它是用来获取所有元组索引组合成的联合类型的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">      ? TupleKeys&lt;args&gt; | args[<span class="string">'length'</span>]</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：0 | 1 | 2</span></span><br><span class="line"><span class="keyword">type</span> keys = TupleKeys&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br></pre></td></tr></table></figure></p>
<p>在有了以上<code>keys</code>后，就能很容易实现<code>TupleToEnum</code>了，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToEnum&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">string</span>[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">&gt; = &#123;</span><br><span class="line">  readonly [K <span class="keyword">in</span> TupleKeys&lt;T&gt; <span class="keyword">as</span> Capitalize&lt;T[K]&gt;]: N <span class="keyword">extends</span> <span class="literal">true</span> ? K : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Format-字符串格式化函数类型"><a href="#Format-字符串格式化函数类型" class="headerlink" title="Format(字符串格式化函数类型)"></a>Format(字符串格式化函数类型)</h3><p><link-and-solution num="545"></link-and-solution></p>
<p><code>%s</code>表示格式化为<code>(x: string) =&gt; any</code>形式，<code>%d</code>表示格式化为<code>(x: number) =&gt; any</code>形式。</p>
<h4 id="用法-112"><a href="#用法-112" class="headerlink" title="用法"></a>用法</h4><p><code>Format</code>是将字符串格式化为指定函数类型的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：(x: string) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result1 = Format&lt;<span class="string">'a%sbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：(x: number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result2 = Format&lt;<span class="string">'a%dbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：(x: number) =&gt; (x: string) =&gt; string&gt;</span></span><br><span class="line"><span class="keyword">type</span> result3 = Format&lt;<span class="string">'a%dbc%s'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-112"><a href="#实现方式-112" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FormatMaps = &#123;</span><br><span class="line">  <span class="string">'s'</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">'d'</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Format&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer P&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? P <span class="keyword">extends</span> keyof FormatMaps</span><br><span class="line">        ? <span class="function">(<span class="params">x: FormatMaps[P]</span>) =&gt;</span> Format&lt;S2&gt;</span><br><span class="line">        : <span class="built_in">string</span></span><br><span class="line">      : <span class="built_in">string</span></span><br></pre></td></tr></table></figure>
<h3 id="LengthOfString-字符串的长度-1"><a href="#LengthOfString-字符串的长度-1" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="651"></link-and-solution></p>
<p>我们之前在<strong>中级</strong>大章节中已经实现过<code>LengthOfString</code>，但它面临的问题是，如果字符有上百个，由于<code>TS</code>对于递归的次数存在限制，会提示嵌套过深。</p>
<h4 id="用法-113"><a href="#用法-113" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：91</span></span><br><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901'</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实现方式-113"><a href="#实现方式-113" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S0&#125;</span><span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span><span class="subst">$&#123;infer S3&#125;</span><span class="subst">$&#123;infer S4&#125;</span><span class="subst">$&#123;infer S5&#125;</span><span class="subst">$&#123;infer S6&#125;</span><span class="subst">$&#123;infer S7&#125;</span><span class="subst">$&#123;infer S8&#125;</span><span class="subst">$&#123;infer S9&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;Rest, [...R, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&gt;</span><br><span class="line">      : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">          ? LengthOfString&lt;S2, [...R, S1]&gt;</span><br><span class="line">          : R[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure>
<p>代码解析：这里我们巧妙的使用占位的思想，<code>S extends ${infer S1}${infer S2}${infer S3}</code>，如果<code>S</code>满足这个占位形式，则表示<code>S</code>的长度至少为<code>2</code>，带入到上面的例子，解析步骤如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 第二弟递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="comment">// 最后一次递归</span></span><br><span class="line">S = <span class="string">'1'</span>不满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, ....., <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 最后结果</span></span><br><span class="line">R[<span class="string">'length'</span>] = <span class="number">91</span></span><br></pre></td></tr></table></figure></p>
<h3 id="UnionToTuple-联合类型转元组"><a href="#UnionToTuple-联合类型转元组" class="headerlink" title="UnionToTuple(联合类型转元组)"></a>UnionToTuple(联合类型转元组)</h3><p><link-and-solution num="730"></link-and-solution></p>
<h4 id="用法-114"><a href="#用法-114" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToTuple</code>是用来将联合类型转成元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToTuple&lt;<span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | never&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-114"><a href="#实现方式-114" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = (</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">  ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">  : never</span><br><span class="line">) <span class="keyword">extends</span> (x: infer R) =&gt; <span class="built_in">any</span> </span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LastUnion&lt;U&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line">    : never</span><br><span class="line">&gt; <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span></span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnionToTuple&lt;</span><br><span class="line">  T,</span><br><span class="line">  Last = LastUnion&lt;T&gt;</span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? []</span><br><span class="line">  : [...UnionToTuple&lt;Exclude&lt;T, Last&gt;&gt;, Last]</span><br></pre></td></tr></table></figure>
<p>代码详解：</p>
<ul>
<li><code>UnionToIntersection</code>: 联合类型取交集，在之前已经实现过，这里不再赘述。主要理解以下案例：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载结果</span></span><br><span class="line"><span class="comment">// function (x: 1): 0;</span></span><br><span class="line"><span class="comment">// function (x: 2): 0;</span></span><br><span class="line"><span class="keyword">type</span> result = UnionToIntersection&lt;f1 | f2&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于函数参数的交集而言，不是简单的把参数取交集，而是”联合”起来，也就是构造一个新的函数类型，即：<strong>函数重载</strong></p>
<ul>
<li><code>LastUnion</code>: 取联合类型最后的一个元素，如果一个函数存在重载的情况，<code>TS</code>会取最后一个函数签名，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：2</span></span><br><span class="line"><span class="keyword">type</span> result1 = f1 &amp; f2 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br><span class="line"><span class="comment">// 结果2：1</span></span><br><span class="line"><span class="keyword">type</span> result2 = f2 &amp; f1 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Join-字符串拼接"><a href="#Join-字符串拼接" class="headerlink" title="Join(字符串拼接)"></a>Join(字符串拼接)</h3><p><link-and-solution num="847"></link-and-solution></p>
<h4 id="用法-115"><a href="#用法-115" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现拼接字符串的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： ''</span></span><br><span class="line"><span class="keyword">const</span> Expected1 = join(<span class="string">'-'</span>)();</span><br><span class="line"><span class="comment">// 结果2： 'a'</span></span><br><span class="line"><span class="keyword">const</span> Expected2 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 结果3： 'abc'</span></span><br><span class="line"><span class="keyword">const</span> Expected3 = join(<span class="string">''</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 结果4： 'a-b-c'</span></span><br><span class="line"><span class="keyword">const</span> Expected4 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-115"><a href="#实现方式-115" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tail&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt; = T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Rest] ? Rest : []</span><br><span class="line"><span class="keyword">type</span> StringJoin&lt;</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">    ? <span class="string">''</span></span><br><span class="line">    : P <span class="keyword">extends</span> [infer Only]</span><br><span class="line">      ? Only</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;P[<span class="number">0</span>]&#125;</span><span class="subst">$&#123;D&#125;</span><span class="subst">$&#123;StringJoin&lt;D, Tail&lt;P&gt;&gt;&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">D</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">delimiter: D</span>): &lt;<span class="title">P</span> <span class="title">extends</span> <span class="title">string</span>[] = []&gt;(<span class="params">...parts: P</span>) =&gt; <span class="title">StringJoin</span>&lt;<span class="title">D</span>, <span class="title">P</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="DeepPick-深层次Pick"><a href="#DeepPick-深层次Pick" class="headerlink" title="DeepPick(深层次Pick)"></a>DeepPick(深层次Pick)</h3><p><link-and-solution num="956"></link-and-solution></p>
<h4 id="用法-116"><a href="#用法-116" class="headerlink" title="用法"></a>用法</h4><p><code>DeepPick</code>是用来深层次获取属性值的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b: <span class="built_in">string</span>,</span><br><span class="line">  c:  <span class="built_in">boolean</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    d: <span class="built_in">number</span>,</span><br><span class="line">    e: <span class="built_in">string</span>,</span><br><span class="line">    f:  <span class="built_in">boolean</span>,</span><br><span class="line">    obj2: &#123;</span><br><span class="line">      g: <span class="built_in">number</span>,</span><br><span class="line">      h: <span class="built_in">string</span>,</span><br><span class="line">      i: <span class="built_in">boolean</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：Obj</span></span><br><span class="line"><span class="keyword">type</span> result1 = DeepPick&lt;Obj, <span class="string">''</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：&#123; a: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = DeepPick&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：&#123; a: number; &#125; &amp; &#123; obj: &#123; d: number; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result3 = DeepPick&lt;Obj, <span class="string">'a'</span>, <span class="string">'obj.d'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-116"><a href="#实现方式-116" class="headerlink" title="实现方式"></a>实现方式</h4><p>在之前，我们实现过根据属性路径取值<code>Get</code>，根据其思路我们很容易实现<code>DeepPick</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetType&lt;T, S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S1]: GetType&lt;T[S1], S2&gt; &#125;</span><br><span class="line">      : never</span><br><span class="line">    : S <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S]: T[K] &#125;</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeepPick&lt;</span><br><span class="line">  T,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> infer keys ? GetType&lt;T, keys&gt; : never</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Camelize-对象属性键转小驼峰"><a href="#Camelize-对象属性键转小驼峰" class="headerlink" title="Camelize(对象属性键转小驼峰)"></a>Camelize(对象属性键转小驼峰)</h3><p><link-and-solution num="1383"></link-and-solution></p>
<h4 id="用法-117"><a href="#用法-117" class="headerlink" title="用法"></a>用法</h4><p><code>Camelize</code>是用来将对象中的<code>key</code>全部转换为小驼峰的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  some_PROP: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123;</span><br><span class="line">    another_prop: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snake_case: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  someProp: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123; </span><br><span class="line">    anotherProp: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snakeCase: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = Camelize&lt;Person&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-117"><a href="#实现方式-117" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CamelCase&lt;S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>_<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;S1&gt;&#125;</span><span class="subst">$&#123;CamelCase&lt;Capitalize&lt;Lowercase&lt;S2&gt;&gt;&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camelize&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> CamelCase&lt;K&gt;]: </span><br><span class="line">    T[K] <span class="keyword">extends</span> [infer R]</span><br><span class="line">      ? [Camelize&lt;R&gt;]</span><br><span class="line">      : T[K] <span class="keyword">extends</span> <span class="built_in">Object</span></span><br><span class="line">        ? Camelize&lt;T[K]&gt;</span><br><span class="line">        : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详解：<code>CamelCase</code>的实现可以分为两个部分，第一部分来自于处理属性<code>key</code>转小驼峰的情况，第二部分来自于嵌套对象的情况。</p>
<ul>
<li>处理属性<code>key</code>：根据之前介绍过的<code>as</code>用法，我们可以在<code>in</code>迭代过程中使用<code>as</code>来进一步<strong>加工或者处理</strong>属性<code>key</code>，也就是<code>CamelCase</code>的部分。</li>
<li>处理嵌套对象：对于<code>T[P]</code>而言，我们考虑嵌套对象为数组和普通对象的情况，首先判断是否为数组类型，如果是则迭代数组递归调用<code>Camelize</code>；如果是普通对象，则直接调用<code>Camelize</code>；如果都不是，则直接返回<code>T[P]</code>即可。</li>
</ul>
<h3 id="DropString-移除全部字符"><a href="#DropString-移除全部字符" class="headerlink" title="DropString(移除全部字符)"></a>DropString(移除全部字符)</h3><p><link-and-solution num="2059"></link-and-solution></p>
<h4 id="用法-118"><a href="#用法-118" class="headerlink" title="用法"></a>用法</h4><p><code>DropString</code>是用来移除全部字符的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'ooar!'</span></span><br><span class="line"><span class="keyword">type</span> result = DropString&lt;<span class="string">'foobar!'</span>, <span class="string">'fb'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-118"><a href="#实现方式-118" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrngToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 | StrngToUnion&lt;S2&gt;</span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DropString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U = StrngToUnion&lt;R&gt;</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> U</span><br><span class="line">      ? DropString&lt;S2, R&gt;</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;S1&#125;</span><span class="subst">$&#123;DropString&lt;S2, R&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br></pre></td></tr></table></figure>
<p>代码详解：实现<code>DropString</code>的核心是将指定的字符串转换为联合类型，转换之后只需要迭代字符串，判断当前迭代的字符是不是在联合类型中，如果是则直接丢弃，不是则原样保留。</p>
<h3 id="Split-字符串Split方法"><a href="#Split-字符串Split方法" class="headerlink" title="Split(字符串Split方法)"></a>Split(字符串Split方法)</h3><p><link-and-solution num="2822"></link-and-solution></p>
<h4 id="用法-119"><a href="#用法-119" class="headerlink" title="用法"></a>用法</h4><p><code>Split</code>是用来实现字符串<code>split</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：["Hi!", "How", "are", "you?"]</span></span><br><span class="line"><span class="keyword">type</span> result = Split&lt;<span class="string">'Hi! How are you?'</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-119"><a href="#实现方式-119" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Split&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  SEP <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer _&#125;</span>`</span></span><br><span class="line">      ? S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;SEP&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">        ? Split&lt;S2, SEP, [...R, S1]&gt;</span><br><span class="line">        : S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">          ? SEP <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">            ? R</span><br><span class="line">            : [...R, S]</span><br><span class="line">          : [...R, S]</span><br><span class="line">      : <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure>
<h3 id="ClassPublicKeys-类的公共键"><a href="#ClassPublicKeys-类的公共键" class="headerlink" title="ClassPublicKeys(类的公共键)"></a>ClassPublicKeys(类的公共键)</h3><p><link-and-solution num="2828"></link-and-solution></p>
<h4 id="用法-120"><a href="#用法-120" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-120"><a href="#实现方式-120" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsRequiredKeys-是否为必填key"><a href="#IsRequiredKeys-是否为必填key" class="headerlink" title="IsRequiredKeys(是否为必填key)"></a>IsRequiredKeys(是否为必填key)</h3><p><link-and-solution num="2857"></link-and-solution></p>
<h4 id="用法-121"><a href="#用法-121" class="headerlink" title="用法"></a>用法</h4><p><code>IsRequiredKeys</code>是用来判断是否为必填<code>key</code>的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsRequiredKeys&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsRequiredKeys&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现方式-121"><a href="#实现方式-121" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsRequiredKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T <span class="keyword">extends</span> Record&lt;K, T[K]&gt; ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>根据<code>IsRequiredKey</code>的实现思路，我们可以很容易实现<code>IsOptionalKey</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsOptionalKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;&#125; <span class="keyword">extends</span> &#123; [P <span class="keyword">in</span> K]: T[P] &#125; ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsOptionalKey&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsOptionalKey&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="ObjectEntries-对象Object-entries方法"><a href="#ObjectEntries-对象Object-entries方法" class="headerlink" title="ObjectEntries(对象Object.entries方法)"></a>ObjectEntries(对象Object.entries方法)</h3><p><link-and-solution num="2949"></link-and-solution></p>
<h4 id="用法-122"><a href="#用法-122" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-122"><a href="#实现方式-122" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsPalindrome-是否为回文"><a href="#IsPalindrome-是否为回文" class="headerlink" title="IsPalindrome(是否为回文)"></a>IsPalindrome(是否为回文)</h3><p><link-and-solution num="4037"></link-and-solution></p>
<h4 id="用法-123"><a href="#用法-123" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-123"><a href="#实现方式-123" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="MutableKeys-所有可写键"><a href="#MutableKeys-所有可写键" class="headerlink" title="MutableKeys(所有可写键)"></a>MutableKeys(所有可写键)</h3><p><link-and-solution num="5181"></link-and-solution></p>
<h4 id="用法-124"><a href="#用法-124" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-124"><a href="#实现方式-124" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Intersection-交集"><a href="#Intersection-交集" class="headerlink" title="Intersection(交集)"></a>Intersection(交集)</h3><p><link-and-solution num="5423"></link-and-solution></p>
<h4 id="用法-125"><a href="#用法-125" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-125"><a href="#实现方式-125" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="BinaryToDecimal-二进制转十进制"><a href="#BinaryToDecimal-二进制转十进制" class="headerlink" title="BinaryToDecimal(二进制转十进制)"></a>BinaryToDecimal(二进制转十进制)</h3><p><link-and-solution num="6141"></link-and-solution></p>
<h4 id="用法-126"><a href="#用法-126" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-126"><a href="#实现方式-126" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectKeyPaths-对象属性键路径"><a href="#ObjectKeyPaths-对象属性键路径" class="headerlink" title="ObjectKeyPaths(对象属性键路径)"></a>ObjectKeyPaths(对象属性键路径)</h3><p><link-and-solution num="7258"></link-and-solution></p>
<h4 id="用法-127"><a href="#用法-127" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-127"><a href="#实现方式-127" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="TwoSum-LeetCode两数之和"><a href="#TwoSum-LeetCode两数之和" class="headerlink" title="TwoSum(LeetCode两数之和)"></a>TwoSum(LeetCode两数之和)</h3><p><link-and-solution num="8804"></link-and-solution></p>
<h4 id="用法-128"><a href="#用法-128" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-128"><a href="#实现方式-128" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ValidDate-校验是否为合法日期"><a href="#ValidDate-校验是否为合法日期" class="headerlink" title="ValidDate(校验是否为合法日期)"></a>ValidDate(校验是否为合法日期)</h3><p><link-and-solution num="9155"></link-and-solution></p>
<h4 id="用法-129"><a href="#用法-129" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-129"><a href="#实现方式-129" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Assign-对象Object-assign方法"><a href="#Assign-对象Object-assign方法" class="headerlink" title="Assign(对象Object.assign方法)"></a>Assign(对象Object.assign方法)</h3><p><link-and-solution num="9160"></link-and-solution></p>
<h4 id="用法-130"><a href="#用法-130" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-130"><a href="#实现方式-130" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Maximum-数字中的最大值"><a href="#Maximum-数字中的最大值" class="headerlink" title="Maximum(数字中的最大值)"></a>Maximum(数字中的最大值)</h3><p><link-and-solution num="9384"></link-and-solution></p>
<h4 id="用法-131"><a href="#用法-131" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-131"><a href="#实现方式-131" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="DeepCapitalize-深度首字母大写"><a href="#DeepCapitalize-深度首字母大写" class="headerlink" title="DeepCapitalize(深度首字母大写)"></a>DeepCapitalize(深度首字母大写)</h3><p><link-and-solution num="9775"></link-and-solution></p>
<h4 id="用法-132"><a href="#用法-132" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-132"><a href="#实现方式-132" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="UnionReplace-联合类型替换"><a href="#UnionReplace-联合类型替换" class="headerlink" title="UnionReplace(联合类型替换)"></a>UnionReplace(联合类型替换)</h3><p><link-and-solution num="13580"></link-and-solution></p>
<h4 id="用法-133"><a href="#用法-133" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-133"><a href="#实现方式-133" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="FizzBuzz-Fizz和Buzz输出问题"><a href="#FizzBuzz-Fizz和Buzz输出问题" class="headerlink" title="FizzBuzz(Fizz和Buzz输出问题)"></a>FizzBuzz(Fizz和Buzz输出问题)</h3><p><link-and-solution num="14080"></link-and-solution></p>
<h4 id="用法-134"><a href="#用法-134" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-134"><a href="#实现方式-134" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="RLE-运行长度编码"><a href="#RLE-运行长度编码" class="headerlink" title="RLE(运行长度编码)"></a>RLE(运行长度编码)</h3><p><link-and-solution num="14188"></link-and-solution></p>
<h4 id="用法-135"><a href="#用法-135" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-135"><a href="#实现方式-135" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectPathArray-对象键路径数组"><a href="#ObjectPathArray-对象键路径数组" class="headerlink" title="ObjectPathArray(对象键路径数组)"></a>ObjectPathArray(对象键路径数组)</h3><p><link-and-solution num="15260"></link-and-solution></p>
<h4 id="用法-136"><a href="#用法-136" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-136"><a href="#实现方式-136" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="SnakeCase-字符串下划线连接"><a href="#SnakeCase-字符串下划线连接" class="headerlink" title="SnakeCase(字符串下划线连接)"></a>SnakeCase(字符串下划线连接)</h3><p><link-and-solution num="19458"></link-and-solution></p>
<h4 id="用法-137"><a href="#用法-137" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-137"><a href="#实现方式-137" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsNegativeNumber-是否为负数"><a href="#IsNegativeNumber-是否为负数" class="headerlink" title="IsNegativeNumber(是否为负数)"></a>IsNegativeNumber(是否为负数)</h3><p><link-and-solution num="25747"></link-and-solution></p>
<h4 id="用法-138"><a href="#用法-138" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-138"><a href="#实现方式-138" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="OptionalUndefined-按需转换为可选属性"><a href="#OptionalUndefined-按需转换为可选属性" class="headerlink" title="OptionalUndefined(按需转换为可选属性)"></a>OptionalUndefined(按需转换为可选属性)</h3><p><link-and-solution num="28143"></link-and-solution></p>
<h4 id="用法-139"><a href="#用法-139" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-139"><a href="#实现方式-139" class="headerlink" title="实现方式"></a>实现方式</h4><h2 id="地狱"><a href="#地狱" class="headerlink" title="地狱"></a>地狱</h2><p>撰写中…</p>

        </div>

        
            <div class="article-tags tags">
                
                    <a href="/tags/typescript/"><i class="fa fa-tag"></i>&nbsp;&nbsp;typescript</a>
                
            </div>
        

        
            <div class="art-item-footer">
                
                    <span class="art-item-left">
                        <i class="fa fa-chevron-left" aria-hidden="true"></i>&nbsp;
                        <a href="/2024/09/18/Web移动端在线IDE-online-editor/" rel="prev" title="Web移动端在线IDE(online-editor)">
                            Web移动端在线IDE(online-editor)
                        </a>
                    </span>
                
                
                    <span class="art-item-right">
                        <a href="/2024/08/01/TypeScript教程-一/" rel="next" title="TypeScript教程(一)">
                            TypeScript教程(一)
                        </a>&nbsp;
                        <i class="fa fa-chevron-right" aria-hidden="true"></i>
                    </span>
                
            </div>
        

    </section>

</article>

<br>

<!-- 显示推荐文章和评论 -->


<script>
    window.subData = {
        title: 'TypeScript教程(二)',
        tools: true
    }
</script>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>
    
        <img class='avatar waves-image' src='https://avatars2.githubusercontent.com/u/20313228?s=400&u=81b6a332e9a0f8c63e4841766106f3c8f881cfb5&v=4' />
    
</section>


  <section class='m_widget categories'>
<div class='header'><i class="fa fa-sitemap" aria-hidden="true"></i>&nbsp;&nbsp;分类</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/css/"><div class='name'>css</div><div class='badge'>11</div></a></li>
    
        <li><a class="flat-box" href="/categories/javascript/"><div class='name'>javascript</div><div class='badge'>182</div></a></li>
    
        <li><a class="flat-box" href="/categories/nodejs/"><div class='name'>nodejs</div><div class='badge'>21</div></a></li>
    
        <li><a class="flat-box" href="/categories/python/"><div class='name'>python</div><div class='badge'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/服务器/"><div class='name'>服务器</div><div class='badge'>17</div></a></li>
    
        <li><a class="flat-box" href="/categories/计算机原理/"><div class='name'>计算机原理</div><div class='badge'>21</div></a></li>
    
    </ul>
    
</div>
</section>


  
<div class="m_widget tagcloud">
    <div class="header"><i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;标签</div>
    <div class='content'>
        <a href="/tags/3D/" style="font-size: 14.83px; color: #939393">3D</a> <a href="/tags/AI/" style="font-size: 14.83px; color: #939393">AI</a> <a href="/tags/MYSQL笔记/" style="font-size: 20.67px; color: #6c6c6c">MYSQL笔记</a> <a href="/tags/Threejs/" style="font-size: 15.67px; color: #8e8e8e">Threejs</a> <a href="/tags/WEB3/" style="font-size: 15.67px; color: #8e8e8e">WEB3</a> <a href="/tags/ajax/" style="font-size: 18.17px; color: #7d7d7d">ajax</a> <a href="/tags/canvas/" style="font-size: 14.83px; color: #939393">canvas</a> <a href="/tags/cordova/" style="font-size: 14px; color: #999">cordova</a> <a href="/tags/docker/" style="font-size: 14px; color: #999">docker</a> <a href="/tags/electron/" style="font-size: 14px; color: #999">electron</a> <a href="/tags/github/" style="font-size: 18.17px; color: #7d7d7d">github</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/html/" style="font-size: 17.33px; color: #828282">html</a> <a href="/tags/jquery/" style="font-size: 15.67px; color: #8e8e8e">jquery</a> <a href="/tags/linux/" style="font-size: 14.83px; color: #939393">linux</a> <a href="/tags/nodejs/" style="font-size: 15.67px; color: #8e8e8e">nodejs</a> <a href="/tags/npm/" style="font-size: 14px; color: #999">npm</a> <a href="/tags/typescript/" style="font-size: 15.67px; color: #8e8e8e">typescript</a> <a href="/tags/vue/" style="font-size: 21.5px; color: #666">vue</a> <a href="/tags/webSocket/" style="font-size: 14px; color: #999">webSocket</a> <a href="/tags/webpack/" style="font-size: 18.17px; color: #7d7d7d">webpack</a> <a href="/tags/web图形/" style="font-size: 18.17px; color: #7d7d7d">web图形</a> <a href="/tags/web安全/" style="font-size: 18.17px; color: #7d7d7d">web安全</a> <a href="/tags/web性能/" style="font-size: 19px; color: #777">web性能</a> <a href="/tags/worker/" style="font-size: 14.83px; color: #939393">worker</a> <a href="/tags/兼容性/" style="font-size: 15.67px; color: #8e8e8e">兼容性</a> <a href="/tags/后端/" style="font-size: 15.67px; color: #8e8e8e">后端</a> <a href="/tags/后端代理服务/" style="font-size: 14px; color: #999">后端代理服务</a> <a href="/tags/图片处理/" style="font-size: 18.17px; color: #7d7d7d">图片处理</a> <a href="/tags/基础知识/" style="font-size: 24px; color: #555">基础知识</a> <a href="/tags/少儿编程/" style="font-size: 14px; color: #999">少儿编程</a> <a href="/tags/工具库/" style="font-size: 23.17px; color: #5b5b5b">工具库</a> <a href="/tags/微信/" style="font-size: 14.83px; color: #939393">微信</a> <a href="/tags/手写/" style="font-size: 19.83px; color: #717171">手写</a> <a href="/tags/打印/" style="font-size: 14px; color: #999">打印</a> <a href="/tags/文章收集/" style="font-size: 14px; color: #999">文章收集</a> <a href="/tags/日语/" style="font-size: 18.17px; color: #7d7d7d">日语</a> <a href="/tags/样式/" style="font-size: 18.17px; color: #7d7d7d">样式</a> <a href="/tags/正则/" style="font-size: 14px; color: #999">正则</a> <a href="/tags/浏览器/" style="font-size: 16.5px; color: #888">浏览器</a> <a href="/tags/爬虫/" style="font-size: 14px; color: #999">爬虫</a> <a href="/tags/移动端/" style="font-size: 21.5px; color: #666">移动端</a> <a href="/tags/算法/" style="font-size: 15.67px; color: #8e8e8e">算法</a> <a href="/tags/编译/" style="font-size: 17.33px; color: #828282">编译</a> <a href="/tags/网络基础/" style="font-size: 20.67px; color: #6c6c6c">网络基础</a> <a href="/tags/调试/" style="font-size: 14.83px; color: #939393">调试</a> <a href="/tags/资源导航/" style="font-size: 14.83px; color: #939393">资源导航</a> <a href="/tags/软考/" style="font-size: 14px; color: #999">软考</a> <a href="/tags/面试题/" style="font-size: 22.33px; color: #606060">面试题</a> <a href="/tags/面试题系列/" style="font-size: 18.17px; color: #7d7d7d">面试题系列</a>
    </div>
</div>




      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
    <div class="social-wrapper">
      
    </div>
    <br>
    <div>博客内容遵循 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="licenses">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div>
    <div>本站使用 <a href="https://github.com/xaoxuu/hexo-theme-material-x" target="_blank" class="codename">Material-X</a> 作为主题，
		总访问量为 <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
    </div>

</footer>

  <script>setLoadingBarProgress(80);</script>
  <!-- <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script> -->
<script src="/js/jquery.min.js"></script>
<!-- <script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script> -->
<script src="/js/waves.min.js"></script>
<!-- <script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script> -->
<script src="/js/scrollreveal.min.js"></script>
<!-- 访问统计 -->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- 推荐文章 -->
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<!-- <script src="//unpkg.com/valine/dist/Valine.min.js"></script> -->
<script src="/js/jquery.fitvids.js"></script>
<script>
var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
var ALGOLIA_API_KEY = "";
var ALGOLIA_APP_ID = "";
var ALGOLIA_INDEX_NAME = "";
var AZURE_SERVICE_NAME = "";
var AZURE_INDEX_NAME = "";
var AZURE_QUERY_KEY = "";
var BAIDU_API_ID = "";
var SEARCH_SERVICE = "hexo";
var ROOT = "/"||"/";
if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


    
    
    


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
