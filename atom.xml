<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-02-18T08:56:33.335Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http请求头的安全策略</title>
    <link href="/2020/02/18/http%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%9A%84%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    <id>/2020/02/18/http请求头的安全策略/</id>
    <published>2020-02-18T07:51:36.000Z</published>
    <updated>2020-02-18T08:56:33.335Z</updated>
    
    <content type="html"><![CDATA[<p>http请求头中相关安全的头字段<br><a id="more"></a></p><h1 id="http请求头的安全策略"><a href="#http请求头的安全策略" class="headerlink" title="http请求头的安全策略"></a>http请求头的安全策略</h1><p>我们的项目在经过开发，测试之后，还得经过安全小组的安全漏斗扫描，经常会暴漏一些返回头缺少安全字段的漏洞，今天我稍加整理常用的几个。<br>如果想了解更多的请求头和响应头的字段信息，可以看本站另一篇文章，<a href="/2019/04/15/http请求头响应头字段详解/">这里</a></p><h2 id="1-X-Frame-Options"><a href="#1-X-Frame-Options" class="headerlink" title="1.X-Frame-Options"></a>1.X-Frame-Options</h2><p>如果网站可以嵌入到IFRAME元素中，则攻击者可以在社交场合设计一种情况，即受害者被指向攻击者控制的网站，该网站构成目标网站的框架。然后攻击者可以操纵受害者在目标网站上不知不觉地执行操作。即使有跨站点请求伪造保护，这种攻击也是可能的，并且被称为“clickjacking”，有关更多信息，<a href="https://www.owasp.org/index.php/Clickjacking" target="_blank" rel="noopener">请参阅</a>。为了避免这种情况，创建了“X-Frame-Options”标题。此标题允许网站所有者决定允许哪些网站构建其网站。<br>通常的建议是将此标头设置为“SAMEORIGIN”，它只允许属于同源策略的资源构成受保护资源的框架，或者设置为“DENY”，它拒绝任何资源（本地或远程）尝试框架也提供“X-Frame-Options”标头的资源。如下所示：<br>X-Frame-Options：SAMEORIGIN<br>请注意，“X-Frame-Options”标题已被弃用，将由内容安全策略中的Frame-Options指令替换，该指令仍处于活动开发阶段。但是，“X-Frame-Options”标题目前具有更广泛的支持，因此仍应实施安全措施。<br>说白了呢，就是让你的网站禁止被嵌套。<br>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;httpProtocol&gt;</span><br><span class="line">  &lt;customHeaders&gt;</span><br><span class="line">    &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt;</span><br><span class="line">  &lt;/customHeaders&gt;</span><br><span class="line">&lt;/httpProtocol&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-Content-Security-Policy"><a href="#2-Content-Security-Policy" class="headerlink" title="2.Content-Security-Policy"></a>2.Content-Security-Policy</h2><p>内容安全策略（CSP）旨在允许Web应用程序的所有者通知客户端浏览器有关应用程序的预期行为（包括内容源，脚本源，插件类型和其他远程资源），这允许浏览器更多智能地执行安全约束。虽然CSP本质上是复杂的，如果没有适当部署它可能会变得混乱，一个应用良好的CSP可以大大降低利用大多数形式的跨站点脚本攻击的机会。<br>需要整个帖子来深入了解CSP允许的功能和不同设置，因此建议进一步阅读。以下是Mozilla开发者网络对CSP的<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP" target="_blank" rel="noopener">精彩介绍性帖子</a><br>下面的简要示例显示了如何使用CSP指定您的网站希望从任何URI加载图像，从受信任的媒体提供商（包括内容分发网络）列表中插入插件内容，以及仅从您控制的服务器加载脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy：default-src&apos;self&apos;; img-src *; object-src media1.example.com media2.example.com * .cdn.example.com; script-src trustedscripts.example.com</span><br></pre></td></tr></table></figure></p><p>请注意，使用CSP的主要问题涉及策略错误配置（即使用“不安全内联”），或使用过于宽松的策略，因此在实施CSP时应特别注意。<br>这个呢，是将你引入的一切，加一个限制，这样如果别人想通过一些手段在你的网站加一些不好的东西，我们就可以有效地防止了。<br>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;httpProtocol&gt;</span><br><span class="line">  &lt;customHeaders&gt;</span><br><span class="line">    &lt;add name=&quot;Content-Security-Policy&quot; value=&quot;script-src &apos;unsafe-inline&apos; http://localhost:56504; object-src &apos;none&apos;; style-src &apos;unsafe-inline&apos; http://localhost:56504;&quot; /&gt;</span><br><span class="line">    &lt;/customHeaders&gt;</span><br><span class="line">  &lt;/httpProtocol&gt;</span><br></pre></td></tr></table></figure></p><p>其中预设值有以下这些：</p><ul><li>none 不匹配任何东西。</li><li>self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。</li><li>unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。</li><li>unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。</li></ul><h1 id="3-X-Content-Type-Options"><a href="#3-X-Content-Type-Options" class="headerlink" title="3.X-Content-Type-Options"></a>3.X-Content-Type-Options</h1><p>互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：”text/html”代表html文档，”image/png”是PNG图片，”text/css”是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。<br>例如，我们即使给一个html文档指定Content-Type为”text/plain”，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure></p><p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// php</span><br><span class="line">header(&quot;X-Content-Type-Options:nosniff&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="4-X-XSS-Protection"><a href="#4-X-XSS-Protection" class="headerlink" title="4.X-XSS-Protection"></a>4.X-XSS-Protection</h2><p>顾名思义，这个响应头是用来防范XSS的。最早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置：</p><ul><li>0：禁用XSS保护；</li><li>1：启用XSS保护；</li><li>1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；<br>浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。<br>demo:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// php</span><br><span class="line">header(&quot;X-XSS-Protection: 1&quot;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http请求头中相关安全的头字段&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图片裁剪插件</title>
    <link href="/2020/02/16/%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E6%8F%92%E4%BB%B6/"/>
    <id>/2020/02/16/图片裁剪插件/</id>
    <published>2020-02-16T07:51:13.000Z</published>
    <updated>2020-02-17T01:33:58.172Z</updated>
    
    <content type="html"><![CDATA[<p>一个图片裁剪插件，并穿给后端<br><a id="more"></a></p><h1 id="图片裁剪插件"><a href="#图片裁剪插件" class="headerlink" title="图片裁剪插件"></a>图片裁剪插件</h1><p>我们在日常开发中，裁剪图片并上传，是经常出现的需求。前几天，就有一个这样的需求，但是要求比较特殊，于是自己写了一个图片裁剪插件，因为自己写的改起来比较灵活。</p><h2 id="其实裁剪图片无非就是"><a href="#其实裁剪图片无非就是" class="headerlink" title="其实裁剪图片无非就是:"></a>其实裁剪图片无非就是:</h2><ul><li>文件选择图片，利用FileReader将文件格式的图片转成base64格式。</li><li>把这个base64格式显示在页面上，作为原图。</li><li>可以在原图的上面弄一个剪裁的方框，可以用鼠标来控制大小并移动，我觉得这里是最难的，需要很强的逻辑能力。</li><li>再利用canvas，以原图为基准，进行画图的裁剪，最后通过canvas方法得到裁剪后的base64格式图片。</li><li>最后把base64格式的图片转成Blob对象，利用ajax传送给后端。</li></ul><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="选择图片文件转base64"><a href="#选择图片文件转base64" class="headerlink" title="选择图片文件转base64"></a>选择图片文件转base64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function file2base64(imgFile, callBack) &#123;</span><br><span class="line">  var fr = new FileReader();</span><br><span class="line">  fr.onload = function() &#123;</span><br><span class="line">    // fr.result就是base64格式数据</span><br><span class="line">    callBack(fr.result);</span><br><span class="line">  &#125;</span><br><span class="line">  fr.readAsDataURL(imgFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将base64图片转化blob"><a href="#将base64图片转化blob" class="headerlink" title="将base64图片转化blob"></a>将base64图片转化blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function base64url2blob(base64url) &#123;</span><br><span class="line">  var binaryString = atob(base64url.split(&apos;,&apos;)[1]),</span><br><span class="line">        mimeType = base64url.split(&apos;,&apos;)[0].match(/:(.*?);/)[1],</span><br><span class="line">        length = binaryString.length,</span><br><span class="line">        u8arr = new Uint8Array(length),</span><br><span class="line">        blob;</span><br><span class="line">    while(length--) &#123;</span><br><span class="line">      u8arr[length] = binaryString.charCodeAt(length);</span><br><span class="line">    &#125;</span><br><span class="line">    blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;);</span><br><span class="line">    return blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图片转化为blob"><a href="#将图片转化为blob" class="headerlink" title="将图片转化为blob"></a>将图片转化为blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function img2blob(nImg, compressVal) &#123;</span><br><span class="line">  // 获取图片原始宽高</span><br><span class="line">  var cloneImg = nImg.cloneNode(true);</span><br><span class="line">  var nCanvas = document.createElement(&apos;canvas&apos;);</span><br><span class="line">  nCanvas.style.display = &apos;none&apos;;</span><br><span class="line">  document.body.appendChild(nCanvas);</span><br><span class="line">  nCanvas.width = cloneImg.width;</span><br><span class="line">  nCanvas.height = cloneImg.height;</span><br><span class="line">  var ctx = nCanvas.getContext(&quot;2d&quot;);</span><br><span class="line">  ctx.drawImage(nImg,0,0,cloneImg.width,cloneImg.height);</span><br><span class="line">  var base64Data = nCanvas.toDataURL(&quot;image/jpeg&quot;, compressVal);</span><br><span class="line">  var blob = this.base64url2blob(base64Data);</span><br><span class="line">  return blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是几个重要的格式转换方法。<br>最后，贴出源码demo，里边包含后端接收的nodejs代码。<br><a href="https://github.com/jinux7/study-collections/tree/master/image-clipper-upload" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个图片裁剪插件，并穿给后端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="图片处理" scheme="/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手写一个自己的webpack</title>
    <link href="/2020/01/31/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84webpack/"/>
    <id>/2020/01/31/手写一个自己的webpack/</id>
    <published>2020-01-31T07:51:30.000Z</published>
    <updated>2020-01-31T09:24:16.564Z</updated>
    
    <content type="html"><![CDATA[<p>一个超级简化版的webpack打包工具<br><a id="more"></a></p><h1 id="手写一个自己的webpack"><a href="#手写一个自己的webpack" class="headerlink" title="手写一个自己的webpack"></a>手写一个自己的webpack</h1><p>webpack现在用的人非常多，我们在开发vue，react，angular的时候默认的打包工具就是webpack，作为一名前端开发者来说，webpack是现在必须掌握的技能之一。随着webpack版本的不断增加，功能和复杂度越来越高，会配置的话都得学一阵子，但是，抛开使用来说，想没想过它的原理是什么？如果自己写一个该从哪里入手呢，今天我就写一个简化版的webpack。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>简化版的webpack，实现了它的最基础的功能，也就是模块化的引用处理，比如，main.js文件依赖了a.js文件，使用es6的语法import语法，浏览器是不支持的，需要用工具打包成浏览器支持的语法，我就实现这个最基础的功能。</p><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>打包文件，首先需要分析代码，比如，入口文件main.js，分析出import语句，都依赖哪些文件，再去读取这些依赖的文件，而分析js代码就需要babel这个工具库，babel工具库可以将es6代码转换成es5，es3代码，功能特别强大。</p><h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><p>这里，依赖babel的3个工具，分别是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;@babel/core&quot;: &quot;^7.8.3&quot;,</span><br><span class="line">&quot;@babel/parser&quot;: &quot;^7.8.3&quot;,</span><br><span class="line">&quot;@babel/traverse&quot;: &quot;^7.8.3&quot;</span><br></pre></td></tr></table></figure></p><p>parser是用来将js代码解析成ast语法书。<br>traverse可以将ast语法书进行遍历，对相应的ast语法书节点做单独的获取或者处理。<br>babel-core是babel的核心，可以将es6的js代码或ast语法书转化成es5代码。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>用paser将es6的代码先转成ast语法树</p><h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>用traverse处理ast语法书中的import节点，获取依赖文件路径，并获取依赖文件的代码，重复做步骤1，步骤2的处理。</p><h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>用babel-core将获取到的文件全部转成es5语法。</p><h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>最后把这些文件拼接成一个可执行的js代码，保存起来，html直接引用就可以执行了。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>上面步骤都说了，但是还是有点抽象，下面贴出代码，一目了然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const parser = require(&apos;@babel/parser&apos;);</span><br><span class="line">const traverse = require(&apos;@babel/traverse&apos;).default;</span><br><span class="line">const babel = require(&apos;@babel/core&apos;);</span><br><span class="line"></span><br><span class="line">let ID = 0;</span><br><span class="line">function createAsset(fileName) &#123;</span><br><span class="line">  // 这个文件里所依赖的其它文件路径</span><br><span class="line">  let dependencies = [];</span><br><span class="line">  const content = fs.readFileSync(fileName, &apos;utf8&apos;);</span><br><span class="line">  // 用babel的parser来解析读取的的文件内容content,获取ast抽象语法书</span><br><span class="line">  const ast = parser.parse(content, &#123;</span><br><span class="line">    sourceType: &apos;module&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 用babel的traverse功能来观察ast语法树的相应节点，进行相应的处理</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration(&#123; node &#125;) &#123;</span><br><span class="line">      // console.log(node.source.value);</span><br><span class="line">      dependencies.push(node.source.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 用babel来讲es6语法转成es5语法</span><br><span class="line">  const &#123; code &#125; = babel.transformFromAstSync(ast, null, &#123;</span><br><span class="line">    presets: [&apos;@babel/preset-env&apos;]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  let id = ID++;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    id,</span><br><span class="line">    fileName,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createGraph() &#123;</span><br><span class="line">  const mainAsset = createAsset(&apos;./src/main.js&apos;);</span><br><span class="line">  // 队列存放单个文件资源,这里利用循环队列去搜寻依赖文件，而没有使用递归方法</span><br><span class="line">  const queue = [ mainAsset ];</span><br><span class="line">  for(const asset of queue) &#123;</span><br><span class="line">    const dirname = path.dirname(asset.fileName);</span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line">    asset.dependencies.forEach(relativePath =&gt; &#123;</span><br><span class="line">      const absolutePath = path.join(dirname, relativePath);</span><br><span class="line">      const child = createAsset(absolutePath);</span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return queue;</span><br><span class="line">&#125;</span><br><span class="line">// 打包生成处理后的js文件</span><br><span class="line">function bundle() &#123;</span><br><span class="line">  const graph = createGraph(&apos;./src/main.js&apos;);</span><br><span class="line">  let modules = ``;</span><br><span class="line">  graph.forEach(mod=&gt; &#123;</span><br><span class="line">    modules += `</span><br><span class="line">      $&#123;mod.id&#125;: [</span><br><span class="line">        function(require, module, exports) &#123;</span><br><span class="line">          $&#123;mod.code&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        $&#123;JSON.stringify(mod.mapping)&#125;</span><br><span class="line">      ],</span><br><span class="line">    `;</span><br><span class="line">  &#125;);</span><br><span class="line">  const result = `(function(modules) &#123;</span><br><span class="line">    function require(id) &#123;</span><br><span class="line">      const fn = modules[id][0],</span><br><span class="line">            mapping = modules[id][1];</span><br><span class="line">      function localRequire(relativePath) &#123;</span><br><span class="line">        return require(mapping[relativePath]);</span><br><span class="line">      &#125;</span><br><span class="line">      const module = &#123;</span><br><span class="line">        exports: &#123;&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn(localRequire, module, module.exports);</span><br><span class="line">      return module.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    require(0);</span><br><span class="line">  &#125;)(&#123;$&#123;modules&#125;&#125;)`;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = bundle();</span><br><span class="line">fs.writeFileSync(&apos;./dist/bundle.js&apos;, result);</span><br></pre></td></tr></table></figure></p><h2 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99webpack/nux-webpack" target="_blank" rel="noopener">截这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个超级简化版的webpack打包工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>简单的聊聊iframe</title>
    <link href="/2020/01/19/%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E8%81%8Aiframe/"/>
    <id>/2020/01/19/简单的聊聊iframe/</id>
    <published>2020-01-19T06:11:04.000Z</published>
    <updated>2020-01-19T06:41:47.197Z</updated>
    
    <content type="html"><![CDATA[<p>iframe在html中的简单使用<br><a id="more"></a></p><h1 id="简单的聊聊iframe"><a href="#简单的聊聊iframe" class="headerlink" title="简单的聊聊iframe"></a>简单的聊聊iframe</h1><p>我们在前端开发中，iframe的使用场景很多，即便是vue，react时代，我还是乐此不疲的在项目中使用iframe，因为它会隔离页面彼此的环境，避免造成一些不必要的干扰。</p><h2 id="在同域下使用iframe"><a href="#在同域下使用iframe" class="headerlink" title="在同域下使用iframe"></a>在同域下使用iframe</h2><p>在同域下使用iframe,父级页面可以获取iframe页面里的信息，还可以操作iframe页面中的内容。<br><a href="https://github.com/jinux7/study-collections/tree/master/iframe/same-origin" target="_blank" rel="noopener">案例</a><br>在同域下没什么好说的，父页面可以随意控制子页面。</p><h2 id="跨域下使用iframe"><a href="#跨域下使用iframe" class="headerlink" title="跨域下使用iframe"></a>跨域下使用iframe</h2><p>跨域下使用iframe,父页面是不能操作子页面的，但是子页面可以操作父页面。<br>而且，后台返回的头信息，还能够更加严格的控制iframe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;DENY&apos;); // 不允许此页面被iframe加载</span><br><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;SAMEORIGIN&apos;); // 只可以在相同域名下加载</span><br><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;allow-from http://baidu.com/&apos;); // 允许指定的url加载iframe,但是这个属性在chrome,firefox,opera并不好使,只在edge中兼容</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/jinux7/study-collections/tree/master/iframe/cross-origin" target="_blank" rel="noopener">案例</a><br>目前为止，没有找到跨域控制iframe页面内容的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iframe在html中的简单使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构的JavaScript实现</title>
    <link href="/2019/11/28/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/"/>
    <id>/2019/11/28/常用数据结构的JavaScript实现/</id>
    <published>2019-11-28T08:12:54.000Z</published>
    <updated>2019-11-28T08:16:47.245Z</updated>
    
    <content type="html"><![CDATA[<p>一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现<br><a id="more"></a></p><h1 id="常用数据结构的JavaScript实现"><a href="#常用数据结构的JavaScript实现" class="headerlink" title="常用数据结构的JavaScript实现"></a>常用数据结构的JavaScript实现</h1><p>觉得这篇文章很不错，收藏下来，感谢作者。<br><a href="https://mp.weixin.qq.com/s/04PFD6dHhUjdh7wpT33UMQ" target="_blank" rel="noopener">这里是连接哦</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux的常用操作</title>
    <link href="/2019/11/28/linux%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>/2019/11/28/linux的常用操作/</id>
    <published>2019-11-28T01:46:55.000Z</published>
    <updated>2020-02-04T01:52:10.250Z</updated>
    
    <content type="html"><![CDATA[<p>linux的一些基础常用操作<br><a id="more"></a></p><h1 id="linux的常用操作"><a href="#linux的常用操作" class="headerlink" title="linux的常用操作"></a>linux的常用操作</h1><h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><p>在linux下安装应用的方法有很多，我也尝试了好几种，最后感觉还是用yum安装方便。<br>在使用yum安装应用的时候需要配置一下yum源，这里写出两条命令，常用的应用软件都已经有了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -O http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="文件的移动"><a href="#文件的移动" class="headerlink" title="文件的移动"></a>文件的移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将repo结尾的文件移动到当前目录的back文件夹下</span><br><span class="line">mv *.repo ./back</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、删除文件命令</span><br><span class="line">rm -f 文件名</span><br><span class="line">将会强行删除文件，且无提示</span><br><span class="line">需要注意：</span><br><span class="line">使用rm -rf要格外注意，linux中没有回收站，慎重删除</span><br><span class="line">2、删除文件夹以及文件夹中的所有文件命令：</span><br><span class="line">rm -rf 目录名字</span><br><span class="line">其中：</span><br><span class="line">-r：向下递归删除</span><br><span class="line">-f：直接强行删除，且没有任何提示</span><br></pre></td></tr></table></figure><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep node</span><br></pre></td></tr></table></figure><h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><h3 id="搜索一个程序所在位置"><a href="#搜索一个程序所在位置" class="headerlink" title="搜索一个程序所在位置"></a>搜索一个程序所在位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">whereis &lt;程序名称&gt;</span><br><span class="line">查找软件的安装路径</span><br><span class="line">-b 只查找二进制文件</span><br><span class="line">-m 只查找帮助文件</span><br><span class="line">-s 只查找源代码</span><br><span class="line">-u 排除指定类型文件</span><br><span class="line">-f 只显示文件名</span><br><span class="line">-B &lt;目录&gt; 在指定目录下查找二进制文件</span><br><span class="line">-M &lt;目录&gt; 在指定目录下查找帮助文件</span><br><span class="line">-S &lt;目录&gt; 在指定目录下查找源代码</span><br></pre></td></tr></table></figure><h3 id="查找一个文件夹所在目录"><a href="#查找一个文件夹所在目录" class="headerlink" title="查找一个文件夹所在目录"></a>查找一个文件夹所在目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &lt;文件名&gt;</span><br></pre></td></tr></table></figure><h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><p>使用之前确保安装了lrzsz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lrzsz</span><br></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><h3 id="开启nginx服务"><a href="#开启nginx服务" class="headerlink" title="开启nginx服务"></a>开启nginx服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf.default</span><br><span class="line">// 以我的nginx安装目录为例，nginx.conf.default这个文件就是nginx的主默认配置文件</span><br></pre></td></tr></table></figure><h2 id="压缩和解压zip"><a href="#压缩和解压zip" class="headerlink" title="压缩和解压zip"></a>压缩和解压zip</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装zip</span><br><span class="line">yum install zip</span><br><span class="line">// 安装unzip</span><br><span class="line">yum install unzip</span><br></pre></td></tr></table></figure><h3 id="使用zip"><a href="#使用zip" class="headerlink" title="使用zip"></a>使用zip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：</span><br><span class="line">zip -q -r html.zip /home/html</span><br><span class="line">// 如果在我们在 /home/html 目录下，可以执行以下命令：</span><br><span class="line">zip -q -r html.zip *</span><br></pre></td></tr></table></figure><h3 id="使用unzip"><a href="#使用unzip" class="headerlink" title="使用unzip"></a>使用unzip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 它会默认将文件解压到当前目录 </span><br><span class="line"># unzip test.zip </span><br><span class="line">// 如果要解压到指定目录，可以加上 -d 选项</span><br><span class="line"># unzip test.zip -d /root/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的一些基础常用操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>chrome浏览器设置可跨域</title>
    <link href="/2019/11/20/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%8F%AF%E8%B7%A8%E5%9F%9F/"/>
    <id>/2019/11/20/chrome浏览器设置可跨域/</id>
    <published>2019-11-20T07:39:35.000Z</published>
    <updated>2019-11-20T08:02:01.960Z</updated>
    
    <content type="html"><![CDATA[<p>chrome浏览器设置可跨域<br><a id="more"></a></p><h1 id="chrome浏览器设置可跨域"><a href="#chrome浏览器设置可跨域" class="headerlink" title="chrome浏览器设置可跨域"></a>chrome浏览器设置可跨域</h1><p>跨域方法很多种，我比较喜欢简单粗暴的修改chrome配置<br>1.先chrome鼠标右键打开下，点击打开属性，出现下面这幅图<br><img src="/2019/11/20/chrome浏览器设置可跨域/1.png" alt="img"><br>2.将下面的这段粘贴在目标的字符串的后面，注意要隔着一个空格<br>chrome版本49之前：–disable-web-security<br>chrome版本49之后：open -a Google\ Chrome –args –disable-web-security –user-data-dir</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;chrome浏览器设置可跨域&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>css初始化</title>
    <link href="/2019/10/30/css%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>/2019/10/30/css初始化/</id>
    <published>2019-10-30T08:16:54.000Z</published>
    <updated>2019-10-30T08:31:54.672Z</updated>
    
    <content type="html"><![CDATA[<p>css的初始化设计<br><a id="more"></a></p><h1 id="css初始化"><a href="#css初始化" class="headerlink" title="css初始化"></a>css初始化</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">charset</span> <span class="string">"utf-8"</span>;<span class="selector-tag">html</span>&#123;<span class="attribute">background-color</span>:<span class="number">#fff</span>;<span class="attribute">color</span>:<span class="number">#000</span>;<span class="attribute">font-size</span>:<span class="number">12px</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">legend</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">xmp</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">xmp</span>,<span class="selector-tag">tt</span>,<span class="selector-tag">code</span>,<span class="selector-tag">kbd</span>,<span class="selector-tag">samp</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5</span>;<span class="attribute">font-family</span>:tahoma,arial,<span class="string">"Hiragino Sans GB"</span>,simsun,sans-serif&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">small</span>,<span class="selector-tag">big</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">font-family</span>:tahoma,arial,<span class="string">"Hiragino Sans GB"</span>,<span class="string">"微软雅黑"</span>,simsun,sans-serif&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">b</span>,<span class="selector-tag">strong</span>&#123;<span class="attribute">font-weight</span>:normal&#125;</span><br><span class="line"><span class="selector-tag">address</span>,<span class="selector-tag">cite</span>,<span class="selector-tag">dfn</span>,<span class="selector-tag">em</span>,<span class="selector-tag">i</span>,<span class="selector-tag">optgroup</span>,<span class="selector-tag">var</span>&#123;<span class="attribute">font-style</span>:normal&#125;</span><br><span class="line"><span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;<span class="attribute">border-spacing</span>:<span class="number">0</span>;<span class="attribute">text-align</span>:left&#125;</span><br><span class="line"><span class="selector-tag">caption</span>,<span class="selector-tag">th</span>&#123;<span class="attribute">text-align</span>:inherit&#125;</span><br><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">menu</span>&#123;<span class="attribute">list-style</span>:none&#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>,<span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">object</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">vertical-align</span>:middle&#125;</span><br><span class="line"><span class="selector-tag">article</span>,<span class="selector-tag">aside</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">figcaption</span>,<span class="selector-tag">hgroup</span>,<span class="selector-tag">details</span>,<span class="selector-tag">menu</span>&#123;<span class="attribute">display</span>:block&#125;</span><br><span class="line">audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>,<span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,<span class="selector-tag">q</span><span class="selector-pseudo">:before</span>,<span class="selector-tag">q</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>:<span class="string">"\0020"</span>&#125;</span><br><span class="line"><span class="selector-tag">textarea</span>&#123;<span class="attribute">overflow</span>:auto;<span class="attribute">resize</span>:vertical&#125;</span><br><span class="line"><span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>,<span class="selector-tag">a</span>&#123;<span class="attribute">outline</span>:<span class="number">0</span> none;<span class="attribute">border</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::-moz-focus-inner</span>,<span class="selector-tag">input</span><span class="selector-pseudo">::-moz-focus-inner</span>&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">mark</span>&#123;<span class="attribute">background-color</span>:transparent&#125;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">ins</span>,<span class="selector-tag">s</span>,<span class="selector-tag">u</span>,<span class="selector-tag">del</span>&#123;<span class="attribute">text-decoration</span>:none&#125;</span><br><span class="line"><span class="selector-tag">sup</span>,<span class="selector-tag">sub</span>&#123;<span class="attribute">vertical-align</span>:baseline&#125;</span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">overflow-x</span>: hidden;<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">font-size</span>: <span class="number">50px</span>;<span class="attribute">-webkit-tap-highlight-color</span>: transparent;&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: Arial, <span class="string">"Microsoft Yahei"</span>, <span class="string">"Helvetica Neue"</span>, Helvetica, sans-serif;<span class="attribute">color</span>: <span class="number">#333</span>;<span class="attribute">font-size</span>: .<span class="number">28em</span>;<span class="attribute">line-height</span>: <span class="number">1</span>;<span class="attribute">-webkit-text-size-adjust</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">hr</span> &#123;<span class="attribute">height</span>: .<span class="number">02rem</span>;<span class="attribute">margin</span>: .<span class="number">1rem</span> <span class="number">0</span>;<span class="attribute">border</span>: medium none;<span class="attribute">border-top</span>: .<span class="number">02rem</span> solid <span class="number">#cacaca</span>;&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="number">#25a4bb</span>;<span class="attribute">text-decoration</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">input</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;<span class="comment">/*屏蔽阴影*/</span></span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(0,0,0,0);</span><br><span class="line">    <span class="comment">/*ios android去除自带阴影的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止长按链接与图片弹出菜单 */</span></span><br><span class="line">    <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止选中文本(如无文本选中需求,此为必选项) */</span></span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;  </span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">-webkit-overflow-scrolling: touch; // ios滑动不卡顿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css的初始化设计&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="样式" scheme="/tags/%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>VUE自定义组件v-model使用</title>
    <link href="/2019/10/22/VUE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6v-model%E4%BD%BF%E7%94%A8/"/>
    <id>/2019/10/22/VUE自定义组件v-model使用/</id>
    <published>2019-10-22T05:55:13.000Z</published>
    <updated>2019-10-22T06:18:00.062Z</updated>
    
    <content type="html"><![CDATA[<p>vue中自定义组件v-model双向数据绑定的使用<br><a id="more"></a></p><h1 id="VUE自定义组件v-model使用"><a href="#VUE自定义组件v-model使用" class="headerlink" title="VUE自定义组件v-model使用"></a>VUE自定义组件v-model使用</h1><p>我们在写vue组建的时候，可以往组件里传prop，但是普通的属性都是单向数据流，要想在子组件里修改父组件里值，必须在父组件中定义一个事件，在子组件里<code>this.$emit(&#39;事件名&#39;,&#39;...参数&#39;)</code>,但是我觉得好麻烦，要想实现数据的双向绑定还得定义子组件调用的事件方法，我们可以直接使用<code>v-model</code>,可以简单些。<br>父组件代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Child v-model=<span class="string">"val"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      val: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子组件代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;val&#125;&#125;</span><br><span class="line">    &lt;div @click=<span class="string">"changeVal"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: [<span class="string">'val'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeVal () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="number">456</span>); <span class="comment">// 注意这里默认是input事件哦</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是双向数据绑定写着会简单些。<br>最后，看一下vue中v-model的语法糖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"price"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> :value=<span class="string">"price"</span> @input=<span class="string">"price=$event.target.value"</span>&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue中自定义组件v-model双向数据绑定的使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端优化之Pre技术简介</title>
    <link href="/2019/10/14/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E4%B9%8BPre%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/"/>
    <id>/2019/10/14/前端优化之Pre技术简介/</id>
    <published>2019-10-14T05:06:31.000Z</published>
    <updated>2019-10-14T05:23:30.164Z</updated>
    
    <content type="html"><![CDATA[<p>link标签中pre技术的介绍<br><a id="more"></a></p><h1 id="前端优化之Pre技术简介"><a href="#前端优化之Pre技术简介" class="headerlink" title="前端优化之Pre技术简介"></a>前端优化之Pre技术简介</h1><p>Pre技术：预加载技术。提供在不影响当前页面情况下，浏览器预加载资源的性能优化方案。</p><h2 id="DNS-Prefetch"><a href="#DNS-Prefetch" class="headerlink" title="DNS Prefetch"></a>DNS Prefetch</h2><p>就是上述提到的，用于告知浏览器，尽可能预先解析指定域名的DNS。使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"//the-domain-to-be-prefetched.com"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>至于兼容性，可以说是目前为止所有的Pre技术里最好的了，<a href="http://caniuse.com/#search=dns-prefetch" target="_blank" rel="noopener">兼容性查看</a><br>IE是从IE9开始支持DNS Prefetch的，但是，是从IE10开始支持dns-prefetch。IE9里，并不是使用dns-prefetch来定义一个DNS的预解析，而是使用prefetch。挺尴尬的，因为prefetch在w3规范里又被用到了另一个Pre技术，下面会讲到。</p><h2 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h2><p>预连接。和DNS Prefetch类似，但是，更进一步。它不仅要求浏览器预解析指定域名的DNS，还需要预先与服务器握手以及TLS协商（如果使用了HTTPS）。使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//the-domain-to-be-preconnect.com"</span> crossorigin=<span class="string">"anonymous"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p><a href="http://caniuse.com/#search=preconnect" target="_blank" rel="noopener">兼容性查看</a><br>由于会与服务器握手，因此，就需要确定“是否跨域”。和script类似，带crossorigin属性，以告知浏览器如何处理跨域和cookie。</p><h2 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h2><p>上述DNS Prefetch里提到过，IE9里使用的DNS Prefetch类型名是prefetch，但是，这个类型名在规范里又被用于另外一个意图。<br>Prefetch：预获取，在Preconnect基础上更进一步，它要求浏览器获取整个的指定资源，link[href]值指定的是某个具体资源，而不是简单的一个域名了。除了和Preconnect一样拥有rel、href和crossorigin外，还有as，可用于告知浏览器资源类型，这个类型和MIME不一样，是一个统称类型，比如：所有的图片都是as=”image”，JS的是as=”script”，HTML的是 as=”html”等，<a href="https://fetch.spec.whatwg.org/#concept-request-destination" target="_blank" rel="noopener">具体可以参考</a>。<br>使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"//the-domain.com/prefetch.js"</span> crossorigin <span class="keyword">as</span>=<span class="string">"script"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>as属性并不是必须的，但是建议加上，以便浏览器能更好的添加请求Header来优化资源的获取。<br>使用Prefetch，整个资源都会被加载，但是，浏览器不允许对资源预处理或执行，资源只是被提前加载，并缓存起来，以便将来使用。<a href="http://caniuse.com/#search=prefetch" target="_blank" rel="noopener">兼容性查看</a></p><h2 id="Prerender"><a href="#Prerender" class="headerlink" title="Prerender"></a>Prerender</h2><p>预渲染。与Prefetch类似，浏览器会下载整个资源，但是，Prefetch不允许浏览器对资源做预处理和执行，而Prerender则会告知浏览器，下载资源（HTML）并解析/执行它，包括被解析资源的子资源，这意味着会下载该HTML中的图片、样式、脚本等等。<br>Prerender没有as属性，它下载的是HTML，使用方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//the-domain-to-be-preconnect.com"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>由于不允许对当前页面产生影响，浏览器设置预渲染的页面visibilityState属性为hidden。<a href="http://caniuse.com/#search=prerender" target="_blank" rel="noopener">兼容性查看</a><br>建议少用这个，太耗资源。而且，查看上述兼容性，你会看到Chrome 58里又把这个功能干掉了。</p><h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>预加载。这是一个和Prefetch几乎一模一样的功能，但是，其加载的资源适用的场景又完全不一样。使用方式只是将上述Prefetch中的prefetch改成preload。其他的完全一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"//the-domain.com/prefetch.png"</span> crossorigin <span class="keyword">as</span>=<span class="string">"image"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>与Prefetch*不同之处在于：</p><ul><li>Prefetch的优先级很低，低到浏览器可以不加载</li><li>Preload的优先级很高，浏览器一定要加载</li><li>Prefetch加载的资源用于将来某个页面中（这意味着它可能压根不会被用到）</li><li>Preload加载的资源用于当前页面中</li></ul><p>所以，在使用prefetch还是preload时候，需要考虑上述的不同点，而不应该盲目使用。[Preload以前叫Subresource]<br><a href="http://caniuse.com/#search=preload" target="_blank" rel="noopener">兼容性查看</a><br>最后，上述Pre技术，除了Preload，其他的Pre都可能“不被浏览器执行”，这不是兼容性的问题，而是，这些Pre都不是浏览器必须行为，浏览器会根据一定的策略决定是否Pre相应的资源或操作，这些策略包括：CPU、内存等的占用率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;link标签中pre技术的介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>&lt;script&gt;标签的defer,async,module</title>
    <link href="/2019/10/14/script-%E6%A0%87%E7%AD%BE%E7%9A%84defer-async-module/"/>
    <id>/2019/10/14/script-标签的defer-async-module/</id>
    <published>2019-10-14T03:15:11.000Z</published>
    <updated>2019-10-14T04:32:47.370Z</updated>
    
    <content type="html"><![CDATA[<p><code>&lt;script&gt;</code>标签中defer,async,module的使用<br><a id="more"></a></p><h1 id="lt-script-标签的defer-async-module"><a href="#lt-script-标签的defer-async-module" class="headerlink" title="&lt;script>标签的defer,async,module"></a>&lt;script>标签的defer,async,module</h1><h2 id="defer-amp-async"><a href="#defer-amp-async" class="headerlink" title="defer&amp;async"></a>defer&amp;async</h2><p>传统方法<br>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"application/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">// module code</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="application/</span>javascript<span class="string">" src="</span>path/to/myModule.js<span class="string">"&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=”application/javascript”可以省略。<br>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。<br>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>&lt;script&gt;</code>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。<br>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>加载规则<br>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入type=”module”属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。<br>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。<br><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>一旦使用了async属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。<br>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">"./utils.js"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>对于外部的模块脚本（上例是foo.js），有几点需要注意。</li><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明use strict。</li><li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li><li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。<br>下面是一个示例模块。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="keyword">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中defer,async,module的使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>测试相关术语整理</title>
    <link href="/2019/10/12/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E6%95%B4%E7%90%86/"/>
    <id>/2019/10/12/测试相关术语整理/</id>
    <published>2019-10-12T07:38:38.000Z</published>
    <updated>2019-10-12T07:55:59.342Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一些测试的相关术语<br><a id="more"></a></p><h1 id="测试相关术语整理"><a href="#测试相关术语整理" class="headerlink" title="测试相关术语整理"></a>测试相关术语整理</h1><p>作为一名前端开发工程师，工作中肯定会和测试同事打交道，为了不丢面子，一些测试用语还是应该知道滴。</p><ul><li>Unit testing（单元测试），指一段代码的基本测试，其实际大小是未定的，通常是一个函数或子程序，一般由开发者执行。</li><li>Integration testing（集成测试），被测试系统的所有组件都集成在一起，找出被测试系统组件之间关系和接口中的错误。该测试一般在单元测试之后进行。</li><li>Acceptance testing（验收测试），系统开发生命周期方法论的一个阶段，这时相关的用户和／或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。这是管理性和防御性控制。</li><li>Alpha testing (α测试),是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。</li><li>Beta testing(β测试),测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。</li><li>Black box testing（黑盒测试），指测试人员不关心程序具体如何实现的一种测试方法。根据软件的规格对软件进行各种输入和观察软件的各种输出结果来发现软件的缺陷的测试，这类测试不考虑软件内部的运作原理，因此软件对用户来说就像一个黑盒子。</li><li>White box testing（白盒测试），根据软件内部的工作原理分析来进行测试,基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。</li><li>Automated Testing（自动化测试），使用自动化测试工具来进行测试，这类测试一般不需要人干预，通常在GUI、性能等测试中用得较多。</li><li>Bug (错误)，有时称作defect（缺陷）或error（错误），软件程序中存在的编程错误，可能会带来不必要的副作用，软件的功能和特性与设计规格说明书或用户需求不一致的方面。软件缺陷表现特征为：软件未达到产品说明书标明的功能；软件出现产品说明书指明不会出现的错误；软件功能超出产品说明书指明的范围；虽然产品说明书未指出但是软件应达到的目标；软件测试人员或用户认为软件难以理解，不易使用，运行速度缓慢等问题。 Bug report（错误报告），也称为“Bug record（错误记录）”，记录发现的软件错误信息的文档，通常包括错误描述、复现步骤、抓取的错误图像和注释等。</li><li>Bug tracking system（错误跟踪系统，BTS），也称为“Defect tracking system，DTS”，管理软件测试缺陷的专用数据库系统，可以高效率地完成软件缺陷的报告、验证、修改、查询、统计、存储等任务。尤其适用于大型多语言软件的测试管理。</li><li>“抓虫大扫除”（Bug Bash）：在某一个版本的发行里程碑到达之后，在发行之前项目经理向全体开发组织发出通知，告诉大家哪一天的某个时间是Bug Bash的时间，到时候全体成员，包括开发、测试、文档等团队、甚至市场部门的员工，全都放下手中的工作，在规定的那一个或几个小时的时间里，每个人把自己当作是用户一样来使用这个未成品的软件，并且进行竞赛，看谁能找到最多的Bug。这样做的目的是，不是按照测试方案的顺序来检查软件，而是通过像真正的用户那样来使用软件，即完全是任意性的、无规则的顺序，看看在这样的使用条件下，还有没有仍旧没有被发现的严重的Bug。我们往往采用谁找到最严重的Bug 就得奖的方法来鼓励大家尽力找出Bug。抓虫大扫除一结束，项目经理马上进行新呈交的Bug数量的统计，然后向开发组织中的全体员工公布。得奖的小有免费的咖啡、午餐、电影票等，大有各种礼物。所以每次Bug Bash 大家都踊跃参加，找到很多测试案例执行时没找到的问题。</li><li>Exception（异常/例外），一个引起正常程序执行挂起的事件。</li><li>Crash（崩溃），计算机系统或组件突然并完全的丧失功能，例如软件或系统突然退出或没有任何反应（死机）。</li><li>Build（工作版本），软件开发过程中用于内部测试的功能和性能等不完善的软件版本。工作版本既可以是系统的可操作版本，也可以是展示要在最终产品中提供的部分功能的部分系统。</li><li>Functional testing (功能测试)，也称为behavioral testing（行为测试），根据产品特征、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化软件的功能测试，用于验证应用程序或网站对目标用户能正确工作。使用适当的平台、浏览器和测试脚本，以保证目标用户的体验将足够好，就像应用程序是专门为该市场开发的一样。</li><li>Load testing（负载测试），通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。在这种测试中，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力。负载测试的目标是确定并确保系统在超出最大预期工作量的情况下仍能正常运行。此外，负载测试还要评估性能特征，例如，响应时间、事务处理速率和其他与时间相关的方面。</li><li>Performance testing（性能测试），评价一个产品或组件与性能需求是否符合的测试。包括负载测试、强度测试、数据库容量测试、基准测试等类型。</li><li>Pilot testing（引导测试），软件开发中，验证系统在真实硬件和客户基础上处理典型操作的能力。在软件外包测试中，引导测试通常是客户检查软件测试公司测试能力的一种形式，只有通过了客户特定的引导测试，软件测试公司才能接受客户真实软件项目的软件测试。</li><li>Portability testing（可移植性测试），测试软件是否可以被成功移植到指定的硬件或软件平台上。</li><li>Compatibility Testing（兼容性测试），也称“Configuration testing（配置测试）”，测试软件是否和系统的其它与之交互的元素之间兼容，如：浏览器、操作系统、硬件等。验证测试对象在不同的软件和硬件配置中的运行情况。</li><li>Installing testing（安装测试），确保该软件在正常情况和异常情况的不同条件下，例如，进行首次安装、升级、完整的或自定义的安装都能进行安装。异常情况包括磁盘空间不足、缺少目录创建权限等。核实软件在安装后可立即正常运行。安装测试包括测试安装代码以及安装手册。安装手册提供如何进行安装，安装代码提供安装一些程序能够运行的基础数据。</li><li>International testing（国际化测试），国际化测试的目的是测试软件的国际化支持能力，发现软件的国际化的潜在问题，保证软件在世界不同区域中都能正常运行。国际化测试使用每种可能的国际输入类型，针对任何区域性或区域设置检查产品的功能是否正常，软件国际化测试的重点在于执行国际字符串的输入/输出功能。国际化测试数据必须包含东亚语言、德语、复杂脚本字符和英语（可选）的混合字符。</li><li>Localizability testing(本地化能力测试)，本地化能力是指不需要重新设计或修改代码，将程序的用户界面翻译成任何目标语言的能力。为了降低本地化能力测试的成本，提高测试效率，本地化能力侧是通常在软件的伪本地化版本上进行。本地化能力测试中发现的典型错误包括：字符的硬编码（即软件中需要本地化的字符写在了代码内部），对需要本地化的字符长度设置了国定值，在软件运行时以控件位置定位，图标和位图中包含了需要本地化的文本，软件的用户界面与文档术语不一致等。</li><li>Localization testing（本地化测试），本地化测试的对象是软件的本地化版本。本地化测试的目的是测试特定目标区域设置的软件本地化质量。本地化测试的环境是在本地化的操作系统上安装本地化的软件。从测试方法上可以分为基本功能测试，安装/卸载测试，当地区域的软硬件兼容性测试。测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和联机帮助等部分。</li><li>Ad hoc testing (随机测试)，没有书面测试用例、记录期望结果、检查列表、脚本或指令的测试。主要是根据测试者的经验对软件进行功能和性能抽查。随机测试是根据测试说明书执行用例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</li><li>Smoke testing（冒烟测试），冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作。冒烟测试的执行者是版本编译人员。参考“Sanity testing（健全测试）”。</li><li>Sanity testing（健全测试），软件主要功能成分的简单测试以保证它是否能进行基本的测试。</li><li>User interface（用户界面，UI），广义是指使用户可以和计算机进行交互的硬件和/或软件。狭义是指软件中的可见外观及其底层与用户交互的部分（菜单、对话框、窗口和其它控件）。</li><li>User interface testing (用户界面测试)，指测试用户界面的风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等等。UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。</li><li>Static testing（静态测试），不通过执行来测试一个系统。如代码检查，文档检查和评审等。</li><li>Regression testing（回归测试），在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，对软件的任何新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再现。</li><li>Capture/Replay Tool (捕获/回放工具)，一种测试工具，能够捕获在测试过程中传递给软件的输入，并且能够在以后的时间中，重复这个执行的过程。这类工具一般在GUI测试中用的较多。</li><li>Debug（调试），开发人员确定引起错误的根本原因和确定可能的修复措施的过程。一般发生在子系统或单元模块编码完成时，或者根据测试错误报告指出错误以后，开发人员需要执行调试过程来解决已存在的错误。</li><li>Deployment（部署），也称为shipment(发布)，对内部IT系统而言，指它的第一个版本通过彻底的测试、形成产品、交付给付款客户的阶段。 Dynamic testing（动态测试），通过执行软件的手段来测试软件。</li><li>Garbage characters（乱码字符），程序界面中显示的无意义的字符，例如，程序对双字节字符集的字符不支持时，这些字符不能正确显示。</li><li>GB 18030 testing（GB 18030测试），软件支持GB 18030字符集标准能力的测试，包括GB 18030字符的输入、输出、显示、存储的支持程度。</li><li>Priority（优先权），从商业角度出发是指错误的重要性，尤其是从客户和用户的角度出发，是指错误对于系统的可行性和可接受性的影响。与“Severity（严重性）”相对照。</li><li>Severity（严重性），错误对被测系统的影响程度，在终端用户条件下发生的可能性，软件错误妨碍系统使用的程度。</li><li>Quality assurance（质量保证QA），采取相关活动，以保证一个开发组织交付的产品满足性能需求和已确立的标准和过程。</li><li>Review（评审），在产品开发过程中，把产品提交给项目成员、用户、管理者或其它相关人员评价或批准的过程。</li><li>Screen shot（抓屏、截图），软件测试中，将软件界面中的错误（窗口、菜单、对话框等）的全部或一部分，使用专用工具存储成图像文件，以便于后续处理。</li><li>Software life cycle（软件生命周期），开始于一个软件产品的构思，结束于该产品不再被使用的这段期间。</li><li>Structured query language（结构化查询语句，SQL），在一个关系数据库中查询和处理数据的一种语言。</li><li>TBD(To be determined，待定)，在测试文档中标是一项进行中的尚未最终确定的工作。</li><li>Test（测试），执行软件以验证其满足指定的需求并检测错误的过程。检测已有条件之间的不同，并评价软件项的特性软件项的分析过程。软件工程过程的一个活动，它将软件在预定的条件下运行以判断软件是否符合预期结果。</li><li>Test case（测试用例），为特定目标而开发的一组测试输入、执行条件和预期结果，其目标可以是测试某个程序路径或核实是否满足某个特定的需求。</li><li>Testing coverage（测试覆盖），指测试系统覆盖被测试系统的程度，一项给定测试或一组测试对某个给定系统或构件的所有指定测试用例进行处理所达到的程度。</li><li>Testing environment（测试环境），进行测试的环境，包括测试平台、测试基础设施、测试实验室和其他设施。</li><li>Testing item（测试项），作为测试对象的工作版本。</li><li>Testing plan（测试计划），描述了要进行的测试活动的范围、方法、资源和进度的文档。它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。</li><li>Testing procedure（测试过程），指设置、执行给定测试用例并对测试结果进行评估的一系列详细步骤。</li><li>Testing script（测试脚本），一般指的是一个特定测试的一系列指令，这些指令可以被自动化测试工具执行。</li><li>Testing suite（测试包），一组测试用里的执行框架；一种组织测试用例的方法。在测试包里，测试用例可以组合起来创造出独特的测试条件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍一些测试的相关术语&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>带标签的模板字符串</title>
    <link href="/2019/10/12/%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>/2019/10/12/带标签的模板字符串/</id>
    <published>2019-10-12T07:01:55.000Z</published>
    <updated>2019-10-12T07:14:01.991Z</updated>
    
    <content type="html"><![CDATA[<p>模板字符串的特殊用法<br><a id="more"></a></p><h1 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h1><p>模板字符串中我们使用 ${exporession} 作为占位符，而作为字符串连接的语法糖是其最基本的用法，而带标签的模板字符串则是一种函数调用，这能够让模板字符串更加强大，拥有真正模板引擎的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">strs, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strs)</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name =<span class="string">'jinux'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">a <span class="string">`name: <span class="subst">$&#123;name&#125;</span>, age: <span class="subst">$&#123;age&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>在浏览器的console面板打印一下。<br>可以看到，标签模板字符串的标签函数的第一个参数是由原始的字符串由占位字符串分割而成的字符串组成的数组，剩下的参数则是对应占位符的值。<br>利用这个特性常被提到的是避免XSS攻击：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">literals, ...placeholders</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> placeholders.reduce(<span class="function">(<span class="params">pre, val, i</span>) =&gt;</span> pre + literals[i] + val</span><br><span class="line">    .replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>), <span class="string">''</span>) + literals[literals.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模板字符串的特殊用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>SPA应用前端预渲染之VUE</title>
    <link href="/2019/10/11/SPA%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E9%A2%84%E6%B8%B2%E6%9F%93%E4%B9%8BVUE/"/>
    <id>/2019/10/11/SPA应用前端预渲染之VUE/</id>
    <published>2019-10-11T07:22:53.000Z</published>
    <updated>2019-10-12T06:22:35.408Z</updated>
    
    <content type="html"><![CDATA[<p>vue中如何实现预渲染<br><a id="more"></a></p><h1 id="SPA应用前端预渲染之VUE"><a href="#SPA应用前端预渲染之VUE" class="headerlink" title="SPA应用前端预渲染之VUE"></a>SPA应用前端预渲染之VUE</h1><p>SPA应用的缺点是第一次打开缓慢，再有就是SEO不友好，优化有两种方式，一种是前端预渲染，另一种是后端渲染ssr,今天我们只说前端预渲染。<br>前端预渲染必须在webpack的基础上来做，用到的插件是prerender-spa-plugin。<br>我们在创建vue项目的时候现在都是用vue-cli，这里我只举例3.0版本。</p><h2 id="prerender-spa-plugin的使用"><a href="#prerender-spa-plugin的使用" class="headerlink" title="prerender-spa-plugin的使用"></a>prerender-spa-plugin的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install prerender-spa-plugin --save</span><br></pre></td></tr></table></figure><h3 id="vue-config-js中增加"><a href="#vue-config-js中增加" class="headerlink" title="vue-config.js中增加"></a>vue-config.js中增加</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">                    <span class="comment">// 生成文件的路径，也可以与webpakc打包的一致。</span></span><br><span class="line">                    <span class="comment">// 下面这句话非常重要！！！</span></span><br><span class="line">                    <span class="comment">// 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span></span><br><span class="line">                    staticDir: path.join(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">                    <span class="comment">// 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span></span><br><span class="line">                    routes: [<span class="string">'/'</span>, <span class="string">'/product'</span>,<span class="string">'/about'</span>],</span><br><span class="line">                    <span class="comment">// 这个很重要，如果没有配置这段，也不会进行预编译</span></span><br><span class="line">                    renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">                        inject: &#123;</span><br><span class="line">                            foo: <span class="string">'bar'</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        headless: <span class="literal">false</span>,</span><br><span class="line">                        <span class="comment">// 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。</span></span><br><span class="line">                        renderAfterDocumentEvent: <span class="string">'render-event'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在main-js中增加"><a href="#在main-js中增加" class="headerlink" title="在main.js中增加"></a>在main.js中增加</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'render-event'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h3 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h3><p>router.js 中设置mode: “history”</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>运行npm run build，之后在dist文件夹下可以看到跟预渲染路由名字一样文件夹，里边有一个index.html的文件，这就是预渲染页面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在现实中，这种需求还是很多的，我现在做的项目领导对首页加载一直不满意，首页是一个登录页面，现在的做法我把登录页的内容直接写死到dom里了，当js文件加载好了之后再覆盖掉，这种方式也可以，我看掘金的首页就是这么干的。<br>我来说一下我理解的预渲染，比如想把about页面预渲染出来，打包之后发现有两个html文件，正常的首页index.html页和about文件夹下的index.html页，仔细观察about预渲染页面，引入的js，css文件是一样的，只是显示的dom内容已经写死在dom里了，当然，也可以把首页的html文件预渲染，其实也是静态化，这样SEO就可以抓到里边的内容。预渲染的页面刚访问的时候里边内容是写死的，当点击路由后又切回到vue自己的路由模式来加载页面，当然，我猜在vue的路由里边已经删除了预渲染页面的路由，访问这些页面的时候只能去服务器端去下载静态的预渲染页面了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue中如何实现预渲染&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
      <category term="webpack" scheme="/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>flex简单教程</title>
    <link href="/2019/10/10/flex%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
    <id>/2019/10/10/flex简单教程/</id>
    <published>2019-10-10T05:27:39.000Z</published>
    <updated>2019-10-10T06:00:49.210Z</updated>
    
    <content type="html"><![CDATA[<p>flex语法的简单记录<br><a id="more"></a></p><h1 id="flex简单教程"><a href="#flex简单教程" class="headerlink" title="flex简单教程"></a>flex简单教程</h1><p>flex在项目中经常使用，但是语法还是经常忘，这里简单的记录下基本语法，以便方便查看，如果想系统学习，请阅读阮一峰老师的两篇文章<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a> 和 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局教程：实例篇</a></p><h2 id="容器指定为flex容器"><a href="#容器指定为flex容器" class="headerlink" title="容器指定为flex容器"></a>容器指定为flex容器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex; <span class="comment">// 块元素flex布局 </span></span><br><span class="line">  display: inline-flex; <span class="comment">// 行间元素flex布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex容器的属性"><a href="#flex容器的属性" class="headerlink" title="flex容器的属性"></a>flex容器的属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  <span class="comment">// 属性决定主轴的方向（即项目的排列方向）。</span></span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flex-wrap属性定义，如果一条轴线排不下，如何换行。</span></span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span></span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line"></span><br><span class="line">  // justify-content属性定义了项目在主轴上的对齐方式。</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"></span><br><span class="line">  // align-items属性定义项目在交叉轴上如何对齐。</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"></span><br><span class="line">  // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex容器里项目的属性"><a href="#flex容器里项目的属性" class="headerlink" title="flex容器里项目的属性"></a>flex容器里项目的属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  <span class="comment">// order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span></span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line"></span><br><span class="line">  // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line"></span><br><span class="line">  // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line"></span><br><span class="line">  // flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line"></span><br><span class="line">  // flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</span><br><span class="line">  flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] // 例：auto (1 1 auto) 和 none (0 0 auto)</span><br><span class="line"></span><br><span class="line">  // align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flex语法的简单记录&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="样式" scheme="/tags/%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单快速理解web缓存</title>
    <link href="/2019/10/09/%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3web%E7%BC%93%E5%AD%98/"/>
    <id>/2019/10/09/简单快速理解web缓存/</id>
    <published>2019-10-09T05:39:13.000Z</published>
    <updated>2019-10-09T06:51:14.510Z</updated>
    
    <content type="html"><![CDATA[<p>简单快速,5分钟你就能理解web缓存<br><a id="more"></a></p><h1 id="简单快速理解web缓存"><a href="#简单快速理解web缓存" class="headerlink" title="简单快速理解web缓存"></a>简单快速理解web缓存</h1><p>之前我已经写过了一篇关于web缓存的文章，<a href="/2018/09/19/HTTP缓存机制及原理/">阅读点这里</a>，不过，这篇文章比较长，今天再写个短小易懂的，便于快速查看。</p><h2 id="服务器的缓存协商"><a href="#服务器的缓存协商" class="headerlink" title="服务器的缓存协商"></a>服务器的缓存协商</h2><p>缓存有两种，一种是需要服务器验证，另外一种是不用发送请求验证。</p><h2 id="ETag-Last-Modified"><a href="#ETag-Last-Modified" class="headerlink" title="ETag/Last-Modified"></a>ETag/Last-Modified</h2><p>这两种方式做法类似，都要向服务器发送一次请求进行验证。简直，缓存就缓存呗，为什么还要验证呢？ 其实，这是该协议的一种特有方式，发送一次验证主要是检查文件是否发生变化。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>ETag是用来计算文件的内容是否发生变化，比如，你在文件中删除一个空格，这样都算文件内容发生变化。 通常做法是用md5或者SHA1算法，计算出文件的唯一值。 在前端其实都可以完成， 找到一个文件文件解析的md5算法，然后将文件传入，就可以得到ETag的值。 不过这里，我们着重点并不是让你生成Etag，而是看看ETag在缓存中的重要作用。 ETag是HTTP/1.1A的一种办法，由Web服务器生成，并写入响应头中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//response Headers</span></span><br><span class="line">ETag:<span class="string">"751F63A30AB5F98F855D1D90D217B356"</span></span><br></pre></td></tr></table></figure></p><p>接着，到了浏览器之后，便缓存在本地。 当下次打开同样的文章时，会在请求头中发送If-None-Match, 给服务器检查文件是否发生变化。如果没有，则告诉浏览器使用本地的，否则返回新文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request Headers</span></span><br><span class="line">If-None-Match: <span class="string">"751F63A30AB5F98F855D1D90D217B356"</span></span><br></pre></td></tr></table></figure></p><p>通常情况下，服务器默认是打开Etag的，但是为了防止你的同事，或者后台哥哥的后台配置文件不正确，关闭了Etag，这时候，就需要你对对配置文件做一些设置。 这里我以Nginx为例: 打开ngnix.conf文件，检查是否有以下语句:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">etag off;</span><br><span class="line">more_set_headers -s <span class="number">404</span> -t <span class="string">'ETag'</span>;</span><br><span class="line">more_clear_headers <span class="string">'Etag'</span>;</span><br></pre></td></tr></table></figure></p><p>如果有则将其删除掉。然后重启nginx就可以了。他们将Etag关闭的原因其实也很简单，就是因为，Etag打开之后会增加服务器的负载，造成性能的局限性，所以，关闭或者打开Etag都要经过权衡的。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>这和文档内容信息验证不同，这里采用的是日期验证办法。 即，服务器上会对文件打上一个文件改动的日期，然后客户端接受该日期，下次请求时，返回该日期，服务器验证，如果日期未变，则告诉浏览器使用本地缓存即可。 即，在服务器的相应头中，可以设置Last-Modified，来启用这一缓存协议.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Response Header</span></span><br><span class="line">Last-Modified:Tue, <span class="number">03</span> Mar <span class="number">2015</span> <span class="number">01</span>:<span class="number">38</span>:<span class="number">18</span> GMT</span><br></pre></td></tr></table></figure></p><p>接受到这一响应头之后，浏览器会对该文件做一个缓存，并保存该日期。当下次请求的时候，会通过If-Modified-Since将日期传入并验证:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since:Tue, <span class="number">03</span> Mar <span class="number">2015</span> <span class="number">01</span>:<span class="number">38</span>:<span class="number">18</span> GMT</span><br></pre></td></tr></table></figure></p><p>如果日期未变，则告诉浏览器使用缓存。 那我们通常应该怎样启用服务器这一功能呢？ 默认情况下，服务器会对静态资源发送Last-modified的tag。 但是，需要注意，Last-Modified的更新时间只能以秒来计，如果你文件改动过于频繁，Last-Modified是无效的(不过，谁牛逼到1s内能多次更新文件嘞~) 实际上.Last-Modified的这个标签的我们通常并不会单独使用它，通常与expires结合，形成一个可降级的缓存.</p><h2 id="Expires-Cache-Control"><a href="#Expires-Cache-Control" class="headerlink" title="Expires/Cache-Control"></a>Expires/Cache-Control</h2><p>Expires/Cache协议与上述验证协议最大的不同在于，他可以省略发送验证请求环节，不需要服务器的验证，而直接使用本地缓存。 通常这种方式，适用于，项目稳定，版本迭代不多的时候。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>在服务器端可以设置Expires的一个绝对时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Response Headers</span></span><br><span class="line">Expires:Tue, <span class="number">03</span> May <span class="number">2016</span> <span class="number">09</span>:<span class="number">33</span>:<span class="number">34</span> GMT</span><br></pre></td></tr></table></figure></p><p>这告诉浏览器,在2016.5.3号之前,可以直接使用该文本的缓存副本。但是，可能会因为服务器和客户端的GMT时间不同，会有一定的bug。 所以，这里只提议在长时间缓存的情况下使用。否则，应该选择Cache-Control. 那在服务器端该怎么设置呢？ 这里以nginx为例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(?:css|js)$ &#123;</span><br><span class="line">  expires <span class="number">1</span>d;</span><br><span class="line">  access_log off;</span><br><span class="line">  add_header Cache-Control <span class="string">"public"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过expires设置过期时间为一天，此时，服务器会根据当前的时间，加上一天.同时添加Expires和Cache-Control头部标签。 即,得到的Response Header为:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expires: Fri, <span class="number">28</span> Feb <span class="number">2014</span> <span class="number">10</span>:<span class="number">42</span>:<span class="number">09</span> GMT</span><br><span class="line">Cache-Control: max-age=<span class="number">86400</span> <span class="comment">//24*60*60</span></span><br></pre></td></tr></table></figure></p><p>(HTTP规定，如果出现max-age和expires，则max-age默认覆盖掉expires) 当expires为负数表示no-cache，正数或零表示max-age=time。 如果你不想缓存，可以直接设置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expires <span class="number">-1</span>;  <span class="comment">//永远过期，Cache-Control: no-cache</span></span><br></pre></td></tr></table></figure></p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>这应该是HTTP1.1为了解决HTTP1.0中expires的时间差的bug，而新添加的一个tag. 他的配置项很多，其实完全都可以取代expires(现在大多数服务器都支持). 引用一段原话:</p><ul><li>Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。</li></ul><p>不过，目前大部分服务器都会将两者添加上，因为HTTP规定，如果Cache-Control和expires同时出现的话，expires会默认被覆盖掉。 此时，返回的响应码不再是304(文件未改动),而是200(资源成功访问).</p><p>当前每次发送请求之前浏览器会检查缓存系统里，是否有相应文件的备份，如果有的话，则直接从本地模仿一个Response头 理论知识铺垫完毕，我们来take a look. 看看cache-control 有哪些可以配置的属性(以下属性都跟在cache-control后)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public: 共有缓存，可被缓存代理服务器缓存,比如CDN</span><br><span class="line">private: 私有缓存，不能被共有缓存代理服务器缓存，可被用户的代理缓存如浏览器。</span><br><span class="line">max-age=[秒]：表示在这个时间范围内缓存是新鲜的无需更新。类似Expires时间，不过这个时间是相对的，而不是绝对的。也就是某次请求成功后多少秒内缓存是新鲜的。</span><br><span class="line">s-maxage=[秒]：类似max-age, 除了仅应用于共享缓存（如代理）。</span><br><span class="line">no-cache：这里不是不缓存的意思，只是每次在使用缓存之前都强制发送请求给源服务器进行验证，检查文件该没改变(其实这里和ETag/Last区别不大)</span><br><span class="line">no-store：就是禁止缓存，不让浏览器保留缓存副本</span><br><span class="line">must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是<span class="number">200</span>而是<span class="number">304</span>了。</span><br><span class="line">proxy-revalidate：类似must-revalidate，除了只能应用于代理缓存。</span><br></pre></td></tr></table></figure></p><p>比如，这里我可以设置Cache-Control为:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Response Headers</span></span><br><span class="line">Cache-Control:private, max-age=<span class="number">0</span>, must-revalidate</span><br></pre></td></tr></table></figure></p><p>该文件是一个私有文件,只能被浏览器缓存，而不能被代理缓存。max-age标识该缓存立即过期，其实和no-cache实际上区别不大. 然后must-revalidate告诉浏览器，你必须给我再验证文件过没过期，比如接下来可能会验证Last-Modified或者ETag.如果没有过期则使用本地缓存. 其实上面可以直接等同于:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Response Headers</span></span><br><span class="line">Cache-Control:private,no-cache</span><br></pre></td></tr></table></figure></p><p>使用no-store的结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Response Headers</span></span><br><span class="line">Cache-Control:no-store;</span><br></pre></td></tr></table></figure></p><p>这样表明，不管一不一样都需要重新下载. 强烈表示，不让你使用缓存文件。后续的就不会去验证ETag了。 当然，如果你将IE6那种古老的浏览器考虑进来的话，那你干脆就做的不要脸一点，直接用下面的tag就行:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache, no-store, must-revalidate <span class="comment">//HTTP1.1</span></span><br><span class="line">Pragma: no-cache <span class="comment">//HTTP1.0</span></span><br><span class="line">Expires: <span class="number">0</span> <span class="comment">//Proxy</span></span><br></pre></td></tr></table></figure></p><p>不过现在基本上也没有不支持Cache-Control的浏览器了。所以，正常情况下，可以直接使用.如下的策略来进行设置:(From google developer)  我们通常在nginx怎么配置对应的cache-control头呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">##设置no-cache</span><br><span class="line"><span class="comment">//Nginx</span></span><br><span class="line">expires <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//cache-control</span></span><br><span class="line">Cache-Control:no-cache</span><br><span class="line"></span><br><span class="line">##设置max-age=0</span><br><span class="line"><span class="comment">//Nginx</span></span><br><span class="line">expires <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cache-control</span></span><br><span class="line">Cache-Control:max-age=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">##设置其他头部</span><br><span class="line"><span class="comment">//nginx</span></span><br><span class="line">add_header  Cache-Control <span class="string">"no-cache"</span>;</span><br><span class="line">add_header  Pragma no-cache;</span><br></pre></td></tr></table></figure></p><p>上面说的基本上是服务器的响应头，那在浏览器的Request headers里存在cache-control代表什么呢？ 当请求头中有:Cache-Control: max-age=0,表示缓存需要进行验证(ETag||Last-Modified)，如果缓存未过期,则可以使用。 当请求头中有:Cache-Control: no-cache,表示浏览器只能获取最新的文件。 和Response Header中的no-store相对应。</p><h2 id="组合缓存策略"><a href="#组合缓存策略" class="headerlink" title="组合缓存策略"></a>组合缓存策略</h2><p>上面介绍的last/ETag/Expires/Cache都是HTTP协议的缓存策略。当然，缓存不止这一种，比如在HTML 4.0中定义的某些meta也可以实现自定义缓存的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Cache-Control"</span> content=<span class="string">"no-cache, no-store, must-revalidate"</span> /&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Pragma"</span> content=<span class="string">"no-cache"</span> /&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Expires"</span> content=<span class="string">"0"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>但，实际情况是，这些meta只能在file:// 本地文件中使用，如果是服务器则默认被覆盖。现在目前主流的就是使用HTTP1.1协议缓存 不过我们一般都不会单独使用某一项。 但是，组合之后他们的效果是怎样的呢？  如果你的网页不是什么特别定制化的(私密)的，使用缓存能给你网站的性能带来极大的提升。所以很推荐使用。 一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件(视频就呵呵了). 我们可以针对这几类文件做一些缓存层级.</p><table><thead><tr><th style="text-align:left">文件</th><th style="text-align:left">缓存层级</th></tr></thead><tbody><tr><td style="text-align:left">HTML</td><td style="text-align:left">Cache-Control: no-cache,must-revalidate</td></tr><tr><td style="text-align:left">JS</td><td style="text-align:left">Cache-Control:private,max-age=86400</td></tr><tr><td style="text-align:left">CSS</td><td style="text-align:left">Cache-Control:max-age=2629000</td></tr><tr><td style="text-align:left">img\fonts</td><td style="text-align:left">Cache-Control:max-age=2629000</td></tr></tbody></table><p>上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单快速,5分钟你就能理解web缓存&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PWA应用</title>
    <link href="/2019/10/09/PWA%E5%BA%94%E7%94%A8/"/>
    <id>/2019/10/09/PWA应用/</id>
    <published>2019-10-09T05:21:24.000Z</published>
    <updated>2019-10-09T05:30:13.844Z</updated>
    
    <content type="html"><![CDATA[<p>PWA应用教程<br><a id="more"></a></p><h1 id="PWA应用"><a href="#PWA应用" class="headerlink" title="PWA应用"></a>PWA应用</h1><p>PWA是Progressive Web App的英文缩写， 翻译过来就是渐进式增强WEB应用， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。<br>我也是正要准备学习，<a href="https://pwa.alienzhou.com" target="_blank" rel="noopener">点这里学习</a><br>在这里要感谢<strong>PWA学习手册</strong>的作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PWA应用教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SVG动画介绍</title>
    <link href="/2019/09/30/SVG%E5%8A%A8%E7%94%BB%E4%BB%8B%E7%BB%8D/"/>
    <id>/2019/09/30/SVG动画介绍/</id>
    <published>2019-09-30T03:19:26.000Z</published>
    <updated>2019-10-08T06:23:13.962Z</updated>
    
    <content type="html"><![CDATA[<p>SVG动画效果简单入门介绍<br><a id="more"></a></p><h1 id="SVG动画介绍"><a href="#SVG动画介绍" class="headerlink" title="SVG动画介绍"></a>SVG动画介绍</h1><p>本文主要是讲解关于 SVG 的一些高级动画特效，比如 SVG 动画标签，图形渐变，路径动画，线条动画，SVG 裁剪等。<br>例如：路径动画<br><img src="/2019/09/30/SVG动画介绍/1.gif" alt="img"><br>图形渐变：<br><img src="/2019/09/30/SVG动画介绍/2.gif" alt="img"><br>线条动画：<br><img src="/2019/09/30/SVG动画介绍/3.gif" alt="img"><br>以及，相关的动画的矩阵知识，这个也是现在 CSS 动画里面最重要，同时也是最为欠缺的知识点：<br><img src="/2019/09/30/SVG动画介绍/4.png" alt="img"><br>文章会先从基本语法入手，然后，慢慢深入。介绍一些动画基本原理和对应的数学原理知识点。并且文章后面，还附有相关语法的介绍，当你在遇到不熟悉语法的时候可以参考参考。<br><a href="https://jinux7.github.io/2019/09/29/SVG入门教程/" target="_blank" rel="noopener">前面一篇文章</a>，主要介绍了一些 SVG 的基本概念和基本图形。接下来我们需要了解一下，SVG 处理矢量这个特性之外，还有啥内容吸引我们，能让 SVG 现在普及度这么高？</p><h2 id="SVG-Animation"><a href="#SVG-Animation" class="headerlink" title="SVG Animation"></a>SVG Animation</h2><p>在 SVG 中，如果我们想实现一个动画效果，可以使用 CSS，JS，或者直接使用 SVG 中自带的 animate 元素添加动画。<br>使用 CSS 的话，有两种选择一种是通过 style 直接内联在里面，另外是直接使用相关的动画属性– transform。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;use id=<span class="string">"star"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"starStyle"</span> xlink:href=<span class="string">"#starDef"</span></span><br><span class="line">       transform=<span class="string">"translate(100, 100)"</span></span><br><span class="line">       style=<span class="string">"fill: #008000; stroke: #008000"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>而使用 SVG 中自定的 animate 主要还是 SVG 自己的东西，比较好用。如果想用 CSS 的动画，这都无所谓。<br>先看一个 SVG animate DEMO:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=<span class="string">"10"</span> y=<span class="string">"10"</span> width=<span class="string">"200"</span> height=<span class="string">"20"</span> stroke=<span class="string">"black"</span> fill=<span class="string">"none"</span>&gt;</span><br><span class="line">  &lt;animate</span><br><span class="line">    attributeName=<span class="string">"width"</span></span><br><span class="line">    attributeType=<span class="string">"XML"</span></span><br><span class="line">    <span class="keyword">from</span>=<span class="string">"200"</span> to=<span class="string">"20"</span></span><br><span class="line">    begin=<span class="string">"0s"</span> dur=<span class="string">"5s"</span></span><br><span class="line">    fill=<span class="string">"freeze"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/rect&gt;</span></span><br></pre></td></tr></table></figure></p><p>通过将 animate 标签嵌套在指定的图形里面，即可实现变换的效果。另外，还有 animateTransform，它主要是用来做变形动画的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=<span class="string">"-10"</span> y=<span class="string">"-10"</span> width=<span class="string">"20"</span> height=<span class="string">"20"</span></span><br><span class="line">    style=<span class="string">"fill: #ff9; stroke: black;"</span>&gt;</span><br><span class="line">    &lt;animateTransform attributeType=<span class="string">"XML"</span></span><br><span class="line">      attributeName=<span class="string">"transform"</span> type=<span class="string">"scale"</span></span><br><span class="line">      <span class="keyword">from</span>=<span class="string">"1"</span> to=<span class="string">"4 2"</span></span><br><span class="line">      begin=<span class="string">"0s"</span> dur=<span class="string">"4s"</span> fill=<span class="string">"freeze"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/rect&gt;</span></span><br></pre></td></tr></table></figure></p><p>简单来说：</p><ul><li>animate: 相当于 CSS 中的 transition</li><li>animateTransform: 相当于 CSS 中的 transform</li></ul><p>里面一些技术细节我们这里就不过多讲解了。这里，主要想介绍一下 animate 中的 morph 的效果。</p><h3 id="animate-morph"><a href="#animate-morph" class="headerlink" title="animate morph"></a>animate morph</h3><p>该效果主要做的就是图形内部的渐变。如图：<br><img src="/2019/09/30/SVG动画介绍/2.gif" alt="img"><br>这种动画是怎么实现呢？<br>直接看代码吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;path fill=<span class="string">"#1EB287"</span>&gt;</span><br><span class="line">    &lt;animate </span><br><span class="line">             attributeName=<span class="string">"d"</span> </span><br><span class="line">             dur=<span class="string">"1440ms"</span> </span><br><span class="line">             repeatCount=<span class="string">"indefinite"</span></span><br><span class="line">             keyTimes=<span class="string">"0;</span></span><br><span class="line"><span class="string">                       .0625;</span></span><br><span class="line"><span class="string">                       .208333333;</span></span><br><span class="line"><span class="string">                       .3125;</span></span><br><span class="line"><span class="string">                       .395833333;</span></span><br><span class="line"><span class="string">                       .645833333;</span></span><br><span class="line"><span class="string">                       .833333333;</span></span><br><span class="line"><span class="string">                       1"</span></span><br><span class="line">             calcMode=<span class="string">"spline"</span> </span><br><span class="line">             keySplines=<span class="string">"0,0,1,1;</span></span><br><span class="line"><span class="string">                         .42,0,.58,1;</span></span><br><span class="line"><span class="string">                         .42,0,1,1;</span></span><br><span class="line"><span class="string">                         0,0,.58,1;</span></span><br><span class="line"><span class="string">                         .42,0,.58,1;</span></span><br><span class="line"><span class="string">                         .42,0,.58,1;</span></span><br><span class="line"><span class="string">                         .42,0,.58,1"</span></span><br><span class="line">             values=<span class="string">"M 0,0 </span></span><br><span class="line"><span class="string">                     C 50,0 50,0 100,0</span></span><br><span class="line"><span class="string">                     100,50 100,50 100,100</span></span><br><span class="line"><span class="string">                     50,100 50,100 0,100</span></span><br><span class="line"><span class="string">                     0,50 0,50 0,0</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     M 0,0 </span></span><br><span class="line"><span class="string">                     C 50,0 50,0 100,0</span></span><br><span class="line"><span class="string">                     100,50 100,50 100,100</span></span><br><span class="line"><span class="string">                     50,100 50,100 0,100</span></span><br><span class="line"><span class="string">                     0,50 0,50 0,0</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     M 50,0 </span></span><br><span class="line"><span class="string">                     C 75,25 75,25 100,50 </span></span><br><span class="line"><span class="string">                     75,75 75,75 50,100</span></span><br><span class="line"><span class="string">                     25,75 25,75 0,50</span></span><br><span class="line"><span class="string">                     25,25 25,25 50,0</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     M 25,50 </span></span><br><span class="line"><span class="string">                     C 37.5,25 37.5,25 50,0 </span></span><br><span class="line"><span class="string">                     75,50 75,50 100,100</span></span><br><span class="line"><span class="string">                     50,100 50,100 0,100</span></span><br><span class="line"><span class="string">                     12.5,75 12.5,75 25,50</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     M 25,50 </span></span><br><span class="line"><span class="string">                     C 37.5,25 37.5,25 50,0 </span></span><br><span class="line"><span class="string">                     75,50 75,50 100,100</span></span><br><span class="line"><span class="string">                     50,100 50,100 0,100</span></span><br><span class="line"><span class="string">                     12.5,75 12.5,75 25,50</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     M 50,0</span></span><br><span class="line"><span class="string">                     C 77.6,0 100,22.4 100,50 </span></span><br><span class="line"><span class="string">                     100,77.6 77.6,100 50,100</span></span><br><span class="line"><span class="string">                     22.4,100, 0,77.6, 0,50</span></span><br><span class="line"><span class="string">                     0,22.4, 22.4,0, 50,0</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string">                     </span></span><br><span class="line"><span class="string">                     M 50,0</span></span><br><span class="line"><span class="string">                     C 77.6,0 100,22.4 100,50 </span></span><br><span class="line"><span class="string">                     100,77.6 77.6,100 50,100</span></span><br><span class="line"><span class="string">                     22.4,100, 0,77.6, 0,50</span></span><br><span class="line"><span class="string">                     0,22.4, 22.4,0, 50,0</span></span><br><span class="line"><span class="string">                     Z;</span></span><br><span class="line"><span class="string">                     </span></span><br><span class="line"><span class="string">                     M 100,0 </span></span><br><span class="line"><span class="string">                     C 100,50 100,50 100,100</span></span><br><span class="line"><span class="string">                     50,100 50,100 0,100</span></span><br><span class="line"><span class="string">                     0,50 0,50 0,0</span></span><br><span class="line"><span class="string">                     50,0 50,0 100,0</span></span><br><span class="line"><span class="string">                     Z;"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/path&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>这么多，是不是感觉有点懵逼。不过，我们细分来看一下其实很简单。里面主要是利用 animate 中的 keyTimes，calcMode，keySplines，以及 values 这几个属性。不急，我们一个一个来解释一下。</li><li>keyTimes: 这其实和 CSS 中定义的 @keyframes 一样。通过 0-1 之间的值，定义每段动画完成的时间。格式为：value;value…。例如 0;.0625;.208333333;.3125;.395833333;.645833333;.833333333;1。从第一个动画，到第二个动画经历的时间比例为 6.25%。并且，keyTimes 需要和 values 里面定义的帧数一致。</li><li>calcMode: 用来定义动画具体的插值模型。取值有: discrete | linear[default] | paced | spline。具体可以参考 MDN。这里我们主要介绍一下 spline。该值表示每个动画间使用自定的贝塞尔变换曲线。如果没有特殊要求，使用 linear 其实已经足够了，这样就不用麻烦去定义下面的 keySplines 属性。</li><li>keySplines：该值用来具体定义动画执行时的 贝塞尔曲线。使用格式是通过 ; 来分隔每一个值。即，cubic-bezier(.31,.57,.93,.46) 为一组。使用 keySplines 表达，则为：keySplines = “.31,.57,.93,.46;”。当然，里面的贝塞尔曲线组数为 整个动画帧数 - 1。</li></ul><p>而 values 就很简单了。它是直接结合 attributeName 属性，来设置具体的值，每个值之间使用 ; 进行分隔。<br>像上面那样，可以在指定元素里面嵌套多个 animate，既实现了形状的改变，又实现了颜色的改变。Morph 比较常用于数字的更迭，比如，<a href="https://codepen.io/felixhornoiu/pen/dovub" target="_blank" rel="noopener">倒数 10s 的相关动画</a>。到这里，Morpah 相关的知识点就结束了。</p><p>接着，让我们来看一下 SVG 中，另外一非常重要的标签 – animateMotion。<br>该标签可以让指定的元素，绕着指定的路径进行运动。所以这对于复杂的路径来说非常有用，因为我们很难使用 transform 去模拟复杂的变换路径。看一个 DEMO<br><img src="/2019/09/30/SVG动画介绍/1.gif" alt="img"></p><h3 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h3><p>animateMotion 大致的属性和 animate 差不多，不过，它还拥有自己特有的属性，比如 keyPoints、rotate、path 等。不过，calcMode 在 AM(animateMotion) 中的默认属性由，linear 变为 paced。<br>这些属性，我们慢慢介绍，先从最简单的开始吧。首先，我们来看一个 DEMO：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;g&gt;</span><br><span class="line">  &lt;rect x=<span class="string">"0"</span> y=<span class="string">"0"</span> width=<span class="string">"30"</span> height=<span class="string">"30"</span> style=<span class="string">"fill: #ccc;"</span>/&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"30"</span> cy=<span class="string">"30"</span> r=<span class="string">"15"</span> style=<span class="string">"fill: #cfc; stroke: green;"</span>/&gt;</span><br><span class="line">  &lt;animateMotion <span class="keyword">from</span>=<span class="string">"0,0"</span> to=<span class="string">"60,30"</span> dur=<span class="string">"4s"</span> fill=<span class="string">"freeze"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>from，to：指定两点的位置，位置参数是以元素的坐标为原点的。</li><li>dur：执行渲染时间</li><li>fill：指定动画结束后停留的装填。有 freeze 和 remove 效果。remove 表示回到动画开始的位置，freeze 表示停留在动画结束的位置。</li></ul><p>如果，你想要更复杂的路径，可以直接使用 path 属性来指定路径。用法和 path 标签中 d 属性是一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=<span class="string">"0"</span> y=<span class="string">"0"</span> width=<span class="string">"30"</span> height=<span class="string">"30"</span> style=<span class="string">"fill: #ccc;"</span>&gt;</span><br><span class="line">    &lt;animateMotion</span><br><span class="line">    path=<span class="string">"M50,125 C 100,25 150,225, 200, 125"</span></span><br><span class="line">    dur=<span class="string">"6s"</span> fill=<span class="string">"freeze"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/rect&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者使用 mpath 标签，引用外部的 path。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110"</span></span><br><span class="line">      stroke=<span class="string">"lightgrey"</span> stroke-width=<span class="string">"2"</span> </span><br><span class="line">      fill=<span class="string">"none"</span> id=<span class="string">"theMotionPath"</span>/&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"10"</span> cy=<span class="string">"110"</span> r=<span class="string">"3"</span> fill=<span class="string">"lightgrey"</span>  /&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"110"</span> cy=<span class="string">"10"</span> r=<span class="string">"3"</span> fill=<span class="string">"lightgrey"</span>  /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Red circle which will be moved along the motion path. --&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">""</span> cy=<span class="string">""</span> r=<span class="string">"5"</span> fill=<span class="string">"red"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Define the motion path animation --&gt;</span><br><span class="line">    &lt;animateMotion dur=<span class="string">"6s"</span> repeatCount=<span class="string">"indefinite"</span>&gt;</span><br><span class="line">      &lt;mpath xlink:href=<span class="string">"#theMotionPath"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/animateMotion&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>circle&gt;</span><br></pre></td></tr></table></figure></p><p>动画效果为：<br><img src="/2019/09/30/SVG动画介绍/6.gif" alt="img"><br>所以，一般而言我们在定义 AM 的路径的时候，只用一种方式定义即可，否则会发生相应的覆盖：mpath&gt;path&gt;values&gt;from/to。<br>在 AM 运动中，还有一个很重要的概念就是旋转角。默认情况下，运动物体的角度是按照它和坐标轴的初始角度确定的。例如：<br><img src="/2019/09/30/SVG动画介绍/7.gif" alt="img"><br>这样看起来确实有些别扭，那能不能让物体垂直于路径进行运动呢？<br>有的，根据 rotate 属性值，一共有 3 个值可供选择。</p><ul><li>auto：让物体垂直于路径的切线方向运动。不过，如果你的路径是闭合曲线的话，需要注意起始点的位置。</li></ul><p>例如：<br><img src="/2019/09/30/SVG动画介绍/8.gif" alt="img"></p><ul><li>auto-reverse：让物体垂直于路径的切线方向并 + 180°。也就是和 auto 运动关于切线对称。<br><img src="/2019/09/30/SVG动画介绍/9.gif" alt="img"></li><li>Number：让物体以固定的旋转角度运动。这个就相当于使用 transform:rotate(deg) 进行控制。</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>该标签也是用来模拟 transition 效果的。它和 animate 的主要区别是，它仅仅需要 to 的指定属性，而不需要其他的参考属性，比如 from，by 等。那它有啥特别的存在意义吗？<br>有的，因为 set 针对于所有属性，甚至包括 style 里面的相关 CSS 属性。所以，可以靠它来很好描述一些非 number 的属性值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;text text-anchor=<span class="string">"middle"</span> x=<span class="string">"60"</span> y=<span class="string">"60"</span> style=<span class="string">"visibility: hidden;"</span>&gt;</span><br><span class="line">  &lt;set attributeName=<span class="string">"visibility"</span> attributeType=<span class="string">"CSS"</span></span><br><span class="line">    to=<span class="string">"visible"</span> begin=<span class="string">"4.5s"</span> dur=<span class="string">"1s"</span> fill=<span class="string">"freeze"</span>/&gt;</span><br><span class="line">  All gone!</span><br><span class="line">&lt;<span class="regexp">/text&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="矩阵动画"><a href="#矩阵动画" class="headerlink" title="矩阵动画"></a>矩阵动画</h2><p>上面差不多简单阐述了关于 SVG 一些比较有特点的动画。当然，还有比较重要的线条动画，这个我们放到后面进行讲解。这里先来看一下所有动画中，非常重要的矩阵原理。线性代数应该是大学里面来说，最容易学的一门科目，MD。。。还记得，大学线代期末考试的时候，100 分的同学应该说是如韭菜地般，一抓一大片（对不起，我没能和他们同流合污。）<br>那矩阵是如何在动画中使用的呢？<br>简单的说，矩阵中的每个元素其实可以等价代换为每个因式里面的系数：<br><img src="/2019/09/30/SVG动画介绍/27.png" alt="img"><br>上面也叫作 三维矩阵。即，它涉及到 x,y,z 轴的计算。那对于我们平面 2D 变换来说，那么此时矩阵又是哪种形式呢？<br>很简单，只要将 z 轴永远置为一个常数就 OK。这里，惯例上是直接取 0 0 1 来设置。<br><img src="/2019/09/30/SVG动画介绍/10.png" alt="img"><br>不信的话，大家只要代进去乘以乘，应该就可以得到结果了。所以，在二维中，具体变换方式为：<br><img src="/2019/09/30/SVG动画介绍/4.png" alt="img"><br>后面，我们也会依据这个公式进行相关的变形操作。那矩阵变换是怎么运用到 CSS/SVG 当中呢？<br>在 CSS 中，是直接使用 transform 中的属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(a,b,c,d,e,f);</span><br></pre></td></tr></table></figure></p><p>当然，在 SVG 中也是一样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;g transform=<span class="string">"matrix(1,2,3,4,5,6)"</span>&gt;</span><br><span class="line">    &lt;line x1=<span class="string">"10"</span> y1=<span class="string">"20"</span> x2=<span class="string">"30"</span> y2=<span class="string">"40"</span> style=<span class="string">"stroke-width: 10px; stroke: blue;"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><p>所以，我们主要的重点就是讲解一下 matrix 这个属性。它的格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix(a,b,c,d,e,f);</span><br></pre></td></tr></table></figure></p><p>对应于我们上面的公式有：<br><img src="/2019/09/30/SVG动画介绍/10.png" alt="img"><br>在接触 transform 的时候，大家应该了解到 transform 里面有很多固定的动画属性：</p><ul><li>translate()</li><li>rotate()</li><li>scale()</li><li>skew()<br>实际上，在底层还是使用 matrix 实现的变换。就拿 translate 举个例子吧。<br>translate 的格式为：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate(dx,dy)</span><br></pre></td></tr></table></figure></li></ul><p>相当于参考当前原点，在 x/y 轴上移动 dx/dy 的距离。那么映射到矩阵，应该如何表示呢？<br>很简单，它等同于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix(<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> dx dy);</span><br></pre></td></tr></table></figure></p><p>使用代数证明一下：<br>假设有 matrix(1 0 0 1 20 30)<br>变为矩阵为：<br><img src="/2019/09/30/SVG动画介绍/11.png" alt="img"><br>根据，上面的表达式有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = x<span class="string">'*1 + y'</span>*<span class="number">0</span> + <span class="number">20</span> = x<span class="string">' + 20</span></span><br><span class="line"><span class="string">Y = x'</span>*<span class="number">0</span> + y<span class="string">'*1 + 30 = y'</span> + <span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>所以，就是 X 在原有 X 轴坐标上向右移动 20 的距离，Y 相对于原有移动 30 的距离。<br>那么其他几个属性呢？也是怎么变化的吗？<br>恩，类似。只是里面取值不一样：</p><ul><li>scale(x,y): 放大 X/Y 轴，矩阵的表达为 matrix(x 0 0 y 0 0)。</li><li>rotate(θ): 坐标旋转，矩阵的表达为 matrix(cosθ sinθ -sinθ cosθ 0 0)。</li><li>skew(θx,θy): X/Y 轴拉伸，矩阵的表达为 matrix(1 tanθx tanθy 1 0 0)。</li></ul><p>注意，上面三个都会改变原有物体的坐标系！！！ 这点很重要，换句话说，后面每次变换都是基于前面一个的变换结果的。<br>详情看图：<br><img src="/2019/09/30/SVG动画介绍/12.png" alt="img"><br>详情可以参考：<a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform" target="_blank" rel="noopener">MDN matrix</a><br>不过，这并不是我们使用 matrix 的重点，也不是它的优势。它的优势在于可计算，即，能够将复杂的动画集合到一个表达式中，并且，后续的变换可以直接基于当前的 matrix。<br>我们先来了解一下，如果多个变换动画一起使用，matrix 应该如何表达呢？<br><strong>只需要找到我们变换动画对应的矩阵，然后相乘即可。</strong>例如，先旋转 45°，然后放大 1.5 倍，则有变换动画为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(<span class="number">45</span>deg) scale(<span class="number">1.5</span>,<span class="number">1.5</span>);</span><br></pre></td></tr></table></figure></p><p>注意，虽然，你定义动画是分开的，但此时的动画是同时进行的。为啥？因为，这两个动画实际上可以整合成为一个变换矩阵：<br><img src="/2019/09/30/SVG动画介绍/13.png" alt="img"><br>并且，位置是不可以调换的。比如，transform: scale(2,2) translate(20px,30px)。即，你先放大两倍，然后移动 20,30 的距离。注意，这里移动的 20,30 相对的是已经放大过后的坐标，相对于原坐标而言就是 40,60 了。 如果，你调换位置，即 transform: translate(20px,30px) scale(2,2)。就变成现在原坐标移动 20,30，然后再放大两倍。<br>而上面强调的顺序关系，实际上就可以理解为矩阵不满足交换律的原则。因为一旦交换，结果很可能不一样。</p><h3 id="矩阵高级用法"><a href="#矩阵高级用法" class="headerlink" title="矩阵高级用法"></a>矩阵高级用法</h3><p>上面的内容只是简单的描述了关于矩阵的概念。在实际中，矩阵可以说是真正利器。<br>假设现在有一个动画，要求你将一个物体从一个点通过抛物线的方式移动到另外一个点，那么此时要求 JS/CSS 随你挑。此时，你会不会感觉，呼吸急促，头脑发热呢？<br>恩，matrix 可以治，而且包治百病。不过，matrix 有一个限制点，它只能用于一次线性动画表达式。即，针对于抛物线，椭圆曲线这类复杂曲线来说，不太合适。那么有什么办法吗？<br>有的，微分思想。每一段动画其实都可以通过一定范围内的直线拼接而成，那么这样，我们就可以将一段抛物线拆分为由几段线段构成的曲线。当然，如果你分的越细，拟合度就越高。这里我们不打算过度你和，我们简单的将一段抛物线分为 5段。<br>如图：<br><img src="/2019/09/30/SVG动画介绍/14.png" alt="img"><br>那么接下来就是抠细节。这里，依次取倾角为 45°，30°，0°，-45°，-30° 这 5 段直线。每段分配的时间比例为 20%、25%、10%、25%、20% 这主要是用于 keyframe 的设定。现在，用数学来分析一下，这个动画到底该怎么弄。<br>现在，已知两点之间的距离为 100px。那么我们同样根据上述比例分，则有 20px, 25px, 10px, 25px, 20px。<br>这里我们以 45° 倾角为参考点，则终点坐标为 (20,20); 。那么，该段的矩阵为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意 Y 轴需要取负值！</span></span><br><span class="line"></span><br><span class="line"> <span class="number">1</span> <span class="number">0</span> <span class="number">20</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">-20</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>CSS 中的变形动画为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">-20</span>);</span><br></pre></td></tr></table></figure></p><p>然后，第二段就为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">25</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">-14.4</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>使用矩阵的乘法法，则有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">45</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">-34.4</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p> 变形动画为：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">45</span>,<span class="number">-34.4</span>);</span><br></pre></td></tr></table></figure></p><p>剩余几段也是这样的做法。最终，整个 keyframe 就应该表示为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@keyframe Parabola&#123;</span><br><span class="line">    <span class="number">20</span>%&#123;</span><br><span class="line">        transform: matrix(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">-20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">45</span>%&#123;</span><br><span class="line">        transform: matrix(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">45</span>,<span class="number">-34.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个动画过程差不多都是这样。当然，矩阵也不仅仅局限于这几个动画，凭借着高度定制化和灵活性的特点，这它还常常用于进行回弹，弹跳等动画中。如果大家有兴趣，后期也可以对这类动画进行简单的讲解。<br>后面，我们最后来了解一下 SVG 中很重要的线条动画。</p><h2 id="线条动画"><a href="#线条动画" class="headerlink" title="线条动画"></a>线条动画</h2><p>SVG 中的线条动画常常用作过渡屏（splash screen）中。例如：</p><p><img src="/2019/09/30/SVG动画介绍/15.gif" alt="img"></p><p>或者，一些比较炫酷的 LOGO 中，比如 AllowTeam 的：</p><p><img src="/2019/09/30/SVG动画介绍/16.gif" alt="img"><br>看到这些炫酷的效果，大家有没有动心想学一学，看看自己到底能否做的这么好呢？<br>OK，我们现在来正式介绍一下线条动画。在 SVG 中，最长用到的线条标签就是 Path。这里我前面一篇文章已经做了介绍，我这里就不赘述了。<br>而在具体变化当中用到的是关于 stroke 的相关属性：（下面的属性都可以直接用在 CSS 当中！）</p><ul><li>stroke：定义笔触的颜色。例如：stroke=”green”</li><li>stroke-dasharray：定义 dash 和 gap 的长度。它主要是通过使用 , 来分隔 实线 和 间隔 的值。例如：stroke-dasharray=”5, 5” 表示，按照 实线为 5，间隔为 5 的排布重复下去。如下图：<br><img src="/2019/09/30/SVG动画介绍/28.png" alt="img"><br>放大看有：<br><img src="/2019/09/30/SVG动画介绍/17.png" alt="img"><br>另外，stroke-dasharray 并不局限于只能设置两个值，要知道，它本身的含义是设置最小重复单元，即，dash,gap,dash,gap…。比如，我定义 stroke-dasharray=”15, 10, 5” 则相当于，[15,10,5] 为一段。则有：<br><img src="/2019/09/30/SVG动画介绍/18.png" alt="img"><br>放大看则有：<br><img src="/2019/09/30/SVG动画介绍/19.png" alt="img"></li><li>stroke-dashoffset: 用来设置 dasharray 定义其实 dash 线条开始的位置。值可以为 number || percentage。百分数是相对于 SVG 的 viewport。通常结合 dasharray 可以实现线条的运动。</li><li>stroke-linecap: 线条的端点样式。</li><li>stroke-linejoin: 线条连接的样式</li><li>stroke-miterlimit: 一个比较复杂的概念，如果我们只是画一些一般的线段，使用上面 linejoin 即可。如果涉及对边角要求比较高的，则可以使用该属性进行定义。它的值，其实就是角长度比上线宽：<br><img src="/2019/09/30/SVG动画介绍/20.png" alt="img"><br>而实际理解的话，就是假设当 width 为 1。此时比例为 2。那么 miter = 2。那么超过 2 的 miter 部分则会被 cut 掉。可以参照：<br><img src="/2019/09/30/SVG动画介绍/21.png" alt="img"><br>他主要是配合 linejoin 一起使用。因为 linejoin 默认取值就是 miter。所以，默认情况下就可以使用该标签属性。它默认值为 4。其余的大家下去实践一下即可。详细可以参考: <a href="https://www.oxxostudio.tw/articles/201409/svg-16-storke-miterlimit.html" target="_blank" rel="noopener">miter</a></li><li>stroke-opacity：线段的透明度</li><li>stroke-width：线的粗细。</li></ul><p>OK，介绍完关于 path 的所有 stroke 属性之后，我们就要开始动手写一下让线条动起来的代码。简单来说，就是通过 stroke-dashoffset 和 stroke-dasharray 来做。整个动画可以分为两个过程：</p><ul><li>通过 dasharray 将实线部分隐藏，空余为全线段长。然后，将实线部分增加至全长。比如：dasharray: 0,1000 变为 dasharray: 1000,1000。</li><li>同时，通过 dashoffset 来移动新增的实线部分，造成线段移动的效果。有: dashoffset:0，变为 dashoffset:1000。</li></ul><p>不过，这里我们不打算使用 Path 来做啥复杂的动画，这主要考虑到手头没有一些 SVG 生成工具。所以，这里我们就以 Text 来做吧（因为做起来真的简单）。<br>这里，先以 IV-WEB 这段文字来做动画。<br>先给大家看一下最终结果：<br><img src="/2019/09/30/SVG动画介绍/3.gif" alt="img"><br>那么这种动画是怎么做的呢？<br>这里，我主要介绍一下关于 CSS 相关，SVG 就一个 Text 我直接贴代码了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg viewBox=<span class="string">"0 0 1320 300"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="built_in">Symbol</span> --&gt;</span><br><span class="line">  &lt;symbol id=<span class="string">"s-text"</span>&gt;</span><br><span class="line">    &lt;text text-anchor=<span class="string">"middle"</span></span><br><span class="line">          x=<span class="string">"50%"</span> y=<span class="string">"50%"</span> dy=<span class="string">".35em"</span>&gt;</span><br><span class="line">      IV-WEB</span><br><span class="line">    &lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>symbol&gt;  </span><br><span class="line"></span><br><span class="line">  &lt;!-- Duplicate symbols --&gt;</span><br><span class="line">  &lt;use xlink:href=<span class="string">"#s-text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span></span><br><span class="line">       &gt;&lt;/use&gt;</span><br><span class="line">  &lt;use xlink:href=<span class="string">"#s-text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span></span><br><span class="line">       &gt;&lt;/use&gt;</span><br><span class="line">  &lt;use xlink:href=<span class="string">"#s-text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span></span><br><span class="line">       &gt;&lt;/use&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面是通过创建一个居中定位的字体，然后使用 3 个 text 重叠。具体 CSS 我们下面来说一下。首先，我们营造的效果是从无到有，就需要使用 dasharray 将 gap 设置的足够大。这里我取 300 即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stroke-dasharray: <span class="number">0</span> <span class="number">300</span>;</span><br></pre></td></tr></table></figure></p><p>然后，通过 nth-child 选择器，给每一个文字使用不同的颜色值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:nth-child(<span class="number">3</span>n + <span class="number">1</span>) &#123;</span><br><span class="line">  stroke: #F60A0A;</span><br><span class="line">&#125;</span><br><span class="line">.text:nth-child(<span class="number">3</span>n + <span class="number">2</span>) &#123;</span><br><span class="line">  stroke: #F2FF14;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:nth-child(<span class="number">3</span>n + <span class="number">3</span>) &#123;</span><br><span class="line">  stroke: #FB9505;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面才是重点内容。此时，这 3 个 text 的起始点重合。我现在既要他们在运行时不完全重合，又要他们的线条能进行滚动。不啰嗦了，直接看代码吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@keyframes stroke &#123;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">1000</span>;</span><br><span class="line">    stroke-dasharray: <span class="number">80</span> <span class="number">160</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes stroke1 &#123;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">1080</span>;</span><br><span class="line">    stroke-dasharray: <span class="number">80</span> <span class="number">160</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@keyframes stroke2 &#123;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">1160</span>;</span><br><span class="line">    stroke-dasharray: <span class="number">80</span> <span class="number">160</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是上面 3 个不同的 text 运用的动画。dashoffet 由 0 到 1000。这完成了滚动的目的。同时，为了让字体不重合，我还需要在对应字体的 dashoffset 上，加上不同的间隔距离。比如，第一个字体 offset 为 1000。那么第二个字体，我需要加上前一个字体 dash 的长度，即，80。所以，第二个字体就变为 1080。那么第三个就是加上前两个的 dash 长度，即 1160。<br>大致过程就是这样，详情可以查看： <a href="https://codepen.io/JimmyVV/pen/oWWzdB" target="_blank" rel="noopener">IVWEB 线条动画</a>。</p><h2 id="SVG-中使用-transition"><a href="#SVG-中使用-transition" class="headerlink" title="SVG 中使用 transition"></a>SVG 中使用 transition</h2><p>在 SVG 中，本来就存在相关的动画 Tag，不过里面用起来比较复杂，最常用的还是直接利用 CSS 里面相关的属性标签来做。其中，transition 是最常用的。比如，想做一下颜色的渐变等等。这里可以直接利用 transition 修饰指定的 SVG 属性即可。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># fill 是 SVG 中，专有属性</span><br><span class="line">path &#123; <span class="attr">transition</span>: fill <span class="number">.4</span>s ease; &#125;</span><br><span class="line">#europe       path &#123; fill: red; &#125;</span><br><span class="line">#europe:hover path &#123; fill: white; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="SVG-文字"><a href="#SVG-文字" class="headerlink" title="SVG 文字"></a>SVG 文字</h2><p>在 SVG 中定义文字直接使用 text 标签即可。关于文字来说，一般而言需要注意的点就那么即可，文字的排列，间距等等。这些都可以直接使用 CSS 进行控制。不过，有几个属性比较特殊，这里需要额外提一下。</p><h3 id="text-anchor"><a href="#text-anchor" class="headerlink" title="text-anchor"></a>text-anchor</h3><p>用来定义参考点和实际字符之间的定位关系。格式为：</p><ul><li>text-anchor: start | middle | end | inherit<br>直接看代码解释吧：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Anchors <span class="keyword">in</span> action --&gt;</span><br><span class="line">    &lt;text text-anchor=<span class="string">"start"</span></span><br><span class="line">          x=<span class="string">"60"</span> y=<span class="string">"40"</span>&gt;A&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;text text-anchor="middle"</span></span><br><span class="line"><span class="regexp">          x="60" y="75"&gt;A&lt;/</span>text&gt;</span><br><span class="line"></span><br><span class="line">    &lt;text text-anchor=<span class="string">"end"</span></span><br><span class="line">          x=<span class="string">"60"</span> y=<span class="string">"110"</span>&gt;A&lt;<span class="regexp">/text&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>第一个 A，参考的是 (60,40) 的点，定义为 start ，那么参考点应该在字符的前面。<br><img src="/2019/09/30/SVG动画介绍/22.png" alt="img"><br>而剩下两个也是同样的道理：<br><img src="/2019/09/30/SVG动画介绍/23.png" alt="img"></p><h3 id="tspan"><a href="#tspan" class="headerlink" title="tspan"></a>tspan</h3><p>现在，假如我们想在 text 里面添加一些特殊的字符效果，比如斜体，加粗等。由于，text 标签不能实现嵌套，所以，为了解决这个痛点，提出了 tspan 的标签。它其实就是一个可以嵌套的 text 标签。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;text x=<span class="string">"10"</span> y=<span class="string">"30"</span> style=<span class="string">"font-size:12pt;"</span>&gt;</span><br><span class="line">  Switch among</span><br><span class="line">  &lt;tspan style=<span class="string">"font-style:italic"</span>&gt;italic&lt;<span class="regexp">/tspan&gt;, normal,</span></span><br><span class="line"><span class="regexp">  and &lt;tspan style="font-weight:bold"&gt;bold&lt;/</span>tspan&gt; text.</span><br><span class="line">&lt;<span class="regexp">/text&gt;</span></span><br></pre></td></tr></table></figure></p><p>tspan 里面同样可以自定义相关的自身属性。详细的可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan" target="_blank" rel="noopener">tspan</a> 我这里就不详述了。</p><h3 id="在-Path-展示-text"><a href="#在-Path-展示-text" class="headerlink" title="在 Path 展示 text"></a>在 Path 展示 text</h3><p>Text 一般可以横放，竖放。那有没有啥办法让文字可以按照一定的路径任意排放呢？<br>有的，这里可以使用 textPath 标签，来定义具体参考路径。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;path id=<span class="string">"sharp-corner"</span></span><br><span class="line">    d=<span class="string">"M 30 110 100 110 100 160"</span></span><br><span class="line">    style=<span class="string">"stroke: gray; fill: none;"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;text&gt;</span><br><span class="line">    &lt;textPath xlink:href=<span class="string">"#sharp-corner"</span>&gt;</span><br><span class="line">    Making a quick turn</span><br><span class="line">    &lt;<span class="regexp">/textPath&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>text&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="/2019/09/30/SVG动画介绍/24.png" alt="img"></p><h2 id="Clip"><a href="#Clip" class="headerlink" title="Clip"></a>Clip</h2><p>在 DOM 中如果想展示一个图片的部分，或者以某种形状展示图片的部分，一般是通过一个 cover div 来实现的。不过，如果涉及到不规则图形的话，那么 DOM 就有天生缺陷了（当然使用 CSS 里的 clip-path 可以完成，不过兼容性不太好）。而在 SVG 中，提供了 clipPath 标签，能够让我们自定义裁剪图片的范围和形状。<br>clipPath 里面可以接任何图形，比如，path,rect 甚至是 text。使用的时候，直接在 style 中，指定 clip-path 即可，或者直接使用 clip-path 属性指定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  &lt;clipPath id=<span class="string">"textClip"</span>&gt;</span><br><span class="line">    &lt;text id=<span class="string">"text1"</span> x=<span class="string">"20"</span> y=<span class="string">"20"</span> transform=<span class="string">"rotate(60)"</span></span><br><span class="line">      style=<span class="string">"font-family: 'Liberation Sans';</span></span><br><span class="line"><span class="string">        font-size: 48pt; stroke: black; fill: none;"</span>&gt;</span><br><span class="line">CLIP</span><br><span class="line">    &lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>clipPath&gt;</span><br><span class="line"> &lt;<span class="regexp">/defs&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> &lt;use transform="translate(100, 0)"</span></span><br><span class="line"><span class="regexp">  xlink:href="#shapes" style="clip-path: url(#textClip);"/</span>&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;use transform=<span class="string">"translate(100, 0)"</span></span><br><span class="line">  xlink:href=<span class="string">"#shapes"</span> clip-path=<span class="string">"url(#textClip);"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/09/30/SVG动画介绍/25.png" alt="img"><br>或者说，如果我们想画一个圆的裁剪区域的话：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">     &lt;clipPath id=<span class="string">"circularPath"</span> clipPathUnits=<span class="string">"objectBoundingBox"</span>&gt;</span><br><span class="line">     &lt;circle cx=<span class="string">"0.5"</span> cy=<span class="string">"0.5"</span> r=<span class="string">"0.5"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/clipPath&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>defs&gt;</span><br><span class="line"></span><br><span class="line">&lt;use xlink:href=<span class="string">"#shapes"</span> style=<span class="string">"clip-path: url(#circularPath);"</span> /&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Appendix-参考标签"><a href="#Appendix-参考标签" class="headerlink" title="Appendix 参考标签"></a>Appendix 参考标签</h2><h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><p>分组标签应该毫无意外排第一，因为其实作为绘制图形中最常和最基本的标签。前面一篇文章也主要介绍过了，这里做点补充。<br>每一个分组标签都带有 id 属性，唯一标识该分组，为什么呢？<br>因为，后面我们可以使用该 id 标签添加动画，重用该分组等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;g id=<span class="string">"demo"</span> stroke=<span class="string">"green"</span> fill=<span class="string">"white"</span> stroke-width=<span class="string">"5"</span>&gt;</span><br><span class="line">   &lt;circle cx=<span class="string">"25"</span> cy=<span class="string">"25"</span> r=<span class="string">"15"</span>/&gt;</span><br><span class="line">   &lt;circle cx=<span class="string">"40"</span> cy=<span class="string">"25"</span> r=<span class="string">"15"</span>/&gt;</span><br><span class="line">   &lt;circle cx=<span class="string">"55"</span> cy=<span class="string">"25"</span> r=<span class="string">"15"</span>/&gt;</span><br><span class="line">   &lt;circle cx=<span class="string">"70"</span> cy=<span class="string">"25"</span> r=<span class="string">"15"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><p>每个分组里面可以含有一些描述标签，比如 desc。 这些描述内容是不会被渲染的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;g id=<span class="string">"demo"</span> stroke=<span class="string">"green"</span> fill=<span class="string">"white"</span> stroke-width=<span class="string">"5"</span>&gt;</span><br><span class="line">  &lt;desc&gt;Just Demo&lt;<span class="regexp">/desc&gt;</span></span><br><span class="line"><span class="regexp">  &lt;circle cx="25" cy="25" r="15"/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>该标签就是结合 g 标签一起使用，作用是可以复用 g 分组的样式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;g id=<span class="string">"Port"</span>&gt;</span><br><span class="line">      &lt;circle style=<span class="string">"fill: inherit;"</span> r=<span class="string">"10"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp">&lt;use x="50" y="30" xlink:href="#Port" class="classA"/</span>&gt;</span><br></pre></td></tr></table></figure></p><p>里面使用 xlink:href 加上指定 group 的 id，然后通过 x，y 属性指定副本放置的位置。不过，有一个限制，use 标签的 style 属性，并不能覆盖点原始的 group style 样式。而且，有时候，我们只是想使用一些模板，即，图形并未被解析，只有代码存在。这时候，就需要使用 defs 来包裹了。</p><h3 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h3><p>用来保存一些代码，使其不会被浏览器解析。并且里面的分组可以被 use 属性的 style 样式所覆盖。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;defs&gt;</span><br><span class="line">   &lt;g id=<span class="string">"Port"</span>&gt;</span><br><span class="line">     &lt;circle style=<span class="string">"fill: inherit;"</span> r=<span class="string">"10"</span>/&gt;</span><br><span class="line">   &lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>defs&gt;</span><br><span class="line"></span><br><span class="line">&lt;use x=<span class="string">"50"</span> y=<span class="string">"50"</span> xlink:href=<span class="string">"#Port"</span> style=<span class="string">"fill: blue;"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>该标签和 g 标签类似，也是用来进行分组。不过，它有个特点，即，不会被浏览器所渲染。那它不和 defs 差不多吗？<br>恩，确实。不过，defs 是官方推荐，用来包裹一些模板 svg 代码而创造出来，用来增加可读性的标签。而 symbol 是存粹的作为一个模板。它可以独立于 svg 的 viewbox 来自定义子 viewbox 和 preserveAspectRatio。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;symbol id=<span class="string">"sym01"</span> viewBox=<span class="string">"0 0 150 110"</span>&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"50"</span> cy=<span class="string">"50"</span> r=<span class="string">"40"</span> stroke-width=<span class="string">"8"</span></span><br><span class="line">      stroke=<span class="string">"red"</span> fill=<span class="string">"red"</span>/&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"90"</span> cy=<span class="string">"60"</span> r=<span class="string">"40"</span> stroke-width=<span class="string">"8"</span></span><br><span class="line">      stroke=<span class="string">"green"</span> fill=<span class="string">"white"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/symbol&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;use href="#sym01"</span></span><br><span class="line"><span class="regexp">     x="0" y="0" width="100" height="50"/</span>&gt;</span><br></pre></td></tr></table></figure></p><p>同样使用该模板，也是使用 use 标签来完成。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>既然 use 可以重用 SVG 代码，那么 SVG 里面能不能重用已经画好的 png/jpg 的图片呢？<br>这时候，就需要用到 image 标签。其可以用来加载外部的 PNG, JPEG 图片，注意，官方规定是前两种，其它图片支持不支持官方没做答复。即，如果你使用 GIF 图片，并不能保证所有的浏览器都能正常显示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;image xlink:href=<span class="string">"kwanghwamun.jpg"</span></span><br><span class="line">  x=<span class="string">"72"</span> y=<span class="string">"92"</span></span><br><span class="line">  width=<span class="string">"160"</span> height=<span class="string">"120"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure></p><p>同样，该 image 标签也具有自定义 preserveAspectRatio 的效果。</p><ul><li>x: 定义水平位置</li><li>y: 定义垂直位置</li><li>width: 图片渲染的宽度，必须有。</li><li>height: 图片渲染的高度，必须有。</li><li>preserveAspectRatio: 控制图片的缩放</li></ul><h3 id="marker"><a href="#marker" class="headerlink" title="marker"></a>marker</h3><p>marker 一般是用来画箭头或者线段始末的标识图形。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">    &lt;marker id=<span class="string">"Triangle"</span> viewBox=<span class="string">"0 0 10 10"</span> refX=<span class="string">"1"</span> refY=<span class="string">"5"</span></span><br><span class="line">        markerWidth=<span class="string">"6"</span> markerHeight=<span class="string">"6"</span> orient=<span class="string">"auto"</span>&gt;</span><br><span class="line">      &lt;path d=<span class="string">"M 0 0 L 10 5 L 0 10 z"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/marker&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>defs&gt;</span><br><span class="line"></span><br><span class="line">  &lt;polyline points=<span class="string">"10,90 50,80 90,20"</span> fill=<span class="string">"none"</span> stroke=<span class="string">"black"</span> </span><br><span class="line">      stroke-width=<span class="string">"2"</span> marker-end=<span class="string">"url(#Triangle)"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>如图:<br><img src="/2019/09/30/SVG动画介绍/26.png" alt="img"><br>这里我们只需要里了解即可，因为在实际画的时候，直接使用相关工具生成更加方便。</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>这里的 a 标签和我们直接在 HTML 使用的超链接 a 标签类似。也是用来定义一个外链的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a xlink:href=<span class="string">"https://developer.mozilla.org/en-US/docs/SVG"</span></span><br><span class="line">    target=<span class="string">"_blank"</span>&gt;</span><br><span class="line">  &lt;rect height=<span class="string">"30"</span> width=<span class="string">"120"</span> y=<span class="string">"0"</span> x=<span class="string">"0"</span> rx=<span class="string">"15"</span>/&gt;</span><br><span class="line">  &lt;text fill=<span class="string">"white"</span> text-anchor=<span class="string">"middle"</span> </span><br><span class="line">        y=<span class="string">"21"</span> x=<span class="string">"60"</span>&gt;SVG on MDN&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVG动画效果简单入门介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>SVG入门教程</title>
    <link href="/2019/09/29/SVG%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>/2019/09/29/SVG入门教程/</id>
    <published>2019-09-29T02:04:14.000Z</published>
    <updated>2019-09-29T06:08:38.862Z</updated>
    
    <content type="html"><![CDATA[<p>SVG基础入门教程<br><a id="more"></a></p><h1 id="SVG入门教程"><a href="#SVG入门教程" class="headerlink" title="SVG入门教程"></a>SVG入门教程</h1><p>svg和canvas是web页面画图的两个方式，我们在开发中常用的图形是折线图，柱形图，扇形图等，大多都用现有的库来做，如echarts，highcherts,d3等。但是有些特殊的图形用库是实现不了的，这时候就需要我们自己去完成，canvas性能好，但是难度大，所以，这次我来介绍下svg的基础写法，方便使用。<br>SVG 全称是 Scalable Vector Graphics，即，矢量图。在 Web 中使用 SVG 可以解决位图放大失真的问题。首先，不要把 SVG 和 CSS，Canvas，HTML 搞混。他们之间并没有你中有我，我中有你的关系。SVG 是通过 XML 的形式写在 HTML 文档中的。</p><h2 id="如何书写"><a href="#如何书写" class="headerlink" title="如何书写"></a>如何书写</h2><p>开篇说过，SVG 就是一个 XML。看一下代码吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg x=<span class="string">"0px"</span> y=<span class="string">"0px"</span> width=<span class="string">"450px"</span> height=<span class="string">"100px"</span> viewBox=<span class="string">"0 0 450 100"</span>&gt;</span><br><span class="line">  &lt;rect x=<span class="string">"10"</span> y=<span class="string">"5"</span> fill=<span class="string">"white"</span> stroke=<span class="string">"black"</span> width=<span class="string">"90"</span> height=<span class="string">"90"</span>/&gt;</span><br><span class="line">  &lt;circle fill=<span class="string">"white"</span> stroke=<span class="string">"black"</span> cx=<span class="string">"170"</span> cy=<span class="string">"50"</span> r=<span class="string">"45"</span>/&gt;</span><br><span class="line">  &lt;polygon fill=<span class="string">"white"</span> stroke=<span class="string">"black"</span> points=<span class="string">"279,5 294,35 328,40 303,62</span></span><br><span class="line"><span class="string">  309,94 279,79 258,94 254,62 230,39 263,35"</span>/&gt;</span><br><span class="line">  &lt;line fill=<span class="string">"none"</span> stroke=<span class="string">"black"</span> x1=<span class="string">"410"</span> y1=<span class="string">"95"</span> x2=<span class="string">"440"</span> y2=<span class="string">"6"</span>/&gt;</span><br><span class="line">  &lt;line fill=<span class="string">"none"</span> stroke=<span class="string">"black"</span> x1=<span class="string">"360"</span> y1=<span class="string">"6"</span> x2=<span class="string">"360"</span> y2=<span class="string">"95"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure></p><p>大家看 svg 标签中带有一个 viewBox 的属性。这其实是 SVG 中一个很重要的概念，后面的缩放都会与它有关。<br>说到这里，我们就需要了解一下关于 SVG 的几个基本概念。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>简单来说有 3 个基本概念：</p><ul><li>viewport: 物理窗口</li><li>viewbox: 实物窗口（算了，下面解释）</li><li>preserveAspectRatio: 保留横纵比</li></ul><p>我们接下来，一个一个的进行讲解吧。</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>参照上面的 demo，这实际上就是你用 x,y,width,height。这 4 个属性，在页面上固定的矩形区域。</p><h3 id="viewbox"><a href="#viewbox" class="headerlink" title="viewbox"></a>viewbox</h3><p>定义 SVG 元素在 viewport 中的具体尺寸比例。假设有如下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"500"</span> height=<span class="string">"200"</span> viewBox=<span class="string">"0 0 50 20"</span> &gt;</span><br><span class="line"> &lt;rect x=<span class="string">"20"</span> y=<span class="string">"10"</span> width=<span class="string">"10"</span> height=<span class="string">"5"</span> style=<span class="string">"stroke: #000000; fill:none;"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>viewport 为 [0,0] 到 [500,200]</li><li>viewbox 为 [0,0] 到 [50,20]</li></ul><p>默认情况下 SVG 是自动填充满 viewport 的。注意，在 SVG 中，子标签的所有尺寸都是不能带单位的，因为初始单位就是根据上面两个概念确定。<br>当为以上情况，SVG 中基本的尺寸则不是 1px，而是 500/50 = 10px。所以，如下的图形大小为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=<span class="string">"20"</span> y=<span class="string">"10"</span> width=<span class="string">"10"</span> height=<span class="string">"5"</span> style=<span class="string">"stroke: #000000; fill:none;"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>也就是在 SVG 里面定义的 rect 图形，它的实际尺寸为 [200,100] 到 [100,50]。</p><h3 id="preserveAspectRatio"><a href="#preserveAspectRatio" class="headerlink" title="preserveAspectRatio"></a>preserveAspectRatio</h3><p>该属性就是用来定义上面 viewport 和 viewbox 相互对齐的方式。换句话就是说，它的属性可以改变 viewbox 的具体位置。基本格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;align&gt; [&lt;meetOrSlice&gt;]</span><br></pre></td></tr></table></figure></p><ul><li>align: 定义 viewport 和 viewbox 的对齐方式，分为 x,y 轴两个方向。X 轴方向有三种方式：左边重合（xMin），x 轴中点重合（xMid），右边重合（xMax）。同理，Y 轴也有 顶边重合（YMin），y 轴中点重合（YMid），底边边重合（YMax）</li><li>meetOrSlice: 主要就是定义该 SVG 是内嵌，还是裁剪或是 none（听天有命）。</li></ul><p>其中，align 需要着重理解一下。首先，它的默认值为 xMidYMid，即为中点重合。<br><img src="/2019/09/29/SVG入门教程/1.png" alt="img"><br>可以从图中看出，viewbox 是通过中心进行延展的。注意，它的原点坐标还是在 viewbox 的左上角。如果你是动态增加尺寸的话，此时并不是从左到右增加，而是从中心向两端扩张。同理，如果你使用的是 xMinYMin 的话，那么如果存在尺寸变化，那么相对点则是从左上角开始的。简单来说，align 相对点其实一共有 9 个。<br><img src="/2019/09/29/SVG入门教程/2.png" alt="img"><br>然后就是 meet || slice || none 这三个属性具体干的事情。<br>在这之前，我们需要了解一个公式–缩放比计算公式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vb_h * rat_y = vp_h; 或者 vb_w * rat_x = vp_w;</span><br></pre></td></tr></table></figure></p><p>其中，vb_ 为 viewbox 简写，vp_ 为 viewport 的简写。vb_h 代表就是 viewbox height。vb_w 代表就是 viewbox width。rat_x/y 代表的是 x,y 轴的缩放比例。<br>假设有下列情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"400"</span> height=<span class="string">"200"</span> viewBox=<span class="string">"0 0 200 200"</span> preserveAspectRatio=<span class="string">"xMinYMin slice"</span> style=<span class="string">"border:1px solid #cd0000;"</span>&gt;</span><br><span class="line">    &lt;rect x=<span class="string">"10"</span> y=<span class="string">"10"</span> width=<span class="string">"150"</span> height=<span class="string">"150"</span> fill=<span class="string">"#cd0000"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure></p><p>那么，rat_x 和 rat_y 分别为：</p><ul><li>rat_x = 400/200 = 2</li><li>rat_y = 200/200 = 1</li></ul><p>现在，针对上面 meet/slice 不同的取值，实际应用到 svg 里面的缩放比例是不同的。</p><ul><li>meet(默认值): 本意是让 svg 尽可能的显示在 viewport 里，即，会在 rat_x 和 rat_y 中选择最小的值作为缩放标准。</li><li>slice: 本意是让 svg 完全铺满 viewport，即，会在 rat_x 和 rat_y 中选择最大的值作为缩放标准。</li></ul><p>所以针对不同的取值，基准比例也不同。<br>当为 meet 的情况，那么实际缩放比例为 1。则里面实际矩形的大小就为 (10,10) 到 (150,150)。<br><img src="/2019/09/29/SVG入门教程/3.png" alt="img"><br>当为 slice 的情况，那么实际缩放比例为 2。则里面实际矩形的大小就为 (20,20) 到 (300,300)。<br><img src="/2019/09/29/SVG入门教程/4.png" alt="img"><br>如果你的值为 none 的话，他会直接铺满整个 viewport，即，实际矩形大小为：(20,10) 到 (300,150)。<br><img src="/2019/09/29/SVG入门教程/5.png" alt="img"></p><h3 id="响应式-SVG"><a href="#响应式-SVG" class="headerlink" title="响应式 SVG"></a>响应式 SVG</h3><p>虽然讲起响应式，一些童鞋会想这 TM 又是啥奇技淫巧？<br>对不起，并不是。。。就是一个 viewbox 并且不带 width/height 而已。<br>看个实际的例子吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg viewBox=<span class="string">"0 0 218.8 87.1"</span>&gt;</span><br><span class="line">  &lt;g fill=<span class="string">"none"</span> stroke=<span class="string">"#000"</span>&gt;</span><br><span class="line">    &lt;path d=<span class="string">"M7.3 75L25.9 6.8s58.4-6.4 33.5 13-41.1 32.8-11.2 30.8h15.9v5.5s42.6</span></span><br><span class="line"><span class="string">      18.8 0 20.6"</span> /&gt;</span><br><span class="line">    &lt;path d=<span class="string">"M133.1 58.2s12.7-69.2 24.4-47.5c0 0 4.1 8.6 9.5.9 0 0 5-10 10.4.9 0</span></span><br><span class="line"><span class="string">      0 12.2 32.6 13.6 43 0 0 39.8 5.4 15.8 15.4-13.2 5.5-53.8</span></span><br><span class="line"><span class="string">      13.1-77.4 5.9.1 0-51.9-15.4 3.7-18.6z"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/g&gt; </span></span><br><span class="line"><span class="regexp">&lt;/</span>svg&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到，上面的 svg 标签并没有带上啥 width/height 属性，只是简单描述了 viewBox 的范围而已。当然，里面的尺寸标准都是在这 viewBox 的范围内进行设置的。<br>另外，在这里声明一下，本文章并不是新手教程，也就是说，不会教你一步一步的画直线啊，圆啊，矩形啊等等这些基本图形。这些直接 google 一下，一搜一大把。所以，这里假设大家的水平是处于，能对 SVG 基本的图形属性熟悉即可，对一些高级属性还不是很清楚和熟练。OK，继续~<br>在 SVG 中，能够直接使用的图形有:</p><ul><li>rect</li><li>circle</li><li>ellipse</li><li>line</li><li>polyline</li><li>polygon</li></ul><p>上面没有啥说的，后面我详细说一下两个比较重要的概念，分组和 Path。</p><h2 id="分组和-Path"><a href="#分组和-Path" class="headerlink" title="分组和 Path"></a>分组和 Path</h2><p>通常 Path 和 分组通常是一起使用的，如上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;g fill=<span class="string">"none"</span> stroke=<span class="string">"#000"</span>&gt;</span><br><span class="line">    &lt;path d=<span class="string">"M7.3 75L25.9 6.8s58.4-6.4 33.5 13-41.1 32.8-11.2 30.8h15.9v5.5s42.6</span></span><br><span class="line"><span class="string">      18.8 0 20.6"</span> /&gt;</span><br><span class="line">    &lt;path d=<span class="string">"M133.1 58.2s12.7-69.2 24.4-47.5c0 0 4.1 8.6 9.5.9 0 0 5-10 10.4.9 0</span></span><br><span class="line"><span class="string">      0 12.2 32.6 13.6 43 0 0 39.8 5.4 15.8 15.4-13.2 5.5-53.8</span></span><br><span class="line"><span class="string">      13.1-77.4 5.9.1 0-51.9-15.4 3.7-18.6z"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><p>分组我们放到后面进行讲解，这里先看一下 Path。</p><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Path 在 SVG 中的地位应该是比较高的，实际上，利用 Path 这个一个标签可以画出任意的图形。path 中 d(data) 属性是用来定义相关线条数据，通常是以 M/m 为起始，代表的就是 move to 的意思。在 path 中，一共可以定义 10 种不同的图形。例如 M/m，L/l。 大家可以注意，每种标识符有两种书写方式，即，大小写。</p><ul><li>大写: 参照的是绝对坐标，即，SVG 的右上角</li><li>小写: 参照的相对坐标，即，前一个点的坐标。</li></ul><p>而在 10 中不同表示符中，又可以分为直线和曲线两种不同的标识符。这里，我们分类来讲解一下。</p><h3 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h3><h4 id="M-m"><a href="#M-m" class="headerlink" title="M/m"></a>M/m</h4><p>该使用定义起始点的，没啥特殊的作用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M10 10"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>表示，以 (10,10) 为起始点。</p><h4 id="L-l"><a href="#L-l" class="headerlink" title="L/l"></a>L/l</h4><p>原意是 Line to，用来画线段的。格式和 M/m 差不多：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L x y (or l dx dy)</span><br></pre></td></tr></table></figure></p><h4 id="H-h"><a href="#H-h" class="headerlink" title="H/h"></a>H/h</h4><p>用来画水平线，即，Horizontal。既然方向已经定了，剩下的就是距离，格式很简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H x (or h dx)</span><br></pre></td></tr></table></figure></p><h4 id="V-v"><a href="#V-v" class="headerlink" title="V/v"></a>V/v</h4><p>用来画竖直线，即，vertical。同上，方向也定了，格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V y (or v dy)</span><br></pre></td></tr></table></figure></p><p>看个例子吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M10 10 H 90 V 90 H 10 L 10 10&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>该 path 实际上就是画了一个正方形，宽 = 高 = 90。<br><img src="/2019/09/29/SVG入门教程/6.png" alt="img"></p><h4 id="Z-z"><a href="#Z-z" class="headerlink" title="Z/z"></a>Z/z</h4><p>该标识符用来表示 path 的结束，并且将最后一点和 M/m 标识开头的一点连接起来。所以，它不存在什么表示点之类的，格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z (or z)</span><br></pre></td></tr></table></figure></p><p>而上面也可以进行相关的优化，最终的结果为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M10 10 H 90 V 90 H 10 L 10 10"</span>/&gt;</span><br><span class="line"><span class="comment">// 使用 Z</span></span><br><span class="line">&lt;path d=<span class="string">"M10 10 H 90 V 90 H 10 Z"</span> fill=<span class="string">"transparent"</span> stroke=<span class="string">"black"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>曲线就是 Web 画图中常见的 Bezier Curves（贝塞尔），Arcs，several Bezier curves（很多贝塞尔 - .-）等。<br>我们简单看一下：</p><h4 id="C-c"><a href="#C-c" class="headerlink" title="C/c"></a>C/c</h4><p>这是正统的贝塞尔曲线，需要 4 个参考点，下图应该说比较确切表示了二次贝塞尔所需要的点。所以，C/c 需要定义三个点。<br><img src="/2019/09/29/SVG入门教程/7.png" alt="img"><br>基本格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M10 10 C 20 20, 40 20, 50 10"</span> stroke=<span class="string">"black"</span> fill=<span class="string">"transparent"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="S-s"><a href="#S-s" class="headerlink" title="S/s"></a>S/s</h4><p>该标识符实际上使用来表示一个反射贝塞尔，即，在原有贝塞尔上再加一段贝塞尔曲线，所以，S/s 一般和 C/c 一起使用。<br>基本格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S x2 y2, x y (or s dx2 dy2, dx dy)</span><br></pre></td></tr></table></figure></p><p>实际样式图为：<br><img src="/2019/09/29/SVG入门教程/8.png" alt="img"><br>相当于原有的贝塞尔曲线的最后一段进行反向延长并对称。然后加上新定义的一段限制曲线。<br>具体实例为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80"</span> stroke=<span class="string">"black"</span> fill=<span class="string">"transparent"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Q-q"><a href="#Q-q" class="headerlink" title="Q/q"></a>Q/q</h4><p>该标识符是用来定义二次(quadratic)贝塞尔曲线，该曲线相当于上面传统的贝塞尔来说，更加简单，它只需要定义三个点，即可完整一个贝塞尔曲线，具体作图过程如下：<br><img src="/2019/09/29/SVG入门教程/9.gif" alt="img"><br>基本格式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q x1 y1, x y (or q dx1 dy1, dx dy)</span><br></pre></td></tr></table></figure></p><p>即为图上点， P1(x1,y1)，P2(x,y)<br>起始点为 M 定义的点，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M10 80 Q 95 10 180 80"</span> stroke=<span class="string">"black"</span> fill=<span class="string">"transparent"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="T-t"><a href="#T-t" class="headerlink" title="T/t"></a>T/t</h4><p>该标识符和 S 差不多，也是一个贝塞尔曲线的延长。相当于原曲线的控制点 P1 相当于 end point P2 做对称，然后，只需要定义一个终点即可，即，T/t 只需要定义贝塞尔曲线里面的终点即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T x y (or t dx dy)</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="/2019/09/29/SVG入门教程/10.png" alt="img"><br>所以，简单来说，C/S，Q/T 是两两搭配一起使用的。在使用的时候，千万不要搞混即可。</p><h3 id="弧线"><a href="#弧线" class="headerlink" title="弧线"></a>弧线</h3><h4 id="A-a"><a href="#A-a" class="headerlink" title="A/a"></a>A/a</h4><p>该曲线是用来画弧线(Arcs)，而，弧线通常是圆/椭圆的一部分。当，椭圆的两个轴径长相等则为圆，所以，A/a 是按照椭圆作为基准格式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br><span class="line">a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</span><br></pre></td></tr></table></figure></p><p>说实在的，这个比较复杂。因为，他画椭圆的方式和我们平常不一样，一般情况下，椭圆只要确定一个中心，然后是长短轴，然后是弧度范围即可。<br>但是，它这里是通过椭圆上的两点来确定的，在加上旋转角度，俩轴径等因素来确定的。另外，需要注意，它的起始点是从上一个命令的结束点位置开始计算的。OK，我们首先简单了解一下格式里面的参数：</p><ul><li>rx,ry: 代表的就是长轴短轴，没得说。</li><li>x,y: 代表的是弧长的结束点。开始点就是上一个命令的终点。</li><li>x-axis-rotation: x 轴的旋转角度。顺时针为正</li><li>large-arc-flag[0,1]: 表示取大弧还是小弧。因为两点之间的弧长有两部分。</li><li>sweep-flag[0,1]: 取顺时针的弧，还是逆时针的弧长。参考点是以起始点开始的。</li></ul><p>上面几个属性中，比较难理解的就是 large-arc-flag 和 sweep-flag。这么说吧，前面几个属性充其量只能确定椭圆的位置，和经过椭圆的两个点，不过，一般能通过指定两点的椭圆有两个，而通过这两点划分又会出现 4 段弧长。为了确定 4 个弧长中，是哪一个，需要两个值来确定。即，4 抽 2，2 抽 1。<br><img src="/2019/09/29/SVG入门教程/11.png" alt="img"><br>简单说一种，例如当，laf 和 sf 都为 0的情况。首先，laf 为 0 选择的是小弧长。所以，里面两段比较小的弧长被抽出来。然后，sf 为 0 选择的是逆时针。即，以起始点为参考，选择通过逆时针方向到达终点的那段弧。即，2 抽 1。最终得出我们需要的弧。<br>说实在的，这个是真 TM 复杂。。。<br>给一个参考<a href="https://codepen.io/netsi1964/pen/pJzWoz" target="_blank" rel="noopener">codepen</a>。<br>一般情况下，我们并不需要手动来确定 path，有工具为啥不用工具呢！<br>比如，Illustrator, Sketch 等，都可以自动生成 SVG。不过，生成之后，需要对代码做相关的压缩优化，这些都可以直接在编译器里面找到。<br>你也可以用一下可视化工具<a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="noopener">SVGOMG</a>来简单看一下。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>SVG 中的分组你可以理解为 PS 中的图层，一块图层里面通常只会放一下高内聚的图形，这样既方便移动又方便做动画。SVG 中的分组标签就是 g，使用 g 标签包裹的所有子元素都认同为一组。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;g&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"20"</span> cy=<span class="string">"20"</span> r=<span class="string">"20"</span> fill=<span class="string">"green"</span> /&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"70"</span> cy=<span class="string">"70"</span> r=<span class="string">"20"</span> fill=<span class="string">"purple"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp">&lt;g&gt;</span></span><br><span class="line"><span class="regexp">  &lt;rect x="110" y="110" height="30" width="30" fill="blue" /</span>&gt;</span><br><span class="line">  &lt;rect x=<span class="string">"160"</span> y=<span class="string">"160"</span> height=<span class="string">"30"</span> width=<span class="string">"30"</span> fill=<span class="string">"red"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，使用 g 进行分组，并不会改变原有元素的在屏幕上展示的效果。<br>不过，g 标签除了分组，还有另外一个很重要的功能–动画</p><h4 id="分组动画"><a href="#分组动画" class="headerlink" title="分组动画"></a>分组动画</h4><p>在分组重定义动画是直接写在 transform 属性当中的。实际上，每个子标签都可以使用 transform 的相关属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;g transform=<span class="string">"translate(...) scale(...) rotate(...) translate(...) rotate(...)"</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/g&gt;</span></span><br></pre></td></tr></table></figure></p><p>每种变换动画之间是通过 空格或逗号 连接的。它的执行顺序是从右到左。为啥呢？实际上可以理解为，这就是几个嵌套的 g 叠在一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &lt;g transform=<span class="string">"translate(...) scale(...) rotate(...) translate(...) rotate(...)"</span>&gt;</span><br><span class="line">   ...</span><br><span class="line"> &lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ Being Equivalent to this:</span></span><br><span class="line"><span class="regexp"> &lt;g transform="translate(...)"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;g transform="scale(...)"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;g transform="rotate(...)"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;g transform="translate(...)"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;g transform="rotate(...)"&gt;</span></span><br><span class="line"><span class="regexp">          ...</span></span><br><span class="line"><span class="regexp">        &lt;/g</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/g</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp">&lt;/g</span>&gt;</span><br></pre></td></tr></table></figure></p><p>具体可以使用的动画形式和 CSS 动画一模一样，详情可以参考: <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform" target="_blank" rel="noopener">SVG动画</a></p><p>以上就是SVG的简单入门介绍，<a href="https://www.villainhr.com/page/2017/04/17/SVG%20快速入门" target="_blank" rel="noopener">原文请点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVG基础入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer爬取简书文章</title>
    <link href="/2019/09/26/puppeteer%E7%88%AC%E5%8F%96%E7%AE%80%E4%B9%A6%E6%96%87%E7%AB%A0/"/>
    <id>/2019/09/26/puppeteer爬取简书文章/</id>
    <published>2019-09-26T03:05:46.000Z</published>
    <updated>2019-10-10T05:36:26.016Z</updated>
    
    <content type="html"><![CDATA[<p>puppeteer爬取简书文章的小例子<br><a id="more"></a></p><h1 id="puppeteer爬取简书文章"><a href="#puppeteer爬取简书文章" class="headerlink" title="puppeteer爬取简书文章"></a>puppeteer爬取简书文章</h1><p>puppeteer这个工具库我已经了解有些时候了，自己在之前的文章中也有简单的介绍，也列出了几个学习站点，不过，第一个爬虫的例子，还是缓缓的到来了。<br>这个小例子很简单，只有几十行代码，大概的流程是，首先打开简书的首页，之后下拉到底部，加载数据，下拉几次之后就没有了下拉加载的功能，取而代之的是“阅读更多”按钮，点击后会加载新内容。就这样往复的加载文章的列表，当符合自己设定的上限值后，停止加载，拿到了文章列表后循环的打开相对应的页面，读取文章详细内容，并写到本地磁盘里。<br>代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// 简书网址</span></span><br><span class="line"><span class="keyword">const</span> baseUrl = <span class="string">'https://www.jianshu.com'</span>;  </span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    headless:<span class="literal">false</span>,</span><br><span class="line">    slowMo:<span class="number">250</span>,</span><br><span class="line">    defaultViewport: &#123;</span><br><span class="line">      width: <span class="number">1200</span>,</span><br><span class="line">      height: <span class="number">600</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="comment">// page.setDefaultNavigationTimeout(timeout);</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(baseUrl);</span><br><span class="line">  <span class="comment">// await page.waitFor(1000);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取简书首页中的列表数据</span></span><br><span class="line">  <span class="keyword">const</span> hrefList = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">baseUrl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [], list;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">loadPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'.load-more'</span>); </span><br><span class="line">        <span class="keyword">if</span>(btn) &#123;</span><br><span class="line">          btn.click();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> pageHeight = <span class="built_in">document</span>.querySelector(<span class="string">'#list-container'</span>).offsetHeight;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;pageHeight; i++) &#123;</span><br><span class="line">            <span class="built_in">document</span>.documentElement.scrollTo(<span class="number">0</span>, i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          list = <span class="built_in">document</span>.querySelectorAll(<span class="string">'#list-container .note-list li'</span>);</span><br><span class="line">          <span class="keyword">if</span>(list.length &lt; <span class="number">50</span>) &#123;</span><br><span class="line">            loadPage();</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">              <span class="keyword">let</span> href = item.querySelector(<span class="string">'a'</span>).getAttribute(<span class="string">'href'</span>);</span><br><span class="line">              arr.push(baseUrl + href);</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(arr);</span><br><span class="line">          &#125;    </span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      loadPage();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, baseUrl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过hrefList来获取单个的文章内容，并写入文章文件</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> hrefList) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> page.goto(item);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">var</span> article = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> mainText;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        mainText = <span class="built_in">document</span>.querySelector(<span class="string">'._gp-ck'</span>).innerHTML;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        mainText = <span class="string">'此页面有问题。'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mainText;</span><br><span class="line">    &#125;);</span><br><span class="line">    fs.writeFileSync(<span class="string">'./download-articles/'</span>+item.replace(<span class="regexp">/\/|\:|\./g</span>, <span class="string">''</span>)+<span class="string">'.txt'</span>, article, &#123;</span><br><span class="line">      flag: <span class="string">'a'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭浏览器</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>以后还会更新些更复杂的爬虫案例哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;puppeteer爬取简书文章的小例子&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="爬虫" scheme="/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
