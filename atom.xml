<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2023-04-19T02:08:46.166Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYSQL(十二)</title>
    <link href="/2023/04/06/MYSQL-%E5%8D%81%E4%BA%8C/"/>
    <id>/2023/04/06/MYSQL-十二/</id>
    <published>2023-04-06T08:14:23.000Z</published>
    <updated>2023-04-19T02:08:46.166Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-账号管理<br><a id="more"></a></p><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>MYSQL 新版本需要将创建用户与权限配置分配操作</p><h3 id="添加帐号"><a href="#添加帐号" class="headerlink" title="添加帐号"></a>添加帐号</h3><p>添加用户 houdunren 并设置密码为 admin888<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER houdunren IDENTIFIED BY &apos;admin888&apos;;</span><br></pre></td></tr></table></figure></p><p>刷新帐表使设置立刻生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>下面是设置 root 帐号的密码为 admin888<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;admin888&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>下面来学习设置权限，修改权限后需要用户重新登录生效。<br>查看当前用户权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW grants;</span><br></pre></td></tr></table></figure></p><p>查看指定用户权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &apos;houdunren&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>移除用户权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE ALL ON *.* FROM houdunren@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>用户可以为 code 库中的所有表执行 SELECT 与 INSERT 操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT ,INSERT ON code.* TO houdunren@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>可以从任何电脑登录服务器并管理所有库和表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON *.* TO houdunren@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>用户可以管理 code 库中的所有表，来源以 192.168.0 开始的 IP 地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON code.* TO houdunren@&apos;192.168.0.%&apos;;</span><br></pre></td></tr></table></figure></p><p>用户 houdunren 可以对 code 库中的所有表执行 ALTER ,CREATE ,DROP 指令，并且来源不受限制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALTER ,CREATE ,DROP ON code.* TO houdunren@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-账号管理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(十一)</title>
    <link href="/2023/04/06/MYSQL-%E5%8D%81%E4%B8%80/"/>
    <id>/2023/04/06/MYSQL-十一/</id>
    <published>2023-04-06T08:14:15.000Z</published>
    <updated>2023-04-19T01:56:54.669Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-索引优化<br><a id="more"></a></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>合理设置索引会对数据库性能带来很大提升。</p><h4 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h4><p>为了演示索引需要添加些测试数据，下面是添加学生数据的储存过程代码。如果你已经有测试数据可以省掉这一步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE add_stus(IN num int)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i int DEFAULT 0;</span><br><span class="line">DECLARE _birthday datetime;</span><br><span class="line">WHILE num&gt;i DO</span><br><span class="line">    SET _birthday  = date_sub(now(),INTERVAL floor(RAND()*1000) day);</span><br><span class="line">    INSERT INTO stu SET</span><br><span class="line">    sname = concat(left(md5(RAND()),5),&apos;后盾人向军&apos;),</span><br><span class="line">    class_id =1+FLOOR( RAND()*100000),</span><br><span class="line">    birthday = _birthday ,</span><br><span class="line">    sex = 1+FLOOR(RAND()*2 );</span><br><span class="line"></span><br><span class="line">    SET i= i+1;</span><br><span class="line">END WHILE;</span><br><span class="line">END</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p><p>调用储存过程添加五十万条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call add_stus(500000)</span><br></pre></td></tr></table></figure></p><h4 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h4><p>选择合理范围内最小的</p><p>我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘 I/0 读写开销，减少内存占用，减少 CPU 的占用率。</p><p>选择相对简单的数据类型</p><p>数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如说在保存时间时，因为 PHP 可以良好的处理 LINUX 时间戳所以我们可以将日期存为 int(10)要方便、合适、快速的多。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串数据类型是一个万能数据类型，可以储存数值、字符串等。</p><p>保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的 9 是大于 22 的。如果进行运算时 mysql 会将字符串转换为数值类型，这种转换是不会走索引的。</p><p>如果明确数据在一个完整的集合中如男，女，那么可以使用 set 或 enum 数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。</p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><strong>整数</strong></p><p>整数类型很多比如 tinyint、int、smallint、bigint 等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时 tinyint(10)与 tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定 zerofill 属性查看显示时区别。</p><p><strong>浮点数与精度数值</strong></p><p>浮点数 float 与 double 在储存空间及运行效率上要优于精度数值类型 decimal，但 float 与 double 会有舍入错误而 decimal 则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。</p><p><strong>总结</strong><br>数值数据类型要比字符串执行更快，范围区间小的数据类型占用空间更少，处理速度更快，如 tinyint 可比 bigint 要快的多。选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型。</p><h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><p>EXPLAIN 指令可以帮助开发人员分析 SQL 问题，explain 显示了 mysql 如何使用索引来处理 select 语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。<br><strong>字段说明</strong></p><table><thead><tr><th>字段</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>索引执行顺序</td><td></td></tr><tr><td>select_type</td><td>查询类型</td><td>simple:基本查询 <br> union result:union 的结果</td></tr><tr><td>table</td><td>操作表</td><td></td></tr><tr><td>type</td><td>使用类型</td><td>const: 前面表匹配唯一行检索速度快，如果使用主键值比较<br>ref: 前面表中的非唯一数据<br>eq_ref:前面表中非唯一数据，使用了唯一索引字段，如表关联时使用主键<br>range:索引区间获得，如使用 IN(1,2,3)筛选<br>all:全表遍历<br>index:与 all 类似只是扫描所有表，而非数据表</td></tr><tr><td>possible_keys</td><td>可能用到的索引，不一定被真正使用</td></tr><tr><td>key</td><td>最终使用的索引</td><td></td></tr><tr><td>key_len</td><td>索引字节数</td><td></td></tr><tr><td>ref</td><td>列与索引的比较</td><td>const 为常量比较</td></tr><tr><td>rows</td><td>预计读出的记录条数</td><td></td></tr><tr><td>Extra</td><td>查询说明</td><td>&nbsp;</td></tr></tbody></table><p>使用没有添加索引的 birthday 字段会进行全表扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where birthday = &apos;19900231&apos;;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/1.png" alt="img"><br>使用索引表排序所以 type 为 index<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu order by id ;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/2.png" alt="img"><br>使用主键查询会使用 const 类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where id = 3;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/3.png" alt="img"><br>使用 IN 查询后使用了区间 range 索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where class_id in(1,2,3);</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/4.png" alt="img"><br>下面是多表关联使用索引的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu s inner join class c on s.class_id = c.id where sname = &apos;后盾人&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/5.png" alt="img"></p><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p>索引就像一本书的目录一样，我们可以通过一本书的目录，快速的找到需要的页面，但是我们也不能过多的创建目录页（索引），原因是如果某一篇文章删除或修改将发变所有页码的顺序，就需要重新创建目录。<br><code>select sname from stu where sname=&quot;后盾人&quot;</code> 如果 <code>sname</code> 使用了索引，上面这个例子就会使用到 <code>sname</code> 索引<br><strong>索引弊端</strong></p><ul><li>创建索引会使查询操作变得更加快速，但是会降低增加、删除、更新操作的速度，因为执行这些操作的同时会对索引文件进行重新排序或更新</li><li>创建过多列的索引会大大增加磁盘空间开销</li><li>不要盲目的创建索引，只为查询操作频繁的列创建索引</li></ul><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><table><thead><tr><th>索引</th><th>说明</th></tr></thead><tbody><tr><td>UNIQUE 唯一索引</td><td>不可以出现相同的值，可以有 NULL 值</td></tr><tr><td>INDEX 普通索引</td><td>允许出现相同的索引内容</td></tr><tr><td>PRIMARY KEY 主键索引</td><td>不允许出现相同的值，且不能为 NULL 值</td></tr></tbody></table><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>为 stu 学生表的 sname 字段设置索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD INDEX sname_index(sname)</span><br></pre></td></tr></table></figure></p><p>删除索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP INDEX sname_index</span><br></pre></td></tr></table></figure></p><p>删除主键索引，首先需要移除 auto_increment 然后删除主键索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id int;</span><br><span class="line">ALTER TABLE stu DROP PRIMARY KEY</span><br></pre></td></tr></table></figure></p><p>查看表索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from stu;</span><br></pre></td></tr></table></figure></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>索引是加快查询操作的重要手段，如果当发生查询过慢时添加上索引后会发现速度大大改观</p><h5 id="普通字段"><a href="#普通字段" class="headerlink" title="普通字段"></a>普通字段</h5><p>当没有地表 class_id 字段添加索引时，查找 cid 为 3 的记录会执行全表扫描，性能是最差的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM stu WHERE class_id =5 LIMIT 1;</span><br></pre></td></tr></table></figure></p><p>通过结果的 type=ALL 可以看到执行了全表扫描，遍历了一百万条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select_type   | SIMPLE</span><br><span class="line">table         | stu</span><br><span class="line">partitions    | &lt;null&gt;</span><br><span class="line">type          | ALL</span><br><span class="line">possible_keys | &lt;null&gt;</span><br><span class="line">key           | &lt;null&gt;</span><br><span class="line">key_len       | &lt;null&gt;</span><br><span class="line">ref           | &lt;null&gt;</span><br><span class="line">rows          | 1000000</span><br><span class="line">filtered      | 10.0</span><br><span class="line">Extra         | Using where</span><br></pre></td></tr></table></figure></p><h5 id="索引字段"><a href="#索引字段" class="headerlink" title="索引字段"></a>索引字段</h5><p>下面来为 class_id 添加索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD INDEX class_id(class_id);</span><br></pre></td></tr></table></figure></p><p>再次执行查询来看添加索引后的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM stu WHERE class_id =5 LIMIT 1;</span><br></pre></td></tr></table></figure></p><p>通过查看 type 字段看到已经走了索引，本次查询遍历了 16 条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id            | 1</span><br><span class="line">select_type   | SIMPLE</span><br><span class="line">table         | stu</span><br><span class="line">partitions    | &lt;null&gt;</span><br><span class="line">type          | ref</span><br><span class="line">possible_keys | class_id</span><br><span class="line">key           | class_id</span><br><span class="line">key_len       | 5</span><br><span class="line">ref           | const</span><br><span class="line">rows          | 16</span><br><span class="line">filtered      | 100.0</span><br><span class="line">Extra         | &lt;null&gt;</span><br></pre></td></tr></table></figure></p><h5 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h5><p>在使用连接操作多个表时，如果没有添加索引性能会非常差。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from a join b on a.id=b.id join c on b.id=c.id</span><br></pre></td></tr></table></figure></p><p>结果中会看到每张表都遍历了所有记录<br><img src="/2023/04/06/MYSQL-十一/6.png" alt="img"><br>下面来添加索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE a ADD INDEX id(id);</span><br><span class="line">ALTER TABLE b ADD INDEX id(id);</span><br><span class="line">ALTER TABLE c ADD INDEX id(id);</span><br></pre></td></tr></table></figure></p><p>执行的结果会看到使用了索引，并且并没有进行全表遍历<br><img src="/2023/04/06/MYSQL-十一/7.png" alt="img"></p><h3 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a>字段选择</h3><h4 id="维度思考"><a href="#维度思考" class="headerlink" title="维度思考"></a>维度思考</h4><ul><li>数据列中不重复值出现的个数，维度的最大值是数据行的数量</li><li>如数据表中存在 8 行数据 a ,b ,c,d,a,b,c,d 这个表的维度为 4</li><li>要为维度高的列创建索引</li><li>性别这样的列不适合创建索引，因为维度过低</li></ul><h4 id="索引规则"><a href="#索引规则" class="headerlink" title="索引规则"></a>索引规则</h4><ul><li>对 where，on 或 group by 及 order by 中出现的列使用索引</li><li>对较小的数据列使用索引，这样会使索引文件更小，同时内存中也可以装载更多的索引键</li><li>为较长的字符串使用前缀索引</li><li>不要过多创建索引，除了增加额外的磁盘空间外，对于 DML 操作的速度影响很大</li></ul><h3 id="前缀与组合"><a href="#前缀与组合" class="headerlink" title="前缀与组合"></a>前缀与组合</h3><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>大使用 text/长 varchar 字段时创建索引，会造成索引列长度过长，从而生成过大的索引文件影响检索性能。使用前缀索引方式进行索引，可以有效解决这个问题。前缀索引应该控制在一个合适的点，控制在 0.31 黄金值即可。</p><p>下面是取前缀索引的计算公式，有时也根据字段保存内容确定，比如标题 100 可以取 30 个字符为索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct(left(title,10)))/count(*) from news</span><br></pre></td></tr></table></figure></p><p>下面为文章表 article 的 title 字段添加 30 个长度的前缀索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD INDEX title(title(30));</span><br></pre></td></tr></table></figure></p><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><p>组合索引为是多个字段统一设计索引</p><ul><li>可以较为每个字段设置索引文件体积更小</li><li>使用速度优于多个索引操作</li><li>前面字段没出现，只出现后面字段时不走索引</li></ul><p>下面为学生表中的班级字段 class_id 与学生状态 status 设置组合索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alter table stu add index class_id_status(class_id,status);</span><br></pre></td></tr></table></figure></p><p>使用 class_id 时会走索引，因为 class_id 在组合索引最前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where class_id =3;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/8.png" alt="img"><br>只使用 status 字段不会走索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where status =1</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/9.png" alt="img"><br>当 class_id 与 status 字段一起使用时会走索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where status =1 and class_id=5;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/10.png" alt="img"></p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p>Mysql 的解析器非常智能，会对发出的每条 SQL 进行分析，决定是否使用索引或是否进行全表扫描。</p><p>下面发送的 SQL 解析器分析后已经清楚不会有任何语句符合操作，所以不会操作任何表或索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from houdunwang where false</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/11.png" alt="img"></p><h4 id="表达式影响"><a href="#表达式影响" class="headerlink" title="表达式影响"></a>表达式影响</h4><p>下面 SQL 语句不会使用索引，因为所有索引列参与了计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where status+1=1;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/12.png" alt="img"><br>下面 SQL 不会使用索引，因为使用了函数运算，原理与上面相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where left(sname,1)=&apos;后盾人&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/13.png" alt="img"><br>下面 SQL 不会使用索引，因为索引列是模糊匹配的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where sname like &apos;%向军大叔%&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/14.png" alt="img"><br>下面 SQL 会使用索引，因为不是模糊匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where sname like &apos;后盾人%&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/15.png" alt="img"><br>正则表达式也不会使用索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where sname regexp &apos;^后盾人&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/16.png" alt="img"></p><h4 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h4><p>相同类型比较时走索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where sname=&quot;1&quot;;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/17.png" alt="img"><br>字符串类型使用数值时不走索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from stu where sname=1;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/18.png" alt="img"></p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序中尽量使用添加索引的列进行<br>下例使用数据表进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select id from stu order by birthday</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/19.png" alt="img"><br>排序字段为索引列后使用索引表排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select id from stu order by id ;</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-十一/20.png" alt="img"></p><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>当 Mysql 性能下降时，通过开启慢查询来获得哪条 SQL 语句造成的响应过慢进行分析处理。当然开启慢查询会带来 CPU 损耗与日志记录的 IO 开销，所以我们要间断性的打开慢查询日志来查看 Mysql 运行状态。</p><p>慢查询能记录下所有执行超过 long_query_time 时间的 SQL 语句, 用于找到执行慢的 SQL, 方便我们对这些 SQL 进行优化。</p><h4 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h4><p>查看开启慢查询状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;slow_query%&apos;;</span><br><span class="line"></span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| Variable_name       | Value                             |</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| slow_query_log      | OFF                               |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/homestead-slow.log |</span><br><span class="line">+---------------------+-----------------------------------+</span><br></pre></td></tr></table></figure></p><p>查看慢查询设置的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;long_query_time&quot;</span><br><span class="line"></span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure></p><h4 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h4><p><strong>会话配置</strong></p><p>通过以下指令开启全局慢查询（如果重起 Mysql 后需要重新执行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=&apos;ON&apos;;</span><br></pre></td></tr></table></figure></p><p>设置慢查询时间为 1 秒，即超过 1 秒将会被记录到慢查询日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session long_query_time=1;</span><br></pre></td></tr></table></figure></p><p><strong>全局配置</strong><br>通过修改配置 mysql 配置文件 my.cnf 来开启全局慢查询配置，在配置文件中修改以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow.log</span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure></p><p>重起 MYSQL 服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-索引优化&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(十)</title>
    <link href="/2023/04/06/MYSQL-%E5%8D%81/"/>
    <id>/2023/04/06/MYSQL-十/</id>
    <published>2023-04-06T08:14:07.000Z</published>
    <updated>2023-04-18T08:00:35.082Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-外键约束<br><a id="more"></a></p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>外键表示一个表中的字段被另一个表中的一个字段引用。外键对相关表中的数据造成了限制，使 MySQL 能够保持数据完整性。<br>比如学生和班级表，学生表完全依赖班级表，我们可以通过外键约束让学生表与班级表产生关联，当班级表数据变化时影响学生表。</p><ul><li>父表和子表储存引擎要一致</li><li>使用 InnoDB 引擎支持外键约束</li><li>外键要与主表列类型一致</li><li>外键列使用索引（有些版本的 mysql 会自动帮助为外键设置索引)</li></ul><h3 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h3><p>下面我们先创建表关联后，再详细解释里面的参数选项。</p><h4 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h4><p>下面创建班级表与学生表，并定义学生表与班级表建立外键约束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 班级表</span><br><span class="line">CREATE TABLE class (id int PRIMARY KEY AUTO_INCREMENT,name varchar(50));</span><br><span class="line"></span><br><span class="line">-- 学生表</span><br><span class="line">CREATE TABLE stu (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  `sname` varchar(30) DEFAULT NULL,</span><br><span class="line">  `class_id` int(11) DEFAULT NULL,</span><br><span class="line">  CONSTRAINT `stu_class`</span><br><span class="line">  FOREIGN KEY (`class_id`)</span><br><span class="line">  REFERENCES `class` (`id`)</span><br><span class="line">  ON DELETE CASCADE</span><br><span class="line">  ON UPDATE CASCADE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure></p><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><p>下面是对学生表添加班级表的外键约束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD</span><br><span class="line">CONSTRAINT stu_class</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES class(id)</span><br><span class="line">ON DELETE SET NULL</span><br><span class="line">ON UPDATE CASCADE;</span><br></pre></td></tr></table></figure></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP FOREIGN KEY stu_class;</span><br></pre></td></tr></table></figure><h3 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h3><p>下面列出外键关联用到的关键词。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRAINT</td><td>为外键约束定义名称</td></tr><tr><td>FOREIGN KEY</td><td>子表与父表关联的列</td></tr><tr><td>REFERENCES</td><td>子表关联的父表字段</td></tr><tr><td>ON DELETE</td><td>父表删除时的处理方式</td></tr><tr><td>ON UPDATE</td><td>父表更新时的处理方式</td></tr></tbody></table><h3 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h3><h4 id="ON-DELETE"><a href="#ON-DELETE" class="headerlink" title="ON DELETE"></a>ON DELETE</h4><p>ON DELETE 指在删除时的处理方式，常用的处理方式包括以下几种。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>ON DELETE CASCADE</td><td>删除父表记录时，子表记录同时删除</td></tr><tr><td>ON DELETE SET NULL</td><td>删除父表记录时，子表记录设置为 NULL（子表字段要允许 NULL）</td></tr><tr><td>ON DELETE NO ACTION <br> ON DELETE RESTRICT</td><td>删除父表记录时，子表不做任何处理，必须把子表处理完才可以删除主表</td></tr></tbody></table><h4 id="ON-UPDATE"><a href="#ON-UPDATE" class="headerlink" title="ON UPDATE"></a>ON UPDATE</h4><p>ON UPDATE 指在更新时的处理方式，常用的处理方式包括以下几种。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>ON UPDATE CASCADE</td><td>更新父表记录时，比如更改主表的主键时，子表记录同时更新</td></tr><tr><td>ON UPDATE SET NULL</td><td>更新父表记录时，比如更改主表的主键时，子表记录设置为 NULL</td></tr><tr><td>ON UPDATE NO ACTION <br> ON UPDATE RESTRICT</td><td>更新父表记录时，子表不做任何处理，必须把子表处理完才可以更新主表</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-外键约束&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(九)</title>
    <link href="/2023/04/06/MYSQL-%E4%B9%9D/"/>
    <id>/2023/04/06/MYSQL-九/</id>
    <published>2023-04-06T08:13:57.000Z</published>
    <updated>2023-04-17T08:50:55.169Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-锁机制<br><a id="more"></a></p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>因为 Mysql 支持多线程方式，所以可以同时处理多个客户端请求。有时为了防止客户端同时修改数据，我们使用锁操作完成。</p><p>比如一个用户在修改数据，另一个用户也要修改该条数据，我们可以让第一个用户独占这个表记录，等他操作完再让第二个用户操作。</p><p>下面是典型的商城应用，多用户购买商品时可以使用锁机制保障库存的准确性。<br><img src="/2023/04/06/MYSQL-九/1.png" alt="img"></p><h3 id="储存引擎"><a href="#储存引擎" class="headerlink" title="储存引擎"></a>储存引擎</h3><p><code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能，下面来演示行锁的运行过程。<code>MyIsam</code>引擎在最新版本的 MYSQL 中已经废弃所以不过多讨论了。</p><ul><li>行锁开销大，锁表慢</li><li>行锁高并发下可并行处理，性能更高</li><li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li><li>在事务执行过程中，随时都可以执行锁定，锁在执行 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 的时候释放</li></ul><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>1.A 事务执行以下代码但不提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE stu SET sname = &apos;hdcms&apos; WHERE id=1;</span><br></pre></td></tr></table></figure></p><p>2.B 事务执行以下代码，可以正常执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">update stu set sname = &apos;后盾人&apos; where id=3</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></p><p>3.但 B 事务更新与 A 事务相同的记录则无法操作，执行过程发生阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE stu SET sname = &apos;hdcms&apos; WHERE id=1;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>4.当 A 执行执行COMMIT 提交后，解锁记录行这时 B 事务继续执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">COMMIT;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="非索引阻塞"><a href="#非索引阻塞" class="headerlink" title="非索引阻塞"></a>非索引阻塞</h4><p>使用非索引字段筛选时，将造成全表锁定即表级锁，应该避免这种情况发生，提升数据库的并发性能。<br>1.事务 A 执行以下代码，因为sname字段没有添加索引，造成锁定整个表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE stu SET sname = &apos;hdcms&apos; WHERE sname =&apos;后盾人&apos;;</span><br></pre></td></tr></table></figure></p><p>2.现在事务 B 更新任何一条记录都会造成阻塞，因为现在是表锁状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">update stu set sname = &apos;小明&apos; where id=1</span><br><span class="line">-- 阻塞中...</span><br></pre></td></tr></table></figure></p><p>3.将 sname字段添加索引后，行锁功能就又有效了</p><h4 id="范围锁"><a href="#范围锁" class="headerlink" title="范围锁"></a>范围锁</h4><p>查询没有指定明确范围时也会造成大量记录的锁定<br>1.事务 A 筛选时使用了范围区间，将会造成表锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE goods SET num=200 WHERE id&gt;1 AND id&lt;3;</span><br></pre></td></tr></table></figure></p><p>2.事务 B 将不能修改表中的 ID 大于 2 的记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">update goods set num =1 where id=2;</span><br><span class="line">-- 阻塞中...</span><br></pre></td></tr></table></figure></p><p>但可以更改 ID 为 1 的记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update goods set num =1 where id=1;</span><br></pre></td></tr></table></figure></p><p>3.执行添加时因为不在 id 为 1~3 的范围内所以可以添加，但如果添加时指定 ID 为 2 将会阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into goods (name,num) values(&apos;西瓜&apos;,200);</span><br></pre></td></tr></table></figure></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>非观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。</p><p>下面演示商城下单情况，要用户购买商品后我们要减少库存，如果在高并发情况下多个用户同时修改库存表，会造成库存数据异常，使用悲观锁可以解决这个问题。<br>1.事务 A 执行悲观锁操作后，其他事务执行同一代码时将阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM goods WHERE id=1 FOR UPDATE;</span><br><span class="line">UPDATE goods SET num=num-2 WHERE id=1;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>2.事务 B 执行以下代码将不能查询库存，必须等事务 A 提交或回滚事务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">## B事务中查询中也要使用 FOR UPDATE 悲观锁</span><br><span class="line">SELECT * FROM goods WHERE id=1 FOR UPDATE;</span><br><span class="line">-- 阻塞中...</span><br></pre></td></tr></table></figure></p><p>3.事务 A 提交后，事务 B 会得到事务 A 操作后的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">COMMIT;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p><p>下面使用版本字段来实现乐观锁操作，并实现更改商品库存的案例。<br>1.事务 A 查询商品库存，获取了商品记录，记录中有 VERSION 字段用于记录版本号（目前为 0）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM goods WHERE id = 1;</span><br></pre></td></tr></table></figure></p><p>2.事务 B 同时查询，也获取了版本号为 0 的记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM goods WHERE id = 1;</span><br></pre></td></tr></table></figure></p><p>3.事务 A 更改库存，并增加版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;</span><br></pre></td></tr></table></figure></p><p>4.事务 B 更改数据，但使用的是事务 B 查询到的 0 号版本，因为事务 A 已经提交版本号为 1，造成事务 B 修改失败，保证了数据的完整性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;</span><br></pre></td></tr></table></figure></p><h3 id="表锁机制"><a href="#表锁机制" class="headerlink" title="表锁机制"></a>表锁机制</h3><p>针对一些不支持事务的处理引擎可以使用锁表的方式控制业务。</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><p>为表设置读锁后，当前会话和其他会话都不可以修改数据，但可以读取表数据。<br>1.会话 A 对表 goods 设置了读锁，将不能修改该表，也不能操作其他表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE goods READ;</span><br><span class="line">UPDATE goods SET num=300 WHERE id=1;</span><br><span class="line">SELECT * FROM stu;</span><br></pre></td></tr></table></figure></p><p>2.因为会话 A 对表goods设置了读锁，所以会话 B 也不能修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update goods set num=200 where id=1;</span><br><span class="line">-- 阻塞</span><br></pre></td></tr></table></figure></p><p>3.会话 A 解锁表后，其他会话又可以继续操作表了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。<br>1.会话 A 对表 goods 和 stu 设置写锁，本会话可以正常操作表， 并不能操作其他表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE goods WRITE，stu WRITE;</span><br><span class="line">INSERT INTO goods (name,num )VALUES(&apos;后盾人教程&apos;,300);</span><br></pre></td></tr></table></figure></p><p>2.会话 B 读取/写入表数据都将阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from goods</span><br></pre></td></tr></table></figure></p><p>3.会话 A 解锁表数据后，其他会话都可以正常操作了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-锁机制&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(八)</title>
    <link href="/2023/04/06/MYSQL-%E5%85%AB/"/>
    <id>/2023/04/06/MYSQL-八/</id>
    <published>2023-04-06T08:13:44.000Z</published>
    <updated>2023-04-14T06:11:46.598Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-事务处理<br><a id="more"></a></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>事务是保证多个 SQL 操作的一致性，如果一条失败全部 SQL 也将失效。</p><blockquote><p>学习事务时建议开启两个客户端（或 GUI 软件如 Dbeaver、SequelPro）来体验</p></blockquote><h3 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h3><ul><li>事务是保证多个 SQL 操作的一致性，如果一条失败全部 SQL 也将失效。</li><li>实际业务中大多数是对多个表操作，比如当发表文章时需要将文章的基本信息发到文章基础表和文章内容添加到文章内容表，这种情况不使用事务也没有关系，如果出现数据异常重新添加就可以了</li><li>但牵涉到货币的情况就必须使用事务了，必须保证货币处理是准确的</li><li>当然有些公司要求所有查询都使用事务，这就遵照公司要求完成就可以了</li></ul><h3 id="储存引擎"><a href="#储存引擎" class="headerlink" title="储存引擎"></a>储存引擎</h3><p>查看引擎<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure></p><p>最新版本的 Mysql 中已经不建议使用 MyISAM引擎了，所以我们也不用讨论它了。<br><strong>InnoDB</strong><br>支持事务的引擎建议使用 InnoDB。如果旧表是其他引擎，使用下面语句更改为InnoDB引擎。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></p><h3 id="提交模式"><a href="#提交模式" class="headerlink" title="提交模式"></a>提交模式</h3><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>Mysql 的提交默认是自动提交，即发送一条执行一条。<br>在 DBeaver 执行以下 SQL 后，在另一个 Sequel Pro 会立刻看到结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu (class_id,sname,sex)VALUES(2,&apos;张帝&apos;,&apos;女&apos;);</span><br></pre></td></tr></table></figure></p><p><img src="/2023/04/06/MYSQL-八/1.png" alt="img"><br>在 Sequel Pro 里即可看到结果，这为自动提交。<br><img src="/2023/04/06/MYSQL-八/2.png" alt="img"></p><h4 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h4><p><strong>事务单独开启</strong><br>执行 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句后，表示要开启一项事务处理。</p><ul><li>COMMIT 提交事务</li><li>ROLLBACK 回滚事务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO stu (class_id,sname,sex)VALUES(2,&apos;张帝&apos;,&apos;女&apos;);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p><strong>全局开启事务</strong><br>如果所有 SQL 都使用事务操作，我们可以通过 SET AUTOCOMMIT=0 关闭自动提交来开启事务机制，这样所有语句都是事务类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 关闭自动提交</span><br><span class="line">SET AUTOCOMMIT = 0;</span><br><span class="line"></span><br><span class="line">INSERT INTO stu (class_id,sname,sex)VALUES(2,&apos;李清&apos;,&apos;女&apos;);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 开启自动提交</span><br><span class="line">SET AUTOCOMMIT = 1;</span><br></pre></td></tr></table></figure></p><h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>当高并发访问会遇到多个事务的隔离问题，可能会出现以下：</p><ul><li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</li><li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li><li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ul><blockquote><p>不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p></blockquote><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>说明</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td><td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td><td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td><td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td><td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td></tr></tbody></table><h4 id="查询级别"><a href="#查询级别" class="headerlink" title="查询级别"></a>查询级别</h4><p>mysql8 版本查询隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global.transaction_isolation,@@transaction_isolation;</span><br></pre></td></tr></table></figure></p><p>mysql8 以下版本查询隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></p><h4 id="设置级别"><a href="#设置级别" class="headerlink" title="设置级别"></a>设置级别</h4><p>设置会话隔离级别，影响当前连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure></p><p>设置全局隔离级别，影响全局连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure></p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>为了演示效果将隔离级别设置为最低级 read uncommitted。脏读是一个事务没有提交时可被其他事务读取到。<br>1.事务 A 执行更新操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read UNCOMMITTED;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE stu SET sname = &apos;后盾人&apos; WHERE id=1;</span><br></pre></td></tr></table></figure></p><p>2.因为使用了最低级别<code>read uncommitted</code>，事务 B 在事务 A 没有提交时就可以看到更新的数据，如果事务 A 执行ROLLBACK 事务 B 的读到的数据就为脏数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `stu`;</span><br></pre></td></tr></table></figure></p><p>3.将隔离级别设置为除 <code>read uncommitted</code> 以外的，再重复上面的例子，都可以有效避免脏读的问题。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读指在事务中多次读取的数据出现不一致的情况，我们希望读取的数据在本事务中是一致的。</p><ul><li>事务 A 在执行过程中更新数据，事务 B 同时读取的数据没有脏数据。</li><li>但当事务 A 提交了事务后，事务 B 再读取时得到了最新的数据，这种情况为不可重复读。</li><li>所以要保证事务过程中的数据重复操作是一致的，不受其他事务影响，即避免不可重复读的产生。</li></ul><p>为了演示效果将隔离级别设置为低级别 <code>read committed</code>。<br>1.事务 A 执行以下代码，但没有提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level READ COMMITTED;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE stu SET sname = &apos;后盾人9&apos; WHERE id=1;</span><br></pre></td></tr></table></figure></p><p>2.因为使用了 read committed级别，所以事务 B 不会读到脏数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM stu;</span><br></pre></td></tr></table></figure></p><p>3.事务 A 提交事务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">commit</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>4.此时事务 B 可以读取到事务 A 提交的数据，这就是不能重复读取到同一个数据，即事务 B 读取结果受事务 A 影响。<br>5.将隔离机制设置为 <code>REPEATABLE READ</code> 就可以解决这类不可重复读的问题。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。<br>1.事务 A 执行查询，假如查询结果是 6 条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level REPEATABLE READ;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM stu;</span><br></pre></td></tr></table></figure></p><p>2.事务 B 执行添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level REPEATABLE READ;</span><br><span class="line">insert into stu (class_id,sname,sex) values(2,&apos;后盾人&apos;,1);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p><p>3.事务 A 执行更新，发现更新了 7 条（刚才查询时 6 条，但更新了七条，感觉像出现了幻觉）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">UPDATE stu SET balance = 200;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>4.切换隔离级别为 SERIALIZABLE 后，在事务 A 没有提交时，事务 B 是不能插入数据的（表现形式为等待）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level SERIALIZABLE;</span><br><span class="line"></span><br><span class="line">select @@global.transaction_isolation,@@transaction_isolation;</span><br></pre></td></tr></table></figure></p><h3 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h3><p>程序语言基本上都支持事务的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-type:text/html;charset=utf8&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    $config = [</span><br><span class="line">        &apos;host&apos; =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">        &apos;user&apos; =&gt; &apos;root&apos;,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;root&apos;,</span><br><span class="line">        &apos;database&apos; =&gt; &apos;test&apos;,</span><br><span class="line">        &apos;charset&apos; =&gt; &apos;utf8&apos;</span><br><span class="line">    ];</span><br><span class="line">    $dsn = sprintf(</span><br><span class="line">        &quot;mysql:host=%s;dbname=%s;charset=%s&quot;,</span><br><span class="line">        $config[&apos;host&apos;],</span><br><span class="line">        $config[&apos;database&apos;],</span><br><span class="line">        $config[&apos;charset&apos;]</span><br><span class="line">    );</span><br><span class="line">    $pdo = new PDO($dsn, $config[&apos;user&apos;], $config[&apos;password&apos;]);</span><br><span class="line">    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">&#125; catch (PDOException $e) &#123;</span><br><span class="line">    die($e-&gt;getMessage());</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">    # 开启事务</span><br><span class="line">    $pdo-&gt;beginTransaction();</span><br><span class="line">    $d = $pdo-&gt;exec(&quot;INSERT INTO stu (class_id,sname,sex)</span><br><span class="line">     VALUES(2,&apos;后盾人&apos;,&apos;男&apos;)&quot;);</span><br><span class="line"></span><br><span class="line">    $pdo-&gt;exec(&quot;UPDATE class SET</span><br><span class="line">     stu_count = (SELECT count(*) FROM stu WHERE class_id=2) WHERE id=2&quot;);</span><br><span class="line">    # 提交事务</span><br><span class="line">    $pdo-&gt;commit();</span><br><span class="line">&#125; catch (PDOException $e) &#123;</span><br><span class="line">    # 事务回滚</span><br><span class="line">    $pdo-&gt;rollBack();</span><br><span class="line">    die(&quot;Exception:&quot; . $e-&gt;getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-事务处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(七)</title>
    <link href="/2023/04/06/MYSQL-%E4%B8%83/"/>
    <id>/2023/04/06/MYSQL-七/</id>
    <published>2023-04-06T08:13:35.000Z</published>
    <updated>2023-04-14T03:05:43.236Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-多表攻略<br><a id="more"></a></p><h2 id="多表攻略"><a href="#多表攻略" class="headerlink" title="多表攻略"></a>多表攻略</h2><p>前面我们学习了 sql 语句的操作，但是我们大部分都是操作的单张表，大部分问题只有一张表是不能解决的。我们需要从多张表中获得数据，或者通过其他表的数据删除某个表的记录等操作，这个时候就需要多表操作。</p><h3 id="表关联"><a href="#表关联" class="headerlink" title="表关联"></a>表关联</h3><p><strong>一对一</strong><br>比如说会员表与个人资料（QQ，邮箱）表即为一对一关系。<br><strong>一对多</strong><br>比如学生与班级表间即为一对多关系，一个班级有多个学生，一个学生属于一个班级。<br><strong>多对多</strong><br>粉丝表与用户表关系，一个粉丝可以关注多个用户，一个用户也可以有多个粉丝，像这种关系我们会使用一张中间表来记录关系。</p><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>多个表的连接将会得到所有可能出现的行，即没有明确这两个表间的关联条件时，所有记录都将符合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ,class;</span><br></pre></td></tr></table></figure></p><p>下面是添加条件后的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ,class WHERE stu.class_id = class.id;</span><br></pre></td></tr></table></figure></p><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><p>所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。</p><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>获取用户的资料信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu AS s INNER JOIN user_info as i</span><br><span class="line">ON s.id = i.stu_id;</span><br></pre></td></tr></table></figure></p><p>使用INNER JOIN 使用多表关联的语义更清晰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu INNER JOIN class</span><br><span class="line">ON stu.class_id = class.id;</span><br></pre></td></tr></table></figure></p><p>查询一班的所有同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu INNER JOIN class</span><br><span class="line">ON stu.class_id = class.id</span><br><span class="line">WHERE class.id = 1;</span><br></pre></td></tr></table></figure></p><p>为了性能和多表字段重名覆盖的问题，有必要在查询时明确获取的列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname,class_id,stu.id as stu_id,sex,cname FROM stu INNER JOIN class</span><br><span class="line">ON stu.class_id = class.id</span><br><span class="line">WHERE class.id = 1;</span><br></pre></td></tr></table></figure></p><p>每个班级发表的文章数量，来操作多张表的关联操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.id ,count(*) FROM stu as s</span><br><span class="line">INNER JOIN class as c</span><br><span class="line">INNER JOIN article as a</span><br><span class="line">ON s.class_id = c.id AND s.id = a.stu_id</span><br><span class="line">GROUP BY c.id;</span><br></pre></td></tr></table></figure></p><p>一班的所有女生发表的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.id,a.title FROM stu as s</span><br><span class="line">INNER JOIN class as c</span><br><span class="line">INNER JOIN article as a</span><br><span class="line">ON s.class_id = c.id AND s.id = a.stu_id</span><br><span class="line">WHERE c.id=1 AND s.sex = &apos;女&apos;;</span><br></pre></td></tr></table></figure></p><p>每个班级发表的文章总数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(a.id) as article_sum,c.id FROM stu as s</span><br><span class="line">INNER JOIN class as c</span><br><span class="line">INNER JOIN article as a</span><br><span class="line">ON s.class_id = c.id AND s.id = a.stu_id</span><br><span class="line">GROUP BY c.id;</span><br></pre></td></tr></table></figure></p><p>哪个班级发表的文章超过两篇<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.id,count(*) as total FROM stu as s</span><br><span class="line">INNER JOIN class as c</span><br><span class="line">INNER join article as a</span><br><span class="line">ON s.class_id = c.id AND s.id = a.stu_id</span><br><span class="line">GROUP BY c.id</span><br><span class="line">HAVING total &gt;=2;</span><br></pre></td></tr></table></figure></p><p>每个班级文章的总点击数与平均点击数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT sum(a.click) as class_sum,avg(a.click),c.id FROM stu as s</span><br><span class="line">INNER JOIN class as c</span><br><span class="line">INNER JOIN article as a</span><br><span class="line">ON s.class_id = c.id AND s.id = a.stu_id</span><br><span class="line">GROUP BY c.id</span><br><span class="line">ORDER BY class_sum DESC;</span><br></pre></td></tr></table></figure></p><p>每个班级有多少同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(*),c.cname FROM stu as s INNER JOIN class as c</span><br><span class="line">ON s.class_id = c.id</span><br><span class="line">GROUP BY c.id;</span><br></pre></td></tr></table></figure></p><p>学生人数大于两个的班级名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(*) as total,c.cname FROM stu as s INNER JOIN class as c</span><br><span class="line">ON s.class_id = c.id</span><br><span class="line">GROUP BY c.cname</span><br><span class="line">HAVING total&gt;=2;</span><br></pre></td></tr></table></figure></p><h4 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h4><p>外链接包括<code>LEFT JOIN</code> 与 <code>RIGHT JOIN</code> ，可以简单理解为 <code>LEFT JOIN</code>会包含左侧所有表记录，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p><p>获取没有设置 QQ 的用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sname FROM stu AS s LEFT JOIN user_info as i</span><br><span class="line">ON s.id = i.stu_id</span><br><span class="line">WHERE i.qq is null;</span><br></pre></td></tr></table></figure></p><p>查找所有没有发表文章的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id,s.sname FROM stu as s LEFT JOIN article as a</span><br><span class="line">ON s.id = a.stu_id</span><br><span class="line">WHERE a.id IS NULL;</span><br></pre></td></tr></table></figure></p><p>哪个班级没有学生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c</span><br><span class="line">ON s.class_id = c.id</span><br><span class="line">WHERE s.id IS NULL;</span><br></pre></td></tr></table></figure></p><p>每个班级的平均年龄<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.cname,avg(timestampdiff(year,s.birthday,now())) as t</span><br><span class="line">FROM stu as s INNER JOIN class as c</span><br><span class="line">ON s.class_id = c.id</span><br><span class="line">GROUP BY c.cname;</span><br></pre></td></tr></table></figure></p><p>查找学生所在班级，没有班级的学生显示无<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname,ifnull(s.class_id,&apos;无&apos;) FROM stu AS s LEFT JOIN class AS c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure></p><h4 id="SELF-JOIN"><a href="#SELF-JOIN" class="headerlink" title="SELF JOIN"></a>SELF JOIN</h4><p><code>SELF JOIN</code>为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。<br>查找后盾人的同班同学<br>使用子查询操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu WHERE class_id =</span><br><span class="line">(SELECT class_id FROM stu WHERE sname = &apos;后盾人&apos;)</span><br><span class="line">AND stu.sname !=&apos;后盾人&apos;;</span><br></pre></td></tr></table></figure></p><p>使用自连接查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.sname,s2.sname FROM stu as s1</span><br><span class="line">INNER JOIN stu as s2</span><br><span class="line">ON s1.class_id = s2.class_id</span><br><span class="line">WHERE s1.sname = &apos;后盾人&apos; AND s2.sname !=&apos;后盾人&apos;;</span><br></pre></td></tr></table></figure></p><p>查找与后盾人同年出生的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s2.* FROM stu as s1 INNER JOIN stu AS s2</span><br><span class="line">ON year(s1.birthday) = year(s2.birthday)</span><br><span class="line">WHERE s1.sname =&apos;后盾人&apos; AND s2.sname !=&apos;后盾人&apos;;</span><br></pre></td></tr></table></figure></p><p>查找比后盾人大的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s2.sname,s2.birthday FROM stu AS s1</span><br><span class="line">INNER JOIN stu AS s2</span><br><span class="line">ON year(s1.birthday)&gt;year(s2.birthday)</span><br><span class="line">WHERE s1.sname = &apos;后盾人&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>比如学生可以学习多个课程，一个课程也可以被多个学生学习，这种情况就是多对多的关系。需要创建一张中间表来把这种关系联系起来。<br>查找后盾人学习的课程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname,l.name FROM stu AS s</span><br><span class="line">INNER JOIN user_lesson AS ul</span><br><span class="line">ON s.id = ul.stu_id</span><br><span class="line">INNER JOIN lesson AS l</span><br><span class="line">ON ul.lesson_id = l.id</span><br><span class="line">WHERE s.sname = &apos;后盾人&apos;;</span><br></pre></td></tr></table></figure></p><p>哪个班级的同学最爱学习 PHP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.cname,count(*) AS total FROM stu AS s</span><br><span class="line">INNER JOIN user_lesson AS ul</span><br><span class="line">INNER JOIN lesson AS l</span><br><span class="line">ON s.id = ul.stu_id AND ul.lesson_id = l.id</span><br><span class="line">INNER JOIN class AS c</span><br><span class="line">ON c.id = s.class_id</span><br><span class="line">WHERE l.name=&apos;php&apos;</span><br><span class="line">GROUP BY c.cname</span><br><span class="line">ORDER by total</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p><code>UNION</code> 用于连接多个查询结果，要保证每个查询返回的列的数量与顺序要一样。</p><ul><li>UNION 会过滤重复的结果</li><li>UNION ALL 不过滤重复结果</li><li>列表字段由是第一个查询的字段</li></ul><p>查询年龄最大与最小的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)</span><br><span class="line">UNION</span><br><span class="line">(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)</span><br><span class="line">ORDER BY birthday DESC;</span><br></pre></td></tr></table></figure></p><p>最新发表的文章和学习的课程组成动态数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(SELECT CONCAT(s.sname,&apos;发表了文章：&apos;,a.title) from article as a</span><br><span class="line">INNER JOIN stu as s</span><br><span class="line">ON s.id = a.stu_id</span><br><span class="line">LIMIT 2)</span><br><span class="line">UNION</span><br><span class="line">(SELECT CONCAT(s.sname,&apos;正在学习：&apos;,l.name) FROM stu AS s</span><br><span class="line">INNER JOIN user_lesson as ul</span><br><span class="line">INNER JOIN lesson as l</span><br><span class="line">ON s.id = ul.stu_id AND ul.lesson_id = l.id</span><br><span class="line">LIMIT 2);</span><br></pre></td></tr></table></figure></p><h3 id="多表删除"><a href="#多表删除" class="headerlink" title="多表删除"></a>多表删除</h3><p>删除所有没有学习任何课程的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELETE s FROM stu as s</span><br><span class="line">LEFT JOIN user_lesson as ul</span><br><span class="line">ON s.id = ul.stu_id</span><br><span class="line">WHERE ul.lesson_id IS NULL;</span><br></pre></td></tr></table></figure></p><p>使用子查询操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM stu WHERE id IN(</span><br><span class="line">  SELECT id FROM</span><br><span class="line">    (SELECT s.id FROM stu as s</span><br><span class="line">    LEFT JOIN user_lesson as ul</span><br><span class="line">    ON s.id = ul.stu_id</span><br><span class="line">    WHERE ul.lesson_id IS NULL)</span><br><span class="line">  AS s</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="Exists"><a href="#Exists" class="headerlink" title="Exists"></a>Exists</h3><p><code>Exists</code>与<code>NOT EXISTS</code>都是通过子查询来决定是否返回结果，下面是是语法介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM h1 WHERE [conditions] AND EXISTS(SELECT * FROM h2)</span><br></pre></td></tr></table></figure></p><p>说明如下：</p><ul><li>EXISTS最终返回 true或false</li><li>外层查询会将每条结果传递给子查询，用于进行exists判断</li><li>如果子查询有结果，则外层查询的这条记录返回</li><li>NOT EXISTS是EXISTS的反函数</li></ul><p>哪些学习已经在学习课程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu s where exists(select * from stu_lesson sl where s.id=sl.stu_id);</span><br></pre></td></tr></table></figure></p><p>哪些学生没有课程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu s where not exists(select * from stu_lesson sl where s.id=sl.stu_id);</span><br></pre></td></tr></table></figure></p><p>学习的课程数量&gt;=2个的学生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu s where exists(select id from stu_lesson sl where s.id=sl.stu_id group by id HAVING count(*)&gt;=2);</span><br></pre></td></tr></table></figure></p><p>性别是男生并且设置了QQ号的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from stu s where s.sex=&apos;男&apos; and </span><br><span class="line">exists(select * from stu_info si where s.id=si.stu_id and si.qq is not null );</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-多表攻略&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(六)</title>
    <link href="/2023/04/06/MYSQL-%E5%85%AD/"/>
    <id>/2023/04/06/MYSQL-六/</id>
    <published>2023-04-06T08:13:23.000Z</published>
    <updated>2023-04-12T08:38:36.471Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-排序聚合分组<br><a id="more"></a></p><h2 id="排序聚合分组"><a href="#排序聚合分组" class="headerlink" title="排序聚合分组"></a>排序聚合分组</h2><h3 id="ORDER"><a href="#ORDER" class="headerlink" title="ORDER"></a>ORDER</h3><h4 id="排序介绍"><a href="#排序介绍" class="headerlink" title="排序介绍"></a>排序介绍</h4><p>mysql 对查询结果使用order by 进行排序</p><ul><li>对任何字段进行排序</li><li>desc 降序 asc 升序</li><li>对别名字段可排序</li><li>对函数结果可排序</li><li>支持多列表排序</li><li>排序受校对规则影响（请查看其他章节课程了解校对规则）</li></ul><h4 id="排序实例"><a href="#排序实例" class="headerlink" title="排序实例"></a>排序实例</h4><p>从男到女排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ORDER BY sex ASC;</span><br></pre></td></tr></table></figure></p><p>从男到女排序年龄从小到大排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ORDER BY sex ASC,birthday DESC;</span><br></pre></td></tr></table></figure></p><p>随机获取学生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ORDER BY RAND() LIMIT 1;</span><br></pre></td></tr></table></figure></p><p>按出生月份从小到大排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT birthday,MONTH(birthday) as m FROM stu ORDER BY m ASC;</span><br><span class="line"></span><br><span class="line"># 或使用字符串函数操作</span><br><span class="line">SELECT birthday,mid(birthday,6,2) as m FROM stu ORDER BY m ASC;</span><br></pre></td></tr></table></figure></p><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><p>field 函数用于比较值在集合中的索引，利用这一特性可以自定义排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT FIELD(&apos;a&apos;,&apos;c&apos;,&apos;a&apos;,&apos;b&apos;);</span><br><span class="line"># 第一个a 为比较字符，后面的 c/a/b为集合，所以结果为2，如果在集合中不存在为0</span><br></pre></td></tr></table></figure></p><p>使用 field 进行自定义排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ORDER BY FIELD(left(sname,1),&apos;何&apos;,&apos;赵&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p>统计所有学生人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM stu;</span><br></pre></td></tr></table></figure></p><p>所有女生人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM stu WHERE sex=2;</span><br></pre></td></tr></table></figure></p><p>统计所有分配班级的学生（count(字段)不会统计 null 值，使用 count(*)时会计算 null），所以下面使用具体的字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(class_id) FROM stu;</span><br></pre></td></tr></table></figure></p><h3 id="MIN-MAX"><a href="#MIN-MAX" class="headerlink" title="MIN/MAX"></a>MIN/MAX</h3><p>获取最小的学生出生年份<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT year(max(birthday)) from stu;</span><br></pre></td></tr></table></figure></p><p>最大的班级编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT max(class_id) FROM stu;</span><br></pre></td></tr></table></figure></p><p>获取点击数最少的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE click = (SELECT MIN(click) FROM article);</span><br></pre></td></tr></table></figure></p><h3 id="SUM-AVG"><a href="#SUM-AVG" class="headerlink" title="SUM/AVG"></a>SUM/AVG</h3><p>获取所有文章总点击数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(click) FROM article;</span><br></pre></td></tr></table></figure></p><p>获取平均点击数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(click) FROM article;</span><br></pre></td></tr></table></figure></p><p>获取低于平均点击数据的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE click &lt; (SELECT AVG(click) FROM article);</span><br></pre></td></tr></table></figure></p><p>获取学生的平均年龄<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;</span><br></pre></td></tr></table></figure></p><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>distinct 用于去除结果集中的重复记录</p><p>获取所有班级编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;</span><br></pre></td></tr></table></figure></p><p>获取学生数，同班同名的算一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT class_id,sname) FROM stu WHERE class_id IS NOT NULL;</span><br></pre></td></tr></table></figure></p><p>获取班级平均人数，去掉重复的数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT (count(id)) AS c FROM users GROUP BY class_id</span><br></pre></td></tr></table></figure></p><h3 id="GROUP"><a href="#GROUP" class="headerlink" title="GROUP"></a>GROUP</h3><p>统计受 ONLY_FULL_GROUP_BY 模式影响，有关 ONLY_FULL_GROUP_BY 的详细讨论请查看 「运行模式」章节。</p><p>统计每个班级的人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*),class_id FROM stu WHERE class_id IS NOT NULL GROUP BY class_id ;</span><br></pre></td></tr></table></figure></p><p>每个班年龄最大的同学</p><p>结果中要求出现班级编号和学生姓名，如果 GROUP BY 中只有班级编号字段，默认运行模式下 SELECT 中不能出现学生姓名。</p><p>MYSQL 默认使用 ONLY_FULL_GROUP_BY 模式要求 select 中的列要在 group 中使用。有多种方式可以处理这个问题</p><ul><li>可以通过更改查询模式，允许 select 的列不在 group 中出现</li><li>使用聚合函数</li><li>使用 any_value 函数处理</li><li>GROUP BY 中使用 PRIMAY KEY 或 UNIQUE NOT NULL 字段</li><li>有关 ONLY_FULL_GROUP_BY 模式已经在「运行模式」章节讨论过</li></ul><p>直接查询将产生错误，因为 sname 不是 GROUP BY 使用的字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT min(birthday),sname FROM stu GROUP BY class_id;</span><br></pre></td></tr></table></figure></p><p>使用聚合函数解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT min(birthday),min(sname) FROM stu GROUP BY class_id;</span><br></pre></td></tr></table></figure></p><p>使用 any_value 函数解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT min(birthday),any_value(sname) FROM stu GROUP BY class_id;</span><br></pre></td></tr></table></figure></p><p>也可以使用子查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu where birthday IN(</span><br><span class="line">SELECT min(birthday) FROM stu GROUP BY class_id);</span><br></pre></td></tr></table></figure></p><p>或使用聚合函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT min(birthday),min(sname) FROM stu GROUP BY class_id;</span><br></pre></td></tr></table></figure></p><p>也可以更改查询模式，去掉 ONLY_FULL_GROUP_BY 模式的方式解决。</p><blockquote><p>很多后台程序框架提供配置项用于禁止 ONLY_FULL_GROUP_BY 模式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET sql_mode=&apos;&apos;</span><br><span class="line"></span><br><span class="line">SELECT min(birthday),sname FROM stu GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>统计每班的男、女人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(class_id,&apos;班&apos;),if(sex=1,&apos;男&apos;,&apos;女&apos;) as sex,</span><br><span class="line">count(*) FROM stu</span><br><span class="line">WHERE class_id IS NOT NULL</span><br><span class="line">GROUP BY class_id,sex ORDER BY class_id;</span><br></pre></td></tr></table></figure></p><p>查找超过两个同学的班级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2;</span><br></pre></td></tr></table></figure></p><p>查找本周迟到超过两次的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT stu_id FROM attendance</span><br><span class="line">WHERE date(created_at)&gt;date(DATE_ADD(NOW(),INTERVAL 0-WEEKDAY(NOW()) day))</span><br><span class="line">AND time(created_at)&gt;&apos;08:30:00&apos;</span><br><span class="line">GROUP BY stu_id</span><br><span class="line">HAVING COUNT(*)&gt;2;</span><br></pre></td></tr></table></figure></p><p>本周哪个同学准时到校次数最多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(*) as c,stu_id FROM attendance</span><br><span class="line">WHERE date(created_at)&gt;=date(date_add(now(),interval 0-WEEKDAY(now()) day))</span><br><span class="line">AND time(created_at)&lt;=&apos;08:30:00&apos;</span><br><span class="line">GROUP BY stu_id</span><br><span class="line">ORDER by c desc</span><br><span class="line">limit 1;</span><br></pre></td></tr></table></figure></p><p>本周哪一天迟到的人数最少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT date(created_at) FROM attendance</span><br><span class="line">WHERE date(created_at)&gt;date(DATE_ADD(NOW(),INTERVAL 0-WEEKDAY(NOW()) day))</span><br><span class="line">AND time(created_at)&lt;=&apos;08:30:00&apos;</span><br><span class="line">GROUP BY created_at</span><br><span class="line">ORDER BY COUNT(*) DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></p><p>查找哪个姓的同学最多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT left(sname,1) as s,count(*) AS c FROM stu</span><br><span class="line">GROUP BY s</span><br><span class="line">ORDER BY c DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></p><p>查找超过两个同学的姓氏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT left(sname,1) as s,count(*) AS c FROM stu</span><br><span class="line">GROUP BY s</span><br><span class="line">HAVING c&gt;=2;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-排序聚合分组&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(五)</title>
    <link href="/2023/04/06/MYSQL-%E4%BA%94/"/>
    <id>/2023/04/06/MYSQL-五/</id>
    <published>2023-04-06T08:13:06.000Z</published>
    <updated>2023-04-12T06:24:31.081Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-运行模式<br><a id="more"></a></p><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><blockquote><p>MYSQL 运行时可以使用不同的模式，这是很多语言中都有的特性比如 JS/PHP 等。在 MYSQL5.7 前 SQL 运行在宽松模式，会以开放不严谨的方式运行。<br>在 5.7 后默认运行模式较为严格，这会造成在升级数据库时，数据库的操作出现问题。所以有必要理解 MYSQL 的运行模式机制。</p></blockquote><h3 id="模式说明"><a href="#模式说明" class="headerlink" title="模式说明"></a>模式说明</h3><p>查看当前运行模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@sql_mode</span><br></pre></td></tr></table></figure></p><h4 id="模式选项"><a href="#模式选项" class="headerlink" title="模式选项"></a>模式选项</h4><p>不同运行模式即对不同模式选项的配置，下面是常用的模式选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>ONLY_FULL_GROUP_BY</td><td>结果中的字段需要在 GROUP BY 中出现</td></tr><tr><td>STRICT_TRANS_TABLES</td><td>如果一个值不能插入到一个事务表中，则中断当前的操作</td></tr><tr><td>NO_ZERO_IN_DATE</td><td>不能插入为 0 的日期和月份</td></tr><tr><td>NO_ZERO_DATE</td><td>不能添加 0000-00-00 格式的日期</td></tr><tr><td>ERROR_FOR_DIVISION_BY_ZERO</td><td>除数不能为零，禁止该模式后插入的结果为 NULL</td></tr></tbody></table><h4 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h4><p>常用模式是系统将不同的模式选项过行的组合</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>ANSI</td><td>宽松模式：对长度超过字段定义等错误进行截取等操作。报 WARNING 警告错误</td></tr><tr><td>TRADITIONAL</td><td>严格模式：对数据进行严格校验。事务处理中会进行事务回滚操作。非事务时，发生错误时就立即报错终止，会造成有部分数据插入。</td></tr></tbody></table><p>设置当前会话为宽松模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session sql_mode=ANSI;</span><br><span class="line"># 或</span><br><span class="line">SET sql_mode = ANSI</span><br></pre></td></tr></table></figure></p><p>设置全局模式限制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL sql_mode=&apos;&apos;;</span><br></pre></td></tr></table></figure></p><p>设置为严格模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session sql_mode=TRADITIONAL;</span><br></pre></td></tr></table></figure></p><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><p>我们来看下在不同模式下的表现，首先宽松模式可以插入’0000-00-00’的日期格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET sql_mode = ANSI</span><br><span class="line"></span><br><span class="line">INSERT INTO stu SET birthday  = &apos;0000-00-00&apos;</span><br></pre></td></tr></table></figure></p><p>当使用严格模式时将不可以插入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set sql_mode=TRADITIONAL;</span><br><span class="line"></span><br><span class="line">INSERT INTO stu SET birthday  = &apos;0000-00-00&apos;</span><br></pre></td></tr></table></figure></p><p>内容超过字段长度时宽松模式会过行截断并可以正常插入，下面的字段 rank 使用的是 smallint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET sql_mode = ANSI</span><br><span class="line"></span><br><span class="line">INSERT INTO article SET rank =1000000;</span><br></pre></td></tr></table></figure></p><p>当改为严格模式时不能插入数据会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set sql_mode=TRADITIONAL;</span><br><span class="line"></span><br><span class="line">INSERT INTO article SET rank =1000000;</span><br></pre></td></tr></table></figure></p><h3 id="ONLY-FULL-GROUP-BY"><a href="#ONLY-FULL-GROUP-BY" class="headerlink" title="ONLY_FULL_GROUP_BY"></a>ONLY_FULL_GROUP_BY</h3><p>ONLY_FULL_GROUP_BY 要求 SELECT 中的字段是在与 GROUP BY 中使用的字段</p><ul><li>如果 GROUP BY 是主键或 UNIQUE NOT NULL 时可以在 SELECT 中列出其他字段</li><li>使用 max/min/avg/count 等聚合函数时不受 ONLY_FULL_GROUP_BY 模式影响</li></ul><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>下面获取男生和女生的人</p><ul><li>下面的班级编号 class_id 是男/女两个组中的，这个值是不确定的也是无意义的</li><li>使用 ONLY_FULL_GROUP_BY 模式后将报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id,count(*) AS c FROM stu u GROUP BY sex</span><br></pre></td></tr></table></figure><p>去除 ONLY_FULL_GROUP_BY 模式后可以读到 class_id ，但针对这个 SQL 来讲 class_id 结果是不确定的也是无意义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@sql_mode</span><br><span class="line"></span><br><span class="line">SELECT class_id,count(*) AS c FROM stu u GROUP BY sex</span><br></pre></td></tr></table></figure></p><h4 id="any-value"><a href="#any-value" class="headerlink" title="any_value"></a>any_value</h4><p>有些情况下确实要取到非 GROUP BY 中的字段，使用 any_value 函数可以从组中读取第一个值，解决使用 ONLY_FULL_GROUP_BY 报错的问题<br>any_value 会读取使用 group by 分组后的每组中第一个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET sql_mode = &apos;ONLY_FULL_GROUP_BY,TRADITIONAL&apos;</span><br><span class="line"></span><br><span class="line">SELECT any_value(class_id),count(*) AS c FROM stu u GROUP BY sex;</span><br></pre></td></tr></table></figure></p><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>在 SELECT 中使用 max/min/avg/count 等聚合函数时不受 ONLY_FULL_GROUP_BY 模式影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET sql_mode = &apos;ONLY_FULL_GROUP_BY,TRADITIONAL&apos;</span><br><span class="line"></span><br><span class="line">SELECT max(class_id),count(*) AS c FROM stu u GROUP BY sex</span><br></pre></td></tr></table></figure></p><h4 id="primary-unique"><a href="#primary-unique" class="headerlink" title="primary/unique"></a>primary/unique</h4><p>GROUP BY 使用主键或 unique not null 字段时，不受 ONLY_FULL_GROUP_BY 的约束。下面是获取每班的人数的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.id,c.cname,count(*) FROM stu u</span><br><span class="line">INNER JOIN class c</span><br><span class="line">ON c.id = u.class_id</span><br><span class="line">GROUP BY c.id;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-运行模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(四)</title>
    <link href="/2023/04/06/MYSQL-%E5%9B%9B/"/>
    <id>/2023/04/06/MYSQL-四/</id>
    <published>2023-04-06T08:12:59.000Z</published>
    <updated>2023-04-07T08:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-日期时间<br><a id="more"></a></p><h2 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h2><h3 id="DBeaver"><a href="#DBeaver" class="headerlink" title="DBeaver"></a>DBeaver</h3><p>如果使用 DBeaver 软件学习，需要在编辑连接设置正确时区。<br><img src="/2023/04/06/MYSQL-四/1.png" alt="img"><br>使用命令设置时区<br>设置会话时区，每次连接会话需要重新设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set time_zone = &apos;+8:00&apos;</span><br></pre></td></tr></table></figure></p><p>全局时区设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global time_zone = &apos;+8:00&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th>日期时间类型</th><th>占用空间</th><th>日期格式</th><th>最小值</th><th>最大值</th><th>零值表示</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td><td>0000-00-00 00:00:00</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 08:00:01</td><td>2038-01-19 03:14:07</td><td>00000000000000</td></tr><tr><td>DATE</td><td>4 bytes</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-31</td><td>0000-00-00</td></tr><tr><td>TIME</td><td>3 bytes</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td><td>00:00:00</td></tr><tr><td>YEAR</td><td>1 bytes</td><td>YYYY</td><td>1901</td><td>2155</td><td>0000</td></tr></tbody></table><ul><li>Mysql 保存日期格式使用 YYYY-MM-DD HH:MM:SS 的 ISO 8601 标准</li><li>向数据表储存日期与时间必须使用 ISO 格式</li></ul><h3 id="创建字段"><a href="#创建字段" class="headerlink" title="创建字段"></a>创建字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD birthday datetime default null;</span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>缩写星期名</td></tr><tr><td>%b</td><td>缩写月名</td></tr><tr><td>%c</td><td>月，数值</td></tr><tr><td>%D</td><td>带有英文前缀的月中的天</td></tr><tr><td>%d</td><td>月的天，数值(00-31)</td></tr><tr><td>%e</td><td>月的天，数值(0-31)</td></tr><tr><td>%f</td><td>微秒</td></tr><tr><td>%H</td><td>小时 (00-23)</td></tr><tr><td>%h</td><td>小时 (01-12)</td></tr><tr><td>%I</td><td>小时 (01-12)</td></tr><tr><td>%i</td><td>分钟，数值(00-59)</td></tr><tr><td>%j</td><td>年的天 (001-366)</td></tr><tr><td>%k</td><td>小时 (0-23)</td></tr><tr><td>%l</td><td>小时 (1-12)</td></tr><tr><td>%M</td><td>月名</td></tr><tr><td>%m</td><td>月，数值(00-12)</td></tr><tr><td>%p</td><td>AM 或 PM</td></tr><tr><td>%r</td><td>时间，12-小时（hh:mm:ss AM 或 PM）</td></tr><tr><td>%S</td><td>秒(00-59)</td></tr><tr><td>%s</td><td>秒(00-59)</td></tr><tr><td>%T</td><td>时间, 24-小时 (hh:mm:ss)</td></tr><tr><td>%U</td><td>周 (00-53) 星期日是一周的第一天</td></tr><tr><td>%u</td><td>周 (00-53) 星期一是一周的第一天</td></tr><tr><td>%V</td><td>周 (01-53) 星期日是一周的第一天，与 %X 使用</td></tr><tr><td>%v</td><td>周 (01-53) 星期一是一周的第一天，与 %x 使用</td></tr><tr><td>%W</td><td>星期名</td></tr><tr><td>%w</td><td>周的天 （0=星期日, 6=星期六）</td></tr><tr><td>%X</td><td>年，其中的星期日是周的第一天，4 位，与 %V 使用</td></tr><tr><td>%x</td><td>年，其中的星期一是周的第一天，4 位，与 %v 使用</td></tr><tr><td>%Y</td><td>年，4 位</td></tr><tr><td>%y</td><td>年，2 位</td></tr></tbody></table><h4 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h4><p>使用Date_format格式化日期与时间显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,DATE_FORMAT(birthday,&apos;%Y年%m月%d %H时%i分%s秒&apos;) as birthday from stu;</span><br></pre></td></tr></table></figure></p><p>使用time_format格式化输出时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,TIME_FORMAT(birthday,&apos;%r&apos;) as birthday from stu;</span><br></pre></td></tr></table></figure></p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>以时间戳格式来记录日期与时间。<br>设置 TIMESTAMP 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD updated_at</span><br><span class="line">TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">INSERT INTO stu SET sname = &apos;后盾人&apos;,updated_at = &apos;2020-2-12 10:33:12&apos;;</span><br></pre></td></tr></table></figure></p><p>添加数据时自动更新时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD updated_at</span><br><span class="line">TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">ON UPDATE CURRENT_TIMESTAMP;</span><br></pre></td></tr></table></figure></p><p>当执行添加与更新时字段将自动为当前时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into stu set sname = &apos;小张&apos;;</span><br><span class="line">update stu set sname = &apos;ih&apos; where id= 7;</span><br></pre></td></tr></table></figure></p><ul><li>执行更新或添加都会改变 timestamp 字段</li></ul><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>下面是获取当前日期、时间的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select CURRENT_DATE,CURRENT_TIME,NOW();</span><br></pre></td></tr></table></figure></p><p>获取时间部分值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select YEAR(updated_at),MONTH(updated_at),DAY(updated_at) from stu;</span><br></pre></td></tr></table></figure></p><p>其他可以使用的函数如下</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>HOUR</td><td>时（范围从 0 到 23）</td></tr><tr><td>MINUTE</td><td>分（范围从 0 到 59）</td></tr><tr><td>SECOND</td><td>秒（范围从 0 到 59）</td></tr><tr><td>YEAR</td><td>年（范围从 1000 到 9999）</td></tr><tr><td>MONTH</td><td>月（范围从 1 到 12）</td></tr><tr><td>DAY</td><td>日（范围从 1 开始）</td></tr><tr><td>TIME</td><td>获取时间</td></tr><tr><td>WEEK</td><td>一年中的第几周，从 1 开始计数</td></tr><tr><td>QUARTER</td><td>一年中的季度，从 1 开始计数</td></tr><tr><td>CURRENT_DATE</td><td>当前日期</td></tr><tr><td>CURRENT_TIME</td><td>当前时间</td></tr><tr><td>NOW</td><td>当前时间</td></tr><tr><td>DAYOFYEAR</td><td>一年中的第几天（从 1 开始）</td></tr><tr><td>DAYOFMONTH</td><td>月份中天数（从 1 开始）</td></tr><tr><td>DAYOFWEEK</td><td>星期天（1）到星期六（7）</td></tr><tr><td>WEEKDAY</td><td>星期一（0）到星期天（6）</td></tr><tr><td>TO_DAYS</td><td>从元年到现在的天数（忽略时间部分）</td></tr><tr><td>FROM_DAYS</td><td>根据天数得到日期（忽略时间部分）</td></tr><tr><td>TIME_TO_SEC</td><td>时间转为秒数（忽略日期部分）</td></tr><tr><td>SEC_TO_TIME</td><td>根据秒数转为时间（忽略日期部分）</td></tr><tr><td>UNIX_TIMESTAMP</td><td>根据日期返回秒数（包括日期与时间）</td></tr><tr><td>FROM_UNIXTIME</td><td>根据秒数返回日期与时间（包括日期与时间）</td></tr><tr><td>DATEDIFF</td><td>两个日期相差的天数（忽略时间部分，前面日期减后面日期）</td></tr><tr><td>TIMEDIFF</td><td>计算两个时间的间隔（忽略日期部分）</td></tr><tr><td>TIMESTAMPDIFF</td><td>根据指定单位计算两个日期时间的间隔（包括日期与时间）</td></tr><tr><td>LAST_DAY</td><td>该月的最后一天</td></tr></tbody></table><h4 id="拆分日期时间"><a href="#拆分日期时间" class="headerlink" title="拆分日期时间"></a>拆分日期时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sname,</span><br><span class="line">YEAR(birthday),MONTH(birthday),DAY(birthday),HOUR(birthday),</span><br><span class="line">MINUTE(birthday),SECOND(birthday) from stu;</span><br></pre></td></tr></table></figure><h4 id="当前日期时间"><a href="#当前日期时间" class="headerlink" title="当前日期时间"></a>当前日期时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();</span><br></pre></td></tr></table></figure><h4 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());</span><br></pre></td></tr></table></figure><h4 id="秒转换"><a href="#秒转换" class="headerlink" title="秒转换"></a>秒转换</h4><p>不包含日期的秒转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @time = time(now());</span><br><span class="line">SELECT now(),TIME_TO_SEC(@time),SEC_TO_TIME(TIME_TO_SEC(@time));</span><br></pre></td></tr></table></figure></p><p>日期时间与秒转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),UNIX_TIMESTAMP(birthday),FROM_UNIXTIME(UNIX_TIMESTAMP(birthday)) FROM stu;</span><br></pre></td></tr></table></figure></p><h4 id="天转换"><a href="#天转换" class="headerlink" title="天转换"></a>天转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),TO_DAYS(birthday),FROM_DAYS(TO_DAYS(birthday)) FROM stu;</span><br></pre></td></tr></table></figure><h4 id="差值计算"><a href="#差值计算" class="headerlink" title="差值计算"></a>差值计算</h4><p>计算天数差值，忽略时间部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),DATEDIFF(now(),birthday) from stu;</span><br></pre></td></tr></table></figure></p><p>计算时间差值，忽略天数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),TIMEDIFF(time(birthday),time(now())) from stu;</span><br></pre></td></tr></table></figure></p><h4 id="指定单位差值"><a href="#指定单位差值" class="headerlink" title="指定单位差值"></a>指定单位差值</h4><p>支持的单位有 YEAR/MONTH/WEEK/DAY/HOUR/MINUTE/SECOND 等。下面是获取学生来到人生经历的天数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,TIMESTAMPDIFF(day,birthday,NOW()) from stu;</span><br></pre></td></tr></table></figure></p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>MYSQL 内部将日期按数值进行处理，下面是查找’1990-02-22 09:00:00’ 日期可以写成数值形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE birthday  = 19900222090000</span><br></pre></td></tr></table></figure></p><p>查找在 1990~1999 年出生的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu WHERE birthday BETWEEN &apos;1990-01-01&apos; AND &apos;1999-12-31&apos;;</span><br></pre></td></tr></table></figure></p><p>获取年龄最大的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu ORDER BY birthday ASC LIMIT 1;</span><br><span class="line"># 更准确的查询</span><br><span class="line">SELECT * FROM stu</span><br><span class="line">WHERE birthday =(SELECT birthday FROM stu ORDER BY birthday ASC LIMIT 1);</span><br></pre></td></tr></table></figure></p><p>查询在 1 班或 2 班 1990 年出生的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu WHERE class_id IN(1,2) AND year(birthday)=1999;</span><br></pre></td></tr></table></figure></p><p>90 后最喜欢上的班级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(id) as total,class_id from stu</span><br><span class="line">WHERE LEFT(birthday,4) &gt;= 1990 AND YEAR(birthday)&lt;=2000</span><br><span class="line">GROUP BY class_id</span><br><span class="line">ORDER BY total DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></p><p>大于 20 岁的女生最多的班级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(id),class_id FROM stu</span><br><span class="line">WHERE TIMESTAMPDIFF(YEAR,birthday,now())&gt;20 AND sex=2</span><br><span class="line">GROUP BY class_id</span><br><span class="line">ORDER BY count(id) DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></p><h3 id="时间计算-1"><a href="#时间计算-1" class="headerlink" title="时间计算"></a>时间计算</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ADDTIME</td><td>添加时间（负数为减少），只对时间有效</td></tr><tr><td>TIMESTAMP</td><td>添加时间（负数为减少），只对时间有效</td></tr><tr><td>DATE_ADD</td><td>根据单位添加时间，支持单位有 YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE/DAY_HOUR/DAY_MINUTE/DAY_SECOND/HOUR_MINUTE/HOUR_SECOND（负数时等于 DATE_SUB)</td></tr><tr><td>DATE_SUB</td><td>DATE_ADD 的反函数</td></tr><tr><td>LAST_DAY</td><td>指定月最后一天日期</td></tr></tbody></table><p>七小时前的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ADDTIME(now(),&apos;-7:00:00&apos;)</span><br></pre></td></tr></table></figure></p><p>七天后的日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(now(),INTERVAL 7 DAY);</span><br></pre></td></tr></table></figure></p><p>20 小时 10 分钟后的日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(),INTERVAL &apos;20:10&apos; HOUR_MINUTE);</span><br></pre></td></tr></table></figure></p><p>2 天 8 小时后的日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(),INTERVAL &apos;2 8&apos; DAY_HOUR);</span><br></pre></td></tr></table></figure></p><p>获取本月最后一天日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LAST_DAY(now());</span><br></pre></td></tr></table></figure></p><p>获取本月的第一天日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);</span><br></pre></td></tr></table></figure></p><p>获取本月发表的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article</span><br><span class="line">WHERE created_at &gt;=DATE_SUB(now(),INTERVAL DAYOFMONTH(now()) DAY)</span><br><span class="line">AND created_at &lt;=LAST_DAY(now());</span><br></pre></td></tr></table></figure></p><blockquote><p>因为使用大量函数会造成性能下降，所以推荐在后台程序中算出时间后再进行比对</p></blockquote><p>获取三个月内发表的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article</span><br><span class="line">WHERE publish_time &gt;=DATE_SUB(now(),INTERVAL -3 MONTH) ;</span><br><span class="line"></span><br><span class="line"># 如果从前上个月的一号开始获取</span><br><span class="line">SELECT * from article</span><br><span class="line">WHERE publish_time &gt;= DATE_FORMAT(DATE_SUB(now(),INTERVAL 3 MONTH),&apos;%Y-%m-01&apos;);</span><br></pre></td></tr></table></figure></p><p>获取上个月的最后一天<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT LAST_DAY(DATE_SUB(NOW(),INTERVAL 1 MONTH));</span><br><span class="line"># 或直接通过明确日期</span><br><span class="line">SELECT * FROM article WHERE publish_time&gt;=&apos;2019-01-01&apos; AND publish_time&lt;CURDATE();</span><br></pre></td></tr></table></figure></p><p>下个月的第一天<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(LAST_DAY(NOW()),INTERVAL 1 DAY);</span><br></pre></td></tr></table></figure></p><p>查看出生超过 20 年的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu WHERE birthday &lt; DATE_SUB(NOW(),INTERVAL 20 YEAR);</span><br></pre></td></tr></table></figure></p><p>本周二的日期，使用 DAYOFWEEK 时周二为 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),DATE_ADD(NOW(),INTERVAL 3-DAYOFWEEK(NOW()) DAY);</span><br></pre></td></tr></table></figure></p><p>本周星期日<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT date_add(now(),INTERVAL 6-WEEKDAY(now()) DAY)</span><br><span class="line"></span><br><span class="line">SELECT date_add(now(),INTERVAL 1-DAYOFWEEK(now())+7 day)</span><br></pre></td></tr></table></figure></p><p>上周的星期日<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT date_add(now(),INTERVAL 1-DAYOFWEEK(now()) day)</span><br></pre></td></tr></table></figure></p><p>查看三周前的周二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT now(),</span><br><span class="line">DATE_SUB(DATE_ADD(NOW(),INTERVAL 3-DAYOFWEEK(NOW()) DAY),INTERVAL 21 DAY);</span><br><span class="line"></span><br><span class="line"># 或</span><br><span class="line">SELECT date_add(now(),INTERVAL 3-DAYOFWEEK(now())-21 DAY )</span><br></pre></td></tr></table></figure></p><p>上周一的日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET @week = DATE_SUB(NOW(),interval 1 week);</span><br><span class="line">SELECT DATE_ADD(@week,INTERVAL 0-WEEKDAY(@week) day);</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT date_add(now(),INTERVAL 2-DAYOFWEEK(now())-7 DAY )</span><br></pre></td></tr></table></figure></p><p>获取本月迟到的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from attendance</span><br><span class="line">WHERE created_at &gt;= date_sub(NOW(),INTERVAL DAYOFMONTH(now())-1 DAY)</span><br><span class="line">AND time(created_at)&gt;&apos;08:30:00&apos;;</span><br></pre></td></tr></table></figure></p><p>本月迟到超过 2 次的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select stu_id from attendance</span><br><span class="line">WHERE created_at &gt;= date_sub(NOW(),INTERVAL DAYOFMONTH(now())-1 DAY)</span><br><span class="line">AND time(created_at)&gt;&apos;08:30:00&apos;</span><br><span class="line">GROUP BY stu_id</span><br><span class="line">HAVING count(id)&gt;=2;</span><br></pre></td></tr></table></figure></p><p>本周周一的日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(now(),INTERVAL 0-WEEKDAY(now()) day);</span><br></pre></td></tr></table></figure></p><p>获取本周迟到的学生编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @begin =DATE_FORMAT(date_add(now(),INTERVAL 0-WEEKDAY(now()) day),&apos;%Y-%m-%d&apos;);</span><br><span class="line">select stu_id from attendance</span><br><span class="line">WHERE created_at &gt;= @begin</span><br><span class="line">AND time(created_at)&gt;&apos;08:00:00&apos;</span><br><span class="line">GROUP BY stu_id;</span><br></pre></td></tr></table></figure></p><p>获取上周打卡记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @week = DATE_SUB(now(),INTERVAL 1 WEEK);</span><br><span class="line">SELECT stu_id FROM attendance</span><br><span class="line">WHERE created_at&gt;=DATE_ADD(@week,interval 0-WEEKDAY(@week) day)</span><br><span class="line">AND created_at&lt;=DATE_ADD(@week,interval 4-WEEKDAY(@week) day);</span><br></pre></td></tr></table></figure></p><p>获取本周发表的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE created_at &gt;=DATE_ADD(now(),INTERVAL 0-WEEKDAY(now()) day);</span><br></pre></td></tr></table></figure></p><p>周日来校学习的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from attendance</span><br><span class="line">WHERE date(created_at) = date(date_add(now(),INTERVAL 6 - WEEKDAY(now()) day));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-日期时间&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(三)</title>
    <link href="/2023/04/06/MYSQL-%E4%B8%89/"/>
    <id>/2023/04/06/MYSQL-三/</id>
    <published>2023-04-06T08:12:52.000Z</published>
    <updated>2023-04-06T08:21:50.843Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-数据类型<br><a id="more"></a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h4><p>下面是 mysql 支持的字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 字节</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 字节</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 字节</td><td>极大文本数据</td></tr></tbody></table><p>char 类型是定长类型，比如定义了 20 长度的char类型，只存一个字符也占用 20 个长度，char 好处是处理速度快，缺点是空间占用大，把手机号、邮箱、密码等长度相对固定的设置为 char 类型是不错的选择。<br>varchar 类型与 char 相反，点用空间受内容影响，可以把文章标题、介绍等设置为 varchar 类型更合适。</p><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><p>字符串分二进制与非二进制类型，二进制用于储存图片、声音等文件，非二进制用于储存文本数据。<br>非二进制文本受字符集和校对规则影响。</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同。常用的字符集有 GBK、BIG5、UTF8。<br>UTF8 字符包含文字内容更广，如韩文、日文、德文兼容度更高，也是推荐使用的字符集。<br>下面是查看服务器支持的字符集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CHARACTER SET;</span><br></pre></td></tr></table></figure></p><p>表不设置字符集继承数据库，字段不设置字符集继承表的</p><h4 id="校对规则"><a href="#校对规则" class="headerlink" title="校对规则"></a>校对规则</h4><p>是在字符集内用于字符比较和排序的一套规则，以_ci 结束的为大小写不敏感、_bin 结束的为区分大小写。<br>下面是查看系统支持的校对规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show COLLATION;</span><br></pre></td></tr></table></figure></p><p>当使用不区分大小写的校对规则时 A 与 a 是相同的，否则则不相同，这会影响到排序与比对。<br>如果使用utf8_bin 校对规则时，下面的查询将匹配不到大写的PHP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class WHERE cname = &apos;php&apos;;</span><br></pre></td></tr></table></figure></p><blockquote><p>修改表校对规则，对表的原字段将不影响，只对新增字段影响。</p></blockquote><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>大小写转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT UPPER(cname) as cname,LOWER(description) as `desc` from class;</span><br></pre></td></tr></table></figure></p><p>Left&amp;right<br>left 与 right 函数用于取左或右指定数量的字符，下面是取班级介绍前 8 个字符并用… 连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(LEFT(description,8),&apos;...&apos;) FROM class;</span><br></pre></td></tr></table></figure></p><p>mid<br>从中间取字符串，参数二为起始，参数三为取的字符数量。下面是获取从第二个字符取两个字符值为hp的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from class where mid(cname,2,2) = &apos;hp&apos;;</span><br></pre></td></tr></table></figure></p><p>substring<br>从指定位置开始向右取所有字符串，下面是获取从第二个位置开始的字符值为hp的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from class where SUBSTRING(cname,2) = &apos;hp&apos;;</span><br></pre></td></tr></table></figure></p><p>char_length<br>获取字符串数量</p><p>concat<br>连接字符串使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(&apos;编号:&apos;,id) as id,concat(&apos;班级:&apos;,cname) as name FROM class;</span><br></pre></td></tr></table></figure></p><p>将所有班级前加上后盾人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE class SET cname = CONCAT(&apos;后盾人:&apos;,cname);</span><br></pre></td></tr></table></figure></p><p>截取班级介绍，超过 8 个字符的后面连接…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">if(CHAR_LENGTH(description)&gt;8,CONCAT(LEFT(description,8),&apos;...&apos;),LEFT(description,8)) as name</span><br><span class="line">FROM class;</span><br></pre></td></tr></table></figure></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>Mysql 支持正则表达式操作，可用于处理复杂的匹配操作。<br>查找第二个字符为h的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM class WHERE cname REGEXP &apos;^.h&apos;;</span><br></pre></td></tr></table></figure></p><p>查找班级名称中包含php 或 mysql的记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM class WHERE cname REGEXP &apos;php|mysql&apos;;</span><br></pre></td></tr></table></figure></p><p>所有介绍中包含 php 与 mysql 的课程名前加上后盾人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update class set cname = REPLACE(cname,cname,concat(&apos;后盾人：&apos;,cname))</span><br><span class="line">where description REGEXP  &apos;php|mysql&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><p>在 LIKE 表达式中 % 用于匹配任意多个字符，_ 用于匹配一个字符。<br>查找第二个字符为 h 的班级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT *  FROM class WHERE cname LIKE &apos;_h%&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整型</p><table><thead><tr><th>MySQL 数据类型</th><th>范围（有符号）</th><th>范围（无符号）</th></tr></thead><tbody><tr><td>tinyint(m)</td><td>1 个字节 范围(-128~127)</td><td>(0，255)</td></tr><tr><td>smallint(m)</td><td>2 个字节 范围(-32768~32767)</td><td>(0，65 535)</td></tr><tr><td>mediumint(m)</td><td>3 个字节 范围(-8388608~8388607)</td><td>(0，16 777 215)</td></tr><tr><td>int(m)</td><td>4 个字节 范围(-2147483648~2147483647)</td><td>(0，4 294 967 295)</td></tr><tr><td>bigint(m)</td><td>8 个字节 范围(+-9.22*10 的 18 次方)</td><td>(0，18 446 744 073 709 551 615)</td></tr></tbody></table><ul><li>取值范围如果加了 unsigned，则最大值翻倍，如 tinyint unsigned 的取值范围为(0~256)。</li><li>m 的含义不是允许字段的长度，而是显示长度，在为字段设置 zerofill 时有效。</li></ul><p>添加有前导零的字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE class ADD stu_count smallint(6) ZEROFILL default null;</span><br></pre></td></tr></table></figure></p><p>在命令行查看（有些 GUI 软件不显示前导零)，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------------------------------------------+-----------+</span><br><span class="line">| id | cname | description                                | stu_count |</span><br><span class="line">+----+-------+--------------------------------------------+-----------+</span><br><span class="line">|  4 | Mysql | 数据库                                     |    000001 |</span><br><span class="line">|  5 | PHP   | 后盾人教你使用PHP快速开发网站              |      NULL |</span><br><span class="line">+----+-------+--------------------------------------------+-----------+</span><br></pre></td></tr></table></figure></p><p>浮点型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th></tr></thead><tbody><tr><td>FLOAT</td><td>4 字节</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td></tr><tr><td>DECIMAL</td><td>DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td><td>依赖于 M 和 D 的值</td><td>依赖于 M 和 D 的值</td></tr></tbody></table><p>下面是检测浮点数精度的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table class add e FLOAT(10,2);</span><br><span class="line">update class set e = 12345678.66 where id=11;</span><br></pre></td></tr></table></figure></p><p>查看结果时会发布浮点数结果不精确。</p><ul><li>float：2^23 = 8388608，一共七位，这意味着最多能有 7 位有效数字，但绝对能保证的为 6 位，即 float 的精度为 6~7 位有效数字</li><li>double：2^52 = 4503599627370496，一共 16 位，double 的精度为 15~16 位</li><li>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值</li><li>decimal(m,d) 参数 m&lt;65 是总个数，d&lt;30 且 d&lt;m 是小数位</li><li>对货币等对精度敏感的数据，应该用定点数 decimal 存储</li></ul><h3 id="ENUM-SET"><a href="#ENUM-SET" class="headerlink" title="ENUM/SET"></a>ENUM/SET</h3><h4 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h4><p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。换个枚举最大可以有 65535 个成员值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD sex ENUM(&apos;男&apos;,&apos;女&apos;) DEFAULT NULL;</span><br></pre></td></tr></table></figure></p><p>可以使用索引或值添加 enum 数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu (sname,class_id,sex) VALUES(&apos;李岗&apos;,1,&apos;男&apos;);</span><br><span class="line">INSERT INTO stu (sname,class_id,sex) VALUES(&apos;李玉&apos;,1,2);</span><br></pre></td></tr></table></figure></p><p>可以使用值与索引检索 ENUM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu WHERE sex=&apos;女&apos;;</span><br><span class="line">SELECT * from stu WHERE sex=2;</span><br></pre></td></tr></table></figure></p><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。一个 SET 类型最多可以包含 64 项元素。<br>使用 SET 类型添加文章属性字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD flag SET(&apos;推荐&apos;,&apos;置顶&apos;,&apos;图文&apos;,&apos;热门&apos;);</span><br></pre></td></tr></table></figure></p><p>添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO article (title,status,flag)VALUES(&apos;后盾人&apos;,1,&apos;图文,推荐,置顶&apos;);</span><br></pre></td></tr></table></figure></p><p>使用 find_in_set 查找数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE find_in_set(&apos;图文&apos;,flag);</span><br></pre></td></tr></table></figure></p><p>使用like 查找数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE flag like &apos;%置顶%&apos;</span><br></pre></td></tr></table></figure></p><p>二进制比较<br>可以使用二进制方式对 SET 类型进行模糊筛选。</p><table><thead><tr><th>SET 成员</th><th>十进制值</th><th>二进制值</th></tr></thead><tbody><tr><td>推荐</td><td>1</td><td>0001</td></tr><tr><td>置顶</td><td>2</td><td>0010</td></tr><tr><td>图文</td><td>4</td><td>0100</td></tr><tr><td>热门</td><td>8</td><td>1000</td></tr></tbody></table><p>获取包含图文与推荐的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE flag &amp; 5;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-数据类型&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(二)</title>
    <link href="/2023/04/06/MYSQL-%E4%BA%8C/"/>
    <id>/2023/04/06/MYSQL-二/</id>
    <published>2023-04-06T08:09:47.000Z</published>
    <updated>2023-04-06T08:20:12.422Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-表维护<br><a id="more"></a></p><h2 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h2><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>修改表名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu RENAME stus;</span><br></pre></td></tr></table></figure></p><p>别一种操作方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE stus to stu;</span><br></pre></td></tr></table></figure></p><p>修改表字符集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE class charset gbk;</span><br></pre></td></tr></table></figure></p><p>删除表所有数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE stu;</span><br></pre></td></tr></table></figure></p><p>删除数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stu;</span><br></pre></td></tr></table></figure></p><h3 id="字段管理"><a href="#字段管理" class="headerlink" title="字段管理"></a>字段管理</h3><p>修改字段类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY sname char(30) not null;</span><br></pre></td></tr></table></figure></p><p>修改字段时同时更改字段名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu CHANGE sname name varchar(30) not null;</span><br></pre></td></tr></table></figure></p><p>添加字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD sex SMALLINT default null;</span><br></pre></td></tr></table></figure></p><p>在学生名称后添加邮箱字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD email varchar(50) AFTER sname;</span><br></pre></td></tr></table></figure></p><p>将字段添加到最前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD qq varchar(30) first;</span><br></pre></td></tr></table></figure></p><p>删除学生邮箱字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP email;</span><br></pre></td></tr></table></figure></p><h3 id="主键操作"><a href="#主键操作" class="headerlink" title="主键操作"></a>主键操作</h3><p>一般主键为自增字段，需要删除自增属性后才可以删除主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id int not null;</span><br></pre></td></tr></table></figure></p><p>删除主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP PRIMARY key;</span><br></pre></td></tr></table></figure></p><p>添加表主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table stu2 add PRIMARY KEY(id);</span><br></pre></td></tr></table></figure></p><p>添加自增列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu2 MODIFY id int not null AUTO_INCREMENT;</span><br></pre></td></tr></table></figure></p><p>主键与自增列一起添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table stu3 modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-表维护&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL(一)</title>
    <link href="/2023/04/04/MYSQL-%E4%B8%80/"/>
    <id>/2023/04/04/MYSQL-一/</id>
    <published>2023-04-04T06:57:09.000Z</published>
    <updated>2023-04-06T08:21:15.213Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理-基础操作<br><a id="more"></a></p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>在命令行连接 mysql 的参数如下：</p><table><thead><tr><th>选项</th><th>说明</th><th>默认</th></tr></thead><tbody><tr><td>-u</td><td>帐号</td><td>当前系统同名帐号</td></tr><tr><td>-p</td><td>密码</td></tr><tr><td>-P</td><td>连接端口</td><td>3306</td></tr><tr><td>-h</td><td>主机地址</td><td>127.0.0.1</td></tr><tr><td>-e</td><td>执行 sql 指令</td></tr></tbody></table><h4 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h4><p>连接服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -P3306 -h 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>连接本地数据库时可以使用默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></p><p>使用-e 执行 SQL 语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot -e&quot;show databases;&quot;</span><br></pre></td></tr></table></figure></p><p>退出连接<br>命令行下执行 exit 可通出当前连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></p><h4 id="执行与取消"><a href="#执行与取消" class="headerlink" title="执行与取消"></a>执行与取消</h4><p>每条 SQL 指令以;结束，按回车键后执行该条语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></p><p>放弃语句<br>在 SQL 后使用 \c表示取消本条 SQL，后面不需要写 ;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases \c</span><br></pre></td></tr></table></figure></p><h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>数据库列表<br>使用以下命令可以得到当前服务器中的所有数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></p><p>创建新库<br>下面是创建数据库 houdunren 并设置字符集为 utf8。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE houdunren CHARSET utf8;</span><br></pre></td></tr></table></figure></p><p>查看数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database houdunren;</span><br></pre></td></tr></table></figure></p><p>删除数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database houdunren;</span><br></pre></td></tr></table></figure></p><p>为了防止删除不存在的数据库报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists houdunren;</span><br></pre></td></tr></table></figure></p><p>选择数据库<br>数据库主要是对表操作，选择数据库后可以省掉每次指定数据库的麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use houdunren</span><br></pre></td></tr></table></figure></p><h4 id="导入语句"><a href="#导入语句" class="headerlink" title="导入语句"></a>导入语句</h4><p>有时需要把外部的 SQL 文件导入到服务器中，图像化的数据库管理软件都支持导入，下面我们介绍命令行的使用方法。<br>创建文件<br>下面我们创建 test.sql文件内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database hdcms charset utf8;</span><br><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure></p><p>外部导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt; test.sql</span><br></pre></td></tr></table></figure></p><p>连接后导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">&gt; source test.sql</span><br></pre></td></tr></table></figure></p><h3 id="数据表管理"><a href="#数据表管理" class="headerlink" title="数据表管理"></a>数据表管理</h3><p>可以把数据库理解为文件夹，数据表理解为文件，数据表是真正储存数据的地方。</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>创建数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table class (</span><br><span class="line">id int primary key AUTO_INCREMENT,</span><br><span class="line">cname varchar(30) NOT NULL,</span><br><span class="line">description varchar(100) default NULL)</span><br><span class="line">charset utf8;</span><br></pre></td></tr></table></figure></p><p>以上语句创建表 class 字段说明如下：</p><ul><li>字段 id 为主键自增</li><li>字段 cname 为字符串类型 varchar 并不允许为 null</li><li>字段 description 为可为 null 字符串</li><li>字符集为 utf8 ，如果不设置将继承数据库字符集</li></ul><p>添加测试数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO class (cname,description) VALUES(&apos;PHP&apos;,&apos;后盾人教你使用PHP快速开发网站&apos;);</span><br><span class="line">INSERT INTO class (cname) VALUES(&apos;Mysql&apos;);</span><br></pre></td></tr></table></figure></p><p>因为 description 设置为 null 所以第二个记录没有设置值时使用默认的 null 值。</p><h4 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h4><p>根据已经存在的表结构创建新表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table hdcms like class;</span><br></pre></td></tr></table></figure></p><p>复制其他表的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into hdcms select * from class;</span><br></pre></td></tr></table></figure></p><p>只复制批定字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into hdcms (cname) select cname from class;</span><br></pre></td></tr></table></figure></p><p>复制表时同时复制数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table hdjs select * from class;</span><br></pre></td></tr></table></figure></p><p>下面是只复制指定字段，并为不同名字段起别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table hd (id int primary key AUTO_INCREMENT,name varchar(30)) select id,cname as name from class;</span><br></pre></td></tr></table></figure></p><p>删除数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TEMPORARY TABLE IF EXISTS hd;</span><br></pre></td></tr></table></figure></p><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><p>临时表是用于储存临时数据表表，会在数据库连接中断时自动删除。</p><ul><li>可以与普通表同名，优先级高于普通表</li><li>连接终端时自动删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create TEMPORARY TABLE class_names SELECT * from class;</span><br><span class="line">select * from class_names;</span><br></pre></td></tr></table></figure></li></ul><p>删除临时表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TEMPORARY TABLE IF EXISTS class_names;</span><br></pre></td></tr></table></figure></p><blockquote><p>当然开发中我们更喜欢将临时数据放在缓存或会话中，以上只是介绍这个 mysql 特性。</p></blockquote><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="测试表"><a href="#测试表" class="headerlink" title="测试表"></a>测试表</h4><p>为了进行查询实例操作我们创建以下表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu (id int PRIMARY KEY AUTO_INCREMENT,sname char(30),class_id int default null,age smallint default null)</span><br><span class="line"></span><br><span class="line">INSERT INTO stu(sname,class_id,age) VALUES(&apos;小明&apos;,1,20),(&apos;张三&apos;,2,32),(&apos;李四&apos;,3,null),(&apos;小刘&apos;,null,46);</span><br></pre></td></tr></table></figure></p><h4 id="字段处理"><a href="#字段处理" class="headerlink" title="字段处理"></a>字段处理</h4><p>查询所有字估数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class;</span><br></pre></td></tr></table></figure></p><p>查询指定字段数据并排序字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select description,cname from class;</span><br></pre></td></tr></table></figure></p><h4 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h4><p>根据条件查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class where cname = &apos;php&apos;</span><br></pre></td></tr></table></figure></p><p>查询包含关键词的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class where description like &apos;%p%&apos;;</span><br></pre></td></tr></table></figure></p><p>合并列返回查询结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select CONCAT(id,cname) as &apos;class_info&apos; FROM class;</span><br></pre></td></tr></table></figure></p><p>指定多条件查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM class where id&gt;1 and cname = &apos;php&apos;</span><br></pre></td></tr></table></figure></p><p>查找一班或姓张的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where class_id =1 or sname like &apos;%张%&apos;</span><br></pre></td></tr></table></figure></p><p>介绍中不包含 php 的班级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from class WHERE description NOT LIKE &apos;%php%&apos;;</span><br></pre></td></tr></table></figure></p><p>查询学生所在班级编号，并去除重复值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT class_id from stu ;</span><br></pre></td></tr></table></figure></p><p>查询年龄在 20~35 岁的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age BETWEEN 20 and 35;</span><br></pre></td></tr></table></figure></p><p>查找不在 30~35 岁间的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age NOT BETWEEN 30 and 35;</span><br></pre></td></tr></table></figure></p><p>查找 2、3 班的所有同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu where class_id IN(2,3);</span><br></pre></td></tr></table></figure></p><p>查找除了 1、3 班的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where class_id NOT IN (1,3);</span><br></pre></td></tr></table></figure></p><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>查询没有分配班级的学生姓名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname from stu where class_id is null;</span><br></pre></td></tr></table></figure></p><p>查询已经分配班级的学生信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu where class_id is not null;</span><br></pre></td></tr></table></figure></p><p>查询结果中对没分配班级的学生显示未分配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sname,if(class_id is null,&apos;未分配&apos;,class_id) from stu;</span><br><span class="line"># 也可以使用IFNULl 函数简化操作</span><br><span class="line">select sname,ifnull (class_id ,&apos;未分配&apos;) from stu;</span><br></pre></td></tr></table></figure></p><h4 id="排序结果"><a href="#排序结果" class="headerlink" title="排序结果"></a>排序结果</h4><p>按学生年龄从大到小排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu order by age desc;</span><br></pre></td></tr></table></figure></p><p>班级从大到小排序，相同班级的同学年龄从小到大排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu order by class_id DESC,age ASC;</span><br></pre></td></tr></table></figure></p><p>随机获取一名同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu order by RAND() limit 1;</span><br></pre></td></tr></table></figure></p><p>最后报名的同名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu order by id desc limit 1</span><br></pre></td></tr></table></figure></p><p>第二和第三报名的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Limit 是从零开始的</span><br><span class="line">SELECT * FROM stu order by id ASC limit 1,2;</span><br></pre></td></tr></table></figure></p><p>查找 2 班年龄最小的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu where class_id =2 and age is not null order by age asc limit 1;</span><br></pre></td></tr></table></figure></p><p>以上代码结果不准确，因为可能有同年龄的同学，所以可以使用子查询操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age = (SELECT age from stu where class_id =2 and age is not null order by age asc limit 1)</span><br></pre></td></tr></table></figure></p><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>将班级为 2 的学生改为班级 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu SET class_id = 3 WHERE class_id = 2;</span><br></pre></td></tr></table></figure></p><p>2 班年龄小于 20 岁的同学年龄设置为 NULL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu SET age = null WHERE class_id=2 AND age&lt;20;</span><br></pre></td></tr></table></figure></p><p>将年龄小于 20 岁的同学年龄加 10 岁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu SET age= age+20 WHERE age&lt;20;</span><br></pre></td></tr></table></figure></p><h4 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h4><p>删除所有年龄小于 20 的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM stu WHERE age&lt;20;</span><br></pre></td></tr></table></figure></p><p>删除所有年龄小在 30 并没有班级的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM stu WHERE class_id IS NULL;</span><br></pre></td></tr></table></figure></p><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>添加一条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu SET sname = &apos;小明&apos;,age=22,class_id=1;</span><br></pre></td></tr></table></figure></p><p>添加多条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu (sname,class_id,age) VALUES(&apos;小明&apos;,2,32),(&apos;小张&apos;,3,45);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理-基础操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="MYSQL笔记" scheme="/tags/MYSQL%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的AI工具</title>
    <link href="/2023/04/04/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84AI%E5%B7%A5%E5%85%B7/"/>
    <id>/2023/04/04/提高效率的AI工具/</id>
    <published>2023-04-04T06:24:59.000Z</published>
    <updated>2023-04-04T06:46:44.338Z</updated>
    
    <content type="html"><![CDATA[<p>工作中提高效率的AI工具<br><a id="more"></a></p><h2 id="5款腾讯免费AI工具"><a href="#5款腾讯免费AI工具" class="headerlink" title="5款腾讯免费AI工具"></a>5款腾讯免费AI工具</h2><h3 id="Effidit-智能创作助手"><a href="#Effidit-智能创作助手" class="headerlink" title="Effidit 智能创作助手"></a><a href="https://effidit.qq.com/" target="_blank" rel="noopener">Effidit 智能创作助手</a></h3><blockquote><p>「Effidit」是一款免费的人工智能写作助手，提供多种实用功能，包括文本纠错、文本润色、文本改写、文本扩写、词语推荐、句子推荐与生成等。使用 Effidit 可以轻松完成中英文写作，提高写作效率。</p></blockquote><h3 id="腾讯交互翻译"><a href="#腾讯交互翻译" class="headerlink" title="腾讯交互翻译"></a><a href="https://yi.qq.com/" target="_blank" rel="noopener">腾讯交互翻译</a></h3><blockquote><p>「腾讯交互翻译」是一款免费跨平台人工智能翻译神器，目前支持 20 种语言互译，翻译精准。它最大的特色在于融合了腾讯自研的 AI 技术。</p></blockquote><h3 id="帮小忙"><a href="#帮小忙" class="headerlink" title="帮小忙"></a><a href="https://tool.browser.qq.com/" target="_blank" rel="noopener">帮小忙</a></h3><blockquote><p>「帮小忙」是一款所有功能完全免费的万能工具箱，涵盖了“图片”、“数据换算”、“生活娱乐”、“教育”、“文本工具”、“文档转换”、“开发工具”、“视频”和“PDF 转换工具”等 9 大类在线工具，目前共有 122 款，功能超级全面，最重要的还是免费的。</p></blockquote><h3 id="ARC-实验室"><a href="#ARC-实验室" class="headerlink" title="ARC 实验室"></a><a href="https://arc.tencent.com/zh/ai-demos/faceRestoration" target="_blank" rel="noopener">ARC 实验室</a></h3><blockquote><p>「ARC 实验室」是腾讯专门探索前沿科技的团队，被称为腾讯 PCG 的“侦察兵”、“特种兵”，目前 ARC 实验室公布了三款主要工具：“人像修复”、“人像抠图”和“动漫增强”，完全免费。</p></blockquote><h3 id="腾讯智影"><a href="#腾讯智影" class="headerlink" title="腾讯智影"></a><a href="https://zenvideo.qq.com/" target="_blank" rel="noopener">腾讯智影</a></h3><blockquote><p>「腾讯智影」是一款云端智能视频创作工具，无需下载即可通过 PC 浏览器访问，支持视频云剪辑、素材库、文本配音、数字人播报、自动字幕识别等功能，帮助用户更好地进行视频化的表达。</p></blockquote><h2 id="国外流行AI工具-有些需要科学上网"><a href="#国外流行AI工具-有些需要科学上网" class="headerlink" title="国外流行AI工具(有些需要科学上网)"></a>国外流行AI工具(有些需要科学上网)</h2><h3 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a><a href="https://chat.openai.com/chat" target="_blank" rel="noopener">ChatGPT</a></h3><blockquote><p> ChatGPT 是最近特别火爆的一款 AI 工具，它能够通过理解和学习人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文等任务。</p></blockquote><h3 id="Midjourney"><a href="#Midjourney" class="headerlink" title="Midjourney"></a><a href="https://www.midjourney.com/" target="_blank" rel="noopener">Midjourney</a></h3><blockquote><p>Midjourney 是一个由 Midjourney 研究实验室开发的人工智能程序，它可以根据你输入的文本智能生成图片，当然你也可以使用使用图片去生成与该图片类似的图片（图生图）。</p></blockquote><h3 id="Writesonic"><a href="#Writesonic" class="headerlink" title="Writesonic"></a><a href="https://writesonic.com/" target="_blank" rel="noopener">Writesonic</a></h3><blockquote><p>Writesonic 是一个人工智能作家，它可以以 10 倍的速度为您的博客、广告、电子邮件和网站创建 SEO 优化且无抄袭的内容。</p></blockquote><h3 id="remove-bg"><a href="#remove-bg" class="headerlink" title="remove.bg"></a><a href="https://www.remove.bg/" target="_blank" rel="noopener">remove.bg</a></h3><blockquote><p>使用 remove.bg 智能 AI 工具，您只需轻点一下，就可以在 5 秒钟内完全自动地去除背景。这将为您节省大量编辑时间，同时增加更多的乐趣。remove.bg 支持通过上传图片、拖拽图片和粘贴图片地址的方式选择图片进行处理。</p></blockquote><h3 id="beauiful-ai"><a href="#beauiful-ai" class="headerlink" title="beauiful.ai"></a><a href="https://www.beautiful.ai/" target="_blank" rel="noopener">beauiful.ai</a></h3><blockquote><p>beautiful.ai 提供了大量智能 PPT 模版，您可以自由选择模版，轻松生成您的 PPT，让您可以在几分钟内创建专业 PPT，而不是几个小时。</p></blockquote><h3 id="Galileo-AI"><a href="#Galileo-AI" class="headerlink" title="Galileo AI"></a><a href="https://www.usegalileo.ai/" target="_blank" rel="noopener">Galileo AI</a></h3><blockquote><p>Galileo AI 是一个生成式人工智能，它只需要您输入一个文本提示，即可生成令人惊叹、完全可编辑的 UI 设计，使您能够以超乎想象的速度进行设计。此外，它还提供许多由人工智能生成的插图和图像，供您添加到您的产品中。</p></blockquote><h3 id="Excel-Formula-Bot"><a href="#Excel-Formula-Bot" class="headerlink" title="Excel Formula Bot"></a><a href="https://excelformulabot.com/" target="_blank" rel="noopener">Excel Formula Bot</a></h3><blockquote><p>Excel Formula Bot 借助 AI 能力，让您几秒钟内快速将文本指令转化为 Excel 公式，帮助您解决所有电子表格问题。</p></blockquote><h3 id="Auto-Draw"><a href="#Auto-Draw" class="headerlink" title="Auto Draw"></a><a href="https://www.autodraw.com/" target="_blank" rel="noopener">Auto Draw</a></h3><blockquote><p>AutoDraw 是一种来自谷歌创意实验室的完全免费的 AI 智能自动绘图工具。它将机器学习与天才艺术家的画作配对，帮助每个人快速创建任何视觉效果。并且它可以在任何地方使用：手机、平板电脑、笔记本电脑、台式机等。</p></blockquote><h3 id="TLDR-this"><a href="#TLDR-this" class="headerlink" title="TLDR-this"></a><a href="https://tldrthis.com/" target="_blank" rel="noopener">TLDR-this</a></h3><blockquote><p>TLDR 可帮助您将任何一段文本总结为简洁、易于理解的内容。将自己从信息过载中解放出来。</p></blockquote><h3 id="Fliki"><a href="#Fliki" class="headerlink" title="Fliki"></a><a href="https://fliki.ai/" target="_blank" rel="noopener">Fliki</a></h3><blockquote><p>Fliki 可以将文本转换为带有 AI 语音短视频，您可以在 1 分钟内用人工智能的声音创建音频和视频内容。有了 Fliki，您就可以将您的博客文章或任何基于文本的内容转换成视频、播客或有声读物的配音。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中提高效率的AI工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>前端枚举</title>
    <link href="/2023/03/31/%E5%89%8D%E7%AB%AF%E6%9E%9A%E4%B8%BE/"/>
    <id>/2023/03/31/前端枚举/</id>
    <published>2023-03-31T05:16:16.000Z</published>
    <updated>2023-03-31T06:17:14.623Z</updated>
    
    <content type="html"><![CDATA[<p>前端枚举的简单入门<br><a id="more"></a></p><blockquote><p>枚举在类似java等语言中很基础，但是js中却没有，即使现在的es6也没有把枚举加进来。但是，typescript中是有枚举供使用的。</p></blockquote><h2 id="typescript中枚举示例"><a href="#typescript中枚举示例" class="headerlink" title="typescript中枚举示例"></a>typescript中枚举示例</h2><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ts</span><br><span class="line">enum demo1 &#123;</span><br><span class="line">  Up = 1,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var demo1;</span><br><span class="line">(function (demo1) &#123;</span><br><span class="line">  demo1[demo1[&quot;Up&quot;] = 1] = &quot;Up&quot;;</span><br><span class="line">  demo1[demo1[&quot;Down&quot;] = 2] = &quot;Down&quot;;</span><br><span class="line">  demo1[demo1[&quot;Left&quot;] = 3] = &quot;Left&quot;;</span><br><span class="line">  demo1[demo1[&quot;Right&quot;] = 4] = &quot;Right&quot;;</span><br><span class="line">&#125;)(demo1 || (demo1 = &#123;&#125;));</span><br><span class="line"></span><br><span class="line">// console</span><br><span class="line">&#123;</span><br><span class="line">  &quot;1&quot;: &quot;Up&quot;,</span><br><span class="line">  &quot;2&quot;: &quot;Down&quot;,</span><br><span class="line">  &quot;3&quot;: &quot;Left&quot;,</span><br><span class="line">  &quot;4&quot;: &quot;Right&quot;,</span><br><span class="line">  &quot;Up&quot;: 1,</span><br><span class="line">  &quot;Down&quot;: 2,</span><br><span class="line">  &quot;Left&quot;: 3,</span><br><span class="line">  &quot;Right&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ts</span><br><span class="line">enum demo2 &#123;</span><br><span class="line">  Up = &quot;UP&quot;,</span><br><span class="line">  Down = &quot;DOWN&quot;,</span><br><span class="line">  Left = &quot;LEFT&quot;,</span><br><span class="line">  Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var demo2;</span><br><span class="line">(function (demo2) &#123;</span><br><span class="line">  demo2[&quot;Up&quot;] = &quot;UP&quot;;</span><br><span class="line">  demo2[&quot;Down&quot;] = &quot;DOWN&quot;;</span><br><span class="line">  demo2[&quot;Left&quot;] = &quot;LEFT&quot;;</span><br><span class="line">  demo2[&quot;Right&quot;] = &quot;RIGHT&quot;;</span><br><span class="line">&#125;)(demo2 || (demo2 = &#123;&#125;));</span><br><span class="line"></span><br><span class="line">// console</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Up&quot;: &quot;UP&quot;,</span><br><span class="line">  &quot;Down&quot;: &quot;DOWN&quot;,</span><br><span class="line">  &quot;Left&quot;: &quot;LEFT&quot;,</span><br><span class="line">  &quot;Right&quot;: &quot;RIGHT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ts</span><br><span class="line">enum demo3 &#123;</span><br><span class="line">  No = 0,</span><br><span class="line">  Yes = &quot;YES&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var demo3;</span><br><span class="line">(function (demo3) &#123;</span><br><span class="line">  demo3[demo3[&quot;No&quot;] = 0] = &quot;No&quot;;</span><br><span class="line">  demo3[&quot;Yes&quot;] = &quot;YES&quot;;</span><br><span class="line">&#125;)(demo3 || (demo3 = &#123;&#125;));</span><br><span class="line"></span><br><span class="line">// console</span><br><span class="line">&#123;</span><br><span class="line">  &quot;0&quot;: &quot;No&quot;,</span><br><span class="line">  &quot;No&quot;: 0,</span><br><span class="line">  &quot;Yes&quot;: &quot;YES&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面3个例子，ts部分是在typescript中的写法，js部分是typescript编译后的写法。可以发现，枚举中的数字类型和字符串类型编译后的结果稍有区别，在使用时也可以灵活使用。</p><h2 id="前端中枚举的作用"><a href="#前端中枚举的作用" class="headerlink" title="前端中枚举的作用"></a>前端中枚举的作用</h2><p>不难看出，枚举被编译后的结果就是一个js对象，那直接使用对象不是更好？<br>其实，枚举主要作用是减少代码的错误，比如这样一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum demo &#123;</span><br><span class="line">  Up = &quot;UP&quot;,</span><br><span class="line">  Down = &quot;DOWN&quot;,</span><br><span class="line">  Left = &quot;LEFT&quot;,</span><br><span class="line">  Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用1</span><br><span class="line">demo.Up</span><br><span class="line">// 使用2</span><br><span class="line">demo.Upp</span><br></pre></td></tr></table></figure></p><p>上述代码的使用2，在编译阶段就会报错，如果不使用ts的话，只能在运行时才能发现错误，可以提高代码正确率。</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>vue3的源码中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export const enum ShapeFlags &#123;</span><br><span class="line">  ELEMENT = 1,</span><br><span class="line">  FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1,</span><br><span class="line">  STATEFUL_COMPONENT = 1 &lt;&lt; 2,</span><br><span class="line">  TEXT_CHILDREN = 1 &lt;&lt; 3,</span><br><span class="line">  ARRAY_CHILDREN = 1 &lt;&lt; 4,</span><br><span class="line">  SLOTS_CHILDREN = 1 &lt;&lt; 5,</span><br><span class="line">  TELEPORT = 1 &lt;&lt; 6,</span><br><span class="line">  SUSPENSE = 1 &lt;&lt; 7,</span><br><span class="line">  COMPONENT_SHOULD_KEEP_ALIVE = 1 &lt;&lt; 8,</span><br><span class="line">  COMPONENT_KEPT_ALIVE = 1 &lt;&lt; 9,</span><br><span class="line">  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一段代码，简单些理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const study =  &#123;</span><br><span class="line">    html: 1,</span><br><span class="line">    css: 1 &lt;&lt; 1,</span><br><span class="line">    js: 1 &lt;&lt; 2,</span><br><span class="line">    svg: 1 &lt;&lt; 3,</span><br><span class="line">    canvas: 1 &lt;&lt; 4</span><br><span class="line">&#125;</span><br><span class="line">function isStudy(studentNum, ...enumStudyArr) &#123;</span><br><span class="line">    // 1 00000001 代表html</span><br><span class="line">    // 2 00000010 代表css</span><br><span class="line">    // 4 00000100 代表js</span><br><span class="line">    // 8 00001000 代表svg</span><br><span class="line">    // 16 00010000 代表canvas</span><br><span class="line">    return enumStudyArr.every(item=&gt; &#123;</span><br><span class="line">        return studentNum &amp; item;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 使用：</span><br><span class="line">* 假设mike会html和svg，那么他的num就是1+8=9;</span><br><span class="line">* isStudy(9, study.html, study.svg);</span><br><span class="line">* 如果都会的话，1+2+4+8+16=31;</span><br><span class="line">* isStudy(31, study.html, study.css, study.js, study.svg, study.canvas);</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">let mikeNum = 9;</span><br><span class="line">console.log(&apos;1-&gt;:&apos;, isStudy(mikeNum, study.html, study.svg));</span><br><span class="line">console.log(&apos;2-&gt;:&apos;, isStudy(mikeNum, study.html, study.css, study.js, study.svg, study.canvas));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端枚举的简单入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的执行上下文和调用栈</title>
    <link href="/2023/03/15/javascript%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <id>/2023/03/15/javascript中的执行上下文和调用栈/</id>
    <published>2023-03-15T06:59:07.000Z</published>
    <updated>2023-03-15T07:15:57.124Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript中你必须理解的执行上下文和调用栈<br><a id="more"></a></p><blockquote><p>执行上下文在 JavaScript 是非常重要的基础知识，想要理解 JavaScript 的执行过程，执行上下文 是你必须要掌握的知识。否则只能是知其然不知其所以然。<br>理解执行上下文有什么好处呢？<br>它可以帮助你更好的理解代码的执行过程，作用域，闭包等关键知识点。特别是闭包它是 JavaScript 中的一个难点，当你理解了执行上下文在回头看闭包时，应该会有豁然开朗的感觉。<br>这篇文章我们将深入了解 执行上下文，读完文章之后你应该可以清楚的了解到 JavaScript 解释器到底做了什么，为什么可以在一些函数和变量之前使用它，以及它们的值是如何确定的。</p></blockquote><h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>在 JavaScript 中运行代码时，代码的执行环境非常重要，通常是下列三种情况：</p><ul><li>Global code：代码第一次执行时的默认环境。</li><li>Function code：函数体中的代码</li><li>Eval code：eval 函数内执行的文本（实际开发中很少使用，所以见到的情况不多）</li></ul><p>在网上你可以读到很多关于作用域的文章，为了便于理解本文的内容，我们将 执行上下文 当作代码的 执行环境/作用域。现在就让我们看一个例子：它包括 全局和函数/本地执行上下文。<br><img src="/2023/03/15/javascript中的执行上下文和调用栈/1.image" alt="img"><br>上面的例子我们看到，紫色的框代表全局上下文，绿色、蓝色、橙色代表三个不同的函数上下文。全局上下文执行有一个，它可以被其他上下文访问到。<br>你可以有任意数量的函数上下文，每个函数在调用时都会创建一个新的上下文，它是一个私有范围，函数内部声明的所有东西都不能在函数作用域外访问到。<br>上面的例子中，函数内部可以访问当前上下文之外声明的变量，但是外部却不能访问函数内部的变量/函数。这到底是为什么？其中的代码是如何执行的？</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>浏览器中的 JavaScript 解释器是单线程实现的。这意味着在浏览器中一次只能做一件事情。而其他的行为或事件都会在执行栈中排队等待。如图：<br><img src="/2023/03/15/javascript中的执行上下文和调用栈/2.image" alt="img"><br>我们知道，当浏览器第一次加载脚本时，默认情况下，它会进入全局上下文。如果在全局代码中调用了一个函数，则代码的执行会进入函数中，此时会创建一个新的执行上下文，它会被推到执行上下文栈中。<br>如果在这个过程中函数内部调用了另一个函数，会发生同样的事情，代码的执行会进入函数中，然后创建一个新的执行上下文，它会被推到上下文栈 的顶部。浏览器始终执行栈顶部的执行上下文。<br>一旦函数完成执行，当前的执行上下文将从栈的顶部弹出，然后继续执行下面的，下面程序演示了一个递归函数的执行上下文情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function foo(i) &#123;</span><br><span class="line">    if (i === 3) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        foo(++i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(0));</span><br></pre></td></tr></table></figure></p><p><img src="/2023/03/15/javascript中的执行上下文和调用栈/3.image" alt="img"><br>自己调用自己三次，每次将 i 递增 1，每次函数 foo 被调用的时候，就会创建一个新的执行上下文。一旦当前上下文执行完毕之后，它就会从栈中弹出并转移到下面的上下文中，直到全局上下。</p><p>执行上下文栈的 5 个关键点：</p><ul><li>单线程</li><li>同步执行</li><li>只有一个全局上下文</li><li>任意数量的函数上下文</li><li>每个函数调用都会创建一个新的执行上下文，包括自己调用自己</li></ul><h2 id="详解执行上下文"><a href="#详解执行上下文" class="headerlink" title="详解执行上下文"></a>详解执行上下文</h2><p>到此，我们知道每次调用一个函数时，都会创建一个新的执行上下文。但是在 JavaScript 解释器中，每次调用执行上下文会有两个阶段：<br>1.创建阶段</p><ul><li>创建作用域链</li><li>创建变量，函数，arguments列表。</li><li>确定 this 的指向</li></ul><p>2.执行阶段</p><ul><li>赋值，寻找函数引用，解释/执行代码</li></ul><p>执行上下文可以抽象为一个对象它具备三个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    &apos;scopeChain&apos;: &#123; /* variableObject + all parent execution context&apos;s variableObject */ &#125;,</span><br><span class="line">    &apos;variableObject&apos;: &#123; /* function arguments / parameters, inner variable and function declarations */&#125;,</span><br><span class="line">    &apos;this&apos;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="活动-变量对象-AO-VO"><a href="#活动-变量对象-AO-VO" class="headerlink" title="活动/变量对象[AO/VO]"></a>活动/变量对象[AO/VO]</h2><p>executionContextObj 对象在函数调用时创建，但它是在函数真正执行之前就创建的，这就是我们所说的第一个阶段 创建阶段，此时解释器通过扫描函数的传入参数，arguments，本地函数声明，局部变量声明来创建executionContextObj 对象。将结果变成 variableObject 放入 executionContextObj 中。</p><p>解释器执行代码时的大致描述：<br>1.调用函数<br>2.在执行代码时，创建执行上下文<br>3.进入创建阶段</p><ul><li>初始化作用域链</li><li>创建变量对象（variableObject）</li><li>创建参数对象（arguments object），检查参数的上下文，初始化名称和值，并创建引用副本</li><li>扫描上下文中的函数声明</li><li>每发现一个函数，就会在 variableObject 中创建一个名称，保存函数的引用</li><li>如果名称已经存在，则覆盖引用</li><li>扫描上下文中的变量声明</li><li>每发现一个变量，就在 variableObject 中创建一个名称，并初始化值为 undefined</li><li>如果变量名已经存在，什么都不做，继续扫描</li><li>确定上下文中的 this 指向</li></ul><p>4.执行代码阶段</p><ul><li>在上下文中执行/解释代码，在代码逐行执行时进行变量复赋值</li></ul><p>让我们看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(i) &#123;</span><br><span class="line">    var a = &apos;hello&apos;;</span><br><span class="line">    var b = function privateB() &#123;&#125;;</span><br><span class="line">    function c() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(22);</span><br></pre></td></tr></table></figure></p><p>foo(22) 函数执行的时候，创建阶段如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 22,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 22,</span><br><span class="line">        c: pointer to function c()</span><br><span class="line">        a: undefined,</span><br><span class="line">        b: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    this: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所述，除了形参 i 和 arguments外，在创建阶段我们只把变量进行声明而不进行赋值。<br>在创建阶段完成后，程序会进入函数中执行代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 22,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 22,</span><br><span class="line">        c: pointer to function c()</span><br><span class="line">        a: &apos;hello&apos;,</span><br><span class="line">        b: pointer to function privateB()</span><br><span class="line">    &#125;,</span><br><span class="line">    this: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h2><p>网上很多关于声明提前的内容，它是用来解释变量和函数在声明时会被提前到作用域的顶部。但是并没有人详细解释为什么会发生这种情况，有了刚才关于解释器如何创建活动对象（AO）的认知，我们将很容易看出原因。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    console.log(typeof foo); // function pointer</span><br><span class="line">    console.log(typeof bar); // undefined</span><br><span class="line">    var foo = &apos;hello&apos;,</span><br><span class="line">        bar = function() &#123;</span><br><span class="line">            return &apos;world&apos;;</span><br><span class="line">        &#125;;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return &apos;hello&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></p><p>我们现在可以回答如下问题：<br>为什么我们可以在声明之前访问foo？<br>在执行阶段之前，我们已经完成了创建阶段，此时变量/函数已经被创建，所以当函数执行的时候 foo 可以被访问到。<br>foo 被声明了两次，为什么 foo 显示的是 function 而不是 undefined 或者 string？<br>虽然 foo 被声明了两次，但是我们在创建阶段中说到，函数是在变量之前创建在变量对象中，当变量对象中名称已经存在时，变量声明什么也不做。<br>因此 foo 会被先创建为函数 function foo() 的引用，当执行到 var foo时发现变量对象中已将存在了，所以此时什么也不做，而是继续扫描。<br>为什么 bar 是 undefined？<br>bar 实际上是一个变量只不过它的值是函数，而变量在创建阶段的值为 undefined。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们再来梳理下重要的知识点：</p><ul><li>首先在程序执行时会创建一个全局的执行上下文，有且只有一个。</li><li>函数在每次调用时就会创建一个函数上下文，可以有很多。</li><li>函数上下文可以访问全局上下文的内容，反之则不行。</li><li>创建的上下文会被推入到上下文栈中，然后从顶部开始依次执行。</li><li>执行上下文会分为两个阶段：创建阶段和执行阶段。</li><li>创建阶段会先进行函数声明和变量声明提前。</li><li>创建阶段会先进行函数声明，然后进行变量声明，同时会被放入变量对象中，如果变量对象中已经存在：函数则进行引用的覆盖，变量则什么都不做。</li><li>执行阶段才会进行赋值和运行。</li></ul><p>希望你已经理解了 JavaScript 解释器是如何执行你的代码的。理解执行上下文和 执行上下文栈能够让你清楚的知道你的代码为什么和预期的值不一样。<br>你认为了解，解释器的内部原理是多余还是必须的知识？它是否能够帮助你更好的编写 JavaScript 代码？欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript中你必须理解的执行上下文和调用栈&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>for循环中var与let深入理解</title>
    <link href="/2023/03/15/for%E5%BE%AA%E7%8E%AF%E4%B8%ADvar%E4%B8%8Elet%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>/2023/03/15/for循环中var与let深入理解/</id>
    <published>2023-03-15T06:32:29.000Z</published>
    <updated>2023-03-15T06:53:14.739Z</updated>
    
    <content type="html"><![CDATA[<p>for循环中var与let作用域不同的原理<br><a id="more"></a></p><h2 id="for中的var和let的使用"><a href="#for中的var和let的使用" class="headerlink" title="for中的var和let的使用"></a>for中的var和let的使用</h2><h3 id="var使用"><a href="#var使用" class="headerlink" title="var使用"></a>var使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用var声明，得到3个3</span><br><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[0](); //3</span><br><span class="line">a[1](); //3</span><br><span class="line">a[2](); //3</span><br></pre></td></tr></table></figure><h3 id="let使用"><a href="#let使用" class="headerlink" title="let使用"></a>let使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用let声明，得到0,1,2</span><br><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[0](); //0</span><br><span class="line">a[1](); //1</span><br><span class="line">a[2](); //2</span><br></pre></td></tr></table></figure><h2 id="for循环的展开"><a href="#for循环的展开" class="headerlink" title="for循环的展开"></a>for循环的展开</h2><p>for循序的执行顺序是这样的：设置循环变量(var i = 0)  ==&gt; 循环判断(i&lt;3)  ==&gt; 满足执行循环体 ==&gt; 循环变量自增(i++)</p><h3 id="var展开"><a href="#var展开" class="headerlink" title="var展开"></a>var展开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">&#123;</span><br><span class="line">  //我是父作用域</span><br><span class="line">  var i = 0;</span><br><span class="line">  if (0 &lt; 3) &#123;</span><br><span class="line">    a[0] = function () &#123;</span><br><span class="line">      //我是子作用域</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为1</span><br><span class="line">  if (1 &lt; 3) &#123;</span><br><span class="line">    a[1] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为2</span><br><span class="line">  if (2 &lt; 3) &#123;</span><br><span class="line">    a[2] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为3</span><br><span class="line">  // 跳出循环</span><br><span class="line">&#125;</span><br><span class="line">//调用N次指向都是最终的3</span><br><span class="line">a[0](); //3</span><br><span class="line">a[1](); //3</span><br><span class="line">a[2](); //3</span><br></pre></td></tr></table></figure><h3 id="let展开"><a href="#let展开" class="headerlink" title="let展开"></a>let展开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">&#123;</span><br><span class="line">  //我是父作用域</span><br><span class="line">  let i = 0;</span><br><span class="line">  if (0 &lt; 3) &#123;</span><br><span class="line">    a[0] = function () &#123;</span><br><span class="line">      //我是子作用域</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为1</span><br><span class="line">  if (1 &lt; 3) &#123;</span><br><span class="line">    a[1] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为2</span><br><span class="line">  if (2 &lt; 3) &#123;</span><br><span class="line">    a[2] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为3</span><br><span class="line">  // 跳出循环</span><br><span class="line">&#125;</span><br><span class="line">//调用N次指向都是最终的3</span><br><span class="line">a[0](); //3</span><br><span class="line">a[1](); //3</span><br><span class="line">a[2](); //3</span><br></pre></td></tr></table></figure><blockquote><p>但是，let这样写的结果跟var是一样的。其实浏览器底层的实现跟上边的实现是不一样，详细情况不解释，只写最后实现代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var a = []; </span><br><span class="line">&#123;</span><br><span class="line">  //我是父作用域</span><br><span class="line">  let i = 0;</span><br><span class="line">  if (i &lt; 3) &#123;</span><br><span class="line">    //这一步模拟底层实现</span><br><span class="line">    let k = i;</span><br><span class="line">    a[k] = function () &#123;</span><br><span class="line">      //我是子作用域</span><br><span class="line">      console.log(k);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为1</span><br><span class="line">  if (i &lt; 3) &#123;</span><br><span class="line">    let k = i;</span><br><span class="line">    a[k] = function () &#123;</span><br><span class="line">      console.log(k);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为2</span><br><span class="line">  if (i &lt; 3) &#123;</span><br><span class="line">    let k = i;</span><br><span class="line">    a[k] = function () &#123;</span><br><span class="line">      console.log(k);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为3</span><br><span class="line">  // 跳出循环</span><br><span class="line">&#125;</span><br><span class="line">a[0](); //0</span><br><span class="line">a[1](); //1</span><br><span class="line">a[2](); //2</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.cnblogs.com/echolun/p/10584703.html" target="_blank" rel="noopener">参考-听风是风</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;for循环中var与let作用域不同的原理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>递归深入理解</title>
    <link href="/2023/01/09/%E9%80%92%E5%BD%92%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>/2023/01/09/递归深入理解/</id>
    <published>2023-01-09T02:46:19.000Z</published>
    <updated>2023-01-11T06:08:35.997Z</updated>
    
    <content type="html"><![CDATA[<p>深入的理解递归算法<br><a id="more"></a><br>【<a href="/2019/07/02/js中的递归总结/">递归浅析</a>】这篇文章简单的介绍了递归算法，本编会对递归进行深入的理解。</p><h2 id="递归原理"><a href="#递归原理" class="headerlink" title="递归原理"></a>递归原理</h2><h3 id="什么是递归，它是如何工作的？"><a href="#什么是递归，它是如何工作的？" class="headerlink" title="什么是递归，它是如何工作的？"></a>什么是递归，它是如何工作的？</h3><blockquote><p>递归(recursion)是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。<br>简单说程序调用自身的编程技巧叫递归。递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。</p></blockquote><p>使用递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含2个属性：</p><ul><li>基本情况（bottom cases），基本情况用于保证程序调用及时返回，不在继续递归，保证了程序可终止。</li><li>递推关系（recurrentce relation），可将所有其他情况拆分到基本案例。</li></ul><p>简单的示例：以相反的顺序打印字符串。<br>可以使用迭代的办法轻而易举地解决这个问题，即从字符串的最后一个字符开始遍历字符串。但是如何递归地解决它呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  helper(<span class="number">0</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">index, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!str || index&gt;str.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  helper(index+<span class="number">1</span>, str);</span><br><span class="line">  <span class="built_in">console</span>.log(str[index]);</span><br><span class="line">&#125;</span><br><span class="line">printReverse(<span class="string">'abcdefg'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="递归的程序特征"><a href="#递归的程序特征" class="headerlink" title="递归的程序特征"></a>递归的程序特征</h3><p>优雅性</p><blockquote><p>相比其他解法（比如迭代法），使用递归法，会发现只需少量程序就可描述出解题过程，大大减少了程序的代码量，而且很好理解。递归的能力在于用有限的语句来定义对象的无限集合。</p></blockquote><p>反向性</p><blockquote><p>由于递归调用程序需要维护调用栈，而栈具有后进先出的特征，因此递归程序适合满足取反类需求。</p></blockquote><p>递推关系</p><blockquote><p>递归程序可以较明显的发现递推关系，反过来也可以这么说，具有递推关系的问题基本都可以通过递归求解（当然也许有性能更佳的解法，但递归绝对是一种选择）。递推关系常见问题有杨辉三角、阶乘计算等。</p></blockquote><h3 id="什么时候考虑递归"><a href="#什么时候考虑递归" class="headerlink" title="什么时候考虑递归"></a>什么时候考虑递归</h3><p>具有以下特征的问题可考虑递归求解：</p><ul><li>当问题和子问题具有递推关系，比如杨辉三角、计算阶乘。</li><li>具有递归性质的数据结构，比如链表、树、图。</li><li>反向性问题，比如取反。</li></ul><p>总结下来，最根本的还是要抓住问题本身是否可以通过层层拆解到最小粒度来得解。</p><h2 id="递归的递推性质"><a href="#递归的递推性质" class="headerlink" title="递归的递推性质"></a>递归的递推性质</h2><p>上一节说了，在实现递归函数之前，需要弄明白2件事：</p><ul><li>​递推关系​： 一个问题的结果与其子问题的结果之间的关系。</li><li>​基本情况​: 不需要进一步的递归调用就可以直接计算答案的情况。 它们往往是问题被减少到最小规模的情况，也就是如果将问题划分为子问题是一种自上而下的方式的最下层。</li></ul><p>一旦计算出以上两个元素，再想要实现一个递归函数，就只需要根据​递推关系​调用函数本身，直到其抵达​基本情况​。<br>为了解释以上几点，来看一个经典问题：杨辉三角（也叫帕斯卡三角）。</p><h3 id="帕斯卡三角"><a href="#帕斯卡三角" class="headerlink" title="帕斯卡三角"></a>帕斯卡三角</h3><blockquote><p>帕斯卡三角形是排列成三角形的一系列数字。 在帕斯卡三角形中，每一行的最左边和最右边的数字总是 <code>1</code>。 对于其余的每个数字都是前一行中直接位于它上面的两个数字之和。</p></blockquote><p>下面的插图给出了一个 <code>5</code> 行的帕斯卡三角：<br><img src="/2023/01/09/递归深入理解/1.gif" alt="img"></p><h4 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h4><p>从帕斯卡三角形内的递推关系开始。<br>首先，定义一个函数 <code>f(i,j)</code>，它将会返回帕斯卡三角形​第 <code>i</code> 行​、​第 <code>j</code> 列​的数字。<br>可以用下面的公式来表示这一递推关系：<br><code>f(i,j)=f(i−1,j−1)+f(i−1,j)</code></p><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>可以看到，每行的最左边和最右边的数字是​基本情况​，在这个问题中，它总是等于 1。<br>因此，可以将基本情况定义如下:<br><code>f(i,j)=1wherej=1orj=i</code></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>一旦定义了 ​递推关系​ 和 ​基本情况​，递归函数的实现变得更加直观，特别是在用数学公式表示出这两个元素之后。<br>下面给出一个例子，展示如何用这个公式递归地计算 <code>f(5,3)</code>, 也就是 帕斯卡三角形​第 <code>5</code> 行​中的​第 <code>3</code> 个​数。<br><img src="/2023/01/09/递归深入理解/2.gif" alt="img"><br>可以将 <code>f(5,3)</code> 分解为 <code>f(5,3)=f(4,2)+f(4,3)</code>，然后递归地调用 <code>f(4,2)</code> 和 <code>f(4,3)</code>：<br>对于调用的 <code>f(4,2)</code>，可以进一步展开它，直到到达基本情况，正如下面所描述的：<br><code>f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3</code><br>对于调用的 <code>f(4,3)</code>，类似地，可以将其分解为：<br><code>f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3</code><br>最后，结合上述子问题的结果：<br><code>f(5,3)=f(4,2)+f(4,3)=3+3=6</code><br>可能已经注意到递归解决方案可能会导致一些重复的计算，​例如​，重复计算相同的中间数以获得最后一行中的数字。 举例说明，为了得到 <code>f(5,3)</code> 的结果，在 <code>f(4,2)</code> 和 <code>f(4,3)</code> 的调用中计算了 <code>f(3,2)</code> 两次，这样重复计算效率肯定不高，下一节会给出优化方案来避免重复计算（即记忆术）。</p><h2 id="递归复杂性分析"><a href="#递归复杂性分析" class="headerlink" title="递归复杂性分析"></a>递归复杂性分析</h2><h3 id="递归时间复杂度计算"><a href="#递归时间复杂度计算" class="headerlink" title="递归时间复杂度计算"></a>递归时间复杂度计算</h3><p>给出一个递归算法，其时间复杂度 <code>O(T)</code> 通常是递归调用的数量（记作 <code>R</code>）和计算的时间复杂度的乘积（表示为 <code>O(s)</code>）的乘积：<br><code>O(T)=R∗O(s)</code></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在反转字符串问题中，需要以相反的顺序打印字符串，解决问题的递归关系可以表示如下：<br><code>​printReverse(str) = printReverse(str[1...n]) + print(str[0])</code><br>​其中 <code>​str[1...n]</code>​ 是输入字符串 ​str​ 的子串，仅不含前导字符 ​<code>str[0]​</code>。<br>该函数将被递归调用 n 次，其中 n 是输入字符串的大小。在每次递归结束时，只是打印前导字符，因此该特定操作的时间复杂度是恒定的，即 <code>O(1)</code>。<br>总而言之，递归函数 <code>​printReverse(str)</code>​ 的总体时间复杂度为 <code>O(printReverse)=n∗O(1)=O(n)</code>。</p><h4 id="执行树分析递归调用数量"><a href="#执行树分析递归调用数量" class="headerlink" title="执行树分析递归调用数量"></a>执行树分析递归调用数量</h4><p>在分析递归的时间复杂度时，递归调用的数量不一定和N成线性关系，比如斐波那契数的计算（见第五部分），其递推关系被定义为​<code>f(n) = f(n-1) + f(n-2)</code>​。乍一看，在执行斐波那契函数期间计算递归调用的数量似乎并不简单。<br>执行树定义</p><blockquote><p>执行树是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。</p></blockquote><p>递归函数的执行树将形成 <code>​n</code> 叉树​，其中 ​<code>n</code>​ 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 <code>​f(4)</code>​ 的执行树。<br><img src="/2023/01/09/递归深入理解/3.webp" alt="img"><br>在 n 层的完全二叉树中，节点的总数为 <code>2n−1</code>。因此 <code>​f(n)</code>​ 中递归数目的上限（尽管不严格）也是 <code>2n−1</code>。那么我们可以估计 ​<code>f(n)</code>​ 的时间复杂度为 <code>O(2n)</code>。</p><h3 id="递归空间复杂性分析"><a href="#递归空间复杂性分析" class="headerlink" title="递归空间复杂性分析"></a>递归空间复杂性分析</h3><p>在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：递归相关空间（​recursion related space）和非递归相关空间​（​non-recursion related space​）。</p><h4 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h4><p>递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。为了完成典型的函数调用，系统应该在栈中分配一些空间来保存三个重要信息：</p><ul><li>函数调用的返回地址。一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点。</li><li>传递给函数调用的参数。</li><li>函数调用中的局部变量。</li></ul><p>栈中的这个空间是函数调用期间产生的最小成本。然而，一旦完成函数调用，就会释放该空间。<br>对于递归算法，函数调用将连续链接直到它们到达基本情况（也称为 底层情况）。这意味着用于每个函数调用的空间也会累积。<br>对于递归算法，如果没有产生其他内存消耗，则此递归引起的空间将是算法的空间上限。<br>例如，在本文一开始提到了反转字符串示例中，没有使用额外的内存，因为仅仅是打印一个字符。对于每个递归调用，假设它可能需要一个最大为某一常量值的空间。并且递归调用最多可以链接 <code>​n</code>​ 次，其中 ​<code>n</code>​ 是输入字符串的大小。因此，该递归算法的空间复杂度就是 <code>O(n)</code>。<br>为了更好地说明这一点，接下来将会展示递归调用​ <code>f(x1) -&gt; f(x2) -&gt; f(x3)</code>​ 的执行顺序以及栈空间的分配情况。<br><img src="/2023/01/09/递归深入理解/4.webp" alt="img"><br>栈中的空间将会分配给 ​<code>f(x1)</code>​ 来调用 ​<code>f(x2)</code>​。类似的情况也同样发生在 <code>​f(x2)</code>​ 中，系统会为 <code>​f(x3)</code> 的调用分配另一个空间，最后在​ ​<code>f(x3)</code>​ 中，我们到达基本情况，因此在 ​<code>f(x3)</code>​ 中没有进行进一步的递归调用。<br>正是由于这些与递归相关的空间消耗，有时可能会遇到称为堆栈溢出的情况，其中为程序分配的堆栈达到其最大空间限制并导致程序最终失败。在设计递归算法时，应该仔细评估在输入规模扩大时是否存在堆栈溢出的可能性，栈溢出是非常容易出错的点，在下一节将讨论优化策略。</p><h4 id="非递归相关空间"><a href="#非递归相关空间" class="headerlink" title="非递归相关空间"></a>非递归相关空间</h4><p>正如名称所示，非递归相关空间指的是与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间（通常在堆中）。<br>不管是否递归，都可能需要在任何函数调用之前将问题的输入存储为全局变量。可能还需要保存递归调用的中间结果（也就是即将讨论的记忆化技术）。例如，在使用带有记忆化技术的递归算法解决斐波那契数问题时,使用映射<code>（map）</code>来跟踪在递归调用期间产生的所有中间斐波那契数。因此，在分析空间复杂度时，应该考虑到因采用记忆化技术所导致的空间成本。</p><h2 id="递归的优化策略"><a href="#递归的优化策略" class="headerlink" title="递归的优化策略"></a>递归的优化策略</h2><h3 id="时间优化策略：记忆化"><a href="#时间优化策略：记忆化" class="headerlink" title="时间优化策略：记忆化"></a>时间优化策略：记忆化</h3><p>递归是一种直观而有效的实现算法的方法。 但是，如果不明智地使用它，可能会给性能带来一些不希望的损失，例如重复计算。 在前面提到了帕斯卡三角的重复计算问题，其中一些中间结果被多次计算。<br>在本文中，将进一步研究递归可能出现的重复计算问题。 然后将提出一种常用的技术，称为​记忆化（memoization）​，可以用来避免这个问题。<br>为了演示重复计算的另一个问题，看一个大多数人可能都很熟悉的例子，斐波那契数。 如果定义函数 <code>​F(n)</code>​ 表示在索引 <code>​n</code>​ 处的斐波那契数，那么可以推导出如下的递推关系：<br>​<code>F(n) = F(n - 1) + F(n - 2)</code>​<br>基本情况：<br>​<code>F(0) = 0, F(1) = 1</code><br>​根据斐波那契数列的定义，可以实现下面的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，如果想知道 ​<code>F(4)</code>​ 是多少，可以应用上面的公式并进行展开：<br>​<code>F(4) = F(3) + F(2) = (F(2) + F(1)) + F(2)</code><br>为了得到 <code>f(4)</code> 的结果，需要在上述推导之后计算两次数 <code>​F(2)</code>​ : 第一次在 <code>​F(4)</code>​ 的第一次展开中，第二次在中间结果 ​<code>F(3)</code>​ 中。<br>下面的树显示了在计算 ​<code>F(4)</code>​ 时发生的所有重复计算（按颜色分组）。<br><img src="/2023/01/09/递归深入理解/5.webp" alt="img"><br>为了消除上述情况中的重复计算，正如许多人已经指出的那样，其中一个想法是将中间结果存储在缓存中，以便以后可以重用它们，而不需要重新计算。<br>这个想法也被称为记忆化，这是一种经常与递归一起使用的技术。​<br><strong>记忆化定义</strong></p><blockquote><p>记忆化是一种优化技术，主要用于加快计算机程序的速度，方法是存储昂贵的函数调用的结果，并在相同的输入再次出现时返回缓存的结果。</p></blockquote><p>回到斐波那契函数 <code>​F(n)</code>​。 可以使用哈希表来跟踪每个以 ​<code>n​</code> 为键的 <code>​F(n)</code>​ 的结果。 散列表作为一个缓存，可以避免重复计算。 记忆化技术是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。<br>为了便于比较，下面提供了带有记忆化功能的斐波那契数列解决方案的实现。<br>作为一种练习，可以尝试使记忆化更加通用和非侵入性，即应用记忆化技术而不改变原来的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cache.has(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    result = n;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    result = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  cache.set(n, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>斐波那契数应用的一个经典问题是爬楼梯，在第五节再分析。<br>通过记忆化技术，保存每个索引 <code>​n</code>​ 对应的的斐波那契数的结果。确信每个斐波那契数的计算只会发生一次。而从递推关系来看，斐波纳契数 ​<code>f(n)</code>​ 将取决于其所有 <code>​n-1</code>​ 个先验斐波纳契数。结果，计算 <code>​f(n)</code>​ 的递归将被调用 ​<code>n-1</code>​ 次以计算它所依赖的所有先验数字。<br>现在，可以计算一下采用了记忆化技术优化后的时间复杂度，即 <code>O(1)∗n=O(n)</code>。可以得出记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。</p><h3 id="空间优化策略：尾递归"><a href="#空间优化策略：尾递归" class="headerlink" title="空间优化策略：尾递归"></a>空间优化策略：尾递归</h3><p>上一节讨论了递归空间复杂性分析话题，从中了解到递归调用在系统调用栈上会产生额外空间，如果递归调用层级很深，程序执行过程中很可能导致栈溢出。针对这种情况，有一种称为尾递归的特殊递归，它可以控制递归导致空间开销的影响。<br><strong>尾递归定义</strong></p><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。</p></blockquote><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）。<br>第五部分将看到尾递归优化阶乘运算的例子。</p><h2 id="采用递归解法的几个经典问题"><a href="#采用递归解法的几个经典问题" class="headerlink" title="采用递归解法的几个经典问题"></a>采用递归解法的几个经典问题</h2><blockquote><p>递归在递推关系的数学问题上应用广泛，使用递归法可以解决很多趣味问题，下面来看看都有哪些经典问题。</p></blockquote><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 ​<code>char[]</code>​ 的形式给出。<br>不要给另外的数组分配额外的空间，必须原地修改输入数组、使用 <code>O(1)</code> 的额外空间解决这一问题。<br>可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入：[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line">输出：[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入：[<span class="string">"H"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"h"</span>]</span><br><span class="line">输出：[<span class="string">"h"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"H"</span>]</span><br></pre></td></tr></table></figure></p><p>分析：此问题是根据递归调用栈的特性做后进先出反转。<br>code:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">arrStr</span>) </span>&#123;</span><br><span class="line">  help(arrStr, <span class="number">0</span>, arrStr.length<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> arrStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">arrStr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">let</span> temp = arrStr[left];</span><br><span class="line">      arrStr[left] = arrStr[right];</span><br><span class="line">      arrStr[right] = temp;</span><br><span class="line">  help(arrStr, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">reverseString([<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'0'</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="comment">// 你应该返回</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link5 = &#123;<span class="attr">val</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="number">5</span>, <span class="attr">next</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> link4 = &#123;<span class="attr">val</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="number">4</span>, <span class="attr">next</span>: link5&#125;;</span><br><span class="line"><span class="keyword">const</span> link3 = &#123;<span class="attr">val</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="number">3</span>, <span class="attr">next</span>: link4&#125;;</span><br><span class="line"><span class="keyword">const</span> link2 = &#123;<span class="attr">val</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="number">2</span>, <span class="attr">next</span>: link3&#125;;</span><br><span class="line"><span class="keyword">const</span> link1 = &#123;<span class="attr">val</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">next</span>: link2&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapPairs</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> temp = head.val;</span><br><span class="line">  head.val = head.next.val;</span><br><span class="line">  head.next.val = temp;</span><br><span class="line">  swapPairs(head.next.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swapPairs(link1);</span><br><span class="line"><span class="built_in">console</span>.log(link1);</span><br><span class="line"><span class="built_in">console</span>.log(link2);</span><br><span class="line"><span class="built_in">console</span>.log(link3);</span><br><span class="line"><span class="built_in">console</span>.log(link4);</span><br><span class="line"><span class="built_in">console</span>.log(link5);</span><br></pre></td></tr></table></figure></p><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><img src="/2023/01/09/递归深入理解/1.gif" alt="img"><br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>分析：典型的具有递推关系的数据问题，注意通过记忆化优化。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = []; <span class="comment">// 缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传入数字不是整数，返回空数组</span></span><br><span class="line">  <span class="keyword">if</span>(numRows&lt;=<span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=numRows; i++) &#123;</span><br><span class="line">    arr[i<span class="number">-1</span>] = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">      arr[i<span class="number">-1</span>].push(makeNum(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNum</span>(<span class="params">row, column</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!cache[row]) &#123;</span><br><span class="line">    cache[row]=[];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有缓存，直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(cache[row][column]) <span class="keyword">return</span> cache[row][column]; </span><br><span class="line">  <span class="comment">// 这里是递归的基本情况</span></span><br><span class="line">  <span class="keyword">if</span>(row===column||column==<span class="number">1</span>) &#123;</span><br><span class="line">    cache[row][column] = <span class="number">1</span>; <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记忆化</span></span><br><span class="line">  cache[row][column] = makeNum(row<span class="number">-1</span>, column<span class="number">-1</span>) + makeNum(row<span class="number">-1</span>, column); </span><br><span class="line">  <span class="keyword">return</span> cache[row][column];</span><br><span class="line">&#125;</span><br><span class="line">generate(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数，通常用 ​<code>F(n)</code>​ 表示，形成的序列称为斐波那契数列。该数列由 ​<code>0</code>​ 和 <code>​1</code>​ 开始，后面的每一项数字都是前面两项数字的和。也就是：<br><code>F(0) = 0, F(1) = 1</code><br><code>F(N) = F(N - 1) + F(N - 2)</code>, 其中 <code>N &gt; 1</code><br>给定 ​<code>N</code>​，计算 ​<code>F(N)</code>​。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入：<span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：F(<span class="number">2</span>) = F(<span class="number">1</span>) + F(<span class="number">0</span>) = <span class="number">1</span> + <span class="number">0</span> = <span class="number">1.</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：F(<span class="number">3</span>) = F(<span class="number">2</span>) + F(<span class="number">1</span>) = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2.</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：F(<span class="number">4</span>) = F(<span class="number">3</span>) + F(<span class="number">2</span>) = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure></p><p>分析：递归考虑记忆化优化<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用记忆化版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">return</span> fib(num<span class="number">-1</span>) + fib(num<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">50</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用记忆化版本</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 记忆化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(cache.has(num)) <span class="keyword">return</span> cache.get(num);</span><br><span class="line">  <span class="keyword">let</span> result = fib(num<span class="number">-1</span>) + fib(num<span class="number">-2</span>);</span><br><span class="line">  cache.set(num, result);</span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面两个版本，一个做了记忆化，一个没有，求50的斐波那契数，没做记忆化的用浏览器运行直接卡死，而做了记忆化的瞬间出结果。</p></blockquote><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设爬楼梯。需要 <code>n</code> 阶才能到达楼顶。<br>每次可以爬 <code>1</code> 或 <code>2</code> 个台阶。有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 <code>n</code> 是一个正整数。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>) <span class="number">2</span> 阶</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3</span>) <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure></p><p>分析：该问题通过规律发现递推关系就是斐波那契数。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">stepNum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="keyword">return</span> help(stepNum, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">stepNum, cache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(stepNum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(cache[stepNum]) <span class="keyword">return</span> cache[stepNum];</span><br><span class="line">  <span class="keyword">if</span>(stepNum &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    cache[stepNum] = stepNum;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    cache[stepNum] = help(stepNum<span class="number">-1</span>, cache) + help(stepNum<span class="number">-2</span>, cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[stepNum];</span><br><span class="line">&#125;</span><br><span class="line">climbStairs(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binTree = &#123;</span><br><span class="line">  left: &#123;</span><br><span class="line">    left: &#123;</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: &#123; <span class="attr">left</span>: <span class="literal">null</span>, <span class="attr">right</span>: <span class="literal">null</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: &#123;</span><br><span class="line">      left: &#123;</span><br><span class="line">        left: <span class="literal">null</span>,</span><br><span class="line">        right: &#123;</span><br><span class="line">          left: &#123;</span><br><span class="line">            left: <span class="literal">null</span>,</span><br><span class="line">            right: &#123;</span><br><span class="line">              left: <span class="literal">null</span>,</span><br><span class="line">              right: &#123;</span><br><span class="line">                left: <span class="literal">null</span>,</span><br><span class="line">                right: <span class="literal">null</span>,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          right: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">返回的最大深度是<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>分析：二叉树是典型的具有递归属性的数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">binTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!binTree) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(!binTree.left &amp;&amp; !binTree.right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(binTree.left), maxDepth(binTree.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxDepth(binTree);</span><br></pre></td></tr></table></figure></p><h3 id="计算-x-的-n-次幂函数"><a href="#计算-x-的-n-次幂函数" class="headerlink" title="计算 x 的 n 次幂函数"></a>计算 x 的 n 次幂函数</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">输入: 2, 10</span><br><span class="line">输出: 1024</span><br><span class="line">// 2</span><br><span class="line">输入: 2.1, 3</span><br><span class="line">输出: 9.261</span><br></pre></td></tr></table></figure></p><p>说明：<br><code>-100.0 &lt; x &lt; 100.0</code><br><code>n</code> 是 <code>32</code> 位有符号整数，其数值范围是 <code>[−231, 231 − 1]</code><br>分析：n可能很大，需要防止栈溢出，可思考尾递归实现。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n&gt;<span class="number">0</span> ? help(x, n) : <span class="number">1</span>/help(x, -n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x * help(x, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">myPow(<span class="number">2</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><h3 id="第K个语法符号"><a href="#第K个语法符号" class="headerlink" title="第K个语法符号"></a>第K个语法符号</h3><p>在第一行写上一个<code>0</code>​。接下来的每一行，将前一行中的​<code>0</code>​替换为​<code>01</code>​，<code>​1</code>​替换为​<code>10</code>​。<br>给定行数<code>N</code>和序数<code>​K</code>​，返回第<code>​N</code>行中第<code>​K</code>​个字符。（<code>​K</code>​从<code>1</code>开始）<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入: N = <span class="number">1</span>, K = <span class="number">1</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入: N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">输入: N = <span class="number">2</span>, K = <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">输入: N = <span class="number">4</span>, K = <span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">第一行: <span class="number">0</span></span><br><span class="line">第二行: <span class="number">01</span></span><br><span class="line">第三行: <span class="number">0110</span></span><br><span class="line">第四行: <span class="number">0110100</span></span><br></pre></td></tr></table></figure></p><p>注意：<br>​N​ 的范围 ​[1, 30]​.<br>​K​ 的范围 ​[1, 2^(N-1)]​.<br>分析：识别具有递归关系问题<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNStr</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">return</span> getNStr(n<span class="number">-1</span>).replace(<span class="regexp">/0|1/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">'01'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'1'</span>) <span class="keyword">return</span> <span class="string">'10'</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKChar</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getNStr(n).charAt(k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getKChar(<span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，更加相信递归是一种强大的技术，它能够以一种优雅而有效的方式解决许多问题。同时，它也不是解决任务问题的灵丹妙药。由于时间或空间的限制，并不是所有的问题都可以用递归来解决。递归本身可能会带来一些不希望看到的副作用，如栈溢出。<br>有时，在解决实际问题时乍一看，并不清楚是否可以应用递归算法来解决问题。然而，由于递归的递推性质与所熟悉的数学非常接近，用数学公式来推导某些关系总是有帮助的，也就是说写出递推关系和基本情况是使用递归算法的前置条件。<br>只要有可能，就应用记忆化。在起草递归算法时，可以从最简单的策略开始。有时，在递归过程中，可能会出现重复计算的情况，例如斐波纳契数（Fibonacci）。在这种情况下，可以尝试应用 Memoization 技术，它将中间结果存储在缓存中供以后重用，它可以在空间复杂性上稍加折中，从而极大地提高时间复杂性，因为它可以避免代价较高的重复计算。<br>当堆栈溢出时，尾递归可能会有所帮助。<br>使用递归实现算法通常有几种方法。尾递归是实现递归的一种特殊形式。与记忆化技术不同的是，尾递归通过消除递归带来的堆栈开销，优化了算法的空间复杂度。更重要的是，有了尾递归，就可以避免经常伴随一般递归而来的堆栈溢出问题，而尾递归的另一个优点是，与非尾递归相比，尾部递归更容易阅读和理解。这是由于尾递归不存在调用后依赖（即递归调用是函数中的最后一个动作），这一点不同于非尾递归，因此，只要有可能，就应该尽量运用尾递归。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入的理解递归算法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="算法" scheme="/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-VUE模板编译概览</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-VUE%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%A6%82%E8%A7%88/"/>
    <id>/2023/01/04/前端编译原理-VUE模板编译概览/</id>
    <published>2023-01-04T09:01:05.000Z</published>
    <updated>2023-01-06T02:32:30.454Z</updated>
    
    <content type="html"><![CDATA[<p>VUE模板编译工作流程简介<br><a id="more"></a></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>VUE的模板是要被转换成js渲染函数，在运行时执行的。</p><h2 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h2><p><code>模板</code>-&gt;<code>parse(str)</code>-&gt;<code>模板AST</code>-&gt;<code>transform(ast)</code>-&gt;<code>javascript AST</code>-&gt;<code>generate(JSAST)</code>-&gt;<code>渲染函数</code></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><blockquote><p>词法分析是把字符串解析成tokens</p></blockquote><p>模板字符串转化后的tokens：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;div&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;text&apos;, content: &apos;Vue&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;text&apos;, content: &apos;Template&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;div&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>实现code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">const State = &#123;</span><br><span class="line">  initial: 1,</span><br><span class="line">  tagOpen: 2,</span><br><span class="line">  tagName: 3,</span><br><span class="line">  text: 4,</span><br><span class="line">  tagEnd: 5,</span><br><span class="line">  tagEndName: 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isAlpha(char) &#123;</span><br><span class="line">  return char &gt;= &apos;a&apos; &amp;&amp; char &lt;= &apos;z&apos; || char &gt;= &apos;A&apos; &amp;&amp; char &lt;= &apos;Z&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tokenize(str) &#123;</span><br><span class="line">  let currentState = State.initial</span><br><span class="line">  const chars = []</span><br><span class="line">  const tokens = []</span><br><span class="line">  while(str) &#123;</span><br><span class="line">    const char = str[0]</span><br><span class="line">    switch (currentState) &#123;</span><br><span class="line">      case State.initial:</span><br><span class="line">        if (char === &apos;&lt;&apos;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.text</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagOpen:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;/&apos;) &#123;</span><br><span class="line">          currentState = State.tagEnd</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&gt;&apos;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;tag&apos;,</span><br><span class="line">            name: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.text:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&lt;&apos;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;text&apos;,</span><br><span class="line">            content: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagEnd:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagEndName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagEndName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&gt;&apos;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;tagEnd&apos;,</span><br><span class="line">            name: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><blockquote><p>语法分析是把词法分析出来的tokens解析成AST</p></blockquote><p>模板AST：<br><a href="#模板AST">⬇⬇⬇</a><br>实现code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function parse(str) &#123;</span><br><span class="line">  const tokens = tokenize(str)</span><br><span class="line"></span><br><span class="line">  const root = &#123;</span><br><span class="line">    type: &apos;Root&apos;,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;</span><br><span class="line">  const elementStack = [root]</span><br><span class="line"></span><br><span class="line">  while (tokens.length) &#123;</span><br><span class="line">    const parent = elementStack[elementStack.length - 1]</span><br><span class="line">    const t = tokens[0]</span><br><span class="line">    switch (t.type) &#123;</span><br><span class="line">      case &apos;tag&apos;:</span><br><span class="line">        const elementNode = &#123;</span><br><span class="line">          type: &apos;Element&apos;,</span><br><span class="line">          tag: t.name,</span><br><span class="line">          children: []</span><br><span class="line">        &#125;</span><br><span class="line">        parent.children.push(elementNode)</span><br><span class="line">        elementStack.push(elementNode)</span><br><span class="line">        break</span><br><span class="line">      case &apos;text&apos;:</span><br><span class="line">        const textNode = &#123;</span><br><span class="line">          type: &apos;Text&apos;,</span><br><span class="line">          content: t.content</span><br><span class="line">        &#125;</span><br><span class="line">        parent.children.push(textNode)</span><br><span class="line">        break</span><br><span class="line">      case &apos;tagEnd&apos;:</span><br><span class="line">        elementStack.pop()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    tokens.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模板AST"><a href="#模板AST" class="headerlink" title="模板AST"></a>模板AST</h3><blockquote><p>通过parse步骤后得到的模板AST：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Root&quot;,</span><br><span class="line">  &quot;children&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">      &quot;tag&quot;: &quot;div&quot;,</span><br><span class="line">      &quot;children&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">          &quot;tag&quot;: &quot;p&quot;,</span><br><span class="line">          &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Text&quot;,</span><br><span class="line">              &quot;content&quot;: &quot;Vue&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">          &quot;tag&quot;: &quot;p&quot;,</span><br><span class="line">          &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Text&quot;,</span><br><span class="line">              &quot;content&quot;: &quot;Template&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><blockquote><p>将模板AST转换成javascript AST，此处使用了插件结构，处理转换节点的函数是单独出来的</p></blockquote><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function transform(ast) &#123;</span><br><span class="line">  const context = &#123;</span><br><span class="line">    currentNode: null,</span><br><span class="line">    parent: null,</span><br><span class="line">    replaceNode(node) &#123;</span><br><span class="line">      context.currentNode = node</span><br><span class="line">      context.parent.children[context.childIndex] = node</span><br><span class="line">    &#125;,</span><br><span class="line">    removeNode() &#123;</span><br><span class="line">      if (context.parent) &#123;</span><br><span class="line">        context.parent.children.splice(context.childIndex, 1)</span><br><span class="line">        context.currentNode = null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nodeTransforms: [</span><br><span class="line">      transformRoot,</span><br><span class="line">      transformElement,</span><br><span class="line">      transformText</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用 traverseNode 完成转换</span><br><span class="line">  traverseNode(ast, context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseNode(ast, context) &#123;</span><br><span class="line">  context.currentNode = ast</span><br><span class="line"></span><br><span class="line">  const exitFns = []</span><br><span class="line">  const transforms = context.nodeTransforms</span><br><span class="line">  for (let i = 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">    const onExit = transforms[i](context.currentNode, context)</span><br><span class="line">    if (onExit) &#123;</span><br><span class="line">      exitFns.push(onExit)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!context.currentNode) return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const children = context.currentNode.children</span><br><span class="line">  if (children) &#123;</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      context.parent = context.currentNode</span><br><span class="line">      context.childIndex = i</span><br><span class="line">      traverseNode(children[i], context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let i = exitFns.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    exitFns[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插件工具函数"><a href="#插件工具函数" class="headerlink" title="插件工具函数"></a>插件工具函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">function transformText(node) &#123;</span><br><span class="line">  if (node.type !== &apos;Text&apos;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node.jsNode = createStringLiteral(node.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function transformElement(node) &#123;</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    if (node.type !== &apos;Element&apos;) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const callExp = createCallExpression(&apos;h&apos;, [</span><br><span class="line">      createStringLiteral(node.tag)</span><br><span class="line">    ])</span><br><span class="line">    node.children.length === 1</span><br><span class="line">      ? callExp.arguments.push(node.children[0].jsNode)</span><br><span class="line">      : callExp.arguments.push(</span><br><span class="line">        createArrayExpression(node.children.map(c =&gt; c.jsNode))</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    node.jsNode = callExp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformRoot(node) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    if (node.type !== &apos;Root&apos;) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const vnodeJSAST = node.children[0].jsNode</span><br><span class="line"></span><br><span class="line">    node.jsNode = &#123;</span><br><span class="line">      type: &apos;FunctionDecl&apos;,</span><br><span class="line">      id: &#123; type: &apos;Identifier&apos;, name: &apos;render&apos; &#125;,</span><br><span class="line">      params: [],</span><br><span class="line">      body: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &apos;ReturnStatement&apos;,</span><br><span class="line">          return: vnodeJSAST</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createStringLiteral(value) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;StringLiteral&apos;,</span><br><span class="line">    value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createIdentifier(name) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;Identifier&apos;,</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createArrayExpression(elements) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;ArrayExpression&apos;,</span><br><span class="line">    elements</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCallExpression(callee, arguments) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;CallExpression&apos;,</span><br><span class="line">    callee: createIdentifier(callee),</span><br><span class="line">    arguments</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="javascript-AST"><a href="#javascript-AST" class="headerlink" title="javascript AST"></a>javascript AST</h3><blockquote><p>模板字符串经过转换后生成的javascript AST:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;FunctionDecl&quot;,</span><br><span class="line">  &quot;id&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;render&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;params&quot;: [],</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line">      &quot;return&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">        &quot;callee&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;arguments&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;div&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ArrayExpression&quot;,</span><br><span class="line">            &quot;elements&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">                &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;h&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;p&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;Vue&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">                &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;h&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;p&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;Template&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><blockquote><p>得到转换后的javascript AST后，生成渲染函数字符串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">function generate(node) &#123;</span><br><span class="line">  const context = &#123;</span><br><span class="line">    code: &apos;&apos;,</span><br><span class="line">    push(code) &#123;</span><br><span class="line">      context.code += code</span><br><span class="line">    &#125;,</span><br><span class="line">    currentIndent: 0,</span><br><span class="line">    newline() &#123;</span><br><span class="line">      context.code += &apos;\n&apos; + `  `.repeat(context.currentIndent)</span><br><span class="line">    &#125;,</span><br><span class="line">    indent() &#123;</span><br><span class="line">      context.currentIndent++</span><br><span class="line">      context.newline()</span><br><span class="line">    &#125;,</span><br><span class="line">    deIndent() &#123;</span><br><span class="line">      context.currentIndent--</span><br><span class="line">      context.newline()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  genNode(node, context)</span><br><span class="line"></span><br><span class="line">  return context.code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNode(node, context) &#123;</span><br><span class="line">  switch (node.type) &#123;</span><br><span class="line">    case &apos;FunctionDecl&apos;:</span><br><span class="line">      genFunctionDecl(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;ReturnStatement&apos;:</span><br><span class="line">      genReturnStatement(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;CallExpression&apos;:</span><br><span class="line">      genCallExpression(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;StringLiteral&apos;:</span><br><span class="line">      genStringLiteral(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;ArrayExpression&apos;:</span><br><span class="line">      genArrayExpression(node, context)</span><br><span class="line">      break</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genFunctionDecl(node, context) &#123;</span><br><span class="line">  const &#123; push, indent, deIndent &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`function $&#123;node.id.name&#125; `)</span><br><span class="line">  push(`(`)</span><br><span class="line">  genNodeList(node.params, context)</span><br><span class="line">  push(`) `)</span><br><span class="line">  push(`&#123;`)</span><br><span class="line">  indent()</span><br><span class="line"></span><br><span class="line">  node.body.forEach(n =&gt; genNode(n, context))</span><br><span class="line"></span><br><span class="line">  deIndent()</span><br><span class="line">  push(`&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNodeList(nodes, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    const node = nodes[i]</span><br><span class="line">    genNode(node, context)</span><br><span class="line">    if (i &lt; nodes.length - 1) &#123;</span><br><span class="line">      push(&apos;, &apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genReturnStatement(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`return `)</span><br><span class="line">  genNode(node.return, context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genCallExpression(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  const &#123; callee, arguments: args &#125; = node</span><br><span class="line">  push(`$&#123;callee.name&#125;(`)</span><br><span class="line">  genNodeList(args, context)</span><br><span class="line">  push(`)`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genStringLiteral(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`&apos;$&#123;node.value&#125;&apos;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genArrayExpression(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  push(&apos;[&apos;)</span><br><span class="line">  genNodeList(node.elements, context)</span><br><span class="line">  push(&apos;]&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><blockquote><p>经过transform转换后生成的渲染函数字符串：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function render () &#123;</span><br><span class="line">  return h(&apos;div&apos;, [h(&apos;p&apos;, &apos;Vue&apos;), h(&apos;p&apos;, &apos;Template&apos;)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function compile(template) &#123;</span><br><span class="line">  // 模板AST</span><br><span class="line">  const ast = parse(template);</span><br><span class="line">  // 将模板AST转换为javascript AST</span><br><span class="line">  transform(ast);</span><br><span class="line">  // 代码生成</span><br><span class="line">  const code = generate(ast.jsNode);</span><br><span class="line"></span><br><span class="line">  return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本篇内容摘取《VUE设计与实现》的第15章，简单的介绍了前端模板的编译解析步骤。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/VUE%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">本篇code</a><br><a href="https://github.com/HcySunYang/code-for-vue-3-book" target="_blank" rel="noopener">VUE设计与实现code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VUE模板编译工作流程简介&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-有限状态机</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>/2023/01/04/前端编译原理-有限状态机/</id>
    <published>2023-01-04T03:34:48.000Z</published>
    <updated>2023-01-04T07:01:49.030Z</updated>
    
    <content type="html"><![CDATA[<p>有限状态机在词法分析中的应用<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。</p></blockquote><p>有限状态机在计算机领域的应用非常多，本篇文章主要介绍下在词法解析方面的应用。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>将字符串<br><code>100+200-300</code><br>转化成如下tokens<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;100&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Punctuator&apos;, value: &apos;+&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;200&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Punctuator&apos;, value: &apos;-&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;300&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 四则运算字符串</span><br><span class="line">const inputStr = &apos;100+200-300&apos;;</span><br><span class="line"></span><br><span class="line">// 匹配数字的正则</span><br><span class="line">const NumReg = /[0-9]/</span><br><span class="line">// 匹配标点符号的正则规则</span><br><span class="line">const PunctuatorReg = /[\+\-\*\/]/</span><br><span class="line"></span><br><span class="line">// 最终输出的所有tokens合集</span><br><span class="line">const tokens = []</span><br><span class="line"></span><br><span class="line">// 当前状态机中正在处理的token</span><br><span class="line">let currentToken = &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 词法分析函数</span><br><span class="line"> * @param &#123;*&#125; inputStr </span><br><span class="line"> * @returns tokens</span><br><span class="line"> */</span><br><span class="line">function stateMachine(inputStr) &#123;</span><br><span class="line">  // 定义状态机的初始状态判断函数</span><br><span class="line">  let state = start</span><br><span class="line">  // 依次迭代输入的字符串</span><br><span class="line">  // while(inputStr) &#123;</span><br><span class="line">  //   state = state(inputStr[0]);</span><br><span class="line">  //   inputStr = inputStr.slice(1);</span><br><span class="line">  // &#125;</span><br><span class="line">  inputStr.split(&quot;&quot;).forEach(char =&gt; &#123;</span><br><span class="line">      // 此处的char是每一个字符</span><br><span class="line">      // 调用state函数 并且传入char</span><br><span class="line">      state = state(char)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 遍历结束后仍然需要发送一次最后</span><br><span class="line">  tokens.push(currentToken)</span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 状态机初始函数</span><br><span class="line"> * @param &#123;*&#125; char 输入的字符</span><br><span class="line"> * @return &#123;*&#125; </span><br><span class="line"> */</span><br><span class="line">function start (char) &#123;</span><br><span class="line">  if(NumReg.test(char)) &#123;</span><br><span class="line">      // 首个输入的char是数字 初始化token为numeric</span><br><span class="line">      currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125;</span><br><span class="line">      // 返回的是一个nunmer的处理函数</span><br><span class="line">      return numeric</span><br><span class="line">  &#125;else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">      // 首个输入的char是标点符号 初始化current为punctuator</span><br><span class="line">      currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">      // 返回的是一个punctuator的处理函数</span><br><span class="line">      return punctuator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数字处理函数</span><br><span class="line">function numeric(char) &#123;</span><br><span class="line">  if(NumReg.test(char)) &#123;</span><br><span class="line">      // 如果当前输入是数字 不分词 连续累加value值</span><br><span class="line">      currentToken.value += char</span><br><span class="line">      // 返回numeric函数赋给state</span><br><span class="line">      return numeric</span><br><span class="line">  &#125;else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">      // 如果是标点符号 分词</span><br><span class="line">      // 如果当前输入的标点符号 进行分词</span><br><span class="line">      // 首先将旧的token输入到tokens中</span><br><span class="line">      emitToken(currentToken)</span><br><span class="line">      // 修改当前token</span><br><span class="line">      currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">      // 返回punctuator处理函数</span><br><span class="line">      return punctuator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标点符号状态处理函数</span><br><span class="line">function punctuator(char) &#123;</span><br><span class="line">  // 无论如何都要发射 因为标点符号在分词阶段不会被拼接起来</span><br><span class="line">  emitToken(currentToken)</span><br><span class="line">  if (NumReg.test(char)) &#123;</span><br><span class="line">    currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125;</span><br><span class="line">    return numeric</span><br><span class="line">  &#125; else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">    currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">    return punctuator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return punctuator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将token放入tokens中</span><br><span class="line">function emitToken(token) &#123;</span><br><span class="line">  // 重制 currentToken</span><br><span class="line">  currentToken = &#123; type: &apos;&apos;, value: &apos;&apos; &#125;</span><br><span class="line">  // 将上一次传入的token参数保存到最终输入的tokens中</span><br><span class="line">  tokens.push(token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(stateMachine(inputStr));</span><br></pre></td></tr></table></figure><h3 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 四则运算字符串</span><br><span class="line">const inputStr = &apos;100+200-300&apos;;</span><br><span class="line">// 匹配数字的正则</span><br><span class="line">const NumReg = /[0-9]/</span><br><span class="line">// 匹配标点符号的正则规则</span><br><span class="line">const PunctuatorReg = /[\+\-\*\/]/</span><br><span class="line">// 最终输出的所有tokens合集</span><br><span class="line">const tokens = []</span><br><span class="line">// 当前状态机中正在处理的token</span><br><span class="line">let currentToken = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">let type = &apos;start&apos;;</span><br><span class="line">function start(char, i, str) &#123;</span><br><span class="line">  if( type===&apos;start&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    type = &apos;Numberic&apos;;</span><br><span class="line">    currentToken += char;</span><br><span class="line">  &#125;else if(type===&apos;Numberic&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    currentToken += char;</span><br><span class="line">  &#125;else if(type===&apos;Numberic&apos;&amp;&amp;PunctuatorReg.test(char)) &#123;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Numberic&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    type = &apos;Punctuator&apos;;</span><br><span class="line">    currentToken = char;</span><br><span class="line">  &#125;else if(type===&apos;Punctuator&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    type = &apos;Numberic&apos;;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Punctuator&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    currentToken = char;</span><br><span class="line">  &#125;</span><br><span class="line">  if(type===&apos;Numberic&apos;&amp;&amp;i===(str.length-1)) &#123;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Numberic&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    currentToken = &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stateMachine(str) &#123;</span><br><span class="line">  for(let i=0; i&lt;str.length; i++) &#123;</span><br><span class="line">    start(str[i], i, str);</span><br><span class="line">  &#125;</span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line">console.log(stateMachine(inputStr));</span><br></pre></td></tr></table></figure><p>上面两个案例结果一样，但是过程不同。案例一的状态变化是以返回函数的形式，对代码进行了抽象解耦。案例二有点面向过程的写法，代码冗余，逻辑复杂的话，肯定是第一种方法好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章只是简单的介绍下，有限状态机在编译的词法分析阶段的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有限状态机在词法分析中的应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-编译器流程</title>
    <link href="/2022/12/30/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
    <id>/2022/12/30/前端编译原理-编译器流程/</id>
    <published>2022-12-30T02:44:56.000Z</published>
    <updated>2022-12-30T08:53:48.922Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍前端编译器的工作流程<br><a id="more"></a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本篇文章主要针对前端的JSX语法标签进行编译解析。<br>接下来将使用 Esprima 结合一个简单的 Demo 来实现串通整个编译器的工作流程。</p><h2 id="解析阶段-Parsing"><a href="#解析阶段-Parsing" class="headerlink" title="解析阶段 (Parsing)"></a>解析阶段 (Parsing)</h2><p>首先，在编译器的初始阶段会接受一段代码，通常会是一串字符串。<br>如下JSX代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>编译器拿到这段字符串代码之后会进入解析阶段，在解析阶段主要会做以下两件事：词法分析和语法分析</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>当编译器接受到上边的字符串时，首先会将传入的字符串按照词法效果分割成为一系列被称为 Token 的东西，这一步通常被称为分词。<br>先来看看利用 Esprima Api 查看将上述代码进行词法分析后的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parse1.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 配置支持jsx和tokens 利用parseScript Api 打印对应的tokens</span><br><span class="line">const &#123; tokens &#125; = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true, tokens: true &#125;);</span><br><span class="line">console.log(tokens,&apos;tokens&apos;)</span><br></pre></td></tr></table></figure></p><p>此时上方的语句经过词法分析会被一步一步拆分成为这样的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;id&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;=&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;String&quot;,&quot;value&quot;: &quot;\&quot;app\&quot;&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Hello&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Jue Jin&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到针对上方传入的 JSX 语法被解析成为了一个 Token 组成的数组，数组中每一个对象即代表一个 Token 。<br>每个 Token 都是拥有对应的 type 属性表示它的类型以及 value 属性表示它的值。<br>这一步通过解析阶段的词法分析将传入的代码分割成为了一个个 Token ，通常使用有限状态机是词法分析的最佳途径。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上一步通过词法分析将输入的代码分割成为了一个 tokens 的数组，在这之后需要将 tokens 进行语法分析从而转化成为真正的抽象语法树（AST）形式。<br>所谓抽象语法树，你可以将它理解成为一颗圣诞树。上述 tokens 中每一个 token 都可以看作成为该圣诞树中的一个节点。<br>语法分析正式将上述分成的每个 Token 抽象成为一棵树，从而描述每个 Token 节点之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parse2.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 调用parseScript获得输入代码生成的抽象语法树</span><br><span class="line">const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);</span><br><span class="line">console.log(ast, &apos;ast&apos;)</span><br></pre></td></tr></table></figure></p><p>上述的 Token 在经过语法分析后会变成这样的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;body&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;: &quot;ExpressionStatement&quot;,</span><br><span class="line">    &quot;expression&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">      &quot;openingElement&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;div&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;selfClosing&quot;: false,</span><br><span class="line">        &quot;attributes&quot;: [&#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXAttribute&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;id&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;value&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;app&quot;,</span><br><span class="line">            &quot;raw&quot;: &quot;\&quot;app\&quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;children&quot;: [&#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">        &quot;openingElement&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;p&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;selfClosing&quot;: false,</span><br><span class="line">          &quot;attributes&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;children&quot;: [&#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXText&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;Hello&quot;,</span><br><span class="line">          &quot;raw&quot;: &quot;Hello&quot;</span><br><span class="line">        &#125;],</span><br><span class="line">        &quot;closingElement&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXClosingElement&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;p&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXText&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;Jue Jin&quot;,</span><br><span class="line">        &quot;raw&quot;: &quot;Jue Jin&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      &quot;closingElement&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXClosingElement&quot;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;div&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所谓的语法分析阶段其实就是将 Tokens 经过一系列语法分析成为这颗树，树中的每个节点都会保存各自节点对应的信息。<br>同时因为树形的数据结构也很好的反应出了各个节点之间的关系。</p><h2 id="转化阶段-Transformaiton"><a href="#转化阶段-Transformaiton" class="headerlink" title="转化阶段 (Transformaiton)"></a>转化阶段 (Transformaiton)</h2><p>编译器首先经过转移阶段后将输入的代码转变成为 AST 。之后会进入转化阶段，所谓转化阶段本质上就是对于抽象语法树的一个深度遍历过程。<br>在转化阶段，会遍历这颗抽象语法树从而对于匹配节点进行增删改查从而修改树形结构。<br>比如想为 p 节点上添加一个 id 为 text 的属性，那么此时在遍历 AST 的过程中遍历到对应节点时修改对应的节点属性即可，当然也可以直接粗暴的替换整个节点。</p><blockquote><p>关于 Estraverse ，它是针对 Esprima 生成的抽象语法树进行深度遍历的一个工具库。因为 Estraverse 这个库不支持 JSX 语法，所以这里使用它的一个拓展工具库 estraverse-fb 来实现 JSX 转化的抽象语法树的遍历。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// transform.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 深度遍历AST的工具库</span><br><span class="line">const esTraverseFb = require(&apos;estraverse-fb&apos;)</span><br><span class="line">// 生成AST节点的工具</span><br><span class="line">const &#123; builders &#125; = require(&apos;ast-types&apos;)</span><br><span class="line"></span><br><span class="line">const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);</span><br><span class="line"></span><br><span class="line">// 深度优先的方式</span><br><span class="line">esTraverseFb.traverse(ast, &#123;</span><br><span class="line">  // 进入每个节点时都会出发enter函数</span><br><span class="line">  enter: function (node) &#123;</span><br><span class="line">    const &#123; type, openingElement &#125; = node</span><br><span class="line">    // 判断当前进入的节点是否是匹配的p节点</span><br><span class="line">    if (type === &apos;JSXElement&apos; &amp;&amp; openingElement.name.name === &apos;p&apos;) &#123;</span><br><span class="line">      // 生成当前需要添加的属性节点</span><br><span class="line">      const attribute = builders.jsxAttribute(</span><br><span class="line">        // 第一个参数是name</span><br><span class="line">        builders.jsxIdentifier(&apos;id&apos;),</span><br><span class="line">        // 第二个参数是value</span><br><span class="line">        builders.literal(&apos;text&apos;)</span><br><span class="line">      )</span><br><span class="line">      // 为该节点的开始标签中添加生成的属性 id=&apos;text&apos;</span><br><span class="line">      openingElement.attributes.push(attribute)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 离开每个节点时会触发leave函数</span><br><span class="line">  leave: function () &#123;</span><br><span class="line">    // nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ast);</span><br></pre></td></tr></table></figure><p>此时经过上述的转化，我们更改了原本的 AST 结构。我们将原始的 p 标签对应的节点修改成为了这样的结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">  &quot;openingElement&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;p&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;selfClosing&quot;: false,</span><br><span class="line">    // 这里我们为attributes中添加了一个属性节点</span><br><span class="line">    &quot;attributes&quot;: [&#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">        &quot;loc&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">        &quot;comments&quot;: null,</span><br><span class="line">        &quot;optional&quot;: false,</span><br><span class="line">        &quot;typeAnnotation&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;value&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;loc&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">        &quot;comments&quot;: null,</span><br><span class="line">        &quot;regex&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;loc&quot;: null,</span><br><span class="line">      &quot;type&quot;: &quot;JSXAttribute&quot;,</span><br><span class="line">      &quot;comments&quot;: null</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生成阶段-Code-Generation"><a href="#生成阶段-Code-Generation" class="headerlink" title="生成阶段 (Code Generation)"></a>生成阶段 (Code Generation)</h2><p>上述经过解析阶段 (Parsing) 将输入的字符串转化成了抽象语法树 AST 结构。<br>之后经过转化阶段 (Transformaiton) 对于生成的抽象语法树进行深度遍历节点，从而对于某些节点进行了修改。‘<br>此时编译器拥有了经过处理后的抽象语法树，此时需要做的当然是将所谓的树形结构的抽象语法树转化成为新的代码。<br>这一步通常称为生成阶段(Code Generation)：通过抽象语法树反向转化成为生成的代码，此时最新的代码是根据修改后的 AST 生成的代码。<br>在生成阶段本质上就是遍历抽象语法树，根据抽象语法树上每个节点的类型和属性递归调用从而生成对应的字符串代码。<br>在代码生成阶段，可以借助 EscodeGen 将 AST 转化成为新的字符串代码。</p><blockquote><p>因为 EscodeGen 对于 JSX 语法并不支持，所以这里具体就不详细演示用法了，有兴趣的朋友可以自行尝试。</p></blockquote><p>上方将代码修改的抽象语法树会生成新的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;p id=&quot;text&quot;&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，一次编译器工作流程中包括解析、转化、生成这三个步骤。<br>如果自己想实现，请参考本站的<a href="/2020/07/20/the-super-tiny-compiler/">【tiny编译工具】</a><br><a href="https://github.com/jinux7/study-collections/tree/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">上面例子代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍前端编译器的工作流程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
</feed>
