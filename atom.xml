<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2024-08-02T02:52:25.948Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript教程(二)</title>
    <link href="/2024/08/01/TypeScript%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
    <id>/2024/08/01/TypeScript教程-二/</id>
    <published>2024-08-01T06:37:21.000Z</published>
    <updated>2024-08-02T02:52:25.948Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript进阶教程<br><a id="more"></a></p><h1 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type-Challenges"></a>Type-Challenges</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学习完<code>TypeScript</code>一些基础知识后，已经可以熟练使用一些基本类型定义了，但对于<code>TypeScript</code>的高级用法却依旧无法入门，为了更有趣的学习<code>TypeScript</code>高级用法，选择<a href="https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md" target="_blank" rel="noopener">Type-Challenges</a>类型挑战来作为我们学习的目标。</p><p>在<code>Type-Challenges</code>中，可以从简单(<code>easy</code>)、中等(<code>medium</code>)、困难(<code>hard</code>)以及地狱(<code>extreme</code>)难度，循序渐进的学习<code>TypeScript</code>高级技巧。</p><p>如果你需要选择其它的方向来深入学习<code>TypeScript</code>高级技巧，这里也有一些推荐的开源项目：</p><ul><li>官方内置：在<code>lib.es5.d.ts</code>文件中，<code>TypeScript</code>官方默认内置了一些辅助工具函数，例如：<code>Partial</code>、<code>Required</code>、<code>Pick</code>以及<code>Record</code>等等。</li><li>其它开源库：<a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="noopener">utility-types</a>、<a href="https://github.com/millsp/ts-toolbelt" target="_blank" rel="noopener">ts-toolbelt</a>、<a href="https://github.com/andnp/SimplyTyped" target="_blank" rel="noopener">SimplyTyped</a></li></ul><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="加号和减号"><a href="#加号和减号" class="headerlink" title="加号和减号"></a>加号和减号</h3><blockquote><p>tip<br>加号和减号的用法类似。</p></blockquote><p>在一些内置工具中，可能会出现<code>+</code>或者<code>-</code>这些符号，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Required&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><p>观察以上结果可以得出结论：<code>-?</code>是去掉类型中属性后面的<code>?</code>，整个<code>Required</code>的实际效果是去掉<code>T</code>类型中所有属性键后面的<code>?</code>，让所有属性变成必填的。</p><h3 id="keyof-和-in"><a href="#keyof-和-in" class="headerlink" title="keyof 和 in"></a>keyof 和 in</h3><p><code>keyof</code>和<code>in</code>经常会连在一起使用，当它们连在一起使用时，通常表示一个迭代的过程。</p><h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>在<code>TS</code>中，<code>keyof T</code>这段代码表示获取<code>T</code>类型中所有属性键，这些属性键组合成一个联合类型，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = keyof Person</span><br></pre></td></tr></table></figure></p><p><code>TS</code>中的<code>keyof T</code>，它有点类似<code>JavaScript</code>中的<code>Object.keys()</code>，它们的共同点都是获取属性键的集合，只不过<code>keyof T</code>得到的结果是一个联合类型，而<code>Object.keys()</code>得到的是一个数组。</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p><code>in</code>操作符的右侧通常跟一个联合类型，可以使用<code>in</code>来迭代这个联合类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅演示使用, K为每次迭代的项</span></span><br><span class="line">K <span class="keyword">in</span> <span class="string">'name'</span> | <span class="string">'age'</span> | <span class="string">'sex'</span></span><br><span class="line">K = <span class="string">'name'</span> <span class="comment">// 第一次迭代结果</span></span><br><span class="line">K = <span class="string">'age'</span>  <span class="comment">// 第二次迭代结果</span></span><br><span class="line">K = <span class="string">'sex'</span>  <span class="comment">// 第三次迭代结果</span></span><br></pre></td></tr></table></figure></p><p>根据<code>keyof</code>和<code>in</code>的特点，我们可以撰写一些辅助工具，这里以<code>Readonly</code>为例。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; readony name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Readonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>[P in keyof T]</code>：这段代码表示遍历<code>T</code>中的每一个属性键，每次遍历时属性键取名为<code>P</code>，这和<code>JavaScript</code>中的<code>for in</code>非常类似：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的迭代</span></span><br><span class="line">P <span class="keyword">in</span> keyof T</span><br><span class="line"></span><br><span class="line"><span class="comment">// js中的迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure></li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>TS</code>中的<code>typeof</code>，可以用来获取一个<code>JavaScript</code>变量的类型，经常用于获取一个普通对象或者一个函数的类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'AAA'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：(a: number, b:number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> t1  = <span class="keyword">typeof</span> add</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> obj</span><br></pre></td></tr></table></figure></p><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>类型表示永远不会有值的一种类型。</p><p>例如，如果一个函数抛出一个错误，那么这个函数就可以用<code>never</code>或者<code>void</code>来表示其返回值，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never更适合用来表示永远没有返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void适合用来表示返回值为空的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>never</code>的另外一个知识点是：如果一个联合类型中存在<code>never</code>，那么实际的联合类型并不会包含<code>never</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span> | never</span><br><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span></span><br></pre></td></tr></table></figure></p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><code>extends</code>关键词，一般有两种用法：<strong>类型约束</strong>和<strong>条件类型</strong>。</p><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>类型约束经常和泛型一起使用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型约束</span></span><br><span class="line">U <span class="keyword">extends</span> keyof T</span><br></pre></td></tr></table></figure></p><p><code>keyof T</code>是一个整体，它表示一个联合类型。<code>U extends Union</code>这一整段表示<code>U</code>的类型被收缩在一个联合类型的范围内。例如： <code>U extends &#39;name&#39; | &#39;age&#39;</code>，则表示<code>U</code>只能为<code>name</code>或者<code>age</code>二者其中之一。</p><h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>常见的条件类型表现形式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? <span class="string">'Y'</span> : <span class="string">'N'</span></span><br></pre></td></tr></table></figure></p><p>我们发现条件类型有点像<code>JavaScript</code>中的三元表达式，事实上它们的工作原理是类似的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = <span class="literal">true</span> <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="literal">true</span> : <span class="literal">false</span>                    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span> | <span class="string">'age'</span> ? <span class="literal">true</span> : <span class="literal">false</span>           <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? <span class="literal">true</span> : <span class="literal">false</span>   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; ? <span class="literal">true</span> : <span class="literal">false</span>         <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>在条件类型中，有一个特别需要注意的东西就是：<strong>分布式条件类型</strong>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置工具：交集</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br><span class="line"><span class="keyword">type</span> type1 = <span class="string">'name'</span>|<span class="string">'age'</span></span><br><span class="line"><span class="keyword">type</span> type2 = <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集结果：'name'</span></span><br><span class="line"><span class="keyword">type</span> result = Extract&lt;type1, type2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推理步骤</span></span><br><span class="line"><span class="string">'name'</span>|<span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">step1： (<span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never) =&gt; <span class="string">'name'</span></span><br><span class="line">step2:  <span class="function">(<span class="params">'age' <span class="keyword">extends</span> 'name'|'address'|'sex' ? 'age' : never</span>)   =&gt;</span> never</span><br><span class="line">result: <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><p><code>T extends U ? T : never</code>：因为<code>T</code>是一个联合类型，所以这里适用于<strong>分布式条件类型</strong>的概念。根据其概念，在实际的过程中会把<code>T</code>类型中的每一个子类型进行迭代，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代：</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never</span><br><span class="line"><span class="comment">// 第二次迭代：</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure></li><li><p>在迭代完成之后，会把每次迭代的结果组合成一个新的联合类型(根据<code>never</code>类型的特点，最后的结果会剔除掉<code>never</code>)，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p><code>infer</code>关键词的作用是延时推导，它会在类型未推导时进行占位，等到真正推导成功后，它能准确的返回正确的类型。</p><p>为了更好的理解<code>infer</code>关键词的用法，我们使用<code>ReturnType</code>这个例子来说明，<code>ReturnType</code>是一个用来获取函数返回类型的工具。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: number</span></span><br><span class="line"><span class="keyword">type</span> result = ReturnType&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends (...args: any) =&gt; infer R</code>：如果不看<code>infer R</code>，这段代码实际表示：<code>T</code>是不是一个函数类型。</li><li><code>(...args: any) =&gt; infer R</code>：这段代码实际表示一个函数类型，其中把它的参数使用<code>args</code>来表示，把它的返回类型用<code>R</code>来进行占位。<br>如果<code>T</code>满足是一个函数类型，那么我们返回其函数的返回类型，也就是<code>R</code>；如果不是一个函数类型，就返回<code>never</code>。</li></ul><p><code>TS</code>中的<code>infer</code>占位更像<code>JavaScript</code>中的模板字符串：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的返回类型使用R占位表示</span></span><br><span class="line">(...args: <span class="built_in">any</span>) =&gt; info R</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串中的值，使用变量name占位表示</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><h3 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp; 符号"></a>&amp; 符号</h3><p>在<code>TS</code>中有两种类型值得我们重点关注：<strong>联合类型</strong>和<strong>交叉类型</strong>。</p><p>联合类型一般适用于基本类型的<strong>合并</strong>，它使用<code>|</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="number">1</span> | <span class="literal">true</span> | <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>而交叉类型则适用于对象或者函数的<strong>合并</strong>，它使用<code>&amp;</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = T &amp; U</span><br></pre></td></tr></table></figure></p><p><code>T &amp; U</code>表示一个新的类型，其中这个类型包含<code>T</code>和<code>U</code>中所有的键，这和<code>JavaScript</code>中的<code>Object.assign()</code>函数的作用非常类似。</p><p>根据交叉类型的概念，我们可以封装一个合并对象的<code>merge</code>函数，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.8.4以上版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> unknown <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> unknown <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts v4.8.4以下版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; name: <span class="string">'AAA'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; age: <span class="number">23</span> &#125;</span><br><span class="line"><span class="comment">// js结果：&#123; name：'AAA'; age: 23; &#125;</span></span><br><span class="line"><span class="comment">// ts结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">const</span> result = merge(obj1, obj2)</span><br></pre></td></tr></table></figure></p><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="内置Pick-选取"><a href="#内置Pick-选取" class="headerlink" title="内置Pick(选取)"></a>内置Pick(选取)</h3><p><link-and-solution num="4"></link-and-solution></p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>Pick</code>表示从一个类型中选取指定的几个字段组合成一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: &#123; name: string; address: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PickResult = Pick&lt;Person, <span class="string">'name'</span> | <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof T</code>：表示<code>K</code>只能是<code>keyof T</code>的子类型，如果我们在使用<code>Pick</code>的时候传递了不存在于<code>T</code>的字段，会报错：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：phone无法分配给keyof T</span></span><br><span class="line"><span class="keyword">type</span> result = MyPick&lt;Person, <span class="string">'name'</span> | <span class="string">'phone'</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Readonly-只读"><a href="#内置Readonly-只读" class="headerlink" title="内置Readonly(只读)"></a>内置Readonly(只读)</h3><p><link-and-solution num="7"></link-and-solution></p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p><code>Readonly</code>是用来让所有属性变为只读，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; readonly name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MyReadonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TupleToObject-元组转对象"><a href="#TupleToObject-元组转对象" class="headerlink" title="TupleToObject(元组转对象)"></a>TupleToObject(元组转对象)</h3><p><link-and-solution num="11"></link-and-solution></p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToObject&lt;T&gt;</code>是用来把一个元组转换成一个<code>key/value</code>相同的对象，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：readonly ['msg', 'name']</span></span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="string">'msg'</span>, <span class="string">'name'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 结果：&#123; msg: 'msg'; name: 'name'; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToObject&lt;<span class="keyword">typeof</span> tuple&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>as const</code>：常用来进行常量断言，在此处表示将<code>[&#39;msg&#39;,&#39;name&#39;]</code>推导常量元组，表示其不能新增、删除、修改元素，可以使用<code>as readonly</code>来辅助理解。</li><li><code>T[number]</code>：表示返回数组中所有数字型索引的元素，形成一个联合类型，例如：<code>&#39;msg&#39;|&#39;name&#39;</code>。</li></ul><h3 id="First-数组第一个元素"><a href="#First-数组第一个元素" class="headerlink" title="First(数组第一个元素)"></a>First(数组第一个元素)</h3><p><link-and-solution num="14"></link-and-solution></p><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>First&lt;T&gt;</code>用来返回数组的第一个元素，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = First&lt;[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result2 = First&lt;[]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? never : T[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 占位实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer R, ...infer L] ? R : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends []</code>：用来判断<code>T</code>是否是一个空数组。</li><li><code>T[0]</code>：根据下标取数组第一个元素。</li><li><code>infer R</code>： 表示数组第一个元素的占位。</li><li><code>...infer L</code>: 表示数组剩余元素的占位。</li></ul><h3 id="Length-元组的长度"><a href="#Length-元组的长度" class="headerlink" title="Length(元组的长度)"></a>Length(元组的长度)</h3><p><link-and-solution num="18"></link-and-solution></p><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>Length&lt;T&gt;</code>用来获取一个数组(包括类数组)的长度，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = Length&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：10</span></span><br><span class="line"><span class="keyword">type</span> result2 = Length&lt;&#123; <span class="number">5</span>: <span class="string">'5'</span>, length: <span class="number">10</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? T[<span class="string">'length'</span>] : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends { length: number; }</code>：判断<code>T</code>是否是<code>{ length: number; }</code>的子类型，如果是则代表<code>T</code>为数组或者类数组。</li><li><code>T[&#39;length&#39;]</code>：取<code>T</code>对象的<code>length</code>属性的值(注意，在<code>TypeScript</code>中不能使用<code>T.length</code>来取值，而应该使用<code>T[&#39;length&#39;]</code>)。</li></ul><h3 id="内置Exclude-排除"><a href="#内置Exclude-排除" class="headerlink" title="内置Exclude(排除)"></a>内置Exclude(排除)</h3><p><link-and-solution num="43"></link-and-solution></p><h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><p><code>Exclude</code>是排除的意思，它从<code>T</code>类型中排除属于<code>U</code>类型的子集，可以理解成取<code>T</code>对于<code>U</code>的差集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> ExcludeResult = Exclude&lt;<span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span>, <span class="string">'sex'</span>|<span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br></pre></td></tr></table></figure><ul><li><code>T extends U</code>：这段代码会从<code>T</code>的子类型开始分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U </span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span></span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'name'</span> |</span><br><span class="line">  <span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'age'</span> |</span><br><span class="line">  <span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'sex'</span></span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="PromiseType-promise包裹类型"><a href="#PromiseType-promise包裹类型" class="headerlink" title="PromiseType(promise包裹类型)"></a>PromiseType(promise包裹类型)</h3><p><link-and-solution num="189"></link-and-solution></p><h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseType</code>是用来获取<code>Promise</code>包裹类型的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span> (<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>|<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：(） =&gt; Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> getInfo</span><br><span class="line"><span class="comment">// 结果：Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> returnResult = ReturnType&lt;funcType&gt;</span><br><span class="line"><span class="comment">// 结果：string|number</span></span><br><span class="line"><span class="keyword">type</span> PromiseResult = PromiseType&lt;returnResult&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PromiseType&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer R&gt;</span><br><span class="line">    ? R <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">      ? PromiseType&lt;R&gt;</span><br><span class="line">      : R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends Promise&lt;infer R&gt;</code>：判断<code>T</code>是否是<code>Promise&lt;infer R&gt;</code>的子类型，也就是说<code>T</code>必须满足<code>Promise&lt;any&gt;</code>的形式。</li></ul><h3 id="If-判断"><a href="#If-判断" class="headerlink" title="If(判断)"></a>If(判断)</h3><p><link-and-solution num="268"></link-and-solution></p><h4 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h4><p><code>If&lt;C, T, F&gt;</code>用来表示根据<code>C</code>的值来返回<code>T</code>或者<code>F</code>，如果<code>C</code>为<code>true</code>，则返回<code>T</code>；如果<code>C</code>为<code>false</code>，则返回<code>F</code>，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a'</span></span><br><span class="line"><span class="keyword">type</span> result1 = If&lt;<span class="literal">true</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'b'</span></span><br><span class="line"><span class="keyword">type</span> result2 = If&lt;<span class="literal">false</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>根据上案例，我们可以直观的发现<code>If&lt;C, T, F&gt;</code>的作用有点类似<code>JavaScript</code>中的三元表达式：<code>C ? T : F</code>。</p><h4 id="实现方式-7"><a href="#实现方式-7" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> If&lt;C <span class="keyword">extends</span> <span class="built_in">boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>C extends boolean</code>：表示<code>C</code>为<code>boolean</code>类型的子类型，既<code>C</code>只能为<code>true</code>或者<code>false</code>，传递其它值报错。</li><li><code>C extends true</code>：如果用<code>JavaScript</code>来表示的话，相当于<code>C===true</code>.</li></ul><h3 id="Concat-数组concat方法"><a href="#Concat-数组concat方法" class="headerlink" title="Concat(数组concat方法)"></a>Concat(数组concat方法)</h3><p><link-and-solution num="533"></link-and-solution></p><h4 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h4><p><code>Concat&lt;T, U&gt;</code>用来将两个数组合并起来，类似实现数组的<code>concat</code>方法，使用方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Concat&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-8"><a href="#实现方式-8" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...U]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends any[]</code>：用来限制<code>T</code>是一个数组，如果传递非数组会报错，<code>U</code>也是一样的道理。</li><li><code>[...T, ...U]</code>：可以理解成<code>JavaScript</code>的扩展运算符<code>...</code>。</li></ul><h3 id="Includes-数组includes方法"><a href="#Includes-数组includes方法" class="headerlink" title="Includes(数组includes方法)"></a>Includes(数组includes方法)</h3><p><link-and-solution num="898"></link-and-solution></p><h4 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h4><p><code>Includes&lt;T, U&gt;</code>用来判断<code>U</code>是否在数组<code>T</code>中，类似实现数组的<code>includes</code>方法，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'1'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-9"><a href="#实现方式-9" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = U <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 完善版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> [infer R, ...infer L]</span><br><span class="line">    ? Equal&lt;R, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : MyIncludes&lt;L, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[number]</code>：它返回数组中所有数字类型键对应的值，将这些值构造成一个联合类型，例如：<code>1 | 2 | 3</code>。</li><li><code>U extends T[number]</code>：判断<code>U</code>是否是某个联合类型的子类型，例如：<code>1 extends 1 | 2 | 3</code>。</li><li><code>Equal</code>：是用来判断两个值是否相等的辅助方法。</li></ul><h3 id="Push-数组push方法"><a href="#Push-数组push方法" class="headerlink" title="Push(数组push方法)"></a>Push(数组push方法)</h3><p><link-and-solution num="3057"></link-and-solution></p><h4 id="用法-10"><a href="#用法-10" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Push&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-10"><a href="#实现方式-10" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push实现</span></span><br><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [...T, K]</span><br></pre></td></tr></table></figure><h3 id="Unshift-数组unshift方法"><a href="#Unshift-数组unshift方法" class="headerlink" title="Unshift(数组unshift方法)"></a>Unshift(数组unshift方法)</h3><p><link-and-solution num="3060"></link-and-solution></p><p>与<code>pop</code>和<code>push</code>方法相似的另外一对方法叫<code>shift</code>和<code>unshift</code>，它们的实现思路是一样的。</p><h4 id="用法-11"><a href="#用法-11" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[0, 1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unshift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-11"><a href="#实现方式-11" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unshift实现</span></span><br><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [K, ...T]</span><br></pre></td></tr></table></figure><h3 id="内置Parameters-函数的参数类型"><a href="#内置Parameters-函数的参数类型" class="headerlink" title="内置Parameters(函数的参数类型)"></a>内置Parameters(函数的参数类型)</h3><p><link-and-solution num="3312"></link-and-solution></p><h4 id="用法-12"><a href="#用法-12" class="headerlink" title="用法"></a>用法</h4><p><code>Parameters</code>是用来获取一个函数的参数类型的，其中获取的结果是一个元组，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// [number, string]</span></span><br><span class="line"><span class="keyword">type</span> result = MyParameters&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-12"><a href="#实现方式-12" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyParameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span> ? R : never</span><br></pre></td></tr></table></figure><h3 id="内置Partial-可填-和内置Required-必填"><a href="#内置Partial-可填-和内置Required-必填" class="headerlink" title="内置Partial(可填)和内置Required(必填)"></a>内置Partial(可填)和内置Required(必填)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-13"><a href="#用法-13" class="headerlink" title="用法"></a>用法</h4><p><code>Partial</code>和<code>Required</code>一个是让所有属性可填、另外一个是让所有属性必填，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name?: string; age?: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PartialResult = MyPartial&lt;Person&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> RequiredResult = MyRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-13"><a href="#实现方式-13" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPartial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置Record-构造"><a href="#内置Record-构造" class="headerlink" title="内置Record(构造)"></a>内置Record(构造)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-14"><a href="#用法-14" class="headerlink" title="用法"></a>用法</h4><p><code>Record&lt;K, T&gt;</code>用来将<code>K</code>的每一个键(<code>k</code>)指定为<code>T</code>类型，这样由多个<code>k/T</code>组合成了一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keys = <span class="string">'Cat'</span>|<span class="string">'Dot'</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  Cat: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  Dog: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> RecordResult = Record&lt;keys, Animal&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-14"><a href="#实现方式-14" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRecord&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof any</code>：此代码表示<code>K</code>是<code>keyof any</code>任意类型其所有键的子类型，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K为 'Dog'|'cat'</span></span><br><span class="line"><span class="keyword">type</span> UnionKeys = <span class="string">'Dog'</span> | <span class="string">'Cat'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K为'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TypeKeys = keyof Person</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Extract-交集"><a href="#内置Extract-交集" class="headerlink" title="内置Extract(交集)"></a>内置Extract(交集)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-15"><a href="#用法-15" class="headerlink" title="用法"></a>用法</h4><p><code>Extract&lt;T, U&gt;</code>用来取联合类型<code>T</code>和<code>U</code>的交集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'age'|'address'</span></span><br><span class="line"><span class="keyword">type</span> ExtractResult = Extract&lt;keyof Person, <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-15"><a href="#实现方式-15" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExtract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends U</code>：此代码会自动将<code>T</code>的子类型进行分发，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T extends U</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never |</span><br><span class="line">  <span class="string">'age'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never |</span><br><span class="line">  <span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'address'</span> ? <span class="string">'age'</span> : never</span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'age'</span>|<span class="string">'address'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="内置ReturnType-函数返回类型"><a href="#内置ReturnType-函数返回类型" class="headerlink" title="内置ReturnType(函数返回类型)"></a>内置ReturnType(函数返回类型)</h3><p><link-and-solution num="2"></link-and-solution></p><h4 id="用法-16"><a href="#用法-16" class="headerlink" title="用法"></a>用法</h4><p><code>ReturnType&lt;T&gt;</code>是用来获取一个函数的返回类型的，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span> (<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：number</span></span><br><span class="line">type result = ReturnType&lt;<span class="keyword">typeof</span> getRandom&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-16"><a href="#实现方式-16" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends (...args: any) =&gt; infer R</code>：判断<code>T</code>类型是否是一个函数的子类型，既<code>T</code>是不是一个函数。</li><li><code>infer R</code>：表示待推导的函数返回类型为<code>R</code>，后续可以在表达式中使用<code>R</code>来代替真正的返回类型。</li></ul><h3 id="内置Omit-移除"><a href="#内置Omit-移除" class="headerlink" title="内置Omit(移除)"></a>内置Omit(移除)</h3><p><link-and-solution num="3"></link-and-solution></p><h4 id="用法-17"><a href="#用法-17" class="headerlink" title="用法"></a>用法</h4><p><code>Omit</code>是移除的意思，它用来在<code>T</code>类型中移除指定的字段，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name？: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> OmitResult = Omit&lt;Person, <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-17"><a href="#实现方式-17" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Omit</code>可以借助在上面已经实现过的<code>Pick</code>和<code>Exclude</code>配合来实现，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Omit实现</span></span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K&gt; = MyPick&lt;T, MyExclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li>使用<code>MyExclude&lt;keyof T, K&gt;</code>，可以从<code>T</code>中移除指定的字段，移除后得到一个新的联合类型：<code>&#39;name&#39;|&#39;age&#39;</code></li><li>使用<code>MyPick&lt;T, &#39;name&#39;|&#39;age&#39;&gt;</code>，可以从<code>T</code>中选取这两个字段，组合成一个新的类型。</li></ul><h3 id="Readonly-按需Readonly"><a href="#Readonly-按需Readonly" class="headerlink" title="Readonly(按需Readonly)"></a>Readonly(按需Readonly)</h3><p><link-and-solution num="8"></link-and-solution></p><h4 id="用法-18"><a href="#用法-18" class="headerlink" title="用法"></a>用法</h4><p>不同于初级实现中的<code>Readonly</code>，在中级实现的<code>Readonly</code>中，如果我们传递了指定的字段，那么<code>Readonly</code>会表现为按需实现<code>readonly</code>，用法如下。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected1 &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected2 &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult1 = Readonly&lt;Todo&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult2 = Readonly&lt;Todo, <span class="string">'desc'</span>|<span class="string">'completed'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line"><span class="keyword">const</span> obj: ReadonlyResult2 = &#123;</span><br><span class="line">  title: <span class="string">'AAA'</span>,</span><br><span class="line">  desc: <span class="string">'23'</span>,</span><br><span class="line">  completed: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">obj.title = <span class="string">'aaa'</span></span><br><span class="line">obj.desc = <span class="string">'32'</span> <span class="comment">// error</span></span><br><span class="line">obj.completed = <span class="literal">false</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-18"><a href="#实现方式-18" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.4+版本可直接用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = T &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts v4.5+版本必须用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof T = keyof T</code>：如要传递了<code>K</code>，那么只能是<code>T</code>中已经存在的属性，不存在则报错；如果不传递，则默认值为<code>keyof T</code>，意味着全部属性都添加<code>readonly</code>。</li><li><code>T &amp; U</code>：在本例中表示将<code>T</code>和<code>U</code>中的字段结合起来，如果没有<code>&amp;</code>会丢失一些属性，例如<code>title</code>。</li></ul><h3 id="DeepReadonly-深度Readonly"><a href="#DeepReadonly-深度Readonly" class="headerlink" title="DeepReadonly(深度Readonly)"></a>DeepReadonly(深度Readonly)</h3><p><link-and-solution num="9"></link-and-solution></p><h4 id="用法-19"><a href="#用法-19" class="headerlink" title="用法"></a>用法</h4><p><code>DeepReadonly</code>用来将一个嵌套对象类型中所有字段全部添加<code>readonly</code>关键词，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：</span></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">  b: <span class="built_in">string</span></span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="built_in">boolean</span></span><br><span class="line">    e: <span class="literal">undefined</span>,</span><br><span class="line">    f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> Y = &#123;</span><br><span class="line">  readonly b: <span class="built_in">string</span></span><br><span class="line">  readonly c: &#123;</span><br><span class="line">    readonly d: <span class="built_in">boolean</span></span><br><span class="line">    readonly e: <span class="literal">undefined</span>,</span><br><span class="line">    readonly f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-19"><a href="#实现方式-19" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; ? DeepReadonly&lt;T[P]&gt; : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[P] extends { [key: string]: any }</code>：这段表示<code>T[P]</code>是否是一个包含索引签名的字段，如果包含我们认为它是一个嵌套对象，就可以递归调用<code>DeepReadonly</code>。</li></ul><h3 id="TupleToUnion-元组转联合类型"><a href="#TupleToUnion-元组转联合类型" class="headerlink" title="TupleToUnion(元组转联合类型)"></a>TupleToUnion(元组转联合类型)</h3><p><link-and-solution num="10"></link-and-solution></p><h4 id="用法-20"><a href="#用法-20" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToUnion</code>是用来将一个元组转换成联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'1' | '2' | '3'</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToUnion&lt;[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-20"><a href="#实现方式-20" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: T[number]</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>]</span><br><span class="line"><span class="comment">// way2: 递归</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">    ? R | TupleToUnion&lt;args&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[number]</code>：它会自动迭代元组的数字型索引，然后将所有元素组合成一个联合类型。</li><li><code>R | TupleToUnion&lt;args&gt;</code>：<code>R</code>表示每一次迭代中的第一个元素，它的迭代过程可以用下面伪代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'3'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">''</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | <span class="string">'3'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Chainable-可串联构造器"><a href="#Chainable-可串联构造器" class="headerlink" title="Chainable(可串联构造器)"></a>Chainable(可串联构造器)</h3><p><link-and-solution num="12"></link-and-solution></p><h4 id="用法-21"><a href="#用法-21" class="headerlink" title="用法"></a>用法</h4><p><code>Chainable</code>是用来让一个对象可以进行链式调用的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  foo: <span class="built_in">number</span></span><br><span class="line">  bar: &#123;</span><br><span class="line">    value: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> obj: Chainable&lt;&#123;&#125;&gt;</span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">const</span> result = obj</span><br><span class="line">  .options(<span class="string">'foo'</span>, <span class="number">123</span>)</span><br><span class="line">  .options(<span class="string">'bar'</span>, &#123; value: <span class="string">'Hello'</span> &#125;)</span><br><span class="line">  .options(<span class="string">'name'</span>, <span class="string">'TypeScript'</span>)</span><br><span class="line">  .get()</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-21"><a href="#实现方式-21" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chainable&lt;T&gt; = &#123;</span><br><span class="line">  options&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, V&gt;(key: K, value: V): Chainable&lt;T &amp; &#123;[k <span class="keyword">in</span> K]: V&#125;&gt;</span><br><span class="line">  <span class="keyword">get</span>(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>{[k in K]: V}</code>：每次调用<code>options</code>时，把<code>key/value</code>构造成一个对象，例如：<code>{ foo: 123 }</code>。</li><li><code>T &amp; U</code>：此处使用到<code>&amp;</code>关键词，用来合并<code>T</code>和<code>U</code>两个对象中的所有<code>key</code>。</li><li><code>Chainable&lt;&gt;</code>：递归调用<code>Chainable</code>，赋予新对象以链式调用的能力。</li></ul><h3 id="Last-数组最后一个元素"><a href="#Last-数组最后一个元素" class="headerlink" title="Last(数组最后一个元素)"></a>Last(数组最后一个元素)</h3><p><link-and-solution num="15"></link-and-solution></p><h4 id="用法-22"><a href="#用法-22" class="headerlink" title="用法"></a>用法</h4><p><code>Last</code>是用来获取数组中最后一个元素的，它和我们之前已经实现的<code>First</code>思路很相似。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = Last&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-22"><a href="#实现方式-22" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Last</code>的实现方式很巧妙，因为它既可以在索引上做文章来实现，也可以用占位的思想来实现。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1：索引思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [<span class="built_in">any</span>, ...T][T[<span class="string">'length'</span>]]</span><br><span class="line"><span class="comment">// way2: 后占位思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer R, infer L] ? L : never</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><p><code>[any, ...T]</code>：此代码表示我们构建了一个新数组，并添加了一个新元素到第一个位置，然后把原数组<code>T</code>中的元素依次扩展到新数组中，可以用以下伪代码表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 新数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="built_in">any</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 结果: 3</span></span><br><span class="line"><span class="keyword">const</span> result = arr[T[<span class="string">'length'</span>]]</span><br></pre></td></tr></table></figure></li><li><p><code>T[&#39;length&#39;]</code>：这里我们获取到的是原始<code>T</code>数组的长度，例如<code>[1, 2, 3]</code>，长度值为<code>3</code>。而在新数组中，索引为<code>3</code>的位置正好是最后一个元素的索引，通过这种方式就能达到我们的目的。</p></li><li><code>T extends [...infer R, infer L]</code>：这段代码表示，我们将原数组中最后一个元素使用<code>L</code>进行占位，而其它元素我们用一个<code>R</code>数组表示。这样，如果数组满足这种格式，就能正确返回最后一个元素的值。</li></ul><h3 id="Pop-数组Pop方法"><a href="#Pop-数组Pop方法" class="headerlink" title="Pop(数组Pop方法)"></a>Pop(数组Pop方法)</h3><p><link-and-solution num="16"></link-and-solution></p><p>继续沿用以上处理索引思想或占位的思想，我们能快速实现数组<code>pop</code>方法。</p><h4 id="用法-23"><a href="#用法-23" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Pop&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2：[]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Pop&lt;[]&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-23"><a href="#实现方式-23" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop实现</span></span><br><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> []</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> [...infer Rest, infer L]</span><br><span class="line">      ? Rest</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure><h3 id="PromiseAll返回类型"><a href="#PromiseAll返回类型" class="headerlink" title="PromiseAll返回类型"></a>PromiseAll返回类型</h3><p><link-and-solution num="20"></link-and-solution></p><h4 id="用法-24"><a href="#用法-24" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseAll</code>是用来取<code>Promise.all()</code>函数所有返回的类型，其用法如下<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result1 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result2 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result3 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)])</span><br><span class="line"><span class="keyword">const</span> result4 = PromiseAll&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1： Promise&lt;[1, 2, 3]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">typeof</span> result1</span><br><span class="line"><span class="comment">// 结果2： Promise&lt;[1, 2, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> result2</span><br><span class="line"><span class="comment">// 结果3： Promise&lt;[number, number, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="keyword">typeof</span> result3</span><br><span class="line"><span class="comment">// 结果4： Promise&lt;number[]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t4 = <span class="keyword">typeof</span> result4</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-24"><a href="#实现方式-24" class="headerlink" title="实现方式"></a>实现方式</h4><p>与之前的例子不同，<code>PromiseAll</code>我们声明的是一个<code>function</code>而不是<code>type</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Awaited为内置类型</span></span><br><span class="line"><span class="keyword">type</span> PromiseAllType&lt;T&gt; = <span class="built_in">Promise</span>&lt;&#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: Awaited&lt;T[P]&gt;</span><br><span class="line">&#125;&gt;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">values: readonly [...T]</span>): <span class="title">PromiseAllType</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li>因为<code>Promise.all()</code>函数接受的是一个数组，因此泛型<code>T</code>限制为一个<code>any[]</code>类型的数组。</li><li><code>PromiseAllType</code>的实现思路有点像之前的<code>PromiseType</code>，只不过这里多了一层<code>Promise</code>的包裹，因为<code>Promise.all()</code>的返回类型也是一个<code>Promise</code>。</li></ul><h3 id="LookUp-查找"><a href="#LookUp-查找" class="headerlink" title="LookUp(查找)"></a>LookUp(查找)</h3><p><link-and-solution num="62"></link-and-solution></p><h4 id="用法-25"><a href="#用法-25" class="headerlink" title="用法"></a>用法</h4><p><code>LookUp</code>是用来根据类型值查<code>type</code>找类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'cat'</span></span><br><span class="line">  color: <span class="string">'black'</span> | <span class="string">'orange'</span> | <span class="string">'gray'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'dog'</span></span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">  name: <span class="string">'wang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Dog</span></span><br><span class="line"><span class="keyword">type</span> result = LookUp&lt;Cat | Dog, <span class="string">'dog'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-25"><a href="#实现方式-25" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LookUp&lt;</span><br><span class="line">  U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: <span class="built_in">string</span>; &#125;,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: T &#125; ? U : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>U extends { type: string; }</code>：这段代码限制<code>U</code>的类型必须是具有属性为<code>type</code>的对象。</li><li><code>U extends { type: T }</code>：如果把<code>T</code>的值实际带入，为<code>U extends { type: &#39;dog&#39; }</code>，表示判断<code>U</code>中的<code>type</code>值是不是<code>dog</code>，是则返回<code>U</code>。</li></ul><h3 id="Trim、TrimLeft以及TrimRight"><a href="#Trim、TrimLeft以及TrimRight" class="headerlink" title="Trim、TrimLeft以及TrimRight"></a>Trim、TrimLeft以及TrimRight</h3><p>TrimLeft：<link-and-solution num="106"><br>TrimRight：<link-and-solution num="4803"><br>Trim：<link-and-solution num="108"></link-and-solution></link-and-solution></link-and-solution></p><h4 id="用法-26"><a href="#用法-26" class="headerlink" title="用法"></a>用法</h4><p><code>Trim</code>、<code>TrimLeft</code>以及<code>TrimRight</code>这几个工具比较好理解，它们都是用来移除字符串中的空白符的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = TrimLeft&lt;<span class="string">' str'</span>&gt;  <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t2 = Trim&lt;<span class="string">' str '</span>&gt;     <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t3 = TrimRight&lt;<span class="string">'str '</span>&gt; <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-26"><a href="#实现方式-26" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">' '</span> | <span class="string">'\n'</span> | <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? TrimLeft&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> (<span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> | <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span>) ? Trim&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> TrimRight&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span> ? TrimRight&lt;R&gt; : S</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>TrimLeft</code>和<code>TrimRight</code>的实现思路是相同的，区别在于空白符的占位出现在左侧还是右侧。</li><li><code>Trim</code>的实现就是把<code>TrimLeft</code>和<code>TrimRight</code>所做的事情结合起来。</li></ul><h3 id="Capitalize-首字母大写-和UnCapitalize-首字母小写"><a href="#Capitalize-首字母大写-和UnCapitalize-首字母小写" class="headerlink" title="Capitalize(首字母大写)和UnCapitalize(首字母小写)"></a>Capitalize(首字母大写)和UnCapitalize(首字母小写)</h3><p><link-and-solution num="110"></link-and-solution></p><h4 id="用法-27"><a href="#用法-27" class="headerlink" title="用法"></a>用法</h4><p><code>Capitalize</code>是用来将一个字符串的首字母变成大写的，而<code>UnCapitalize</code>所做的事情跟它相反，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = Capitalize&lt;<span class="string">'hello'</span>&gt;   <span class="comment">// 'Hello'</span></span><br><span class="line"><span class="keyword">type</span> t2 = UnCapitalize&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-27"><a href="#实现方式-27" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br><span class="line"><span class="keyword">type</span> UnCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>无论是<code>Capitalize</code>还是<code>UnCapitalize</code>，它们都依赖内置的工具函数<code>Uppercase</code>或者<code>Lowercase</code>。对于<code>Capitalize</code>而言，我们只需要把首字母隔离出来，然后调用<code>Uppercase</code>即可。对于<code>UnCapitalize</code>而言，我们把首字母调用<code>Lowercase</code>即可。</li></ul><h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><p><link-and-solution num="116"></link-and-solution></p><h4 id="用法-28"><a href="#用法-28" class="headerlink" title="用法"></a>用法</h4><p><code>Replace</code>是用来将字符串中第一次出现的某段内容，使用指定的字符串进行替换，而<code>ReplaceAll</code>是全部替换，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：'foofoobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： foobarbar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">''</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-28"><a href="#实现方式-28" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><p><link-and-solution num="119"></link-and-solution></p><h4 id="用法-29"><a href="#用法-29" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceAll</code>是用来将字符串中指定字符全部替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'foofoofoo'</span></span><br><span class="line"><span class="keyword">type</span> t = ReplaceAll&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-29"><a href="#实现方式-29" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceAll&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;ReplaceAll&lt;L, <span class="keyword">from</span>, to&gt;&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;ReplaceAll&lt;R, <span class="keyword">from</span>, to&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="AppendArgument-追加参数"><a href="#AppendArgument-追加参数" class="headerlink" title="AppendArgument(追加参数)"></a>AppendArgument(追加参数)</h3><p><link-and-solution num="191"></link-and-solution></p><h4 id="用法-30"><a href="#用法-30" class="headerlink" title="用法"></a>用法</h4><p><code>AppendArgument</code>是用来向一个函数追加一个参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结果：(a: number, b: number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> result = AppendArgument&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-30"><a href="#实现方式-30" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendArgument&lt;Fn, A&gt; = Fn <span class="keyword">extends</span> (...args: infer R) =&gt; infer T ? <span class="function">(<span class="params">...args: [...R, A]</span>) =&gt;</span> T : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>我们首先利用<code>infer</code>关键词得到了<code>Fn</code>函数的参数类型以及返回类型，然后把新的参数添加到参数列表，并原样返回其函数类型。</li></ul><h3 id="Permutation-排列组合"><a href="#Permutation-排列组合" class="headerlink" title="Permutation(排列组合)"></a>Permutation(排列组合)</h3><p><link-and-solution num="296"></link-and-solution></p><h4 id="用法-31"><a href="#用法-31" class="headerlink" title="用法"></a>用法</h4><p><code>Permutation</code>是用来将联合类型中的每一个类型进行排列组合，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['A', 'B'] | ['B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result1 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result2 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-31"><a href="#实现方式-31" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Permutation&lt;T, U = T&gt; = </span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [T, ...Permutation&lt;Exclude&lt;U, T&gt;&gt;]</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>[T] extends [never]</code>：这段代码主要是为了处理联合类型为空的情况。</li><li><code>T extends U</code>：这段代码主要是需要使用<strong>分布式条件类型</strong>这个知识点，当<code>T extends U</code>成立时，在其后的判断语句中，<code>T</code>代表当前迭代的类型。</li><li><code>&lt;Exclude&lt;U, T&gt;</code>：因为此时的<code>T</code>代表当前迭代的类型，所以我们从原始联合类型中排除当前类型，然后递归调用<code>Permutation</code>。当<code>T</code>为<code>A</code>时，递归调用<code>Permutation&lt;&#39;B&#39; | &#39;C&#39;&gt;</code>, 此时结果为<code>[&#39;A&#39;]</code> + <code>[&#39;B&#39;, &#39;C&#39;]</code> 或 <code>[&#39;A&#39;]</code> + <code>[&#39;C&#39;, &#39;B&#39;]</code>。</li></ul><h3 id="LengthOfString-字符串的长度"><a href="#LengthOfString-字符串的长度" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="298"></link-and-solution></p><h4 id="用法-32"><a href="#用法-32" class="headerlink" title="用法"></a>用法</h4><p><code>LengthOfString</code>是用来计算一个字符串长度的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-32"><a href="#实现方式-32" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;R, [...T, Char]&gt;</span><br><span class="line">      : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>我们通过一个泛型的辅助数组来帮计算字符串的长度，在第一次符合条件时，将其第一个字符添加到数组中，在后续的递归过程中，如果不符合条件，直接返回<code>T[&#39;length&#39;]</code>，这个过程可以用如下代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>], S = <span class="string">'hello'</span>, R = <span class="string">'ello'</span></span><br><span class="line"><span class="comment">// 第二次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>], S = <span class="string">'ello'</span>, R = <span class="string">'llo'</span></span><br><span class="line"><span class="comment">// 第三次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>], S = <span class="string">'llo'</span>, R = <span class="string">'lo'</span></span><br><span class="line"><span class="comment">// 第四次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>], S = <span class="string">'lo'</span>, R = <span class="string">'o'</span></span><br><span class="line"><span class="comment">// 第五次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>, <span class="string">'o'</span>], S = <span class="string">'o'</span>, R = <span class="string">''</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Flatten-数组降维"><a href="#Flatten-数组降维" class="headerlink" title="Flatten(数组降维)"></a>Flatten(数组降维)</h3><p><link-and-solution num="459"></link-and-solution></p><h4 id="用法-33"><a href="#用法-33" class="headerlink" title="用法"></a>用法</h4><p><code>Flatten</code>是用来将多维数组进行降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Flatten&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>]]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-33"><a href="#实现方式-33" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer L, ...infer R]</span><br><span class="line">      ? L <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">        ? [...Flatten&lt;L&gt;, ...Flatten&lt;R&gt;]</span><br><span class="line">        : [L, ...Flatten&lt;R&gt;]</span><br><span class="line">      : []</span><br></pre></td></tr></table></figure><p>代码详解：<code>Flatten</code>数组降维的主要思路是，遍历数组中的每一个元素，判断其是否为一个数组，如果是，则递归调用<code>Flatten</code>，进行降维。</p><h3 id="AppendToObject-对象添加新属性"><a href="#AppendToObject-对象添加新属性" class="headerlink" title="AppendToObject(对象添加新属性)"></a>AppendToObject(对象添加新属性)</h3><p><link-and-solution num="527"></link-and-solution></p><h4 id="用法-34"><a href="#用法-34" class="headerlink" title="用法"></a>用法</h4><p><code>AppendToObject</code>是用来向指定对象添加一个额外的属性(<code>key/value</code>)，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = AppendToObject&lt;&#123; id: <span class="built_in">number</span>; &#125;, <span class="string">'name'</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-34"><a href="#实现方式-34" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> basicKeyType = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line"><span class="keyword">type</span> AppendToObject&lt;T, K <span class="keyword">extends</span> basicKeyType, V&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T | K]: P <span class="keyword">extends</span> keyof T ? T[P] : V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>basicKeyType</code>：在<code>JavaScript</code>中，因为一个对象的属性只能是<code>string</code>、<code>number</code>或者<code>symbol</code>这三种类型，所以我们限定<code>K</code>必须满足此条件。</li><li><code>keyof T | K</code>：这里表示<code>keyof T</code>的联合类型和<code>K</code>，组合成一个新的联合类型。</li></ul><h3 id="Absolute-绝对值"><a href="#Absolute-绝对值" class="headerlink" title="Absolute(绝对值)"></a>Absolute(绝对值)</h3><p><link-and-solution num="529"></link-and-solution></p><h4 id="用法-35"><a href="#用法-35" class="headerlink" title="用法"></a>用法</h4><p><code>Absolute</code>是用来取一个数的绝对值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1："531"</span></span><br><span class="line"><span class="keyword">type</span> result1 = Absolute&lt;<span class="number">-531</span>&gt;</span><br><span class="line"><span class="comment">// 结果2："9999"</span></span><br><span class="line"><span class="keyword">type</span> result2 = Absolute&lt;<span class="number">9</span>_999n&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-35"><a href="#实现方式-35" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberLike = <span class="built_in">number</span> | <span class="built_in">string</span> | bigint</span><br><span class="line"><span class="keyword">type</span> Absolute&lt;T <span class="keyword">extends</span> NumberLike&gt; =  <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`-<span class="subst">$&#123;infer N&#125;</span>`</span> ? N : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>NumberLike</code>：我们认为<code>&#39;1&#39;</code>和<code>1</code>都是一个合法的数字，所以定义一个辅助的<code>NumberList</code>联合类型。</li><li><code>${T}</code> extends <code>-${infer N}</code>：这里判断我们传递的数字是否为负数，如果是则直接取其正数部分，否则直接返回。</li></ul><p><strong>注意</strong>：这里说到的取绝对值，最后的结果之所以是一个字符串类型，是因为<code>TS</code>对递归次数有限制。如果你想要真正的数字类型，可以考虑实现一个<code>MakeArray</code>辅助方法，使用此方法可以将字符串类型的数字，转换成一个真正的数字类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; =</span><br><span class="line">  N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span></span><br><span class="line">  ? T</span><br><span class="line">  : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = MakeArray&lt;<span class="string">'3'</span>&gt;[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="StringToArray-字符串转数组"><a href="#StringToArray-字符串转数组" class="headerlink" title="StringToArray(字符串转数组)"></a>StringToArray(字符串转数组)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-36"><a href="#用法-36" class="headerlink" title="用法"></a>用法</h4><p><code>StringToArray</code>是用来将一个字符串转换成一个数组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToArray&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-36"><a href="#实现方式-36" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToArray&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? StringToArray&lt;R, [...U, Char]&gt;</span><br><span class="line">      : U</span><br></pre></td></tr></table></figure><p>代码详解：<code>StringToArray</code>的实现主要是使用了递归的思想，它每次拿到字符串中一个字符，然后存入一个辅助数组中，当字符串为空时，直接返回这个辅助数组。</p><h3 id="StringToUnion-字符串转联合类型"><a href="#StringToUnion-字符串转联合类型" class="headerlink" title="StringToUnion(字符串转联合类型)"></a>StringToUnion(字符串转联合类型)</h3><p><link-and-solution num="531"></link-and-solution></p><h4 id="用法-37"><a href="#用法-37" class="headerlink" title="用法"></a>用法</h4><p>在实现<code>StringToArray</code>后，我们能够很容易实现<code>StringToUnion</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'h' | 'e' | 'l' | 'l' | 'o'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-37"><a href="#实现方式-37" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 递归思想</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? Char | StringToUnion&lt;R&gt;</span><br><span class="line">      : never</span><br><span class="line"><span class="comment">// way2: 借用StringToArray</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = StringToArray&lt;S&gt;[<span class="built_in">number</span>]</span><br></pre></td></tr></table></figure><p>代码详解：<code>StringToArray&lt;S&gt;</code>返回的是一个数组，<code>T[number]</code>表示对一个数组进行数字类型索引迭代，其迭代结果是每个元素组合成的一个联合类型。</p><h3 id="Merge-类型合并"><a href="#Merge-类型合并" class="headerlink" title="Merge(类型合并)"></a>Merge(类型合并)</h3><p><link-and-solution num="599"></link-and-solution></p><h4 id="用法-38"><a href="#用法-38" class="headerlink" title="用法"></a>用法</h4><p><code>Merge</code>是用来合并两个类型，如果有重复的字段类型，则第二个的字段类型覆盖第一个的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">  c: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Merge&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-38"><a href="#实现方式-38" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Merge&lt;F, S&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof F | keyof S]: P <span class="keyword">extends</span> keyof S ? S[P] : P <span class="keyword">extends</span> keyof F ? F[P] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>keyof F | keyof S</code>：这段代码的含义是将<code>F</code>和<code>S</code>这两个对象的键组合成一个新的联合类型。</li><li><code>P extends</code>：这里进行了两次<code>extends</code>判断，其中第二次不能直接写成<code>F[P]</code>，而应该多判断一次，当满足条件时才使用<code>F[P]</code>，这是因为<code>P</code>的类型判断无法作用于<code>:</code>符号后面。</li></ul><h3 id="KebabCase-字符串转连字符"><a href="#KebabCase-字符串转连字符" class="headerlink" title="KebabCase(字符串转连字符)"></a>KebabCase(字符串转连字符)</h3><p><link-and-solution num="612"></link-and-solution></p><h4 id="用法-39"><a href="#用法-39" class="headerlink" title="用法"></a>用法</h4><p><code>KebabCase</code>是用来将驼峰形式字符串，转成连字符形式字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：foo-bar-baz</span></span><br><span class="line"><span class="keyword">type</span> result = KebabCase&lt;<span class="string">'FooBarBaz'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-39"><a href="#实现方式-39" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KebabCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? S2 <span class="keyword">extends</span> Uncapitalize&lt;S2&gt;</span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span><span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span>-<span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="Diff-类型差异部分"><a href="#Diff-类型差异部分" class="headerlink" title="Diff(类型差异部分)"></a>Diff(类型差异部分)</h3><p><link-and-solution num="645"></link-and-solution></p><h4 id="用法-40"><a href="#用法-40" class="headerlink" title="用法"></a>用法</h4><p><code>Diff</code>是用来获取两个类型的不同部分的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; id: number; gender: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Diff&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-40"><a href="#实现方式-40" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiffKeys&lt;T, U&gt; = Exclude&lt;keyof T | keyof U, keyof (T | U)&gt;</span><br><span class="line"><span class="keyword">type</span> Diff&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> DiffKeys&lt;T, U&gt;]: K <span class="keyword">extends</span> keyof T ? T[K] : K <span class="keyword">extends</span> keyof U ? U[K] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>keyof Foo | keyof Bar</code>：这段代码是把<code>T</code>和<code>U</code>中的所有属性组合成一个新的联合类型。</li><li><code>keyof (T | U)</code>：这段代码是取<code>T</code>和<code>U</code>的公共属性。</li><li><code>Exclude&lt;K1, K2&gt;</code>：这段代码主要是用来从<code>K1</code>中排除<code>K2</code>，带入以上例子也就是排除掉所有公共属性。</li><li><code>Diff&lt;T, U&gt;</code>：在获取到<code>DiffKeys</code>后，就可以迭代的方式获取到每个属性<code>key</code>，它所对应的类型了。</li><li><code>K extends keyof U</code>：额外再判断一次，是因为<code>K</code>不能在三元表达式右侧使用。</li></ul><h3 id="AnyOf-数组元素真值判断"><a href="#AnyOf-数组元素真值判断" class="headerlink" title="AnyOf(数组元素真值判断)"></a>AnyOf(数组元素真值判断)</h3><p><link-and-solution num="949"></link-and-solution></p><h4 id="用法-41"><a href="#用法-41" class="headerlink" title="用法"></a>用法</h4><p><code>AnyOf</code>用来判断数组元素真假值的，如果任一值为真，返回<code>true</code>；数组为空或者全部为<code>false</code>，才返回<code>false</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AnyOf&lt;[<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>, &#123; name: <span class="string">'name'</span> &#125;]&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AnyOf&lt;[<span class="number">0</span>, <span class="string">''</span>, <span class="literal">false</span>, [], &#123;&#125;]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-41"><a href="#实现方式-41" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FalsyType = <span class="number">0</span> | <span class="string">''</span> | <span class="literal">false</span> | <span class="literal">undefined</span> | <span class="literal">null</span> | [] | &#123; [key: <span class="built_in">string</span>]: never &#125;</span><br><span class="line"><span class="keyword">type</span> AnyOf&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> FalsyType ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：因为我们就是要区分<code>true/false</code>，所以我们把所有为<code>false</code>的值全部列举出来，然后使用<code>T[number]</code>索引迭代，依次去跟<code>FalsyType</code>比较，其中<code>{ [key: string]: never }</code>表示空对象<code>{}</code>。</p><h3 id="IsNever-是否是Never类型"><a href="#IsNever-是否是Never类型" class="headerlink" title="IsNever(是否是Never类型)"></a>IsNever(是否是Never类型)</h3><p><link-and-solution num="1042"></link-and-solution></p><h4 id="用法-42"><a href="#用法-42" class="headerlink" title="用法"></a>用法</h4><p><code>IsNever</code>是用来判断是否为<code>never</code>类型，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsNever&lt;<span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsNever&lt;never&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result3 = IsNever&lt;never | <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-42"><a href="#实现方式-42" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 类型数组</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = T[] <span class="keyword">extends</span> never[] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 数组值</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way3: 值比较</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = Equal&lt;T, never&gt;</span><br></pre></td></tr></table></figure><h3 id="IsUnion-是否联合类型"><a href="#IsUnion-是否联合类型" class="headerlink" title="IsUnion(是否联合类型)"></a>IsUnion(是否联合类型)</h3><p><link-and-solution num="1097"></link-and-solution></p><h4 id="用法-43"><a href="#用法-43" class="headerlink" title="用法"></a>用法</h4><p><code>IsUnion</code>是用来判断一个类型是否为联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsUnion&lt;<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;never&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-43"><a href="#实现方式-43" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 排除法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [Exclude&lt;U, T&gt;] <span class="keyword">extends</span> [never]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 正反对比法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; = </span><br><span class="line">  (T <span class="keyword">extends</span> U</span><br><span class="line">    ? U <span class="keyword">extends</span> T</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : unknown</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  ) <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：上面的实现虽然代码不多，但可能无法一下子就弄明白，为了更好的理解这种实现方式，我们来看如下两个案例分析：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例一</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step1: <span class="built_in">string</span> | <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step2: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">number</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step3: <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">string</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">true</span></span><br><span class="line">result: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例二</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span></span><br><span class="line">step1: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">step2: [never] <span class="keyword">extends</span> [never] =&gt; <span class="literal">false</span></span><br><span class="line">result: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>根据之前我们学到的<strong>分布式条件类型</strong>知识，<code>T extends U</code>的时候，会把<code>T</code>进行子类型分发。</p><p>如案例一的<code>step3</code>、<code>step4</code>，在分发后会把每次迭代的结果联合起来，组合成最终的结果。</p><h3 id="ReplaceKeys-类型替换"><a href="#ReplaceKeys-类型替换" class="headerlink" title="ReplaceKeys(类型替换)"></a>ReplaceKeys(类型替换)</h3><p><link-and-solution num="1130"></link-and-solution></p><h4 id="用法-44"><a href="#用法-44" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceKeys</code>是用来在一个类型中，使用指定的Y类型来替换已经存在的T类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceKeys&lt;&#123; id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125;, <span class="string">'name'</span>, &#123; name: <span class="built_in">boolean</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-44"><a href="#实现方式-44" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceKeys&lt;U, T, Y&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof U]:</span><br><span class="line">    P <span class="keyword">extends</span> T</span><br><span class="line">      ? P <span class="keyword">extends</span> keyof Y</span><br><span class="line">        ? Y[P]</span><br><span class="line">        : never</span><br><span class="line">      : U[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RemoveIndexSignature-移除索引签名"><a href="#RemoveIndexSignature-移除索引签名" class="headerlink" title="RemoveIndexSignature(移除索引签名)"></a>RemoveIndexSignature(移除索引签名)</h3><p><link-and-solution num="1367"></link-and-solution></p><h4 id="用法-45"><a href="#用法-45" class="headerlink" title="用法"></a>用法</h4><p><code>RemoveIndexSignature</code>是用来移除一个类型中的索引签名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  foo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; foo(): void; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = RemoveIndexSignature&lt;Foo&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-45"><a href="#实现方式-45" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckIndexSignature&lt;T, P&gt; = P <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> RemoveIndexSignature&lt;T, K = PropertyKey&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never)] : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>CheckIndexSignature</code>：因为索引签名有一个特点，为<code>string | number | symbol</code>，所以我们通过<code>P extends T ? true : false</code>形式排除此索引签名。其原理如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooKeys = <span class="built_in">string</span> | <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">example1: T = <span class="string">'foo'</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">false</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">example2: T = <span class="built_in">string</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">true</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">step5: <span class="built_in">boolean</span></span><br></pre></td></tr></table></figure></li><li><p><code>as xxx</code>：在之前的案例中，我们介绍过<code>as</code>的用法，在这里有<strong>加工</strong>或<strong>再次断言</strong>的意思。在使用<code>in</code>操作符进行迭代时，对每一个<code>P</code>再使用<code>CheckIndexSignature</code>加工一下，如果是索引签名，这里的结果为<code>never</code>，为<code>never</code>时表示跳过当前迭代，进而达到排除索引签名的目的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代 P = 'foo'</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="literal">false</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; P</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代 P = string</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="built_in">boolean</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终结果</span></span><br><span class="line"><span class="keyword">type</span> result = &#123; foo(): <span class="built_in">void</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="PercentageParser-百分比解析"><a href="#PercentageParser-百分比解析" class="headerlink" title="PercentageParser(百分比解析)"></a>PercentageParser(百分比解析)</h3><p><link-and-solution num="1978"></link-and-solution></p><h4 id="用法-46"><a href="#用法-46" class="headerlink" title="用法"></a>用法</h4><p><code>PercentageParser</code>是用来解析百分比字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = PercentageParser&lt;<span class="string">'+85%'</span>&gt; <span class="comment">// ['+', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result2 = PercentageParser&lt;<span class="string">'-85%'</span>&gt; <span class="comment">// ['-', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result3 = PercentageParser&lt;<span class="string">'85'</span>&gt;   <span class="comment">// ['', '85', '']</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-46"><a href="#实现方式-46" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckPrefix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">'+'</span> | <span class="string">'-'</span> ? S : never</span><br><span class="line"><span class="keyword">type</span> CheckSuffix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>%`</span> ? [L, <span class="string">'%'</span>] : [S, <span class="string">''</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PercentageParser&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;CheckPrefix&lt;infer L&gt;&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? [L, ...CheckSuffix&lt;R&gt;]</span><br><span class="line">    : [<span class="string">''</span>, ...CheckSuffix&lt;S&gt;]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>CheckPrefix</code>是用来处理百分比字符串前面的符号的，如果存在<code>+</code>或者<code>-</code>，则原样返回，如果不存在则返回<code>never</code>，表示没有符号。</li><li><code>CheckSuffix</code>是用来处理百分比字符串后面的百分比符号的，如果存在，则返回一个数组(最后一项固定为百分比符号)；如果不存在，则返回的数组最后一个元素固定为空字符串。</li></ul><h3 id="DropChar-移除字符"><a href="#DropChar-移除字符" class="headerlink" title="DropChar(移除字符)"></a>DropChar(移除字符)</h3><p><link-and-solution num="2070"></link-and-solution></p><h4 id="用法-47"><a href="#用法-47" class="headerlink" title="用法"></a>用法</h4><p><code>DropChar</code>是用来在字符串中移除指定字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：butterfly!</span></span><br><span class="line"><span class="keyword">type</span> result = DropChar&lt;<span class="string">' b u t t e r f l y ! '</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-47"><a href="#实现方式-47" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropChar&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = C <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? DropChar&lt;<span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;R&#125;</span>`</span>, C&gt;</span><br><span class="line">    : S</span><br></pre></td></tr></table></figure><p>代码详解：<code>DropChar</code>和<code>ReplaceAll</code>的实现思路非常相似，首先需要判断待移除的字符是不是空字符串，如果是，则直接返回原始字符串；如果不是，先判断字符串中是否包含待移除的字符，包含则递归调用；不包含则直接返回原始字符串。</p><h3 id="MinusOne-减一"><a href="#MinusOne-减一" class="headerlink" title="MinusOne(减一)"></a>MinusOne(减一)</h3><p><link-and-solution num="2257"></link-and-solution></p><p><code>MinusOne</code>是用来实现数字减一的，其用法如下：</p><h4 id="用法-48"><a href="#用法-48" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：99</span></span><br><span class="line"><span class="keyword">type</span> result = MinusOne&lt;<span class="number">100</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-48"><a href="#实现方式-48" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinusOne&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = N <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">  ? T <span class="keyword">extends</span> [infer F, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : never</span><br><span class="line">  : MinusOne&lt;N, [<span class="number">0</span>, ...T]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：在实现<code>MinusOne</code>的时候，借用了一个空数组，首先判断数组的长度是否等于传递的数字<code>N</code>，如果相等则从数组中随意移除一位，然后返回剩下数组的长度即可；如果不相等，则往数组中添加一个元素，再递归调用<code>MinusOne</code>。</p><p><strong>注意</strong>：由于<code>TS</code>在递归调用时存在最大递归调用次数，所以对于比较大的数字会提示错误。</p><h3 id="PickByType-根据类型选取"><a href="#PickByType-根据类型选取" class="headerlink" title="PickByType(根据类型选取)"></a>PickByType(根据类型选取)</h3><p><link-and-solution num="2595"></link-and-solution></p><h4 id="用法-49"><a href="#用法-49" class="headerlink" title="用法"></a>用法</h4><p><code>PickByType</code>是用来根据类型选取属性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; isReadonly: boolean, isEnable: boolean &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = PickByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-49"><a href="#实现方式-49" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PickByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> U ? P : never]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：<code>PickByType</code>的实现，可以使用<code>as</code>进行第二次断言，当类型满足时就返回当前迭代的<code>P</code>，不满足类型时就返回<code>never</code>，因为<code>never</code>最后会被排除，所以最后的迭代结果只有满足类型的键。</p><h3 id="StartsWith-字符串startsWith方法"><a href="#StartsWith-字符串startsWith方法" class="headerlink" title="StartsWith(字符串startsWith方法)"></a>StartsWith(字符串startsWith方法)</h3><p><link-and-solution num="2688"></link-and-solution></p><h4 id="用法-50"><a href="#用法-50" class="headerlink" title="用法"></a>用法</h4><p><code>StartsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>startsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = StartsWith&lt;<span class="string">'abc'</span>, <span class="string">'ab'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-50"><a href="#实现方式-50" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StartsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="EndsWith-字符串endsWith方法"><a href="#EndsWith-字符串endsWith方法" class="headerlink" title="EndsWith(字符串endsWith方法)"></a>EndsWith(字符串endsWith方法)</h3><p><link-and-solution num="2693"></link-and-solution></p><h4 id="用法-51"><a href="#用法-51" class="headerlink" title="用法"></a>用法</h4><p><code>EndsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>endsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = endsWith&lt;<span class="string">'abc'</span>, <span class="string">'bc'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-51"><a href="#实现方式-51" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EndsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;C&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="PartialByKeys-按需可选"><a href="#PartialByKeys-按需可选" class="headerlink" title="PartialByKeys(按需可选)"></a>PartialByKeys(按需可选)</h3><p><link-and-solution num="2757"></link-and-solution></p><h4 id="用法-52"><a href="#用法-52" class="headerlink" title="用法"></a>用法</h4><p><code>PartialByKeys</code>是用来实现按需可选的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> UserPartialName &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserPartialName</span></span><br><span class="line"><span class="keyword">type</span> result = PartialByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-52"><a href="#实现方式-52" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PartialByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Omit</code>部分：根据之前介绍的<code>Omit</code>的知识，<code>Omit&lt;T, K&gt;</code>表示从<code>T</code>中剔除含有<code>K</code>的类型。</li><li><code>CopyKeys</code>部分：如果不使用<code>CopyKeys</code>，最后的结果为<code>T &amp; U</code>形式，它实际上与使用<code>CopyKeys</code>的结果是一样的。这里使用<code>CopyKeys</code>，很大程度上是为了测试。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用CopyKeys，结果为true；不使用，结果为false</span></span><br><span class="line"><span class="keyword">type</span> result1 = Equal&lt;PartialByKeys&lt;User, <span class="string">'name'</span>&gt;, UserPartialName&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RequiredByKeys-按需必填"><a href="#RequiredByKeys-按需必填" class="headerlink" title="RequiredByKeys(按需必填)"></a>RequiredByKeys(按需必填)</h3><p><link-and-solution num="2759"></link-and-solution></p><p>在实现<code>PartialByKeys</code>后，很容易按照相同的思路去实现<code>RequiredByKeys</code>。</p><h4 id="用法-53"><a href="#用法-53" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredByKeys</code>是用来实现按需必填的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UserRequiredName &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserRequiredName</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-53"><a href="#实现方式-53" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequiredByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]-?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：实现思路参考<code>PartialByKeys</code>。</p><h3 id="Mutable-可改"><a href="#Mutable-可改" class="headerlink" title="Mutable(可改)"></a>Mutable(可改)</h3><p><link-and-solution num="2793"></link-and-solution></p><h4 id="用法-54"><a href="#用法-54" class="headerlink" title="用法"></a>用法</h4><p><code>Mutable</code>是用来让所有属性变为可改的(移除<code>readonly</code>关键词)，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> MutableResult = MyMutable&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-54"><a href="#实现方式-54" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMutable&lt;T&gt; = &#123;</span><br><span class="line">  -readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：</p><ul><li><code>-readonly</code>：表示把<code>readonly</code>关键词去掉，去掉之后此字段变为可改的。</li></ul><h3 id="OmitByType-按类型移除"><a href="#OmitByType-按类型移除" class="headerlink" title="OmitByType(按类型移除)"></a>OmitByType(按类型移除)</h3><p><link-and-solution num="2852"></link-and-solution></p><p><code>OmitByType</code>的实现思路和<code>PickByType</code>类似。</p><h4 id="用法-55"><a href="#用法-55" class="headerlink" title="用法"></a>用法</h4><p><code>OmitByType</code>是用来按照类型移除的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ModelOmitBoolean &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelOmitBoolean</span></span><br><span class="line"><span class="keyword">type</span> result = OmitByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-55"><a href="#实现方式-55" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OmitByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> U <span class="keyword">extends</span> T[P] ? never : P]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：实现思路参考<code>PickByType</code>。</p><h3 id="ObjectEntries"><a href="#ObjectEntries" class="headerlink" title="ObjectEntries"></a>ObjectEntries</h3><p><link-and-solution num="2946"></link-and-solution></p><h4 id="用法-56"><a href="#用法-56" class="headerlink" title="用法"></a>用法</h4><p><code>ObjectEntries</code>是用来实现<code>JavaScript</code>中的<code>Object.entries()</code>方法，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  locations?: <span class="built_in">string</span>[] | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ModelEntries = [<span class="string">'name'</span>, <span class="built_in">string</span>] | [<span class="string">'age'</span>, <span class="built_in">number</span>] | [<span class="string">'locations'</span>, <span class="built_in">string</span>[] | <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelEntries</span></span><br><span class="line"><span class="keyword">type</span> result = ObjectEntries&lt;Model&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-56"><a href="#实现方式-56" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RemoveUndefined&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="literal">undefined</span>] ? T : Exclude&lt;T, <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">type</span> ObjectEntries&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: &#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? [P, RemoveUndefined&lt;T[P]&gt;] : [P, T[P]]</span><br><span class="line">&#125;[keyof T]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>RemoveUndefined</code>：当<code>T</code>仅为<code>undefined</code>，表示原始类型就是<code>undefined</code>; 当<code>T</code>为联合类型时，移除联合类型中的<code>undefined</code>。</li><li><code>[P in keyof T]-?</code>:  表示移除可选属性。</li><li><code>{} extends Pick&lt;T, P&gt;</code>: 判断当前的<code>P</code>是否为可选属性，是的话就是使用<code>RemoveUndefined</code>移除其中的<code>undefined</code>，否则取原始类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果都为true</span></span><br><span class="line"><span class="keyword">type</span> result1 = &#123;&#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; name: <span class="built_in">string</span>; &#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Shift-数组shift方法"><a href="#Shift-数组shift方法" class="headerlink" title="Shift(数组shift方法)"></a>Shift(数组shift方法)</h3><p><link-and-solution num="3062"></link-and-solution></p><h4 id="用法-57"><a href="#用法-57" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift结果：[2, 3]</span></span><br><span class="line"><span class="keyword">type</span> shiftResult = Shift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-57"><a href="#实现方式-57" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift实现</span></span><br><span class="line"><span class="keyword">type</span> Shift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer F, ...infer R] ? R : []</span><br></pre></td></tr></table></figure><h3 id="TupleToNestedObject-元组转嵌套对象"><a href="#TupleToNestedObject-元组转嵌套对象" class="headerlink" title="TupleToNestedObject(元组转嵌套对象)"></a>TupleToNestedObject(元组转嵌套对象)</h3><p><link-and-solution num="3188"></link-and-solution></p><h4 id="用法-58"><a href="#用法-58" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToNestedObject</code>是用来将元组转成嵌套对象的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; a: &#123; b: string; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToNestedObject&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-58"><a href="#实现方式-58" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToNestedObject&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">    ? &#123; [P <span class="keyword">in</span> F &amp; <span class="built_in">string</span>]: TupleToNestedObject&lt;R, U&gt; &#125;</span><br><span class="line">    : U</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>F &amp; string</code>: 等价于如下代码：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &amp; <span class="built_in">string</span> = F <span class="keyword">extends</span> <span class="built_in">string</span> ? F : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p><link-and-solution num="3192"></link-and-solution></p><h4 id="用法-59"><a href="#用法-59" class="headerlink" title="用法"></a>用法</h4><p><code>Reverse</code>是用来实现数组的<code>reverse()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['b', 'a']</span></span><br><span class="line"><span class="keyword">type</span> result = Reverse&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-59"><a href="#实现方式-59" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reverse&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [...infer R, infer L]</span><br><span class="line">    ? [L, ...Reverse&lt;R&gt;]</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><h3 id="FlipArguments-反转函数参数类型"><a href="#FlipArguments-反转函数参数类型" class="headerlink" title="FlipArguments(反转函数参数类型)"></a>FlipArguments(反转函数参数类型)</h3><p><link-and-solution num="3196"></link-and-solution></p><p>借助上面的<code>Reverse</code>方法，可以很容易实现函数参数的反转。</p><h4 id="用法-60"><a href="#用法-60" class="headerlink" title="用法"></a>用法</h4><p><code>FlipArguments</code>是用来实现反转函数参数类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：(a: number, b: string) =&gt; string | number</span></span><br><span class="line"><span class="keyword">type</span> result = FlipArguments&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-60"><a href="#实现方式-60" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlipArguments&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> (...args: infer A) =&gt; infer R</span><br><span class="line">    ? <span class="function">(<span class="params">...args: Reverse&lt;A&gt;</span>) =&gt;</span> R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><h3 id="FlattenDepth-数组按深度降维"><a href="#FlattenDepth-数组按深度降维" class="headerlink" title="FlattenDepth(数组按深度降维)"></a>FlattenDepth(数组按深度降维)</h3><p><link-and-solution num="3243"></link-and-solution></p><h4 id="用法-61"><a href="#用法-61" class="headerlink" title="用法"></a>用法</h4><p><code>FlattenDepth</code>是用来按深度进行数组降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4, [5]]</span></span><br><span class="line"><span class="keyword">type</span> result = FlattenDepth&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[[<span class="number">5</span>]]]], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-61"><a href="#实现方式-61" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlattenDepth&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">1</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? U[<span class="string">'length'</span>] <span class="keyword">extends</span> D</span><br><span class="line">    ? T</span><br><span class="line">    : F <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? [...FlattenDepth&lt;F, D, [<span class="number">0</span>, ...U]&gt;, ...FlattenDepth&lt;R, D&gt;]</span><br><span class="line">      : [F, ...FlattenDepth&lt;R, D, U&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure><p>代码详解：<code>FlattenDepth</code>的实现思路和<code>Flatten</code>基本一致，区别是按深度降维时需要一个数组去记录降维的次数(深度)。</p><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><link-and-solution num="3326"></link-and-solution></p><h4 id="用法-62"><a href="#用法-62" class="headerlink" title="用法"></a>用法</h4><p><code>BEM</code>是用来将字符串连接成CSS BEM格式的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'btn__primary--small' | 'btn__primary--mini' </span></span><br><span class="line"><span class="keyword">type</span> result = BEM&lt;<span class="string">'btn'</span>, [<span class="string">'primary'</span>], [<span class="string">'small'</span>, <span class="string">'mini'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-62"><a href="#实现方式-62" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArrayToString&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [] ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;T[<span class="built_in">number</span>]&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BEM&lt;</span><br><span class="line">  B <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="built_in">string</span>[],</span><br><span class="line">  M <span class="keyword">extends</span> <span class="built_in">string</span>[]</span><br><span class="line">&gt; = <span class="string">`<span class="subst">$&#123;B&#125;</span><span class="subst">$&#123;ArrayToString&lt;E, <span class="string">'--'</span>&gt;&#125;</span><span class="subst">$&#123;ArrayToString&lt;M, <span class="string">'__'</span>&gt;&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>代码详解：实现<code>BEM</code>的思路并不复杂，只需要记住如下两个知识点：</p><ul><li>判断是一个空数组，可以使用<code>T extends []</code>或者<code>T[&#39;length&#39;] extends 0</code>。</li><li><code>T[number]</code>会自动迭代数组，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果: 'A__B' | 'A__C' | 'A__D'</span></span><br><span class="line"><span class="keyword">type</span> result = <span class="string">`A__<span class="subst">$&#123;[<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>][<span class="built_in">number</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="InOrderTraversal-中序遍历"><a href="#InOrderTraversal-中序遍历" class="headerlink" title="InOrderTraversal(中序遍历)"></a>InOrderTraversal(中序遍历)</h3><p><link-and-solution num="3376"></link-and-solution></p><p><strong>先序遍历</strong>：<code>PreOrderTraversal</code>先访问根节点，然后访问左节点，最后访问右节点。<br><br><strong>中序遍历</strong>：<code>InOrderTraversal</code>先访问左节点，然后访问根节点，最后访问右节点。<br><br><strong>后序遍历</strong>：<code>PostOrderTraversal</code>先访问左节点，然后访问右节点，最后访问根节点。</p><h4 id="用法-63"><a href="#用法-63" class="headerlink" title="用法"></a>用法</h4><p><code>InOrderTraversal</code>是用来实现二叉树中序遍历的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  left: <span class="literal">null</span>,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: <span class="number">3</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: [1, 3, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = InOrderTraversal&lt;<span class="keyword">typeof</span> tree&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-63"><a href="#实现方式-63" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个二叉树节点</span></span><br><span class="line"><span class="keyword">interface</span> TreeNode &#123;</span><br><span class="line">  val: <span class="built_in">number</span>;</span><br><span class="line">  left: TreeNode | <span class="literal">null</span>;</span><br><span class="line">  right: TreeNode | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PreOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [T[<span class="string">'val'</span>], ...PreOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PreOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 中序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> InOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...InOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, T[<span class="string">'val'</span>], ...InOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 后序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PostOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...PostOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PostOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;, T[<span class="string">'val'</span>]]</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>[T] extends [TreeNode]</code>: 使用此形式而不用<code>T extends TreeNode</code>，这是因为<code>T</code>是一个<code>TreeNode | null</code>，在左侧会进行分布式条件类型，判断两次：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果Tree嵌套比较深的话，ts会报错</span></span><br><span class="line">TreeNode <span class="keyword">extends</span> TreeNode |</span><br><span class="line"><span class="literal">null</span> <span class="keyword">extends</span> TreeNode</span><br></pre></td></tr></table></figure></li><li><p>遍历方式：根据先序遍历<code>PreOrderTraversal</code>、中序遍历<code>InOrderTraversal</code>、后序遍历<code>PostOrderTraversal</code>的定义，只需要在递归的时候处理其访问顺序即可。</p></li></ul><h3 id="FlipObject-对象键值交换"><a href="#FlipObject-对象键值交换" class="headerlink" title="FlipObject(对象键值交换)"></a>FlipObject(对象键值交换)</h3><p><link-and-solution num="4179"></link-and-solution></p><h4 id="用法-64"><a href="#用法-64" class="headerlink" title="用法"></a>用法</h4><p><code>FlipObject</code>是用来将对象的键值交换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; pi: 'a' &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = FlipObject&lt;&#123; a: <span class="string">'pi'</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-64"><a href="#实现方式-64" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> FlipObject&lt;T <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, BasicType&gt;&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;T[P]&#125;</span>`</span>]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fibonacci-斐波那契数列"><a href="#Fibonacci-斐波那契数列" class="headerlink" title="Fibonacci(斐波那契数列)"></a>Fibonacci(斐波那契数列)</h3><p><link-and-solution num="4182"></link-and-solution></p><p><strong>菲波那切数列</strong>：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…</p><h4 id="用法-65"><a href="#用法-65" class="headerlink" title="用法"></a>用法</h4><p><code>Fibonacci</code>是用来实现斐波那契数列的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = Fibonacci&lt;<span class="number">5</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-65"><a href="#实现方式-65" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fibonacci&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>],</span><br><span class="line">  Prev <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Current <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>]</span><br><span class="line">&gt; = Index[<span class="string">'length'</span>] <span class="keyword">extends</span> N</span><br><span class="line">  ? Current[<span class="string">'length'</span>]</span><br><span class="line">  : Fibonacci&lt;N, [...Index, <span class="number">1</span>], Current, [...Prev, ...Current]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Index</code>：标记当前数列是第几项，从1开始。</li><li><code>Prev</code>：存储数列上一次计算的值，从0开始。</li><li><code>Current</code>: 标记当前数列的值，根据数列的特点，第N项的值，等于<code>N - 1</code>项 + <code>N - 2</code>项的值，即：<code>Current = [...Prev, ...Current]</code></li></ul><h3 id="AllCombinations-全排列"><a href="#AllCombinations-全排列" class="headerlink" title="AllCombinations(全排列)"></a>AllCombinations(全排列)</h3><p><link-and-solution num="4260"></link-and-solution></p><h4 id="用法-66"><a href="#用法-66" class="headerlink" title="用法"></a>用法</h4><p><code>AllCombinations</code>是用来列举全部排列组合可能性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'' | 'A' | 'AB' | 'B' | 'BA'</span></span><br><span class="line"><span class="keyword">type</span> result = AllCombinations&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-66"><a href="#实现方式-66" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? F | StringToUnion&lt;R&gt;</span><br><span class="line">    : never</span><br><span class="line"><span class="keyword">type</span> Combination&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span>,</span><br><span class="line">  K = S</span><br><span class="line">&gt; = [S] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? U</span><br><span class="line">  : K <span class="keyword">extends</span> S</span><br><span class="line">    ? Combination&lt;Exclude&lt;S, K&gt;, U | <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;K&#125;</span>`</span>&gt;</span><br><span class="line">    : U</span><br><span class="line"><span class="keyword">type</span> AllCombinations&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Combination&lt;StringToUnion&lt;S&gt;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>StringToUnion</code>是用来将字符串变成一个联合类型的，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 'A' | 'B'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Combination</code>是用来将联合类型进行排列组合的，以以上<code>&#39;A&#39; | &#39;B&#39;</code>这个联合类型为例，步骤如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：从'A' | 'B这个联合类型中排除当前迭代的字符'A'</span></span><br><span class="line">K = <span class="string">'A'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span>  =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'A'</span>&gt;</span><br><span class="line"><span class="comment">// 第一步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'B'</span>, <span class="string">''</span> | <span class="string">'A'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'A'</span>&#125;</span>B`</span> =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'AB'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：从'A' | 'B'这个联合类型中排除当前迭代的字符'B'</span></span><br><span class="line">K = <span class="string">'B'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span> =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 第二步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'A'</span>, <span class="string">''</span> | <span class="string">'B'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'B'</span>&#125;</span>A`</span> =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">'A'</span> | <span class="string">'BA'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：剔除相同元素</span></span><br><span class="line">result = <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'AB'</span> | <span class="string">'B'</span> | <span class="string">'BA'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="GreaterThan-大于"><a href="#GreaterThan-大于" class="headerlink" title="GreaterThan(大于)"></a>GreaterThan(大于)</h3><p><link-and-solution num="4425"></link-and-solution></p><h4 id="用法-67"><a href="#用法-67" class="headerlink" title="用法"></a>用法</h4><p><code>GreaterThan&lt;T, N&gt;</code>是来用判断正整数T是否大于正整数N的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = GreaterThan&lt;<span class="number">2</span>, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-67"><a href="#实现方式-67" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果比较的数比较大，会提示：Type instantiation is excessively deep and possibly infinite</span></span><br><span class="line"><span class="keyword">type</span> GreaterThan&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : N <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : GreaterThan&lt;T, N, [...R, <span class="number">0</span>]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：使用一个空数组来辅助，每次递归添加一个元素，如果正整数<code>T</code>先等于这个数组的长度，则为<code>false</code>；如果正整数<code>N</code>先等于这个数组的长度，则为<code>true</code>。</p><h3 id="Zip-按位置匹配"><a href="#Zip-按位置匹配" class="headerlink" title="Zip(按位置匹配)"></a>Zip(按位置匹配)</h3><p><link-and-solution num="4471"></link-and-solution></p><h4 id="用法-68"><a href="#用法-68" class="headerlink" title="用法"></a>用法</h4><p><code>Zip</code>是用来将两个元组按照相同索引位置组合成一个新数组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, true], [2, false]]</span></span><br><span class="line"><span class="keyword">type</span> result = Zip&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="literal">true</span>, <span class="literal">false</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-68"><a href="#实现方式-68" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zip&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? U <span class="keyword">extends</span> [infer Head, ...infer Tail]</span><br><span class="line">      ? [[First, Head], ...Zip&lt;Rest, Tail&gt;]</span><br><span class="line">      : []</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><h3 id="IsTuple-是否为元组"><a href="#IsTuple-是否为元组" class="headerlink" title="IsTuple(是否为元组)"></a>IsTuple(是否为元组)</h3><p><link-and-solution num="4484"></link-and-solution></p><h4 id="用法-69"><a href="#用法-69" class="headerlink" title="用法"></a>用法</h4><p><code>IsTuple</code>是用来判断是否为一个元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = IsTuple&lt;[<span class="built_in">number</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-69"><a href="#实现方式-69" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsTuple&lt;T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">      ? <span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码解析：以上代码中，比较关键的代码是<code>number extends T[&#39;length&#39;]</code>，这里不能写成<code>T[&#39;length&#39;] extends number</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1：需要返回false，因为它不定长，违反了元组的定义</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsTuple&lt;<span class="built_in">number</span>[]&gt;</span><br><span class="line"><span class="comment">// case2：需要返回true，因为它定长，只不过长度为0</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsTuple&lt;[]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case1计算逻辑，T['length']返回的是number，不是一个确定的值</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2计算逻辑，T['length']返回的是0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">=&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="Chunk-lodash分割数组"><a href="#Chunk-lodash分割数组" class="headerlink" title="Chunk(lodash分割数组)"></a>Chunk(lodash分割数组)</h3><p><link-and-solution num="4499"></link-and-solution></p><p><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash Chunk</a>: 将一个数组分割成长度为N的多个小数组。</p><h4 id="用法-70"><a href="#用法-70" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, 2], [3, 4]]</span></span><br><span class="line"><span class="keyword">type</span> result = Chunk&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-70"><a href="#实现方式-70" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chunk&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  Size <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> Size</span><br><span class="line">  ? [R, ...Chunk&lt;T, Size&gt;]</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Chunk&lt;L, Size, [...R, F]&gt;</span><br><span class="line">    : R[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? []</span><br><span class="line">      : [R]</span><br></pre></td></tr></table></figure><p>代码详解：实现<code>Chunk</code>大体思路是：借助一个辅助空数组，在遍历数组时往这个辅助数组中添加元素，一直到等于指定长度，然后进行下一次相同操作。</p><h3 id="Fill-数组fill方法"><a href="#Fill-数组fill方法" class="headerlink" title="Fill(数组fill方法)"></a>Fill(数组fill方法)</h3><p><link-and-solution num="4518"></link-and-solution></p><h4 id="用法-71"><a href="#用法-71" class="headerlink" title="用法"></a>用法</h4><p><code>Fill</code>是用来在一个数组中，用指定元素，替换开始索引和结束索引元素的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-71"><a href="#实现方式-71" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fill&lt;</span><br><span class="line">  T <span class="keyword">extends</span> unknown[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Start <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">0</span>,</span><br><span class="line">  End <span class="keyword">extends</span> <span class="built_in">number</span> = T[<span class="string">'length'</span>],</span><br><span class="line">  Count <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Flag <span class="keyword">extends</span> <span class="built_in">boolean</span> = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> Start ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> End</span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Flag <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">      ? [F, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>]&gt;]</span><br><span class="line">      : [N, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>], <span class="literal">true</span>&gt;]</span><br><span class="line">    : T</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Count</code>: 遍历标志位，从数组第一项开始，当等于<code>End</code>时，结束替换。</li><li><code>Flag</code>：遍历标志位，从数组第一项开始，当等于<code>Start</code>是，开始替换。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次遍历 Count = [], Flag = false, T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 满足Flag extends false条件，Count = [0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次遍历 Count = [0], Flag = true(计算而言)，T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0], T = [1, true, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次遍历 Count = [0, 0], Flag = true(主动传递), T =[1, true, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0, 0], T = [1, true, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次判断 Count = [0, 0, 0]，长度等于End，结束，T = [1, true, true]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Without-移除"><a href="#Without-移除" class="headerlink" title="Without(移除)"></a>Without(移除)</h3><p><link-and-solution num="5117"></link-and-solution></p><h4 id="用法-72"><a href="#用法-72" class="headerlink" title="用法"></a>用法</h4><p><code>Without</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[3]</span></span><br><span class="line"><span class="keyword">type</span> result = Without&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-72"><a href="#实现方式-72" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToUnion&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T</span><br><span class="line"><span class="keyword">type</span> Without&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  U = ToUnion&lt;F&gt;,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? First <span class="keyword">extends</span> U</span><br><span class="line">      ? Without&lt;Rest, F, U, [...R]&gt;</span><br><span class="line">      : Without&lt;Rest, F, U, [...R, First]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><p>代码详解：因为<code>F</code>支持单数字和数组，所以定义一个<code>ToUion</code>来统一处理成联合类型。随后直接遍历数组，如果当前迭代的元素在联合类型中，则直接跳过进行下一次迭代；否则，把当前迭代元素添加到<code>R</code>辅助数组中。</p><h3 id="Trunc-Math-trunc取整"><a href="#Trunc-Math-trunc取整" class="headerlink" title="Trunc(Math.trunc取整)"></a>Trunc(Math.trunc取整)</h3><p><link-and-solution num="5140"></link-and-solution></p><h4 id="用法-73"><a href="#用法-73" class="headerlink" title="用法"></a>用法</h4><p><code>Trunc</code>是用来实现<code>Math.trunc()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：100</span></span><br><span class="line"><span class="keyword">type</span> result1 = Trunc&lt;<span class="number">100.32</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：0</span></span><br><span class="line"><span class="keyword">type</span> result2 = Trunc&lt;<span class="number">.3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-73"><a href="#实现方式-73" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trunc&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">&gt; =<span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>.<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">  ? L <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">    ? <span class="string">'0'</span></span><br><span class="line">    : L</span><br><span class="line">  : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><h3 id="IndexOf-数组indexOf方法"><a href="#IndexOf-数组indexOf方法" class="headerlink" title="IndexOf(数组indexOf方法)"></a>IndexOf(数组indexOf方法)</h3><p><link-and-solution num="5153"></link-and-solution></p><h4 id="用法-74"><a href="#用法-74" class="headerlink" title="用法"></a>用法</h4><p><code>IndexOf</code>是用来实现数组<code>indexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2</span></span><br><span class="line"><span class="keyword">type</span> result = IndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-74"><a href="#实现方式-74" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;U, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Index[<span class="string">'length'</span>]</span><br><span class="line">    : IndexOf&lt;Rest, U, [...Index, <span class="number">0</span>]&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>代码详解：需要借助<code>IsEqual</code>来判断两个值是否相等，原因考虑如下案例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsEqual&lt;<span class="number">1</span>, <span class="built_in">number</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsEqual&lt;<span class="string">'a'</span>, <span class="built_in">string</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="Join-数组join方法"><a href="#Join-数组join方法" class="headerlink" title="Join(数组join方法)"></a>Join(数组join方法)</h3><p><link-and-solution num="5310"></link-and-solution></p><h4 id="用法-75"><a href="#用法-75" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现数组<code>join</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a-p-p-l-e'</span></span><br><span class="line"><span class="keyword">type</span> result = Join&lt;[<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'p'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>], <span class="string">'-'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-75"><a href="#实现方式-75" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Join&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      : Join&lt;Rest, U, <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span>&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><h3 id="LastIndexOf-数组lastIndexOf方法"><a href="#LastIndexOf-数组lastIndexOf方法" class="headerlink" title="LastIndexOf(数组lastIndexOf方法)"></a>LastIndexOf(数组lastIndexOf方法)</h3><p><link-and-solution num="5317"></link-and-solution></p><p>借助<code>IndexOf</code>的实现思路，很容易实现<code>lastIndexOf</code>方法。</p><h4 id="用法-76"><a href="#用法-76" class="headerlink" title="用法"></a>用法</h4><p><code>LastIndexOf</code>是用来实现数组<code>lastIndexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = LastIndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-76"><a href="#实现方式-76" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> LastIndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[], </span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [...infer Rest, infer Last]</span><br><span class="line">  ? IsEqual&lt;Last, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : LastIndexOf&lt;Rest, U&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="Unique-数组去重"><a href="#Unique-数组去重" class="headerlink" title="Unique(数组去重)"></a>Unique(数组去重)</h3><p><link-and-solution num="5360"></link-and-solution></p><h4 id="用法-77"><a href="#用法-77" class="headerlink" title="用法"></a>用法</h4><p><code>Unique</code>是用来实现数组去重的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unique&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-77"><a href="#实现方式-77" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>IsEqual</code>和<code>Includes</code>，很容易实现<code>Unique</code>数组去重。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> Includes&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;Last, U&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unique&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Includes&lt;R, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Unique&lt;Last, R&gt;</span><br><span class="line">    : Unique&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure></p><h3 id="MapTypes-类型转换"><a href="#MapTypes-类型转换" class="headerlink" title="MapTypes(类型转换)"></a>MapTypes(类型转换)</h3><p><link-and-solution num="5821"></link-and-solution></p><h4 id="用法-78"><a href="#用法-78" class="headerlink" title="用法"></a>用法</h4><p><code>MapTypes</code>是用来根据指定类型进行替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; type: number; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MapTypes&lt;&#123; <span class="keyword">type</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;, &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-78"><a href="#实现方式-78" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMapType&lt;</span><br><span class="line">  T, </span><br><span class="line">  R,</span><br><span class="line">  Type = R <span class="keyword">extends</span> &#123; mapFrom: T, mapTo: infer To &#125; ? To : never</span><br><span class="line">&gt; = [Type] <span class="keyword">extends</span> [never] ? T : Type</span><br><span class="line"><span class="keyword">type</span> MapTypes&lt;T, R&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: GetMapType&lt;T[P], R&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：在以上的实现中，最核心的代码是获取<code>Type</code>类型。</p><ul><li><code>R extends { mapFrom: T, mapTo: infer To }</code>：这段代码表示，<code>R</code>是不是右边的子类型，我们以以上案例来说明：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当P = 'type'时，</span></span><br><span class="line">T[P] = <span class="built_in">string</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">string</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; To = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; <span class="keyword">type</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当P = 'age'时</span></span><br><span class="line">T[P] = <span class="built_in">number</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">number</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; never</span><br><span class="line">=&gt; GetMapType&lt;T[P], R&gt; = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; age: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ConstructTuple-构造元组"><a href="#ConstructTuple-构造元组" class="headerlink" title="ConstructTuple(构造元组)"></a>ConstructTuple(构造元组)</h3><p><link-and-solution num="7544"></link-and-solution></p><h4 id="用法-79"><a href="#用法-79" class="headerlink" title="用法"></a>用法</h4><p><code>ConstructTuple</code>是用来构造指定长度的元组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[unknown, unknown]</span></span><br><span class="line"><span class="keyword">type</span> result = ConstructTuple&lt;<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-79"><a href="#实现方式-79" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConstructTuple&lt;</span><br><span class="line">  L <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> L</span><br><span class="line">  ? R</span><br><span class="line">  : ConstructTuple&lt;L, [...R, unknown]&gt;</span><br></pre></td></tr></table></figure><h3 id="NumberRange-限定范围数字"><a href="#NumberRange-限定范围数字" class="headerlink" title="NumberRange(限定范围数字)"></a>NumberRange(限定范围数字)</h3><p><link-and-solution num="8640"></link-and-solution></p><h4 id="用法-80"><a href="#用法-80" class="headerlink" title="用法"></a>用法</h4><p><code>NumberRange</code>是用来返回指定范围内的数字的，其返回的是一个联合类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"><span class="keyword">type</span> result = NumberRange&lt;<span class="number">2</span>, <span class="number">9</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-80"><a href="#实现方式-80" class="headerlink" title="实现方式"></a>实现方式</h4><p>实现思路参考：数组<code>Fill</code>方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberRange&lt;</span><br><span class="line">  L, </span><br><span class="line">  H,</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  F = I[<span class="string">'length'</span>] <span class="keyword">extends</span> L ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = I[<span class="string">'length'</span>] <span class="keyword">extends</span> H</span><br><span class="line">  ? I[<span class="built_in">number</span>] | H</span><br><span class="line">  : F <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">    ? NumberRange&lt;L, H, [...I, never]&gt;</span><br><span class="line">    : NumberRange&lt;L, H, [...I, I[<span class="string">'length'</span>]], <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Subsequence-元组子序列"><a href="#Subsequence-元组子序列" class="headerlink" title="Subsequence(元组子序列)"></a>Subsequence(元组子序列)</h3><p><link-and-solution num="8987"></link-and-solution></p><h4 id="用法-81"><a href="#用法-81" class="headerlink" title="用法"></a>用法</h4><p><code>Subsequence</code>是用来根据指定数组生成元组子序列的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[] | [1] | [2] | [1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = Subsequence&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-81"><a href="#实现方式-81" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subsequence&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Subsequence&lt;Last, R | [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>R | [...R, First]</code>: 在一个数组中，对一个联合类型的数组使用<code>...</code>扩展时，会自动进行元素分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['a', 'b'] | ['a', 'c']</span></span><br><span class="line"><span class="keyword">type</span> result = [<span class="string">'a'</span>, ...([<span class="string">'b'</span>] | [<span class="string">'c'</span>])]</span><br></pre></td></tr></table></figure></li></ul><h3 id="CheckRepeatedChars-是否包含相同字符"><a href="#CheckRepeatedChars-是否包含相同字符" class="headerlink" title="CheckRepeatedChars(是否包含相同字符)"></a>CheckRepeatedChars(是否包含相同字符)</h3><p><link-and-solution num="9142"></link-and-solution></p><h4 id="用法-82"><a href="#用法-82" class="headerlink" title="用法"></a>用法</h4><p><code>CheckRepeatedChars</code>是用来检查字符串中是否存在重复字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false </span></span><br><span class="line"><span class="keyword">type</span> result1 = CheckRepeatedChars&lt;<span class="string">'abc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = CheckRepeatedChars&lt;<span class="string">'abb'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-82"><a href="#实现方式-82" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckRepeatedChars&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : CheckRepeatedChars&lt;Last&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>${string}${First}${string}</code>：表示字符串包含<code>First</code>，也可以用<code>infer</code>来代替：<code>${infer Left}${First}${infer Right}</code>。</li></ul><h3 id="FirstUniqueCharIndex-字符串中第一个唯一字符"><a href="#FirstUniqueCharIndex-字符串中第一个唯一字符" class="headerlink" title="FirstUniqueCharIndex(字符串中第一个唯一字符)"></a>FirstUniqueCharIndex(字符串中第一个唯一字符)</h3><p><link-and-solution num="9286"></link-and-solution></p><h4 id="用法-83"><a href="#用法-83" class="headerlink" title="用法"></a>用法</h4><p><code>FirstUniqueCharIndex</code>是用来获取字符串中第一个唯一字符的索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： 0(字符l)</span></span><br><span class="line"><span class="keyword">type</span> result1 = FirstUniqueCharIndex&lt;<span class="string">'leetcode'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result2 = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-83"><a href="#实现方式-83" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>CheckRepeatedChars</code>的实现思路，很容易实现<code>FirstUniqueCharIndex</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FirstUniqueCharIndex&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? <span class="number">-1</span></span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? First <span class="keyword">extends</span> R[<span class="built_in">number</span>]</span><br><span class="line">      ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">      : Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">        ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">        : R[<span class="string">'length'</span>]</span><br><span class="line">    : <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>代码详解：此题的实现思路和<code>FirstUniqueCharIndex</code>类似，只是多了一层判断，以上面案例为例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代时：S = loveleetcode R = [] R[number] = never First = l</span></span><br><span class="line">=&gt; <span class="string">'l'</span> <span class="keyword">extends</span> never 不满足，<span class="string">'oveleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>l<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代时：S = oveleetcode R = ['l'] R[number] = 'l' First = o</span></span><br><span class="line">=&gt; <span class="string">'o'</span> <span class="keyword">extends</span> <span class="string">'l'</span> 不满足，<span class="string">'veleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>o<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代时：S = veleetcode R = ['l', '0'] R[number] = 'l' | 'o' First = v</span></span><br><span class="line">=&gt; <span class="string">'v'</span> <span class="keyword">extends</span> <span class="string">'l'</span> | <span class="string">'o'</span> 不满足，<span class="string">'eleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>v<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>不满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：R['length']</span></span><br><span class="line">=&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="ParseUrlParams-解析url路径参数"><a href="#ParseUrlParams-解析url路径参数" class="headerlink" title="ParseUrlParams(解析url路径参数)"></a>ParseUrlParams(解析url路径参数)</h3><p><link-and-solution num="9616"></link-and-solution></p><h4 id="用法-84"><a href="#用法-84" class="headerlink" title="用法"></a>用法</h4><p><code>ParseUrlParams</code>是用来解析<code>url</code>上参数名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'id' | 'user'</span></span><br><span class="line"><span class="keyword">type</span> result = ParseUrlParams&lt;<span class="string">'posts/:id/:user'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-84"><a href="#实现方式-84" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseUrlParams&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>:<span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span>/<span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">    ? Left | ParseUrlParams&lt;Right&gt;</span><br><span class="line">    : Last</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure><h3 id="GetMiddleElement-数组中位数"><a href="#GetMiddleElement-数组中位数" class="headerlink" title="GetMiddleElement(数组中位数)"></a>GetMiddleElement(数组中位数)</h3><p><link-and-solution num="9896"></link-and-solution></p><h4 id="用法-85"><a href="#用法-85" class="headerlink" title="用法"></a>用法</h4><p><code>GetMiddleElement</code>是用来取数组中位数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result2 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-85"><a href="#实现方式-85" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMiddleElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Middle, <span class="built_in">any</span>]</span><br><span class="line">    ? GetMiddleElement&lt;Middle&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[&#39;length&#39;] extends 0 | 1 | 2</code>：当数组长度小于等于而时，其中位数就是自身。</li><li><code>T extends [any, ...infer Middle, any]</code>: 当长度大于2时，每次迭代去掉首、尾元素，直至数组长度小于等于2，返回。</li></ul><h3 id="FindOnlyElements-数组只出现一次的元素"><a href="#FindOnlyElements-数组只出现一次的元素" class="headerlink" title="FindOnlyElements(数组只出现一次的元素)"></a>FindOnlyElements(数组只出现一次的元素)</h3><p><link-and-solution num="9898"></link-and-solution></p><h4 id="用法-86"><a href="#用法-86" class="headerlink" title="用法"></a>用法</h4><p><code>FindOnlyElements</code>是用来获取数组中只出现一次的元素，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [1]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-86"><a href="#实现方式-86" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindOnlyElements&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> [...U, ...Last][<span class="built_in">number</span>]</span><br><span class="line">    ? FindOnlyElements&lt;Last, [...U, First], R&gt;</span><br><span class="line">    : FindOnlyElements&lt;Last, [...U, First], [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><h3 id="CountArrayElement-计数数组中元素出现的次数"><a href="#CountArrayElement-计数数组中元素出现的次数" class="headerlink" title="CountArrayElement(计数数组中元素出现的次数)"></a>CountArrayElement(计数数组中元素出现的次数)</h3><p><link-and-solution num="9989"></link-and-solution></p><h4 id="用法-87"><a href="#用法-87" class="headerlink" title="用法"></a>用法</h4><p><code>CountArrayElement</code>是用来实现计算数组中元素出现次数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1: &#123; 1: 1, 2: 1, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result1 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2: &#123; 1: 2, 2: 2, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-87"><a href="#实现方式-87" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? [First] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? Flatten&lt;Last, R&gt; </span><br><span class="line">    : First <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? Flatten&lt;Last, [...R, ...Flatten&lt;First&gt;]&gt;</span><br><span class="line">      : Flatten&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjectCount&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">any</span>[]&gt; = &#123;&#125;</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> keyof R</span><br><span class="line">    ? ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [...R[First], <span class="number">0</span>]&gt;&gt;</span><br><span class="line">    : ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [<span class="number">0</span>]&gt;&gt;</span><br><span class="line">  : &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof R]: R[P][<span class="string">'length'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountArrayElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = ObjectCount&lt;Flatten&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Flatten</code>：实现<code>Flatten</code>，用来处理传递多维数组的情况，例如：<code>CountArrayElement&lt;[1, [1, 2], 3, [4, [5]]]&gt;</code></li><li><code>First extends keyof R</code>: 如果当前数组的遍历项是<code>R</code>对象中的一个键，则表明需要计数加一；如果不是，则代表是新项，需要计数为1；</li><li><code>[P in keyof R]: R[P][&#39;length&#39;]</code>: 因为最后结果需要返回数组，而非数组，所以迭代<code>R</code>对象，返回其每个属性的数组长度即可。</li></ul><h3 id="Integer-数字整数"><a href="#Integer-数字整数" class="headerlink" title="Integer(数字整数)"></a>Integer(数字整数)</h3><p><link-and-solution num="10969"></link-and-solution></p><h4 id="用法-88"><a href="#用法-88" class="headerlink" title="用法"></a>用法</h4><p><code>Integer</code>是用来返回数字的整数部分的，如果传入的数子包含小数，则返回<code>never</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：1</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1.1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-88"><a href="#实现方式-88" class="headerlink" title="实现方式"></a>实现方式</h4><p>根据<code>JavaScript</code>中<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">BigInt</a>的用法，其不能包含小数。所以实现方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;bigint&#125;</span>`</span> ? T : never</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>${T}</code> extends <code>${bigint}</code>：这里转成字符串形式比较，不能直接比较，因为<code>number</code>和<code>bigint</code>是两个不同的类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：都是false</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">number</span> <span class="keyword">extends</span> bigint ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = bigint <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ToPrimitive-转化基本类型"><a href="#ToPrimitive-转化基本类型" class="headerlink" title="ToPrimitive(转化基本类型)"></a>ToPrimitive(转化基本类型)</h3><p><link-and-solution num="16259"></link-and-solution></p><h4 id="用法-89"><a href="#用法-89" class="headerlink" title="用法"></a>用法</h4><p><code>ToPrimitive</code>是用来返回一个对象的类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonInfo = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">  married: <span class="literal">false</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="string">'123456'</span></span><br><span class="line">    phone: <span class="string">'13111111111'</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="string">'sing'</span>, <span class="string">'dance'</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="string">'test'</span>]</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  married: <span class="built_in">boolean</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="built_in">string</span></span><br><span class="line">    phone: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="built_in">string</span>]</span><br><span class="line">  fn: <span class="built_in">Function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = ToPrimitive&lt;PersonInfo&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-89"><a href="#实现方式-89" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToPrimitive&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> object</span><br><span class="line">  ? T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">    ? <span class="built_in">Function</span></span><br><span class="line">    : &#123; [P <span class="keyword">in</span> keyof T]: ToPrimitive&lt;T[P]&gt; &#125;</span><br><span class="line">  : T <span class="keyword">extends</span> &#123; valueOf: <span class="function"><span class="params">()</span> =&gt;</span> infer R &#125; ? R : T</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>对于函数来说：当满足<code>T extends (...args: any[]) =&gt; any</code>条件时，直接返回<code>Function</code>。</li><li>对于嵌套对象来说，递归调用<code>ToPrimitive</code>即可。</li><li>对于普通类型来说，判断其是否满足<code>T extends { valueOf: () =&gt; infer R }</code>，是则返回其类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的valueOf是js中的valueOf一样</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(num.valueOf()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="DeepMutable-深度Mutable"><a href="#DeepMutable-深度Mutable" class="headerlink" title="DeepMutable(深度Mutable)"></a>DeepMutable(深度Mutable)</h3><p><link-and-solution num="17973"></link-and-solution></p><h4 id="用法-90"><a href="#用法-90" class="headerlink" title="用法"></a>用法</h4><p><code>DeepMutable</code>是用来深度移除属性<code>readonly</code>修饰符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Test &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span></span><br><span class="line">  readonly description: <span class="built_in">string</span></span><br><span class="line">  readonly completed: <span class="built_in">boolean</span></span><br><span class="line">  readonly meta: &#123;</span><br><span class="line">    readonly author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Expected &#123;</span><br><span class="line">  title: <span class="built_in">string</span></span><br><span class="line">  description: <span class="built_in">string</span></span><br><span class="line">  completed: <span class="built_in">boolean</span></span><br><span class="line">  meta: &#123;</span><br><span class="line">    author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = DeepMutable&lt;Test&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-90"><a href="#实现方式-90" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepMutable&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; - readonly [P <span class="keyword">in</span> keyof T]: DeepMutable&lt;T[P]&gt; &#125;</span><br></pre></td></tr></table></figure><h3 id="AllMatch-数组元素是否与给定元素完全相同"><a href="#AllMatch-数组元素是否与给定元素完全相同" class="headerlink" title="AllMatch(数组元素是否与给定元素完全相同)"></a>AllMatch(数组元素是否与给定元素完全相同)</h3><p><link-and-solution num="18142"></link-and-solution></p><h4 id="用法-91"><a href="#用法-91" class="headerlink" title="用法"></a>用法</h4><p><code>AllMatch</code>是用来判断，数组元素是否与给定元素完全相同的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-91"><a href="#实现方式-91" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑边界情况，简易实现方法</span></span><br><span class="line"><span class="keyword">type</span> errTest1 = AllMatch&lt;[<span class="built_in">any</span>], unknown&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest2 = AllMatch&lt;[unknown], <span class="built_in">any</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest3 = AllMatch&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> U</span><br><span class="line">? <span class="literal">true</span></span><br><span class="line">: <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑边界情况：完整实现</span></span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? AllMatch&lt;Rest, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  : <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Filter-数组过滤"><a href="#Filter-数组过滤" class="headerlink" title="Filter(数组过滤)"></a>Filter(数组过滤)</h3><p><link-and-solution num="18220"></link-and-solution></p><h4 id="用法-92"><a href="#用法-92" class="headerlink" title="用法"></a>用法</h4><p><code>Filter</code>是用来实现数组过滤方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-92"><a href="#实现方式-92" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Filter&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> P</span><br><span class="line">    ? [First, ...Filter&lt;Rest, P&gt;]</span><br><span class="line">    : Filter&lt;Rest, P&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><h3 id="FindAllIndex-查找数组中给定元素所有索引"><a href="#FindAllIndex-查找数组中给定元素所有索引" class="headerlink" title="FindAllIndex(查找数组中给定元素所有索引)"></a>FindAllIndex(查找数组中给定元素所有索引)</h3><p><link-and-solution num="21104"></link-and-solution></p><h4 id="用法-93"><a href="#用法-93" class="headerlink" title="用法"></a>用法</h4><p><code>FindAllIndex</code>是用来返回字符串中所有匹配索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[11]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[2, 13]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'pe'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：[]</span></span><br><span class="line"><span class="keyword">type</span> result3 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">''</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-93"><a href="#实现方式-93" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindAll&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? []</span><br><span class="line">  : T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      ? FindAll&lt;Last, P, [...R, I[<span class="string">'length'</span>]], [...I, <span class="number">0</span>]&gt;</span><br><span class="line">      : FindAll&lt;Last, P, R, [...I, <span class="number">0</span>]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>I extends any[] = []</code>: 设置索引，字符串每迭代移除，<code>I</code>数组长度增加一。</li><li><code>T extends ${P}${string}</code>: 当满足条件时，向结果数组<code>R</code>中添加当前索引即可。</li></ul><h3 id="CombKeys-组合键"><a href="#CombKeys-组合键" class="headerlink" title="CombKeys(组合键)"></a>CombKeys(组合键)</h3><p><link-and-solution num="21106"></link-and-solution></p><h4 id="用法-94"><a href="#用法-94" class="headerlink" title="用法"></a>用法</h4><p><code>CombKeys</code>是用来实现组合键的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'cmd ctrl' | 'cmd opt' | 'cmd fn' | 'ctrl opt' | 'ctrl fn' | 'opt fn'</span></span><br><span class="line"><span class="keyword">type</span> result = CombKeys&lt;[<span class="string">'cmd'</span>, <span class="string">'ctrl'</span>, <span class="string">'opt'</span>, <span class="string">'fn'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-94"><a href="#实现方式-94" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CombKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span>, ...infer Last <span class="keyword">extends</span> <span class="built_in">string</span>[]]</span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;First&#125;</span> <span class="subst">$&#123;Last[<span class="built_in">number</span>]&#125;</span>`</span> | CombKeys&lt;Last&gt;</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure><h3 id="ReplaceFirst-替换元组中第一个匹配项"><a href="#ReplaceFirst-替换元组中第一个匹配项" class="headerlink" title="ReplaceFirst(替换元组中第一个匹配项)"></a>ReplaceFirst(替换元组中第一个匹配项)</h3><p><link-and-solution num="25170"></link-and-solution></p><h4 id="用法-95"><a href="#用法-95" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceFirst</code>是用来替换元组中第一个匹配项，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceFirst&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-95"><a href="#实现方式-95" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceFirst&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly unknown[],</span><br><span class="line">  From,</span><br><span class="line">  To</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> From</span><br><span class="line">    ? [To, ...Rest]</span><br><span class="line">    : [First, ...ReplaceFirst&lt;Rest, From, To&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><h3 id="SimpleVue-简单Vue类型"><a href="#SimpleVue-简单Vue类型" class="headerlink" title="SimpleVue(简单Vue类型)"></a>SimpleVue(简单Vue类型)</h3><p><link-and-solution num="6"></link-and-solution></p><h4 id="用法-96"><a href="#用法-96" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-96"><a href="#实现方式-96" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Currying-柯里化"><a href="#Currying-柯里化" class="headerlink" title="Currying(柯里化)"></a>Currying(柯里化)</h3><p><link-and-solution num="17"></link-and-solution></p><p>在<code>JavaScript</code>中<code>Currying</code>是用来实现函数柯里化的，其用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> three = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = Currying(add)</span><br><span class="line"><span class="keyword">const</span> five = curriedAdd(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h4 id="用法-97"><a href="#用法-97" class="headerlink" title="用法"></a>用法</h4><p><code>Currying</code>是用来实现<code>JavaScript</code>中的柯里化的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = Currying(<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span>, c: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 结果：(a: string) =&gt; (a: number) =&gt; (a: boolean) =&gt; true</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> func</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-97"><a href="#实现方式-97" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CurryFunction&lt;</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">  ? <span class="function"><span class="params">()</span> =&gt;</span> R</span><br><span class="line">  : P <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="function">(<span class="params">a: First</span>) =&gt;</span> R</span><br><span class="line">      : <span class="function">(<span class="params">a: First</span>) =&gt;</span> CurryFunction&lt;Rest, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Currying</span>&lt;<span class="title">F</span>&gt;(<span class="params">fn: F</span>):</span></span><br><span class="line"><span class="function">  <span class="title">F</span> <span class="title">extends</span> (<span class="params">...args: infer P</span>) =&gt; <span class="title">infer</span> <span class="title">R</span></span></span><br><span class="line"><span class="function">  ? <span class="title">CurryFunction</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="function">  : <span class="title">never</span></span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>P</code>：<code>P</code>为调用<code>Currying</code>函数时传递函数参数的参数数组，以上面为例，其值为：<code>[number, string, boolean]</code>。</li><li><code>P extends [infer First, ...infer Rest]</code>: 遍历参数列表，依次返回一个函数即可。</li></ul><h3 id="UnionToIntersection-元组取交集"><a href="#UnionToIntersection-元组取交集" class="headerlink" title="UnionToIntersection(元组取交集)"></a>UnionToIntersection(元组取交集)</h3><p><link-and-solution num="55"></link-and-solution></p><p>在实现<code>UnionToIntersection</code>之前，我们先来回顾一下<code>TS</code>中<code>&amp;</code>符号的作用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="number">1</span> &amp; <span class="string">'foo'</span> &amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; &amp; &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = <span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) &amp; (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)</span></span><br></pre></td></tr></table></figure></p><p>案例解析：</p><ul><li>案例一：因为<code>1</code>、<code>foo</code>以及<code>true</code>，没有交集部分，所以这里结果为<code>never</code>。</li><li>案例二：对于<code>a</code>和<code>c</code>属性而言，它们只存在于自身类型，所以交集部分是自身；对于<code>b</code>属性而言，它在两个类型中都存在，且其属性的类型存在交集部分，既：<code>number</code>。</li><li>案例三：对于函数的交叉类型，我们从函数参数、函数返回值这两个部分来说明。对于函数参数而言，取其联合类型；对于函数返回值而言，取其交叉类型。</li></ul><p>从以上几个案例中可以看出，<code>TS</code>中的<code>&amp;</code>符号是取交集的意思，也叫<strong>交叉类型</strong>。</p><h4 id="用法-98"><a href="#用法-98" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToIntersection</code>所做的事情和<code>&amp;</code>符号是一样的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToIntersection&lt;<span class="number">1</span> | <span class="string">'foo'</span> | <span class="literal">true</span>&gt;</span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToIntersection&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; | &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;&gt;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToIntersection&lt;<span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) | (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-98"><a href="#实现方式-98" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>U extends any ? X : Y</code>： 这里把<code>U</code>类型处理成<code>(x: U) =&gt; any</code>的函数类型。</li><li><code>T extends (x: infer V) =&gt; any ? V : never</code>：这里的<code>T</code>就是上一步的函数类型，如果<code>extends</code>成立，则返回<code>V</code>，此时的<code>V</code>必然满足<code>U &amp; V</code>。</li></ul><h3 id="RequiredKeys-所有必填字段"><a href="#RequiredKeys-所有必填字段" class="headerlink" title="RequiredKeys(所有必填字段)"></a>RequiredKeys(所有必填字段)</h3><p><link-and-solution num="89"></link-and-solution></p><h4 id="用法-99"><a href="#用法-99" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredKeys</code>是用来返回一个类型中所有必填字段，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-99"><a href="#实现方式-99" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequiredKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? never : P)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>{} extends Pick&lt;T, P&gt; ? never : P</code>：是用来判断当前遍历键是否可选键的。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> result = &#123;&#125; <span class="keyword">extends</span> &#123;&#125; | &#123; sex: <span class="literal">undefined</span> &#125; ? never : <span class="string">'sex'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="GetRequired-必填字段组成的类型"><a href="#GetRequired-必填字段组成的类型" class="headerlink" title="GetRequired(必填字段组成的类型)"></a>GetRequired(必填字段组成的类型)</h3><p><link-and-solution num="57"></link-and-solution></p><h4 id="用法-100"><a href="#用法-100" class="headerlink" title="用法"></a>用法</h4><p><code>GetRequired</code>是用来取一个类型中那些由必填字段组成的一个新类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; age: number; sex: undefined; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-100"><a href="#实现方式-100" class="headerlink" title="实现方式"></a>实现方式</h4><p>按照<code>RequiredKeys</code>的实现思路，能够很容易的实现<code>GetRequired</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? P : never)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>T[P] extends Required&lt;T&gt;[P] ? P : never</code>：用来判断当前遍历键的类型是否一致，一致则是必填类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P为name时</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">string</span> | <span class="literal">undefined</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">'name'</span> : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// P为age时</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="OptionalKeys-所有可选字段"><a href="#OptionalKeys-所有可选字段" class="headerlink" title="OptionalKeys(所有可选字段)"></a>OptionalKeys(所有可选字段)</h3><p><link-and-solution num="90"></link-and-solution></p><p><code>OptionalKeys</code>和<code>RequiredKeys</code>所做的事情相反，其获取的是所有可选字段。</p><h4 id="用法-101"><a href="#用法-101" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'sex' | 'address'</span></span><br><span class="line"><span class="keyword">type</span> result = OptionalKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-101"><a href="#实现方式-101" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionalKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? P : never)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：从上面代码中可以看出，它和<code>RequiredKeys</code>实现思路是一样的，区别只是在<code>extends</code>关键词后面的处理不同。</p><h3 id="GetOptional-可选字段组成的类型"><a href="#GetOptional-可选字段组成的类型" class="headerlink" title="GetOptional(可选字段组成的类型)"></a>GetOptional(可选字段组成的类型)</h3><p><link-and-solution num="59"></link-and-solution></p><h4 id="用法-102"><a href="#用法-102" class="headerlink" title="用法"></a>用法</h4><p>按照<code>OptionalKeys</code>的实现思路，能够很容易的实现<code>GetOptional</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; sex?: undefined; address?: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetOptional&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-102"><a href="#实现方式-102" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetOptional&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? never : P)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CapitalizeWords-所有单词首字母大写"><a href="#CapitalizeWords-所有单词首字母大写" class="headerlink" title="CapitalizeWords(所有单词首字母大写)"></a>CapitalizeWords(所有单词首字母大写)</h3><p><link-and-solution num="112"></link-and-solution></p><h4 id="用法-103"><a href="#用法-103" class="headerlink" title="用法"></a>用法</h4><p><code>CapitalizeWords</code>是用来把一个字符串中所有单词，变为大写字母的，其中这个字符串以固定的分隔符分割，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'Foobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = CapitalizeWords&lt;<span class="string">'foobar'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'Foo Bar.Hello,World'</span></span><br><span class="line"><span class="keyword">type</span> t2 = CapitalizeWords&lt;<span class="string">'foo bar.hello,world'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-103"><a href="#实现方式-103" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CapitalizeWords&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Uppercase&lt;First&gt; <span class="keyword">extends</span> Lowercase&lt;First&gt;</span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;Rest&gt;&#125;</span>`</span></span><br><span class="line">    : CapitalizeWords&lt;Rest, <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;</span><br><span class="line">  : Capitalize&lt;R&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Uppercase&lt;First&gt; extends Lowercase&lt;First&gt;</code>：为了找到连串的大写字符串，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S = foo bar.hello,world</span></span><br><span class="line">R = <span class="string">'foo'</span> First = <span class="string">' '</span> Rest = <span class="string">'bar.hello,world'</span></span><br><span class="line">=&gt; <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`foo `</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&gt;&#125;</span>`</span></span><br><span class="line">=&gt; <span class="string">`Foo <span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&#125;</span>`</span></span><br><span class="line">=&gt; ...</span><br><span class="line">=&gt; <span class="string">'Foo Bar.Hello,World'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CamelCase-下划线字符串转小驼峰"><a href="#CamelCase-下划线字符串转小驼峰" class="headerlink" title="CamelCase(下划线字符串转小驼峰)"></a>CamelCase(下划线字符串转小驼峰)</h3><p><link-and-solution num="114"></link-and-solution></p><h4 id="用法-104"><a href="#用法-104" class="headerlink" title="用法"></a>用法</h4><p>与<strong>中级</strong>章节实现不同，此章节中<code>CamelCase</code>是用来将下划线字符串转小驼峰的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'fooBarHelloWorld'</span></span><br><span class="line"><span class="keyword">type</span> result = CamelCase&lt;<span class="string">'foo_bar_hello_world'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-104"><a href="#实现方式-104" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsLetter&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Uppercase&lt;S&gt; <span class="keyword">extends</span> Lowercase&lt;S&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> CamelCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? CamelCase&lt;</span><br><span class="line">      Rest,</span><br><span class="line">      IsLetter&lt;First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? R <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer P&#125;</span>_`</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;Uppercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;Lowercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span></span><br><span class="line">    &gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>IsLetter</code>: 用来判断是否为字母的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsLetter&lt;<span class="string">'$'</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsLetter&lt;<span class="string">'A'</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>IsLetter&lt;L&gt; extends true</code>: 如果是字母的话，则根据是否以下划线结尾，如果是，则只需要紧邻下划线的字母<code>L</code>大写即可，否小写。</p></li></ul><h3 id="ParsePrintFormat-获取字符串格式化参数"><a href="#ParsePrintFormat-获取字符串格式化参数" class="headerlink" title="ParsePrintFormat(获取字符串格式化参数)"></a>ParsePrintFormat(获取字符串格式化参数)</h3><p><link-and-solution num="147"></link-and-solution></p><h4 id="用法-105"><a href="#用法-105" class="headerlink" title="用法"></a>用法</h4><p><code>ParsePrintFormat</code>是用来获取字符串格式化参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数映射表</span></span><br><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['string', 'dec']</span></span><br><span class="line"><span class="keyword">type</span> result = ParsePrintFormat&lt;<span class="string">'Hello %s: score is %d'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-105"><a href="#实现方式-105" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Char <span class="keyword">extends</span> keyof ControlMap</span><br><span class="line">      ? ParsePrintFormat&lt;S2, [...R, ControlMap[Char]]&gt;</span><br><span class="line">      : ParsePrintFormat&lt;S2, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="comment">// way2: 不借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Char <span class="keyword">extends</span> keyof ControlsMap</span><br><span class="line">    ? [ControlsMap[Char], ...ParsePrintFormat&lt;Rest&gt;]</span><br><span class="line">    : ParsePrintFormat&lt;Rest&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>代码详解：在以上实现方法中，借用了辅助数组的思想，拿上面案例来说，具体迭代分析如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">S满足条件 R = [] S1 = <span class="string">'Hello '</span> Char = <span class="string">'s'</span> S2 = <span class="string">': score is %d'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">S满足条件 R = [<span class="string">'string'</span>]  S1 = <span class="string">': score is '</span> Char = <span class="string">'d'</span> S2 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次迭代</span></span><br><span class="line">S不满足条件 R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">result = R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="VueBasicProps-Vue的Props类型"><a href="#VueBasicProps-Vue的Props类型" class="headerlink" title="VueBasicProps(Vue的Props类型)"></a>VueBasicProps(Vue的Props类型)</h3><p><link-and-solution num="213"></link-and-solution></p><h4 id="用法-106"><a href="#用法-106" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-106"><a href="#实现方式-106" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsAny和NotAny"><a href="#IsAny和NotAny" class="headerlink" title="IsAny和NotAny"></a>IsAny和NotAny</h3><p><link-and-solution num="223"></link-and-solution></p><h4 id="用法-107"><a href="#用法-107" class="headerlink" title="用法"></a>用法</h4><p><code>IsAny</code>是用来判断一个类型是否为<code>any</code>的，<code>NotAny</code>和它做的事情相反。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = IsAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t2 = IsAny&lt;never&gt;     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t3 = IsAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t4 = NotAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t5 = NotAny&lt;never&gt;     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t6 = NotAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-107"><a href="#实现方式-107" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsAny&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> (<span class="number">1</span> &amp; T) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> NotAny&lt;T&gt; = <span class="literal">true</span> <span class="keyword">extends</span> IsAny&lt;T&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：<code>1 &amp; T</code>的结果只能是：<code>1</code>、<code>never</code>或者<code>any</code>。当使用<code>0 extends</code>这三个结果的时候，只有<code>any</code>判断为真。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="number">0</span> <span class="keyword">extends</span> never ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="number">0</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="Get-字符串路径取值"><a href="#Get-字符串路径取值" class="headerlink" title="Get(字符串路径取值)"></a>Get(字符串路径取值)</h3><p><link-and-solution num="270"></link-and-solution></p><h4 id="用法-108"><a href="#用法-108" class="headerlink" title="用法"></a>用法</h4><p><code>Get</code>是用来进行字符串路径取值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      value: <span class="string">'foobar'</span>,</span><br><span class="line">      count: <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    include: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'foo.baz'</span>: <span class="literal">false</span></span><br><span class="line">  hello: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：world</span></span><br><span class="line"><span class="keyword">type</span> t1 = Get&lt;Data, <span class="string">'hello'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：foobar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Get&lt;Data, <span class="string">'foo.bar.value'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t3 = Get&lt;Data, <span class="string">'foo.baz'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> t4 = Get&lt;Data, <span class="string">'no.exits'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-108"><a href="#实现方式-108" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Get&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = K <span class="keyword">extends</span> keyof T</span><br><span class="line">  ? T[K]</span><br><span class="line">  : K <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line">    : T[K &amp; keyof T]</span><br></pre></td></tr></table></figure><p>代码详解：对于<code>Get</code>的实现，主要分为两部分：含有<code>.</code>符号的字符串和不含<code>.</code>符号的字符串。</p><ul><li><p>含有<code>.</code>符号的字符串：对于这种情况，我们先判断<code>.</code>符号左侧部分是否满足为<code>T</code>类型的某个<code>key</code>，如果满足，则递归调用<code>Get</code>；如果不满足，则直接返回<code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1如果是T的属性键，则返回S1；如果不是，则返回never</span></span><br><span class="line">Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S1 <span class="keyword">extends</span> keyof T ? Get&lt;T[S1], S2&gt; : never</span><br></pre></td></tr></table></figure></li><li><p>不含有<code>.</code>符号的字符串：对于这种情况，我们只需要判断它是否为<code>T</code>类型中的某个<code>key</code>，如果是，则直接取值；如果不是，则返回<code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K如果是T的属性键，则返回K；如果不是，则返回never</span></span><br><span class="line">T[K &amp; keyof T]</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S <span class="keyword">extends</span> keyof T ? T[S] : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="StringToNumber-字符串数字转数字"><a href="#StringToNumber-字符串数字转数字" class="headerlink" title="StringToNumber(字符串数字转数字)"></a>StringToNumber(字符串数字转数字)</h3><p><link-and-solution num="300"></link-and-solution></p><h4 id="用法-109"><a href="#用法-109" class="headerlink" title="用法"></a>用法</h4><p><code>StringToNumber</code>是用来将字符串形式的数字转换成真正数字类型数字的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：123</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-109"><a href="#实现方式-109" class="headerlink" title="实现方式"></a>实现方式</h4><p>在<code>JavaScript</code>中，我们可以很方便的调用<code>Number()</code>方法或者<code>parseInt()</code>方法来将字符串类型的数字，转换成数字类型的数字。但在<code>TS</code>中，并没有这样的方法，需要我们来手动实现。</p><p><code>StringToNumber</code>的实现并不容易理解，我们需要将其进行拆分，一步步来完善，其实现思路如下：</p><ul><li><p>第一步：可以很容易获取字符串<code>&#39;123&#39;</code>中每一位字符，我们将其存储在辅助数组<code>T</code>中，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? StringToNumber&lt;S2, [...T, S1]&gt;</span><br><span class="line">    : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['1', '2', '3']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二步：我们需要将单个字符串类型的数字，转换成真正数字类型的数字，可以借助中间数组来帮忙，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> =&gt; [<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">1</span></span><br><span class="line"><span class="string">'2'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">2</span></span><br><span class="line"><span class="string">'3'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'9'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure></li></ul><p>根据以上规律，我们封装一个<code>MakeArray</code>方法，它的实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t1 = MakeArray&lt;<span class="string">'1'</span>&gt; <span class="comment">// [0]</span></span><br><span class="line"><span class="keyword">type</span> t2 = MakeArray&lt;<span class="string">'2'</span>&gt; <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="keyword">type</span> t3 = MakeArray&lt;<span class="string">'3'</span>&gt; <span class="comment">// [0, 0, 0]</span></span><br></pre></td></tr></table></figure></p><ul><li>第三步：现在有了百位，十位和个位的数字，我们应该运用算术把它们按照一定的规律累加起来，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> target = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">1</span> + <span class="number">2</span> = <span class="number">12</span></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">12</span> + <span class="number">3</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">// 迭代规律</span></span><br><span class="line">target = <span class="number">10</span> * target + N</span><br></pre></td></tr></table></figure></li></ul><p>根据以上思路，我们还需要一个乘十的工具函数，对应到实际需求，就是需要把一个数组<code>copy</code>十次，因此我们封装一个<code>Multiply10</code>工具，其实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result = Multiply10&lt;[<span class="number">1</span>]&gt; <span class="comment">// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></span><br></pre></td></tr></table></figure></p><ul><li><p>第四步：根据前几步的分析，把所有东西串联起来，<code>StringToNumber</code>完整实现代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Digital = <span class="string">'0'</span>|<span class="string">'1'</span>|<span class="string">'2'</span>|<span class="string">'3'</span>|<span class="string">'4'</span>|<span class="string">'5'</span>|<span class="string">'6'</span>|<span class="string">'7'</span>|<span class="string">'8'</span>|<span class="string">'9'</span></span><br><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> Digital</span><br><span class="line">      ? StringToNumber&lt;S2, [...Multiply10&lt;T&gt;, ...MakeArray&lt;S1&gt;]&gt;</span><br><span class="line">      : never</span><br><span class="line">    : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></li><li><p>第五步：为了更好的理解递归的过程，我们拆解成如下步骤来说明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'123'</span> S1 = <span class="string">'1'</span> S2 = <span class="string">'23'</span> T = [<span class="number">0</span>] T[<span class="string">'length'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'23'</span>  S1 = <span class="string">'2'</span> S2 = <span class="string">'3'</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'3'</span>  S1 = <span class="string">'3'</span> S2 = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次递归，S不满足$&#123;infer S1&#125;$&#123;infer S2&#125; T['length']取值</span></span><br><span class="line">S = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="FilterOut-数组元素过滤"><a href="#FilterOut-数组元素过滤" class="headerlink" title="FilterOut(数组元素过滤)"></a>FilterOut(数组元素过滤)</h3><p><link-and-solution num="399"></link-and-solution></p><h4 id="用法-110"><a href="#用法-110" class="headerlink" title="用法"></a>用法</h4><p><code>FilterOut</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[2]</span></span><br><span class="line"><span class="keyword">type</span> result = FilterOut&lt;[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>], <span class="string">'a'</span> | <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-110"><a href="#实现方式-110" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterOut&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer R, ...infer args]</span><br><span class="line">      ? [R] <span class="keyword">extends</span> [F]</span><br><span class="line">        ? FilterOut&lt;args, F, [...K]&gt;</span><br><span class="line">        : FilterOut&lt;args, F, [...K, R]&gt;</span><br><span class="line">      : K</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>第一步：我们借用赋值函数来存放最后的结果。</li><li>第二步：迭代数组<code>T</code>，拿每一个元素去和指定的<code>F</code>进行判断，如果<code>R</code>是<code>F</code>的子类型，则不添加此元素到结果数组中，反之添加。</li><li>第三步：当迭代完毕时，直接返回结果数组<code>K</code>。</li></ul><h3 id="TupleToEnum-元组转枚举"><a href="#TupleToEnum-元组转枚举" class="headerlink" title="TupleToEnum(元组转枚举)"></a>TupleToEnum(元组转枚举)</h3><p><link-and-solution num="472"></link-and-solution></p><h4 id="用法-111"><a href="#用法-111" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToEnum</code>是用来将元组转换为枚举的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OperatingSystem = [<span class="string">'macOs'</span>, <span class="string">'Windows'</span>, <span class="string">'Linux'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> Expected1 = &#123;</span><br><span class="line">  readonly MacOs: <span class="string">'macOs'</span>;</span><br><span class="line">  readonly Windows: <span class="string">'Windows'</span>;</span><br><span class="line">  readonly Linux: <span class="string">'Linux'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected2 = &#123;</span><br><span class="line">  readonly MacOs: <span class="number">0</span>;</span><br><span class="line">  readonly Windows: <span class="number">1</span>;</span><br><span class="line">  readonly Linux: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> result1 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> result2 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem, <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-111"><a href="#实现方式-111" class="headerlink" title="实现方式"></a>实现方式</h4><p>在实现<code>TupleToEnum</code>之前，我们先来实现<code>TupleKeys</code>，它是用来获取所有元组索引组合成的联合类型的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">      ? TupleKeys&lt;args&gt; | args[<span class="string">'length'</span>]</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：0 | 1 | 2</span></span><br><span class="line"><span class="keyword">type</span> keys = TupleKeys&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br></pre></td></tr></table></figure></p><p>在有了以上<code>keys</code>后，就能很容易实现<code>TupleToEnum</code>了，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToEnum&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">string</span>[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">&gt; = &#123;</span><br><span class="line">  readonly [K <span class="keyword">in</span> TupleKeys&lt;T&gt; <span class="keyword">as</span> Capitalize&lt;T[K]&gt;]: N <span class="keyword">extends</span> <span class="literal">true</span> ? K : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Format-字符串格式化函数类型"><a href="#Format-字符串格式化函数类型" class="headerlink" title="Format(字符串格式化函数类型)"></a>Format(字符串格式化函数类型)</h3><p><link-and-solution num="545"></link-and-solution></p><p><code>%s</code>表示格式化为<code>(x: string) =&gt; any</code>形式，<code>%d</code>表示格式化为<code>(x: number) =&gt; any</code>形式。</p><h4 id="用法-112"><a href="#用法-112" class="headerlink" title="用法"></a>用法</h4><p><code>Format</code>是将字符串格式化为指定函数类型的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：(x: string) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result1 = Format&lt;<span class="string">'a%sbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：(x: number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result2 = Format&lt;<span class="string">'a%dbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：(x: number) =&gt; (x: string) =&gt; string&gt;</span></span><br><span class="line"><span class="keyword">type</span> result3 = Format&lt;<span class="string">'a%dbc%s'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-112"><a href="#实现方式-112" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FormatMaps = &#123;</span><br><span class="line">  <span class="string">'s'</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">'d'</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Format&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer P&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? P <span class="keyword">extends</span> keyof FormatMaps</span><br><span class="line">        ? <span class="function">(<span class="params">x: FormatMaps[P]</span>) =&gt;</span> Format&lt;S2&gt;</span><br><span class="line">        : <span class="built_in">string</span></span><br><span class="line">      : <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h3 id="LengthOfString-字符串的长度-1"><a href="#LengthOfString-字符串的长度-1" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="651"></link-and-solution></p><p>我们之前在<strong>中级</strong>大章节中已经实现过<code>LengthOfString</code>，但它面临的问题是，如果字符有上百个，由于<code>TS</code>对于递归的次数存在限制，会提示嵌套过深。</p><h4 id="用法-113"><a href="#用法-113" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：91</span></span><br><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-113"><a href="#实现方式-113" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S0&#125;</span><span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span><span class="subst">$&#123;infer S3&#125;</span><span class="subst">$&#123;infer S4&#125;</span><span class="subst">$&#123;infer S5&#125;</span><span class="subst">$&#123;infer S6&#125;</span><span class="subst">$&#123;infer S7&#125;</span><span class="subst">$&#123;infer S8&#125;</span><span class="subst">$&#123;infer S9&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;Rest, [...R, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&gt;</span><br><span class="line">      : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">          ? LengthOfString&lt;S2, [...R, S1]&gt;</span><br><span class="line">          : R[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure><p>代码解析：这里我们巧妙的使用占位的思想，<code>S extends ${infer S1}${infer S2}${infer S3}</code>，如果<code>S</code>满足这个占位形式，则表示<code>S</code>的长度至少为<code>2</code>，带入到上面的例子，解析步骤如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 第二弟递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="comment">// 最后一次递归</span></span><br><span class="line">S = <span class="string">'1'</span>不满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, ....., <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 最后结果</span></span><br><span class="line">R[<span class="string">'length'</span>] = <span class="number">91</span></span><br></pre></td></tr></table></figure></p><h3 id="UnionToTuple-联合类型转元组"><a href="#UnionToTuple-联合类型转元组" class="headerlink" title="UnionToTuple(联合类型转元组)"></a>UnionToTuple(联合类型转元组)</h3><p><link-and-solution num="730"></link-and-solution></p><h4 id="用法-114"><a href="#用法-114" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToTuple</code>是用来将联合类型转成元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToTuple&lt;<span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | never&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-114"><a href="#实现方式-114" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = (</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">  ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">  : never</span><br><span class="line">) <span class="keyword">extends</span> (x: infer R) =&gt; <span class="built_in">any</span> </span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LastUnion&lt;U&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line">    : never</span><br><span class="line">&gt; <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span></span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnionToTuple&lt;</span><br><span class="line">  T,</span><br><span class="line">  Last = LastUnion&lt;T&gt;</span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? []</span><br><span class="line">  : [...UnionToTuple&lt;Exclude&lt;T, Last&gt;&gt;, Last]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>UnionToIntersection</code>: 联合类型取交集，在之前已经实现过，这里不再赘述。主要理解以下案例：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载结果</span></span><br><span class="line"><span class="comment">// function (x: 1): 0;</span></span><br><span class="line"><span class="comment">// function (x: 2): 0;</span></span><br><span class="line"><span class="keyword">type</span> result = UnionToIntersection&lt;f1 | f2&gt;</span><br></pre></td></tr></table></figure></li></ul><p>对于函数参数的交集而言，不是简单的把参数取交集，而是”联合”起来，也就是构造一个新的函数类型，即：<strong>函数重载</strong></p><ul><li><code>LastUnion</code>: 取联合类型最后的一个元素，如果一个函数存在重载的情况，<code>TS</code>会取最后一个函数签名，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：2</span></span><br><span class="line"><span class="keyword">type</span> result1 = f1 &amp; f2 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br><span class="line"><span class="comment">// 结果2：1</span></span><br><span class="line"><span class="keyword">type</span> result2 = f2 &amp; f1 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="Join-字符串拼接"><a href="#Join-字符串拼接" class="headerlink" title="Join(字符串拼接)"></a>Join(字符串拼接)</h3><p><link-and-solution num="847"></link-and-solution></p><h4 id="用法-115"><a href="#用法-115" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现拼接字符串的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： ''</span></span><br><span class="line"><span class="keyword">const</span> Expected1 = join(<span class="string">'-'</span>)();</span><br><span class="line"><span class="comment">// 结果2： 'a'</span></span><br><span class="line"><span class="keyword">const</span> Expected2 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 结果3： 'abc'</span></span><br><span class="line"><span class="keyword">const</span> Expected3 = join(<span class="string">''</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 结果4： 'a-b-c'</span></span><br><span class="line"><span class="keyword">const</span> Expected4 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-115"><a href="#实现方式-115" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tail&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt; = T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Rest] ? Rest : []</span><br><span class="line"><span class="keyword">type</span> StringJoin&lt;</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">    ? <span class="string">''</span></span><br><span class="line">    : P <span class="keyword">extends</span> [infer Only]</span><br><span class="line">      ? Only</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;P[<span class="number">0</span>]&#125;</span><span class="subst">$&#123;D&#125;</span><span class="subst">$&#123;StringJoin&lt;D, Tail&lt;P&gt;&gt;&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">D</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">delimiter: D</span>): &lt;<span class="title">P</span> <span class="title">extends</span> <span class="title">string</span>[] = []&gt;(<span class="params">...parts: P</span>) =&gt; <span class="title">StringJoin</span>&lt;<span class="title">D</span>, <span class="title">P</span>&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="DeepPick-深层次Pick"><a href="#DeepPick-深层次Pick" class="headerlink" title="DeepPick(深层次Pick)"></a>DeepPick(深层次Pick)</h3><p><link-and-solution num="956"></link-and-solution></p><h4 id="用法-116"><a href="#用法-116" class="headerlink" title="用法"></a>用法</h4><p><code>DeepPick</code>是用来深层次获取属性值的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b: <span class="built_in">string</span>,</span><br><span class="line">  c:  <span class="built_in">boolean</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    d: <span class="built_in">number</span>,</span><br><span class="line">    e: <span class="built_in">string</span>,</span><br><span class="line">    f:  <span class="built_in">boolean</span>,</span><br><span class="line">    obj2: &#123;</span><br><span class="line">      g: <span class="built_in">number</span>,</span><br><span class="line">      h: <span class="built_in">string</span>,</span><br><span class="line">      i: <span class="built_in">boolean</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：Obj</span></span><br><span class="line"><span class="keyword">type</span> result1 = DeepPick&lt;Obj, <span class="string">''</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：&#123; a: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = DeepPick&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：&#123; a: number; &#125; &amp; &#123; obj: &#123; d: number; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result3 = DeepPick&lt;Obj, <span class="string">'a'</span>, <span class="string">'obj.d'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-116"><a href="#实现方式-116" class="headerlink" title="实现方式"></a>实现方式</h4><p>在之前，我们实现过根据属性路径取值<code>Get</code>，根据其思路我们很容易实现<code>DeepPick</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetType&lt;T, S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S1]: GetType&lt;T[S1], S2&gt; &#125;</span><br><span class="line">      : never</span><br><span class="line">    : S <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S]: T[K] &#125;</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeepPick&lt;</span><br><span class="line">  T,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> infer keys ? GetType&lt;T, keys&gt; : never</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Camelize-对象属性键转小驼峰"><a href="#Camelize-对象属性键转小驼峰" class="headerlink" title="Camelize(对象属性键转小驼峰)"></a>Camelize(对象属性键转小驼峰)</h3><p><link-and-solution num="1383"></link-and-solution></p><h4 id="用法-117"><a href="#用法-117" class="headerlink" title="用法"></a>用法</h4><p><code>Camelize</code>是用来将对象中的<code>key</code>全部转换为小驼峰的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  some_PROP: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123;</span><br><span class="line">    another_prop: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snake_case: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  someProp: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123; </span><br><span class="line">    anotherProp: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snakeCase: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = Camelize&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-117"><a href="#实现方式-117" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CamelCase&lt;S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>_<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;S1&gt;&#125;</span><span class="subst">$&#123;CamelCase&lt;Capitalize&lt;Lowercase&lt;S2&gt;&gt;&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camelize&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> CamelCase&lt;K&gt;]: </span><br><span class="line">    T[K] <span class="keyword">extends</span> [infer R]</span><br><span class="line">      ? [Camelize&lt;R&gt;]</span><br><span class="line">      : T[K] <span class="keyword">extends</span> <span class="built_in">Object</span></span><br><span class="line">        ? Camelize&lt;T[K]&gt;</span><br><span class="line">        : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：<code>CamelCase</code>的实现可以分为两个部分，第一部分来自于处理属性<code>key</code>转小驼峰的情况，第二部分来自于嵌套对象的情况。</p><ul><li>处理属性<code>key</code>：根据之前介绍过的<code>as</code>用法，我们可以在<code>in</code>迭代过程中使用<code>as</code>来进一步<strong>加工或者处理</strong>属性<code>key</code>，也就是<code>CamelCase</code>的部分。</li><li>处理嵌套对象：对于<code>T[P]</code>而言，我们考虑嵌套对象为数组和普通对象的情况，首先判断是否为数组类型，如果是则迭代数组递归调用<code>Camelize</code>；如果是普通对象，则直接调用<code>Camelize</code>；如果都不是，则直接返回<code>T[P]</code>即可。</li></ul><h3 id="DropString-移除全部字符"><a href="#DropString-移除全部字符" class="headerlink" title="DropString(移除全部字符)"></a>DropString(移除全部字符)</h3><p><link-and-solution num="2059"></link-and-solution></p><h4 id="用法-118"><a href="#用法-118" class="headerlink" title="用法"></a>用法</h4><p><code>DropString</code>是用来移除全部字符的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'ooar!'</span></span><br><span class="line"><span class="keyword">type</span> result = DropString&lt;<span class="string">'foobar!'</span>, <span class="string">'fb'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-118"><a href="#实现方式-118" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrngToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 | StrngToUnion&lt;S2&gt;</span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DropString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U = StrngToUnion&lt;R&gt;</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> U</span><br><span class="line">      ? DropString&lt;S2, R&gt;</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;S1&#125;</span><span class="subst">$&#123;DropString&lt;S2, R&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br></pre></td></tr></table></figure><p>代码详解：实现<code>DropString</code>的核心是将指定的字符串转换为联合类型，转换之后只需要迭代字符串，判断当前迭代的字符是不是在联合类型中，如果是则直接丢弃，不是则原样保留。</p><h3 id="Split-字符串Split方法"><a href="#Split-字符串Split方法" class="headerlink" title="Split(字符串Split方法)"></a>Split(字符串Split方法)</h3><p><link-and-solution num="2822"></link-and-solution></p><h4 id="用法-119"><a href="#用法-119" class="headerlink" title="用法"></a>用法</h4><p><code>Split</code>是用来实现字符串<code>split</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：["Hi!", "How", "are", "you?"]</span></span><br><span class="line"><span class="keyword">type</span> result = Split&lt;<span class="string">'Hi! How are you?'</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-119"><a href="#实现方式-119" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Split&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  SEP <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer _&#125;</span>`</span></span><br><span class="line">      ? S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;SEP&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">        ? Split&lt;S2, SEP, [...R, S1]&gt;</span><br><span class="line">        : S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">          ? SEP <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">            ? R</span><br><span class="line">            : [...R, S]</span><br><span class="line">          : [...R, S]</span><br><span class="line">      : <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure><h3 id="ClassPublicKeys-类的公共键"><a href="#ClassPublicKeys-类的公共键" class="headerlink" title="ClassPublicKeys(类的公共键)"></a>ClassPublicKeys(类的公共键)</h3><p><link-and-solution num="2828"></link-and-solution></p><h4 id="用法-120"><a href="#用法-120" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-120"><a href="#实现方式-120" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsRequiredKeys-是否为必填key"><a href="#IsRequiredKeys-是否为必填key" class="headerlink" title="IsRequiredKeys(是否为必填key)"></a>IsRequiredKeys(是否为必填key)</h3><p><link-and-solution num="2857"></link-and-solution></p><h4 id="用法-121"><a href="#用法-121" class="headerlink" title="用法"></a>用法</h4><p><code>IsRequiredKeys</code>是用来判断是否为必填<code>key</code>的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsRequiredKeys&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsRequiredKeys&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-121"><a href="#实现方式-121" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsRequiredKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T <span class="keyword">extends</span> Record&lt;K, T[K]&gt; ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>根据<code>IsRequiredKey</code>的实现思路，我们可以很容易实现<code>IsOptionalKey</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsOptionalKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;&#125; <span class="keyword">extends</span> &#123; [P <span class="keyword">in</span> K]: T[P] &#125; ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsOptionalKey&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsOptionalKey&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="ObjectEntries-对象Object-entries方法"><a href="#ObjectEntries-对象Object-entries方法" class="headerlink" title="ObjectEntries(对象Object.entries方法)"></a>ObjectEntries(对象Object.entries方法)</h3><p><link-and-solution num="2949"></link-and-solution></p><h4 id="用法-122"><a href="#用法-122" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-122"><a href="#实现方式-122" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsPalindrome-是否为回文"><a href="#IsPalindrome-是否为回文" class="headerlink" title="IsPalindrome(是否为回文)"></a>IsPalindrome(是否为回文)</h3><p><link-and-solution num="4037"></link-and-solution></p><h4 id="用法-123"><a href="#用法-123" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-123"><a href="#实现方式-123" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="MutableKeys-所有可写键"><a href="#MutableKeys-所有可写键" class="headerlink" title="MutableKeys(所有可写键)"></a>MutableKeys(所有可写键)</h3><p><link-and-solution num="5181"></link-and-solution></p><h4 id="用法-124"><a href="#用法-124" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-124"><a href="#实现方式-124" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Intersection-交集"><a href="#Intersection-交集" class="headerlink" title="Intersection(交集)"></a>Intersection(交集)</h3><p><link-and-solution num="5423"></link-and-solution></p><h4 id="用法-125"><a href="#用法-125" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-125"><a href="#实现方式-125" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="BinaryToDecimal-二进制转十进制"><a href="#BinaryToDecimal-二进制转十进制" class="headerlink" title="BinaryToDecimal(二进制转十进制)"></a>BinaryToDecimal(二进制转十进制)</h3><p><link-and-solution num="6141"></link-and-solution></p><h4 id="用法-126"><a href="#用法-126" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-126"><a href="#实现方式-126" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectKeyPaths-对象属性键路径"><a href="#ObjectKeyPaths-对象属性键路径" class="headerlink" title="ObjectKeyPaths(对象属性键路径)"></a>ObjectKeyPaths(对象属性键路径)</h3><p><link-and-solution num="7258"></link-and-solution></p><h4 id="用法-127"><a href="#用法-127" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-127"><a href="#实现方式-127" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="TwoSum-LeetCode两数之和"><a href="#TwoSum-LeetCode两数之和" class="headerlink" title="TwoSum(LeetCode两数之和)"></a>TwoSum(LeetCode两数之和)</h3><p><link-and-solution num="8804"></link-and-solution></p><h4 id="用法-128"><a href="#用法-128" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-128"><a href="#实现方式-128" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ValidDate-校验是否为合法日期"><a href="#ValidDate-校验是否为合法日期" class="headerlink" title="ValidDate(校验是否为合法日期)"></a>ValidDate(校验是否为合法日期)</h3><p><link-and-solution num="9155"></link-and-solution></p><h4 id="用法-129"><a href="#用法-129" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-129"><a href="#实现方式-129" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Assign-对象Object-assign方法"><a href="#Assign-对象Object-assign方法" class="headerlink" title="Assign(对象Object.assign方法)"></a>Assign(对象Object.assign方法)</h3><p><link-and-solution num="9160"></link-and-solution></p><h4 id="用法-130"><a href="#用法-130" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-130"><a href="#实现方式-130" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Maximum-数字中的最大值"><a href="#Maximum-数字中的最大值" class="headerlink" title="Maximum(数字中的最大值)"></a>Maximum(数字中的最大值)</h3><p><link-and-solution num="9384"></link-and-solution></p><h4 id="用法-131"><a href="#用法-131" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-131"><a href="#实现方式-131" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="DeepCapitalize-深度首字母大写"><a href="#DeepCapitalize-深度首字母大写" class="headerlink" title="DeepCapitalize(深度首字母大写)"></a>DeepCapitalize(深度首字母大写)</h3><p><link-and-solution num="9775"></link-and-solution></p><h4 id="用法-132"><a href="#用法-132" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-132"><a href="#实现方式-132" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="UnionReplace-联合类型替换"><a href="#UnionReplace-联合类型替换" class="headerlink" title="UnionReplace(联合类型替换)"></a>UnionReplace(联合类型替换)</h3><p><link-and-solution num="13580"></link-and-solution></p><h4 id="用法-133"><a href="#用法-133" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-133"><a href="#实现方式-133" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="FizzBuzz-Fizz和Buzz输出问题"><a href="#FizzBuzz-Fizz和Buzz输出问题" class="headerlink" title="FizzBuzz(Fizz和Buzz输出问题)"></a>FizzBuzz(Fizz和Buzz输出问题)</h3><p><link-and-solution num="14080"></link-and-solution></p><h4 id="用法-134"><a href="#用法-134" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-134"><a href="#实现方式-134" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="RLE-运行长度编码"><a href="#RLE-运行长度编码" class="headerlink" title="RLE(运行长度编码)"></a>RLE(运行长度编码)</h3><p><link-and-solution num="14188"></link-and-solution></p><h4 id="用法-135"><a href="#用法-135" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-135"><a href="#实现方式-135" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectPathArray-对象键路径数组"><a href="#ObjectPathArray-对象键路径数组" class="headerlink" title="ObjectPathArray(对象键路径数组)"></a>ObjectPathArray(对象键路径数组)</h3><p><link-and-solution num="15260"></link-and-solution></p><h4 id="用法-136"><a href="#用法-136" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-136"><a href="#实现方式-136" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="SnakeCase-字符串下划线连接"><a href="#SnakeCase-字符串下划线连接" class="headerlink" title="SnakeCase(字符串下划线连接)"></a>SnakeCase(字符串下划线连接)</h3><p><link-and-solution num="19458"></link-and-solution></p><h4 id="用法-137"><a href="#用法-137" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-137"><a href="#实现方式-137" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsNegativeNumber-是否为负数"><a href="#IsNegativeNumber-是否为负数" class="headerlink" title="IsNegativeNumber(是否为负数)"></a>IsNegativeNumber(是否为负数)</h3><p><link-and-solution num="25747"></link-and-solution></p><h4 id="用法-138"><a href="#用法-138" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-138"><a href="#实现方式-138" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="OptionalUndefined-按需转换为可选属性"><a href="#OptionalUndefined-按需转换为可选属性" class="headerlink" title="OptionalUndefined(按需转换为可选属性)"></a>OptionalUndefined(按需转换为可选属性)</h3><p><link-and-solution num="28143"></link-and-solution></p><h4 id="用法-139"><a href="#用法-139" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-139"><a href="#实现方式-139" class="headerlink" title="实现方式"></a>实现方式</h4><h2 id="地狱"><a href="#地狱" class="headerlink" title="地狱"></a>地狱</h2><p>撰写中…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript进阶教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript教程(一)</title>
    <link href="/2024/08/01/TypeScript%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
    <id>/2024/08/01/TypeScript教程-一/</id>
    <published>2024-08-01T06:37:09.000Z</published>
    <updated>2024-08-02T01:52:16.585Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript基础教程<br><a id="more"></a></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><code>TypeScript</code>是<code>JavaScript</code>的一个超集，主要提供了<strong>类型系统</strong>和对<strong>ES6</strong>的支持，它于2012年10月正式发布第一个版本。</p><p>优势：</p><ul><li>能在开发过程中更快的发现潜在问题。</li><li>对编辑器更友好的代码提示功能。</li><li>代码语义更清晰易懂。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>你首先需要在<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>按照你电脑的操作系统下载对应的<code>Node</code>版本进行安装。</p><h3 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>你需要使用如下命令全局安装<code>TypeScript</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">$ npm install -g typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后，查看版本号</span></span><br><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>如果你对具体版本有严格的要求，你同样可以按照指定版本号进行安装。</p></blockquote><p>如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按指定版本号进行安装</span></span><br><span class="line">$ npm install -g typescript@3.6.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后，查看版本号</span></span><br><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure></p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>在正式开始学习<code>TypeScript</code>之前，我们需要创建一个叫做<code>TypeScript</code>的文件夹：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">$ mkdir TypeScript</span><br></pre></td></tr></table></figure></p><p>随后在<code>TypeScript</code>文件夹中创建<code>demo.ts</code>文件，其代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello,world'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>.ts</code>中的代码一般而言是不能直接运行在浏览器的，需要我们把<code>typescript</code>代码进行编译成普通的<code>javascript</code>代码以后才能运行在浏览器，我们可以使用如下命令来进行编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译命令</span></span><br><span class="line">$ tsc demo.ts</span><br></pre></td></tr></table></figure></p><p>当编译完毕后，我们可以在文件夹中看到多出来了一个叫做<code>demo.js</code>文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- TypeScript</span><br><span class="line">|   |-- demo.js</span><br><span class="line">|   |-- demo.ts</span><br></pre></td></tr></table></figure></p><p>随后我们需要使用如下命令来执行我们编译后的<code>javascript</code>代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ node demo.js</span><br></pre></td></tr></table></figure></p><p>当执行完毕以上命令后，你可以在终端上看到输出一下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,world</span><br></pre></td></tr></table></figure></p><p><strong>简化过程</strong>：我们发现，如果要运行一个<code>.ts</code>文件，我们首先需要使用<code>tsc</code>命令去编译它，随后再使用<code>node</code>命令去执行它，那么有没有一种工具能够一个步骤就帮我们做完以上的事情呢？我们需要全局安装一个叫做<code>ts-node</code>的工具：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ts-node</span></span><br><span class="line">$ npm install ts-node -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕，查看版本号</span></span><br><span class="line">$ ts-node -v</span><br></pre></td></tr></table></figure></p><p>在<code>ts-node</code>安装完毕后，我们先删除<code>demo.js</code>文件，随后使用<code>ts-node</code>命令来编译并执行我们的代码：</p><blockquote><p>warning<br><code>ts-node</code>包有升级更新，如果运行<code>ts-node</code>命令报错，请按照<code>ts-node</code>最新文档进行处理。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除demo.js文件</span></span><br><span class="line">$ rm demo.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译并执行</span></span><br><span class="line">$ ts-node demo.ts</span><br></pre></td></tr></table></figure><p>以上命令执行完毕后，你将会看到与上面实例相同的输出结果。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>我们知道<code>JavaScript</code>分为<strong>原始数据类型</strong>和<strong>对象类型</strong>，原始数据类型包括：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>和<code>symbol</code>。<br>在<code>TypeScript</code>中，我们可以如下定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsNum: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> tsStr: <span class="built_in">string</span> = <span class="string">'AAA'</span></span><br><span class="line"><span class="keyword">let</span> tsFlag: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> tsNull: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> tsUndefined: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="void空值"><a href="#void空值" class="headerlink" title="void空值"></a>void空值</h4><p>我们知道在<code>JavaScript</code>中，是没有空值(<code>void</code>)的概念的，但在<code>TypeScript</code>中，可以使用<code>void</code>来表示一个没有返回值的函数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以定义一个<code>void</code>类型的变量，不过这样的变量并没有什么意义，因为我们只能给这种变量赋值为<code>null</code>或<code>undefined</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> voidValue1: <span class="built_in">void</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> voidValue2: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="void、null和undefined"><a href="#void、null和undefined" class="headerlink" title="void、null和undefined"></a>void、null和undefined</h4><p><code>void</code>和<code>null</code>与<code>undefined</code>是有一定区别的，在<code>TypeScript</code>中，<code>null</code>和<code>undefined</code>是所有类型的子类型，也就是说可以把<code>undefined</code>或<code>null</code>赋值给<code>number</code>等类型的变量:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsNumber1: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> tsNumber2: <span class="built_in">number</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>而对于<code>void</code>而言，它只能被赋值为<code>null</code>或者<code>undefined</code>：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两行代码会编译报错</span></span><br><span class="line"><span class="keyword">let</span> voidValue1: <span class="built_in">void</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> voidValue2: <span class="built_in">void</span> = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p>任意值<code>Any</code>用来表示可以接受任何类型的值。</p><p>在有以上内容的基础上，我们知道以下代码会报错：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量被定义为number，那么它只能接受number类型的值，不能改变其类型，会编译报错</span></span><br><span class="line"><span class="keyword">let</span> tsNumber: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line">tsNumber = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>但是如果一个变量被定义为<code>any</code>，那么代表它可以接受任何类型的值：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是正确的，编译成功</span></span><br><span class="line"><span class="keyword">let</span> tsAny: <span class="built_in">any</span> = <span class="number">123</span></span><br><span class="line">tsAny = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>现在我们来思考一个问题，如果我们定义了一个变量，没有指定其类型，也没有初始化，那么它默认为<code>any</code>类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是正确的，编译成功</span></span><br><span class="line"><span class="keyword">let</span> tsValue</span><br><span class="line">tsValue = <span class="number">123</span></span><br><span class="line">tsValue = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><h3 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h3><p>在以上的所有实例中，我们都为每一个变量提供了一个确定的类型，这种做法就叫做<strong>类型注解</strong>。而有些时候，当我们没有为其提供一个确定的类型，但提供了一个确定的值，那么<code>TypeScript</code>会根据我们给定的值的类型自动推断出这个变量的类型，这就叫<strong>类型推断</strong>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typescript会自动为num1变量推断为number</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typescript会自动为num4变量推断为number</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">456</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">789</span></span><br><span class="line"><span class="keyword">let</span> num4 = num2 + num3</span><br></pre></td></tr></table></figure></p><p>根据以上的案例，当我们给一个变量一个明确值的情况下，我们可以省略为其定义类型。但如果在函数参数中，则我们必须为其指定一个类型，如果不指定则默认为<code>any</code>:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者省略函数的返回值类型，因为typescript会基于num1和num1全部为number类型，从而推断出函数返回值为number类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>建议</strong>：始终为函数返回值提供一个确定的类型是有一个比较推荐的好习惯。</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p><strong>联合类型</strong>：表示取值可以为多种类型中的一种，多种类型使用<code>|</code>分隔开。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">value = <span class="number">123</span></span><br><span class="line">value = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>当我们使用联合类型的时候，因为<code>TypeScript</code>不确定到底是哪一个类型，所以我们只能访问此联合类型的所有类型公用的属性和方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span> (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码不会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueToStr</span> (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>warning<br>另外一个值得注意的地方就是，当联合类型被赋值后，<code>TypeScript</code>会根据类型推断来确定变量的类型，一旦确定后，则此变量只能使用这种类型的属性和方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsValue: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">tsValue = <span class="string">'123'</span></span><br><span class="line"><span class="built_in">console</span>.log(tsValue.length) <span class="comment">// 编译正确</span></span><br><span class="line">tsValue = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(tsValue.length) <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在<code>TypeScript</code>中，接口<code>interface</code>是一个比较重要的概念，它是对行为的抽象，而具体的行为需要由类去实现，接口<code>interface</code>中的任何代码都不会被最后编译到<code>JavaScript</code>中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，<code>person</code>变量它是<code>Person</code>类型的，那么此变量只能接受接口规定的属性，且属性值的类型也必须和接口中规定的一致，多一个属性或者少一个属性在<code>TypeScript</code>中都不是被允许的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">let</span> person1: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">let</span> person2: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的任意属性"><a href="#接口中的任意属性" class="headerlink" title="接口中的任意属性"></a>接口中的任意属性</h4><p>以上一个例子为基础，假设我们接口只对<code>name</code>和<code>age</code>做规定，其它任何属性都是可以的，那么我们可以如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  <span class="comment">// 任意属性</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的可选属性"><a href="#接口中的可选属性" class="headerlink" title="接口中的可选属性"></a>接口中的可选属性</h4><p>现在假设，我们有一个接口，它只对<code>name</code>做规定，但是对于是否包含<code>age</code>不做要求，那么可以如下方式进行处理：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  <span class="comment">// age属性是可选的</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成功</span></span><br><span class="line"><span class="keyword">let</span> person1: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的只读属性"><a href="#接口中的只读属性" class="headerlink" title="接口中的只读属性"></a>接口中的只读属性</h4><p>最后我们要介绍的知识点是只读属性，一旦在接口中标记了属性为只读的， 那么其不能被赋值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  readonly age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">person.age = <span class="number">32</span></span><br></pre></td></tr></table></figure></p><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>在<code>JavaScript</code>中，定义函数有三种表现形式：</p><ul><li>函数声明。</li><li>函数表达式。</li><li>箭头函数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> func2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> func3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数有参数，则必须在<code>TypeScript</code>中为其定义具体的类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">// 输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="string">'2'</span>))  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><h4 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h4><p>函数也可以使用接口来定义其类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AddInterface &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add: AddInterface = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure></p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>前面我们已经提到过，必须为具体的参数提供具体的类型，但如果一个函数接受一个参数，这个参数又是可选的，那么我们可以如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  b ? a * b : a * a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>))     <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>可选参数必须放在最后一个位置，否则会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">b?: <span class="built_in">number</span>, a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  b ? a * b : a * a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>在<code>JavaScript</code>中，函数允许我们给参数设置默认值，因此另外一种处理可选参数的方式是，为参数提供一个默认值，此时<code>TypeScript</code>将会把该参数识别为可选参数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span> = 1</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>))     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>给一个参数设置了默认值后，就不再受<code>TypeScript</code>可选参数必须在最后一个位置的限制了。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">b: <span class="built_in">number</span> = 1, a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时必须显示的传递一个undefined进行占位</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="literal">undefined</span>,<span class="number">4</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))        <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>在<code>ES6</code>中，我们可以使用<code>...</code>符号进行收缩剩余参数，在<code>TypeScript</code>中，我们依然可以这么做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest是一个数组，我们可以使用数组的类型来定义它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span> (<span class="params">a: number, ...rest: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)    <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(rest) <span class="comment">// [2, 3, 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,)</span><br></pre></td></tr></table></figure></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>因为在<code>JavaScript</code>中，并没有限制函数参数的个数或者类型，因此<code>JavaScript</code>没有函数重载的概念，在<code>TypeScript</code>中对于函数重载的理解是：只要函数参数的类型或者函数参数的数量不同时，就可以认为这是两个函数(重载)。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个为函数声明，最后一个才是函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">''</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'1'</span>, <span class="string">'2'</span>))  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>在有函数重载时，会优先从第一个进行逐一匹配，因此如果重载函数有包含关系，应该将最精准的函数定义写在最前面。</p></blockquote><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在上面联合类型中，我们知道可以变量可以是多个类型的，这可能会在代码编写的过程中带给我们一些困惑：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'student'</span></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'teacher'</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">person: Student | Teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 强制断言为Student类型</span></span><br><span class="line">    (person <span class="keyword">as</span> Student).sayHi()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 强制断言为Teacher类型</span></span><br><span class="line">    (person <span class="keyword">as</span> Teacher).sayHello()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> Student()</span><br><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> Teacher()</span><br><span class="line">print(stu)      <span class="comment">// student</span></span><br><span class="line">print(teacher)  <span class="comment">// teacher</span></span><br></pre></td></tr></table></figure></p><p>代码分析：在<code>print</code>函数中，我们接受的参数可以是<code>Student</code>或者<code>Teacher</code>，在此函数内部我们希望能够根据不同的类型来调用不同的方法。我们首先使用<code>instanceof</code>来判断参数是否为<code>Student</code>类的实例，是我们将<code>person</code>参数强制断言成<code>Student</code>类型，此时就可以安全的调用<code>sayHi</code>方法了，<code>Teacher</code>同理。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名用<code>type</code>关键字来给一个类型起一个新的名字，类型别名常用于联合类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> combineType = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> typeObj = &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> value1: combineType = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> obj: typeObj = &#123;</span><br><span class="line">  age: <span class="number">123</span>,</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型用来表示一个变量只能取某几个字符串值中的一个。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eventName = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span> (<span class="params">event: eventName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="string">'click'</span>)    <span class="comment">// click</span></span><br><span class="line">handleEvent(<span class="string">'scroll'</span>)   <span class="comment">// scroll</span></span><br><span class="line">handleEvent(<span class="string">'dbclick'</span>)  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>和普通的变量一样，数组中的类型定义也有一定的规则：类型+方括号表示<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number类型</span></span><br><span class="line"><span class="keyword">let</span> numArray: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 只允许存储string类型</span></span><br><span class="line"><span class="keyword">let</span> strArray: <span class="built_in">string</span>[] = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>值得一提的是，以上案例还有一种泛型方式的写法：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number类型</span></span><br><span class="line"><span class="keyword">let</span> numArray: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 只允许存储string类型</span></span><br><span class="line"><span class="keyword">let</span> strArray: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>在数组中也可以使用联合类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number和string类型的值</span></span><br><span class="line"><span class="keyword">let</span> tsArray: (<span class="built_in">number</span> | <span class="built_in">string</span>) [] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>我们知道，在数组中不仅可以存储基础数据类型，还可以存储对象类型，如果需要存储对象类型，可以用如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储对象仅有name和age，且name为string类型，age为number类型的对象</span></span><br><span class="line"><span class="keyword">let</span> objArray: (&#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;)[] = [</span><br><span class="line">  &#123; name: <span class="string">'AAA'</span>, age: <span class="number">23</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>为了更加方便的撰写代码，我们可以使用类型别名的方式来管理以上类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objArray: person[] = [</span><br><span class="line">  &#123; name: <span class="string">'AAA'</span>, age: <span class="number">23</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>对元组的理解是：一个数组如果知道它确定的长度，且每个位置的值的类型也是确定的，那么就可以把这样的数组称为元组。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple数组只有2个元素，并且第一个元素类型为string，第二个元素类型为number</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'AAA'</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>当访问元组中已知位置的索引时，将得到其对应正确的值；当访问元组中未知位置的索引时，会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'AAA'</span>, <span class="number">123</span>]</span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">1</span>]) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">2</span>]) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举<code>Enum</code>类型用来表示取值限定在指定的范围，例如一周只能有七天，颜色只能有红、绿、蓝等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors.red)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.green) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.blue)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>代码分析：我们定义一个<code>colors</code>的枚举类型，其取值只能是<code>red</code>、<code>green</code>、<code>blue</code>。我们可以在打印的内容发现，其输出值从0开始，依次累加1。这是枚举类型的默认行为，我们可以手动设置一个起始值：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red = <span class="number">10</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors.red)   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.green) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.blue)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><p>在枚举类型中，我们不仅可以正向的获取值，还可以通过值反向获取枚举：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red = <span class="number">10</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">10</span>]) <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">11</span>]) <span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">12</span>]) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>在<code>JavaScript</code>中，通过<code>extends</code>关键字来实现子类继承父类，子类也可以通过<code>super</code>关键字来访问父类的属性或者方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  sayTeacherHello () &#123;</span><br><span class="line">    <span class="comment">// 调用父类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sayHello()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> Teacher(<span class="string">'why'</span>)</span><br><span class="line">teacher.sayHello()        <span class="comment">// hello, why</span></span><br><span class="line">teacher.sayTeacherHello() <span class="comment">// hello, why</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>有一种关于类属性的简写方式，就是在类的构造函数中指明访问修饰符。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写形式</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>在<code>class</code>中，可以通过<code>getter</code>和<code>setter</code>来改变属性的读取和赋值行为。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">// 私有属性，只能在类中进行访问</span></span><br><span class="line">  <span class="keyword">private</span> _name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// why</span></span><br><span class="line">person.name = <span class="string">'AAA'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// AAA</span></span><br></pre></td></tr></table></figure></p><h4 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h4><p>所谓静态属性和静态方法，就是只能通过类来进行访问，不能通过类的实例来进行访问。在众多设计模式中，有一种设计模式叫做单例设计模式，可以使用<code>static</code>静态方法来辅助我们完成单例设计模式。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> _instance: Person</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> getInstance () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>._instance = <span class="keyword">new</span> Person()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = Person.getInstance()</span><br><span class="line"><span class="keyword">const</span> person2 = Person.getInstance()</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h4 id="TypeScript类的访问修饰符"><a href="#TypeScript类的访问修饰符" class="headerlink" title="TypeScript类的访问修饰符"></a>TypeScript类的访问修饰符</h4><p>在以上的实例中，我们使用到了<code>TypeScript</code>中关于类的几种访问修饰符，它有三种：</p><ul><li><code>public</code>：公有的，在任何地方都可以访问到。</li><li><code>protected</code>：受保护的，只能在类的内部及其类的子类内部使用。</li><li><code>private</code>：私有的，只能在类的内部进行使用。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> age: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">protected</span> address: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">age: <span class="built_in">number</span>, address: <span class="built_in">string</span>, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.address = address</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my addresss is <span class="subst">$&#123;<span class="keyword">this</span>.address&#125;</span>`</span>) <span class="comment">// my address is 广东广州</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)        <span class="comment">// my name is why</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)          <span class="comment">// 编译报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">21</span>, <span class="string">'广东广州'</span>, <span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age)     <span class="comment">// 编译报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address) <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>可以使用<code>readonly</code>关键字来表示属性是只读的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> readonly name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'AAA'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// AAA</span></span><br><span class="line">person.name = <span class="string">'BBB'</span>       <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在<code>TypeScript</code>中，可以使用<code>abstract</code>关键字来定义抽象类以及抽象类中的抽象方法，在使用抽象类的过程中，有几点需要注意：</p><ul><li>抽象类不能被实例化，只能被继承。</li><li>抽象类中的抽象方法必须被子类实现。</li></ul><p>抽象类不能被实例化：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> Animal&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal() <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><p>抽象类中的抽象方法必须被子类实现：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> eat (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">  <span class="comment">// 子类必须实现抽象类中的抽象方法</span></span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'person is eating'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line">person.eat()                <span class="comment">// person is eating</span></span><br></pre></td></tr></table></figure></p><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><blockquote><p>tip<br>一个类可以实现一个或者多个接口，用逗号分隔。</p></blockquote><p>如果我们定义了一个接口，然后类去实现它，那么这个接口中的属性和方法，在类中必须全部都要存在，否则会编译报错。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>在上面的案例中，我们使用到了类实现接口，其实一个接口还可以继承自另外一个接口。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="comment">// Person接口继承了Animal，就拥有了Animal种所有的属性和方法</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Person &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>在有些语言中，接口一般而言是不能继承类的，但在<code>TypeScript</code>中是可以继承的，接口继承类以后，就拥有类中所有的属性和方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  y: <span class="number">10</span>,</span><br><span class="line">  z: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(point3d)  <span class="comment">// &#123; x: 10, y: 10, z: 10 &#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型<code>generics</code>是指在定义函数、接口和类的时候，不预先指定其具体类型，而在使用的时候再去指定的一种特性。</p><h4 id="函数中的泛型"><a href="#函数中的泛型" class="headerlink" title="函数中的泛型"></a>函数中的泛型</h4><p>假设我们有如下一个函数，其中参数<code>a</code>和<code>b</code>接受的类型必须为相同的类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在没有了解到泛型之前，我们可以用联合类型来定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码分析：在以上的例子中，我们仅仅只是规定了<code>a</code>和<code>b</code>参数必须是<code>number</code>类型或者<code>string</code>类型，但并没有办法来限制<code>a</code>和<code>b</code>必须是同一个类型。这个时候我们可以使用泛型来表示：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>&gt; (<span class="params">a: T, b: T</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：我们在调用<code>join()</code>函数并进行传参的时候，<code>TypeScript</code>会自动帮我们推断参数的类型，以上三行代码也可以像如下方式进行撰写：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">string</span>&gt;(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>泛型可以是多个的。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt; (<span class="params">a: T, b: P</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>代码分析：在以上的案例中，<code>join</code>方法接受2个泛型类型，其中参数<code>a:T</code>，参数<code>b:p</code>，因此<code>console.log(join(1, &#39;2&#39;))</code>会正确被编译并输出12。</p><h4 id="类中的泛型"><a href="#类中的泛型" class="headerlink" title="类中的泛型"></a>类中的泛型</h4><p>泛型同样可以使用在类中。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CreateClass&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createNumber = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">createNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createString = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">createString.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createNumber.add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(createString.add(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>在<a href="mailto:`TypeScript@2.3" target="_blank" rel="noopener">`TypeScript@2.3</a>+`以后的版本，我们可以为泛型提供一个默认值。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CreateClass&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createNumber = <span class="keyword">new</span> CreateClass()</span><br><span class="line">createNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createString = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">createString.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createNumber.add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(createString.add(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>代码分析：在<code>CreateClass</code>类的定义部分，我们为泛型提供了一个默认值<code>number</code>，因此我们在实例<code>createNumber</code>初始化的时候就可以不用传递<code>number</code>了。</p><h4 id="接口中的泛型"><a href="#接口中的泛型" class="headerlink" title="接口中的泛型"></a>接口中的泛型</h4><p>像在类中一样，泛型可以存在于接口中。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArray &#123;</span><br><span class="line">  &lt;T&gt;(length: <span class="built_in">number</span>, value: T): T[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createArrayFunc: CreateArray = <span class="function"><span class="keyword">function</span> (<span class="params">length, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    result[index] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createArrayFunc(<span class="number">3</span>, <span class="string">'AAA'</span>))  <span class="comment">// ['AAA', 'AAA', 'AAA']</span></span><br><span class="line"><span class="built_in">console</span>.log(createArrayFunc(<span class="number">2</span>, <span class="literal">true</span>))   <span class="comment">// [true, true]</span></span><br></pre></td></tr></table></figure></p><h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。<br>声明合并，我们在上面已经有实例的案例了，那就是函数的重载。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">''</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'1'</span>, <span class="string">'2'</span>))  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><p>当重复定义同一个接口时，会进行接口合并：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p> warning<br>当合并的属性类型不一致时，会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="comment">// 报错，name类型冲突</span></span><br><span class="line">  name: <span class="built_in">number</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在我们以上所有案例中，我们编写的代码大多数是运行在<code>Node</code>环境下的，接下来我们来编写一些代码，让其在浏览器环境中运行。</p><p>首先我们需要创建如下的项目以及目录结构：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-- TypeScript</span><br><span class="line">|   |-- dist</span><br><span class="line">|   |   |-- index.html</span><br><span class="line">|   |-- src</span><br><span class="line">|   |   |-- page.ts</span><br><span class="line">|   |-- tsconfig.json</span><br></pre></td></tr></table></figure></p><p>其中，<code>tsconfig.json</code>的配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                </span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist"</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./src"</span>, </span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在配置完<code>tsconfig.json</code>以后，我们来撰写<code>page.ts</code>中的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Header &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Header'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Content &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Content'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Footer &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Footer'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Page &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Header()</span><br><span class="line">    <span class="keyword">new</span> Content()</span><br><span class="line">    <span class="keyword">new</span> Footer()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写完以上代码后，我们运行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译src下的*.ts文件到dist目录下</span></span><br><span class="line">$ tsc</span><br></pre></td></tr></table></figure></p><p>随后我们在<code>dist/index.html</code>中引用我们刚刚编译的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Page()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当我们在浏览器中运行<code>index.html</code>文件后，我们可以在浏览器下正确的看到我们想要的输出内容。</p><p>当我们在打开<code>page.js</code>文件时，我们可以发现：<br><img src="/2024/08/01/TypeScript教程-一/1.png" alt="page.js代码"></p><p><strong>在全局作用域环境下，我们一次性引入了四个全局变量</strong>：<code>Header</code>、<code>Content</code>、<code>Footer</code>和<code>Page</code>。要解决这个问题，我们可以使用<code>namespace</code>命令空间：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名空间包裹我们的代码并把Page类导出出去</span></span><br><span class="line"><span class="keyword">namespace</span> Home &#123;</span><br><span class="line">  <span class="keyword">class</span> Header &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Header'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> Content &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Content'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> Footer &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Footer'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Page &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> Header()</span><br><span class="line">      <span class="keyword">new</span> Content()</span><br><span class="line">      <span class="keyword">new</span> Footer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随后，再次使用<code>tsc</code>命令重新编译代码，编译后的<code>page.js</code>如下：<br><img src="/2024/08/01/TypeScript教程-一/2.png" alt="Page.js代码"></p><p>再次修改<code>index.html</code>中的代码，我们依然能够得到跟前面示例代码一样的输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Home.Page()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript基础教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>electron基础入门</title>
    <link href="/2024/07/17/electron%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>/2024/07/17/electron基础入门/</id>
    <published>2024-07-17T01:22:37.000Z</published>
    <updated>2024-07-19T06:31:12.918Z</updated>
    
    <content type="html"><![CDATA[<p>electron+vue3+pinia构建一个桌面应用<br><a id="more"></a><br>Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux。</p><p>本教程使用vite+vue3+pinia配合electron开发一个桌面应用。</p><blockquote><p>app应用功能，点击添加按钮，弹出dialog，填写内容后提交，将内容保存在<code>public/files</code>文件夹下，并且当前列表会展示出目前的文件列表。点击相应的文件会跳转到详情页展示。</p></blockquote><h1 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h1><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><h3 id="安装vue3"><a href="#安装vue3" class="headerlink" title="安装vue3"></a>安装vue3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>按照命令行提示输入项目名<code>base-tutorial</code>,之后选择<code>vue</code>项目，语言<code>javascript</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd base-tutorial</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>通过上边的命令可以启动vue3项目了。</p><h2 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h2><h3 id="安装electron"><a href="#安装electron" class="headerlink" title="安装electron"></a>安装electron</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron -D</span><br></pre></td></tr></table></figure><p>electron比较大，根据网络情况可能会安装失败，多尝试几次。</p><h3 id="安装nodemon"><a href="#安装nodemon" class="headerlink" title="安装nodemon"></a>安装nodemon</h3><p>开发方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon -D</span><br></pre></td></tr></table></figure></p><p>之后在<code>package.json</code>中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;nodemon --exec electron . --watch ./ --ext .js,.html,.css,.vue&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>监控<code>.js,.html,.css,.vue</code>这些文件变化，自动重启<code>electron</code>应用。</p><h3 id="安装electron-win-state"><a href="#安装electron-win-state" class="headerlink" title="安装electron-win-state"></a>安装electron-win-state</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-win-state --save</span><br></pre></td></tr></table></figure><p><code>electron-win-state</code>可以记录应用上次关闭前窗口大小和位置。</p><h3 id="编写electron应用"><a href="#编写electron应用" class="headerlink" title="编写electron应用"></a>编写electron应用</h3><p>在<code>package.json</code>中添加<code>electron</code>应用的主入口文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;main.js&quot;</span><br></pre></td></tr></table></figure></p><p>在项目根目录下新建<code>main.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; app, BrowserWindow &#125; from &apos;electron&apos;;</span><br><span class="line">import WinState from &apos;electron-win-state&apos;; // 保存窗口位置和大小的调整</span><br><span class="line"></span><br><span class="line">const createWindow = ()=&gt; &#123;</span><br><span class="line">  const winState = new WinState.default(&#123;</span><br><span class="line">    defaultWidth: 1000,</span><br><span class="line">    defaultHeight: 800,</span><br><span class="line">    electronStoreOptions: &#123;</span><br><span class="line">      name: &apos;window-state-main&apos; // 开启多个窗口的时候分别记录</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  const win = new BrowserWindow(&#123;</span><br><span class="line">    ...winState.winOptions,</span><br><span class="line">    show: false,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  win.loadURL(&apos;http://localhost:5173&apos;);</span><br><span class="line">  win.webContents.openDevTools();</span><br><span class="line">  winState.manage(win);</span><br><span class="line">  win.on(&apos;ready-to-show&apos;, ()=&gt; &#123;</span><br><span class="line">    win.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().then(()=&gt; &#123;</span><br><span class="line">  createWindow();</span><br><span class="line"></span><br><span class="line">  app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class="line">    if (BrowserWindow.getAllWindows().length === 0) &#123;</span><br><span class="line">      createWindow()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行<code>npm start</code>,app顺利启动<br>但是在调试工具打印台会看到<code>Electron Security Warning (Insecure Content-Security-Policy)</code>警告，解决办法是在index.html中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;self&apos;; img-src &apos;self&apos; data:; style-src &apos;self&apos; &apos;unsafe-inline&apos;&quot;&gt;</span><br></pre></td></tr></table></figure></p><h1 id="添加新功能"><a href="#添加新功能" class="headerlink" title="添加新功能"></a>添加新功能</h1><p>添加路由，状态管理，ui库，css预编译，css初始化，lodash等</p><h2 id="安装对应的库"><a href="#安装对应的库" class="headerlink" title="安装对应的库"></a>安装对应的库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router --save</span><br><span class="line">npm i stylus --save</span><br><span class="line">npm i pinia --save</span><br><span class="line">npm i normalize.css --save</span><br><span class="line">npm i lodash --save</span><br><span class="line">npm i element-plus --save</span><br></pre></td></tr></table></figure><h2 id="改造vue内容"><a href="#改造vue内容" class="headerlink" title="改造vue内容"></a>改造vue内容</h2><h3 id="修改App-vue"><a href="#修改App-vue" class="headerlink" title="修改App.vue"></a>修改App.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;electron基础入门&lt;/h1&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>添加路由插槽<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><h3 id="新建views"><a href="#新建views" class="headerlink" title="新建views"></a>新建views</h3><p>在<code>src</code>目录下，新建<code>views</code>文件夹<br>在<code>views</code>下新建<code>Home.vue，Detail.vue</code>文件</p><h3 id="新建router"><a href="#新建router" class="headerlink" title="新建router"></a>新建router</h3><p>在<code>src</code>目录下，新建<code>router</code>文件夹<br>在<code>router</code>下新建<code>index.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createRouter, createWebHashHistory &#125; from &apos;vue-router&apos;;</span><br><span class="line">import Home from &apos;@/views/Home.vue&apos;;</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    redirect: &apos;/home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/home&apos;,</span><br><span class="line">    name: &apos;home&apos;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/detail&apos;,</span><br><span class="line">    name: &apos;detail&apos;,</span><br><span class="line">    component: ()=&gt; import(&apos;@/views/Detail.vue&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure></p><h3 id="修改Home-vue"><a href="#修改Home-vue" class="headerlink" title="修改Home.vue"></a>修改Home.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted, nextTick &#125; from &apos;vue&apos;;</span><br><span class="line">import useLoadingStore from &apos;../store/loading&apos;;</span><br><span class="line">import List from &apos;./List.vue&apos;;</span><br><span class="line"></span><br><span class="line">const loadingSotate = useLoadingStore();</span><br><span class="line"></span><br><span class="line">const dialogVisible = ref(false);</span><br><span class="line">const list = ref([]);</span><br><span class="line">const refForm = ref(null);</span><br><span class="line">const form = reactive(&#123;</span><br><span class="line">  title: &apos;&apos;,</span><br><span class="line">  city: &apos;&apos;,</span><br><span class="line">  desc: &apos;&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">const rules = &#123;</span><br><span class="line">  title: [</span><br><span class="line">    &#123; required: true, message: &apos;请输入题目&apos;, trigger: &apos;blur&apos; &#125;  </span><br><span class="line">  ],</span><br><span class="line">  city: [</span><br><span class="line">    &#123; required: true, message: &apos;请选择城市&apos;, trigger: &apos;change&apos; &#125;  </span><br><span class="line">  ],</span><br><span class="line">  desc: [</span><br><span class="line">    &#123; required: true, message: &apos;请输入描述&apos;, trigger: &apos;blur&apos; &#125;  </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">const onAdd = ()=&gt; &#123;</span><br><span class="line">  dialogVisible.value = true;</span><br><span class="line">  nextTick(()=&gt; &#123;</span><br><span class="line">    refForm.value.resetFields();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const sunmitHandle = ()=&gt; &#123;</span><br><span class="line">  refForm.value.validate(async valid=&gt; &#123;</span><br><span class="line">    if(valid) &#123;</span><br><span class="line">      dialogVisible.value = false;</span><br><span class="line">      loadingSotate.set(true);</span><br><span class="line">      // 调用渲染进程提供的方法</span><br><span class="line">      await rendererApi.saveText(JSON.stringify(form));</span><br><span class="line">      loadingSotate.set(false);</span><br><span class="line">      getList();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const getList = async ()=&gt; &#123;</span><br><span class="line">  list.value = await rendererApi.getText();</span><br><span class="line">&#125;</span><br><span class="line">// 主进程调用vue侧的函数</span><br><span class="line">rendererApi.showAddDialog(()=&gt; &#123;</span><br><span class="line">  onAdd();</span><br><span class="line">&#125;);</span><br><span class="line">onMounted(async ()=&gt; &#123;</span><br><span class="line">  getList();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;onAdd&quot;&gt;+&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;List :listData=&quot;list&quot;&gt;&lt;/List&gt;</span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      v-model=&quot;dialogVisible&quot;</span><br><span class="line">      title=&quot;添加内容&quot;</span><br><span class="line">      width=&quot;80%&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;el-form :model=&quot;form&quot; ref=&quot;refForm&quot; :rules=&quot;rules&quot; label-width=&quot;auto&quot; style=&quot;max-width: 600px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;题目&quot; prop=&quot;title&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.title&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;城市&quot; prop=&quot;city&quot;&gt;</span><br><span class="line">        &lt;el-select v-model=&quot;form.city&quot; placeholder=&quot;请选择城市&quot;&gt;</span><br><span class="line">          &lt;el-option label=&quot;沈阳&quot; value=&quot;沈阳&quot; /&gt;</span><br><span class="line">          &lt;el-option label=&quot;大连&quot; value=&quot;大连&quot; /&gt;</span><br><span class="line">        &lt;/el-select&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;描述&quot; prop=&quot;desc&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.desc&quot; type=&quot;textarea&quot; :row=&quot;5&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">      &lt;template #footer&gt;</span><br><span class="line">        &lt;div class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot; @click=&quot;sunmitHandle&quot;&gt;</span><br><span class="line">            确定</span><br><span class="line">          &lt;/el-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="修改Detail-vue"><a href="#修改Detail-vue" class="headerlink" title="修改Detail.vue"></a>修改Detail.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useRoute, useRouter &#125; from &apos;vue-router&apos;;</span><br><span class="line"></span><br><span class="line">const route = useRoute();</span><br><span class="line">const router = useRouter();</span><br><span class="line">const query = route.query;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;go-back&quot;&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;router.go(-1)&quot;&gt;返回&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; query.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;来自-&#123;&#123; query.city &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;pre&gt;&#123;&#123; query.desc &#125;&#125;&lt;/pre&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.go-back &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="添加pinia"><a href="#添加pinia" class="headerlink" title="添加pinia"></a>添加pinia</h3><p>在<code>src</code>下新建<code>store</code>文件夹，新建<code>loading.js</code>文件。<br>此文件内容控制<code>Loading</code>组件显示隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &apos;pinia&apos;;</span><br><span class="line">const useLoadingStore = defineStore(&apos;websiteStore&apos;, &#123;</span><br><span class="line">state() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">bShow: false</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line">set(val) &#123;</span><br><span class="line">this.bShow = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">getBShow() &#123;</span><br><span class="line">      return this.bShow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">export default useLoadingStore;</span><br></pre></td></tr></table></figure></p><h3 id="添加loading"><a href="#添加loading" class="headerlink" title="添加loading"></a>添加loading</h3><p>在<code>App.vue</code>文件夹下添加<code>Loading</code>组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import useLoadingStore from &apos;../store/loading&apos;;</span><br><span class="line"></span><br><span class="line">const loadingSotate = useLoadingStore();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;loading-wrap&quot; v-if=&quot;loadingSotate.getBShow&quot;&gt;</span><br><span class="line">    &lt;svg class=&quot;circular&quot; viewBox=&quot;0 0 50 50&quot;&gt;&lt;circle class=&quot;path&quot; cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;20&quot; fill=&quot;none&quot;&gt;&lt;/circle&gt;&lt;/svg&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.loading-wrap &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background-color: rgba(255, 255, 255, .8);</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  .circular &#123;</span><br><span class="line">    stroke: #000000;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    animation: loading-rotate .5s linear infinite alternate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes loading-rotate &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">    opacity: 0</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(1.2);</span><br><span class="line">    opacity: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>比如在Home页面控制Loading组件显示隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loadingSotate.set(true);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  loadingSotate.set(false);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure></p><p>显示后3秒隐藏</p><h2 id="改造electron内容"><a href="#改造electron内容" class="headerlink" title="改造electron内容"></a>改造electron内容</h2><p><code>vue</code>侧提交内容后，需要将内容保存到文件里。需要修改<code>electron</code>的主进程和渲染进程</p><h3 id="electron主进程"><a href="#electron主进程" class="headerlink" title="electron主进程"></a>electron主进程</h3><h4 id="在main-js里新增"><a href="#在main-js里新增" class="headerlink" title="在main.js里新增"></a>在<code>main.js</code>里新增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webPreferences: &#123;</span><br><span class="line">  preload: path.resolve(__dirname, &apos;./preload/index.js&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>引入渲染进程文件。</p><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>在根目录下新建<code>controller</code>文件夹，再新建<code>saveText.js</code>文件，用于保存<code>vue</code>侧保存的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ipcMain &#125; from &apos;electron&apos;;</span><br><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import fs from &apos;fs&apos;;</span><br><span class="line">import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;</span><br><span class="line"></span><br><span class="line">ipcMain.handle(&apos;on-save-text-event&apos;, (e, str)=&gt; &#123;</span><br><span class="line">  const data = JSON.parse(str);</span><br><span class="line">  const filePath = path.resolve(__dirnameFn(import.meta.url), &apos;../public/files/&apos;, data.title + &apos;-&apos; + data.city + &apos;.txt&apos;);</span><br><span class="line">  fs.writeFileSync(filePath, data.desc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>ipcMain.handle</code>用来注册事件，渲染进程可以触发这个事件的回调函数。</p><h3 id="electron渲染进程"><a href="#electron渲染进程" class="headerlink" title="electron渲染进程"></a>electron渲染进程</h3><p>在根目录下新建<code>preload</code>文件夹，再新建<code>index.js</code>文件，这里都是渲染进程的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; contextBridge, ipcRenderer &#125; = require(&apos;electron&apos;)</span><br><span class="line"></span><br><span class="line">const saveText = async data=&gt; &#123;</span><br><span class="line">  let result = await ipcRenderer.invoke(&apos;on-save-text-event&apos;, data);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">contextBridge.exposeInMainWorld(&apos;myApi&apos;, &#123;</span><br><span class="line">  saveText,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>渲染进程将<code>saveText</code>这个方法暴露给vue侧，可以<code>window.saveText</code>来调用，调用时，渲染进程会触发主进程注册的对应事件的回调函数完成保存文件的功能。</p><blockquote><p>通过vue侧-&gt;渲染进程-&gt;主进程,也就是vue侧向主进程发起的通讯，后边还会实现electron主进程向vue侧发起的通讯。</p></blockquote><h2 id="后续修改略"><a href="#后续修改略" class="headerlink" title="后续修改略"></a>后续修改略</h2><p>之后还会对vue侧，渲染进程，主进程代码修改，这里就不一一列举。思路还是主进程注册事件，渲染进程暴漏给vue侧全局方法调用来触发主进程的事件回调函数。</p><h2 id="自定义Menu"><a href="#自定义Menu" class="headerlink" title="自定义Menu"></a>自定义Menu</h2><p>可以自定义<code>Menu</code>，这里为了使用主进程-&gt;渲染进程-&gt;vue侧的通讯，也就是在菜单中点击按钮，调用vue侧的一个方法。<br>这个流程与上面vue侧-&gt;渲染进程-&gt;主进程的调用正好相反。</p><h3 id="渲染进程新增事件注册"><a href="#渲染进程新增事件注册" class="headerlink" title="渲染进程新增事件注册"></a>渲染进程新增事件注册</h3><p>在preload的index.js中，新增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主进程触发渲染进程</span><br><span class="line">const showAddDialog = cb=&gt; ipcRenderer.on(&apos;on-show-add-dialog-event&apos;, (e, value)=&gt; &#123;</span><br><span class="line">  cb(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="vue侧调用"><a href="#vue侧调用" class="headerlink" title="vue侧调用"></a>vue侧调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主进程调用vue侧的函数</span><br><span class="line">rendererApi.showAddDialog(()=&gt; &#123;</span><br><span class="line">  onAdd();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="新建buildMenu-js"><a href="#新建buildMenu-js" class="headerlink" title="新建buildMenu.js"></a>新建buildMenu.js</h3><p>在<code>controller</code>下新建<code>buildMenu.js</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">import &#123; app, Menu, ipcMain &#125; from &apos;electron&apos;;</span><br><span class="line">import &#123; inject &#125; from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">const isMac = process.platform === &apos;darwin&apos;;</span><br><span class="line"></span><br><span class="line">let mainWindow = null;</span><br><span class="line"></span><br><span class="line">const template = [</span><br><span class="line">  // &#123; role: &apos;appMenu&apos; &#125;</span><br><span class="line">  ...(isMac</span><br><span class="line">    ? [&#123;</span><br><span class="line">        label: app.name,</span><br><span class="line">        submenu: [</span><br><span class="line">          &#123; role: &apos;about&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;services&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;hide&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;hideOthers&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;unhide&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;quit&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;]</span><br><span class="line">    : []),</span><br><span class="line">  // &#123; role: &apos;fileMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;File&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      isMac ? &#123; role: &apos;close&apos; &#125; : &#123; role: &apos;quit&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;editMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;Edit&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;undo&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;redo&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;cut&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;copy&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;paste&apos; &#125;,</span><br><span class="line">      ...(isMac</span><br><span class="line">        ? [</span><br><span class="line">            &#123; role: &apos;pasteAndMatchStyle&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;delete&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;selectAll&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              label: &apos;Speech&apos;,</span><br><span class="line">              submenu: [</span><br><span class="line">                &#123; role: &apos;startSpeaking&apos; &#125;,</span><br><span class="line">                &#123; role: &apos;stopSpeaking&apos; &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        : [</span><br><span class="line">            &#123; role: &apos;delete&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;selectAll&apos; &#125;</span><br><span class="line">          ])</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;viewMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;View&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;reload&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;forceReload&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;toggleDevTools&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;resetZoom&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoomIn&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoomOut&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;togglefullscreen&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;windowMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;Window&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;minimize&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoom&apos; &#125;,</span><br><span class="line">      ...(isMac</span><br><span class="line">        ? [</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;front&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;window&apos; &#125;</span><br><span class="line">          ]</span><br><span class="line">        : [</span><br><span class="line">            &#123; role: &apos;close&apos; &#125;</span><br><span class="line">          ])</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    role: &apos;help&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: &apos;Learn More&apos;,</span><br><span class="line">        click: async () =&gt; &#123;</span><br><span class="line">          const &#123; shell &#125; = require(&apos;electron&apos;)</span><br><span class="line">          await shell.openExternal(&apos;https://electronjs.org&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;actions&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: &apos;添加&apos;,</span><br><span class="line">        click: async ()=&gt; &#123;</span><br><span class="line">          // 触发renderer进程的on-show-add-dialog-event事件</span><br><span class="line">          mainWindow.webContents.send(&apos;on-show-add-dialog-event&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        accelerator: &apos;CommandOrControl+Alt+O&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const menu = Menu.buildFromTemplate(template)</span><br><span class="line">Menu.setApplicationMenu(menu)</span><br><span class="line">export const injectMainWindow = win=&gt; &#123;</span><br><span class="line">  mainWindow = win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在<code>vue</code>侧调用渲染进程暴露的函数，把需要执行的<code>vue</code>侧回调函数传进去。</li><li>渲染进程函数执行后注册了<code>on-show-add-dialog-event</code>这个渲染进程事件。</li><li><code>Menu</code>菜单点击后，主进程触发渲染进程事件，这个事件的回调函数中会执行<code>vue</code>侧提供的回调函数。</li></ul><p>通过上述步骤即可完成主进程-&gt;渲染进程-&gt;<code>vue</code>侧的通信</p><h1 id="托盘-amp-app图标"><a href="#托盘-amp-app图标" class="headerlink" title="托盘&amp;app图标"></a>托盘&amp;app图标</h1><h2 id="mac端"><a href="#mac端" class="headerlink" title="mac端"></a>mac端</h2><p>在<code>controller</code>下新建<code>tray.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 兼容mac电脑</span><br><span class="line">import &#123; Tray &#125; from &apos;electron&apos;;</span><br><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;</span><br><span class="line"></span><br><span class="line">const createTray = (app, win)=&gt; &#123;</span><br><span class="line">  const tray = new Tray(path.resolve(__dirnameFn(import.meta.url), &apos;../icon.png&apos;));</span><br><span class="line">  tray.setToolTip(&apos;electron-tutorial&apos;);</span><br><span class="line">  tray.on(&apos;click&apos;, e=&gt; &#123;</span><br><span class="line">    if(e.shiftKey) &#123;</span><br><span class="line">      app.quit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default createTray;</span><br></pre></td></tr></table></figure></p><p>在<code>main.js</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// tray 兼容mac托盘</span><br><span class="line">import createTray from &apos;./controller/tray.js&apos;;</span><br><span class="line"></span><br><span class="line">createTray(app, win);</span><br></pre></td></tr></table></figure></p><h2 id="window端"><a href="#window端" class="headerlink" title="window端"></a>window端</h2><p>在<code>main.js</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icon: nativeImage.createFromPath(path.resolve(__dirnameFn(import.meta.url), &apos;./icon.png&apos;)),</span><br></pre></td></tr></table></figure></p><h1 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h1><p>全屏功能可以应用在一些终端设备中，比如商场或者机场的自助终端。<br>在<code>main.js</code>中增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 取消浏览器头部菜单栏</span><br><span class="line">frame: false</span><br><span class="line">// 设置全屏</span><br><span class="line">win.maximize();</span><br></pre></td></tr></table></figure></p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @electron-forge/cli -D</span><br><span class="line">npm i @electron-forge/maker-squirrel -D</span><br></pre></td></tr></table></figure></p><h2 id="window端-1"><a href="#window端-1" class="headerlink" title="window端"></a>window端</h2><p>在根目录下新增<code>forge.config.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  makers: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;@electron-forge/maker-squirrel&apos;,</span><br><span class="line">      config: &#123;</span><br><span class="line">        certificateFile: &apos;./cert.pfx&apos;,</span><br><span class="line">        certificatePassword: process.env.CERTIFICATE_PASSWORD</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;make&quot;: &quot;electron-forge make&quot;</span><br></pre></td></tr></table></figure></p><p>执行<code>npm run make</code>,（网络不好有时会失败，重试几次），在根目录输出一个<code>out</code>文件夹。在里边找到项目名称的<code>exe</code>文件就是可执行app。</p><h2 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h2><p>开发调试时，<code>main.js</code>中，引入<code>vue</code>侧是<code>win.loadURL(&#39;http://localhost:5173&#39;);</code>这样引入的，这样打包的话，执行<code>app</code>应用时还需要启动<code>vue</code>项目才可以使用。<br>如果想直接把<code>vue</code>侧直接打到<code>app</code>应用包中，修改<code>main.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// win.loadURL(&apos;http://localhost:5173&apos;);</span><br><span class="line">win.loadFile(path.resolve(__dirnameFn(import.meta.url), &apos;./dist/index.html&apos;));</span><br></pre></td></tr></table></figure></p><p>还需要修改<code>dist/index.html</code>中引入的js和css的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="line">&lt;!-- &lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;/assets/index-CrynHw1J.css&quot;&gt; --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;./assets/index-CrynHw1J.css&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>将绝对路径改成相对路径。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上完成了一个简单的electron+vue的项目。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>本教程代码<a href="https://github.com/jinux7/study-collections/tree/master/electron/base-tutorial" target="_blank" rel="noopener">source</a></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>保存网站的app<br>代码<a href="https://github.com/jinux7/study-collections/tree/master/electron/readit" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;electron+vue3+pinia构建一个桌面应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
      <category term="electron" scheme="/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>pnpm创建monorepo项目</title>
    <link href="/2024/07/04/pnpm%E5%88%9B%E5%BB%BAmonorepo%E9%A1%B9%E7%9B%AE/"/>
    <id>/2024/07/04/pnpm创建monorepo项目/</id>
    <published>2024-07-04T08:15:46.000Z</published>
    <updated>2024-07-05T05:29:50.693Z</updated>
    
    <content type="html"><![CDATA[<p>使用pnpm工具创建monorepo项目<br><a id="more"></a><br>monorepo项目是当下非常流行的，例如React、Vue、Vite等项目都在使用。创建monorepo项目的方法很多，本文使用pnpm来创建。</p><h2 id="全局安装pnpm"><a href="#全局安装pnpm" class="headerlink" title="全局安装pnpm"></a>全局安装pnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>创建一个叫monorepo的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir monorepo</span><br></pre></td></tr></table></figure></p><h2 id="创建相关文件"><a href="#创建相关文件" class="headerlink" title="创建相关文件"></a>创建相关文件</h2><h3 id="初始化package-json"><a href="#初始化package-json" class="headerlink" title="初始化package.json"></a>初始化package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init</span><br></pre></td></tr></table></figure><h3 id="pnpm-workspace-yaml"><a href="#pnpm-workspace-yaml" class="headerlink" title="pnpm-workspace.yaml"></a>pnpm-workspace.yaml</h3><p>新建pnpm-workspace.yaml文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  - &apos;packages/*&apos;</span><br></pre></td></tr></table></figure></p><p>表示packages下是子项目</p><h3 id="npmignore"><a href="#npmignore" class="headerlink" title=".npmignore"></a>.npmignore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/</span><br></pre></td></tr></table></figure><p>这个文件设置发布的时候过滤掉node_modules文件夹的内容</p><h2 id="创建packages文件夹"><a href="#创建packages文件夹" class="headerlink" title="创建packages文件夹"></a>创建packages文件夹</h2><p>在packages下创建子项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir core utils api</span><br></pre></td></tr></table></figure></p><p>创建好三个子项目文件夹后，分别初始化package.json，之后需要修改package.json的name，加上npmjs上所对应的Organizations名字(名字前加@)。<br>再加上<code>&quot;publishConfig&quot;: {&quot;access&quot;: &quot;public&quot;}</code>，用来告诉npmjs这个是公开的（私有是收费的，发布的时候会报错）。<br>core package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/core&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;node ./index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@nux-monorepo/api&quot;: &quot;workspace:^&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>api package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/api&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@nux-monorepo/utils&quot;: &quot;workspace:^&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>utils package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/utils&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><h3 id="公共依赖"><a href="#公共依赖" class="headerlink" title="公共依赖"></a>公共依赖</h3><p>在monorepo目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add loadsh -w</span><br></pre></td></tr></table></figure></p><p><code>-w</code>表示在主项目目录下添加依赖</p><h3 id="局部依赖"><a href="#局部依赖" class="headerlink" title="局部依赖"></a>局部依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @nux-monorepo/utils -F @nux-monorepo/api</span><br></pre></td></tr></table></figure><p>表示给<code>@nux-monorepo/api</code>子项目添加了一个<code>@nux-monorepo/utils</code>的依赖。<br>再加一个依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @nux-monorepo/api -F @nux-monorepo/core</span><br></pre></td></tr></table></figure></p><p>可以看上边的package.json文件,添加依赖后的效果。<br>上边公共依赖和局部依赖执行命令都是在项目的根目录下执行即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以在子项目中运行<code>npm run dev</code>去执行,也可以在主项目下直接执行,在主项目的package.json下添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev:core&quot;: &quot;pnpm -F @nux-monorepo/core dev&quot;</span><br></pre></td></tr></table></figure></p><p>运行结果跟在子项目中是一样的。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="普通发布"><a href="#普通发布" class="headerlink" title="普通发布"></a>普通发布</h3><ul><li>在npmjs官网有一个账号</li><li>在npmjs新建一个Organizations,这个名字就是子项目package.json中name的前缀,<code>@nux-monorepo/core</code>中的<code>nux-monorepo</code></li><li>进入到子项目,执行<code>pnpm publish</code>,注意,这里需要把npm的源设置成官网的<code>https://registry.npmjs.org/</code>(因为npmjs的官方源下载速度慢，平时都会切换国内的镜像地址，这里需要注意下)</li></ul><p>每次发布时需要修改version版本号，一样的话发布会失败。</p><h3 id="脚本发布"><a href="#脚本发布" class="headerlink" title="脚本发布"></a>脚本发布</h3><p>上面的发布需要进入到每个子项目进行发布，非常麻烦，可以编写一个脚本，进行批量发布。<br>这里还有一点，可以在脚本中修改版本号，可以根据不同的规则修改，本文简单起见，把子项目中的version版本号都设置成主项目里的version，但是发布前主项目的version需要手动修改一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const &#123; exec &#125; = require(&apos;child_process&apos;);</span><br><span class="line"></span><br><span class="line">const packagesRoot = &apos;./packages&apos;;</span><br><span class="line">const packageName = &apos;package.json&apos;;</span><br><span class="line">let version;</span><br><span class="line">// 获取主项目package.json中的version</span><br><span class="line">let packageData = fs.readFileSync(path.resolve(&apos;./&apos;, packageName), &apos;utf8&apos;);</span><br><span class="line">version = JSON.parse(packageData).version;</span><br><span class="line">// 发布的命令行执行函数</span><br><span class="line">function publishPackage(packageDir) &#123;</span><br><span class="line">    exec(`cd $&#123;packageDir&#125; &amp;&amp; pnpm publish`, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">      if (error) &#123;</span><br><span class="line">        console.error(`Error publishing $&#123;packageDir&#125;:`, error);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(`Published: $&#123;packageDir&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 扫描子项目函数</span><br><span class="line">function scanAndPublish(directory) &#123;</span><br><span class="line">  fs.readdir(directory, &#123; withFileTypes: true &#125;, (err, files) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      console.error(&apos;Error reading directory:&apos;, err);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files.forEach((file) =&gt; &#123;</span><br><span class="line">      if (file.isDirectory()) &#123;</span><br><span class="line">        // 修改package.json中的version</span><br><span class="line">        let packagePath = path.resolve(&apos;./&apos;, packagesRoot, file.name, packageName);</span><br><span class="line">        let packageData = JSON.parse(fs.readFileSync(packagePath, &apos;utf8&apos;));</span><br><span class="line">        packageData.version = version;</span><br><span class="line">        let writeData = JSON.stringify(packageData, null, 2);</span><br><span class="line">        fs.writeFileSync(packagePath, writeData, &apos;utf8&apos;);</span><br><span class="line">        // 发布</span><br><span class="line">        publishPackage(path.dirname(packagePath));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主入口</span><br><span class="line">scanAndPublish(packagesRoot);</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @nux-monorepo/core</span><br></pre></td></tr></table></figure><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/monorepo/pnpm" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用pnpm工具创建monorepo项目&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="npm" scheme="/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>从零打造一个Web地图引擎</title>
    <link href="/2024/07/03/%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AAWeb%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E/"/>
    <id>/2024/07/03/从零打造一个Web地图引擎/</id>
    <published>2024-07-03T01:19:47.000Z</published>
    <updated>2024-07-03T02:27:57.898Z</updated>
    
    <content type="html"><![CDATA[<p>从零开始，实现一个web地图，类似百度地图的效果<br><a id="more"></a><br>本文clone来至<a href="https://github.com/wanglin2/front-article/blob/main/%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AAWeb%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E.md?plain=1" target="_blank" rel="noopener">wanglin2</a></p><p>说到地图，大家一定很熟悉，平时应该都使用过百度地图、高德地图、腾讯地图等，如果涉及到地图相关的开发需求，也有很多选择，比如前面的几个地图都会提供一套<code>js API</code>，此外也有一些开源地图框架可以使用，比如<code>OpenLayers</code>、<code>Leaflet</code>等。</p><p>那么大家有没有想过这些地图是怎么渲染出来的呢，为什么根据一个经纬度就能显示对应的地图呢，不知道没关系，本文会带各位从零实现一个简单的地图引擎，来帮助大家了解<code>GIS</code>基础知识及<code>Web</code>地图的实现原理。</p><h1 id="选个经纬度"><a href="#选个经纬度" class="headerlink" title="选个经纬度"></a>选个经纬度</h1><p>首先我们去高德地图上选个经纬度，作为我们后期的地图中心点，打开<a href="https://lbs.amap.com/tools/picker" target="_blank" rel="noopener">高德坐标拾取</a>工具，随便选择一个点：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/1.png" alt="1.png"></p><p>笔者选择了杭州的雷峰塔，经纬度为：<code>[120.148732,30.231006]</code>。</p><h1 id="瓦片url分析"><a href="#瓦片url分析" class="headerlink" title="瓦片url分析"></a>瓦片url分析</h1><p>地图瓦片我们使用高德的在线瓦片，地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>目前各大地图厂商的瓦片服务遵循的规则是有不同的：</p><blockquote><p>谷歌XYZ规范：谷歌地图、OpenStreetMap、高德地图、geoq、天地图，坐标原点在左上角</p><p>TMS规范：腾讯地图，坐标原点在左下角</p><p>WMTS规范：原点在左上角，瓦片不是正方形，而是矩形，这个应该是官方标准</p><p>百度地图比较特立独行，投影、分辨率、坐标系都跟其他厂商不一样，原点在经纬度都为0的位置，也就是中间，向右为X正方向，向上为Y正方向</p></blockquote><p>谷歌和<code>TMS</code>的瓦片区别可以通过该地址可视化的查看：<a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#1/25.12/-0.61" target="_blank" rel="noopener">地图瓦片</a>。</p><p>虽然规范不同，但原理基本是一致的，都是把地球投影成一个巨大的正方形世界平面图，然后按照四叉树进行分层切割，比如第一层，只有一张瓦片，显示整个世界的信息，所以基本只能看到洲和海的名称和边界线，第二层，切割成四张瓦片，显示信息稍微多了一点，以此类推，就像一个金字塔一样，底层分辨率最高，显示的细节最多，瓦片数也最多，顶层分辨率最低，显示的信息很少，瓦片数量相对也最少：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/2.png" alt="2.png"></p><p>每一层的瓦片数量计算公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(Math.pow(2, n), 2)// 行*列：2^n * 2^n</span><br></pre></td></tr></table></figure><p>十八层就需要<code>68719476736</code>张瓦片，所以一套地图瓦片整体数量是非常庞大的。</p><p>瓦片切好以后，通过行列号和缩放层级来保存，所以可以看到瓦片地址中有三个变量：<code>x</code>、<code>y</code>、<code>z</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x：行号</span><br><span class="line">y：列号</span><br><span class="line">z：分辨率，一般为0-18</span><br></pre></td></tr></table></figure><p>通过这三个变量就可以定位到一张瓦片，比如下面这个地址，行号为<code>109280</code>，列号为<code>53979</code>，缩放层级为<code>17</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>对应的瓦片为：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/3.png" alt="3.png"></p><p>关于瓦片的更多信息可以阅读<a href="https://segmentfault.com/a/1190000011276788" target="_blank" rel="noopener">瓦片地图原理</a>。</p><h1 id="坐标系简介"><a href="#坐标系简介" class="headerlink" title="坐标系简介"></a>坐标系简介</h1><p>高德地图使用的是<code>GCJ-02坐标系</code>，也称火星坐标系，由中国国家测绘局在02年发布，是在GPS坐标（<code>WGS-84</code>坐标系）基础上经加密后而来，也就是增加了非线性的偏移，让你摸不准真实位置，为了国家安全，国内地图服务商都需要使用<code>GCJ-02坐标系</code>。</p><p><code>WGS-84</code>坐标系是国际通用的标准，<code>EPSG</code>编号为<code>EPSG:4326</code>，通常GPS设备获取到的原始经纬度和国外的地图厂商使用的都是<code>WGS-84</code>坐标系。</p><p>这两种坐标系都是地理坐标系，球面坐标，单位为<code>度</code>，这种坐标方便在地球上定位，但是不方便展示和进行面积距离计算，我们印象中的地图都是平面的，所以就有了另外一种平面坐标系，平面坐标系是通过投影的方式从地理坐标系中转换过来，所以也称为投影坐标系，通常单位为<code>米</code>，投影坐标系根据投影方式的不同存在多种，在<code>Web</code>开发的场景里通常使用的是<code>Web墨卡托投影</code>，编号为<code>EPSG:3857</code>，它基于<code>墨卡托投影</code>，把<code>WGS-84</code>坐标系投影成正方形：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/4.png" alt="4.png"></p><p>这是通过舍弃了南北<code>85.051129纬度</code>以上的地区实现的，因为它是正方形，所以一个大的正方形可以很方便的被分割为更小的正方形。</p><p>坐标系更详细的信息可参考<a href="https://juejin.cn/post/6924478988307922957" target="_blank" rel="noopener">GIS之坐标系统</a>，<code>EPSG:3857</code>的详细信息可参考<a href="http://epsg.io/3857" target="_blank" rel="noopener">EPSG:3857</a>。</p><h1 id="经纬度定位行列号"><a href="#经纬度定位行列号" class="headerlink" title="经纬度定位行列号"></a>经纬度定位行列号</h1><p>上一节里我们简单介绍了一下坐标系，按照<code>Web</code>地图的标准，我们的地图引擎也选择支持<code>EPSG:3857</code>投影，但是我们通过高德工具获取到的是火星坐标系的经纬度坐标，所以第一步要把经纬度坐标转换为<code>Web墨卡托</code>投影坐标，这里为了简单，先直接把火星坐标当做<code>WGS-84</code>坐标，后面再来看这个问题。</p><p>转换方法网上一搜就有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 角度转弧度</span></span><br><span class="line"><span class="keyword">const</span> angleToRad = <span class="function">(<span class="params">angle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> angle * (<span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弧度转角度</span></span><br><span class="line"><span class="keyword">const</span> radToAngle = <span class="function">(<span class="params">rad</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rad * (<span class="number">180</span> / <span class="built_in">Math</span>.PI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地球半径</span></span><br><span class="line"><span class="keyword">const</span> EARTH_RAD = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4326转3857</span></span><br><span class="line"><span class="keyword">const</span> lngLat2Mercator = <span class="function">(<span class="params">lng, lat</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 经度先转弧度，然后因为 弧度 = 弧长 / 半径 ，得到弧长为 弧长 = 弧度 * 半径 </span></span><br><span class="line">    <span class="keyword">let</span> x = angleToRad(lng) * EARTH_RAD; </span><br><span class="line">    <span class="comment">// 纬度先转弧度</span></span><br><span class="line">    <span class="keyword">let</span> rad = angleToRad(lat)</span><br><span class="line">    <span class="comment">// 下面我就看不懂了，各位随意。。。</span></span><br><span class="line">    <span class="keyword">let</span> sin = <span class="built_in">Math</span>.sin(rad)</span><br><span class="line">    <span class="keyword">let</span> y = EARTH_RAD / <span class="number">2</span> * <span class="built_in">Math</span>.log((<span class="number">1</span> + sin) / (<span class="number">1</span> - sin))</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3857转4326</span></span><br><span class="line"><span class="keyword">const</span> mercatorTolnglat = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lng = radToAngle(x) / EARTH_RAD</span><br><span class="line">    <span class="keyword">let</span> lat = radToAngle((<span class="number">2</span> * <span class="built_in">Math</span>.atan(<span class="built_in">Math</span>.exp(y / EARTH_RAD)) - (<span class="built_in">Math</span>.PI / <span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> [lng, lat]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3857</code>坐标有了，它的单位是<code>米</code>，那么怎么转换成瓦片的行列号呢，这就涉及到<code>分辨率</code>的概念了，即地图上一像素代表实际多少米，分辨率如果能从地图厂商的文档里获取是最好的，如果找不到，也可以简单计算一下（如果使用计算出来的也不行，那就只能求助搜索引擎了），我们知道地球半径是<code>6378137</code>米，<code>3857</code>坐标系把地球当做正圆球体来处理，所以可以算出地球周长，投影是贴着地球赤道的：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/5.png" alt="5.png"></p><p>所以投影成正方形的世界平面图后的边长代表的就是地球的周长，前面我们也知道了每一层级的瓦片数量的计算方式，而一张瓦片的大小一般是<code>256*256</code>像素，所以用地球周长除以展开后的世界平面图的边长就知道了地图上每像素代表实际多少米：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地球周长</span></span><br><span class="line"><span class="keyword">const</span> EARTH_PERIMETER = <span class="number">2</span> * <span class="built_in">Math</span>.PI * EARTH_RAD</span><br><span class="line"><span class="comment">// 瓦片像素</span></span><br><span class="line"><span class="keyword">const</span> TILE_SIZE = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某一层级下的分辨率</span></span><br><span class="line"><span class="keyword">const</span> getResolution = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tileNums = <span class="built_in">Math</span>.pow(<span class="number">2</span>, n)</span><br><span class="line">    <span class="keyword">const</span> tileTotalPx = tileNums * TILE_SIZE</span><br><span class="line">    <span class="keyword">return</span> EARTH_PERIMETER / tileTotalPx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地球周长算出来是<code>40075016.68557849</code>，可以看到<code>OpenLayers</code>就是这么计算的：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/5-5.webp" alt="5-5.webp"></p><p><code>3857</code>坐标的单位是<code>米</code>，那么把坐标除以分辨率就可以得到对应的像素坐标，再除以<code>256</code>，就可以得到瓦片的行列号：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/6.png" alt="6.png"></p><p>函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据3857坐标及缩放层级计算瓦片行列号</span></span><br><span class="line"><span class="keyword">const</span> getTileRowAndCol = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resolution = getResolution(z)</span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">Math</span>.floor(x / resolution / TILE_SIZE)</span><br><span class="line">    <span class="keyword">let</span> col = <span class="built_in">Math</span>.floor(y / resolution / TILE_SIZE)</span><br><span class="line">    <span class="keyword">return</span> [row, col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们把层级固定为<code>17</code>，那么分辨率<code>resolution</code>就是<code>1.194328566955879</code>，雷峰塔的经纬度转成<code>3857</code>的坐标为：<code>[13374895.665697495, 3533278.205310311]</code>，使用上面的函数计算出来行列号为：<code>[43744, 11556]</code>，我们把这几个数据代入瓦片的地址里进行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=43744&amp;y=11556&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p><img src="/2024/07/03/从零打造一个Web地图引擎/7.png" alt="7.png"></p><p>一片空白，这是为啥呢，其实是因为原点不一样，<code>4326</code>和<code>3857</code>坐标系的原点在赤道和本初子午线相交点，非洲边上的海里，而瓦片的原点在左上角：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/8.png" alt="8.png"></p><p>再来看下图会更容易理解：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/9.png" alt="9.png"></p><p><code>3857</code>坐标系的原点相当于在世界平面图的中间，向右为<code>x</code>轴正方向，向上为<code>y</code>轴正方向，而瓦片地图的原点在左上角，所以我们需要根据图上【绿色虚线】的距离计算出【橙色实线】的距离，这也很简单，水平坐标就是水平绿色虚线的长度加上世界平面图的一半，垂直坐标就是世界平面图的一半减去垂直绿色虚线的长度，世界平面图的一半也就是地球周长的一半，修改<code>getTileRowAndCol</code>函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTileRowAndCol = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">  x += EARTH_PERIMETER / <span class="number">2</span>     <span class="comment">// ++</span></span><br><span class="line">  y = EARTH_PERIMETER / <span class="number">2</span> - y  <span class="comment">// ++</span></span><br><span class="line">  <span class="keyword">let</span> resolution = getResolution(z)</span><br><span class="line">  <span class="keyword">let</span> row = <span class="built_in">Math</span>.floor(x / resolution / TILE_SIZE)</span><br><span class="line">  <span class="keyword">let</span> col = <span class="built_in">Math</span>.floor(y / resolution / TILE_SIZE)</span><br><span class="line">  <span class="keyword">return</span> [row, col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次计算出来的瓦片行列号为<code>[109280, 53979]</code>，代入瓦片地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/10.png" alt="10.png"></p><p>可以看到雷峰塔出来了。</p><h1 id="瓦片显示位置计算"><a href="#瓦片显示位置计算" class="headerlink" title="瓦片显示位置计算"></a>瓦片显示位置计算</h1><p>我们现在能根据一个经纬度找到对应的瓦片，但是这还不够，我们的目标是要能在浏览器上显示出来，这就需要解决两个问题，一个是加载多少块瓦片，二是计算每一块瓦片的显示位置。</p><p>渲染瓦片我们使用<code>canvas</code>画布，模板如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"map"</span> <span class="attr">ref</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>地图画布容器<code>map</code>的大小我们很容易获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器大小</span></span><br><span class="line"><span class="keyword">let</span> &#123; width, height &#125; = <span class="keyword">this</span>.$refs.map.getBoundingClientRect()</span><br><span class="line"><span class="keyword">this</span>.width = width</span><br><span class="line"><span class="keyword">this</span>.height = height</span><br><span class="line"><span class="comment">// 设置画布大小</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="keyword">this</span>.$refs.canvas</span><br><span class="line">canvas.width = width</span><br><span class="line">canvas.height = height</span><br><span class="line"><span class="comment">// 获取绘图上下文</span></span><br><span class="line"><span class="keyword">this</span>.ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></table></figure><p>地图中心点我们设在画布中间，另外中心点的经纬度<code>center</code>和缩放层级<code>zoom</code>因为都是我们自己设定的，所以也是已知的，那么我们可以计算出中心坐标对应的瓦片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心点对应的瓦片</span></span><br><span class="line"><span class="keyword">let</span> centerTile = getTileRowAndCol(</span><br><span class="line">    ...lngLat2Mercator(...this.center),<span class="comment">// 4326转3857</span></span><br><span class="line">    <span class="keyword">this</span>.zoom<span class="comment">// 缩放层级</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>缩放层级还是设为<code>17</code>，中心点还是使用雷峰塔的经纬度，那么对应的瓦片行列号前面我们已经计算过了，为<code>[109280, 53979]</code>。</p><p>中心坐标对应的瓦片行列号知道了，那么该瓦片左上角在世界平面图中的像素位置我们也就知道了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心瓦片左上角对应的像素坐标</span></span><br><span class="line"><span class="keyword">let</span> centerTilePos = [centerTile[<span class="number">0</span>] * TILE_SIZE, centerTile[<span class="number">1</span>] * TILE_SIZE]</span><br></pre></td></tr></table></figure><p>计算出来为<code>[27975680, 13818624]</code>。这个坐标怎么转换到屏幕上呢，请看下图：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/11.png" alt="11.png"></p><p>中心经纬度的瓦片我们计算出来了，瓦片左上角的像素坐标也知道了，然后我们再计算出中心经纬度本身对应的像素坐标，那么和瓦片左上角的差值就可以计算出来，最后我们把画布的原点移动到画布中间（画布默认原点为左上角，x轴正方向向右，y轴正方向向下），也就是把中心经纬度作为坐标原点，那么中心瓦片的显示位置就是这个差值。</p><p>补充一下将经纬度转换成像素的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算4326经纬度对应的像素坐标</span></span><br><span class="line"><span class="keyword">const</span> getPxFromLngLat = <span class="function">(<span class="params">lng, lat, z</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [_x, _y] = lngLat2Mercator(lng, lat)<span class="comment">// 4326转3857</span></span><br><span class="line">  <span class="comment">// 转成世界平面图的坐标</span></span><br><span class="line">  _x += EARTH_PERIMETER / <span class="number">2</span></span><br><span class="line">  _y = EARTH_PERIMETER / <span class="number">2</span> - _y</span><br><span class="line">  <span class="keyword">let</span> resolution = resolutions[z]<span class="comment">// 该层级的分辨率</span></span><br><span class="line">  <span class="comment">// 米/分辨率得到像素</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">Math</span>.floor(_x / resolution)</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Math</span>.floor(_y / resolution)</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算中心经纬度对应的像素坐标：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心点对应的像素坐标</span></span><br><span class="line"><span class="keyword">let</span> centerPos = getPxFromLngLat(...this.center, <span class="keyword">this</span>.zoom)</span><br></pre></td></tr></table></figure><p>计算差值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心像素坐标距中心瓦片左上角的差值</span></span><br><span class="line"><span class="keyword">let</span> offset = [</span><br><span class="line">    centerPos[<span class="number">0</span>] - centerTilePos[<span class="number">0</span>],</span><br><span class="line">    centerPos[<span class="number">1</span>] - centerTilePos[<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后通过<code>canvas</code>来把中心瓦片渲染出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动画布原点到画布中间</span></span><br><span class="line"><span class="keyword">this</span>.ctx.translate(<span class="keyword">this</span>.width / <span class="number">2</span>, <span class="keyword">this</span>.height / <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 加载瓦片图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"><span class="comment">// 拼接瓦片地址</span></span><br><span class="line">img.src = getTileUrl(...centerTile, <span class="keyword">this</span>.zoom)</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 渲染到canvas</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.drawImage(img, -offset[<span class="number">0</span>], -offset[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先来看看<code>getTileUrl</code>方法的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接瓦片地址</span></span><br><span class="line"><span class="keyword">const</span> getTileUrl = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> domainIndexList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  <span class="keyword">let</span> domainIndex =</span><br><span class="line">    domainIndexList[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * domainIndexList.length)]</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`https://webrd0<span class="subst">$&#123;domainIndex&#125;</span>.is.autonavi.com/appmaptile?x=<span class="subst">$&#123;x&#125;</span>&amp;y=<span class="subst">$&#123;y&#125;</span>&amp;z=<span class="subst">$&#123;z&#125;</span>&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里随机了四个子域：<code>webrd01</code>、<code>webrd02</code>、<code>webrd03</code>、<code>webrd04</code>，这是因为浏览器对于同一域名同时请求的资源是有数量限制的，而当地图层级变大后需要加载的瓦片数量会比较多，那么均匀分散到各个子域下去请求可以更快的渲染出所有瓦片，减少排队等待时间，基本所有地图厂商的瓦片服务地址都支持多个子域。</p><p>为了方便看到中心点的位置，我们再额外渲染两条中心辅助线，效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/12.png" alt="12.png"></p><p>可以看到中心点确实是雷峰塔，当然这只是渲染了中心瓦片，我们要的是瓦片铺满整个画布，对于其他瓦片我们都可以根据中心瓦片计算出来，比如中心瓦片左边的一块，它的计算如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瓦片行列号，行号减1，列号不变</span></span><br><span class="line"><span class="keyword">let</span> leftTile = [centerTile[<span class="number">0</span>] - <span class="number">1</span>, centerTile[<span class="number">1</span>]]</span><br><span class="line"><span class="comment">// 瓦片显示坐标，x轴减去一个瓦片的大小，y轴不变</span></span><br><span class="line"><span class="keyword">let</span> leftTilePos = [</span><br><span class="line">    offset[<span class="number">0</span>] - TILE_SIZE * <span class="number">1</span>,</span><br><span class="line">    offset[<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以我们只要计算出中心瓦片四个方向各需要几块瓦片，然后用一个双重循环即可计算出画布需要的所有瓦片，计算需要的瓦片数量很简单，请看下图：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/13.png" alt="13.png"></p><p>画布宽高的一半减去中心瓦片占据的空间即可得到该方向剩余的空间，然后除以瓦片的尺寸就知道需要几块瓦片了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算瓦片数量</span></span><br><span class="line"><span class="keyword">let</span> rowMinNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.width / <span class="number">2</span> - offset[<span class="number">0</span>]) / TILE_SIZE)<span class="comment">// 左</span></span><br><span class="line"><span class="keyword">let</span> colMinNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.height / <span class="number">2</span> - offset[<span class="number">1</span>]) / TILE_SIZE)<span class="comment">// 上</span></span><br><span class="line"><span class="keyword">let</span> rowMaxNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.width / <span class="number">2</span> - (TILE_SIZE - offset[<span class="number">0</span>])) / TILE_SIZE)<span class="comment">// 右</span></span><br><span class="line"><span class="keyword">let</span> colMaxNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.height / <span class="number">2</span> - (TILE_SIZE - offset[<span class="number">1</span>])) / TILE_SIZE)<span class="comment">// 下</span></span><br></pre></td></tr></table></figure><p>我们把中心瓦片作为原点，坐标为<code>[0, 0]</code>，来个双重循环扫描一遍即可渲染出所有瓦片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上到下，从左到右，加载瓦片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = -colMinNum; j &lt;= colMaxNum; j++) &#123;</span><br><span class="line">        <span class="comment">// 加载瓦片图片</span></span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.src = getTileUrl(</span><br><span class="line">            centerTile[<span class="number">0</span>] + i,<span class="comment">// 行号</span></span><br><span class="line">            centerTile[<span class="number">1</span>] + j,<span class="comment">// 列号</span></span><br><span class="line">            <span class="keyword">this</span>.zoom</span><br><span class="line">        )</span><br><span class="line">        img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 渲染到canvas</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.drawImage(</span><br><span class="line">                img, </span><br><span class="line">                i * TILE_SIZE - offset[<span class="number">0</span>], </span><br><span class="line">                j * TILE_SIZE - offset[<span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/14.png" alt="14.png"></p><p>很完美。</p><h1 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h1><p>拖动可以这么考虑，前面已经实现了渲染指定经纬度的瓦片，当我们按住进行拖动时，可以知道鼠标滑动的距离，然后把该距离，也就是像素转换成经纬度的数值，最后我们再更新当前中心点的经纬度，并清空画布，调用之前的方法重新渲染，不停重绘造成是在移动的视觉假象。</p><p>监听鼠标相关事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"canvas"</span> @<span class="attr">mousedown</span>=<span class="string">"onMousedown"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isMousedown: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"mousemove"</span>, <span class="keyword">this</span>.onMousemove);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"mouseup"</span>, <span class="keyword">this</span>.onMouseup);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标按下</span></span><br><span class="line">        onMousedown(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.which === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.isMousedown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标移动</span></span><br><span class="line">        onMousemove(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isMousedown) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标松开</span></span><br><span class="line">        onMouseup() &#123;</span><br><span class="line">            <span class="keyword">this</span>.isMousedown = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onMousemove</code>方法里计算拖动后的中心经纬度及重新渲染画布：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算本次拖动的距离对应的经纬度数据</span></span><br><span class="line"><span class="keyword">let</span> mx = e.movementX * resolutions[<span class="keyword">this</span>.zoom];</span><br><span class="line"><span class="keyword">let</span> my = e.movementY * resolutions[<span class="keyword">this</span>.zoom];</span><br><span class="line"><span class="comment">// 把当前中心点经纬度转成3857坐标</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = lngLat2Mercator(...this.center);</span><br><span class="line"><span class="comment">// 更新拖动后的中心点经纬度</span></span><br><span class="line">center = mercatorToLngLat(x - mx, my + y);</span><br></pre></td></tr></table></figure><p><code>movementX</code>和<code>movementY</code>属性能获取本次和上一次鼠标事件中的移动值，兼容性不是很好，不过自己计算该值也很简单，详细请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/movementX" target="_blank" rel="noopener">MDN</a>。乘以当前分辨率把<code>像素</code>换算成<code>米</code>，然后把当前中心点经纬度也转成<code>3857</code>的<code>米</code>坐标，偏移本次移动的距离，最后再转回<code>4326</code>的经纬度坐标作为更新后的中心点即可。</p><p>为什么<code>x</code>是减，<code>y</code>是加呢，很简单，我们鼠标向右和向下移动时距离是正的，相应的地图会向右或向下移动，<code>4326</code>坐标系向右和向上为正方向，那么地图向右移动时，中心点显然是相对来说是向左移了，因为向右为正方向，所以中心点经度方向就是减少了，所以是减去移动的距离，而地图向下移动，中心点相对来说是向上移了，因为向上为正方向，所以中心点纬度方向就是增加了，所以加上移动的距离。</p><p>更新完中心经纬度，然后清空画布重新绘制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空画布</span></span><br><span class="line"><span class="keyword">this</span>.clear();</span><br><span class="line"><span class="comment">// 重新绘制，renderTiles方法就是上一节的代码逻辑封装</span></span><br><span class="line"><span class="keyword">this</span>.renderTiles();</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/15.gif" alt="15.gif"></p><p>可以看到已经凌乱了，这是为啥呢，其实是因为图片加载是一个异步的过程，我们鼠标移动过程中，会不断的计算出要加载的瓦片进行加载，但是可能上一批瓦片还没加载完成，鼠标已经移动到新的位置了，又计算出一批新的瓦片进行加载，此时上一批瓦片可能加载完成并渲染出来了，但是这些瓦片有些可能已经被移除画布，不需要显示，有些可能还在画布内，但是使用的还是之前的位置，渲染出来也是不对的，同时新的一批瓦片可能也加载完成并渲染出来，自然导致了最终显示的错乱。</p><p>知道原因就简单了，首先我们加个缓存对象，因为在拖动过程中，很多瓦片只是位置变了，不需要重新加载，同一个瓦片加载一次，后续只更新它的位置即可；另外再设置一个对象来记录当前画布上应该显示的瓦片，防止不应该出现的瓦片渲染出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缓存瓦片</span></span><br><span class="line">    tileCache: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 记录当前画布上需要的瓦片</span></span><br><span class="line">    currentTileCache: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为需要记录瓦片的位置、加载状态等信息，我们创建一个瓦片类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瓦片类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opt = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 画布上下文</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx</span><br><span class="line">    <span class="comment">// 瓦片行列号</span></span><br><span class="line">    <span class="keyword">this</span>.row = row</span><br><span class="line">    <span class="keyword">this</span>.col = col</span><br><span class="line">    <span class="comment">// 瓦片层级</span></span><br><span class="line">    <span class="keyword">this</span>.zoom = zoom</span><br><span class="line">    <span class="comment">// 显示位置</span></span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">    <span class="comment">// 一个函数，判断某块瓦片是否应该渲染</span></span><br><span class="line">    <span class="keyword">this</span>.shouldRender = shouldRender</span><br><span class="line">    <span class="comment">// 瓦片url</span></span><br><span class="line">    <span class="keyword">this</span>.url = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 缓存key</span></span><br><span class="line">    <span class="keyword">this</span>.cacheKey = <span class="keyword">this</span>.row + <span class="string">'_'</span> + <span class="keyword">this</span>.col + <span class="string">'_'</span> + <span class="keyword">this</span>.zoom</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">this</span>.img = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 图片是否加载完成</span></span><br><span class="line">    <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.createUrl()</span><br><span class="line">    <span class="keyword">this</span>.load()</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 生成url</span></span><br><span class="line">  createUrl() &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = getTileUrl(<span class="keyword">this</span>.row, <span class="keyword">this</span>.col, <span class="keyword">this</span>.zoom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载图片</span></span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="keyword">this</span>.img = <span class="keyword">new</span> Image()</span><br><span class="line">    <span class="keyword">this</span>.img.src = <span class="keyword">this</span>.url</span><br><span class="line">    <span class="keyword">this</span>.img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将图片渲染到canvas上</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.loaded || !<span class="keyword">this</span>.shouldRender(<span class="keyword">this</span>.cacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ctx.drawImage(<span class="keyword">this</span>.img, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 更新位置</span></span><br><span class="line">  updatePos(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改之前的双重循环渲染瓦片的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.currentTileCache = &#123;&#125;<span class="comment">// 清空缓存对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = -colMinNum; j &lt;= colMaxNum; j++) &#123;</span><br><span class="line">        <span class="comment">// 当前瓦片的行列号</span></span><br><span class="line">        <span class="keyword">let</span> row = centerTile[<span class="number">0</span>] + i</span><br><span class="line">        <span class="keyword">let</span> col = centerTile[<span class="number">1</span>] + j</span><br><span class="line">        <span class="comment">// 当前瓦片的显示位置</span></span><br><span class="line">        <span class="keyword">let</span> x = i * TILE_SIZE - offset[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> y = j * TILE_SIZE - offset[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 缓存key</span></span><br><span class="line">        <span class="keyword">let</span> cacheKey = row + <span class="string">'_'</span> + col + <span class="string">'_'</span> + <span class="keyword">this</span>.zoom</span><br><span class="line">        <span class="comment">// 记录画布当前需要的瓦片</span></span><br><span class="line">        <span class="keyword">this</span>.currentTileCache[cacheKey] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 该瓦片已加载过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tileCache[cacheKey]) &#123;</span><br><span class="line">            <span class="comment">// 更新到当前位置</span></span><br><span class="line">            <span class="keyword">this</span>.tileCache[cacheKey].updatePos(x, y).render()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未加载过</span></span><br><span class="line">            <span class="keyword">this</span>.tileCache[cacheKey] = <span class="keyword">new</span> Tile(&#123;</span><br><span class="line">                ctx: <span class="keyword">this</span>.ctx,</span><br><span class="line">                row,</span><br><span class="line">                col,</span><br><span class="line">                zoom: <span class="keyword">this</span>.zoom,</span><br><span class="line">                x,</span><br><span class="line">                y,</span><br><span class="line">                <span class="comment">// 判断瓦片是否在当前画布缓存对象上，是的话则代表需要渲染</span></span><br><span class="line">                shouldRender: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.currentTileCache[key]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/16.gif" alt="16.gif"></p><p>可以看到，拖动已经正常了，当然，上述实现还是很粗糙的，需要优化的地方很多，比如：</p><p>1.一般会先排个序，优先加载中心瓦片</p><p>2.缓存的瓦片越来越多肯定也会影响性能，所以还需要一些清除策略</p><p>这些问题有兴趣的可以自行思考。</p><h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><p>拖动是实时更新中心点经纬度，那么缩放自然更新缩放层级就行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 缩放层级范围</span></span><br><span class="line">            minZoom: <span class="number">3</span>,</span><br><span class="line">            maxZoom: <span class="number">18</span>,</span><br><span class="line">            <span class="comment">// 防抖定时器</span></span><br><span class="line">            zoomTimer: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'wheel'</span>, <span class="keyword">this</span>.onMousewheel)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标滚动</span></span><br><span class="line">        onMousewheel(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 层级变小</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &gt; <span class="keyword">this</span>.minZoom) <span class="keyword">this</span>.zoom--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 层级变大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &lt; <span class="keyword">this</span>.maxZoom) <span class="keyword">this</span>.zoom++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加个防抖，防止快速滚动加载中间过程的瓦片</span></span><br><span class="line">            <span class="keyword">this</span>.zoomTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.clear()</span><br><span class="line">                <span class="keyword">this</span>.renderTiles()</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/17.gif" alt="17.gif"></p><p>功能是有了，不过效果很一般，因为我们平常使用的地图缩放都是有一个放大或缩小的过渡动画，而这个是直接空白然后重新渲染，不仔细看都不知道是放大还是缩小。</p><p>所以我们不妨加个过渡效果，当我们鼠标滚动后，先将画布放大或缩小，动画结束后再根据最终的缩放值来渲染需要的瓦片。</p><p>画布默认缩放值为<code>1</code>，放大则在此基础上乘以<code>2</code>倍，缩小则除以<code>2</code>，然后动画到目标值，动画期间设置画布的缩放值及清空画布，重新绘制画布上的已有瓦片，达到放大或缩小的视觉效果，动画结束后再调用<code>renderTiles</code>重新渲染最终缩放值需要的瓦片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画使用popmotion库，https://popmotion.io/</span></span><br><span class="line"><span class="keyword">import</span> &#123; animate &#125; <span class="keyword">from</span> <span class="string">'popmotion'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            lastZoom: <span class="number">0</span>,</span><br><span class="line">            scale: <span class="number">1</span>,</span><br><span class="line">            scaleTmp: <span class="number">1</span>,</span><br><span class="line">            playback: <span class="literal">null</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标滚动</span></span><br><span class="line">        onMousewheel(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 层级变小</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &gt; <span class="keyword">this</span>.minZoom) <span class="keyword">this</span>.zoom--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 层级变大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &lt; <span class="keyword">this</span>.maxZoom) <span class="keyword">this</span>.zoom++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 层级未发生改变</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastZoom === <span class="keyword">this</span>.zoom) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.lastZoom = <span class="keyword">this</span>.zoom</span><br><span class="line">            <span class="comment">// 更新缩放比例，也就是目标缩放值</span></span><br><span class="line">            <span class="keyword">this</span>.scale *= e.deltaY &gt; <span class="number">0</span> ? <span class="number">0.5</span> : <span class="number">2</span></span><br><span class="line">            <span class="comment">// 停止上一次动画</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.playback) &#123;</span><br><span class="line">                <span class="keyword">this</span>.playback.stop()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启动画</span></span><br><span class="line">            <span class="keyword">this</span>.playback = animate(&#123;</span><br><span class="line">                <span class="keyword">from</span>: <span class="keyword">this</span>.scaleTmp,<span class="comment">// 当前缩放值</span></span><br><span class="line">                to: <span class="keyword">this</span>.scale,<span class="comment">// 目标缩放值</span></span><br><span class="line">                onUpdate: <span class="function">(<span class="params">latest</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 实时更新当前缩放值</span></span><br><span class="line">                    <span class="keyword">this</span>.scaleTmp = latest</span><br><span class="line">                    <span class="comment">// 保存画布之前状态，原因有二：</span></span><br><span class="line">                    <span class="comment">// 1.scale方法是会在之前的状态上叠加的，比如初始是1，第一次执行scale(2,2)，第二次执行scale(3,3)，最终缩放值不是3，而是6，所以每次缩放完就恢复状态，那么就相当于每次都是从初始值1开始缩放，效果就对了</span></span><br><span class="line">                    <span class="comment">// 2.保证缩放效果只对重新渲染已有瓦片生效，不会对最后的renderTiles()造成影响</span></span><br><span class="line">                    <span class="keyword">this</span>.ctx.save()</span><br><span class="line">                    <span class="keyword">this</span>.clear()</span><br><span class="line">                    <span class="keyword">this</span>.ctx.scale(latest, latest)</span><br><span class="line">                    <span class="comment">// 刷新当前画布上的瓦片</span></span><br><span class="line">                    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.currentTileCache).forEach(<span class="function">(<span class="params">tile</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.tileCache[tile].render()</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">// 恢复到画布之前状态</span></span><br><span class="line">                    <span class="keyword">this</span>.ctx.restore()</span><br><span class="line">                &#125;,</span><br><span class="line">                onComplete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 动画完成后将缩放值重置为1</span></span><br><span class="line">                    <span class="keyword">this</span>.scale = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">this</span>.scaleTmp = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 根据最终缩放值重新计算需要的瓦片并渲染</span></span><br><span class="line">                    <span class="keyword">this</span>.renderTiles()</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/17.gif" alt="17.gif"></p><p>虽然效果还是一般，不过至少能看出来是在放大还是缩小。</p><h1 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h1><p>前面还遗留了一个小问题，即我们把高德工具上选出的经纬度直接当做<code>4326</code>经纬度，前面也讲过，它们之间是存在偏移的，比如手机<code>GPS</code>获取到的经纬度一般都是<code>84</code>坐标，直接在高德地图显示，会发现和你实际位置不一样，所以就需要进行一个转换，有一些工具可以帮你做些事情，比如<a href="https://github.com/hujiulong/gcoord" target="_blank" rel="noopener">Gcoord</a>、<a href="https://github.com/wandergis/coordtransform" target="_blank" rel="noopener">coordtransform</a>等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述效果看着比较一般，其实只要在上面的基础上稍微加一点瓦片的淡出动画，效果就会好很多，目前一般都是使用<code>canvas</code>来渲染<code>2D</code>地图，如果自己实现动画不太方便，也有一些强大的<code>canvas</code>库可以选择，笔者最后使用<a href="https://konvajs.org/" target="_blank" rel="noopener">Konva.js</a>库重做了一版，加入了瓦片淡出动画，最终效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/18.gif" alt="18.gif"></p><p>另外只要搞清楚各个地图的瓦片规则，就能稍加修改支持更多的地图瓦片：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/19.webp" alt="19.webp"></p><p>具体实现限于篇幅不再展开，有兴趣的可以阅读本文源码。</p><p>本文详细的介绍了一个简单的<code>web</code>地图开发过程，上述实现原理仅是笔者的个人思路，不代表<code>openlayers</code>等框架的原理，因为笔者也是<code>GIS</code>的初学者，所以难免会有问题，或更好的实现，欢迎指出。</p><p>完整源码：<a href="https://github.com/jinux7/study-collections/tree/master/web%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从零开始，实现一个web地图，类似百度地图的效果&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
      <category term="canvas" scheme="/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>《Vue.js 设计与实现》速读</title>
    <link href="/2024/06/21/%E3%80%8AVue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%80%9F%E8%AF%BB/"/>
    <id>/2024/06/21/《Vue-js-设计与实现》速读/</id>
    <published>2024-06-21T02:21:16.000Z</published>
    <updated>2024-06-21T05:46:30.706Z</updated>
    
    <content type="html"><![CDATA[<p>《Vue.js 设计与实现》概要总结<br><a id="more"></a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这是一本没有带你阅读一行源码，却可以让你在阅读完成之后，对 <code>vue 3</code> 所有的核心逻辑 <strong>了如指掌</strong> 的书籍。</p><p>无论是 <strong>响应性、调度系统、惰性执行</strong> ，还是 <strong>渲染器、diff 算法、编辑器三大步 </strong>  ，甚至是 <strong>有限自动状态机</strong> 等所有你能想到知识，本书都可以给你答案。</p><p>它就是  <strong>尤雨溪亲自做序</strong> ，<strong>Vue 官方团队成员：霍春阳</strong> 编写的  <strong>Vue.js 设计与实现</strong>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当前这个时间段下，关于 <code>vue 3</code> 源码的书籍，主要有两本。</p><p>第一本就是，咱们本次要讲的  <strong>《Vue.js 设计与实现》</strong>。</p><p>第二本是，<strong>《vue.js 技术内幕》</strong>，作者是黄轶。</p><p>正巧，两本书我都买来了。</p><p>这两本书，虽然都是讲解 <code>vue 3</code> 源码的，但是在讲解的方式上，有非常大的区别。</p><p>首先是 《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 <strong>从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序）</strong>，以 <strong>提出问题 - 分析思路 - 解决问题</strong> 的方式，来讲解 <code>vue 3</code> 的核心设计。其内部，没有读一行 <code>vue3</code> 的源码，但却可以让我们对整个 <code>vue 3</code> 的核心，拥有一个非常清楚的认知。</p><p>其次是 《vue.js 技术内幕》：它是一个标准的 “源码分析” 书籍，内部对 <code>vue 3</code> 的很多源码，进行了逐一的解读。</p><p>如果大家想要学习 <code>vue 3</code> 的设计思路，掌握框架设计的思维方式。那么我强烈推荐你看一看《Vue.js 设计与实现》。</p><p>如果你想要对 <code>vue</code> 源码进行逐一解读，那么可以看一下《vue.js 技术内幕》。</p><p>那么明确好了现在市面上学习 <code>vue 3</code> 源码的方式之后，下面就让我们进入到 《Vue.js 设计与实现》的学习中去吧！</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>《Vue.js 设计与实现》的内容一共分为 6 篇， <code>18</code> 个章节：</p><ul><li>首先第一篇：对 <code>vue</code> 的整个框架设计，进行了概述</li><li>第二篇：主要讲解了 <code>vue</code> 中的响应式系统，除了大家所熟悉的 <code>proxy</code> 之外，额外还包含了：调度系统 <code>scheduler</code>、惰性执行 <code>lazy</code>、<code>ref</code> 的实现原理</li><li>第三篇：主要针对 <code>vue</code> 的渲染器（<code>renderer</code>）进行了讲解，额外还包含了 <code>diff</code> 算法的详细讲解</li><li>第四篇：是组件化。包含了 组件的渲染机制，以及对 <code>vue</code> 官方组件 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 的实现原理，进行了剖析</li><li>第五篇：是编译器（<code>compiler</code>）。在这一篇中，把编译器的三大步：<code>parse</code>、<code>transform</code>、<code>generate</code> 进行了分步的讲解。</li><li>最后：是服务端渲染。主要是 <code>CSR</code>、<code>SSR</code> 以及 同构渲染。</li></ul><h2 id="第一篇：框架设计概览"><a href="#第一篇：框架设计概览" class="headerlink" title="第一篇：框架设计概览"></a>第一篇：框架设计概览</h2><p>整个第一篇分为三个章节：</p><ol><li>权衡的艺术：这里主要涉及到了 <code>vue</code> 框架设计的一些基本概念，也是咱们讲解的重点</li><li>框架设计的核心要素：相对比较杂，都是一些零碎的知识点</li><li>Vue.js 3 的设计思路：这一章包含了 <code>vue</code> 框架设计的逻辑主线，也非常重要，但是内容并不多</li></ol><p>那么首先咱们先来看第一章。</p><h3 id="第一章：权衡的艺术"><a href="#第一章：权衡的艺术" class="headerlink" title="第一章：权衡的艺术"></a>第一章：权衡的艺术</h3><p>在这一章中，开头的一句话，描述了框架设计的精髓，这句话也是尤雨溪在多个开发者大会中经常提到的，那就是：<strong>框架的设计，本身就是一种权衡的艺术</strong>。</p><p>在这一章中，书中分别从三个方面来去分析了所谓权衡的艺术，到底是什么意思。</p><h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>首先第一个方面就是：<strong>命令式和声明式</strong> 的概念。</p><p>所谓 <strong>命令式</strong> 指的就是：<strong>关注过程</strong> 的范式。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231540415.png" alt="image-20230207231540415"></p><p>而 <strong>声明式</strong> 指的就是： <strong>关注结果</strong> 的范式。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231536123.png" alt="image-20230207231536123"></p><p>什么意思呢？我们来举一个小例子：</p><blockquote><p>张三的妈妈，让张三去买酱油。</p><p>那么对于张三而言，他就需要：拿钱、出门、下楼、进超市、拿酱油、付钱、回家。</p><p>而对于张三的妈妈来说，她完全不需要关心张三做了什么，只需要对张三说一声就可以了。</p></blockquote><p>那么在这个例子中，张三就是一个典型的命令式，他需要完成整件事情的所有过程。</p><p>而张三的妈妈，就是典型的声明式，她不关心过程只关心结果。</p><p>那么这里大家来想一下，<code>vue</code> 是声明式的？还是命令式的？</p><p>对于 <code>vue</code> 而言，它的内部实现一定是 <strong>命令式</strong> 的，而我们在使用 <code>vue</code> 的时候，则是通过 <strong>声明式</strong> 来使用的。</p><p>也就是说： <strong>vue 封装了命令式的过程，对外暴露出了声明式的结果</strong></p><h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>在明确好了命令式和声明式的概念之后。接下来咱们来看下从 <strong>性能</strong> 层面，<code>vue</code> 所体现出来的一种权衡的方式。</p><p>针对于性能的分析，主要从两个方面去说。</p><p>首先第一个方面：大家觉得 <strong>是命令式的性能更强，还是声明式的性能更强呢？</strong></p><p>答案是：<strong>命令式的性能 &gt; 声明式的性能</strong>。</p><p>其实原因非常简单，对于 <strong>命令式</strong> 的代码而言，它直接通过 <strong>原生的 <code>JavaScript</code> 进行实现</strong>，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 <code>1</code>。</p><p>而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 <code>1 + N</code> 的。</p><p>那么既然如此，<code>vue</code> 为什么还要对外暴露出声明式的接口呢？</p><p>这其实是因为：<strong>声明式的可维护性，要远远大于命令式的可维护性</strong>。</p><blockquote><p>大家从这两段代码（命令式和声明式代码）中就可以发现，声明式代码比命令式代码要简单的多。</p><p>越简单的代码，可维护性就越强</p></blockquote><p>当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 <code>vue</code> 的性能优化之下，它并不会比纯命令式的性能差太多）</p><p>而这样的一种权衡，在 <code>template</code> 模板中，更是体现的淋漓尽致。</p><p>在前端领域，想要使用 <code>JavaScript</code> 修改 <code>html</code> 的方式，主要有三种：<strong><code>原生 JavaScript、innerHTML、虚拟 DOM</code></strong></p><p>很多小伙伴都会认为 <code>虚拟 DOM</code> 的性能是最高的，其实不是。</p><p>我们来看这个对比。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207233547097.png" alt="image-20230207233547097" style="zoom:50%;"></p><p>从这个对比我们可以发现，<code>虚拟 DOM</code> 的性能，并不是最高的。</p><p>但是它的 <strong>心智负担（书写难度）最小</strong>， 从而带来了 <strong>可维护性最高</strong>。所以哪怕它的性能并不是最高的。<code>vue</code> 依然选择了 <code>虚拟 DOM</code> 来进行了渲染层的构建。</p><p>这个也是一种性能与可维护性的权衡。</p><h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>第一章的最后一部分，主要讲解的就是 <strong>运行时和编译时</strong>。</p><p>这两个名词，各位小伙伴在日常开发中，应该是经常听到的。</p><p>它们两个都是框架设计的一种方式，可单独出现，也可组合使用。</p><p>那么下面咱们就分别来介绍一下它们。</p><p>首先是 <strong>运行时：<code>runtime</code></strong>。</p><blockquote><p>它指的是：<strong>利用 render 函数，直接把 虚拟 <code>DOM</code>  转化为 真实 <code>DOM</code> 元素</strong> 的一种方式。</p><p>在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。</p></blockquote><p>其次是 <strong>编译时：compiler</strong>：</p><blockquote><p>它指的是：<strong>直接把 <code>template</code> 模板中的内容，转化为 真实 <code>DOM</code> 元素</strong>。</p><p>因为存在编译的过程，所以可以分析用户提供的内容。</p><p>同时，没有运行时理论上性能会更好。</p><p>目前该方式，有具体的实现库，那就是现在也非常火的 <code>Svelte</code></p><p>但是这里要注意： <strong>它的真实性能，没有办法达到理论数据。</strong></p></blockquote><p>最后是 <strong>运行时 + 编译时</strong>：</p><blockquote><p>它的过程被分为两步：</p><ol><li>先把 <code>template</code> 模板转化为 <code>render</code> 函数。也就是 <strong>编译时</strong></li><li>再利用 <code>render</code> 函数，把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code>。也就是 <strong>运行时</strong></li></ol><p>两者的结合，可以：</p><p>在 编译时，分析用户提供的内容<br>在 运行时，提供足够的灵活性</p><p>这也是 <code>vue</code> 的主要实现方式。</p></blockquote><h3 id="第二章：框架设计的核心要素"><a href="#第二章：框架设计的核心要素" class="headerlink" title="第二章：框架设计的核心要素"></a>第二章：框架设计的核心要素</h3><p>这一章主要讲解了，框架设计时一些凌乱的注意点。</p><p>比如：</p><ol><li>通过 环境变量 和 <code>TreeShanking</code> 控制打包之后的体积</li><li>构建不同的打包产物，以应用不同的场景</li><li>提供了 <code>callWithErrorHandling</code> 接口函数，来对错误进行统一处理</li><li>源码通过 <code>TypeScript</code> 开发，以保证可维护性。</li><li>内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。</li></ol><p>这些东西都是基于一个个的小点单独去说的，整体之间并没有一个完成的线性逻辑。</p><p>所以大家可以根据具体感兴趣或者不了解的点，单独去看就可以。</p><h3 id="第三章：Vue-js-3-的设计思路"><a href="#第三章：Vue-js-3-的设计思路" class="headerlink" title="第三章：Vue.js 3 的设计思路"></a>第三章：Vue.js 3 的设计思路</h3><p>在这一章中，作者站在一个高层的角度，以 <strong><code>UI</code> 形式、渲染器、组件、编辑器</strong> 为逻辑主线进行的讲解。</p><p>下面咱们就来捋一捋这条线。</p><p>在 <code>Vue</code> 中 <code>UI</code> 形式主要分为两种：</p><ul><li>声明式的模板描述<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170232727.png" alt="image-20230208170232727"></li><li>命令式的 render 函数<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170236795.png" alt="image-20230208170236795"></li></ul><p>而针对于 <strong>声明式的模板描述</strong> 而言，本质上就是咱们常用的 <code>tempalte</code> 模板。它会被 <strong>编辑器</strong> 编译，得到 <strong>渲染函数 <code>render</code></strong> 。</p><p>渲染器与渲染函数，并 <strong>不是</strong> 一个东西。</p><p>渲染器是 <strong>函数 <code>createRenderer</code> 的返回值，是一个对象。被叫做 <code>renderer</code></strong>。 <strong><code>renderer</code> 对象中有一个方法 <code>render</code></strong>，这个 <code>render</code> ，就是我们常说的<strong>渲染函数</strong>。</p><p>渲染函数接收两个参数 <code>VNode</code> 和 <code>container</code>。</p><p>其中 <code>VNode</code> 表示 <strong>虚拟 DOM</strong>，本质上是一个 <code>JS</code> 对象。<code>container</code> 是一个容器，表示被挂载的位置。而 <code>render</code> 函数的作用，就是： <strong>把 <code>vnode</code> 挂载到 <code>container</code> 上</strong>。</p><p>同时，因为 <code>Vue</code> 以组件代表最小颗粒度，所以 <code>vue</code> 内部的渲染，本质上是：<strong>大量的组件渲染</strong>。</p><p>而组件本质上是一组 <code>DOM</code> 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 <code>DOM</code>。也就是说，<code>Vue</code> 本质上是： <strong>以组件作为介质，来完成针对于一组、一组的 <code>DOM</code> 渲染。</strong></p><h3 id="第一篇总结"><a href="#第一篇总结" class="headerlink" title="第一篇总结"></a>第一篇总结</h3><p>在整个第一篇中，作者主要就是通过这三章的内容， <strong>自顶向下</strong> 的为我们介绍了 <code>vue</code> 的框架设计逻辑。其目的主要就是为了让我们了解， <code>Vue</code> 框架的运行逻辑和一些关键概念。</p><h2 id="第二篇：响应式系统"><a href="#第二篇：响应式系统" class="headerlink" title="第二篇：响应式系统"></a>第二篇：响应式系统</h2><p>第二篇主要是针对 <strong>响应式系统</strong> 的讲解。</p><p>同样也是被分为三章：</p><ul><li>首先第一章，也是最重要的一章，就是 <strong>响应系统的作用与实现</strong></li><li>第二章，主要针对 <strong>对象的响应性实现原理</strong> 进行了讲解</li><li>第三章，主要针对 <strong>非对象的响应性实现原理</strong> 进行了讲解</li></ul><h3 id="第四章：响应系统的作用与实现"><a href="#第四章：响应系统的作用与实现" class="headerlink" title="第四章：响应系统的作用与实现"></a>第四章：响应系统的作用与实现</h3><p>在这一章中，作者从 <strong>响应式数据的概念开始，讲解了响应式系统的实现。</strong> 然后针对于 <strong>计算属性与 <code>watch</code>  的实现原理，进行了分析。</strong> 在分析的过程中，也对其所设计到的 <strong><code>调度系统（scheduler）</code> 和  <code>惰性执行（lazy）</code> 的原理进行了明确。</strong> 最后讲解了在 <strong>竞态问题下，关于过期的副作用的处理逻辑。</strong> </p><h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><p>那么首先咱们先来看基本概念 <strong>副作用函数 与 响应式数据</strong>。</p><p>所谓 <strong>副作用函数</strong> 指的是 <strong>会产生副作用的函数</strong>，这样的函数非常的多。比如</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208190429676.png" alt="image-20230208190429676"></p><p>在这段代码中， <code>effect</code> 的触发会导致全局变化 <code>val</code> 发生变化，那么 <code>effect</code> 就可以被叫做<strong>副作用函数</strong>。而如果 <code>val</code> 这个数据的变化，导致了视图的变化，那么 <code>val</code> 就被叫做 <strong>响应式数据</strong>。</p><p>那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为：</p><ul><li>第一个是 <code>getter</code> 行为，也就是 <strong>数据读取</strong></li><li>第二个是 <code>setter</code> 行为，也就是 <strong>数据修改</strong></li></ul><p>在 <code>vue 2</code> 中，这样的两个行为通过 <code>Object.defineProperty</code> 进行的实现。</p><p>在 <code>vue 3</code> 中，这样的两个行为通过 <code>Proxy</code> 进行的实现。</p><p>那么具体的实现逻辑是什么呢？咱们来看下面的图示：</p><blockquote><p>首先是 <code>getter</code> 形式：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191120105.png" alt="image-20230208191120105" style="zoom:20%;"></p><p>在该函数中，存在一个 <code>effect</code> 方法，方法内部触发了 <code>getter</code> 行为。一旦 <code>getter</code> 行为被触发，则把对应的 <code>effect</code> 方法保存到一个 “桶（数据对象）” 中</p><p>当触发 <code>setter</code> 行为时：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191257788.png" alt="image-20230208191257788" style="zoom:23%;"></p><p>则会从 “桶” 中取出 <code>effect</code> 方法，并执行。</p><p>那么此时因为 <code>obj.text</code> 的值发生了变化，所以 <code>effect</code> 被执行时 <code>document.body.innerText</code> 会被赋上新的值。从而导致视图发生变化。</p></blockquote><p>这是一套构建响应式系统的基础逻辑。这一套逻辑足够应对大家在日常的 <strong>面试</strong> 或者 <strong>工作</strong> 中的基本需求。</p><p>而这套逻辑说起来简单，做起来还是有一些难度的。</p><h4 id="调度系统（scheduler）"><a href="#调度系统（scheduler）" class="headerlink" title="调度系统（scheduler）"></a>调度系统（scheduler）</h4><p>那么说完了基本的响应性之后，接下来咱们来看 <strong>调度系统（<code>scheduler</code>）</strong></p><p>所谓调度系统，指的就是 <strong>响应性的可调度性</strong>。</p><p>而所谓的可调度，指的就是 <strong>当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式</strong></p><p>比如，在这段打印中，决定打印的顺序</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208192343242.png" alt="image-20230208192343242" style="zoom:50%;"></p><p>而想要实现一个调度系统，则需要依赖 <strong><code>异步：Promise</code> 和 <code>队列：jobQueue</code></strong> 来进行实现。咱们需要 <strong>基于 <code>Set</code> 构建出一个基本的队列数组 <code>jobQueue</code>，利用 <code>Promise</code> 的异步特性，来控制执行的顺序</strong></p><h4 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h4><p>当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 <strong>计算属性（computed）</strong> 的实现了。</p><p>计算属性本质上是： <strong>一个属性值，当依赖的响应式数据发生变化时，重新计算</strong></p><p>那么它的实现就需要彻底依赖于 <strong>调度系统（scheduler）</strong> 来进行实现。</p><h4 id="惰性执行（lazy）"><a href="#惰性执行（lazy）" class="headerlink" title="惰性执行（lazy）"></a>惰性执行（lazy）</h4><p>说完计算属性，那么下面我们来看下 <code>watch</code> 监听器。</p><p><code>watch</code> 监听器本质上是 <strong>观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数</strong></p><p>这也就意味着，<code>watch</code> 很多时候并不需要立刻执行。</p><p>那么此时，就需要使用到 <strong>惰性执行（<code>lazy</code>）</strong> 来进行控制。</p><p>惰性执行的实现要比调度系统简单。它本质上 <strong>是一个 <code>boolean</code> 型的值，可以被添加到 <code>effect</code> 函数中，用来控制副作用的执行</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!lazy) &#123;</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watch-的实现原理"><a href="#watch-的实现原理" class="headerlink" title="watch 的实现原理"></a>watch 的实现原理</h4><p>基于 调度系统 与 惰性执行，那么就可以实现 <code>watch</code> 监听器了。</p><h4 id="过期的副作用"><a href="#过期的副作用" class="headerlink" title="过期的副作用"></a>过期的副作用</h4><p><code>watch</code> 监听器的实现非常广泛，有时候我们甚至可以在 <strong><code>watch</code> 中完成一些异步操作。</strong></p><p>但是大量的异步操作，极有可能会导致 <strong>竞态问题</strong>。</p><p>所谓的竞态问题，指的是 <strong>在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机</strong>。比如咱们来看这段代码</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208194352049.png" alt="image-20230208194352049" style="zoom:33%;"></p><blockquote><p>这段代码完成的是一个异步操作。</p><p>如果 <code>obj</code> 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 <code>data</code> 被赋值为 请求B 的结果。</p><p>但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 <code>data</code> 的值就会变为 请求 A 的返回值。</p><p>这个咱们的期望是不一样的。</p><p>那么这样的问题，就是 <strong>竞态问题</strong></p></blockquote><p>而如果想要解决这问题，那么就需要使用到 <code>watch</code> 回调函数的第三个参数 <code>onInvalidate</code>，它本身也是一个回调函数。并且 <strong>该回调函数（<code>onInvalidate</code>）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</strong></p><p>而 <code>onInvalidate</code> 的实现原理也非常简单，只需要 <strong>在副作用函数（effct）重新执行前，先触发 <code>onInvalidate</code></strong> 即可。</p><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><p>那么到这里，咱们就把 <strong>响应性系统的大致核心逻辑</strong> 明确完成了。从这个逻辑中，我们知道想要实现响应性数据，那么核心就是通过 <code>Proxy</code> 实现。</p><p>那么这个 <code>proxy</code> 具体怎么做呢？</p><p>接下来，咱们来看第五章。</p><h3 id="第五章：非原始值（对象）的响应性方案"><a href="#第五章：非原始值（对象）的响应性方案" class="headerlink" title="第五章：非原始值（对象）的响应性方案"></a>第五章：非原始值（对象）的响应性方案</h3><p>书中的第五章整体而言非常简单，主要就介绍了两个接口，<code>Proxy</code> 和 <code>Reflect</code>。</p><p>这两个接口通常会一起进行使用，其中：</p><ul><li><code>Proxy</code> 可以 <strong>代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象）</strong></li><li><code>Reflect</code> 可以 <strong>在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用</strong></li></ul><h3 id="第六章：原始值（非对象）的响应性方案"><a href="#第六章：原始值（非对象）的响应性方案" class="headerlink" title="第六章：原始值（非对象）的响应性方案"></a>第六章：原始值（非对象）的响应性方案</h3><p>如果大家熟悉 <code>proxy</code> 的话，那么可以知道，针对于 <code>proxy</code> 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。</p><p>但是，在 <code>vue</code> 中，我们可以通过 <code>ref</code> 构建简单数据类型的响应。</p><p>那么 <code>ref</code> 是如何进行实现的呢？</p><p>这里大家要注意：<strong>针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献</strong></p><p>在最新的 <code>vue 3.2</code> 代码中，<code>vue</code> 通过 <strong><code>get</code> 、<code>set</code>  函数标记符，让函数以属性调用的形式被触发。</strong>这两个修饰符，可以让我们 <strong>像调用属性一样，调用方法</strong>。 所以当我们平时 <strong>访问 ref.value 属性时，本质上是  value() 函数的执行</strong>。</p><h3 id="第二篇总结"><a href="#第二篇总结" class="headerlink" title="第二篇总结"></a>第二篇总结</h3><p>那么到这里咱们整个响应式系统的大概流程，就已经描述完成了。其核心逻辑主要就是在第四章中。</p><p>至于第五章和第六章，更多的偏向于具体的细节和代码逻辑。</p><h2 id="第三篇：渲染器"><a href="#第三篇：渲染器" class="headerlink" title="第三篇：渲染器"></a>第三篇：渲染器</h2><p>那么下面咱们来看 <strong>第三篇：渲染器</strong> 。</p><p>第三篇一共被分为 5 个章节。但是只讲解了三部分内容。</p><ul><li>首先第七章，主要讲解了<strong>渲染器的设计</strong>。</li><li>第八章，主要讲解了 <strong><code>DOM</code> 的挂载和更新的逻辑</strong>。</li><li>而 第九、十、十一 这三章，主要讲解了 <strong>Diff 算法</strong></li></ul><h3 id="第七章：渲染器的设计"><a href="#第七章：渲染器的设计" class="headerlink" title="第七章：渲染器的设计"></a>第七章：渲染器的设计</h3><p>在之前咱们说过 <strong>渲染器与渲染函数不是一个东西</strong></p><ul><li><strong>渲染器</strong> 是 <code>createRenderer</code> 的返回值，是一个对象。</li><li><strong>渲染函数</strong> 是渲染器对象中的 <code>render</code> 方法</li></ul><p>在 <code>vue 3.2.37</code> 的源码内部，<code>createRenderer</code> 函数的具体实现是通过 <code>baseCreateRenderer</code> 进行的。它的代码量非常庞大，涉及到了 <code>2000</code> 多行的代码。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209085155034.png" alt="image-20230209085155034" style="zoom:33%;"></p><p>代码量虽多，但是核心思路并不是特别复杂。总体可以被分为两部分：</p><ol><li><strong>在浏览器端渲染时，利用 <code>DOM API</code> 完成 <code>DOM</code> 操作</strong>：比如，如果渲染 <code>DOM</code> 那么就使用 <code>createElement</code>，如果要删除 <code>DOM</code> 那么就使用 <code>removeChild</code>。</li><li><strong>渲染器不能与宿主环境（浏览器）产生强耦合</strong>：因为 <code>vue</code> 不光有浏览器渲染，还包括了 <code>服务端</code> 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。</li></ol><p>在渲染的过程中，还有一个非常重要的概念 <code>vnode</code>。书中并没有专门的章节来介绍 <code>vnode</code>。所以为了避免各位小伙伴对 <code>vnode</code> 不了解，咱们单独把 <code>vnode</code> 说一下。</p><p>所谓 <code>vnode</code> 本身是 <strong>一个普通的 JavaScript 对象，代表了渲染的内容</strong>。对象中通过 <code>type</code> 表示渲染的 <code>DOM</code>。比如 <code>type === div</code>：则表示 <code>div</code> 标签、<code>type === Framgnet</code> 则表示渲染片段（vue 3 新增）、<code>type === Text</code> 则表示渲染文本节点。</p><h3 id="第八章：挂载与更新"><a href="#第八章：挂载与更新" class="headerlink" title="第八章：挂载与更新"></a>第八章：挂载与更新</h3><p>对于渲染器而言，它做的最核心的事情就是 <strong>对节点进行挂载、更新的操作</strong>。作者在第八章中，详细的介绍了对应的逻辑。</p><p>整个第八章分为两部分来讲解了这个事情：</p><ol><li><code>DOM</code> 节点操作</li><li>属性节点操作</li></ol><h4 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a><code>DOM</code> 节点操作</h4><p>首先先来看 <code>DOM</code> 节点操作。<code>DOM</code> 节点的操作可以分为三部分：</p><ul><li><strong>挂载</strong>：所谓挂载表示节点的初次渲染。比如，可以直接通过 <code>createElement</code> 方法新建一个 <code>DOM</code> 节点，再利用 <code>parentEl.insertBefore</code> 方法插入节点。</li><li><strong>更新</strong>：当响应性数据发生变化时，可能会涉及到 <code>DOM</code> 的更新。此时的更新本质上是属于 <strong>属性的更新</strong>。咱们等到属性节点操作那里再去说。</li><li><strong>卸载</strong>：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 <code>parentEl.removeChild</code> 进行。</li></ul><p>以上三种类型，是 <code>vue</code> 在进行 <code>DOM</code> 操作时的常见逻辑。基本上覆盖了 <code>DOM</code> 操作 <code>90% 以上</code> 的常见场景</p><h4 id="属性节点操作"><a href="#属性节点操作" class="headerlink" title="属性节点操作"></a>属性节点操作</h4><p>看完了 <code>DOM</code> 操作之后，接下来咱们来看属性节点操作。</p><p>针对于属性而言，大体可以分为两类：</p><ol><li><strong>属性</strong>：比如 <code>class</code>、<code>id</code>、<code>value</code>、<code>src</code>…</li><li><strong>事件</strong>：比如 <code>click</code>、<code>input</code>….</li></ol><p>那么咱们就先来看 <strong>非事件的属性部分</strong>。</p><p>想要了解 <code>vue</code> 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 <strong>浏览器中的属性分类</strong>。</p><p>在浏览器中 <code>DOM</code> 属性其实被分为了两类：</p><ul><li>第一类叫做 <code>HTML Attributes</code>：直接定义在 <code>HTML 标签</code> 上的属性，都属于这一类。</li><li><p>第二类叫做 <code>DOM Properties</code>：它是拿到 <code>DOM</code> 对象后定义的属性。咱们接下来主要要说的就是它。</p><p><code>HTML Attributes</code> 的定义相对而言比较简单和直观，但是问题在于 <strong>它只能在 <code>html</code> 中进行操作</strong>。</p></li></ul><p>而如果想要在 <code>JS</code> 中操作 <code>DOM</code> 属性，就必须要通过  <code>DOM Properties</code> 来进行实现。但是因为 <code>JS</code> 本身特性的问题，会导致某些 <code>DOM Properties</code> 的设置存在特殊性。比如 <code>class、type、value</code> 这三个。</p><p>所以为了保证 <code>DOM Properties</code> 的成功设置，那么我们就必须要知道 <strong>不同属性的 <code>DOM Properties</code> 定义方式 </strong>。</p><p>下面咱们来看一下。</p><p><code>DOM Properties</code> 的设置一共被分为两种：</p><ol><li><code>el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;)</code></li><li><code>. 属性赋值</code> ： <code>el.属性名 = 属性值</code> 或者 <code>el[属性名] = 属性值</code> 都属于 <code>.属性赋值</code>  </li></ol><p>我们来看这段代码：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209093545078.png" alt="image-20230209093545078" style="zoom:50%;"></p><blockquote><p>在这段代码中，我们为 <code>textarea</code> 利用 <code>DOM Properties</code> 的方式设置了三个不同的属性：</p><ul><li>首先是 <code>class</code>： <code>class</code> 在属性操作中是一个非常特殊的存在。它有两个名字 <code>class</code> 和 <code>className</code>。如果我们直接通过 <code>el.setAttribute</code> 的话，那么必须要用 <code>class</code> 才可以成功，而如果是通过 <code>. 属性</code> 的形式，那么必须要使用 <code>className</code> 才可以成功。</li><li>第二个是 <code>type</code>： <code>type</code> 仅支持 <code>el.setAttribute</code>  的方式，不支持 <code>.属性的方式</code></li><li>第三个是 <code>value</code>：<code>value</code> 不支持直接使用 <code>el.setAttribute</code>  设置，但是支持 <code>.属性</code> 的设置方式</li></ul></blockquote><p>除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>接下来，咱们来看 <code>vue</code> 对事件的处理操作。</p><p>事件的处理和属性、<code>DOM</code> 一样，也是分为 <strong>添加、删除、更新</strong> 三类。</p><ul><li>添加：添加比较简单，主要利用 <code>el.addEventListener</code> 进行实现即可。</li><li>删除：主要利用 <code>el.removeEventListener</code> 进行处理。</li><li>更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。</li></ul><p>通常情况下，我们所认知的事件更新应该是 <strong>删除旧事件、添加新事件</strong> 的过程。但是如果利用 <code>el.addEventListener</code> 和 <code>el.removeEventListener</code> 来完成这件事情，是一件非常消耗性能的事。</p><p>那么怎么能够节省性能，同时完成事件的更新呢？</p><p>这时，<code>vue</code> 对事件的更新提出了一个叫做 <code>vei</code> 的概念，这个概念的意思是： <strong>为 <code>addEventListener</code> 回调函数，设置了一个 <code>value</code> 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。</strong></p><p>这个代码比较多，大家如果想要查看具体代码的话，可以 <a href="https://github.com/lgd8981289/vue-next-mini" target="_blank" rel="noopener">在 github 搜索 vue-next-mini</a>，进入到 <code>packages/runtime-dom/src/modules/events.ts</code> 路径下查看。</p><h3 id="第九、十、十一章：Diff-算法"><a href="#第九、十、十一章：Diff-算法" class="headerlink" title="第九、十、十一章：Diff 算法"></a>第九、十、十一章：Diff 算法</h3><p>整个渲染器最后的三个章节全部都用来讲解了 <code>diff</code> 算法。</p><p>针对于 <code>diff</code> 而言，它的本质其实就是一个对比的方法，其描述的核心就是： <strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p><p>目前针对于 <code>vue 3.2.37</code> 的版本来说，整个的 <code>diff</code> 算法被分为 5 步（<strong>这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助</strong>）：</p><ol><li><code>sync from start</code>：自前向后的对比</li><li><code>sync from end</code>：自后向前的对比</li><li><code>common sequence + mount</code>：新节点多于旧节点，需要挂载</li><li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li><li><code>unknown sequence</code>：乱序</li></ol><p>而，针对于书中的这三章来说，本质上是按照 <strong>简单 diff 算法、双端 diff 算法、快速 diff 算法</strong> 的顺序把整个 <code>diff</code> 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。</p><p>所以说咱们在当前的这个分享中，肯定是没有办法为大家讲解具体算法逻辑的。</p><p>针对于这一块，我同样也是准备了另外的博客。</p><h3 id="第三篇总结"><a href="#第三篇总结" class="headerlink" title="第三篇总结"></a>第三篇总结</h3><p>针对于第三篇渲染器来说，咱们所描述的重点主要是围绕  <strong>渲染器的设计</strong> 和  <strong><code>DOM</code> 的挂载和更新的逻辑</strong> 来去说的。</p><p>针对于这两部分而言，大家要明确 <strong>渲染器与渲染函数的区别</strong>，同时要知道 <code>HTML Attributes</code> 和 <code>DOM Properties</code> 在行为上的差异性。另外关于事件更新的 <code>vei</code> 概念，应该也可以给大家带来一些新的思路。</p><p>而针对于 <code>diff</code>，咱们没有放在当前分享中去说，主要还是因为时长不够的原因。但是我为大家准备了额外的博客和视频，大家可以根据自己需要去进行查看。</p><h2 id="第四篇：组件化"><a href="#第四篇：组件化" class="headerlink" title="第四篇：组件化"></a>第四篇：组件化</h2><p>第四篇组件化，它应该算是比较简单的一个篇章，也是分为三部分来去讲解：</p><ol><li>组件的实现原理：这是咱们讲解的重心，但是不用担心，它并不复杂。</li><li>异步组件与函数式组件：这个比较冷僻，在实际开发中的使用场景有限</li><li>内建组件和模块：里面主要讲解了 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 这三个内置组件的实现逻辑</li></ol><h3 id="第十二章：组件的实现原理"><a href="#第十二章：组件的实现原理" class="headerlink" title="第十二章：组件的实现原理"></a>第十二章：组件的实现原理</h3><p>想要了解 <code>vue</code> 中组件的实现，那么首先我们需要知道什么是组件。</p><p>组件本质上就是一个 <code>JavaScript</code> 对象，比如，以下对象就是一个基本的组件</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209105953064.png" alt="image-20230209105953064" style="zoom:33%;"></p><p>而对于组件而言，同样需要使用 <code>vnode</code> 来进行表示，当 <code>vnode</code> 的 <code>type</code> 属性是一个 <strong>自定义对象</strong> 时，那么这个 <code>vnode</code> 就表示组件的 <code>vnode</code></p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110548502.png" alt="image-20230209110548502" style="zoom:33%;"></p><p>而组件的渲染，本质上是 <strong>组件包含的 <code>DOM</code> 的渲染。</strong> 对于组件而言，必然会包含一个 <code>render</code> 渲染函数。如果没有 <code>render</code> 函数，那么 <code>vue</code> 会把 <code>template</code> 模板编译为 <code>render</code> 函数。而组件渲染的内容，其实就是 <code>render</code> 函数返回的 <code>vnode</code>。具体的渲染逻辑，全部都通过渲染器执行。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110919710.png" alt="image-20230209110919710" style="zoom:33%;"></p><p><code>vue 3</code> 之后提出了 <code>composition API</code>，<code>composition API</code> 包含一个入口函数，也就是 <code>setup</code> 函数。 <code>setup</code> 函数包含两种类型的返回值：</p><ol><li><strong>返回一个函数</strong>：当 <code>setup</code> 返回一个函数时，那么该函数会被作为 <code>render</code> 函数直接渲染。</li><li><strong>返回一个对象</strong>：当 <code>setup</code> 返回一个对象时，那么 <code>vue</code> 会直接把该对象的属性，作为 <code>render</code> 渲染时的依赖数据</li></ol><p>同时，对于组件来说还有一个 <strong>插槽</strong> 的概念。插槽的实现并不神奇。插槽本质上 <strong>是一段 <code>innerHTML</code> 的内容，在 <code>vnode</code> 中以 <code>children</code> 属性进行呈现</strong>。当插槽被渲染时，只需要渲染 <code>children</code> 即可。</p><p>对于组件来说，除了咱们常用的 <strong>对象组件</strong> 之外，<code>vue</code> 还提供了额外的两种组件，也就是 <strong>异步组件与函数式组件</strong>。</p><h3 id="第十三章：异步组件与函数式组件"><a href="#第十三章：异步组件与函数式组件" class="headerlink" title="第十三章：异步组件与函数式组件"></a>第十三章：异步组件与函数式组件</h3><p>所谓异步组件，指的是： <strong>异步加载的组件</strong> 。</p><p>比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。</p><p>异步组件在 <strong>优化页面性能、拆包、服务端下发组件</strong> 时，会比较有用。</p><p>而对于 <strong>函数式组件</strong> 来说，相对就比较冷僻了。函数式组件指的是 <strong>没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 <code>props</code> 属性</strong> 。在实际开发中，并不常见。</p><h3 id="第十四章：内建组件和模块"><a href="#第十四章：内建组件和模块" class="headerlink" title="第十四章：内建组件和模块"></a>第十四章：内建组件和模块</h3><p>这一章中，主要描述了 <code>vue</code> 的三个内置组件。</p><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>首先第一个是 <code>KeepAlive</code>。</p><p>这是我们在日常开发中，非常常用的内置组件。它可以 <strong>缓存一个组件，避免该组件不断地销毁和创建</strong>。</p><p>看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 <strong>组件卸载</strong> 和 <strong>组件挂载</strong> 两个方面：</p><ul><li><strong>组件卸载</strong>：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中</li><li><strong>组件挂载</strong>：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。</li></ul><h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code> 是 <code>vue 3</code> 新增的组件，作用是 <strong>将 <code>Teleport</code> 插槽的内容渲染到其他的位置</strong>。比如我们可以把 <code>dialog</code> 渲染到 <code>body</code> 根标签之下。</p><p>它的实现原理，主要也是分为两部分：</p><ol><li>把 Teleport 组件的渲染逻辑，从渲染器中抽离</li><li>在指定的位置进行独立渲染</li></ol><h4 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h4><p><code>Transition</code> 是咱们常用的动画组件，作用是 <strong>实现动画逻辑</strong>。</p><p>其核心原理同样被总结为两点：</p><ol><li><code>DOM</code> 元素被挂载时，将动效附加到该 <code>DOM</code> 元素上</li><li><code>DOM</code> 元素被卸载时，等在 <code>DOM</code> 元素动效执行完成后，执行卸载 <code>DOM</code> 操作</li></ol><h3 id="第四篇总结"><a href="#第四篇总结" class="headerlink" title="第四篇总结"></a>第四篇总结</h3><p>整个第四篇，主要围绕着组件来去讲。所以内容并不复杂。</p><p>对于咱们的日常的开发与面试而言，其实只需要搞清楚 <strong>组件的原理</strong> 与 <strong>内建组件原理</strong> 即可。</p><h2 id="第五篇：编译器"><a href="#第五篇：编译器" class="headerlink" title="第五篇：编译器"></a>第五篇：编译器</h2><p>编译器是一个非常复杂的环节。作者主要通过 <strong>编辑器核心逻辑、解析器、编译优化</strong> 这三个方向进行了说明。</p><p>其中对于我们日常开发与面试来说，最核心的就是 <strong>第十五章：编译器核心技术概述</strong> 。这也是咱们在这一篇中的主要章节。</p><h3 id="第十五章：编译器核心技术概述"><a href="#第十五章：编译器核心技术概述" class="headerlink" title="第十五章：编译器核心技术概述"></a>第十五章：编译器核心技术概述</h3><p>在编译器核心技术概述，主要包含两个核心内容：</p><ol><li>模板 <code>DSL</code> 的编译器</li><li><code>Vue</code> 编译流程三大步</li></ol><h4 id="模板-DSL-的编译器"><a href="#模板-DSL-的编译器" class="headerlink" title="模板 DSL 的编译器"></a>模板 <code>DSL</code> 的编译器</h4><p>在任何一个编程语言中，都存在编译器的概念。 <code>vue</code> 的编译器是在 <strong>一种领域下，特定语言的编译器</strong> ，那么这种编译器被叫做 <code>DSL</code> 编译器。</p><p>而编译器的本质是 <strong>通过一段程序，可以把 A 语言翻译成 B 语言</strong>。在 <code>vue</code> 中的体现就是 <strong>把 <code>tempalte</code> 模板，编译成 <code>render</code> 渲染函数</strong></p><p>一个完整的编译器，一个分为 <strong>两个阶段、六个流程</strong>：</p><ul><li>编译前端：<ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>编译后端：<ul><li>中间代码生成</li><li>优化</li><li>目标代码生成</li></ul></li></ul><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113241592.png" alt="image-20230209113241592"></p><p>而对于 <code>vue</code> 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113421705.png" alt="image-20230209113421705"></p><ol><li><code>parse</code>：通过 <code>parse</code> 函数，把模板编译成 <code>AST</code> 对象</li><li><code>transform</code>：通过 <code>transform</code> 函数，把 <code>AST</code> 转化为 <code>JavaScript AST</code></li><li><code>generate</code>：通过 <code>generate</code> 函数，把 <code>JavaScript AST</code> 转化为 渲染函数（<code>render</code>）</li></ol><p>这三大步中，每一步都包含非常复杂的逻辑实现。</p><p>和之前一样，因为篇幅的问题，我们没有办法这里去详细讲解三大步的流程。</p><p>我依然为大家提供了 <a href="https://juejin.cn/post/7197977396603256890/42118200" target="_blank" rel="noopener">博客版</a></p><h4 id="第十六章：解析器（parse）"><a href="#第十六章：解析器（parse）" class="headerlink" title="第十六章：解析器（parse）"></a>第十六章：解析器（parse）</h4><p>这一章，主要详细讲解了 <strong>parse 解析逻辑</strong>。是在三大步中的 <code>parse</code> 逻辑的基础上，进行了一个加强。</p><p>所以这里咱们也按下不表</p><h4 id="第十七章：编译优化"><a href="#第十七章：编译优化" class="headerlink" title="第十七章：编译优化"></a>第十七章：编译优化</h4><p>最后就是编译优化。</p><p>编译优化也是一个非常大的概念，其核心就是 <strong>通过编译的手段提取关键信息，并以此知道生成最优代码的过程</strong>。</p><p>它的核心优化逻辑，主要是 <strong>把节点分为两类</strong>：</p><ul><li>第一类是 <strong>动态节点</strong>：也就是会 <strong>受数据变化影响</strong> 的节点</li><li>第二类是 <strong>静态节点</strong>：也就是 <strong>不受数据变化影响</strong> 的节点</li></ul><p>优化主要的点，就是 <strong>动态节点</strong>。</p><p>优化的方式主要是通过 <code>Block 树</code> 进行优化。</p><p><code>Block 树</code> 本质上就是一个 <strong>虚拟节点数对象</strong>，内部包含一个 <code>dynamicChildren</code> 属性，用来 <strong>收集所有的动态子节点</strong>，以达到提取关键点进行优化的目的。</p><p>除此之外，还有一些小的优化手段，比如：</p><ul><li>静态提升</li><li>预字符串化</li><li>缓存内联事件处理函数</li><li><code>v-once</code> 指令</li><li>…</li></ul><h3 id="第五篇总结"><a href="#第五篇总结" class="headerlink" title="第五篇总结"></a>第五篇总结</h3><p>其实第五篇编译器应该是整本书中，逻辑最复杂的一篇了。内部包含了特别多的代码实现。</p><p>但是因为篇幅问题，所以我们没有办法给大家进行详细介绍。只能是把大致的核心流程为大家进行明确。希望大家见谅。</p><h2 id="第六篇：服务端渲染"><a href="#第六篇：服务端渲染" class="headerlink" title="第六篇：服务端渲染"></a>第六篇：服务端渲染</h2><p>最后一篇只有一个章节，就是 <strong>同构渲染</strong>。</p><p>想要了解同构渲染，那么需要先搞明白 <code>CSR、SSR</code> 的概念。</p><ul><li><code>CSR</code>：所谓 <code>CSR</code> 指的是 <strong>客户端渲染</strong>。<ul><li>浏览器向服务器发起请求</li><li>服务器查询数据库，返回数据</li><li>浏览器得到数据，进行页面构建</li></ul></li><li><code>SSR</code>：表示 <strong>服务端渲染</strong><ul><li>览器向服务器发起请求</li><li>服务器查询数据库，根据数据，生成 <code>HTML</code> ，并进行返回</li><li>浏览器直接渲染 <code>HTML</code></li></ul></li></ul><p>两种方式各有利弊，所以同构渲染，指的就是 <strong>把 <code>CSR</code> 和 <code>SSR</code> 进行合并</strong>。既可以单独 <code>CSR</code> ，也可以单独 <code>SSR</code>，同时还可以 <strong>结合两者，在首次渲染时，通过 <code>SSR</code>，在非首次渲染时，通过 <code>CSR</code></strong>。</p><p>以下是三者的对比图</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209121227934.png" alt="image-20230209121227934" style="zoom:50%;"></p><p>而针对 <code>vue</code> 的服务端渲染来说，它是 <strong>将虚拟 <code>DOM</code>  渲染为 <code>HTML</code> 字符串</strong>，本质上是 <strong>解析的 <code>vnode</code> 对象，然后进行的 <code>html</code> 的字符串拼接</strong></p><p>最后又讲解了客户端激活的原理，大致分为两步：</p><ol><li>为页面中的 <code>DOM</code> 元素与虚拟节点对象之间建立联系</li><li>为页面中的 <code>DOM</code> 元素添加事件绑定</li></ol><p>这两步主要是通过 <code>renderer.hydrate()</code> 方法进行实现了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 那么到这里，整个 《Vue.js 设计与实现》就已经全部说完了。</p><p>整本书中，涉及到的内容是非常全面的，就像咱们开头所说的一样，它是一个 <strong>从高层的设计角度，来探讨框架需要关注的问题。</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Vue.js 设计与实现》概要总结&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>日语-N2文法</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-N2%E6%96%87%E6%B3%95/"/>
    <id>/2024/06/11/日语-N2文法/</id>
    <published>2024-06-11T03:11:15.000Z</published>
    <updated>2024-06-11T05:22:08.066Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之N2文法<br><a id="more"></a></p><h1 id="単元"><a href="#単元" class="headerlink" title="単元"></a>単元</h1><h2 id="第１７課"><a href="#第１７課" class="headerlink" title="第１７課"></a>第１７課</h2><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><h4 id="～ぬきで／～ぬきにして-本意是去除的意思，引申义是不是，不必，不需要，不的意思"><a href="#～ぬきで／～ぬきにして-本意是去除的意思，引申义是不是，不必，不需要，不的意思" class="headerlink" title="～ぬきで／～ぬきにして　本意是去除的意思，引申义是不是，不必，不需要，不的意思"></a>～ぬきで／～ぬきにして　本意是去除的意思，引申义是不是，不必，不需要，不的意思</h4><ul><li>堅苦しいあいさつはぬきにして思い切り飲みましょう。</li><li>これはお世辞抜きで面白いですよ。</li></ul><h4 id="～（よう）とする／としている-打算做-正要做，马上快要"><a href="#～（よう）とする／としている-打算做-正要做，马上快要" class="headerlink" title="～（よう）とする／としている　打算做/正要做，马上快要"></a>～（よう）とする／としている　打算做/正要做，马上快要</h4><ul><li>犯人は警察に捕まりそうになって，銃で自殺しょうとした。</li><li>复习：すると　一……就……，紧接着前项事情发生后项事情</li></ul><h4 id="据说的几种表达方式"><a href="#据说的几种表达方式" class="headerlink" title="据说的几种表达方式"></a>据说的几种表达方式</h4><ul><li>～といわれています（第3课）通常认为</li><li>～そうです （第4课）</li><li>～とのことです （第5课）</li><li>～ということです （第5课）</li><li>～とまで（さえ）いわれている （第17课）夸张的据说，极端情况下使用</li><li>蘇州は美しい街だ，東洋のベニスとさえいわれている。</li></ul><h2 id="第１8課"><a href="#第１8課" class="headerlink" title="第１8課"></a>第１8課</h2><h3 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h3><h4 id="在……的时候，期间"><a href="#在……的时候，期间" class="headerlink" title="在……的时候，期间"></a>在……的时候，期间</h4><ul><li>時　表示时间<ul><li>小さい時</li></ul></li><li>間　表示时间和空间<ul><li>皆が寝ている間に，～</li><li>東京と大阪の間に，～</li></ul></li><li>ところ　表示状态<ul><li>忙しいところですが，～</li></ul></li><li>うち　在……当中，在……期间，趁着（年轻等）<ul><li>～うちに　等同于～間に，表示在这个期间一定发生了动作<ul><li>母が外出しているうちに（間に），掃除をして部屋をピカピカにしよう。</li></ul></li><li>～うちは　表示在这个期间没有变化<ul><li>体が健康なうちは，妻と二人でのんびり暮らしたい。</li></ul></li></ul></li><li>折，節，際　和時一样，属于美化语</li></ul><h4 id="假定形＋幸いです／恐縮です-对方这么做我会很高兴-我这么做的化给对方添麻烦"><a href="#假定形＋幸いです／恐縮です-对方这么做我会很高兴-我这么做的化给对方添麻烦" class="headerlink" title="假定形＋幸いです／恐縮です　对方这么做我会很高兴/我这么做的化给对方添麻烦"></a>假定形＋幸いです／恐縮です　对方这么做我会很高兴/我这么做的化给对方添麻烦</h4><ul><li>後日こちらからお電話いたしますので，その折にご都合をお聞かせいただければ幸いです。</li><li>お忙しい中恐縮ですが，ご連絡いただければ幸いです。</li></ul><h4 id="AをBにした／とした-以A作为B的一部分-全部"><a href="#AをBにした／とした-以A作为B的一部分-全部" class="headerlink" title="AをBにした／とした　以A作为B的一部分/全部"></a>AをBにした／とした　以A作为B的一部分/全部</h4><ul><li>弊社では，「金星」をベースにした新感覚のカクテルもごよういしています。</li><li>この服は「エコロジー」をコンセプトとした素材でできています。</li></ul><h4 id="なお／また／さらに-另外，还有"><a href="#なお／また／さらに-另外，还有" class="headerlink" title="なお／また／さらに　另外，还有"></a>なお／また／さらに　另外，还有</h4><h2 id="第１９課"><a href="#第１９課" class="headerlink" title="第１９課"></a>第１９課</h2><h3 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋次第＋～-一……就……"><a href="#ます形＋次第＋～-一……就……" class="headerlink" title="ます形＋次第＋～　一……就……"></a>ます形＋次第＋～　一……就……</h4><ul><li>わかり次第ご連絡を差し上げます。</li><li>準備ができ次第，ご案内いたします。</li><li>复习：～たら，すぐに，～と</li></ul><h4 id="ます形＋つつある-表示动作正在逐渐变化或朝着一个方向发展"><a href="#ます形＋つつある-表示动作正在逐渐变化或朝着一个方向发展" class="headerlink" title="ます形＋つつある　表示动作正在逐渐变化或朝着一个方向发展"></a>ます形＋つつある　表示动作正在逐渐变化或朝着一个方向发展</h4><ul><li>中国国内の物価が上がりつつある。</li><li>复习：一方，ばかりだ，の一途をたどる，いく</li></ul><h4 id="～と評判だ-得到很高的评价"><a href="#～と評判だ-得到很高的评价" class="headerlink" title="～と評判だ　得到很高的评价"></a>～と評判だ　得到很高的评价</h4><ul><li>都内の浄水場で処理した水をボトルに詰めて販売していて，味も美味しいと評判だ。</li></ul><h4 id="～に伴って～-随着-，表示伴随着某个重大事件连带发生了另外的事件"><a href="#～に伴って～-随着-，表示伴随着某个重大事件连带发生了另外的事件" class="headerlink" title="～に伴って～　随着~，表示伴随着某个重大事件连带发生了另外的事件"></a>～に伴って～　随着~，表示伴随着某个重大事件连带发生了另外的事件</h4><ul><li>冷戦の終結に伴って，経済関係の重要性が強調されるようになってきた。</li><li>都市の緑化に伴って，駅周辺に花や木が増えってきた。</li><li>复习：～とともに</li></ul><h4 id="～のもと（で）-表示在……之下，之中。本意是表示位置靠下的部位"><a href="#～のもと（で）-表示在……之下，之中。本意是表示位置靠下的部位" class="headerlink" title="～のもと（で）　表示在……之下，之中。本意是表示位置靠下的部位"></a>～のもと（で）　表示在……之下，之中。本意是表示位置靠下的部位</h4><ul><li>国連の旗のもと，各国が協力して紛争の平和的な解決を目指している。</li><li>マイナス３０度吹雪という悪天候のものでも，観測作業は継続された。</li></ul><h4 id="一方-一边，一边，表示并列同时经行"><a href="#一方-一边，一边，表示并列同时经行" class="headerlink" title="一方　一边，一边，表示并列同时经行"></a>一方　一边，一边，表示并列同时经行</h4><ul><li>彼は大学で哲学を教える一方，大工として働いている。</li><li>复习：一方也有朝着趋势一直发展的意思</li></ul><h2 id="第２０課"><a href="#第２０課" class="headerlink" title="第２０課"></a>第２０課</h2><h3 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h3><h4 id="～だらけ-满是，沾满了，很多"><a href="#～だらけ-满是，沾满了，很多" class="headerlink" title="～だらけ　满是，沾满了，很多"></a>～だらけ　满是，沾满了，很多</h4><ul><li>ここのところ，失敗だらけなんです。</li><li>間違いだらけの答案を採点する。</li></ul><h4 id="と思ったら，～-刚一……就……，动作刚一发生，就发生了意外的事情"><a href="#と思ったら，～-刚一……就……，动作刚一发生，就发生了意外的事情" class="headerlink" title="~と思ったら，～　刚一……就……，动作刚一发生，就发生了意外的事情"></a>~と思ったら，～　刚一……就……，动作刚一发生，就发生了意外的事情</h4><ul><li>電車は発車したと思ったら大きな音を出して急停車した。</li><li>その学生は，就職したと思ったらさっさと辞めてしまった。</li></ul><h4 id="～というより-～というよりむしろ-比起这样说……还不如……-与其说是……不如说……"><a href="#～というより-～というよりむしろ-比起这样说……还不如……-与其说是……不如说……" class="headerlink" title="～というより/～というよりむしろ　比起这样说……还不如……/与其说是……不如说……"></a>～というより/～というよりむしろ　比起这样说……还不如……/与其说是……不如说……</h4><ul><li>正直に言えば，喜んで引き受けたというより思わず頷いたという形だった。</li><li>この料理は，中華料理というよりむしろ日本料理というほうが適切だ。</li></ul><h4 id="ばかり"><a href="#ばかり" class="headerlink" title="ばかり"></a>ばかり</h4><ul><li>～たばかりです　主观上觉得事情刚刚完成<ul><li>彼は3月に大学を卒業したばかりです。</li></ul></li><li>～ばかり～　全是，尽是，光是<ul><li>最近，変な夢ばかり見る。</li></ul></li><li>～てはばかりいる　消极的事情反复发生<ul><li>彼はよく遅れてばかりいる。</li></ul></li><li>～ばかりではなく　不仅……而且……<ul><li>その地方は寒いばかりではなく，乾燥しているため，農業には向いていない。</li></ul></li><li>～ばかりだ　朝着一个不好的方向不断发展<ul><li>病気はどんどん悪くなるばかりだ。</li></ul></li></ul><h4 id="～ほど-表示程度很高"><a href="#～ほど-表示程度很高" class="headerlink" title="～ほど　表示程度很高"></a>～ほど　表示程度很高</h4><ul><li>李さんは日本人と間違わるほど，日本語が上手だ。</li><li>その日は，部屋のコップの水さえ凍るほどの寒さだった。</li></ul><h4 id="Aを境にB-以A作为分水岭有了B这样的变化"><a href="#Aを境にB-以A作为分水岭有了B这样的变化" class="headerlink" title="Aを境にB　以A作为分水岭有了B这样的变化"></a>Aを境にB　以A作为分水岭有了B这样的变化</h4><ul><li>1970年代を境に，日本は高齢化社会になったといわれる。</li></ul><h1 id="単元-1"><a href="#単元-1" class="headerlink" title="単元"></a>単元</h1><h2 id="第２１課"><a href="#第２１課" class="headerlink" title="第２１課"></a>第２１課</h2><h3 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h3><h4 id="～分-与之相对应的，与另一部分做对比"><a href="#～分-与之相对应的，与另一部分做对比" class="headerlink" title="～分　与之相对应的，与另一部分做对比"></a>～分　与之相对应的，与另一部分做对比</h4><ul><li>急いだ分，仕上がりはよくない。</li><li>食べたら食べた分，運動をしないと，太ってしまいます。</li></ul><h4 id="～ずつ-在进行反复进行的动作时，每次动作实现需要的数量或分量"><a href="#～ずつ-在进行反复进行的动作时，每次动作实现需要的数量或分量" class="headerlink" title="～ずつ　在进行反复进行的动作时，每次动作实现需要的数量或分量"></a>～ずつ　在进行反复进行的动作时，每次动作实现需要的数量或分量</h4><ul><li>3人ずつ部屋に入ってください。</li><li>機械が壊れないように，電流を少しずつ流します。</li></ul><h4 id="わけ"><a href="#わけ" class="headerlink" title="わけ"></a>わけ</h4><ul><li>～わけだ　自然而然的<ul><li>田中さんは大学を卒業して3年だから，今年25歳になるというわけだ。</li></ul></li><li>～わけがない　没有道理<ul><li>食べる後にお金を上げないわけがない。</li></ul></li><li>～わけではない　并不是，不应该，不能<ul><li>皆がルールを守らないから，自分も守らなくていいというわけではない。</li></ul></li><li>～わけにはいかない　不能（没有道理的）<ul><li>ここであきらめいるわけにはいきません。</li></ul></li></ul><h4 id="必ずしも～ない-未必，表示部分否定，不强烈的否定"><a href="#必ずしも～ない-未必，表示部分否定，不强烈的否定" class="headerlink" title="必ずしも～ない　未必，表示部分否定，不强烈的否定"></a>必ずしも～ない　未必，表示部分否定，不强烈的否定</h4><ul><li>学校で学んだことが必ずしも生活に役に立つわけではない。</li><li>王さんの言うことが必ずしも正しいとは限らない。</li></ul><h4 id="～を始め-以……代表（为首）"><a href="#～を始め-以……代表（为首）" class="headerlink" title="～を始め　以……代表（为首）"></a>～を始め　以……代表（为首）</h4><ul><li>中国，日本，韓国を始めとするアジアの国々にとって経済的な協力関係は重要だ。</li></ul><h4 id="～に至るまで-意思和まで一样，多用于列举极端的事物"><a href="#～に至るまで-意思和まで一样，多用于列举极端的事物" class="headerlink" title="～に至るまで　意思和まで一样，多用于列举极端的事物"></a>～に至るまで　意思和まで一样，多用于列举极端的事物</h4><ul><li>この店には，日常使うもの，歯ブラシやせっけんはもちろん，整髪料に至るまでそろっている。</li></ul><h4 id="～といっても過言ではない-即使这么说也不过分"><a href="#～といっても過言ではない-即使这么说也不过分" class="headerlink" title="～といっても過言ではない　即使这么说也不过分"></a>～といっても過言ではない　即使这么说也不过分</h4><ul><li>私は本が好きだ。本を読まない日はないといっても過言ではない。</li><li>現在，中国の経済が世界経済の動向を決めるといっても言い過ぎではない。</li></ul><h2 id="第２２課"><a href="#第２２課" class="headerlink" title="第２２課"></a>第２２課</h2><h3 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋ながら／つつ"><a href="#ます形＋ながら／つつ" class="headerlink" title="ます形＋ながら／つつ"></a>ます形＋ながら／つつ</h4><ul><li>同时进行的动作，强调后面的动作<ul><li>彼は食べながらテレビを見る。</li><li>私は，今，お茶を飲みつつ手紙を書いています。</li></ul></li><li>虽然……但是……，表示转折<ul><li>彼は大学生でありながら，喫茶店を経営している。</li><li>何かしなければならないと思いつつ，時間が過ぎてしまった。</li></ul></li></ul><h4 id="まま-照旧，一如原样"><a href="#まま-照旧，一如原样" class="headerlink" title="まま　照旧，一如原样"></a>まま　照旧，一如原样</h4><ul><li>～たまま／～のまま　理应改变却没有改变</li><li>～ままに　表示顺从该动作或意志和～どおり有一样的意思<ul><li>お客様のご希望のままに，シェフが調理します。</li><li>あなたが望むままに生きていきなさい。</li></ul></li></ul><h4 id="～なしで／～抜きで-在不具备本来该有的某种东西的状态下做某事"><a href="#～なしで／～抜きで-在不具备本来该有的某种东西的状态下做某事" class="headerlink" title="～なしで／～抜きで　在不具备本来该有的某种东西的状态下做某事"></a>～なしで／～抜きで　在不具备本来该有的某种东西的状态下做某事</h4><ul><li>準備なしで発表をしたら，失敗した。</li><li>相談抜きで面白い。</li></ul><h4 id="～に加え（て）-不仅……而且……"><a href="#～に加え（て）-不仅……而且……" class="headerlink" title="～に加え（て）　不仅……而且……"></a>～に加え（て）　不仅……而且……</h4><ul><li>前回の勝利に加えて，今回も大差で勝った。</li></ul><h4 id="～たびに-每当……就会……"><a href="#～たびに-每当……就会……" class="headerlink" title="～たびに　每当……就会……"></a>～たびに　每当……就会……</h4><ul><li>海絵来るたびに，子供のころ溺れたことを思い出す。</li><li>卒業式のたびに校長先生は泣きながらあいさつをします。</li><li>拓展：～といつも／～時はいつも／～ごとに　意思和～たびに一样</li></ul><h4 id="次第"><a href="#次第" class="headerlink" title="次第"></a>次第</h4><ul><li>一……就……</li><li>～次第で　随着……，取决于……</li><li>この裁判では，あなたの証言次第で，被告は有罪になります。</li><li>今回の旅行でどこへ行くかは，予算次第です。</li></ul><h2 id="第２３課"><a href="#第２３課" class="headerlink" title="第２３課"></a>第２３課</h2><h3 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h3><h4 id="～だからこそ-正因为，こそ在这里起到了强调的作用"><a href="#～だからこそ-正因为，こそ在这里起到了强调的作用" class="headerlink" title="～だからこそ　正因为，こそ在这里起到了强调的作用"></a>～だからこそ　正因为，こそ在这里起到了强调的作用</h4><ul><li>偶然ではなく，~努力したからこそ教員試験に合格したんだ。</li></ul><h4 id="从……到……"><a href="#从……到……" class="headerlink" title="从……到……"></a>从……到……</h4><ul><li>～から～まで　具有连续性的准确范围<ul><li>3時から3時15分まで休憩します。</li></ul></li><li>～から～にかけて　断断续续，大致范围<ul><li>城を持たない水上都市として，明から清にかけて大きく発展した。</li></ul></li><li>～にわたって　时间长，跨度大，范围大<ul><li>10年にわたって研究開発によって，ようやく新しい農薬が完成した。</li></ul></li></ul><h4 id="时间＋を通して-表示整个时间范围"><a href="#时间＋を通して-表示整个时间范围" class="headerlink" title="时间＋を通して　表示整个时间范围"></a>时间＋を通して　表示整个时间范围</h4><ul><li>今週一週間を通して湿度が高く，蒸し暑い日が続くでしょう。</li></ul><h4 id="～ことがない-不会出现这样的情况"><a href="#～ことがない-不会出现这样的情况" class="headerlink" title="～ことがない　不会出现这样的情况"></a>～ことがない　不会出现这样的情况</h4><ul><li>その美しさはみ飽きることがない。</li></ul><h4 id="～ことはない-没必要，用不着"><a href="#～ことはない-没必要，用不着" class="headerlink" title="～ことはない　没必要，用不着"></a>～ことはない　没必要，用不着</h4><ul><li>ここまで来て，今さえ，やめることはない。</li></ul><h2 id="第２４課"><a href="#第２４課" class="headerlink" title="第２４課"></a>第２４課</h2><h3 id="文法-7"><a href="#文法-7" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋がち-往往会，容易会，表示消极的事项"><a href="#ます形＋がち-往往会，容易会，表示消极的事项" class="headerlink" title="ます形＋がち　往往会，容易会，表示消极的事项"></a>ます形＋がち　往往会，容易会，表示消极的事项</h4><ul><li>一般の視聴者にとって，CMは迷惑なものと考えられがちだ。</li><li>それは，小さい子にありがちな自己中心的な考え方です。</li></ul><h4 id="～以上（は）～／～からには～-既然……就……（建议，义务，表决心）"><a href="#～以上（は）～／～からには～-既然……就……（建议，义务，表决心）" class="headerlink" title="～以上（は）～／～からには～　既然……就……（建议，义务，表决心）"></a>～以上（は）～／～からには～　既然……就……（建议，义务，表决心）</h4><ul><li>応援する以上は最後まで応援したほうがいい。</li><li>視聴者が，企業の広告ではなく番組のためにテレビを見る以上，広告主の企業や放送局と視聴者の利害は常に対立することになる。</li></ul><h4 id="ます形／一类形容词去い＋がる-想做，觉得，用于第三人称"><a href="#ます形／一类形容词去い＋がる-想做，觉得，用于第三人称" class="headerlink" title="ます形／一类形容词去い＋がる　想做，觉得，用于第三人称"></a>ます形／一类形容词去い＋がる　想做，觉得，用于第三人称</h4><ul><li>恥ずかしがってばかりいないで，自分から発言してはどうですか。</li><li>その子供はジュースを食べたがっている。</li></ul><h1 id="単元-2"><a href="#単元-2" class="headerlink" title="単元"></a>単元</h1><h2 id="第２５課"><a href="#第２５課" class="headerlink" title="第２５課"></a>第２５課</h2><h3 id="文法-8"><a href="#文法-8" class="headerlink" title="文法"></a>文法</h3><h4 id="～ついに-终于，表示花费时间或经过艰苦努力终于完成某事"><a href="#～ついに-终于，表示花费时间或经过艰苦努力终于完成某事" class="headerlink" title="～ついに　终于，表示花费时间或经过艰苦努力终于完成某事"></a>～ついに　终于，表示花费时间或经过艰苦努力终于完成某事</h4><ul><li>あの二人は7年交際して，ついに婚約した。</li><li>やっと　侧重于期待的事情终于实现了</li><li>あの二人は7年交際して，やっよ婚約した。</li></ul><h4 id="よく"><a href="#よく" class="headerlink" title="よく"></a>よく</h4><ul><li>经常<ul><li>陳さんは東京によく遊びに行きます。</li></ul></li><li>程度<ul><li>李さん，その洋服よく似合いますね。</li></ul></li><li>意外或感叹<ul><li>それにしても，よく会場を押さえられましたよね</li></ul></li><li>以よくも的形式表示惊讶或憎恶<ul><li>裏切っておきながら，彼はよくも私たちの前に姿を見せられたものだ。</li></ul></li></ul><h4 id="ます形＋きる-表示动作或事情彻底完成，用于动作或事情实现起来有困难时"><a href="#ます形＋きる-表示动作或事情彻底完成，用于动作或事情实现起来有困难时" class="headerlink" title="ます形＋きる　表示动作或事情彻底完成，用于动作或事情实现起来有困难时"></a>ます形＋きる　表示动作或事情彻底完成，用于动作或事情实现起来有困难时</h4><ul><li>3人分の料理を1人で食べきった。</li><li>中国をはじめとしたアジアの国々，ヨーロッパやアメリカ，中東，ロシアなどにも，数えきれないほどの日本食レストランがある。</li><li>类似的表达还有ます形＋通す　不放弃，不会改变想法，把某一动作坚持做到最后<ul><li>演奏家は途中で間違えたが，最後までその曲を弾き通した。</li></ul></li></ul><h4 id="～に応じた（接名词）／～に応じて（接动词）-根据-适应-，书面语"><a href="#～に応じた（接名词）／～に応じて（接动词）-根据-适应-，书面语" class="headerlink" title="～に応じた（接名词）／～に応じて（接动词）　根据/适应~，书面语"></a>～に応じた（接名词）／～に応じて（接动词）　根据/适应~，书面语</h4><ul><li>賃金は働きに応じて支払われる。</li><li>外国で売られている寿司は，文化の違いに応じた「創作料理」になっていることが多い。</li></ul><h4 id="～から見ると／～から見ても／～から見れば-从……来看，从某种立场上审视，考虑问题。"><a href="#～から見ると／～から見ても／～から見れば-从……来看，从某种立场上审视，考虑问题。" class="headerlink" title="～から見ると／～から見ても／～から見れば　从……来看，从某种立场上审视，考虑问题。"></a>～から見ると／～から見ても／～から見れば　从……来看，从某种立场上审视，考虑问题。</h4><ul><li>日本人から見ると，寿司だとは思えないものもたくさんある。</li><li>私から見て，佐藤さんは素晴らしい上司だ。</li></ul><h4 id="～に即した／～に即して-按照……-根据……"><a href="#～に即した／～に即して-按照……-根据……" class="headerlink" title="～に即した／～に即して　按照……/根据……"></a>～に即した／～に即して　按照……/根据……</h4><ul><li>食べ物はその国の状況に即して変化するものなのだ。</li><li>現状に即して考えると，政府の予測は楽観的過ぎる。</li></ul><h4 id="ぬ，ず-都是古日语用于表示未然形"><a href="#ぬ，ず-都是古日语用于表示未然形" class="headerlink" title="ぬ，ず　都是古日语用于表示未然形"></a>ぬ，ず　都是古日语用于表示未然形</h4><ul><li>江戸前ならぬ，アメリカ前，ニュージーランド前の寿司をその土地のスタイルで楽しむのもよいのではないだろうか。</li></ul><h2 id="第２６課"><a href="#第２６課" class="headerlink" title="第２６課"></a>第２６課</h2><h3 id="文法-9"><a href="#文法-9" class="headerlink" title="文法"></a>文法</h3><h4 id="～だけあって-真不愧是……，一般和さすが连用"><a href="#～だけあって-真不愧是……，一般和さすが连用" class="headerlink" title="～だけあって　真不愧是……，一般和さすが连用"></a>～だけあって　真不愧是……，一般和さすが连用</h4><ul><li>さすが上海一の高級ホテルだけあって，素晴らしい会場ですね。</li></ul><h4 id="～だけに-正是由于……"><a href="#～だけに-正是由于……" class="headerlink" title="～だけに　正是由于……"></a>～だけに　正是由于……</h4><ul><li>今回のテストは簡単だっただけに，クラスの平均点は高かった。</li></ul><h4 id="古日语表示未然形"><a href="#古日语表示未然形" class="headerlink" title="古日语表示未然形"></a>古日语表示未然形</h4><ul><li>复习：ず（三类动词せず），ぬ</li><li>ざる<ul><li>ない形＋ざるをえない／～しかない　不得不……，只好……<ul><li>約束だから，明日までにやらざるをえません。</li><li>期限が迫っているので，決めざるを得ません。</li><li>パソコンがフリーズしたので，プログラムを終了するしかありません。</li></ul></li></ul></li></ul><h4 id="～にもかかわらず-尽管……-虽然……"><a href="#～にもかかわらず-尽管……-虽然……" class="headerlink" title="～にもかかわらず　尽管……/虽然……"></a>～にもかかわらず　尽管……/虽然……</h4><ul><li>何度も注意したにもかかわらず，娘はまた友達の悪口を言っている。</li><li>李さんは頭が痛いにもかかわらず，寝ないで仕事を続けた。</li></ul><h4 id="～どころか-从根本上否定，用于消极事项，类似はもちろん"><a href="#～どころか-从根本上否定，用于消极事项，类似はもちろん" class="headerlink" title="～どころか　从根本上否定，用于消极事项，类似はもちろん"></a>～どころか　从根本上否定，用于消极事项，类似はもちろん</h4><ul><li>忙しくて，昼ご飯どころか，朝ご飯も食べていない。</li><li>このところ支出が多くて，貯金するどころか，借金が増えてしまった。</li></ul><h4 id="ます形＋かねる／かねない-难以实现-不好的事情很容易很可能实现"><a href="#ます形＋かねる／かねない-难以实现-不好的事情很容易很可能实现" class="headerlink" title="ます形＋かねる／かねない　难以实现/不好的事情很容易很可能实现"></a>ます形＋かねる／かねない　难以实现/不好的事情很容易很可能实现</h4><ul><li>このままだと，プロジェクトは中止になりかねない。</li></ul><h2 id="第２７課"><a href="#第２７課" class="headerlink" title="第２７課"></a>第２７課</h2><h3 id="文法-10"><a href="#文法-10" class="headerlink" title="文法"></a>文法</h3><h4 id="Aなしには／では／て＋B-没有A是不可能完成B的"><a href="#Aなしには／では／て＋B-没有A是不可能完成B的" class="headerlink" title="Aなしには／では／て＋B　没有A是不可能完成B的"></a>Aなしには／では／て＋B　没有A是不可能完成B的</h4><ul><li>今回の成功は，彼らの協力なしにはありえなかったと思います。</li><li>お金もなしに，会社を成立することは不可能だ。</li></ul><h4 id="ます形＋える／うる-也表示为动词的可能态"><a href="#ます形＋える／うる-也表示为动词的可能态" class="headerlink" title="ます形＋える／うる　也表示为动词的可能态"></a>ます形＋える／うる　也表示为动词的可能态</h4><ul><li>この状態は，予想しえない事態だ。</li></ul><h4 id="字典形＋まい"><a href="#字典形＋まい" class="headerlink" title="字典形＋まい"></a>字典形＋まい</h4><ul><li>～ないだろう　表示否定推测，难道不是……<ul><li>この勝負の勝敗はすでに決まっていたのではあるまいか。</li></ul></li><li>～しないつもりだ　表示否定的意志<ul><li>こんな所にはもう二度と来るまい。</li></ul></li></ul><h4 id="～ずにはいられない-忍不住要……做"><a href="#～ずにはいられない-忍不住要……做" class="headerlink" title="～ずにはいられない　忍不住要……做"></a>～ずにはいられない　忍不住要……做</h4><ul><li>部屋が汚れていると，片づけずにはいられない。</li><li>その映画を見たら，泣かずにはいられない。</li></ul><h4 id="～のみならず-不仅……"><a href="#～のみならず-不仅……" class="headerlink" title="～のみならず　不仅……"></a>～のみならず　不仅……</h4><ul><li>中国のみならず，日本でも張一心は人気がある。</li><li>复习：和～ばかりでなく，～だけではなく意思一样</li></ul><h4 id="ちなみに～-顺便一提，附带，补充说明"><a href="#ちなみに～-顺便一提，附带，补充说明" class="headerlink" title="ちなみに～　顺便一提，附带，补充说明"></a>ちなみに～　顺便一提，附带，补充说明</h4><ul><li>玉袁譚公園では，日本から寄贈された桜を見ることができる。ちなみに，北京の桜は東京よりも3週間ほど開花が遅いそうだ。</li></ul><h2 id="第２８課"><a href="#第２８課" class="headerlink" title="第２８課"></a>第２８課</h2><h3 id="文法-11"><a href="#文法-11" class="headerlink" title="文法"></a>文法</h3><h4 id="～もんです-表示理由的ものです"><a href="#～もんです-表示理由的ものです" class="headerlink" title="～もんです　表示理由的ものです"></a>～もんです　表示理由的ものです</h4><ul><li>ここ数日忙しかったもんで，なかなかお電話できず申し訳ありませんでした。</li></ul><h4 id="ついでに-做某事同时又在做着其他事情"><a href="#ついでに-做某事同时又在做着其他事情" class="headerlink" title="ついでに　做某事同时又在做着其他事情"></a>ついでに　做某事同时又在做着其他事情</h4><ul><li>散歩に出たついでに，コンビニで買い物をして帰った。</li></ul><h4 id="だったらいいんです／ならいいんです-那就好"><a href="#だったらいいんです／ならいいんです-那就好" class="headerlink" title="だったらいいんです／ならいいんです　那就好"></a>だったらいいんです／ならいいんです　那就好</h4><ul><li>コンテストは大成功のうちに終わりました。<ul><li>だったらいいんです。</li></ul></li></ul><h4 id="～だけには～-唯独对……"><a href="#～だけには～-唯独对……" class="headerlink" title="～だけには～　唯独对……"></a>～だけには～　唯独对……</h4><ul><li>健康だけには自信があったのに。</li></ul><h4 id="Aに反してB-与A相反的B"><a href="#Aに反してB-与A相反的B" class="headerlink" title="Aに反してB　与A相反的B"></a>Aに反してB　与A相反的B</h4><ul><li>予想に反して，来場者は1万人を超えた。</li></ul><h4 id="そてらとは別に-另一方面，与～一方有相同的意思"><a href="#そてらとは別に-另一方面，与～一方有相同的意思" class="headerlink" title="そてらとは別に　另一方面，与～一方有相同的意思"></a>そてらとは別に　另一方面，与～一方有相同的意思</h4><ul><li>彼は英会話学校で動いています。しかし，それらとは別に芸術家として活動しています。</li></ul><h1 id="単元-3"><a href="#単元-3" class="headerlink" title="単元"></a>単元</h1><h2 id="第２９課"><a href="#第２９課" class="headerlink" title="第２９課"></a>第２９課</h2><h3 id="文法-12"><a href="#文法-12" class="headerlink" title="文法"></a>文法</h3><h4 id="～までもない-没必要"><a href="#～までもない-没必要" class="headerlink" title="～までもない　没必要"></a>～までもない　没必要</h4><ul><li>今さら言うまでもありません，すべて皆さんのおかげです。</li></ul><h4 id="～ぶり／～っぷり-……的样子"><a href="#～ぶり／～っぷり-……的样子" class="headerlink" title="～ぶり／～っぷり　……的样子"></a>～ぶり／～っぷり　……的样子</h4><ul><li>彼の歩きぶりから見せと，どうも足にけがをしているようだ。</li><li>佐藤さんはいつも食べっぷりがいい。</li><li>复习：时间＋ぶり表示时间间隔</li></ul><h4 id="たった-仅仅经常和だけ连用"><a href="#たった-仅仅经常和だけ连用" class="headerlink" title="たった　仅仅经常和だけ连用"></a>たった　仅仅经常和だけ连用</h4><ul><li>たった1年で，これだけ業績を上げたんですから。</li></ul><h4 id="～に決まっている-一定是……，绝对是……，肯定是……"><a href="#～に決まっている-一定是……，绝对是……，肯定是……" class="headerlink" title="～に決まっている　一定是……，绝对是……，肯定是……"></a>～に決まっている　一定是……，绝对是……，肯定是……</h4><ul><li>今から会社に帰っても，もう誰もいないにきまっている。</li></ul><h4 id="AうえでB／AたうえでB-为了A，在此之前先做B-先做A，然后做B"><a href="#AうえでB／AたうえでB-为了A，在此之前先做B-先做A，然后做B" class="headerlink" title="AうえでB／AたうえでB　为了A，在此之前先做B/先做A，然后做B"></a>AうえでB／AたうえでB　为了A，在此之前先做B/先做A，然后做B</h4><ul><li>外国に住むうえで，一番気を付けなければならないことは何ですか。</li><li>多額の資金を集めたうえで，会長に立候補した。</li></ul><h4 id="そう～ではない-并不是……"><a href="#そう～ではない-并不是……" class="headerlink" title="そう～ではない　并不是……"></a>そう～ではない　并不是……</h4><ul><li>日本語はそう難しくないと思います。</li></ul><h4 id="～とはいうものの-虽然这么说，尽管"><a href="#～とはいうものの-虽然这么说，尽管" class="headerlink" title="～とはいうものの　虽然这么说，尽管"></a>～とはいうものの　虽然这么说，尽管</h4><ul><li>とはいうものの，宇宙に持っていける食べ物には，いくつかの条件がある。</li><li>このはかりはデザインが斬新なものの，実用的ではない。</li></ul><h4 id="～にすら-尽然，连"><a href="#～にすら-尽然，连" class="headerlink" title="～にすら　尽然，连"></a>～にすら　尽然，连</h4><ul><li>そのことは，田中さんすら知らなかった。</li><li>疲れ切って，食事すらできない。</li></ul><h4 id="～にあたって-在……之际"><a href="#～にあたって-在……之际" class="headerlink" title="～にあたって　在……之际"></a>～にあたって　在……之际</h4><ul><li>海外に赴任するにあたって，いろいろな準備をしなければなりませんでした。</li></ul><h2 id="第３０課"><a href="#第３０課" class="headerlink" title="第３０課"></a>第３０課</h2><h3 id="文法-13"><a href="#文法-13" class="headerlink" title="文法"></a>文法</h3><h4 id="Aに先立ってB-在A之前先做B动作"><a href="#Aに先立ってB-在A之前先做B动作" class="headerlink" title="Aに先立ってB　在A之前先做B动作"></a>Aに先立ってB　在A之前先做B动作</h4><ul><li>トレーニングの開始に先立ち，細かいスケジュールを立てた。</li></ul><h4 id="Aを通してB-表示方法手段，通过A做B动作"><a href="#Aを通してB-表示方法手段，通过A做B动作" class="headerlink" title="Aを通してB　表示方法手段，通过A做B动作"></a>Aを通してB　表示方法手段，通过A做B动作</h4><ul><li>妻とは，私と妻の共通の友人を通して知り合いました。</li><li>复习：时间段+を通して　表示整个时间段</li></ul><h4 id="～できなくはない-不是不能"><a href="#～できなくはない-不是不能" class="headerlink" title="～できなくはない　不是不能"></a>～できなくはない　不是不能</h4><ul><li>その映画は原作を読まなくても理解できなくはないですが，よく分からないと思うころがたくさんあると思います。</li></ul><h4 id="～にしたがって／～につれて-随着……，按照……"><a href="#～にしたがって／～につれて-随着……，按照……" class="headerlink" title="～にしたがって／～につれて　随着……，按照……"></a>～にしたがって／～につれて　随着……，按照……</h4><ul><li>年を取るにしたがって，一日が短く感じられるのはなぜだろう。</li><li>太陽が沈むにしたがって，辺りは暗くなった。</li></ul><h4 id="～にすぎない-不过如此，没什么大不了的"><a href="#～にすぎない-不过如此，没什么大不了的" class="headerlink" title="～にすぎない　不过如此，没什么大不了的"></a>～にすぎない　不过如此，没什么大不了的</h4><ul><li>私はあくまで彼の代理で会議に出席したにすぎない。</li></ul><h4 id="～に位置している-位于，处于……位置"><a href="#～に位置している-位于，处于……位置" class="headerlink" title="～に位置している　位于，处于……位置"></a>～に位置している　位于，处于……位置</h4><ul><li>フランスはドイツの西に位置しています。</li></ul><h4 id="～にほかならない-正因为是……"><a href="#～にほかならない-正因为是……" class="headerlink" title="～にほかならない　正因为是……"></a>～にほかならない　正因为是……</h4><ul><li>落第の原因は，勉強不足にほかならない。</li></ul><h4 id="～としても，～-即使……也……"><a href="#～としても，～-即使……也……" class="headerlink" title="～としても，～　即使……也……"></a>～としても，～　即使……也……</h4><ul><li>両親が反対したとしても，私は留学します。</li><li>明日は忙しいので，そちらに伺えるとしても遅くなってしまうと思います。</li></ul><h2 id="第３１課"><a href="#第３１課" class="headerlink" title="第３１課"></a>第３１課</h2><h3 id="文法-14"><a href="#文法-14" class="headerlink" title="文法"></a>文法</h3><h4 id="～くせに-明明……却……"><a href="#～くせに-明明……却……" class="headerlink" title="～くせに　明明……却……"></a>～くせに　明明……却……</h4><ul><li>俺より2年後輩のくせに，すごいじゃないか。</li><li>私の息子は，学校で答えが分からないくせに，いつも手を挙げているそうだ。</li></ul><h4 id="（动词原形-形容词去い＋くある-名词和形动＋である）＋べき-表示第三人称的应该……"><a href="#（动词原形-形容词去い＋くある-名词和形动＋である）＋べき-表示第三人称的应该……" class="headerlink" title="（动词原形/形容词去い＋くある/名词和形动＋である）＋べき　表示第三人称的应该……"></a>（动词原形/形容词去い＋くある/名词和形动＋である）＋べき　表示第三人称的应该……</h4><ul><li>とにかく，先に栄転を受けるべきだよ。</li><li>すべての人は平等であるべきだ。</li><li>地球の自然はいつまでも美しくあるべきだ。</li></ul><h4 id="～もんか／～ものか-不……"><a href="#～もんか／～ものか-不……" class="headerlink" title="～もんか／～ものか　不……"></a>～もんか／～ものか　不……</h4><ul><li>こうなったら，もう心配なんてするもんか。</li><li>助けてやると言ったのに断るなんて，もう絶対に助けてやるものか。</li></ul><h4 id="～てやる-说话人给予对方利益，恩惠。"><a href="#～てやる-说话人给予对方利益，恩惠。" class="headerlink" title="～てやる　说话人给予对方利益，恩惠。"></a>～てやる　说话人给予对方利益，恩惠。</h4><ul><li>今日は俺がおごってやるよ。</li><li>娘に四捨五入の方法を教えてやる。</li></ul><h4 id="～とすると／～とすれば／～となると／～としたら-如果……"><a href="#～とすると／～とすれば／～となると／～としたら-如果……" class="headerlink" title="～とすると／～とすれば／～となると／～としたら　如果……"></a>～とすると／～とすれば／～となると／～としたら　如果……</h4><ul><li>公衆の面前でスピーチするとなると，緊張してしまいます。</li></ul><h4 id="～がなされる／～をする-古日语的用法，书面语"><a href="#～がなされる／～をする-古日语的用法，书面语" class="headerlink" title="～がなされる／～をする　古日语的用法，书面语"></a>～がなされる／～をする　古日语的用法，书面语</h4><ul><li>今回の研究会では活溌な議論がなされる。</li></ul><h2 id="第３２課"><a href="#第３２課" class="headerlink" title="第３２課"></a>第３２課</h2><h3 id="文法-15"><a href="#文法-15" class="headerlink" title="文法"></a>文法</h3><h4 id="～どころではない-顾不上……，不是做……的时候"><a href="#～どころではない-顾不上……，不是做……的时候" class="headerlink" title="～どころではない　顾不上……，不是做……的时候"></a>～どころではない　顾不上……，不是做……的时候</h4><ul><li>父は正月だというのに出かけるどころではなく，家で遅くまで仕事をしている。</li></ul><h4 id="～なりに-站在……立场上"><a href="#～なりに-站在……立场上" class="headerlink" title="～なりに　站在……立场上"></a>～なりに　站在……立场上</h4><ul><li>大阪で，僕なりに考えました。</li><li>あの子もあの子なりに意見があるのでしょうから，怒らないでまず話を聞いてあげてください。</li></ul><h4 id="～でしかない-不过是……"><a href="#～でしかない-不过是……" class="headerlink" title="～でしかない　不过是……"></a>～でしかない　不过是……</h4><ul><li>貯金しているといっても，まだ１０万円でしかない。</li><li>言葉というのはコミュニケーションをするための道具でしかない。</li></ul><h4 id="～恐れがある／～かねない（有依据时可以使用）-恐怕会……，很有可能……发生不好的事情"><a href="#～恐れがある／～かねない（有依据时可以使用）-恐怕会……，很有可能……发生不好的事情" class="headerlink" title="～恐れがある／～かねない（有依据时可以使用）　恐怕会……，很有可能……发生不好的事情"></a>～恐れがある／～かねない（有依据时可以使用）　恐怕会……，很有可能……发生不好的事情</h4><ul><li>台風が本州に上達する恐れがある。</li><li>あんな運転の仕方では，衝突事故でも起こしかねない。</li></ul><h4 id="～のみ-和だけ一样的意思，书面语"><a href="#～のみ-和だけ一样的意思，书面语" class="headerlink" title="～のみ　和だけ一样的意思，书面语"></a>～のみ　和だけ一样的意思，书面语</h4><ul><li>この商品は，予約している方のみ購入することができます。</li></ul><h4 id="～に至る-到……为止，书面语"><a href="#～に至る-到……为止，书面语" class="headerlink" title="～に至る　到……为止，书面语"></a>～に至る　到……为止，书面语</h4><ul><li>現在では1000羽以上が確認されるに至っている。</li><li>結婚に至るまで，二人の間にはいろんなことがありました。</li></ul><h4 id="AかたわらB-表示A和B同时进行，A是主要动作，B是次要动作"><a href="#AかたわらB-表示A和B同时进行，A是主要动作，B是次要动作" class="headerlink" title="AかたわらB　表示A和B同时进行，A是主要动作，B是次要动作"></a>AかたわらB　表示A和B同时进行，A是主要动作，B是次要动作</h4><ul><li>山本さんはコーチのかたわら，審判としても活躍している。</li></ul><h4 id="～に終わる（失敗，不調）-以不顺利的情况结束"><a href="#～に終わる（失敗，不調）-以不顺利的情况结束" class="headerlink" title="～に終わる（失敗，不調）　以不顺利的情况结束"></a>～に終わる（失敗，不調）　以不顺利的情况结束</h4><ul><li>今回の世界大会で，日本チームは実力が出せずに不調に終わった。</li></ul><h4 id="～をもって-以……分水岭，从……起，到……为止"><a href="#～をもって-以……分水岭，从……起，到……为止" class="headerlink" title="～をもって　以……分水岭，从……起，到……为止"></a>～をもって　以……分水岭，从……起，到……为止</h4><ul><li>私は，3月31日をもって，会社を退職することにいたしました。</li></ul><h4 id="～に際して-在……之际，……的时候，书面语"><a href="#～に際して-在……之际，……的时候，书面语" class="headerlink" title="～に際して　在……之际，……的时候，书面语"></a>～に際して　在……之际，……的时候，书面语</h4><ul><li>本ホームページのご利用に際しては，以かの点にご注意ください。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之N2文法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-N3文法</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-N3%E6%96%87%E6%B3%95/"/>
    <id>/2024/06/11/日语-N3文法/</id>
    <published>2024-06-11T03:10:55.000Z</published>
    <updated>2024-06-11T05:20:24.688Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之N3文法<br><a id="more"></a></p><h1 id="単元"><a href="#単元" class="headerlink" title="単元"></a>単元</h1><h2 id="第１課"><a href="#第１課" class="headerlink" title="第１課"></a>第１課</h2><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><h4 id="～くらい-ぐらい-ほど-接续：动词简体，形容词，形容动词＋な，名词"><a href="#～くらい-ぐらい-ほど-接续：动词简体，形容词，形容动词＋な，名词" class="headerlink" title="～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词"></a>～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词</h4><ol><li><p>接续：动词简体，形容词，形容动词+ な</p></li><li><p>……左右，大约……，可以和ほど替换</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：家から学校まで一時間ぐらいかかる。</span><br><span class="line">译：从家到学校大概要花1个小时左右。</span><br><span class="line"></span><br><span class="line">例：どのぐらい日本語を勉強していますか。</span><br><span class="line">译：大概学了多久日语呢？</span><br></pre></td></tr></table></figure><ol start="3"><li>表示动作或状态的程度，可以和ほど替换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：飛ぶほど嬉しい。</span><br><span class="line">译：高兴地飞起。</span><br><span class="line"></span><br><span class="line">例：今日は忙しくて、食事する時間もないくらいだ。</span><br><span class="line">译：今天太忙了以至于我连吃饭的时间都没有。</span><br></pre></td></tr></table></figure><ol start="4"><li>表示最低程度，至少</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：いくら忙しくても、電話ぐらいはできるでしょう。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：自分の事ぐらいは自分でやります。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ol start="5"><li>没有比……更……，可以和ほど替换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：朱さんぐらい可愛い人はいない。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：戦争ぐらい残酷なものはない。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="とは-というのは"><a href="#とは-というのは" class="headerlink" title="とは/というのは"></a>とは/というのは</h4><ol><li>所谓的~ 用于下定义和解释说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：JRとは、Japan Railwaysの略です。</span><br><span class="line">译：JR是Japan Railways的简写。</span><br></pre></td></tr></table></figure><ol start="2"><li>……是因为…… 前者是因为后者导致的，这时只能用～というのは～のだ</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は怒ったというのは、きっと酷い事を言われたのでしょう。</span><br><span class="line">译：他生气的原因一定是被说了很过分的话吧？</span><br></pre></td></tr></table></figure><h4 id="～というものは-ということは-用于说明该事物的本质特征"><a href="#～というものは-ということは-用于说明该事物的本质特征" class="headerlink" title="～というものは/ということは 用于说明该事物的本质特征"></a>～というものは/ということは 用于说明该事物的本质特征</h4><ol><li>～というものは 用于名词</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：人間というものは一人で生きていくことはできません。</span><br><span class="line">译：人类是一个人无法生存下去的吧。</span><br></pre></td></tr></table></figure><ol start="2"><li>～ということは 用于动词，也可以用于对事情原因的推测</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：一人で生活するということは、大変なことですね。</span><br><span class="line">译：一个人生活真是不容易呀。</span><br><span class="line"></span><br><span class="line">例：彼は怒ったということは、きっと酷い事を言われたのでしょう。</span><br><span class="line">译：他生气的原因一定是被说了很过分的话吧？</span><br></pre></td></tr></table></figure><ol start="3"><li>～ということは/つまり、～ということだ　也就是说……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日から会社へ来なくてもいい、つまり君はクビだということだ。</span><br><span class="line">译：明天就不用来公司上班了，也就是说你被解雇了。</span><br></pre></td></tr></table></figure><h4 id="～はもちろん-はもとより-自不必说"><a href="#～はもちろん-はもとより-自不必说" class="headerlink" title="～はもちろん/はもとより　自不必说"></a>～はもちろん/はもとより　自不必说</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：最近は仕事が忙しくて、土曜日はもちろん、日曜日も休めない。</span><br><span class="line">译：最近工作太忙了，星期六就不用说了，星期天也没法休息了。</span><br><span class="line"></span><br><span class="line">例：主要都市を結ぶ路線はもちろん、世界で初めて実用化されたリニアモーターカーも国営です。</span><br><span class="line">译：连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。</span><br></pre></td></tr></table></figure><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>日本には，JR，鉄道，公営の３種類の鉄道会社があります。JRとは，Japan Railwaysの略です。以前は国営の鉄道でしたが，１９８７年に民営化されました。世界的に有名な新幹線もJRの路線の１つで，日本の主要な都市と都市を結んでいます。最高時速は３００キロを超えます。最初に完成したのは東海道新幹線ですが，山陽新幹線，東北新幹線，九州新幹線など，路線がどんどん延びています。</p><p>中国の鉄道は，ほとんど国営です。主要都市を結ぶ路線はもちろん，世界で初めて実用化されたリニアモーターも国営です。</p><blockquote><p>在日本有JR、铁路、公营三种类型的铁路公司。JR是Japan Railways的简称。以前是属于国有铁路，1987年民营化了。世界有名的新干线就是JR的其中一条线路，把日本主要城市与城市之间连接起来。最高时速超过300公里。最初完成的是东海道新干线、山阳新干线以及九州新干线等等，渐渐的线路不断延伸。</p></blockquote><blockquote><p>中国的铁路基本都是国营的。连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。</p></blockquote><h2 id="第２課"><a href="#第２課" class="headerlink" title="第２課"></a>第２課</h2><h3 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h3><h4 id="～ものです。"><a href="#～ものです。" class="headerlink" title="～ものです。"></a>～ものです。</h4><ol><li>表示对事物的性质或变化的感慨或吃惊，经常与よく一起使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一人でよく返って来られたものですね。</span><br><span class="line">译：竟然能一个人回来呀。</span><br></pre></td></tr></table></figure><ol start="2"><li>AはBものです，A本质上具有B的性质、B是理所应当的事情</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：人の心は分からないものです。（本质）</span><br><span class="line">译：人心是最难懂的。</span><br><span class="line"></span><br><span class="line">例：約束の時間に遅れる時は，相手に連絡するものです。（理所应当）</span><br><span class="line">译：在约定的时间迟到了的话，应该和对方联系。</span><br></pre></td></tr></table></figure><h4 id="口语中经常使用～て来接续，书面语中使用ます形来接续"><a href="#口语中经常使用～て来接续，书面语中使用ます形来接续" class="headerlink" title="口语中经常使用～て来接续，书面语中使用ます形来接续"></a>口语中经常使用～て来接续，书面语中使用ます形来接续</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：深いお辞儀をし，相手の名刺をお辞儀をしながら受け取ります。</span><br><span class="line">译：深深地鞠躬，一边鞠躬一边接受对方的名片。</span><br></pre></td></tr></table></figure><h4 id="简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！"><a href="#简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！" class="headerlink" title="简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！"></a>简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：名刺を出す時も受け取る時も，両手を使うほうが丁寧です。</span><br><span class="line">译：名片递出和接收的时候，用双手是更加礼貌的。</span><br></pre></td></tr></table></figure><h4 id="いくら～ても～-无论……也……"><a href="#いくら～ても～-无论……也……" class="headerlink" title="いくら～ても～　无论……也……"></a>いくら～ても～　无论……也……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この店ではいくら食べても，１０００円です。</span><br><span class="line">译：这家店不管吃多少，只要1000日元。</span><br></pre></td></tr></table></figure><h3 id="课文-1"><a href="#课文-1" class="headerlink" title="课文"></a>课文</h3><p>仕事で初対面の人にあった時は，名刺を出します。名刺の出し方と受け取り方にも決まりがあります。相手が目上の時は，まず自分から名刺をだして深いお辞儀をし，次に相手の名刺をお辞儀をしながら受け取ります。出す時も受け取る時も，両手を使うほうが丁寧です。</p><p>また，話内容にも気をつけなけれならなりません。初対面の時は，個人的なことを聞かないのが普通です。特に仕事の場で出合った相手には，個人的な質問を避けたほうがいいでしょう。結婚しているかどうか，給料はいくらか，年齢はいくつかなどもは，普通は聞きません。</p><blockquote><p>工作场合下和对方第一次见面时，要递出名片。名片的递出和接收方法都是有规定的。对方是上级的时候，首先自己首先递出名片并深鞠躬，接着边鞠躬边接收对方的名片。名片递出和接收的时候，用双手是更加礼貌的。</p></blockquote><blockquote><p>另外聊天的内容也要注意。第一次见面时，个人相关的事情一般不要询问。特别是工作场合遇到对方，最好避免个人问题。结婚了没，工资多少，年龄多大了等问题一般不要询问。</p></blockquote><h2 id="第３課"><a href="#第３課" class="headerlink" title="第３課"></a>第３課</h2><h3 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h3><h4 id="～を含めて＋数量词-包括-在内的-「数量词」"><a href="#～を含めて＋数量词-包括-在内的-「数量词」" class="headerlink" title="～を含めて＋数量词 包括~在内的+「数量词」"></a>～を含めて＋数量词 包括~在内的+「数量词」</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今回の『金星』プロジェクトは，私を含めて４名のスタッフが担当いたします。</span><br><span class="line">译：这次金星项目包括我一共四人负责。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：～ほか＋数量词 除开……还有+「数量词」……</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今回のプロジェクトの担当者は，主任の李秀麗ほか３名のスタッフです。</span><br><span class="line">译：这次的项目负责人除了李秀丽以外还有3人。</span><br></pre></td></tr></table></figure><h4 id="～にとって-对……来说，表示从某人立场上来说，用于表明立场"><a href="#～にとって-对……来说，表示从某人立场上来说，用于表明立场" class="headerlink" title="～にとって 对……来说，表示从某人立场上来说，用于表明立场"></a>～にとって 对……来说，表示从某人立场上来说，用于表明立场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。</span><br><span class="line">译：对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><blockquote><p>～として，有和当事人有同一向想法的时候使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：困っている人を助けるのは，人間として当然のことです。</span><br><span class="line">译：帮助有困难的人，作为人来说是应当的。</span><br></pre></td></tr></table></figure><blockquote><p>～としては，站在客观立场上，强调自己的立场</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私としては，その案に反対です。</span><br><span class="line">译：我个人是反对这个方案的。</span><br></pre></td></tr></table></figure><blockquote><p>～にしたら・～してみれば・～にすれば 有希望对方理解的感觉</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大人には簡単でも，子供にしたら難しいでしょう。</span><br><span class="line">译：对大人来说简单，可对小孩子就困难的很。</span><br></pre></td></tr></table></figure><h4 id="～が，～けど-表示转折或者铺垫下文的说法"><a href="#～が，～けど-表示转折或者铺垫下文的说法" class="headerlink" title="～が，～けど 表示转折或者铺垫下文的说法"></a>～が，～けど 表示转折或者铺垫下文的说法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：すみませんが，今話してもいいでしょう。</span><br><span class="line">译：打扰一下，现在方便说话吗？</span><br><span class="line"></span><br><span class="line">例：李さんも日本語も上手ですけど，王さんも上手ですね。</span><br><span class="line">译：李桑日语说的很好，王桑也说的很好呀。</span><br></pre></td></tr></table></figure><h4 id="～わけには-もいきません-依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱"><a href="#～わけには-もいきません-依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱" class="headerlink" title="～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱"></a>～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：名字をつけないわけにはにいきません。</span><br><span class="line">译：不取名字是不行的。</span><br><span class="line"></span><br><span class="line">例：質問がたくさんあっても，無視するわけにもいかないので，きちんと答えています。</span><br><span class="line">译：即使问题有很多，也不能无视它，要好好地回答。</span><br></pre></td></tr></table></figure><h4 id="～といわれています-据说，通常认为，表示非说话人主观判断，而是一种普遍的常识"><a href="#～といわれています-据说，通常认为，表示非说话人主观判断，而是一种普遍的常识" class="headerlink" title="～といわれています　据说，通常认为，表示非说话人主观判断，而是一种普遍的常识"></a>～といわれています　据说，通常认为，表示非说话人主观判断，而是一种普遍的常识</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。</span><br><span class="line">译：日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。</span><br></pre></td></tr></table></figure><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li>佐藤：よろしくお願いします。李さんも日本語が上手ですけど，王さんも上手です。</li><li>王：ありがとうございます。出身は浙江省の紹興ですが，大学時代，日本に留学していたんです。ですから，今回のプロジェクトに大変興味があります。</li><li>佐藤：紹興ですか，１０年前に，一度だけ行ったことがあります。</li><li>王：そうでうか。</li><li>佐藤：ええ。私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">佐藤：请多关照。李桑日语说的很好，王桑也说的很好呀。</span><br><span class="line">王：谢谢夸奖。出生于浙江绍兴，大学地时候，去日本留学过。所以对这次地项目非常地有兴趣。</span><br><span class="line">佐藤：绍兴吗，10年前，去过一次呀。</span><br><span class="line">王：是吗？</span><br><span class="line">佐藤：是的呢。对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。</span><br></pre></td></tr></table></figure><h3 id="课文-2"><a href="#课文-2" class="headerlink" title="课文"></a>课文</h3><p>しかし，名字をつけないわけにはいきません。そこで，多くの人が，地名や地形から名字をつけましら。日本の名字に，『木』，『林』，『山』，『川』など自然に関係する名字が多いのは，そのためです。家が谷の中にあるから『中谷』，近くに大きな杉の木があるから『大杉』とつけられた名字もたくさんあります。日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。</p><blockquote><p>但是不取名字是不行的。所以大多数人的名字是来源于地名或地形。因此日本的名字中，『木』，『林』，『山』，『川』等等和自然有关的名字很多。家住在山谷中就叫『中谷』，附近有巨大的杉树就叫『大杉』这样的名字也有很多。日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。</p></blockquote><h2 id="第４課"><a href="#第４課" class="headerlink" title="第４課"></a>第４課</h2><h3 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h3><h4 id="信息的转述"><a href="#信息的转述" class="headerlink" title="信息的转述"></a>信息的转述</h4><ol><li>简体＋そうです</li></ol><ul><li>转述他人信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：李さんは明日会社を休むそうです。</span><br><span class="line">译：李桑明天休假。</span><br></pre></td></tr></table></figure><ul><li>听说传闻</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼女はもうすぐ結婚するそうです。</span><br><span class="line">译：她好像马上要结婚了。</span><br></pre></td></tr></table></figure><ul><li>样态，似乎、好像、看起来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この葡萄が美味しそうです。</span><br><span class="line">译：这个葡萄看起来很好吃的样子。</span><br></pre></td></tr></table></figure><ol start="2"><li>～とのことです、～ということです 听说，据说</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：このダムには３メートルくらいの魚がいるということです。</span><br><span class="line">译：听说这个水坝有3米长的鱼。</span><br><span class="line"></span><br><span class="line">例：山田さんがよろしくとのことです。</span><br><span class="line">译：听说山田人很好。</span><br></pre></td></tr></table></figure><ol start="3"><li>～といってもいました 记得说过，或者用于确认对方说的话</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：青木主任がちょっとお話しをしたいと言っていました。</span><br><span class="line">译：青木主任想和你说几句话。</span><br></pre></td></tr></table></figure><ol start="4"><li>简体＋って 与家人、朋友等亲密的人表示传闻，可以替换～と，～とは，～という人は</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日は雨だって。</span><br><span class="line">译：明天有雨。</span><br></pre></td></tr></table></figure><h4 id="思ったより-超出预想水平或范围"><a href="#思ったより-超出预想水平或范围" class="headerlink" title="思ったより 超出预想水平或范围"></a>思ったより 超出预想水平或范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：思ったより大変な仕事になりそうなんです。</span><br><span class="line">译：工作变得超乎想象的辛苦呢。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：予想以上に/想像以上に 比より更加正式程度也更强一些</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：今月の給料は予想以上に少なくて，がっかりしました。</span><br><span class="line">译：这个月的工资比预想的少多了，很失望。</span><br><span class="line"></span><br><span class="line">例：上海の変化は想像以上に速いですね。</span><br><span class="line">译：上海的变化比预想的还要快呀。</span><br></pre></td></tr></table></figure><h4 id="～といえば-说道-用于把名词作为话题提出，对话题进行说明"><a href="#～といえば-说道-用于把名词作为话题提出，对话题进行说明" class="headerlink" title="～といえば　说道~ 用于把名词作为话题提出，对话题进行说明"></a>～といえば　说道~ 用于把名词作为话题提出，对话题进行说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：かつて，日本のサラリーマンといえば，朝早く家を出て家に帰るのは深夜になり，残業や休日出勤をするのは当たり前でした。</span><br><span class="line">译：以前说到日本的上班族，很早出门深夜回家，加班和周末上班是理所应当的。</span><br></pre></td></tr></table></figure><h4 id="このように-综上所述"><a href="#このように-综上所述" class="headerlink" title="このように 综上所述"></a>このように 综上所述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このように，日本のサラリーマンの働き方は，かつてに比べると大きく変化しています。</span><br><span class="line">译：综上所述，日本的上班族的工作方式对比之前有了很大变化。</span><br></pre></td></tr></table></figure><h3 id="会话-1"><a href="#会话-1" class="headerlink" title="会话"></a>会话</h3><ul><li>青木：お忙しいところすみません。実は，上海支社で進めている『金星』プロジェクトが，思ったより大変な仕事になりそうなんです。</li><li>山田：そうですか。</li><li>青木：それで，東京本社でも『金星』プロジェクトの担当者を決めることになりました。突然ですが，山田さん，この仕事をしてもらえませんか。</li><li>山田：私が『金星』プロジェクトの担当者に？</li><li>青木：はい。上海支社の李さんからの要望なんです。</li><li>山田：李さんが，私を推薦してくれたんですか。</li><li>青木：ええ。山田さんは上海支社に行ったこともあるし，中国の事情に詳しいからということでした。</li><li>山田：分かりました。中国と関係のある仕事なら，ぜひやってみたいと思います。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">青木：这忙还打扰你。实际上上海分公司正在推进的金星项目，变得比预想还要麻烦呢。</span><br><span class="line">山田：是这样吗？</span><br><span class="line">青木：所以，东京总公司决定了金星项目的负责人。虽然有些突然，山田桑，这份工作你愿意接受吗？</span><br><span class="line">山田：我担任金星项目的负责人吗？</span><br><span class="line">青木：是的。上海分公司的李桑推荐的。</span><br><span class="line">山田：李桑推荐的我吗？</span><br><span class="line">青木：是的呢。山田桑去过上海分公司，对中国的事情也很了解。</span><br><span class="line">山田：我知道了。和中国有关系的工作，请一定要让我试试。</span><br></pre></td></tr></table></figure><h3 id="课文-3"><a href="#课文-3" class="headerlink" title="课文"></a>课文</h3><p>さらに，フレックスタイム制度を導入する会社も増えています。これは，自分の出勤と退勤の時間を自由に決められる制度です。労働者が自分の生活と仕事のバランスを取りながら，働くことができるように設けられました。</p><blockquote><p>另外，引入弹性时间制度的公司也增加了不少。这是项可以自己自由决定上班和下班时间的制度。这个是为劳动者既能平衡自己的生活和工作，也能工作所设计的。</p></blockquote><h1 id="単元-1"><a href="#単元-1" class="headerlink" title="単元"></a>単元</h1><h2 id="第５課"><a href="#第５課" class="headerlink" title="第５課"></a>第５課</h2><h3 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h3><h4 id="转换话题"><a href="#转换话题" class="headerlink" title="转换话题"></a>转换话题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ところで　         话说回来</span><br><span class="line">話しが変わりますが　说点别的</span><br><span class="line">さて　             那么</span><br><span class="line">それで　           然后</span><br><span class="line">けれども/でも　     不过/但是</span><br><span class="line">それでは/では　     那么（转换下一个话题）</span><br><span class="line">それはそうと　      先不说这个</span><br></pre></td></tr></table></figure><h4 id="～を～にして-以……为……"><a href="#～を～にして-以……为……" class="headerlink" title="～を～にして　以……为……"></a>～を～にして　以……为……</h4><ol><li>～をきっかけにして 以……为契机</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：コンテストで最高賞を受賞したのをきっかけにして，売れるようになりました。</span><br><span class="line">译：再一次竞赛后得到最高奖为契机，变得开始畅销。</span><br></pre></td></tr></table></figure><ol start="2"><li>～を手がかりにして 以……为线索</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：犯人が残したナイフを手がかりにして，事件を解決した。</span><br><span class="line">译：以犯人留下的小刀为线索，将事件解决了。</span><br></pre></td></tr></table></figure><ol start="3"><li>～を頼りにして　根据……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：李さんが書いてくれた地図を頼りにして，美術館を探した。</span><br><span class="line">译：我根据李桑画的地图找到了美术馆。</span><br></pre></td></tr></table></figure><h4 id="～ということからきた～-～に由来した～-由此而来的，源于"><a href="#～ということからきた～-～に由来した～-由此而来的，源于" class="headerlink" title="～ということからきた～/～に由来した～　由此而来的，源于"></a>～ということからきた～/～に由来した～　由此而来的，源于</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：相撲でぐらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。</span><br><span class="line">译：相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。</span><br><span class="line"></span><br><span class="line">例：『天ぷら』はボルトガル語の”tempera”に由来した言葉です。</span><br><span class="line">译：『天妇罗』的由来时葡萄牙语的“tempera”一词。</span><br></pre></td></tr></table></figure><h4 id="～のは間違いない-一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用"><a href="#～のは間違いない-一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用" class="headerlink" title="～のは間違いない　一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用"></a>～のは間違いない　一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：中国の体操選手がオリンピックで優勝するのは間違いない。</span><br><span class="line">译：中国的体操选手一定会在奥林匹克上获胜。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：～に違いない/～に相違ない（书面） 能和 <strong>きっと 多分</strong> 这样的词语一起使用 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：このガイドブックは内容が豊富で面白い。きっと売れるに違いない。</span><br><span class="line">译：这本指南的内容丰富有趣。一定买的很好。</span><br><span class="line"></span><br><span class="line">例：彼は十分な休みを取っていなかったに相違ない。</span><br><span class="line">译：他一定没有得到充分的休息。</span><br></pre></td></tr></table></figure><h4 id="～という点から-で-从……方面来"><a href="#～という点から-で-从……方面来" class="headerlink" title="～という点から/で　从……方面来"></a>～という点から/で　从……方面来</h4><ol><li>という点から分類する　从……方面来分类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語の単語を，元の言葉は何かという点から分類すると，……</span><br><span class="line">译：日语的单词是以它原来的语言是什么这一点来分类的。</span><br></pre></td></tr></table></figure><ol start="2"><li>という点から判断する 从……方面来判断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いろいろな証拠という点から判断するんですが，彼は犯人です。</span><br><span class="line">译：各种各样的证据判断出，他是犯人。</span><br></pre></td></tr></table></figure><ol start="3"><li>という点で　依据……性质来判断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：遅くまで開いているという点で，あの店は便利です。</span><br><span class="line">译：营业到很晚这一点来看，那家店很便利。</span><br></pre></td></tr></table></figure><h4 id="～を中心とした～-以……为中心"><a href="#～を中心とした～-以……为中心" class="headerlink" title="～を中心とした～　以……为中心"></a>～を中心とした～　以……为中心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉だ。</span><br><span class="line">译：外来语主要是19世纪以后，以西洋为中心的外国引进的语言。</span><br></pre></td></tr></table></figure><h4 id="AをBという-呼ぶ（书面）-把A叫做B"><a href="#AをBという-呼ぶ（书面）-把A叫做B" class="headerlink" title="AをBという/呼ぶ（书面）　把A叫做B"></a>AをBという/呼ぶ（书面）　把A叫做B</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。</span><br><span class="line">译：另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。</span><br></pre></td></tr></table></figure><h4 id="名词＋の-形容动词-な-简体＋ような（名词）-ように（动词）-像是……，类似……"><a href="#名词＋の-形容动词-な-简体＋ような（名词）-ように（动词）-像是……，类似……" class="headerlink" title="名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……"></a>名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：東京のような大都市では，家賃が高くて大変だ。</span><br><span class="line">译：像东京这样的大城市，房租太高了太不容易了。</span><br><span class="line"></span><br><span class="line">例：鳥が飛ぶように空を飛んでみたい。</span><br><span class="line">译：想像鸟一样在空中飞行。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><blockquote><p>～という/いったよう＋な/に　列举多个例子时使用，いった有<strong>没有列举完</strong>的语气，といったような可以省略为といった</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：エビ，イカ，卵といったようなコレステロの高い食品は避けた穂がいい。</span><br><span class="line">译：避免高胆固醇食物，如虾、鱿鱼和鸡蛋。</span><br><span class="line"></span><br><span class="line">例：テレビ，冷蔵庫，布団というように，一人暮らしで必要な物を買った。</span><br><span class="line">译：我买了一个人生活必需的东西，比如电视、冰箱和被褥。</span><br></pre></td></tr></table></figure><blockquote><p>～というふうな/に　用于列举多个具体事例，陈述处理办法或顺序，略显口语</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：北京，上海，広州というふうに，中国の大きな都市を順番に訪問した。</span><br><span class="line">译：我们依次参观了中国的大城市，如北京、上海和广州。</span><br></pre></td></tr></table></figure><h4 id="～に受ける-受欢迎"><a href="#～に受ける-受欢迎" class="headerlink" title="～に受ける　受欢迎"></a>～に受ける　受欢迎</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『金星』という名前は，中国人にうけるでしょう。</span><br><span class="line">译：金星这个名字，中国人会喜欢吧？</span><br></pre></td></tr></table></figure><h4 id="～に基づいた～-以……为根据"><a href="#～に基づいた～-以……为根据" class="headerlink" title="～に基づいた～　以……为根据"></a>～に基づいた～　以……为根据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：音読みとは，昔の中国語の発音に基づいた読み方だ。</span><br><span class="line">译：音读是指以以前中文的发音为根据的读法。</span><br></pre></td></tr></table></figure><h4 id="うち-在……当中"><a href="#うち-在……当中" class="headerlink" title="~うち　在……当中"></a>~うち　在……当中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：若いうち</span><br><span class="line">译：趁着年轻</span><br><span class="line"></span><br><span class="line">例：参加者のうち，賞品がもらえるのは３位までだ。</span><br><span class="line">译：参加人中，能得到奖品的只有三位。</span><br></pre></td></tr></table></figure><h3 id="会话-2"><a href="#会话-2" class="headerlink" title="会话"></a>会话</h3><ul><li>佐藤：ええ，『金星』は星の名前ですが，『金星』というのは，『すばらしい働きをすること』を表します。相撲でくらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">佐藤：『金星』是指星星的名字，这里的金星是指，有着出色工作表现的意思。相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。</span><br></pre></td></tr></table></figure><h3 id="课文-4"><a href="#课文-4" class="headerlink" title="课文"></a>课文</h3><p>日本の単語を，元の言葉は何かという点から分類すると，和語，漢語，外来語，混種語の４つに分かることができる。和語はもともと日本語にあった言葉で，漢語は中国から取り入れられた言葉だ。<br>漢語は『音読み』する。音読みとは，昔の中国の発音に基いた読み方だ。外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉で，普通片仮名でかく。<br>さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。『消しゴム』や『マラソン大会』『正月休み』などの言葉だ。</p><blockquote><p>日语的单词是以它原来的语言是什么这一点来分类的。可以分为和语、汉语、外来语、混合语四种。和语是最早日语就有的语言，汉语是从中国引入的语言。<br>汉语是音读。所谓的音读是指以以前中文的发音为根据的读法。外来语主要是19世纪以后，以西洋为中心的外国引进的语言，用普通片假名书写。<br>另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。诸如“橡皮擦”、“马拉松比赛”和“新年假期”之类的词。</p></blockquote><h2 id="第６課"><a href="#第６課" class="headerlink" title="第６課"></a>第６課</h2><h3 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h3><h4 id="～ちゃって-～じゃって-是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。"><a href="#～ちゃって-～じゃって-是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。" class="headerlink" title="～ちゃって/～じゃって　是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。"></a>～ちゃって/～じゃって　是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">食べてしまう　ー＞　食べちゃう　ー＞　食べちゃって</span><br><span class="line">飲んでしまう　ー＞　飲んでじゃう　ー＞　飲んでじゃって</span><br><span class="line"></span><br><span class="line">例：打ち合わせが長引いちゃって。</span><br><span class="line">译：会议拖了很长时间。</span><br></pre></td></tr></table></figure><h4 id="気になる-一直想着……-对某人有意思"><a href="#気になる-一直想着……-对某人有意思" class="headerlink" title="気になる 一直想着…… 对某人有意思"></a>気になる 一直想着…… 对某人有意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そんなことを聞くということは，佐藤さん，李さんのことが気になるのかしら。</span><br><span class="line">译：听到这样的话，佐藤桑，你是不是对李桑有意思呀。</span><br></pre></td></tr></table></figure><h4 id="～による-よって-根据……"><a href="#～による-よって-根据……" class="headerlink" title="～による/よって　根据……"></a>～による/よって　根据……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『はし』といっても，その形や材料は国や地域によって違う。</span><br><span class="line">译：虽说都是筷子，它的形态和材料会因为国家和地区而不同。</span><br></pre></td></tr></table></figure><h4 id="簡体＋といっても-虽说……"><a href="#簡体＋といっても-虽说……" class="headerlink" title="簡体＋といっても 虽说……"></a>簡体＋といっても 虽说……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：英語できないといっても，日常会話は十分にできる。</span><br><span class="line">译：虽说英语不行，但是日常对话应该够了。</span><br></pre></td></tr></table></figure><h4 id="簡体／名詞の＋ほか，～も-除了……之外，也……"><a href="#簡体／名詞の＋ほか，～も-除了……之外，也……" class="headerlink" title="簡体／名詞の＋ほか，～も 除了……之外，也……"></a>簡体／名詞の＋ほか，～も 除了……之外，也……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：材料は木や竹，プラスチックのほか，玉や金属の物もある。</span><br><span class="line">译：材料是木头或竹子，除了塑料以外，也有玉和金属的。</span><br></pre></td></tr></table></figure><h4 id="～をしている-状态的表示方法"><a href="#～をしている-状态的表示方法" class="headerlink" title="～をしている 状态的表示方法"></a>～をしている 状态的表示方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：韓国の箸は中国より少し短く，やや平らな形をしている。</span><br><span class="line">译：韩国的筷子比中国的短了一些，也要扁平一些。</span><br></pre></td></tr></table></figure><h4 id="～とされる-和-と考えられている-意思一样：被认为是……"><a href="#～とされる-和-と考えられている-意思一样：被认为是……" class="headerlink" title="～とされる 和 と考えられている 意思一样：被认为是……"></a>～とされる 和 と考えられている 意思一样：被认为是……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本では２月１４日のバレンタインデーは，女性が男性にチョコレートを贈る日だとされる。</span><br><span class="line">译：在日本2月14日情人节被认为是女性向男性赠送巧克力的日子。</span><br></pre></td></tr></table></figure><h4 id="面倒を見る-照顾"><a href="#面倒を見る-照顾" class="headerlink" title="面倒を見る　照顾"></a>面倒を見る　照顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：部下の面倒をよくみるし。</span><br><span class="line">译：很照顾自己的下属。</span><br></pre></td></tr></table></figure><h3 id="会话-3"><a href="#会话-3" class="headerlink" title="会话"></a>会话</h3><ul><li>中井さん：うん。明るくて，仕事熱心な人だっていったよ。部下の面倒をよく見るし，優しいし，まさに理想的な上司です。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中井桑：是的。人很开朗，对工作也很热心的人呢。对下属也很照顾，人也温柔，简直是理想的上司呢。</span><br></pre></td></tr></table></figure><h3 id="课文-5"><a href="#课文-5" class="headerlink" title="课文"></a>课文</h3><p>『はし』といっても，その形や材料は国や地域によって違う。中国の箸は長くて，先端が丸太さがあまり変わらない。材料は木や竹，プラスチックのほか，玉や金属の物もある。<br>韓国の箸は中国より少し短く，やや平らな形をしている。ステンレスなど，金属の物が一般的だ。<br>日本の箸は韓国の物に比べてさらに短く，先のほうは細くなっていて，尖っている。材質は木や竹が多く，漆が塗られていることがある。</p><blockquote><p>虽说都是筷子，它的形态和材料会因为国家和地区而不同。中国的筷子比较长，筷子前端的圆度没怎么变化。材料是木头或竹子，除了塑料以外，也有玉和金属的。<br>韩国的筷子比中国的短了一些，也要扁平一些。一般是不锈钢之类的金属。<br>日本的筷子相比韩国要短一些，前者很细很尖。材质大多数是木头或竹子，也有在表面涂漆的。</p></blockquote><h2 id="第７課"><a href="#第７課" class="headerlink" title="第７課"></a>第７課</h2><h3 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h3><h4 id="簡体＋参考にする-参考になる-把……作为参考-有参考价值"><a href="#簡体＋参考にする-参考になる-把……作为参考-有参考价值" class="headerlink" title="簡体＋参考にする/参考になる 把……作为参考/有参考价值"></a>簡体＋参考にする/参考になる 把……作为参考/有参考价值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：『燕醸造のCMを参考にする』と書いてあるけど，これはどいう意味？</span><br><span class="line">译：上面写着『燕牌啤酒的广告有参考价值』，这是什么意思呢？</span><br><span class="line"></span><br><span class="line">例：このCMは，きっと参考になるだろうと思います。</span><br><span class="line">译：这个广告一定有参考价值。</span><br></pre></td></tr></table></figure><h4 id="名詞の＋うえで-这……方面"><a href="#名詞の＋うえで-这……方面" class="headerlink" title="名詞の＋うえで 这……方面"></a>名詞の＋うえで 这……方面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ただし，仕事のうえでのメールや目上の人に送る場合は，いくつか気をつけなければならないことがある。</span><br><span class="line">译：然而工作上的邮件和发送给上级的场合下，有一些必须注意事项。</span><br></pre></td></tr></table></figure><h4 id="名词-さえ～ば，～-只要……就……"><a href="#名词-さえ～ば，～-只要……就……" class="headerlink" title="名词+さえ～ば，～ 只要……就……"></a>名词+さえ～ば，～ 只要……就……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お金と時間さえあれば，毎日演劇を見に行きたい。</span><br><span class="line">译：只要有钱和时间，每天都想去剧院。</span><br></pre></td></tr></table></figure><h4 id="～などという-这……之类的"><a href="#～などという-这……之类的" class="headerlink" title="～などという 这……之类的"></a>～などという 这……之类的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『こんにちは』『はじめまして』などという，メールの内容の分からない表現は避ける。</span><br><span class="line">译：邮件内容要避免『你好』『初次见面』之类的无法理解内容的表达方式。</span><br></pre></td></tr></table></figure><h4 id="～ごとに-表示每隔……（间隔）"><a href="#～ごとに-表示每隔……（间隔）" class="headerlink" title="～ごとに　表示每隔……（间隔）"></a>～ごとに　表示每隔……（间隔）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：１年ごとに，売り上げの目標作って，営業活動を頑張った。</span><br><span class="line">译：每年都会指定销售目标，努力开展营业活动。</span><br></pre></td></tr></table></figure><h3 id="课文-6"><a href="#课文-6" class="headerlink" title="课文"></a>课文</h3><p>件名を描く時は，用件を明確にする</p><p>宛て先と自分の名前を忘れずに入れる</p><p>用件は簡潔にする</p><p>最後に署名を入れる</p><blockquote><p>描述主题时，用词要明确<br>不要忘记写收件人和自己的名字<br>用词要简洁<br>最后要署上你的名字</p></blockquote><h2 id="第８課"><a href="#第８課" class="headerlink" title="第８課"></a>第８課</h2><h3 id="文法-7"><a href="#文法-7" class="headerlink" title="文法"></a>文法</h3><h4 id="だけ-仅仅"><a href="#だけ-仅仅" class="headerlink" title="だけ　仅仅"></a>だけ　仅仅</h4><ol><li>だけで　少量的事情或者事物就能引发后项结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと見ただけで，本物だとわかります。</span><br><span class="line">译：仅仅只是看了一眼，就知道是真的。</span><br></pre></td></tr></table></figure><ol start="2"><li>だけだ／だけではない　仅此/不仅</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そのだけです。</span><br><span class="line">译：仅此而已。</span><br><span class="line"></span><br><span class="line">例：中井さんは事件あった場所を知っているだけだ。</span><br><span class="line">译：田中桑仅仅只是知道发生时间的场所。</span><br></pre></td></tr></table></figure><ol start="3"><li>だけではすまない／だけですむ　仅仅这样是不行的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：課長に報告したら，注意されるだけではさまない。</span><br><span class="line">译：向课长报告的话，仅仅是注意是不行的。</span><br></pre></td></tr></table></figure><h4 id="～代わりに／～かわって／～に代わる-……被代替……"><a href="#～代わりに／～かわって／～に代わる-……被代替……" class="headerlink" title="～代わりに／～かわって／～に代わる　……被代替……"></a>～代わりに／～かわって／～に代わる　……被代替……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：相手は丼を使う代わりに紙コップを使い，その中に砕いたインスタントラーメンを入れる，お湯を注いで，食べ始めた。</span><br><span class="line">译：对方使用纸杯代替碗，在纸杯中放入碎的方便面，再放入开水，就可以开始吃了。</span><br><span class="line"></span><br><span class="line">例：手紙の代わりに電子メールをうちます。</span><br><span class="line">译：发送电子邮件代替信件。</span><br><span class="line"></span><br><span class="line">例：父に代わって長男がご挨拶に伺います。</span><br><span class="line">译：长子代替父亲前来问候。</span><br><span class="line"></span><br><span class="line">例：丼に代わる新しい容器が必要だ。</span><br><span class="line">译：使用新容器代替是有必要的。</span><br></pre></td></tr></table></figure><h4 id="～（ら）れるようにしなければいけない-努力做到"><a href="#～（ら）れるようにしなければいけない-努力做到" class="headerlink" title="～（ら）れるようにしなければいけない　努力做到"></a>～（ら）れるようにしなければいけない　努力做到</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：免許証はいつでも見せられるようにしなければいけない。</span><br><span class="line">译：驾照无论何时都需要能看到。</span><br></pre></td></tr></table></figure><h4 id="～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果"><a href="#～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果" class="headerlink" title="～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果"></a>～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：何度も失敗した末に，ようやく開発に成功した。</span><br><span class="line">译：经历无数次失败，最终成功开发出来。</span><br><span class="line"></span><br><span class="line">例：苦労したあげく，結局失敗した。</span><br><span class="line">译：辛苦的工作到最后还是失败了。</span><br></pre></td></tr></table></figure><h3 id="会話"><a href="#会話" class="headerlink" title="会話"></a>会話</h3><ul><li>王：はい。商品のPRだけじゃなくて，日本の文化を紹介するコーナーを作ってはどうかと考えています。日本の食べ物とか若者の意識とかを紹介するのも面白いとおもいます。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">王：是的。这不仅是商品的提案，我想做一个介绍日本文化的栏目。介绍日本的饮食什么的，年轻人的想法什么的都很有趣。</span><br></pre></td></tr></table></figure><h3 id="课文-7"><a href="#课文-7" class="headerlink" title="课文"></a>课文</h3><p>しかし，開発は簡単ではなかった。容器の材料は，ガラス，紙，プラスチック，金属，当時考えられるだけの物が集められた。様々な工夫のすえ，『発泡スチロール』が採用された。容器の形についても試作が繰り返された。片手を持てて，手から滑り落ちない形を理想として，現在の形が生まれた。</p><blockquote><p>然而，开发不是这么简单的。容器的材料有不锈钢、纸、塑料、金属，这些都是当时能想到的汇聚起来的东西。通过各种各样的方式方法，最终采用了泡沫塑料。关于容器的形状也多次尝试制作。以单手就能拿起，不容易从手中滑落为理想，诞生了现在的形状。</p></blockquote><h1 id="単元-2"><a href="#単元-2" class="headerlink" title="単元"></a>単元</h1><h2 id="第９課"><a href="#第９課" class="headerlink" title="第９課"></a>第９課</h2><h3 id="文法-8"><a href="#文法-8" class="headerlink" title="文法"></a>文法</h3><h4 id="自动词-てある-人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态"><a href="#自动词-てある-人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态" class="headerlink" title="自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态"></a>自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：「王風」という名札が付けてあります。</span><br><span class="line">译：上面挂有【王风】名字的牌子。</span><br><span class="line"></span><br><span class="line">例：玄関の電気がつけてあります。</span><br><span class="line">译：玄关的灯开着。</span><br></pre></td></tr></table></figure><h4 id="他动词-ている-自然状态持续着"><a href="#他动词-ている-自然状态持续着" class="headerlink" title="他动词 + ている 自然状态持续着"></a>他动词 + ている 自然状态持续着</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：窓が開けています。</span><br><span class="line">译：窗户开着。</span><br><span class="line"></span><br><span class="line">例：窓が開けてあります。</span><br><span class="line">译：窗户打开着。</span><br></pre></td></tr></table></figure><h4 id="自动词-ておく-有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。"><a href="#自动词-ておく-有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。" class="headerlink" title="自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。"></a>自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：ファイルは机の上に置いておきます。</span><br><span class="line">译：我把文件反正桌子上。</span><br><span class="line"></span><br><span class="line">例：朝起きられるように、時計を6時にセットしておく。</span><br><span class="line">译：为了能早起，我定了6点的闹钟。</span><br></pre></td></tr></table></figure><h4 id="名词-どおり-与～一样；按照～那样；预想；预计"><a href="#名词-どおり-与～一样；按照～那样；预想；预计" class="headerlink" title="名词 + どおり 与～一样；按照～那样；预想；预计"></a>名词 + どおり 与～一样；按照～那样；预想；预计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：予定通り17時30分に到着いたしましたが…</span><br><span class="line">译：和预计的一样17点30分到达了……</span><br><span class="line"></span><br><span class="line">例：田中さんは、希望通り大学院に進学しました。</span><br><span class="line">译：田中如愿升入研究生院。</span><br></pre></td></tr></table></figure><h4 id="後ほど；後（のち）で；あとで-前者更有礼貌"><a href="#後ほど；後（のち）で；あとで-前者更有礼貌" class="headerlink" title="後ほど；後（のち）で；あとで 前者更有礼貌"></a>後ほど；後（のち）で；あとで 前者更有礼貌</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：後ほど，お泊まりのホテルに届けいたします。</span><br><span class="line">译：稍后送到您住宿的酒店。</span><br><span class="line"></span><br><span class="line">例：詳細については後ほどご報告いたします。</span><br><span class="line">译：详细情况稍后汇报给您。</span><br></pre></td></tr></table></figure><blockquote><p>另外还有 先ほど</p></blockquote><h3 id="会话-4"><a href="#会话-4" class="headerlink" title="会话"></a>会话</h3><ul><li><p>王さん：ちょっと，いたい，いつまでも待ってばいいんですか。もう６時半ですよ。</p></li><li><p>手荷物係：申し訳ございません。ただ今お調べしております。もう少しお待ちいただけませんか。</p></li><li><p>王さん：そんな，困りますよ。ロビーで同僚が待っているんです。早くしてもらえませんか。</p></li><li><p>手荷物係：本当に申し訳ございません。後ほど，お泊まりのホテルに届けいたします。よろしいでしょうか。</p></li><li><p>王さん：仕方ないですね。できるだけ早く届けてくださいよ。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">王桑：喂，究竟要让我等到多久才好呀？已经6点半了呀！</span><br><span class="line">行李员：真的十分抱歉！但是现在还在调查中，请在稍等一下可以吗？</span><br><span class="line"></span><br><span class="line">王桑：怎么会这样，太麻烦了。前厅还有同事在等着我。能尽快找到还给我吗？</span><br><span class="line">行李员：真的非常抱歉，稍后送到您住宿的酒店，这样您觉得可以吗？</span><br><span class="line"></span><br><span class="line">王桑：只好这样了。快点送过来呀！</span><br></pre></td></tr></table></figure><h3 id="课文-8"><a href="#课文-8" class="headerlink" title="课文"></a>课文</h3><p>4月1日17時20分，憧れのローマに到着。荷物を受け取って，入国。旅行社の人が迎えに来ているはずだが，見つからない。もし来なかったらと思い，不安になった時，背の高い男性が，にこにこしながら近付いてきて何か言う。誰かと思ったら，我々を迎えに来たガイドさんだった。</p><blockquote><p>4月1日17点20分，憧憬的罗马到了。取到了托运的行李，入国。因该有旅行社的人来接我们，但是没有看见。正在想着如果没有来的话怎么办，感到不安的时候，有个背高高的男性笑眯眯的走过来说着什么。我正在想着这是谁，原来是来迎接我们的导游。</p></blockquote><h2 id="第１０課"><a href="#第１０課" class="headerlink" title="第１０課"></a>第１０課</h2><h3 id="文法-9"><a href="#文法-9" class="headerlink" title="文法"></a>文法</h3><h4 id="よう（更为正式）／ように-目的，为了……"><a href="#よう（更为正式）／ように-目的，为了……" class="headerlink" title="よう（更为正式）／ように　目的，为了……"></a>よう（更为正式）／ように　目的，为了……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：できるだけたくさんの取材ができるよう予定を立てました。</span><br><span class="line">译：为了尽可能多的采访，我们定了这样的行程。</span><br><span class="line"></span><br><span class="line">例：早く病気がなおるよう、安静にしていた。</span><br><span class="line">译：为了病能早点好，静养了一段时间。</span><br></pre></td></tr></table></figure><h4 id="～による／よって"><a href="#～による／よって" class="headerlink" title="～による／よって"></a>～による／よって</h4><h5 id="被动中提示动作的主体"><a href="#被动中提示动作的主体" class="headerlink" title="被动中提示动作的主体."></a>被动中提示动作的主体.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このレストランは，有名なデザイナーによって設計された。</span><br><span class="line">译：这个饭店是有名的设计师设计的。</span><br></pre></td></tr></table></figure><h5 id="根据，依据"><a href="#根据，依据" class="headerlink" title="根据，依据"></a>根据，依据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：林さんが行くかどうかによって，私もどうするかきめます。</span><br><span class="line">译：小林去不去决定了我怎么完成。</span><br></pre></td></tr></table></figure><h5 id="方式，方法"><a href="#方式，方法" class="headerlink" title="方式，方法"></a>方式，方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この薬の効果は，多くの実験によって確認されている。</span><br><span class="line">译：这个药的效果是经过了多次实验才确认的。</span><br></pre></td></tr></table></figure><h4 id="～になります-代替です／だ，语气更加的含蓄，委婉。"><a href="#～になります-代替です／だ，语气更加的含蓄，委婉。" class="headerlink" title="～になります　代替です／だ，语气更加的含蓄，委婉。"></a>～になります　代替です／だ，语气更加的含蓄，委婉。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お１人様１６０００円になりますが，よろしいですか。</span><br><span class="line">译：一个人16000日元，您觉得可以吗？</span><br></pre></td></tr></table></figure><h3 id="课文-9"><a href="#课文-9" class="headerlink" title="课文"></a>课文</h3><p>温泉地では，お客を集めるための工夫をしている。例えば，宿泊する人以外がホテルや旅館の入浴施設を有料で使用できる「日帰り温泉」がある。<br>「入浴＋昼ご飯」や，「入浴＋部屋で休憩」など，宿泊する時間のない人のためにさまざまなプランもある。最近では「日帰り入浴」専用の施設も増えてきている。</p><p>また銭湯といって，安い値段で入浴できる施設もある。銭湯とは，多くの家にお風呂がなかったころに作られた入浴施設のことだ。現在ではその数も少なくなってきているが，最近では，「スーパー銭湯」が出てきて人気を集めている。普通の銭湯より値段は高いが，いろいろな種類のお風呂やマッサージ，エステなどがあり，1日中たのしめる。「スーパー銭湯」は忙しい人たちのちょっとした癒しの場になっているのだ。</p><blockquote><p>泡温泉的地方为了能揽客下了很大的功夫。比如，有住宿以外的人可以通过付费使用旅馆的入浴设施【日归温泉】。还有【温泉+晚饭】和【温泉+房间休息】等等，没有住宿时间的人也有各种各样的方案。最近【日归温泉】专用设置也增加了许多。</p></blockquote><blockquote><p>另外还有钱汤，价格实惠的洗浴设施也有。所谓钱汤是指，以前许多家里没有可以泡温泉的地方，而建立的公用洗浴设施。现在这样的设施在慢慢减少，最近出现了很有人气的超级钱汤。比普通的钱汤价格稍微贵一点，但是有各种各样的种类，洗浴，按摩以及美容，可以享受一整天。超级钱汤正在成为给那些忙碌人难得消除身心疲惫的场所。</p></blockquote><h2 id="第１１課"><a href="#第１１課" class="headerlink" title="第１１課"></a>第１１課</h2><h3 id="文法-10"><a href="#文法-10" class="headerlink" title="文法"></a>文法</h3><h4 id="避免断定的说法"><a href="#避免断定的说法" class="headerlink" title="避免断定的说法"></a>避免断定的说法</h4><ul><li>难道不是吗？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">书面语：</span><br><span class="line"></span><br><span class="line">ではないか</span><br><span class="line">ではないだろうか</span><br><span class="line">ではないでしょうか。</span><br><span class="line"></span><br><span class="line">口语：</span><br><span class="line"></span><br><span class="line">ではありませんか</span><br><span class="line">ではないですか</span><br><span class="line">じゃありませんか</span><br><span class="line">じゃないですか</span><br><span class="line">じゃないか</span><br></pre></td></tr></table></figure><ul><li>～きがする　好像，对过去的某事尽管记忆模糊，但是认为是那样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：その時は，賛成した気がします。</span><br><span class="line">译：那个时候我好像是赞成的。</span><br></pre></td></tr></table></figure><ul><li>～と思う／～と思える／～と思われる　认为，～と思える／～と思われる 有自然而然地这样认为，而非专断的意见</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：彼女の言っていることは事実だと思う。</span><br><span class="line">译：我觉得她说的话是事实。</span><br><span class="line"></span><br><span class="line">例：私はこの方針が正しいと思えません。</span><br><span class="line">译：我不觉得这个方针是正确的。</span><br></pre></td></tr></table></figure><h4 id="～はずです-应该是……，基于推论或记忆认为理所应当成立的事情"><a href="#～はずです-应该是……，基于推论或记忆认为理所应当成立的事情" class="headerlink" title="～はずです　应该是……，基于推论或记忆认为理所应当成立的事情"></a>～はずです　应该是……，基于推论或记忆认为理所应当成立的事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は今年定年のはずです。</span><br><span class="line">译：他今年应该退休了。</span><br></pre></td></tr></table></figure><h4 id="～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。"><a href="#～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。" class="headerlink" title="～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。"></a>～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あの雲の様子から見て，明日は雨のようだ。</span><br><span class="line">译：从那个云的样子来看，明天可能要下雨。</span><br><span class="line"></span><br><span class="line">例：天気予報によると，今年の冬は暖かいらしい。</span><br><span class="line">译：天气预报说今年冬天可能会比较暖和。</span><br></pre></td></tr></table></figure><h4 id="～のところ-……的时刻，有包含这个的后续可能会发生某种变化的语气"><a href="#～のところ-……的时刻，有包含这个的后续可能会发生某种变化的语气" class="headerlink" title="～のところ　……的时刻，有包含这个的后续可能会发生某种变化的语气"></a>～のところ　……的时刻，有包含这个的后续可能会发生某种变化的语气</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：興行成績は現在のところ第２位ですが，来週はトップになる見込みです。</span><br><span class="line">译：票房成绩目前还是第二名，但下周有可能登顶。</span><br></pre></td></tr></table></figure><h4 id="～見込みです-很可能，有希望的意思"><a href="#～見込みです-很可能，有希望的意思" class="headerlink" title="～見込みです　很可能，有希望的意思"></a>～見込みです　很可能，有希望的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：来年の業績はかなり良い見込みです。</span><br><span class="line">译：明年的业已有希望相当好。</span><br></pre></td></tr></table></figure><h4 id="形容词去掉い＋まる（自动词：变得）／める（他动词：使……）-古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语"><a href="#形容词去掉い＋まる（自动词：变得）／める（他动词：使……）-古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语" class="headerlink" title="形容词去掉い＋まる（自动词：变得）／める（他动词：使……）　古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语"></a>形容词去掉い＋まる（自动词：变得）／める（他动词：使……）　古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そうそう，日本映画の人気も高まっていますよ。</span><br><span class="line">译：是的呢，日本电影的人气也变得很高。</span><br><span class="line"></span><br><span class="line">例：社員一人一人の節約の意識を，もう少し高めないといけない。</span><br><span class="line">译：必须提高每个社员的节约意识。</span><br></pre></td></tr></table></figure><h4 id="～に夢中になる-被什么东西吸引而聚精会神投入其中的状态"><a href="#～に夢中になる-被什么东西吸引而聚精会神投入其中的状态" class="headerlink" title="～に夢中になる　被什么东西吸引而聚精会神投入其中的状态"></a>～に夢中になる　被什么东西吸引而聚精会神投入其中的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：昔の子供は学校が終われると，外で遊ぶに夢中になったものです。</span><br><span class="line">译：以前的小孩放学后，会沉迷在外面玩。</span><br></pre></td></tr></table></figure><blockquote><p>知识拓展</p></blockquote><ul><li>夢中になって 专心致志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。</span><br><span class="line">译：来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。</span><br></pre></td></tr></table></figure><ul><li>夢中で/夢中だ　拼命的做</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：田中さんは今日仕事に夢中だから，しばらく結婚はしないでしょう。</span><br><span class="line">译：看田中桑今天拼命的工作，最近一段时间应该不会结婚吧？</span><br><span class="line"></span><br><span class="line">例：大きな犬に追いかけられて，夢中で逃げだ。</span><br><span class="line">译：被大型犬着，拼命地逃跑。</span><br></pre></td></tr></table></figure><h4 id="～うえに，～-不仅……而且……"><a href="#～うえに，～-不仅……而且……" class="headerlink" title="～うえに，～　不仅……而且……"></a>～うえに，～　不仅……而且……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日は気温が低いうえに，風が強いので，とても寒く感じる。</span><br><span class="line">译：今天不仅气温低风也很大，感觉非常冷啊。</span><br></pre></td></tr></table></figure><h4 id="～とともに，～-随着前向的变化，后向也因此伴随着变化，也有同时进行的意思"><a href="#～とともに，～-随着前向的变化，后向也因此伴随着变化，也有同时进行的意思" class="headerlink" title="～とともに，～　随着前向的变化，后向也因此伴随着变化，也有同时进行的意思"></a>～とともに，～　随着前向的变化，后向也因此伴随着变化，也有同时进行的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：その後，デジタル技術の開発が進むとともに，高画質のいきいきとした映像が生み出されるようになった。</span><br><span class="line">译：之后，随着数字技术的开发，产生了高画质的生动影像。</span><br><span class="line"></span><br><span class="line">例：原因を調査するとともに，再発を防ぐための努力もしていかなければならない。</span><br><span class="line">译：随着原因的调查，为了防止再次发生而不得不努力。</span><br></pre></td></tr></table></figure><h3 id="会話-1"><a href="#会話-1" class="headerlink" title="会話"></a>会話</h3><ul><li><p>担当者：ええ，若者は日本のものと外国のものを区別していないような気がします。彼らは，映画にしても音楽にしても，いいものならすぐに受け入れます。</p></li><li><p>王：そうですね。中国の若者も同じだという気がします。じゃあ，彼らの心をつかむには，どうすればいいんでしょうか。</p></li><li><p>担当者：うーん…，難しい質問ですね。やはり本当にいいものを作ることではないでしょうか。</p></li><li><p>王：本当にいいもの，ですか？</p></li><li><p>担当者：ええ。今の若者は，テレビCMより，同時代の人の口コミを信じます。映像でも音楽でも，本当にいいものを提供すれば，口コミで広がっていくはずです。</p></li><li><p>王：なるほど。ありがとうございます。とても参考になりました。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">担当者：是的，我觉得年轻人好像没有区分日本的东西和外国的东西。他们不管是电影还是音乐，只要是觉得好的马上就会接受。</span><br><span class="line">王：是这样呢，中国的年轻人好像也是这样。那么怎么做才能抓住他们的心呢？</span><br><span class="line"></span><br><span class="line">担当者：嗯，很难得问题呀。果然还是要真正做出好的东西对吧？</span><br><span class="line">王：真的好的东西，是吗？</span><br><span class="line"></span><br><span class="line">担当者：是的。现今的年轻人比起电视频道更相信同龄人的口碑。不管是电影还是音乐，提供真正好的东西的话，口碑应该也会越来越好。</span><br><span class="line">王：原来如此，谢谢。非常有参考价值。</span><br></pre></td></tr></table></figure><h3 id="课文-10"><a href="#课文-10" class="headerlink" title="课文"></a>课文</h3><p>日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。日本の漫画は，子供向けから成人向けまで，対象の年代ごとにさまざまな種類がある。</p><p>会社員の生活や，経済に関するものなど，大人にしか楽しめない内容の漫画が多くある。一方，子供向けの漫画でも，大人が楽しめるものも多い。近年，中国では「クレヨンしんちゃん」「ドラえもん」「ちびまる子ちゃん」などの漫画が子供だけでなく大人からも人気を集めている。</p><blockquote><p>来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。日本的漫画从孩子到成人，会因为看漫画对象的年代不同有着各种各样的分类。</p></blockquote><blockquote><p>公司职员的生活或者经济相关的漫画等等，有很多精彩的内容只有大人才能看的漫画有很多。另一方面，也有很多小孩子和大人都能看得的漫画。近几年，在中国像【蜡笔小新】、【哆啦A梦】【樱桃小丸子】等等这样的漫画不仅小孩子喜欢，也很受大人们的欢迎。</p></blockquote><h2 id="第１２課"><a href="#第１２課" class="headerlink" title="第１２課"></a>第１２課</h2><h3 id="文法-11"><a href="#文法-11" class="headerlink" title="文法"></a>文法</h3><h4 id="耳にする／目にする-表示没主动去看听，而是被动传入"><a href="#耳にする／目にする-表示没主动去看听，而是被动传入" class="headerlink" title="耳にする／目にする　表示没主动去看听，而是被动传入"></a>耳にする／目にする　表示没主动去看听，而是被动传入</h4><ul><li>最も大阪の方言が聞けると思っていたんですが，あまり耳にしませんでした。</li><li>携帯電話の普及で，最近公衆電話を目にしなくなりました。</li></ul><h4 id="～せい／せいで／せいか-事情的原因，原因不明确时用せいか"><a href="#～せい／せいで／せいか-事情的原因，原因不明确时用せいか" class="headerlink" title="～せい／せいで／せいか　事情的原因，原因不明确时用せいか"></a>～せい／せいで／せいか　事情的原因，原因不明确时用せいか</h4><ul><li>風邪を引いているせいか，今日は仕事に集中できない。</li><li>計画が失敗したのは，私のせいだ。</li></ul><h4 id="～おかけで／～おかけか-多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか"><a href="#～おかけで／～おかけか-多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか" class="headerlink" title="～おかけで／～おかけか　多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか"></a>～おかけで／～おかけか　多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか</h4><ul><li>林さんのおかけで，助かりました。</li><li>薬を飲んだおかけか，1日で熱が下がりました。</li></ul><h4 id="～です／だけれど，～-虽然……，但是……，意思和が，だけ一样的但是更有礼貌"><a href="#～です／だけれど，～-虽然……，但是……，意思和が，だけ一样的但是更有礼貌" class="headerlink" title="～です／だけれど，～　虽然……，但是……，意思和が，だけ一样的但是更有礼貌"></a>～です／だけれど，～　虽然……，但是……，意思和が，だけ一样的但是更有礼貌</h4><ul><li>せっかくですけれど，今日は遠慮しておきます。</li></ul><h4 id="～においても-对于，在……方面，就……而言"><a href="#～においても-对于，在……方面，就……而言" class="headerlink" title="～においても　对于，在……方面，就……而言"></a>～においても　对于，在……方面，就……而言</h4><ul><li>日本語においても，発音，文法，語彙など，地域による言葉の違いがある。</li></ul><h4 id="～ことになる-也就是说，变得……会这样"><a href="#～ことになる-也就是说，变得……会这样" class="headerlink" title="～ことになる　也就是说，变得……会这样"></a>～ことになる　也就是说，变得……会这样</h4><ul><li>参加者は男性３名，女性２名，５名ということになる。</li></ul><h3 id="课文-11"><a href="#课文-11" class="headerlink" title="课文"></a>课文</h3><p>中国は多民族国家で，民族によって使用する言語が異なっている。また中国語も一つではなく，かなりの数の方言が存在する。それぞれの方言は発音も文法も語彙も大きく違っている。</p><p>日本語においても，発音，文法，語彙など，地域による言葉の違いがある。</p><p>まず，発音やアクセントの違いがある。例えば，「はし」という言葉だ。「箸」の「はし」，「橋」の「はし」。ほかにも異なった意味があるが，この二つの意味で考えてみよう。</p><p>方言の違いによってこんな誤解が起きることもある。例えば，東北地方に「なげる」という方言がある。これは「捨てる」という意味だが，方言を知らない人が「これをなげす」と言われて，「投げる」だと解釈して，ごみを投げ返して怒られたという話がある。また，関西地方には「ほかす」という方言がある。やはり「捨てる」という意味が，これを「保管して」と聞き間違えて，要らないものを大切に保管してしまったという話もある。</p><h1 id="単元-3"><a href="#単元-3" class="headerlink" title="単元"></a>単元</h1><h2 id="第１３課"><a href="#第１３課" class="headerlink" title="第１３課"></a>第１３課</h2><h3 id="文法-12"><a href="#文法-12" class="headerlink" title="文法"></a>文法</h3><h4 id="折り入って～-诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫"><a href="#折り入って～-诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫" class="headerlink" title="折り入って～　诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫"></a>折り入って～　诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫</h4><ul><li>折り入ってお話したいのですが，今よろしいでしょうか。</li></ul><h4 id="もしかして／もしかすると・もしかしたら-该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句"><a href="#もしかして／もしかすると・もしかしたら-该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句" class="headerlink" title="もしかして／もしかすると・もしかしたら　该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句"></a>もしかして／もしかすると・もしかしたら　该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句</h4><ul><li>もしかして，上海の李さんも来るの？</li></ul><h4 id="～ことになりました-决定要……-有受到多种因素的影响后才做出的决定，自然的变成这样的"><a href="#～ことになりました-决定要……-有受到多种因素的影响后才做出的决定，自然的变成这样的" class="headerlink" title="～ことになりました　决定要…… 　有受到多种因素的影响后才做出的决定，自然的变成这样的"></a>～ことになりました　决定要…… 　有受到多种因素的影响后才做出的决定，自然的变成这样的</h4><ul><li>王さんが結婚式に出席してくれことになりました。</li><li>来年の春に結婚することになりました。</li></ul><h4 id="朝着一个方向不断发展，有～ていく的感觉"><a href="#朝着一个方向不断发展，有～ていく的感觉" class="headerlink" title="朝着一个方向不断发展，有～ていく的感觉"></a>朝着一个方向不断发展，有～ていく的感觉</h4><ul><li><p>～一方だ</p><ul><li>世界の人口は増加する一方が，日本の人口は減り始めている。</li><li>前后主语一样时表示同时做某事，可用于接续<ul><li>彼は事故の原因を調べる一方，被害の拡大を防いだ。</li></ul></li><li>前后主语不一样时表示对比，也可以用于接续<ul><li>出生率が下がる一方，平均寿命どんどん長くなっています。</li></ul></li></ul></li><li><p>～ばかりだ</p><ul><li>全是，尽是，光是<ul><li>最近，変な夢ばかり見る。</li><li>彼は週末になると博物館ばかり行っている</li></ul></li><li>朝着一个不好的方向不断发展<ul><li>病気はどんどん悪くなるばかりだ。</li></ul></li></ul></li><li><p>の一途をたどる　书面语</p><ul><li>出生率は減少の一途をたどっている。</li></ul></li></ul><h4 id="AのBにはCがある-AのB的原因之一有C"><a href="#AのBにはCがある-AのB的原因之一有C" class="headerlink" title="AのBにはCがある　AのB的原因之一有C"></a>AのBにはCがある　AのB的原因之一有C</h4><ul><li>事故の原因には整備不良がある。</li><li>「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。</li></ul><h4 id="Aに対する-对于A的……（态度，感情，动作），也有对比的意思"><a href="#Aに対する-对于A的……（态度，感情，动作），也有对比的意思" class="headerlink" title="Aに対する　对于A的……（态度，感情，动作），也有对比的意思"></a>Aに対する　对于A的……（态度，感情，动作），也有对比的意思</h4><ul><li>政府に対する国民の批判が高まっている。</li><li>地球温暖化に対して取り組みは国によってさまざまだ。</li><li>兄はおとなしく内向的なのに対して，弟はとても活発で外向的だ。</li></ul><h3 id="课文-12"><a href="#课文-12" class="headerlink" title="课文"></a>课文</h3><p>「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。例えば，結婚年齢が遅くなる「晩婚化」の傾向は，年々強まっている。結婚時の女性の平均年齢は，1977年には25.0歳であったが，1992年には26.0歳，2004年には27.8歳になった。</p><p>高年齢になると出産を控える傾向が強まり，一人の女性が出産する子供の数を示す「出生率」が下がる。それが少子化の原因に繋がっている。</p><h2 id="第１４課"><a href="#第１４課" class="headerlink" title="第１４課"></a>第１４課</h2><h3 id="文法-13"><a href="#文法-13" class="headerlink" title="文法"></a>文法</h3><h4 id="～を問わず-不论……，书面语"><a href="#～を問わず-不论……，书面语" class="headerlink" title="～を問わず　不论……，书面语"></a>～を問わず　不论……，书面语</h4><ul><li>男女を問わず，黒か濃い紺色，灰色の地味なスーツを指す。</li></ul><h4 id="～て初めて～-只有……才能……"><a href="#～て初めて～-只有……才能……" class="headerlink" title="～て初めて～　只有……才能……"></a>～て初めて～　只有……才能……</h4><ul><li>これらの試験をとっばして初めて内定をもらうことになる 。</li></ul><p>####　少しでも～　尽可能早的……</p><ul><li>少しでもいい席を取れるように，会場の前に朝早くから多くの人が並んでいる。</li></ul><h3 id="课文-13"><a href="#课文-13" class="headerlink" title="课文"></a>课文</h3><p>面接は話す場であり，文を読む場ではない。志望動機や自己PRなど，履歴書に書いたものをそのまま話すのはよくない。</p><p>会社の建物に入り，出るまでが採用試験である。受付での話し方や待合室での態度なども評価の対象になる。</p><p>面接でははじめの印象が大切である。清潔のあるきちんとした服装をすること。</p><h2 id="第１５課"><a href="#第１５課" class="headerlink" title="第１５課"></a>第１５課</h2><h3 id="文法-14"><a href="#文法-14" class="headerlink" title="文法"></a>文法</h3><h4 id="ちっとも／少しも／全然／真く＋～ない-一点也不"><a href="#ちっとも／少しも／全然／真く＋～ない-一点也不" class="headerlink" title="ちっとも／少しも／全然／真く＋～ない　一点也不"></a>ちっとも／少しも／全然／真く＋～ない　一点也不</h4><ul><li>学生の頃と，ちっとも変わってないわね。</li><li>課長は少しも部下の意見を聞いてくれない。</li><li>昨日の夜のことは全然覚えてない。</li><li>山田さんと町子さんが結婚することを真く知らなかった。</li></ul><h4 id="それはそうと-先不说那个，转换话题"><a href="#それはそうと-先不说那个，转换话题" class="headerlink" title="それはそうと　先不说那个，转换话题"></a>それはそうと　先不说那个，转换话题</h4><ul><li>今回は仕事で日本に来たんでしょう。</li></ul><h4 id="決して～ない-绝对不是这样，绝对不这样做"><a href="#決して～ない-绝对不是这样，绝对不这样做" class="headerlink" title="決して～ない　绝对不是这样，绝对不这样做"></a>決して～ない　绝对不是这样，绝对不这样做</h4><ul><li>彼は決して嘘はつきません</li><li>誰にも決してを分からない場所にお金を隠した。</li></ul><h3 id="课文-14"><a href="#课文-14" class="headerlink" title="课文"></a>课文</h3><p>日本の料理には，面白い名前のものがある。例えば，「親子丼」というのは，鶏肉と卵を調理してご飯にのせた料理である。鶏肉と卵は親と子であることからついた名前だ。<br>ほなに，「他人丼」という料理もある。豚肉や牛肉と卵を調理してご飯に載せた料理である。豚肉と卵は「親子」ではなく「他人」だからである。</p><p>では，「キツネうどん」というのはどんな料理だろうか。決して狐の肉が入ったうどんではない。うどんの上に，「油揚げ」という，豆腐を油揚げた物を載せた料理だ。<br>油揚げの色がキツネのような色だからとか，油揚げがキツネの好物だから，という理由でこんな名前が付けられたという。</p><h2 id="第１６課"><a href="#第１６課" class="headerlink" title="第１６課"></a>第１６課</h2><h3 id="文法-15"><a href="#文法-15" class="headerlink" title="文法"></a>文法</h3><h4 id="～ともに-一起做……和一緒に一样的意思"><a href="#～ともに-一起做……和一緒に一样的意思" class="headerlink" title="～ともに　一起做……和一緒に一样的意思"></a>～ともに　一起做……和一緒に一样的意思</h4><ul><li>今までともに助け合って，頑張ってきた。</li></ul><h4 id="～とも-全部，都"><a href="#～とも-全部，都" class="headerlink" title="～とも　全部，都"></a>～とも　全部，都</h4><ul><li>私たち姉妹は５人とも元気です。</li></ul><h4 id="～からといって～とは限らない／ない-虽然说……但也不一定-不"><a href="#～からといって～とは限らない／ない-虽然说……但也不一定-不" class="headerlink" title="～からといって～とは限らない／ない　虽然说……但也不一定/不"></a>～からといって～とは限らない／ない　虽然说……但也不一定/不</h4><ul><li>日本人だからといって，日本の文化に詳しいとは限らない。</li><li>森さんは，お酒を飲まないからといってお酒が嫌いではない。</li></ul><h3 id="会話-2"><a href="#会話-2" class="headerlink" title="会話"></a>会話</h3><p>中国には「白头偕老」という言葉があります。これは「ともに白髪になるまで一緒にいる」いう意味の言葉です。お二人とも，きっとこの言葉通りの幸せな夫婦になられるでしょう。</p><h3 id="课文-15"><a href="#课文-15" class="headerlink" title="课文"></a>课文</h3><p>キリスト教式で結婚式を上げるからといって，キリスト教の信者であるとは限らない。ウエディングドレスが着たいからとか，教会で挙式したいからなど，自分の好みで挙式のスタイルを決める人が多く，宗教で決める人は少数である。ほてるや結婚式場には，挙式の場所が設けられているので，実際に神社や教会へ行く人の数は少ない。さらに，海外で挙式をする人も多くなっている。</p><p>下のグラフは，ある出版社が首都圏の夫婦４００組に対して行ったアンケートの結果を求めたものである。これを見ると，挙式の形式が時代とともに変わってきていることが分かる。１９９４年には「キリスト教式結婚式」が56.6%，「人前結婚式」が5.4%であったのに対して，２００５年では，それぞれ74.4%，12.6%に増えた。一方，伝統的な挙式形式である「神前結婚式」は，２００５年には１９９４年の３分の１まで減少した。このように，結婚式に対する人々の意識は，時代にとともに変化してきている。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之N3文法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-(简敬)语</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E7%AE%80%E6%95%AC-%E8%AF%AD/"/>
    <id>/2024/06/11/日语-简敬-语/</id>
    <published>2024-06-11T03:10:38.000Z</published>
    <updated>2024-06-11T05:18:08.534Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之(简敬)语<br><a id="more"></a></p><h1 id="简体"><a href="#简体" class="headerlink" title="简体"></a>简体</h1><h2 id="变形规则"><a href="#变形规则" class="headerlink" title="变形规则"></a>变形规则</h2><h3 id="名词和形容动词"><a href="#名词和形容动词" class="headerlink" title="名词和形容动词"></a>名词和形容动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：だ，である</span><br><span class="line"></span><br><span class="line">一般否定：ではない、じゃない</span><br><span class="line"></span><br><span class="line">过去时：だった</span><br><span class="line"></span><br><span class="line">过去否定：ではなかった、じゃなかった</span><br></pre></td></tr></table></figure><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：寒い</span><br><span class="line"></span><br><span class="line">一般否定：寒くない</span><br><span class="line"></span><br><span class="line">过去时：寒かった</span><br><span class="line"></span><br><span class="line">过去否定：寒くなかった</span><br></pre></td></tr></table></figure><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：字典形</span><br><span class="line"></span><br><span class="line">一般否定：ない形</span><br><span class="line"></span><br><span class="line">过去时：た形</span><br><span class="line"></span><br><span class="line">过去否定：なかった</span><br></pre></td></tr></table></figure><h2 id="活用形"><a href="#活用形" class="headerlink" title="活用形"></a>活用形</h2><h3 id="终止形"><a href="#终止形" class="headerlink" title="终止形"></a>终止形</h3><blockquote><p>终止形即终止句子的形式<br>当名词和形容动词后面有か时可以省略だ</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动词简体</span><br><span class="line"></span><br><span class="line">形容词简体</span><br><span class="line"></span><br><span class="line">形容动词＋だ</span><br><span class="line"></span><br><span class="line">名词＋だ</span><br></pre></td></tr></table></figure><h3 id="连体形"><a href="#连体形" class="headerlink" title="连体形"></a>连体形</h3><blockquote><p>用于修饰名词, 所以连体形没有名词的变形</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动词简体</span><br><span class="line"></span><br><span class="line">形容词简体</span><br><span class="line"></span><br><span class="line">形容动词＋な</span><br></pre></td></tr></table></figure><h3 id="连用形"><a href="#连用形" class="headerlink" title="连用形"></a>连用形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I形: ます形</span><br><span class="line"></span><br><span class="line">II形: て形, た形</span><br></pre></td></tr></table></figure><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h3 id="简体可以修饰名词"><a href="#简体可以修饰名词" class="headerlink" title="简体可以修饰名词"></a>简体可以修饰名词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は四川語を話すことができます。</span><br><span class="line">译：我会说四川话。</span><br></pre></td></tr></table></figure><h3 id="简体＋といいます-引用别人说的话"><a href="#简体＋といいます-引用别人说的话" class="headerlink" title="简体＋といいます　引用别人说的话"></a>简体＋といいます　引用别人说的话</h3><ol><li>直接引用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：寝る前に、『おやしみ』といいます。</span><br><span class="line">译：睡觉之前一般会说“晚安”。</span><br></pre></td></tr></table></figure><ol start="2"><li>间接引用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ミーラさんは『来週東京へ出張する』といいます。</span><br><span class="line">译：米勒说下周要去东京出差。</span><br></pre></td></tr></table></figure><h3 id="动词和形容词简体-形容动词な-名词の＋とき-在……时候，动词简体过去式表示动作之后的情况"><a href="#动词和形容词简体-形容动词な-名词の＋とき-在……时候，动词简体过去式表示动作之后的情况" class="headerlink" title="动词和形容词简体/形容动词な/名词の＋とき　在……时候，动词简体过去式表示动作之后的情况"></a>动词和形容词简体/形容动词な/名词の＋とき　在……时候，动词简体过去式表示动作之后的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：暇なとき、遊びに来ましょうか。</span><br><span class="line">译：闲暇的时候，来玩吧！</span><br><span class="line"></span><br><span class="line">例：国へ帰るとき</span><br><span class="line">译：回国途中时……</span><br><span class="line"></span><br><span class="line">例：国へ帰ったとき</span><br><span class="line">译：回国后……</span><br></pre></td></tr></table></figure><h3 id="字典形＋と……-一怎么样"><a href="#字典形＋と……-一怎么样" class="headerlink" title="字典形＋と…… 一怎么样"></a>字典形＋と…… 一怎么样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：右へ曲がると郵便局があります。</span><br><span class="line">译：一右转就到邮局了。</span><br></pre></td></tr></table></figure><h3 id="简体-名词な＋んですか"><a href="#简体-名词な＋んですか" class="headerlink" title="简体/名词な＋んですか"></a>简体/名词な＋んですか</h3><ol><li>寻求更详细的说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうして遅れたんですか。</span><br><span class="line">译：为什么迟到了呢？</span><br></pre></td></tr></table></figure><ol start="2"><li>提起话题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：NHKを見学したいんですが、どうしたらいいですか。</span><br><span class="line">译：我想去NHK参观学习，怎做么才好呢？</span><br></pre></td></tr></table></figure><h3 id="终止形＋し＋终止形＋し＋终止形＋「から」"><a href="#终止形＋し＋终止形＋し＋终止形＋「から」" class="headerlink" title="终止形＋し＋终止形＋し＋终止形＋「から」"></a>终止形＋し＋终止形＋し＋终止形＋「から」</h3><ol><li>并列</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ワット先生は熱心だし真面目だし、経験もあります。</span><br><span class="line">译：瓦特老师既热心又认真，而且非常有经验。</span><br></pre></td></tr></table></figure><ol start="2"><li>列举理由，表示轻微的因果关系，暗示还有其他理由</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：駅から近いし、車でも来られるし、この店はとても便利です。</span><br><span class="line">译：离车站又近，坐车也能来，这家店真是便利呀。</span><br></pre></td></tr></table></figure><h3 id="动词字典形-动词ない形＋つもりです-下决心打算做某事"><a href="#动词字典形-动词ない形＋つもりです-下决心打算做某事" class="headerlink" title="动词字典形/动词ない形＋つもりです　下决心打算做某事"></a>动词字典形/动词ない形＋つもりです　下决心打算做某事</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：国へ帰っても柔道を続けるつもりです。</span><br><span class="line">译：即使回国也打算继续柔道。</span><br><span class="line"></span><br><span class="line">例：明日からは煙草を吸わないつもりです。</span><br><span class="line">译：打算从明天开始不再吸烟了。</span><br></pre></td></tr></table></figure><h3 id="动词字典形-名词の＋予定です-预计，预定的计划"><a href="#动词字典形-名词の＋予定です-预计，预定的计划" class="headerlink" title="动词字典形/名词の＋予定です　预计，预定的计划"></a>动词字典形/名词の＋予定です　预计，预定的计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：７月の終わりにドイツへ出張する予定です。</span><br><span class="line">译：预计7月完去德国出差。</span><br><span class="line"></span><br><span class="line">例：旅行は１週間ぐらいの予定です。</span><br><span class="line">译：预计旅行一周左右。</span><br></pre></td></tr></table></figure><h3 id="动词た形-ない形ない＋ほうがいいです。-最好做…-用于给别人提供建议和忠告"><a href="#动词た形-ない形ない＋ほうがいいです。-最好做…-用于给别人提供建议和忠告" class="headerlink" title="动词た形/ない形ない＋ほうがいいです。　最好做… 用于给别人提供建议和忠告"></a>动词た形/ない形ない＋ほうがいいです。　最好做… 用于给别人提供建议和忠告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：毎日運動したほうがいいです。</span><br><span class="line">译：最好每天运动。</span><br></pre></td></tr></table></figure><h3 id="终止形＋でしょう-表示说话人的推测"><a href="#终止形＋でしょう-表示说话人的推测" class="headerlink" title="终止形＋でしょう　表示说话人的推测"></a>终止形＋でしょう　表示说话人的推测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：明日は雨が降るでしょう。</span><br><span class="line">译：明天要下雨吧？</span><br><span class="line"></span><br><span class="line">例：楊さんは合格するでしょうか。</span><br><span class="line">译：杨同学及格了吧？</span><br></pre></td></tr></table></figure><h3 id="终止形＋かもしれません-可能，或许，可以简写为かも"><a href="#终止形＋かもしれません-可能，或许，可以简写为かも" class="headerlink" title="终止形＋かもしれません　可能，或许，可以简写为かも"></a>终止形＋かもしれません　可能，或许，可以简写为かも</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：約束の時間に合わないかもしれません。</span><br><span class="line">译：可能会错过了约定的时间。</span><br></pre></td></tr></table></figure><h3 id="字典形-た形＋とおりに、～-按照……做……"><a href="#字典形-た形＋とおりに、～-按照……做……" class="headerlink" title="字典形/た形＋とおりに、～　按照……做……"></a>字典形/た形＋とおりに、～　按照……做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：私はやるとおりに、やってください。</span><br><span class="line">译：请跟着我做。</span><br><span class="line"></span><br><span class="line">例：みたとおりに、話してください。</span><br><span class="line">译：请按照所看到的那样说。</span><br></pre></td></tr></table></figure><ul><li>拓展：～らしい　推测，传闻，……的样子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あそこにいる人は男らしい。</span><br><span class="line">译：那人像是个男的。</span><br><span class="line"></span><br><span class="line">例：彼はとても男らしい。</span><br><span class="line">译：她非常像一名男性。</span><br></pre></td></tr></table></figure><h3 id="ます形-名词の＋とおりに、～-正如，按照"><a href="#ます形-名词の＋とおりに、～-正如，按照" class="headerlink" title="ます形/名词の＋とおりに、～　正如，按照"></a>ます形/名词の＋とおりに、～　正如，按照</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：説明書のとおりに、組み立てました。</span><br><span class="line">译：我按照说明书组装好了。</span><br></pre></td></tr></table></figure><h3 id="た形-名词の＋あとで-……之后……-（する前に、した後で）"><a href="#た形-名词の＋あとで-……之后……-（する前に、した後で）" class="headerlink" title="た形/名词の＋あとで　……之后…… （する前に、した後で）"></a>た形/名词の＋あとで　……之后…… （する前に、した後で）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：仕事のあとで、飲みに行きませんか。</span><br><span class="line">译：下班后要去喝一杯吗？</span><br></pre></td></tr></table></figure><h3 id="可能态字典形-ない形ない＋ように、～-为了……而……-前方必须是非意志类词语，前后主语可以不一致"><a href="#可能态字典形-ない形ない＋ように、～-为了……而……-前方必须是非意志类词语，前后主语可以不一致" class="headerlink" title="可能态字典形/ない形ない＋ように、～　为了……而…… 前方必须是非意志类词语，前后主语可以不一致"></a>可能态字典形/ない形ない＋ように、～　为了……而…… 前方必须是非意志类词语，前后主语可以不一致</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：早く泳げるように、毎日練習しています。</span><br><span class="line">译：为了早点学会游泳，每天都在练习。</span><br><span class="line"></span><br><span class="line">例：忘れないように、メモしてください。</span><br><span class="line">译：为了不忘记，记了笔记。</span><br><span class="line"></span><br><span class="line">例：老人にも読めるように、新聞の字を大きくする。</span><br><span class="line">译：为了让老人也能阅读，放大了报纸上的字。</span><br></pre></td></tr></table></figure><h3 id="字典形-名词の＋ために、～-为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿"><a href="#字典形-名词の＋ために、～-为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿" class="headerlink" title="字典形/名词の＋ために、～　为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿"></a>字典形/名词の＋ために、～　为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：自分の店を持つために、貯金しています。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="可能态字典形-ない形なく＋ように、なります-变得……"><a href="#可能态字典形-ない形なく＋ように、なります-变得……" class="headerlink" title="可能态字典形/ない形なく＋ように、なります　变得……"></a>可能态字典形/ない形なく＋ように、なります　变得……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：毎日練習すれば、泳げように、なります。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：太りましたから、好きな服が着られなくように、なりました。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="字典形-ない形ない＋ように、します-努力（尽可能）做或不做……"><a href="#字典形-ない形ない＋ように、します-努力（尽可能）做或不做……" class="headerlink" title="字典形/ない形ない＋ように、します　努力（尽可能）做或不做……"></a>字典形/ない形ない＋ように、します　努力（尽可能）做或不做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：毎日運動して、何でも食べるように、しています。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：もっと野菜を食べるように、してください。（更有礼貌）</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="疑问词＋终止形＋か、～"><a href="#疑问词＋终止形＋か、～" class="headerlink" title="疑问词＋终止形＋か、～"></a>疑问词＋终止形＋か、～</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：結婚のお祝いは何がいいか、話しています。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：私たちが初めて会ったのはいつか、覚えていますか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="终止形（名词不加だ）＋かどうか、～"><a href="#终止形（名词不加だ）＋かどうか、～" class="headerlink" title="终止形（名词不加だ）＋かどうか、～"></a>终止形（名词不加だ）＋かどうか、～</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：その話は本堂かどうか、わかりません。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：まちがいがないかどうか、調べてください。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="名词-形容词去い-形容动词＋がる-有……的感觉-感觉……"><a href="#名词-形容词去い-形容动词＋がる-有……的感觉-感觉……" class="headerlink" title="名词/形容词去い/形容动词＋がる　有……的感觉, 感觉……"></a>名词/形容词去い/形容动词＋がる　有……的感觉, 感觉……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：嬉しがる</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：好きがる</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="名词に-形容词去い加く-形容动词に＋します-使……变成……-名词に还有选择和决定的意思"><a href="#名词に-形容词去い加く-形容动词に＋します-使……变成……-名词に还有选择和决定的意思" class="headerlink" title="名词に/形容词去い加く/形容动词に＋します　使……变成……　名词に还有选择和决定的意思"></a>名词に/形容词去い加く/形容动词に＋します　使……变成……　名词に还有选择和决定的意思</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：音を大きくします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：部屋を綺麗にします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：会議は明日にします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：部屋はシングルにしますか、ツインにしますか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="连体形-名词の＋場合は、～-如果……就……-后面一般接对策或导致的结果"><a href="#连体形-名词の＋場合は、～-如果……就……-后面一般接对策或导致的结果" class="headerlink" title="连体形/名词の＋場合は、～　如果……就……(后面一般接对策或导致的结果)"></a>连体形/名词の＋場合は、～　如果……就……(后面一般接对策或导致的结果)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：会議に間に合わない場合は、連絡してください。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：時間に遅れた場合は、会場に入れません。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="连体形-名词な＋のに、～-明明……却……-表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。"><a href="#连体形-名词な＋のに、～-明明……却……-表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。" class="headerlink" title="连体形/名词な＋のに、～　明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。"></a>连体形/名词な＋のに、～　明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：約束をしたのに、彼女はきませんでした。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：約束をしたのに、どうして来なかったですか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-～ている-た＋ところです-即将-正在-刚刚做了（5-10分钟的事情）"><a href="#动词字典形-～ている-た＋ところです-即将-正在-刚刚做了（5-10分钟的事情）" class="headerlink" title="动词字典形/～ている/~た＋ところです　即将/正在/刚刚做了（5-10分钟的事情）"></a>动词字典形/～ている/~た＋ところです　即将/正在/刚刚做了（5-10分钟的事情）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：会議は今から始まるところです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：今私は勉強しているところです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：たった今バスがでたところです</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-ない形ない-形容词-形容动词な-名词の＋はずです-应该会，确信的推断。"><a href="#动词字典形-ない形ない-形容词-形容动词な-名词の＋はずです-应该会，确信的推断。" class="headerlink" title="动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです　应该会，确信的推断。"></a>动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです　应该会，确信的推断。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：くるはずですよ</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="简体＋そうです-据说，传闻。"><a href="#简体＋そうです-据说，传闻。" class="headerlink" title="简体＋そうです　据说，传闻。"></a>简体＋そうです　据说，传闻。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：天気予報によると、明日はさむくなるそうです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：クララさんは子どもの時、フランスに住んでいたそうです</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-形容词-形容动词な-名词の＋ようです-好像，感官感受到的好像"><a href="#动词字典形-形容词-形容动词な-名词の＋ようです-好像，感官感受到的好像" class="headerlink" title="动词字典形/形容词/形容动词な/名词の＋ようです　好像，感官感受到的好像"></a>动词字典形/形容词/形容动词な/名词の＋ようです　好像，感官感受到的好像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：渡辺さんはこのごろはやくかえりますから、どうも恋人ができたようですね。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="～がします。-有……的感受"><a href="#～がします。-有……的感受" class="headerlink" title="～がします。　有……的感受"></a>～がします。　有……的感受</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：おと（こえ）がします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：あじがします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：においがします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：～顔がします　有~样的表情</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h1 id="敬语"><a href="#敬语" class="headerlink" title="敬语"></a>敬语</h1><h2 id="礼貌体"><a href="#礼貌体" class="headerlink" title="礼貌体"></a>礼貌体</h2><h3 id="です"><a href="#です" class="headerlink" title="です"></a>です</h3><p>普通形态：～です。<br>过去形态：～でした。<br>否定形态：～では（じゃ）ありません。<br>过去否定形态：～では（じゃ）ありませんでした。</p><h3 id="ます"><a href="#ます" class="headerlink" title="ます"></a>ます</h3><p>普通形态：～ます。<br>过去形态：～ました。<br>否定形态：～ません。<br>过去否定形态：～ませんでした。</p><h2 id="尊他语"><a href="#尊他语" class="headerlink" title="尊他语"></a>尊他语</h2><h3 id="被动形表达尊敬"><a href="#被动形表达尊敬" class="headerlink" title="被动形表达尊敬"></a>被动形表达尊敬</h3><ul><li>課長はもう帰られました。</li></ul><h3 id="お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～"><a href="#お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～" class="headerlink" title="お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～"></a>お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～</h3><ul><li><p>～ください　请……</p><ul><li>お待ちください。</li></ul></li><li><p>～になる</p><ul><li>社長はもうお帰りになりました。</li></ul></li></ul><h3 id="特殊动词的敬语变形"><a href="#特殊动词的敬语变形" class="headerlink" title="特殊动词的敬语变形"></a>特殊动词的敬语变形</h3><ul><li>いらっしゃる ー＞ いらっしゃいます　ー＞　いる、来る、行く</li><li>召し上がります　ー＞　食べる、飲む</li><li>おっしゃる　ー＞ おっしゃいます　ー＞　言う<ul><li>というと　ー＞　とおっしゃいますと</li></ul></li><li>なさる　ー＞ なさいます　ー＞　する</li><li>ご覧になります　ー＞　見る<ul><li>ご覧ください　―＞　見てください</li></ul></li><li>ご存じです　ー＞　知っています</li><li>くださる　ー＞　くださいます　ー＞　くれる</li></ul><h3 id="ます形＋まして-用于敬语中使前后敬语一致，使礼貌程度一致"><a href="#ます形＋まして-用于敬语中使前后敬语一致，使礼貌程度一致" class="headerlink" title="ます形＋まして　用于敬语中使前后敬语一致，使礼貌程度一致"></a>ます形＋まして　用于敬语中使前后敬语一致，使礼貌程度一致</h3><ul><li>ハンスが昨夜ねつをだしまして、今朝もまだ下がらないんです。</li></ul><h3 id="お＋形容词"><a href="#お＋形容词" class="headerlink" title="お＋形容词"></a>お＋形容词</h3><ul><li><p>お忙しい</p><ul><li>今日はお忙しいようですから，また明後日伺います。</li></ul></li><li><p>お詳しい</p><ul><li>御社が中国国内の酒類販売ルートにお詳しいことを，MTS社の聞くより伺いました。</li></ul></li></ul><h2 id="自谦语"><a href="#自谦语" class="headerlink" title="自谦语"></a>自谦语</h2><h3 id="お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～-1"><a href="#お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～-1" class="headerlink" title="お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～"></a>お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～</h3><ul><li><p>～＋する／いたします／できる</p><ul><li>今月のスケジュールはお送りします。</li><li>はい，ご用意できます。</li></ul></li><li><p>～＋申し上げる・申し上げます　同する一样的意思，但是敬意程度更高</p><ul><li>よろしくご検討くださいますようお願い申し上げます。</li></ul></li><li><p>お＋动词て型＋しております　～ています 的自谦语</p><ul><li>只今お調べしております。</li><li>お呼び出ししております。</li></ul></li></ul><h3 id="特殊动词的敬语变形-1"><a href="#特殊动词的敬语变形-1" class="headerlink" title="特殊动词的敬语变形"></a>特殊动词的敬语变形</h3><ul><li>差し上げります　ー＞　上げる</li><li>いただきます　ー＞　もらう，食べる，飲む</li><li>参ります　ー＞　行く、来る</li><li>おります　ー＞　いる</li><li>申します　ー＞　言う</li><li>いたします　ー＞　する</li><li>拝見します　ー＞　見る</li><li>伺います　ー＞　聞く、いる</li><li>存じます　ー＞　思う，知る<ul><li>ことと存じます　ー＞　と思います</li></ul></li><li>お目にかかります　ー＞　会う</li><li>お目にかけります　ー＞　見せる</li><li>私　ー＞　わたくし<ul><li>私たち　ー＞　わたくしども</li></ul></li><li>お～しております　ー＞　～ています、お～します</li><li>使役态表达自谦</li><li>常用组合形式为～＋させていただきます<ul><li>検討させていただきます</li></ul></li></ul><h2 id="礼貌语"><a href="#礼貌语" class="headerlink" title="礼貌语"></a>礼貌语</h2><ul><li>お手洗い　ー＞　洗手间</li><li>ございます　ー＞　ある</li><li>でございます　ー＞　です</li><li>よろしい　ー＞　いい</li><li>より　―＞　から</li><li>にて　―＞　で</li><li>～におかれましては／～には　―＞　～は　书函中表达敬意的写法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之(简敬)语&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-(形助副)词</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E5%BD%A2%E5%8A%A9%E5%89%AF-%E8%AF%8D/"/>
    <id>/2024/06/11/日语-形助副-词/</id>
    <published>2024-06-11T03:10:19.000Z</published>
    <updated>2024-06-11T03:28:17.307Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之(形助副)词<br><a id="more"></a></p><h1 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h1><h3 id="1-修饰名词"><a href="#1-修饰名词" class="headerlink" title="1. 修饰名词"></a>1. 修饰名词</h3><p>~い + 名词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：優しい人</span><br><span class="line">译：温柔的人</span><br></pre></td></tr></table></figure><h3 id="2-名词化"><a href="#2-名词化" class="headerlink" title="2. 名词化"></a>2. 名词化</h3><p>形容词（去い） + さ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：部長は頭の痛さを我慢して出張した。</span><br><span class="line">译：部长忍着头痛出差去了。</span><br></pre></td></tr></table></figure><h3 id="3-修饰动词"><a href="#3-修饰动词" class="headerlink" title="3. 修饰动词"></a>3. 修饰动词</h3><p>形容词（去い） + く</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：浅く笑う</span><br><span class="line">译：浅笑</span><br></pre></td></tr></table></figure><h3 id="4-句中接续"><a href="#4-句中接续" class="headerlink" title="4. 句中接续"></a>4. 句中接续</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼女は美しくて優しいです。</span><br><span class="line">译：她美丽温柔。</span><br></pre></td></tr></table></figure><h1 id="形容动词"><a href="#形容动词" class="headerlink" title="形容动词"></a>形容动词</h1><h3 id="1-修饰名词-1"><a href="#1-修饰名词-1" class="headerlink" title="1. 修饰名词"></a>1. 修饰名词</h3><p>形容动词 + な + 名词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：綺麗な景色</span><br><span class="line">译：美丽的风景</span><br></pre></td></tr></table></figure><h3 id="2-名词化-1"><a href="#2-名词化-1" class="headerlink" title="2. 名词化"></a>2. 名词化</h3><p>形容动词 + さ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あの店は家に近いので、便利さは一番です。</span><br><span class="line">译：那个商店离家很近，非常方便呀。</span><br></pre></td></tr></table></figure><h3 id="3-修饰动词-1"><a href="#3-修饰动词-1" class="headerlink" title="3. 修饰动词"></a>3. 修饰动词</h3><p>形容动词 + に</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：簡単にしました</span><br><span class="line">译：轻易地完成了</span><br></pre></td></tr></table></figure><h3 id="4-句中接续-1"><a href="#4-句中接续-1" class="headerlink" title="4. 句中接续"></a>4. 句中接续</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この町は綺麗で静かです。</span><br><span class="line">译：这坐小镇真是美丽安静呀。</span><br></pre></td></tr></table></figure><h1 id="助词"><a href="#助词" class="headerlink" title="助词"></a>助词</h1><p>助词是日语中的一大特色，它是日语语言中的黏着剂，串连起一个个完整的句子和含义。</p><h2 id="常用助词"><a href="#常用助词" class="headerlink" title="常用助词"></a>常用助词</h2><h3 id="1-を"><a href="#1-を" class="headerlink" title="1. を"></a>1. <code>を</code></h3><ul><li>提示宾语</li></ul><p>全員が無事であることをお祈りします。</p><blockquote><p>祈祷大家都没事。</p></blockquote><ul><li>表示经过的场所</li></ul><p>猫は塀の上を走っていった。  </p><blockquote><p>小猫从在墙上跑走了。</p></blockquote><ul><li>动作的出发点，起点</li></ul><p>彼は文房具を売る6階でエレベーターを降りた。</p><blockquote><p>他在买文具的6楼下了电梯。</p></blockquote><h3 id="2-に"><a href="#2-に" class="headerlink" title="2. に"></a>2. <code>に</code></h3><ul><li>动作作用的对象</li></ul><p>親に黙って、会社を辞めてしまった。</p><blockquote><p>瞒着父母辞掉了工作。</p></blockquote><ul><li>动作变化的结果</li></ul><p>温度がマイナスになると、水が氷になります。</p><blockquote><p>温度到达零度以下水就会结冰。</p></blockquote><ul><li>事物存在的场所</li></ul><p>その言葉にうそは少しもなかった。</p><blockquote><p>那些话里一点谎言也没有。</p></blockquote><ul><li>动作的着落点</li></ul><p>道に倒れている人を助けました。</p><blockquote><p>救助了倒在道路上的人。</p></blockquote><ul><li>表示目的</li></ul><p>スーパーへ買い物に行きます。</p><blockquote><p>去超市买东西。</p></blockquote><h3 id="3-が"><a href="#3-が" class="headerlink" title="3. が"></a>3. <code>が</code></h3><ul><li>固定搭配，前接表示感觉的词表示感觉</li></ul><p>さっき隣の部屋で人の話し声がしました。 </p><blockquote><p>我刚才听到隔壁有人说话的声音。</p></blockquote><ul><li>接在自动词前面</li></ul><p>新しくて白い建物が見えるでしょう。あれが王さんの家です。</p><blockquote><p>能看到那座又新又白的建筑吧，那就是小王的家。</p></blockquote><ul><li>表示转折或铺垫</li></ul><p>ちょっとお願いがあるんですが…</p><p>予定どおり１７時３０分に到着いたしましたが…</p><h3 id="4-で"><a href="#4-で" class="headerlink" title="4. で"></a>4. <code>で</code></h3><ul><li>表示交通工具手段</li></ul><p>バスで学校へ行きます。</p><blockquote><p>坐公交去学校。</p></blockquote><ul><li>表示动作发生的场所</li></ul><p>運動場で走ります。</p><blockquote><p>在运动场上跑步。</p></blockquote><ul><li>表示原因</li></ul><p>地震でビルが倒れた。</p><blockquote><p>地震把大楼震倒了。</p></blockquote><ul><li>表示范围</li></ul><p>クラスの中で李さんが一番かっこいいです。</p><blockquote><p>班里小李最帅。</p></blockquote><ul><li>表示限定</li></ul><p>明日いっぱいで仕事を終わらせてください。</p><blockquote><p>请在明天内完成工作。</p></blockquote><h3 id="5-と"><a href="#5-と" class="headerlink" title="5. と"></a>5. <code>と</code></h3><ul><li>表示共同动作的对象</li></ul><p>李さんと一緒に映画を見に行きます。</p><blockquote><p>和小李一起去看电影。</p></blockquote><ul><li>表示引用的内容</li></ul><p>ほら、見てごらん。あそこに｢危険｣と書いてありますよ。</p><blockquote><p>你瞧，那里写着“危险”两个字哦。</p></blockquote><h3 id="6-へ"><a href="#6-へ" class="headerlink" title="6. へ"></a>6. <code>へ</code></h3><ul><li>表示动作移动的方向</li></ul><p>買い物へいく途中王先生に会いました。</p><blockquote><p>去买东西的路上遇到了王老师。  </p></blockquote><h3 id="7-から"><a href="#7-から" class="headerlink" title="7. から"></a>7. <code>から</code></h3><ul><li>表示起点</li></ul><p>学校から家まで1時間かかります。</p><blockquote><p>从家到学校要花1个小时。</p></blockquote><ul><li>表示原因</li></ul><p>昨日試験がありましたから行かなかった。</p><blockquote><p>因为昨天有考试所以没去。</p></blockquote><ul><li>表示成分/材料</li></ul><p>この箱は紙からできた。</p><blockquote><p>这个箱子是纸做的。</p></blockquote><h3 id="8-まで"><a href="#8-まで" class="headerlink" title="8. まで"></a>8. <code>まで</code></h3><ul><li>表示终点</li></ul><p>試験は明日までです。</p><blockquote><p>考试到明天结束。</p></blockquote><h3 id="9-の"><a href="#9-の" class="headerlink" title="9. の"></a>9. <code>の</code></h3><ul><li>表示所属,属性</li></ul><p>高校時代最後の運動会は一生忘れられない。</p><blockquote><p>高中时代最后一次运动会终生难忘。</p></blockquote><ul><li>名词化</li></ul><p>あのう、赤いのがありますか。</p><blockquote><p>请问有红色的吗？</p></blockquote><ul><li>表解释说明</li></ul><p>昨日試験がありましたから、来なかったのです。</p><blockquote><p>因为昨天有考试所以没来。</p></blockquote><h3 id="9-～けど"><a href="#9-～けど" class="headerlink" title="9. ～けど"></a>9. <code>～けど</code></h3><ul><li>表示转折或铺垫</li></ul><p>あうの，荷物がでてこないんですけど…</p><blockquote><p>那个，我的行李还有没有出来，能不能……</p></blockquote><p>知っていたけど，言わなかっただけだ。</p><blockquote><p>我是知道的，只不过没有说罢了。</p></blockquote><h1 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h1><p>副词用作连用修饰语，表示用言的状态、程度，或者表明句子的陈述语气等的词叫作副词。</p><h2 id="常用副词"><a href="#常用副词" class="headerlink" title="常用副词"></a>常用副词</h2><h3 id="あ"><a href="#あ" class="headerlink" title="あ"></a>あ</h3><h4 id="あまり"><a href="#あまり" class="headerlink" title="あまり"></a>あまり</h4><p>后接动词，肯定：太，过于；否定：不那么，不怎么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あまり食べると毒だよ。</span><br><span class="line">译：吃太多会伤身。</span><br><span class="line"></span><br><span class="line">例：あまり良くない。</span><br><span class="line">译：不怎么好。</span><br></pre></td></tr></table></figure><h4 id="あるいは"><a href="#あるいは" class="headerlink" title="あるいは"></a>あるいは</h4><p>或者；或许</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すぐ行けば或いは間に合うかもしれない。</span><br><span class="line">译：马上出发的话或许能赶上也说不定。</span><br></pre></td></tr></table></figure><h4 id="あいにく"><a href="#あいにく" class="headerlink" title="あいにく"></a>あいにく</h4><p>不凑巧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あいにく彼は留守でした。</span><br><span class="line">译：不凑巧他不在家。</span><br></pre></td></tr></table></figure><h3 id="い"><a href="#い" class="headerlink" title="い"></a>い</h3><h4 id="いかが"><a href="#いかが" class="headerlink" title="いかが"></a>いかが</h4><p>如何；怎样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ご病人の具合はいかがでしょうか。</span><br><span class="line">译：病人的情况如何？</span><br></pre></td></tr></table></figure><h4 id="一番（いちばん）"><a href="#一番（いちばん）" class="headerlink" title="一番（いちばん）"></a>一番（いちばん）</h4><p>最</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼が一番よく知っている。</span><br><span class="line">译：他知道的最清楚。</span><br></pre></td></tr></table></figure><h4 id="一生懸命（いっしょうけんめい）"><a href="#一生懸命（いっしょうけんめい）" class="headerlink" title="一生懸命（いっしょうけんめい）"></a>一生懸命（いっしょうけんめい）</h4><p>拼命</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一生懸命努力する。</span><br><span class="line">译：拼命努力着。</span><br></pre></td></tr></table></figure><h4 id="一緒に（いっしょに）"><a href="#一緒に（いっしょに）" class="headerlink" title="一緒に（いっしょに）"></a>一緒に（いっしょに）</h4><p>一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一緒にビルを飲みましょう。</span><br><span class="line">译：一起去喝啤酒吧。</span><br></pre></td></tr></table></figure><h4 id="一層（いっそう）"><a href="#一層（いっそう）" class="headerlink" title="一層（いっそう）"></a>一層（いっそう）</h4><p>更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病気は一層悪くなった。</span><br><span class="line">译：病情更加恶化了。</span><br></pre></td></tr></table></figure><h4 id="一般に（いっぱんに）"><a href="#一般に（いっぱんに）" class="headerlink" title="一般に（いっぱんに）"></a>一般に（いっぱんに）</h4><p>一般地、普遍地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一般にイギリス発祥とされるゴルフ。</span><br><span class="line">译：一般认为高尔夫的发祥地是英国。</span><br></pre></td></tr></table></figure><h4 id="いつまでも"><a href="#いつまでも" class="headerlink" title="いつまでも"></a>いつまでも</h4><p>永远；无论到何时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いつまでも友達でいましょう。</span><br><span class="line">译：永远是朋友。</span><br></pre></td></tr></table></figure><h4 id="いつも"><a href="#いつも" class="headerlink" title="いつも"></a>いつも</h4><p>总是；经常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いつもニコニコしていたら，嫌なことが寄り付きません。</span><br><span class="line">译：经常面带微笑的话，不好的事情就不会靠近哦。</span><br></pre></td></tr></table></figure><h3 id="お"><a href="#お" class="headerlink" title="お"></a>お</h3><h4 id="凡そ（およそ）"><a href="#凡そ（およそ）" class="headerlink" title="凡そ（およそ）"></a>凡そ（およそ）</h4><ol><li>大约</li><li>凡是</li><li>完全（用于否定）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：君の話は凡そ分かった。</span><br><span class="line">译：你的话我大概明白了。</span><br><span class="line"></span><br><span class="line">例：凡そ人間として生まれた以上…</span><br><span class="line">译：本来既然生而为人……</span><br><span class="line"></span><br><span class="line">例：政治とは凡そ縁がない。</span><br><span class="line">译：与政治全然无缘。</span><br></pre></td></tr></table></figure><h3 id="か"><a href="#か" class="headerlink" title="か"></a>か</h3><h4 id="がっかり"><a href="#がっかり" class="headerlink" title="がっかり"></a>がっかり</h4><ol><li>失望</li><li>筋疲力竭</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そんなにがっかりするな。</span><br><span class="line">译：别那么丧气呀。</span><br><span class="line"></span><br><span class="line">例：疲れてがっかりした。</span><br><span class="line">译：累得精疲力竭了。</span><br></pre></td></tr></table></figure><h4 id="必ず（かならず）"><a href="#必ず（かならず）" class="headerlink" title="必ず（かならず）"></a>必ず（かならず）</h4><p>一定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：必ず失敗する。</span><br><span class="line">译：必定要失败。</span><br></pre></td></tr></table></figure><h4 id="かなり"><a href="#かなり" class="headerlink" title="かなり"></a>かなり</h4><p>相当（出乎意料的那种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：かなりの距離。</span><br><span class="line">译：相当远的距离。</span><br><span class="line"></span><br><span class="line">例：あの人は日本語がかなりできる。</span><br><span class="line">译：那个人日语相当不错。</span><br></pre></td></tr></table></figure><h3 id="き"><a href="#き" class="headerlink" title="き"></a>き</h3><h4 id="きちんと"><a href="#きちんと" class="headerlink" title="きちんと"></a>きちんと</h4><ol><li>整整齐齐地，干干净净地</li><li>规规矩矩地，准确地</li><li>正好，正巧，正合适</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：料金はきちんと払ってある。</span><br><span class="line">译：钱已经如数付清。</span><br><span class="line"></span><br><span class="line">例：3時にきちんと集まる。</span><br><span class="line">译：3点准时集合。</span><br><span class="line"></span><br><span class="line">例：きちんとした字。</span><br><span class="line">译：工整的字。</span><br></pre></td></tr></table></figure><h4 id="きっと"><a href="#きっと" class="headerlink" title="きっと"></a>きっと</h4><p>一定（经常和だろう/でしょう一起使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：きっと合格できる。</span><br><span class="line">译：一定能合格。</span><br></pre></td></tr></table></figure><h4 id="極めて（きわめて）"><a href="#極めて（きわめて）" class="headerlink" title="極めて（きわめて）"></a>極めて（きわめて）</h4><p>极其</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：極めて簡単な問題である。</span><br><span class="line">译：是个极其简单的问题。</span><br></pre></td></tr></table></figure><h3 id="け"><a href="#け" class="headerlink" title="け"></a>け</h3><h4 id="結局（けっきょく）"><a href="#結局（けっきょく）" class="headerlink" title="結局（けっきょく）"></a>結局（けっきょく）</h4><p>到底，终究</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：結局だれがやるのか。</span><br><span class="line">译：到底谁来做呢？</span><br></pre></td></tr></table></figure><h4 id="結構（けっこう-）"><a href="#結構（けっこう-）" class="headerlink" title="結構（けっこう ）"></a>結構（けっこう ）</h4><p>相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私の日本語も結構通（つう）じたようだ。</span><br><span class="line">译：我的日语还算讲的通了。</span><br></pre></td></tr></table></figure><h4 id="決して（けっして）"><a href="#決して（けっして）" class="headerlink" title="決して（けっして）"></a>決して（けっして）</h4><p>决不~ 后要接否定使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：決して屈（く）しない。</span><br><span class="line">译：绝不屈服。</span><br></pre></td></tr></table></figure><h3 id="さ"><a href="#さ" class="headerlink" title="さ"></a>さ</h3><h4 id="さっき"><a href="#さっき" class="headerlink" title="さっき"></a>さっき</h4><p>刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：さっき帰ったばかりだ。</span><br><span class="line">译：刚刚才回来。</span><br></pre></td></tr></table></figure><h4 id="早速（さっそく-）"><a href="#早速（さっそく-）" class="headerlink" title="早速（さっそく ）"></a>早速（さっそく ）</h4><p>立刻，马上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：早速返事をくれた。</span><br><span class="line">译：很快给我了反馈。</span><br></pre></td></tr></table></figure><h4 id="さっぱり"><a href="#さっぱり" class="headerlink" title="さっぱり"></a>さっぱり</h4><p>清爽；干净；直爽；清单；不油腻；完全；精光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例：さっぱりした身なりをしている。</span><br><span class="line">译：打扮得干净利落。</span><br><span class="line"></span><br><span class="line">例：この料理はさっぱりしている。</span><br><span class="line">译：这个菜很清淡。</span><br><span class="line"></span><br><span class="line">例：約束のことはきれいさっぱりと忘れてしまった。</span><br><span class="line">译：早把约定忘得干干净净</span><br><span class="line"></span><br><span class="line">例：この映画はさっぱりおもしろくない。</span><br><span class="line">译：这个电影一点也不好看。</span><br><span class="line"></span><br><span class="line">例：どうもさっぱりだ。</span><br><span class="line">译：真糟糕。</span><br></pre></td></tr></table></figure><h3 id="し"><a href="#し" class="headerlink" title="し"></a>し</h3><h4 id="しっかり"><a href="#しっかり" class="headerlink" title="しっかり"></a>しっかり</h4><p>牢牢地；紧紧地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しっかりつかまる。</span><br><span class="line">译：牢牢抓住。</span><br></pre></td></tr></table></figure><h4 id="じっと"><a href="#じっと" class="headerlink" title="じっと"></a>じっと</h4><p>一动不动地；一声不响地，忍耐着，不出声；目不转睛地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：じっと見つめる。</span><br><span class="line">译：盯着看。</span><br><span class="line"></span><br><span class="line">例：じっとしていられない。</span><br><span class="line">译：坐立不安。</span><br></pre></td></tr></table></figure><h4 id="実は（じつは）"><a href="#実は（じつは）" class="headerlink" title="実は（じつは）"></a>実は（じつは）</h4><p>说真的，老实说，事实是，说实在的，其实，原来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：実は私にもよく分からない。</span><br><span class="line">译：说真的，我也不太明白。</span><br></pre></td></tr></table></figure><h4 id="しばらく"><a href="#しばらく" class="headerlink" title="しばらく"></a>しばらく</h4><p>暂时，不久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらく待ってくれ。 </span><br><span class="line">译：（你）给我等一会儿。</span><br></pre></td></tr></table></figure><p>一时的，暂且</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらく辛抱する。</span><br><span class="line">译：姑且忍耐一时。</span><br></pre></td></tr></table></figure><p>许久，好久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらくでしたね。</span><br><span class="line">译：好久不见呀。</span><br></pre></td></tr></table></figure><h4 id="充分（じゅうぶん）"><a href="#充分（じゅうぶん）" class="headerlink" title="充分（じゅうぶん）"></a>充分（じゅうぶん）</h4><p>充分的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：自分の力を充分発揮する。</span><br><span class="line">译：充分发挥自己的才能。</span><br></pre></td></tr></table></figure><h3 id="す"><a href="#す" class="headerlink" title="す"></a>す</h3><h4 id="ずいぶん"><a href="#ずいぶん" class="headerlink" title="ずいぶん"></a>ずいぶん</h4><p>相当厉害；非常，很；颇，相当；特别；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病人は熱のためにずいぶん苦しんでいる。</span><br><span class="line">译：病人因发烧很难受。</span><br></pre></td></tr></table></figure><p>好久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ずいぶん捜した。</span><br><span class="line">译：找了好久。</span><br></pre></td></tr></table></figure><h4 id="すぐ"><a href="#すぐ" class="headerlink" title="すぐ"></a>すぐ</h4><p>立刻；马上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すぐ出かけましょう。</span><br><span class="line">译：马上出门吧。</span><br></pre></td></tr></table></figure><h4 id="すこし"><a href="#すこし" class="headerlink" title="すこし"></a>すこし</h4><p>一点点；稍微</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：少し疲れました。</span><br><span class="line">译：有点累了。</span><br></pre></td></tr></table></figure><h4 id="すっかり"><a href="#すっかり" class="headerlink" title="すっかり"></a>すっかり</h4><p>完全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すっかり忘れていた。</span><br><span class="line">译：全忘了。</span><br></pre></td></tr></table></figure><h4 id="ずっと"><a href="#ずっと" class="headerlink" title="ずっと"></a>ずっと</h4><p>一直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今朝からずっと待っていた。</span><br><span class="line">译：从今天早晨一直等到现在。</span><br></pre></td></tr></table></figure><p>远比…..更</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼の方がずっといい。</span><br><span class="line">译：他的方法好得多。</span><br></pre></td></tr></table></figure><p>径直（走）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ずっと前へ進み出た。</span><br><span class="line">译：径直走到前面。</span><br></pre></td></tr></table></figure><h4 id="すべて"><a href="#すべて" class="headerlink" title="すべて"></a>すべて</h4><p>全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題はすべて解決した。</span><br><span class="line">译：问题全部解决了。</span><br></pre></td></tr></table></figure><h3 id="せ"><a href="#せ" class="headerlink" title="せ"></a>せ</h3><h4 id="せっかく"><a href="#せっかく" class="headerlink" title="せっかく"></a>せっかく</h4><p>难得，好不容易</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：せっかく晩ご飯を作ったのに、みんなは外食にするなんて。</span><br><span class="line">译：我特意做了晚饭，大家却在外面吃饭。</span><br></pre></td></tr></table></figure><h4 id="ぜったい"><a href="#ぜったい" class="headerlink" title="ぜったい"></a>ぜったい</h4><p>绝对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ぜったい間違いない。</span><br><span class="line">译：绝对没有错。</span><br></pre></td></tr></table></figure><h4 id="ぜひ"><a href="#ぜひ" class="headerlink" title="ぜひ"></a>ぜひ</h4><p>一定；务必</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ぜひ遊びに来てね。</span><br><span class="line">译：一定要来玩哦。</span><br></pre></td></tr></table></figure><h4 id="全然（ぜんぜん）"><a href="#全然（ぜんぜん）" class="headerlink" title="全然（ぜんぜん）"></a>全然（ぜんぜん）</h4><p>一点也不…..（后接否定，表全否）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：全然興味がない。</span><br><span class="line">译：完全没了兴趣。</span><br></pre></td></tr></table></figure><h4 id="全部（ぜんぶ）"><a href="#全部（ぜんぶ）" class="headerlink" title="全部（ぜんぶ）"></a>全部（ぜんぶ）</h4><p>全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題は全部解決ずみだ。</span><br><span class="line">译：问题已经全部解决。</span><br></pre></td></tr></table></figure><h3 id="そ"><a href="#そ" class="headerlink" title="そ"></a>そ</h3><h4 id="相当（そうとう）"><a href="#相当（そうとう）" class="headerlink" title="相当（そうとう）"></a>相当（そうとう）</h4><p>相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日は相当（に）寒いです。</span><br><span class="line">译：今天相当的冷呀。</span><br></pre></td></tr></table></figure><h4 id="そろそろ"><a href="#そろそろ" class="headerlink" title="そろそろ"></a>そろそろ</h4><p>就要，快要；不久；时间差不多了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：もうそろそろ晚飯だ。</span><br><span class="line">译：就要吃晚饭了。</span><br></pre></td></tr></table></figure><p>渐渐；逐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そろそろ（と）寒くなってきた。</span><br><span class="line">译：渐渐地冷起来了。</span><br></pre></td></tr></table></figure><p>慢慢地；徐徐地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そろそろと歩く。</span><br><span class="line">译：慢慢地走。</span><br></pre></td></tr></table></figure><h4 id="それぞれ"><a href="#それぞれ" class="headerlink" title="それぞれ"></a>それぞれ</h4><p>各自；分别；各个；每个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：それぞれ別の道を行く。</span><br><span class="line">译：各走各的路。</span><br></pre></td></tr></table></figure><h4 id="それほど"><a href="#それほど" class="headerlink" title="それほど"></a>それほど</h4><p>那么，那样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語はそれほど難しくありません。</span><br><span class="line">译：语并不是那么难。</span><br></pre></td></tr></table></figure><h3 id="た"><a href="#た" class="headerlink" title="た"></a>た</h3><h4 id="だんだん"><a href="#だんだん" class="headerlink" title="だんだん"></a>だんだん</h4><p>渐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：だんだん秋めいてきた。</span><br><span class="line">译：渐有秋意了。</span><br></pre></td></tr></table></figure><h4 id="たまに"><a href="#たまに" class="headerlink" title="たまに"></a>たまに</h4><p>偶尔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たまにはご両親に電話を掛けなさい。</span><br><span class="line">译：偶尔请给你父母打个电话。</span><br></pre></td></tr></table></figure><h4 id="多分（たぶん）"><a href="#多分（たぶん）" class="headerlink" title="多分（たぶん）"></a>多分（たぶん）</h4><p>大概（经常和でしょう/だろう一起使用，表示推测，大概….）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼が言うことは多分本当だろう。</span><br><span class="line">译：他说的大概是真的吧！</span><br></pre></td></tr></table></figure><h4 id="大体（だいたい）"><a href="#大体（だいたい）" class="headerlink" title="大体（だいたい）"></a>大体（だいたい）</h4><p>大体上；大概</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大体以下のように規定する。</span><br><span class="line">译：大致规定如下。</span><br></pre></td></tr></table></figure><p>基本上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大体できた。 </span><br><span class="line">译：基本上完成了。</span><br></pre></td></tr></table></figure><h4 id="たいてい"><a href="#たいてい" class="headerlink" title="たいてい"></a>たいてい</h4><p>大致上，大都，差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題はたいてい出来た。</span><br><span class="line">译：问题大都产生了。</span><br></pre></td></tr></table></figure><p>大概，恐怕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たいてい大丈夫だろう。</span><br><span class="line">译：大概没问题吧。</span><br></pre></td></tr></table></figure><h4 id="たくさん"><a href="#たくさん" class="headerlink" title="たくさん"></a>たくさん</h4><p>许多（后接名词时要加の例：たくさんの人 动词可直接接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たくさんの人。</span><br><span class="line">译：很多人。</span><br></pre></td></tr></table></figure><h4 id="確か（たしか）"><a href="#確か（たしか）" class="headerlink" title="確か（たしか）"></a>確か（たしか）</h4><p>似乎，大概，表示根据记忆有相当把握的推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：確か2000円でした。</span><br><span class="line">译：要是没错，那是二千日元。</span><br></pre></td></tr></table></figure><h4 id="たとえ"><a href="#たとえ" class="headerlink" title="たとえ"></a>たとえ</h4><p>即使</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たとえ負けても後悔しない。</span><br><span class="line">译：即使输了也不后悔。</span><br></pre></td></tr></table></figure><h4 id="例えば（たとえば）"><a href="#例えば（たとえば）" class="headerlink" title="例えば（たとえば）"></a>例えば（たとえば）</h4><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：スポーツ，例えばバレーボールや卓球などをなさいますか。</span><br><span class="line">译：体育活动，例如排球、乒乓球，你参加吗？</span><br></pre></td></tr></table></figure><h3 id="ち"><a href="#ち" class="headerlink" title="ち"></a>ち</h3><h4 id="ちゃんと"><a href="#ちゃんと" class="headerlink" title="ちゃんと"></a>ちゃんと</h4><p>好好地；踏踏实实地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちゃんと仕事をする。</span><br><span class="line">译：踏踏实实地工作。</span><br></pre></td></tr></table></figure><p>整整齐齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：物をちゃんとかたづける。</span><br><span class="line">译：把东西收拾好。</span><br></pre></td></tr></table></figure><p>确实；的确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わたしがちゃんと見た。</span><br><span class="line">译：我确实看见了。</span><br></pre></td></tr></table></figure><h4 id="ちょうど"><a href="#ちょうど" class="headerlink" title="ちょうど"></a>ちょうど</h4><p>刚好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど居合わせる。</span><br><span class="line">译：正好在场。</span><br></pre></td></tr></table></figure><p>宛如，好像，恰似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど絵のようだ。</span><br><span class="line">译：好像一幅画。</span><br></pre></td></tr></table></figure><p>正，整。完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど８時。</span><br><span class="line">译：八点整。</span><br></pre></td></tr></table></figure><h4 id="ちょっと"><a href="#ちょっと" class="headerlink" title="ちょっと"></a>ちょっと</h4><p>一会儿，一下；表示数量不多，程度不深，时间很短等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと待ってください。</span><br><span class="line">译：请稍等一下。</span><br></pre></td></tr></table></figure><p>相当，颇。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと名の通った人</span><br><span class="line">译：颇有名望的人</span><br></pre></td></tr></table></figure><p>不太容易，表示没那么简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっとわからない。</span><br><span class="line">译：不太明白。</span><br></pre></td></tr></table></figure><p>试试，看看，以轻松的心情事做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと行ってくる。</span><br><span class="line">译：去去就来。</span><br></pre></td></tr></table></figure><h3 id="つ"><a href="#つ" class="headerlink" title="つ"></a>つ</h3><h4 id="ついでに"><a href="#ついでに" class="headerlink" title="ついでに"></a>ついでに</h4><p>顺便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：散歩のついでに、お菓子を買ってきた。</span><br><span class="line">译：去散步，顺便买来了点心。</span><br></pre></td></tr></table></figure><h4 id="ついに"><a href="#ついに" class="headerlink" title="ついに"></a>ついに</h4><p>终于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ついに出来上がった。</span><br><span class="line">译：终于完成了。</span><br></pre></td></tr></table></figure><p>直到最后（也不）；始终（不）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ついに会わずじまいだ。</span><br><span class="line">译：直到最后也未能见面。</span><br></pre></td></tr></table></figure><h4 id="次々（つぎつぎ）"><a href="#次々（つぎつぎ）" class="headerlink" title="次々（つぎつぎ）"></a>次々（つぎつぎ）</h4><p>连续不断、络绎不绝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：次々に仕掛け花火が打ち上げられる。</span><br><span class="line">译：一个接一个地放起烟火。</span><br></pre></td></tr></table></figure><h4 id="常に（つねに）"><a href="#常に（つねに）" class="headerlink" title="常に（つねに）"></a>常に（つねに）</h4><p>经常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：常にあることだ。</span><br><span class="line">译：常有的事。</span><br></pre></td></tr></table></figure><h4 id="つまり"><a href="#つまり" class="headerlink" title="つまり"></a>つまり</h4><p>总之，归根究底</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：つまり君は何を言いたいのか。</span><br><span class="line">译：究竟你想说什么呢？</span><br></pre></td></tr></table></figure><h3 id="て"><a href="#て" class="headerlink" title="て"></a>て</h3><h4 id="できるだけ"><a href="#できるだけ" class="headerlink" title="できるだけ"></a>できるだけ</h4><p>尽量地；尽可能地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：できるだけのことをする。</span><br><span class="line">译：尽力而为。</span><br></pre></td></tr></table></figure><h3 id="と"><a href="#と" class="headerlink" title="と"></a>と</h3><h4 id="どう"><a href="#どう" class="headerlink" title="どう"></a>どう</h4><p>如何；怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：それはどういうわけだ。</span><br><span class="line">译：那是为什么呢？</span><br><span class="line"></span><br><span class="line">例：もう一杯どう。 </span><br><span class="line">译：再来一杯怎么样？</span><br></pre></td></tr></table></figure><h4 id="どうか"><a href="#どうか" class="headerlink" title="どうか"></a>どうか</h4><p>请；务必</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あのことはどうかなるだろう。</span><br><span class="line">译：那件事总会有办法的吧。</span><br></pre></td></tr></table></figure><p>礼貌用语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうかよろしくお願いします。</span><br><span class="line">译：请多关照。</span><br></pre></td></tr></table></figure><p>不正常；异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は今日にどうかしている。</span><br><span class="line">译：他今天与往常不一样。</span><br></pre></td></tr></table></figure><p>怎么回事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：それはどうか分からない。</span><br><span class="line">译：不明白那是怎么回事。</span><br></pre></td></tr></table></figure><h4 id="どうして"><a href="#どうして" class="headerlink" title="どうして"></a>どうして</h4><p>为什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日はどうして学校を休みましたか。</span><br><span class="line">译：今天怎么没来上学呀。</span><br></pre></td></tr></table></figure><p>怎么样，怎么办，如何。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この機械をどうして動かすか教えてほしい。</span><br><span class="line">译：希望教给我怎样开动这个机器。</span><br></pre></td></tr></table></figure><p>岂止，岂料，意外，相反</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やさしそうに見えるが，どうして，なかなか気が強い。 </span><br><span class="line">译：看上去像很温柔，其实刚强得很。</span><br></pre></td></tr></table></figure><p>唉呀唉呀。出乎意料时表示吃惊或感叹的词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうして，たいした人気だ。</span><br><span class="line">译：唉呀唉呀，真红得不得了。</span><br></pre></td></tr></table></figure><h4 id="当然（とうぜん）"><a href="#当然（とうぜん）" class="headerlink" title="当然（とうぜん）"></a>当然（とうぜん）</h4><p>当然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：謝るのが当然だ。</span><br><span class="line">译：道歉是应当的。</span><br></pre></td></tr></table></figure><h4 id="ときどき"><a href="#ときどき" class="headerlink" title="ときどき"></a>ときどき</h4><p>偶尔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ときどき外食する。</span><br><span class="line">译：偶尔再外面吃饭。</span><br></pre></td></tr></table></figure><h4 id="とても"><a href="#とても" class="headerlink" title="とても"></a>とても</h4><p>非常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日はとても寒いです。</span><br><span class="line">译：今天非常的冷呀。</span><br></pre></td></tr></table></figure><h4 id="とにかく"><a href="#とにかく" class="headerlink" title="とにかく"></a>とにかく</h4><p>总之</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：とにかく仕事を続けたくない。</span><br><span class="line">译：总之我不想继续工作了。</span><br></pre></td></tr></table></figure><h4 id="ともに"><a href="#ともに" class="headerlink" title="ともに"></a>ともに</h4><p>一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：学友とともに恩師を訪ねる。 </span><br><span class="line">译：和学友一同访问恩师。</span><br></pre></td></tr></table></figure><p>同时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：残念であるとともに、くやしくも思う。</span><br><span class="line">译：感到遗憾的同时，也很悔恨。</span><br></pre></td></tr></table></figure><h4 id="どうぞ"><a href="#どうぞ" class="headerlink" title="どうぞ"></a>どうぞ</h4><p>请</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はい，どうぞ。</span><br><span class="line">译：请。</span><br></pre></td></tr></table></figure><p>礼貌用语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうぞよろしく。</span><br><span class="line">译：请多关照。</span><br></pre></td></tr></table></figure><h4 id="特に（とくに）"><a href="#特に（とくに）" class="headerlink" title="特に（とくに）"></a>特に（とくに）</h4><p>特别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：特に注意すべき点。</span><br><span class="line">译：应特别注意的地方。</span><br></pre></td></tr></table></figure><h3 id="な"><a href="#な" class="headerlink" title="な"></a>な</h3><h4 id="なお"><a href="#なお" class="headerlink" title="なお"></a>なお</h4><p>更加，愈发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：薬を飲んで、なお悪くなった。</span><br><span class="line">译：吃了药更加不好了。</span><br></pre></td></tr></table></figure><p>犹，尚，还，仍然，依然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今もなお夢中している。</span><br><span class="line">译：现在也仍然非常热衷。</span><br></pre></td></tr></table></figure><p>此外（接续）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なお、詳しいことは後で話します。</span><br><span class="line">译：此外，具体事宜稍后再谈。</span><br></pre></td></tr></table></figure><h4 id="なかなか"><a href="#なかなか" class="headerlink" title="なかなか"></a>なかなか</h4><p>后接形容词时表肯定：相当<br>后接动词ない型时：轻易(不)，怎么也….，表示动作很难完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：去年の冬はなかなか寒かったですね。</span><br><span class="line">译：去年冬天相当的冷呀。</span><br><span class="line"></span><br><span class="line">例：なかなか怒らない。</span><br><span class="line">译：轻易不生气。</span><br></pre></td></tr></table></figure><h4 id="なるべく"><a href="#なるべく" class="headerlink" title="なるべく"></a>なるべく</h4><p>尽量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なるべくなら明日来ていただけませんか。</span><br><span class="line">译：可能的话，请明天来怎么样？</span><br></pre></td></tr></table></figure><h4 id="なるほど"><a href="#なるほど" class="headerlink" title="なるほど"></a>なるほど</h4><p>诚然，的确；果然；怪不得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なるほど美しい人だ。</span><br><span class="line">译：的确是个美人。</span><br></pre></td></tr></table></figure><h4 id="なんとなく"><a href="#なんとなく" class="headerlink" title="なんとなく"></a>なんとなく</h4><p>不知为何，总觉得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：先輩の前では、なんとなく気兼ねする。</span><br><span class="line">译：在老前辈面前总觉得拘束。</span><br></pre></td></tr></table></figure><p>无意中，不自主地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なんとなく、口を滑らせてしまった。</span><br><span class="line">译：无意中说漏了嘴。</span><br></pre></td></tr></table></figure><h3 id="は"><a href="#は" class="headerlink" title="は"></a>は</h3><h4 id="はっきり"><a href="#はっきり" class="headerlink" title="はっきり"></a>はっきり</h4><p>清楚；明白</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はっきりと見える。</span><br><span class="line">译：清晰可见。</span><br></pre></td></tr></table></figure><h4 id="ばらばら"><a href="#ばらばら" class="headerlink" title="ばらばら"></a>ばらばら</h4><p>零散；散乱（形容动词）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ばらばらの髪の毛。</span><br><span class="line">译：披散的头发。</span><br></pre></td></tr></table></figure><p>忽地跳出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：悪漢共がばらばらと現れた。</span><br><span class="line">译：坏蛋们忽地跳了出来。</span><br></pre></td></tr></table></figure><p>哗啦啦的雨声</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大粒の雨がばらばらと降り出した。</span><br><span class="line">译：大雨点哗啦哗啦地下了起来。</span><br></pre></td></tr></table></figure><h3 id="ひ"><a href="#ひ" class="headerlink" title="ひ"></a>ひ</h3><h4 id="非常に（ひじょうに）"><a href="#非常に（ひじょうに）" class="headerlink" title="非常に（ひじょうに）"></a>非常に（ひじょうに）</h4><p>非常地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：血糖値が非常に高い。</span><br><span class="line">译：血糖值非常高。</span><br></pre></td></tr></table></figure><h4 id="びっくり"><a href="#びっくり" class="headerlink" title="びっくり"></a>びっくり</h4><p>吓一跳；吃惊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：びっくり仰天する。</span><br><span class="line">译：大吃一惊。</span><br></pre></td></tr></table></figure><h3 id="ほ"><a href="#ほ" class="headerlink" title="ほ"></a>ほ</h3><h4 id="ほとんど"><a href="#ほとんど" class="headerlink" title="ほとんど"></a>ほとんど</h4><p>几乎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ほとんど眠れなかった。</span><br><span class="line">译：几乎没有睡。</span><br></pre></td></tr></table></figure><p>大部分；大概；大致；大体上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：古い建物はほとんど取り払われた。</span><br><span class="line">译：旧房子差不多都拆掉了。</span><br></pre></td></tr></table></figure><h3 id="ま"><a href="#ま" class="headerlink" title="ま"></a>ま</h3><h4 id="まあまあ"><a href="#まあまあ" class="headerlink" title="まあまあ"></a>まあまあ</h4><p>一般般，尚可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まあまあいいだろう。</span><br><span class="line">译：还算可以吧。</span><br></pre></td></tr></table></figure><h4 id="また"><a href="#また" class="headerlink" title="また"></a>また</h4><p>又；再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：またにしましょう。</span><br><span class="line">译：改天再说〔去,来,做〕吧；下次再说吧！</span><br></pre></td></tr></table></figure><h4 id="まだ"><a href="#まだ" class="headerlink" title="まだ"></a>まだ</h4><p>还</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ完成していない。</span><br><span class="line">译：尚未完成。</span><br></pre></td></tr></table></figure><p>还，仍旧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ会議中だ。</span><br><span class="line">译：会议还在进行中。</span><br></pre></td></tr></table></figure><p>才，仅，刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ作ったばかりだ。</span><br><span class="line">译：刚刚做完。</span><br></pre></td></tr></table></figure><p>还，更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：理由はまだある。</span><br><span class="line">译：理由还有。</span><br></pre></td></tr></table></figure><p>还，还好，还算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このほうがまだましだ。</span><br><span class="line">译：这样还算好。</span><br></pre></td></tr></table></figure><h4 id="まっすぐ"><a href="#まっすぐ" class="headerlink" title="まっすぐ"></a>まっすぐ</h4><p>笔直；径直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに見る。</span><br><span class="line">译：直向前看。</span><br></pre></td></tr></table></figure><p>一直；照直；不绕弯；直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに家に帰る。</span><br><span class="line">译：直接回家。</span><br></pre></td></tr></table></figure><p>正直；坦率；耿直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに白状する。</span><br><span class="line">译：老实供认；坦白交代。</span><br></pre></td></tr></table></figure><h4 id="まったく"><a href="#まったく" class="headerlink" title="まったく"></a>まったく</h4><p>完全地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まったく健康になった。</span><br><span class="line">译：完全康复。</span><br></pre></td></tr></table></figure><p>全然；完全（否定）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お酒はまったく飲まない。</span><br><span class="line">译：全然不喝酒。</span><br></pre></td></tr></table></figure><p>真，实在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まったく困ったものだ。</span><br><span class="line">译：真难办。</span><br></pre></td></tr></table></figure><h4 id="ますます"><a href="#ますます" class="headerlink" title="ますます"></a>ますます</h4><p>越来越……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ますます元気になった。</span><br><span class="line">译：越来越有精神了。</span><br></pre></td></tr></table></figure><h4 id="間も無く（まもなく）"><a href="#間も無く（まもなく）" class="headerlink" title="間も無く（まもなく）"></a>間も無く（まもなく）</h4><p>马上就要……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：間も無く春休みがやって来る。</span><br><span class="line">译：春假不久就会来到。</span><br></pre></td></tr></table></figure><h4 id="まるで"><a href="#まるで" class="headerlink" title="まるで"></a>まるで</h4><p>简直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まるで違う。</span><br><span class="line">译：完全不一样。</span><br></pre></td></tr></table></figure><p>好像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まるで夢のようだ。</span><br><span class="line">译：好像做梦一样。</span><br></pre></td></tr></table></figure><h3 id="め"><a href="#め" class="headerlink" title="め"></a>め</h3><h4 id="めったに"><a href="#めったに" class="headerlink" title="めったに"></a>めったに</h4><p>（后接否定）几乎（不）……很（少），（不）常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：めったに怒らない。</span><br><span class="line">译：很少发火。</span><br></pre></td></tr></table></figure><h4 id="めっきり"><a href="#めっきり" class="headerlink" title="めっきり"></a>めっきり</h4><p>显著，急剧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病人はめっきりよくなってきた。</span><br><span class="line">译：病人明显好转了。</span><br></pre></td></tr></table></figure><h3 id="も"><a href="#も" class="headerlink" title="も"></a>も</h3><h4 id="もう"><a href="#もう" class="headerlink" title="もう"></a>もう</h4><p>已经</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：当地に来てもう半月になった。</span><br><span class="line">译：来到此地已经半个月了。</span><br></pre></td></tr></table></figure><h4 id="もし"><a href="#もし" class="headerlink" title="もし"></a>もし</h4><p>如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：もし彼が来たら，またせておいてください。</span><br><span class="line">译：要是他来了，请让他等一下。</span><br></pre></td></tr></table></figure><h4 id="もっと"><a href="#もっと" class="headerlink" title="もっと"></a>もっと</h4><p>更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：リンゴをもっとください。</span><br><span class="line">译：再给些苹果吧。</span><br></pre></td></tr></table></figure><h4 id="最も（もっとも）"><a href="#最も（もっとも）" class="headerlink" title="最も（もっとも）"></a>最も（もっとも）</h4><p>最</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：最もよい。</span><br><span class="line">译：最好。</span><br></pre></td></tr></table></figure><h3 id="や"><a href="#や" class="headerlink" title="や"></a>や</h3><h4 id="やがて"><a href="#やがて" class="headerlink" title="やがて"></a>やがて</h4><p>不久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やがて夜になった。</span><br><span class="line">译：天不久就黑了。</span><br></pre></td></tr></table></figure><p>大约，大致，差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やがて小１時間になる。</span><br><span class="line">译：差不多过了一个小时。</span><br></pre></td></tr></table></figure><h4 id="約（やく）"><a href="#約（やく）" class="headerlink" title="約（やく）"></a>約（やく）</h4><p>大约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：約4時間。</span><br><span class="line">译：约四小时。</span><br></pre></td></tr></table></figure><h4 id="やっと"><a href="#やっと" class="headerlink" title="やっと"></a>やっと</h4><p>好不容易；终于；总算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：終電にやっと間に合った。</span><br><span class="line">译：好不容易赶上了末班电车。</span><br></pre></td></tr></table></figure><p>勉勉强强；刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やっとでき上がった。</span><br><span class="line">译：好不容易才完成了。</span><br></pre></td></tr></table></figure><h4 id="やはり"><a href="#やはり" class="headerlink" title="やはり"></a>やはり</h4><p>果然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：注意したが、やはりミスがある。</span><br><span class="line">译：虽然注意了，但还是有错。</span><br></pre></td></tr></table></figure><p>虽然…仍旧…。归根到底仍然是最初预测的结论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やはり女がいた。 </span><br><span class="line">译：果然在外边有了女人。</span><br></pre></td></tr></table></figure><p>依然，仍旧。情况和以前一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今でも、やはり昔のままになっている。 </span><br><span class="line">译：即使到了现在，（它）仍旧保留着原来的风貌。</span><br></pre></td></tr></table></figure><h3 id="ゆ"><a href="#ゆ" class="headerlink" title="ゆ"></a>ゆ</h3><h4 id="ゆっくり"><a href="#ゆっくり" class="headerlink" title="ゆっくり"></a>ゆっくり</h4><p>慢慢地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ご飯をゆっくり食べる。</span><br><span class="line">译：慢慢地吃饭。</span><br></pre></td></tr></table></figure><p>有余地，宽敞舒适，充裕，舒畅，安静，舒适</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いまからでもゆっくり間に合う。</span><br><span class="line">译：即使从现在起也还来得及。</span><br></pre></td></tr></table></figure><h3 id="よ"><a href="#よ" class="headerlink" title="よ"></a>よ</h3><h4 id="ようやく"><a href="#ようやく" class="headerlink" title="ようやく"></a>ようやく</h4><p>终于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく試験が終わった。</span><br><span class="line">译：考试终于结束了。</span><br></pre></td></tr></table></figure><p>勉强，好不容易，总算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく間に合った。</span><br><span class="line">译：总算赶上了。</span><br></pre></td></tr></table></figure><p>渐渐，逐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく春らしくなってきた。</span><br><span class="line">译：渐渐有点春意了。</span><br></pre></td></tr></table></figure><h4 id="よほど"><a href="#よほど" class="headerlink" title="よほど"></a>よほど</h4><p>很，颇，相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：よほど自信があるのだろう。</span><br><span class="line">译：很有自信吧！</span><br></pre></td></tr></table></figure><p>差一点就…..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：よほど帰ろうかと思った。</span><br><span class="line">译：差点想回去。</span><br></pre></td></tr></table></figure><h3 id="わ"><a href="#わ" class="headerlink" title="わ"></a>わ</h3><h4 id="割合（わりあい）"><a href="#割合（わりあい）" class="headerlink" title="割合（わりあい）"></a>割合（わりあい）</h4><p>比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この子は割合と勉強する。</span><br><span class="line">译：这个孩子比较用功。</span><br></pre></td></tr></table></figure><h4 id="わざと"><a href="#わざと" class="headerlink" title="わざと"></a>わざと</h4><p>故意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わざと聞こえないふりにする。</span><br><span class="line">译：故意装作听不见。</span><br></pre></td></tr></table></figure><h4 id="わざわざ"><a href="#わざわざ" class="headerlink" title="わざわざ"></a>わざわざ</h4><p>特意地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そのために、わざわざ来たのだ。 </span><br><span class="line">译：为此特意过来的。</span><br></pre></td></tr></table></figure><p>故意地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わざわざいたずら書きをする。</span><br><span class="line">译：故意乱涂乱画。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之(形助副)词&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-动词变形</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/"/>
    <id>/2024/06/11/日语-动词变形/</id>
    <published>2024-06-11T03:09:46.000Z</published>
    <updated>2024-06-11T03:25:52.011Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之动词变形<br><a id="more"></a></p><h1 id="ます形"><a href="#ます形" class="headerlink" title="ます形"></a>ます形</h1><h2 id="变形规则："><a href="#变形规则：" class="headerlink" title="变形规则："></a>变形规则：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　い段＋ます</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ます</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　きます</span><br><span class="line">  サ变动词：する　ー＞　します</span><br></pre></td></tr></table></figure><h2 id="文法："><a href="#文法：" class="headerlink" title="文法："></a>文法：</h2><h3 id="1-ます形本身就是动词的敬语形态"><a href="#1-ます形本身就是动词的敬语形态" class="headerlink" title="1. ます形本身就是动词的敬语形态"></a>1. ます形本身就是动词的敬语形态</h3><h3 id="2-ますー＞ましょう-ましょうか-劝诱-积极主动为对方做某事"><a href="#2-ますー＞ましょう-ましょうか-劝诱-积极主动为对方做某事" class="headerlink" title="2. ますー＞ましょう/ましょうか　劝诱/积极主动为对方做某事"></a>2. ますー＞ましょう/ましょうか　劝诱/积极主动为对方做某事</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：一緒にビールを飲みましょ！</span><br><span class="line">译：一起去喝啤酒吧！</span><br><span class="line"></span><br><span class="line">例：傘を貸しましょうか？</span><br><span class="line">译：可以把伞借给我吗？</span><br></pre></td></tr></table></figure><h3 id="3-ますー＞ませんか-更有礼貌的询问对方"><a href="#3-ますー＞ませんか-更有礼貌的询问对方" class="headerlink" title="3. ますー＞ませんか　更有礼貌的询问对方"></a>3. ますー＞ませんか　更有礼貌的询问对方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あのシャツはありませんか？</span><br><span class="line">译：那件衬衫还有吗？</span><br></pre></td></tr></table></figure><h3 id="4-ます形可直接修饰名词"><a href="#4-ます形可直接修饰名词" class="headerlink" title="4. ます形可直接修饰名词"></a>4. ます形可直接修饰名词</h3><ul><li>做……的方法 ます形+方（かた）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：漢字の読み方</span><br><span class="line">译：汉字的读法</span><br></pre></td></tr></table></figure><h3 id="5-ます形＋ながら＋句子2-一边做……一般做……强调后面的动作"><a href="#5-ます形＋ながら＋句子2-一边做……一般做……强调后面的动作" class="headerlink" title="5. ます形＋ながら＋句子2  一边做……一般做……强调后面的动作"></a>5. ます形＋ながら＋句子2  一边做……一般做……强调后面的动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：音楽を聴きながら食事します。</span><br><span class="line">译：一边听音乐一边吃饭。</span><br></pre></td></tr></table></figure><h3 id="6-ます形-形容词去い-形容动词＋すぎる-过度做……-超过许可范围-不好的事情"><a href="#6-ます形-形容词去い-形容动词＋すぎる-过度做……-超过许可范围-不好的事情" class="headerlink" title="6. ます形/形容词去い/形容动词＋すぎる　过度做……, 超过许可范围, 不好的事情"></a>6. ます形/形容词去い/形容动词＋すぎる　过度做……, 超过许可范围, 不好的事情</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：働きすぎる。</span><br><span class="line">译：过度工作</span><br><span class="line"></span><br><span class="line">例：最近の車は操作が簡単すぎて、運転がおもしくないです。</span><br><span class="line">译：最近的车操作起来太简单了，都没有驾驶乐趣了。</span><br></pre></td></tr></table></figure><h3 id="7-ます形-形容词去い-形容动词＋そうです-样态助动词-看起来好像……"><a href="#7-ます形-形容词去い-形容动词＋そうです-样态助动词-看起来好像……" class="headerlink" title="7. ます形/形容词去い/形容动词＋そうです(样态助动词)　看起来好像……"></a>7. ます形/形容词去い/形容动词＋そうです(样态助动词)　看起来好像……</h3><p><em>特殊变形词语: いいー＞よさ　ないー＞なさ</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：今にも雨が降りそうです。</span><br><span class="line">译：今天看起好像要下雨了。</span><br><span class="line"></span><br><span class="line">例：その料理は辛そうです。</span><br><span class="line">译：这个料理看起来很辣的样子。</span><br><span class="line"></span><br><span class="line">例：この机は丈夫そうです。</span><br><span class="line">译：这张桌子看起来很结实。</span><br></pre></td></tr></table></figure><h3 id="8-ます形＋やすいです-客观觉得容易……"><a href="#8-ます形＋やすいです-客观觉得容易……" class="headerlink" title="8. ます形＋やすいです　客观觉得容易……"></a>8. ます形＋やすいです　客观觉得容易……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このパソコンは使いやすいです。</span><br><span class="line">译：这台电脑很容易使用。</span><br></pre></td></tr></table></figure><h3 id="9-ます形＋にくいです-客观觉得难……"><a href="#9-ます形＋にくいです-客观觉得难……" class="headerlink" title="9. ます形＋にくいです　客观觉得难……"></a>9. ます形＋にくいです　客观觉得难……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このカープは割れにくくて、安全ですよ。</span><br><span class="line">译：这个杯子很难裂开，很安全哟。</span><br></pre></td></tr></table></figure><h3 id="10-ます形＋がたいです-主观觉得难……-认知类-说话类的词语-书面语"><a href="#10-ます形＋がたいです-主观觉得难……-认知类-说话类的词语-书面语" class="headerlink" title="10. ます形＋がたいです　主观觉得难……　(认知类, 说话类的词语, 书面语)"></a>10. ます形＋がたいです　主观觉得难……　(认知类, 说话类的词语, 书面语)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この宿題はやりがたいです。</span><br><span class="line">译：这道题做起来很难。</span><br></pre></td></tr></table></figure><h3 id="11-ます形＋かねる-难以……-郑重书面语-与敬语连用"><a href="#11-ます形＋かねる-难以……-郑重书面语-与敬语连用" class="headerlink" title="11. ます形＋かねる　难以……　(郑重书面语, 与敬语连用)"></a>11. ます形＋かねる　难以……　(郑重书面语, 与敬语连用)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと断りかねる</span><br><span class="line">译：难以拒绝</span><br></pre></td></tr></table></figure><h1 id="た形"><a href="#た形" class="headerlink" title="た形"></a>た形</h1><h2 id="变形规则"><a href="#变形规则" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">    く、ぐ　ー＞　いた、いだ</span><br><span class="line">        特例：いく　ー＞　行った</span><br><span class="line">    う、つ、る　ー＞　った</span><br><span class="line">    ぬ、ぶ、む　ー＞　んだ</span><br><span class="line">    す　ー＞　した</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋た</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　きた</span><br><span class="line">    サ变动次：する　ー＞　した</span><br><span class="line"></span><br><span class="line">形容词：去掉 い+かった</span><br><span class="line">    ~かったり、～かったりです　既……又……</span><br><span class="line"></span><br><span class="line">形容动词：词语+だった</span><br><span class="line">    ~だったり、～だったりです　既……又……</span><br></pre></td></tr></table></figure><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h3 id="1-动词-形容词-形容动词的た形表示动词的简体过去式"><a href="#1-动词-形容词-形容动词的た形表示动词的简体过去式" class="headerlink" title="1. 动词/形容词/形容动词的た形表示动词的简体过去式"></a>1. 动词/形容词/形容动词的た形表示动词的简体过去式</h3><h3 id="2-～たことがあります-有过……的经历"><a href="#2-～たことがあります-有过……的经历" class="headerlink" title="2. ～たことがあります　有过……的经历"></a>2. ～たことがあります　有过……的经历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は日本へ行ったことがあります。</span><br><span class="line">译：我去过日本。</span><br></pre></td></tr></table></figure><h3 id="3-～たり、～たり-交替，反复的动作"><a href="#3-～たり、～たり-交替，反复的动作" class="headerlink" title="3. ～たり、～たり　交替，反复的动作"></a>3. ～たり、～たり　交替，反复的动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は歌ったり、ダンスしたりこができます。</span><br><span class="line">译：我可以边唱歌边跳舞。</span><br></pre></td></tr></table></figure><h3 id="4-疑问词＋～たらいいですか-做……才好呢？"><a href="#4-疑问词＋～たらいいですか-做……才好呢？" class="headerlink" title="4. 疑问词＋～たらいいですか　做……才好呢？"></a>4. 疑问词＋～たらいいですか　做……才好呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうしたらいいですか？</span><br><span class="line">译：怎么做才好呢？</span><br></pre></td></tr></table></figure><h3 id="5-～たら、～-如果……就……"><a href="#5-～たら、～-如果……就……" class="headerlink" title="5. ～たら、～　如果……就……"></a>5. ～たら、～　如果……就……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：雨が降ったら、行きません。</span><br><span class="line">译：如果下雨了，就不去了。</span><br></pre></td></tr></table></figure><h3 id="6-～た＋ばかりです-刚刚做了，比ところです更长的时间但是是主观觉得时间短"><a href="#6-～た＋ばかりです-刚刚做了，比ところです更长的时间但是是主观觉得时间短" class="headerlink" title="6. ～た＋ばかりです　刚刚做了，比ところです更长的时间但是是主观觉得时间短"></a>6. ～た＋ばかりです　刚刚做了，比ところです更长的时间但是是主观觉得时间短</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は3月に大学を卒業したばかりです。</span><br><span class="line">译：他3月份才刚刚从大学毕业。</span><br></pre></td></tr></table></figure><h1 id="て形"><a href="#て形" class="headerlink" title="て形"></a>て形</h1><h2 id="变形规则-1"><a href="#变形规则-1" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">    く、ぐ　ー＞　いて、いで</span><br><span class="line">        特例：いく　ー＞　行って</span><br><span class="line">    う、つ、る　ー＞　って</span><br><span class="line">    ぬ、ぶ、む　ー＞　んで</span><br><span class="line">    す　ー＞　して</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋て</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　きて</span><br><span class="line">    サ变动次：する　ー＞　して</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋くて</span><br><span class="line"></span><br><span class="line">形容动词和名词：～＋で</span><br></pre></td></tr></table></figure><h2 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h2><h3 id="1-～てください-请……（轻微的命令）"><a href="#1-～てください-请……（轻微的命令）" class="headerlink" title="1. ～てください　请……（轻微的命令）"></a>1. ～てください　请……（轻微的命令）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やめてください。</span><br><span class="line">译：请不要这么做！</span><br></pre></td></tr></table></figure><h3 id="2-～てもいいです-可以做……"><a href="#2-～てもいいです-可以做……" class="headerlink" title="2. ～てもいいです　可以做……"></a>2. ～てもいいです　可以做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：食べていいです。</span><br><span class="line">译：可以吃掉。</span><br></pre></td></tr></table></figure><h3 id="3-～てはいけません-不可以做……"><a href="#3-～てはいけません-不可以做……" class="headerlink" title="3. ～てはいけません　不可以做……"></a>3. ～てはいけません　不可以做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いま伝染病時から、旅行してはいけません。</span><br><span class="line">译：因为现在是疫情时期，不可以去旅行。</span><br></pre></td></tr></table></figure><h3 id="4-～ています"><a href="#4-～ています" class="headerlink" title="4. ～ています"></a>4. ～ています</h3><h4 id="4-1-正在做某事"><a href="#4-1-正在做某事" class="headerlink" title="4.1 正在做某事"></a>4.1 正在做某事</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ゲームしています。</span><br><span class="line">译：正在打游戏。</span><br></pre></td></tr></table></figure><h4 id="4-2-表示状态（结婚，认识某人，住在，有等）"><a href="#4-2-表示状态（结婚，认识某人，住在，有等）" class="headerlink" title="4.2 表示状态（结婚，认识某人，住在，有等）"></a>4.2 表示状态（结婚，认识某人，住在，有等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今大阪に住んでいます。</span><br><span class="line">译：目前我住在大版。</span><br></pre></td></tr></table></figure><h4 id="4-3-反复进行的动作或习惯（学习，工作等）"><a href="#4-3-反复进行的动作或习惯（学习，工作等）" class="headerlink" title="4.3 反复进行的动作或习惯（学习，工作等）"></a>4.3 反复进行的动作或习惯（学习，工作等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：勉強しています</span><br><span class="line">译：学习中……</span><br></pre></td></tr></table></figure><h3 id="5-～てあげます-为别人做……（我或我方为第三方做事情）"><a href="#5-～てあげます-为别人做……（我或我方为第三方做事情）" class="headerlink" title="5. ～てあげます　为别人做……（我或我方为第三方做事情）"></a>5. ～てあげます　为别人做……（我或我方为第三方做事情）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="5-1-比自己地位低的人，动物，植物可以用-やります"><a href="#5-1-比自己地位低的人，动物，植物可以用-やります" class="headerlink" title="5.1 比自己地位低的人，动物，植物可以用　やります"></a>5.1 比自己地位低的人，动物，植物可以用　やります</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="5-2-比自己地位高的人，可以用-あしあげます"><a href="#5-2-比自己地位高的人，可以用-あしあげます" class="headerlink" title="5.2 比自己地位高的人，可以用　あしあげます"></a>5.2 比自己地位高的人，可以用　あしあげます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="6-～てもらいます-主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）"><a href="#6-～てもらいます-主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）" class="headerlink" title="6. ～てもらいます　主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）"></a>6. ～てもらいます　主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="6-1-比自己地位高的人，可以用-～ていただきます"><a href="#6-1-比自己地位高的人，可以用-～ていただきます" class="headerlink" title="6.1 比自己地位高的人，可以用　～ていただきます"></a>6.1 比自己地位高的人，可以用　～ていただきます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="7-～てくれます-别人主动为我做……（别人为我或我方做事情，别人主动为我做）"><a href="#7-～てくれます-别人主动为我做……（别人为我或我方做事情，别人主动为我做）" class="headerlink" title="7. ～てくれます　别人主动为我做……（别人为我或我方做事情，别人主动为我做）"></a>7. ～てくれます　别人主动为我做……（别人为我或我方做事情，别人主动为我做）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="7-1-比自己地位高的人，可以用-～てくださいます"><a href="#7-1-比自己地位高的人，可以用-～てくださいます" class="headerlink" title="7.1 比自己地位高的人，可以用　～てくださいます"></a>7.1 比自己地位高的人，可以用　～てくださいます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="7-2-～てくださいませんか-超级有礼貌的表达方式"><a href="#7-2-～てくださいませんか-超级有礼貌的表达方式" class="headerlink" title="7.2 ～てくださいませんか　超级有礼貌的表达方式"></a>7.2 ～てくださいませんか　超级有礼貌的表达方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="7-3-～ていただけませんか-能帮我做……吗？"><a href="#7-3-～ていただけませんか-能帮我做……吗？" class="headerlink" title="7.3 ～ていただけませんか　能帮我做……吗？"></a>7.3 ～ていただけませんか　能帮我做……吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="8-～ても～-即使……也……"><a href="#8-～ても～-即使……也……" class="headerlink" title="8. ～ても～　即使……也……"></a>8. ～ても～　即使……也……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やっても、無理です。</span><br><span class="line">译：即使做了，也不行了。</span><br></pre></td></tr></table></figure><h3 id="9-～てしまいます-表示下决心、将来完成"><a href="#9-～てしまいます-表示下决心、将来完成" class="headerlink" title="9. ～てしまいます　表示下决心、将来完成"></a>9. ～てしまいます　表示下决心、将来完成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：昼ご飯までにレポートを書いてしまいます。</span><br><span class="line">译：我要在午饭前把报告写完。</span><br></pre></td></tr></table></figure><h3 id="10-～てしまいました"><a href="#10-～てしまいました" class="headerlink" title="10. ～てしまいました"></a>10. ～てしまいました</h3><h4 id="10-1-强调某个行为已经全部完成了"><a href="#10-1-强调某个行为已经全部完成了" class="headerlink" title="10.1. 强调某个行为已经全部完成了"></a>10.1. 强调某个行为已经全部完成了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：漢字の宿題はもうやってしまいました。</span><br><span class="line">译：汉字的作业已经全部做完了。</span><br></pre></td></tr></table></figure><h4 id="10-2-为难状态下的困惑，后悔（发生了不好的事情）"><a href="#10-2-为难状态下的困惑，后悔（发生了不好的事情）" class="headerlink" title="10.2. 为难状态下的困惑，后悔（发生了不好的事情）"></a>10.2. 为难状态下的困惑，后悔（发生了不好的事情）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：パスポートをなくしてしまいました。</span><br><span class="line">译：护照弄丢了。</span><br></pre></td></tr></table></figure><h3 id="11-～てあります"><a href="#11-～てあります" class="headerlink" title="11. ～てあります"></a>11. ～てあります</h3><h4 id="11-1-表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）"><a href="#11-1-表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）" class="headerlink" title="11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）"></a>11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：机の上にメモが置いてあります。</span><br><span class="line">译：桌子上放着笔记本。</span><br></pre></td></tr></table></figure><h4 id="11-2-表示状态时和ています的区别"><a href="#11-2-表示状态时和ています的区别" class="headerlink" title="11.2. 表示状态时和ています的区别"></a>11.2. 表示状态时和ています的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动词，强调窗户的状态</span><br><span class="line">例：窓が閉まっています。</span><br><span class="line">译：窗户关闭着。</span><br><span class="line"></span><br><span class="line">他动词，强调不知道被谁关了窗户这件事的结果</span><br><span class="line">例：窓が閉めてあります</span><br><span class="line">译：窗户关闭着</span><br></pre></td></tr></table></figure><h4 id="11-3-表示为将来提前做准备"><a href="#11-3-表示为将来提前做准备" class="headerlink" title="11.3. 表示为将来提前做准备"></a>11.3. 表示为将来提前做准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：誕生日のプレゼントはもう買ってあります。</span><br><span class="line">译：生日礼物已经买好了。</span><br></pre></td></tr></table></figure><h3 id="12-～ておきます"><a href="#12-～ておきます" class="headerlink" title="12. ～ておきます"></a>12. ～ておきます</h3><h4 id="12-1-做某件事之前必要做的事情"><a href="#12-1-做某件事之前必要做的事情" class="headerlink" title="12.1. 做某件事之前必要做的事情"></a>12.1. 做某件事之前必要做的事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：旅行の前に切符を買っておきます。</span><br><span class="line">译：旅行之前要把票买好。</span><br></pre></td></tr></table></figure><h4 id="12-2-为下次使用而完成必要的动作"><a href="#12-2-为下次使用而完成必要的动作" class="headerlink" title="12.2. 为下次使用而完成必要的动作"></a>12.2. 为下次使用而完成必要的动作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はさみを使ったら、元の所に戻して置いてください。</span><br><span class="line">译：用完剪刀后，请放回原来的地方。</span><br></pre></td></tr></table></figure><h4 id="12-3-让状态持续下去"><a href="#12-3-让状态持续下去" class="headerlink" title="12.3. 让状态持续下去"></a>12.3. 让状态持续下去</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日会議がありますから、いすはこのままにして置いてください。</span><br><span class="line">译：明天还有会议，椅子就这样保持下去吧。</span><br></pre></td></tr></table></figure><h4 id="12-4-临时的措施"><a href="#12-4-临时的措施" class="headerlink" title="12.4. 临时的措施"></a>12.4. 临时的措施</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：資料は後で見ておきます、そこに置いといてください。</span><br><span class="line">译：资料之后要看，请放在哪里。</span><br></pre></td></tr></table></figure><h4 id="12-5-～ておきます-ー＞-～ときます（口语）"><a href="#12-5-～ておきます-ー＞-～ときます（口语）" class="headerlink" title="12.5. ～ておきます　ー＞　～ときます（口语）"></a>12.5. ～ておきます　ー＞　～ときます（口语）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そこにおいといてください。</span><br><span class="line">译：请放到那里。</span><br></pre></td></tr></table></figure><h3 id="13-まだ～ていません-事情或者动作还没有发生"><a href="#13-まだ～ていません-事情或者动作还没有发生" class="headerlink" title="13. まだ～ていません　事情或者动作还没有发生"></a>13. まだ～ていません　事情或者动作还没有发生</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：銀行はまだ開いていません。</span><br><span class="line">译：银行还没有开门。</span><br></pre></td></tr></table></figure><h3 id="14-～てみる-试着做……"><a href="#14-～てみる-试着做……" class="headerlink" title="14. ～てみる　试着做……"></a>14. ～てみる　试着做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：も一度考えてみます。</span><br><span class="line">译：在试着思考一次。</span><br><span class="line"></span><br><span class="line">例：このズボンをはいてみてもいいですか。</span><br><span class="line">译：可以试穿一下这条裤子吗？</span><br></pre></td></tr></table></figure><h3 id="15-（て形-ない形-ないで）＋动词2-在动词1的情况下做动词2-有「没有做……而是做……」的意思"><a href="#15-（て形-ない形-ないで）＋动词2-在动词1的情况下做动词2-有「没有做……而是做……」的意思" class="headerlink" title="15. （て形/ない形+ないで）＋动词2  在动词1的情况下做动词2 　有「没有做……而是做……」的意思"></a>15. （て形/ない形+ないで）＋动词2  在动词1的情况下做动词2 　有「没有做……而是做……」的意思</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：醤油を付けて食べます。</span><br><span class="line">译：沾着酱油吃。</span><br><span class="line"></span><br><span class="line">例：醤油を付けないで食べます。</span><br><span class="line">译：不要沾着酱油吃。</span><br><span class="line"></span><br><span class="line">例：日曜日はどこも行かないで、うちでゆっくり休みます。</span><br><span class="line">译：周日哪里也不去，在家里好好休息。</span><br></pre></td></tr></table></figure><h3 id="16-～て来ます"><a href="#16-～て来ます" class="headerlink" title="16. ～て来ます"></a>16. ～て来ます</h3><h4 id="16-1-做某个动作之后再回来-有去去就回的感觉"><a href="#16-1-做某个动作之后再回来-有去去就回的感觉" class="headerlink" title="16.1. 做某个动作之后再回来, 有去去就回的感觉"></a>16.1. 做某个动作之后再回来, 有去去就回的感觉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと煙草を買ってきます。</span><br><span class="line">译：我去买包香烟。</span><br></pre></td></tr></table></figure><h4 id="16-2-有逐渐变化的意思"><a href="#16-2-有逐渐变化的意思" class="headerlink" title="16.2. 有逐渐变化的意思"></a>16.2. 有逐渐变化的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：消えて来ます。</span><br><span class="line">译：慢慢消失了。</span><br></pre></td></tr></table></figure><h1 id="ない形"><a href="#ない形" class="headerlink" title="ない形"></a>ない形</h1><h2 id="变形规则-2"><a href="#变形规则-2" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">う段　ー＞　あ段＋ない</span><br><span class="line">    以う结尾的动词，要去掉う变成わない。買うー＞買わない</span><br><span class="line">    ある的ない形就是ない</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ない</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　来（こ）ない</span><br><span class="line">    サ变动次：する　ー＞　しない</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋くない</span><br><span class="line"></span><br><span class="line">形容动词和名词：～＋では（じゃ）ない</span><br></pre></td></tr></table></figure><h2 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h2><h3 id="1-一般用于否定"><a href="#1-一般用于否定" class="headerlink" title="1. 一般用于否定"></a>1. 一般用于否定</h3><h3 id="2-～ないでください-请不要做……"><a href="#2-～ないでください-请不要做……" class="headerlink" title="2. ～ないでください　请不要做……"></a>2. ～ないでください　请不要做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="3-必须做……"><a href="#3-必须做……" class="headerlink" title="3. 必须做……"></a>3. 必须做……</h3><ul><li>～なければ、なりません</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ul><li>～ないと、いけません</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ul><li>～ないと</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="4-～なくてもいいです-不做……也可以"><a href="#4-～なくてもいいです-不做……也可以" class="headerlink" title="4. ～なくてもいいです　不做……也可以"></a>4. ～なくてもいいです　不做……也可以</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h1 id="可能态"><a href="#可能态" class="headerlink" title="可能态"></a>可能态</h1><h2 id="变形规则-3"><a href="#变形规则-3" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　え段＋る</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋られる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：くる　ー＞　こられる</span><br><span class="line">    サ变动词：する　ー＞　できる</span><br></pre></td></tr></table></figure><h2 id="变化后的词性"><a href="#变化后的词性" class="headerlink" title="变化后的词性"></a>变化后的词性</h2><ul><li>变化之后都是二类动词</li><li>变化之后都是自动词</li></ul><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><h3 id="1-事物的性质"><a href="#1-事物的性质" class="headerlink" title="1.事物的性质"></a>1.事物的性质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この野菜は生で食べらない。</span><br><span class="line">译：这个蔬菜不能生吃。</span><br></pre></td></tr></table></figure><h3 id="2-表示可能性"><a href="#2-表示可能性" class="headerlink" title="2.表示可能性"></a>2.表示可能性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：この事は両親に言えません。</span><br><span class="line">译：这件事不能对父母说。</span><br><span class="line"></span><br><span class="line">例：今は社長に会えません。</span><br><span class="line">译：现在无法会见社长。</span><br><span class="line"></span><br><span class="line">例：事務所の人は誰もそのコンーピュータを使えます。</span><br><span class="line">译：事务所的人谁都不会使用那台电脑。</span><br></pre></td></tr></table></figure><h3 id="3-能力"><a href="#3-能力" class="headerlink" title="3.能力"></a>3.能力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語を話せます。</span><br><span class="line">译：会说日语。</span><br></pre></td></tr></table></figure><h1 id="假定形"><a href="#假定形" class="headerlink" title="假定形"></a>假定形</h1><h2 id="变形规则-4"><a href="#变形规则-4" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段　ー＞　え段＋ば</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋れば</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　くれば</span><br><span class="line">    サ变动次：する　ー＞　すれば</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋ければ</span><br><span class="line"></span><br><span class="line">形容动词和名词：〜＋なら「ば」</span><br></pre></td></tr></table></figure><h2 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h2><h3 id="1-一般条件：一……就……"><a href="#1-一般条件：一……就……" class="headerlink" title="1. 一般条件：一……就……"></a>1. 一般条件：一……就……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いい天気なら、向こうに島が見えます。</span><br><span class="line">译：天气好的话，你可以看到对面的小岛。</span><br></pre></td></tr></table></figure><h3 id="2-假定条件：如果……就……"><a href="#2-假定条件：如果……就……" class="headerlink" title="2. 假定条件：如果……就……"></a>2. 假定条件：如果……就……</h3><blockquote><p>PS: 前句是意志类词语，后句是对听话人提要求的话，只能用たら，たら范围最大。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：時間がなかったら、テレビを見ません。</span><br><span class="line">译：没时间我就不看电视了。</span><br><span class="line"></span><br><span class="line">例：時間がなければ、テレビを見ません。</span><br><span class="line">译：没时间我就不看电视了。</span><br><span class="line"></span><br><span class="line">例：よがったら、助けてもらいますか。</span><br><span class="line">译：可以的话，能帮下忙吗？</span><br></pre></td></tr></table></figure><h3 id="3-名词-なら-可用于对方提出的话题，再提供一些信息"><a href="#3-名词-なら-可用于对方提出的话题，再提供一些信息" class="headerlink" title="3. 名词+なら　可用于对方提出的话题，再提供一些信息"></a>3. 名词+なら　可用于对方提出的话题，再提供一些信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：温泉に行きたいんですが、どこか良い所がありませんか。</span><br><span class="line">译：非常想去泡温泉呀，有什么好地方吗？</span><br><span class="line"></span><br><span class="line">例：温泉なら、白馬がいいですよ。</span><br><span class="line">译：如果是温泉的话，白马县挺不错的哦。</span><br></pre></td></tr></table></figure><h3 id="4-疑问词＋假定形＋いいですか-等同于-〜たらいいですか-怎么做才好呢？"><a href="#4-疑问词＋假定形＋いいですか-等同于-〜たらいいですか-怎么做才好呢？" class="headerlink" title="4. 疑问词＋假定形＋いいですか　等同于　〜たらいいですか　怎么做才好呢？"></a>4. 疑问词＋假定形＋いいですか　等同于　〜たらいいですか　怎么做才好呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：本を借りたいですが、どうすればいいですか。</span><br><span class="line">译：想借本书，怎么做才好呢？</span><br></pre></td></tr></table></figure><h3 id="5-假定形＋连体形＋ほど〜-越……越……"><a href="#5-假定形＋连体形＋ほど〜-越……越……" class="headerlink" title="5. 假定形＋连体形＋ほど〜　越……越……"></a>5. 假定形＋连体形＋ほど〜　越……越……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：パソコンは操作が簡単なら簡単なほどいいです。</span><br><span class="line">译：电脑的操作越简单越好呀。</span><br></pre></td></tr></table></figure><h1 id="被动形"><a href="#被动形" class="headerlink" title="被动形"></a>被动形</h1><h2 id="变形规则-5"><a href="#变形规则-5" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段　ー＞　あ段＋れる</span><br><span class="line"></span><br><span class="line">二类动词：去る＋られる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　来られる</span><br><span class="line">    サ变动次：する　ー＞　される</span><br></pre></td></tr></table></figure><h2 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h2><h3 id="AはBに＋被动形-A被B……"><a href="#AはBに＋被动形-A被B……" class="headerlink" title="AはBに＋被动形　A被B……"></a>AはBに＋被动形　A被B……</h3><blockquote><p>中性，好坏都可表达<br>当A是作品或者发明时，被动形前面要加上よって</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：私は先生に褒められました。</span><br><span class="line">译：我被老师表扬了。</span><br><span class="line"></span><br><span class="line">例：私は犬に噛まれました。</span><br><span class="line">译：我被狗咬了。</span><br><span class="line"></span><br><span class="line">例：電話はベルによって発明されました。</span><br><span class="line">译：电话是被贝尔发明的。</span><br></pre></td></tr></table></figure><h3 id="AはBに＋なにを被动形-A的なに被B……"><a href="#AはBに＋なにを被动形-A的なに被B……" class="headerlink" title="AはBに＋なにを被动形 A的なに被B……"></a>AはBに＋なにを被动形 A的なに被B……</h3><blockquote><p>中性，不好的事情<br>A和~是从属关系（A的~），但是不能直接使用『Aの~』作为主语</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は犬に手を噛まれました。</span><br><span class="line">译：我的手被狗咬了。</span><br></pre></td></tr></table></figure><h1 id="使役态"><a href="#使役态" class="headerlink" title="使役态"></a>使役态</h1><h2 id="变形规则-6"><a href="#变形规则-6" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　あ段＋せる</span><br><span class="line">う结尾　ー＞　わせる</span><br><span class="line"></span><br><span class="line">二类动词：去る＋させる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　こさせる</span><br><span class="line">  サ变动词：する　ー＞　させる</span><br></pre></td></tr></table></figure><h2 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h2><h3 id="～を自动词使役态-让名词（某人）做"><a href="#～を自动词使役态-让名词（某人）做" class="headerlink" title="～を自动词使役态　让名词（某人）做~"></a>～を自动词使役态　让名词（某人）做~</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：息子をイギリスヘ留学させます。 </span><br><span class="line">译：让我的儿子去英国留学。</span><br></pre></td></tr></table></figure><h3 id="～に～を他动词使役态-让名词（某人）做"><a href="#～に～を他动词使役态-让名词（某人）做" class="headerlink" title="～に～を他动词使役态　让名词（某人）做~"></a>～に～を他动词使役态　让名词（某人）做~</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：娘にピアノを習わせます。</span><br><span class="line">译：让女儿学习钢琴</span><br></pre></td></tr></table></figure><h1 id="意志形"><a href="#意志形" class="headerlink" title="意志形"></a>意志形</h1><h2 id="变形规则-7"><a href="#变形规则-7" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　お段＋う</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋よう</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　こよう</span><br><span class="line">  サ变动词：する　ー＞　しよう</span><br></pre></td></tr></table></figure><h2 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h2><h3 id="自己的意志"><a href="#自己的意志" class="headerlink" title="自己的意志"></a>自己的意志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと休まない。</span><br><span class="line">译：要不休息一下？</span><br><span class="line"></span><br><span class="line">例：うん、休もう。</span><br><span class="line">译：嗯，去休息吧！</span><br></pre></td></tr></table></figure><h3 id="劝诱"><a href="#劝诱" class="headerlink" title="劝诱"></a>劝诱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：て伝おうか。</span><br><span class="line">译：能帮我一下吗？</span><br></pre></td></tr></table></figure><h3 id="提议-大家一起做"><a href="#提议-大家一起做" class="headerlink" title="提议(大家一起做)"></a>提议(大家一起做)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：みんなですごし休もうか。</span><br><span class="line">译：大家一起休息一下吧？</span><br></pre></td></tr></table></figure><h3 id="意志形＋とおもっています-很久以前就打算做……"><a href="#意志形＋とおもっています-很久以前就打算做……" class="headerlink" title="意志形＋とおもっています　很久以前就打算做……"></a>意志形＋とおもっています　很久以前就打算做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：週末は海に行こうとおもっています。</span><br><span class="line">译：很久以前就打算周末去海边呢。</span><br></pre></td></tr></table></figure><h3 id="意志形＋とおもいます-刚刚有这样的打算……"><a href="#意志形＋とおもいます-刚刚有这样的打算……" class="headerlink" title="意志形＋とおもいます　刚刚有这样的打算……"></a>意志形＋とおもいます　刚刚有这样的打算……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今から銀行へ行こうとおもいます。</span><br><span class="line">译：我今天才打算去银行。</span><br></pre></td></tr></table></figure><h2 id="敬体"><a href="#敬体" class="headerlink" title="敬体"></a>敬体</h2><h3 id="～ましょう"><a href="#～ましょう" class="headerlink" title="～ましょう"></a>～ましょう</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：休みましょう。</span><br><span class="line">译：休息一下吧！</span><br></pre></td></tr></table></figure><h1 id="命令形"><a href="#命令形" class="headerlink" title="命令形"></a>命令形</h1><h2 id="变形规则-8"><a href="#变形规则-8" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　え段</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ろ</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：くる　ー＞　こい</span><br><span class="line">    サ变动词：する　ー＞　しろ</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h1 id="命令形和禁止形"><a href="#命令形和禁止形" class="headerlink" title="命令形和禁止形"></a>命令形和禁止形</h1><h2 id="变形规则-9"><a href="#变形规则-9" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典形＋な</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之动词变形&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-五十音图</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/"/>
    <id>/2024/06/11/日语-五十音图/</id>
    <published>2024-06-11T03:09:09.000Z</published>
    <updated>2024-06-11T03:25:57.204Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之五十音图发音<br><a id="more"></a></p><h1 id="五十音图"><a href="#五十音图" class="headerlink" title="五十音图"></a>五十音图</h1><h2 id="平假名"><a href="#平假名" class="headerlink" title="平假名"></a>平假名</h2><table><thead><tr><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr><td>あ（a）</td><td>い（i）</td><td>う（u）</td><td>え（e）</td><td>お（o）</td></tr><tr><td>か（ka）</td><td>き（ki）</td><td>く（ku）</td><td>け（ke）</td><td>こ（ko）</td></tr><tr><td>さ（sa）</td><td>し（si）</td><td>す（su）</td><td>せ（se）</td><td>そ（so）</td></tr><tr><td>た（ta）</td><td>ち（chi）</td><td>つ（tsu）</td><td>て（te）</td><td>と（to）</td></tr><tr><td>な（na）</td><td>に（ni）</td><td>ぬ（nu）</td><td>ね（ne）</td><td>の（no）</td></tr><tr><td>は（ha）</td><td>ひ（hi）</td><td>ふ（fu）</td><td>へ（he）</td><td>ほ（ho）</td></tr><tr><td>ま（ma）</td><td>み（mi）</td><td>む（mu）</td><td>め（me）</td><td>も（mo）</td></tr><tr><td>や（ya）</td><td>い（i）</td><td>ゆ（yu）</td><td>え（e）</td><td>よ（yo）</td></tr><tr><td>ら（ra）</td><td>り（ri）</td><td>る（ru）</td><td>れ（re）</td><td>ろ（ro）</td></tr><tr><td>わ（wa）</td><td>い（i）</td><td>う（u）</td><td>え（e）</td><td>を（wo）</td></tr><tr><td>ん（n）</td><td></td><td></td><td></td></tr></tbody></table><h2 id="片假名"><a href="#片假名" class="headerlink" title="片假名"></a>片假名</h2><table><thead><tr><th>ア段</th><th>イ段</th><th>ウ段</th><th>エ段</th><th>オ段</th></tr></thead><tbody><tr><td>ア（a）</td><td>イ（i）</td><td>ウ（u）</td><td>エ（e）</td><td>オ（o）</td></tr><tr><td>カ（ka）</td><td>キ（ki）</td><td>ク（ku）</td><td>ケ（ke）</td><td>コ（ko）</td></tr><tr><td>サ（sa）</td><td>シ（si）</td><td>ス（su）</td><td>セ（se）</td><td>ソ（so）</td></tr><tr><td>タ（ta）</td><td>チ（chi）</td><td>ツ（tsu）</td><td>テ（te）</td><td>ト（to）</td></tr><tr><td>ナ（na）</td><td>ニ（ni）</td><td>ヌ（nu）</td><td>ネ（ne）</td><td>ノ（no）</td></tr><tr><td>ハ（ha）</td><td>ヒ（hi）</td><td>フ（fu）</td><td>ヘ（he）</td><td>ホ（ho）</td></tr><tr><td>マ（ma）</td><td>ミ（mi）</td><td>ム（mu）</td><td>メ（me）</td><td>モ（mo）</td></tr><tr><td>ヤ（ya）</td><td>イ（i）</td><td>ユ（yu）</td><td>エ（e）</td><td>ヨ（yo）</td></tr><tr><td>ラ（ra）</td><td>リ（ri）</td><td>ル（ru）</td><td>レ（re）</td><td>ロ（ro）</td></tr><tr><td>ワ（wa）</td><td>イ（i）</td><td>ウ（u）</td><td>エ（e）</td><td>ヲ（wo）</td></tr><tr><td>ン（n）</td><td></td><td></td><td></td></tr></tbody></table><h2 id="浊音-半浊音"><a href="#浊音-半浊音" class="headerlink" title="浊音/半浊音"></a>浊音/半浊音</h2><table><thead><tr><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr><td>が（ga）</td><td>ぎ（gi）</td><td>ぐ（gu）</td><td>げ（ge）</td><td>ご（go）</td></tr><tr><td>ざ（za）</td><td>じ（ji）</td><td>ず（zu）</td><td>ぜ（ze）</td><td>ぞ（zo）</td></tr><tr><td>だ（da）</td><td>ぢ（ji）</td><td>づ（zu）</td><td>で（ze）</td><td>ど（do）</td></tr><tr><td>ば（ba）</td><td>び（bi）</td><td>ぶ（bu）</td><td>べ（be）</td><td>ぼ（bo）</td></tr><tr><td>ぱ（pa）</td><td>ぴ（pi）</td><td>ぷ（pu）</td><td>ぺ（pe）</td><td>ぽ（po）</td></tr></tbody></table><h2 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h2><table><thead><tr><th>や段</th><th>ゆ段</th><th>よ段</th></tr></thead><tbody><tr><td>きゃ（kya）</td><td>きゅ（kyu）</td><td>きょ（kyo）</td></tr><tr><td>ぎゃ（gya）</td><td>ぎゅ（gyu）</td><td>ぎょ（gyo）</td></tr><tr><td>しゃ（sha）</td><td>しゅ（shu）</td><td>しょ（sho）</td></tr><tr><td>じゃ（ja）</td><td>じゅ（ju）</td><td>じょ（jo）</td></tr><tr><td>ちゃ（cha）</td><td>ちゅ（chu）</td><td>ちょ（cho）</td></tr><tr><td>にゃ（nya）</td><td>にゅ（nyu）</td><td>にょ（nyo）</td></tr><tr><td>ひゃ（hya）</td><td>ひゅ（hyu）</td><td>ひょ（hyo）</td></tr><tr><td>びゃ（bya）</td><td>びゅ（byu）</td><td>びょ（byo）</td></tr><tr><td>ぴゃ（pya）</td><td>ぴゅ（pyu）</td><td>ぴょ（pyu）</td></tr><tr><td>みゃ（mya）</td><td>みゅ（myu）</td><td>みょ（myo）</td></tr><tr><td>りゃ（rya）</td><td>りゅ（ryu）</td><td>りょ（ryo）</td></tr></tbody></table><h2 id="拨音"><a href="#拨音" class="headerlink" title="拨音"></a>拨音</h2><p>ん不出现在词头，ん在其后面发音为n的音</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：反対（はんたい）、新聞（しんぶん）、天気（てんき）</span><br></pre></td></tr></table></figure><h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><p>つ音的主要在两个发音之前停顿一拍，促音与否会影响单词的含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">物価（ぶっか）部下（ぶか）</span><br><span class="line">喝采（かっさい）火災（かさい）</span><br><span class="line">夫（おっと）音（おと）</span><br></pre></td></tr></table></figure><h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><p>长音是两倍母音的发音，长音与否同样也会影响单词的含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">おばあさん（奶奶）、おばさん（阿姨）</span><br><span class="line">お爺（じい）さん（爷爷）、おじさん（叔叔）</span><br><span class="line">雪（ゆき）、勇気（ゆうき）</span><br></pre></td></tr></table></figure><h2 id="音调"><a href="#音调" class="headerlink" title="音调"></a>音调</h2><h3 id="升调"><a href="#升调" class="headerlink" title="升调"></a>升调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庭（に👆わ）</span><br><span class="line">鼻（は👆な）</span><br></pre></td></tr></table></figure><h3 id="降调"><a href="#降调" class="headerlink" title="降调"></a>降调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本（ほ👇ん）</span><br><span class="line">天気（て👇んき）</span><br></pre></td></tr></table></figure><h3 id="词中降调"><a href="#词中降调" class="headerlink" title="词中降调"></a>词中降调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卵（た👆ま👇ご）</span><br><span class="line">飛行機（ひ👆こ👇うき）</span><br></pre></td></tr></table></figure><h3 id="接续降调"><a href="#接续降调" class="headerlink" title="接续降调"></a>接续降调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">靴（くつ👇）</span><br><span class="line">花（はな👇）</span><br></pre></td></tr></table></figure><h3 id="升调和接续降调的区别"><a href="#升调和接续降调的区别" class="headerlink" title="升调和接续降调的区别"></a>升调和接续降调的区别</h3><p>花和鼻发音都一样，但是后面接助词时助词的发音却不一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：花👇が咲く</span><br><span class="line">例：鼻👉が高い</span><br></pre></td></tr></table></figure><p>音调不同词语的意思也有可能不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：橋（はし👇）</span><br><span class="line">例：箸（は👇し）</span><br></pre></td></tr></table></figure><h2 id="语调"><a href="#语调" class="headerlink" title="语调"></a>语调</h2><h3 id="平调"><a href="#平调" class="headerlink" title="平调"></a>平调</h3><p>陈述句一般都是平调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日友達とお花見をします。👉</span><br><span class="line">译：明天和朋友一起去赏花。</span><br></pre></td></tr></table></figure><h3 id="升调-1"><a href="#升调-1" class="headerlink" title="升调"></a>升调</h3><p>疑问句是升调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ミラさんも一緒に行きませんか。👆</span><br><span class="line">译：米勒先生你也一块去吗？</span><br></pre></td></tr></table></figure><h3 id="降调-1"><a href="#降调-1" class="headerlink" title="降调"></a>降调</h3><p>表示同意和失望的语气时也有用降调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ああ、いいですね。👇</span><br><span class="line">译：啊，好的呢！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之五十音图发音&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Three.js基础入门</title>
    <link href="/2024/06/06/Three-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>/2024/06/06/Three-js基础入门/</id>
    <published>2024-06-06T05:59:37.000Z</published>
    <updated>2024-06-06T06:12:46.721Z</updated>
    
    <content type="html"><![CDATA[<p>Three.js基础入门学习<br><a id="more"></a></p><blockquote><p>Three.js是一款开源的主流3D绘图JS引擎（名字Three就是3D的含义），原作者为Mr.Doob。<a href="https://github.com/mrdoob/three.js/" target="_blank" rel="noopener">项目地址为</a><br>Three.js经常会和WebGL混淆， 但也并不总是，three.js其实是使用WebGL来绘制三维效果的。 WebGL是一个只能画点、线和三角形的非常底层的系统. 想要用WebGL来做一些实用的东西通常需要大量的代码， 这就是Three.js的用武之地。它封装了诸如场景、灯光、阴影、材质、贴图、空间运算等一系列功能，让你不必要再从底层WebGL开始写起。</p></blockquote><h2 id="场景Scene"><a href="#场景Scene" class="headerlink" title="场景Scene"></a>场景Scene</h2><p>三维场景Scene (opens new window)对象理解为虚拟的3D场景，用来表示模拟生活中的真实三维场景,或者说三维世界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建3D场景对象Scene</span><br><span class="line">const scene = new THREE.Scene();</span><br></pre></td></tr></table></figure></p><h2 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h2><p>物体 = 几何体 + 材质</p><h3 id="几何体Geometry"><a href="#几何体Geometry" class="headerlink" title="几何体Geometry"></a>几何体Geometry</h3><p><img src="/2024/06/06/Three-js基础入门/1.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个长方体几何对象Geometry</span><br><span class="line">const geometry = new THREE.BoxGeometry(100, 100, 100);</span><br></pre></td></tr></table></figure></p><h3 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h3><p><img src="/2024/06/06/Three-js基础入门/2.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个材质对象Material</span><br><span class="line">const material = new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: 0xff0000, // 0xff0000设置材质颜色为红色</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="网格模型Mesh-物体"><a href="#网格模型Mesh-物体" class="headerlink" title="网格模型Mesh(物体)"></a>网格模型Mesh(物体)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 两个参数分别为几何体geometry、材质material</span><br><span class="line">const mesh = new THREE.Mesh(geometry, material); // 网格模型对象Mesh</span><br><span class="line">// 设置网格模型在三维空间中的位置坐标，默认是坐标原点</span><br><span class="line">mesh.position.set(0,10,0);</span><br><span class="line">// 在threejs中你创建了一个表示物体的虚拟对象Mesh，需要通过.add()方法，把网格模型mesh添加到三维场景scene中。</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><h2 id="摄像机Camera"><a href="#摄像机Camera" class="headerlink" title="摄像机Camera"></a>摄像机Camera</h2><p>Threejs如果想把三维场景Scene渲染到web网页上，还需要定义一个虚拟相机Camera，就像你生活中想获得一张照片，需要一台用来拍照的相机。<br><img src="/2024/06/06/Three-js基础入门/3.png" alt="img"><br>Threejs提供了正投影相机OrthographicCamera和透视投影相机PerspectiveCamera，本次使用比较常用的透视投影相机PerspectiveCamera。</p><h3 id="透视投影相机PerspectiveCamera"><a href="#透视投影相机PerspectiveCamera" class="headerlink" title="透视投影相机PerspectiveCamera"></a>透视投影相机PerspectiveCamera</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)</span><br><span class="line">const width = 800; //宽度</span><br><span class="line">const height = 500; //高度</span><br><span class="line">// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面</span><br><span class="line">const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);</span><br></pre></td></tr></table></figure><p><code>PerspectiveCamera( fov, aspect, near, far )</code></p><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>fov</td><td>相机视锥体竖直方向视野角度</td><td>50</td></tr><tr><td>aspect</td><td>相机视锥体水平方向和竖直方向长度比，一般设置为Canvas画布宽高比width / height</td><td>1</td></tr><tr><td>near</td><td>相机视锥体近裁截面相对相机距离</td><td>0.1</td></tr><tr><td>far</td><td>相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向</td><td>2000</td></tr></tbody></table><h3 id="相机位置-position"><a href="#相机位置-position" class="headerlink" title="相机位置.position"></a>相机位置.position</h3><p>生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs中虚拟相机同样如此。<br>比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。<br>相机对象Camera具有位置属性.position，通过位置属性.position可以设置相机的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相机在Three.js三维坐标系中的位置</span><br><span class="line">// 根据需要设置相机位置具体值</span><br><span class="line">camera.position.set(200, 200, 200);</span><br></pre></td></tr></table></figure></p><h3 id="相机观察目标-lookAt"><a href="#相机观察目标-lookAt" class="headerlink" title="相机观察目标.lookAt()"></a>相机观察目标.lookAt()</h3><p>你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于threejs相机而言，就是设置.lookAt()方法的参数，指定一个3D坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 相机观察目标指向Threejs 3D空间中某个位置</span><br><span class="line">camera.lookAt(0, 0, 0); // 坐标原点</span><br><span class="line">camera.lookAt(0, 10, 0);  // y轴上位置10</span><br><span class="line">camera.lookAt(mesh.position); // 指向mesh对应的位置</span><br></pre></td></tr></table></figure></p><h2 id="渲染器WebGLRenderer"><a href="#渲染器WebGLRenderer" class="headerlink" title="渲染器WebGLRenderer"></a>渲染器WebGLRenderer</h2><h3 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h3><p>通过WebGL渲染器WebGLRenderer可以实例化一个WebGL渲染器对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建渲染器对象</span><br><span class="line">const renderer = new THREE.WebGLRenderer();</span><br></pre></td></tr></table></figure></p><h3 id="设置Canvas画布尺寸-setSize"><a href="#设置Canvas画布尺寸-setSize" class="headerlink" title="设置Canvas画布尺寸.setSize()"></a>设置Canvas画布尺寸.setSize()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义threejs输出画布的尺寸(单位:像素px)</span><br><span class="line">const width = 800; //宽度</span><br><span class="line">const height = 500; //高度</span><br><span class="line">renderer.setSize(width, height); // 设置three.js渲染区域的尺寸(像素px)</span><br></pre></td></tr></table></figure><h3 id="渲染器渲染方法-render"><a href="#渲染器渲染方法-render" class="headerlink" title="渲染器渲染方法.render()"></a>渲染器渲染方法.render()</h3><p>渲染器WebGLRenderer执行渲染方法.render()就可以生成一个Canvas画布(照片)，并把三维场景Scene呈现在canvas画布上面,你可以把.render()理解为相机的拍照动作“咔”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.render(scene, camera); // 执行渲染操作</span><br></pre></td></tr></table></figure></p><h3 id="渲染器Canvas画布属性-domElement"><a href="#渲染器Canvas画布属性-domElement" class="headerlink" title="渲染器Canvas画布属性.domElement"></a>渲染器Canvas画布属性.domElement</h3><p>渲染器WebGLRenderer通过属性.domElement可以获得渲染方法.render()生成的Canvas画布，.domElement本质上就是一个HTML元素：Canvas画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure></p><h2 id="光Light"><a href="#光Light" class="headerlink" title="光Light"></a>光Light</h2><p>实际生活中物体表面的明暗效果是会受到光照的影响，比如晚上不开灯，你就看不到物体，灯光比较暗，物体也比较暗。在threejs中，咱们用网格模型Mesh模拟生活中物体，所以threejs中模拟光照Light对物体表面的影响，就是模拟光照Light对网格模型Mesh表面的影响。</p><h3 id="受光照影响材质"><a href="#受光照影响材质" class="headerlink" title="受光照影响材质"></a>受光照影响材质</h3><p>threejs提供的网格材质，有的受光照影响，有的不受光照影响。<br><img src="/2024/06/06/Three-js基础入门/4.png" alt="img"></p><h3 id="光源简介"><a href="#光源简介" class="headerlink" title="光源简介"></a>光源简介</h3><p>Three.js提供了多种模拟生活中光源。<br><img src="/2024/06/06/Three-js基础入门/5.png" alt="img"><br>下面用点光源举例子</p><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>点光源PointLight可以类比为一个发光点，就像生活中一个灯泡以灯泡为中心向四周发射光线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 点光源：两个参数分别表示光源颜色和光照强度</span><br><span class="line">// 参数1：0xffffff是纯白光,表示光源颜色</span><br><span class="line">// 参数2：1.0,表示光照强度，可以根据需要调整</span><br><span class="line">const pointLight = new THREE.PointLight(0xffffff, 1.0);</span><br></pre></td></tr></table></figure></p><p>除了通过THREE.PointLight的参数2设置光照强度，你可以可以直接访问光照强度属性.intensity设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointLight.intensity = 1.0;//光照强度</span><br></pre></td></tr></table></figure></p><h3 id="光源衰减"><a href="#光源衰减" class="headerlink" title="光源衰减"></a>光源衰减</h3><p>实际生活中点光源，比如一个灯泡，随着距离的改变，光线会衰减，越来越弱，光源衰减属性.decay默认值是2.0，如果你不希望衰减可以设置为0.0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointLight.decay = 0.0; // 设置光源不随距离衰减</span><br></pre></td></tr></table></figure></p><h3 id="光源位置"><a href="#光源位置" class="headerlink" title="光源位置"></a>光源位置</h3><p>你把点光源想象为一个电灯泡，你在3D空间中，放的位置不同，模型的渲染效果就不一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//点光源位置</span><br><span class="line">pointLight.position.set(400, 0, 0); // 点光源放在x轴上</span><br></pre></td></tr></table></figure></p><h3 id="光源添加到场景"><a href="#光源添加到场景" class="headerlink" title="光源添加到场景"></a>光源添加到场景</h3><p>光源和网格模型Mesh对应一样是三维场景的一部分，自然需要添加到三维场景中才能起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.add(pointLight); // 点光源添加到场景中</span><br></pre></td></tr></table></figure></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>threejs可以借助HTML5的API请求动画帧window.requestAnimationFrame实现动画渲染。</p><h3 id="threejs旋转动画"><a href="#threejs旋转动画" class="headerlink" title="threejs旋转动画"></a>threejs旋转动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 渲染函数</span><br><span class="line">function render() &#123;</span><br><span class="line">    renderer.render(scene, camera); // 执行渲染操作</span><br><span class="line">    mesh.rotateY(0.01); // 每次绕y轴旋转0.01弧度</span><br><span class="line">    requestAnimationFrame(render); // 请求再次执行渲染函数render，渲染下一帧</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="计算两帧渲染时间间隔和帧率"><a href="#计算两帧渲染时间间隔和帧率" class="headerlink" title="计算两帧渲染时间间隔和帧率"></a>计算两帧渲染时间间隔和帧率</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 渲染循环</span><br><span class="line">const clock = new THREE.Clock();</span><br><span class="line">function render() &#123;</span><br><span class="line">    const spt = clock.getDelta()*1000;//毫秒</span><br><span class="line">    console.log(&apos;两帧渲染时间间隔(毫秒)&apos;,spt);</span><br><span class="line">    console.log(&apos;帧率FPS&apos;,1000/spt);</span><br><span class="line">    renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度</span><br><span class="line">    requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="渲染循环和相机控件OrbitControls"><a href="#渲染循环和相机控件OrbitControls" class="headerlink" title="渲染循环和相机控件OrbitControls"></a>渲染循环和相机控件OrbitControls</h3><p>设置了渲染循环,相机控件OrbitControls就不用再通过事件change执行renderer.render(scene, camera);，毕竟渲染循环一直在执行renderer.render(scene, camera)。</p><blockquote><p>以上内容就是Three.js的基础内容，下面介绍一些辅助开发的插件。</p></blockquote><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><h3 id="辅助观察坐标系"><a href="#辅助观察坐标系" class="headerlink" title="辅助观察坐标系"></a>辅助观察坐标系</h3><p>THREE.AxesHelper()的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// AxesHelper：辅助观察的坐标系</span><br><span class="line">const axesHelper = new THREE.AxesHelper(150);</span><br><span class="line">scene.add(axesHelper);</span><br></pre></td></tr></table></figure></p><h3 id="AxesHelper的xyz轴"><a href="#AxesHelper的xyz轴" class="headerlink" title="AxesHelper的xyz轴"></a>AxesHelper的xyz轴</h3><p>three.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。</p><h2 id="相机控件OrbitControls"><a href="#相机控件OrbitControls" class="headerlink" title="相机控件OrbitControls"></a>相机控件OrbitControls</h2><p>平时开发调试代码，或者展示模型的时候，可以通过相机控件OrbitControls实现旋转缩放预览效果。</p><h3 id="OrbitControls使用"><a href="#OrbitControls使用" class="headerlink" title="OrbitControls使用"></a>OrbitControls使用</h3><ul><li>旋转：拖动鼠标左键</li><li>缩放：滚动鼠标中键</li><li>平移：拖动鼠标右键</li></ul><h3 id="引入扩展库OrbitControls-js"><a href="#引入扩展库OrbitControls-js" class="headerlink" title="引入扩展库OrbitControls.js"></a>引入扩展库OrbitControls.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 引入轨道控制器扩展库OrbitControls.js</span><br><span class="line">import &#123; OrbitControls &#125; from &apos;three/addons/controls/OrbitControls.js&apos;;</span><br></pre></td></tr></table></figure><h3 id="使用OrbitControls"><a href="#使用OrbitControls" class="headerlink" title="使用OrbitControls"></a>使用OrbitControls</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置相机控件轨道控制器OrbitControls</span><br><span class="line">const controls = new OrbitControls(camera, renderer.domElement);</span><br><span class="line">// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景</span><br><span class="line">controls.addEventListener(&apos;change&apos;, function () &#123;</span><br><span class="line">    renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">&#125;);//监听鼠标、键盘事件</span><br></pre></td></tr></table></figure><h2 id="stats查看threejs渲染帧率"><a href="#stats查看threejs渲染帧率" class="headerlink" title="stats查看threejs渲染帧率"></a>stats查看threejs渲染帧率</h2><p>three.js每执行WebGL渲染器.render()方法一次，就在canvas画布上得到一帧图像，不停地周期性执行.render()方法就可以更新canvas画布内容，一般场景越复杂往往渲染性能越低，也就是每秒钟执行.render()的次数越低。<br>通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(FPS),所谓渲染帧率(FPS)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。</p><h3 id="引入Stats"><a href="#引入Stats" class="headerlink" title="引入Stats"></a>引入Stats</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//引入性能监视器stats.js</span><br><span class="line">import Stats from &apos;three/addons/libs/stats.module.js&apos;;</span><br></pre></td></tr></table></figure><h3 id="Stats使用"><a href="#Stats使用" class="headerlink" title="Stats使用"></a>Stats使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建stats对象</span><br><span class="line">const stats = new Stats();</span><br><span class="line">// stats.domElement:web页面上输出计算结果,一个div元素，</span><br><span class="line">document.body.appendChild(stats.domElement);</span><br><span class="line">// 渲染函数</span><br><span class="line">function render() &#123;</span><br><span class="line">// requestAnimationFrame循环调用的函数中调用方法update(),来刷新时间</span><br><span class="line">stats.update();</span><br><span class="line">renderer.render(scene, camera); // 执行渲染操作</span><br><span class="line">requestAnimationFrame(render); // 请求再次执行渲染函数render，渲染下一帧</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h2 id="demo-source"><a href="#demo-source" class="headerlink" title="demo source"></a>demo source</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">import * as THREE from &apos;three&apos;;</span><br><span class="line">// 引入轨道控制器扩展库OrbitControls.js</span><br><span class="line">import &#123; OrbitControls &#125; from &apos;three/addons/controls/OrbitControls.js&apos;;</span><br><span class="line">//引入性能监视器stats.js</span><br><span class="line">import Stats from &apos;three/addons/libs/stats.module.js&apos;;</span><br><span class="line"></span><br><span class="line">// 获取屏幕宽高</span><br><span class="line">const width = screen.width;</span><br><span class="line">const height = screen.height;</span><br><span class="line">// 变量声明</span><br><span class="line">let scene, camera, mesh, renderer, directionalLight, stats;</span><br><span class="line">// 初始化场景函数</span><br><span class="line">function initScene() &#123;</span><br><span class="line">  // 创建3D场景对象Scene</span><br><span class="line">  scene = new THREE.Scene();</span><br><span class="line">&#125;</span><br><span class="line">// 创建物体</span><br><span class="line">function initObject() &#123;</span><br><span class="line">  //创建一个长方体几何对象Geometry</span><br><span class="line">  const geometry = new THREE.BoxGeometry(20, 20, 20); </span><br><span class="line">  //创建一个材质对象Material</span><br><span class="line">  const material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000,//0xff0000设置材质颜色为红色</span><br><span class="line">    transparent:true,//开启透明</span><br><span class="line">    opacity:0.8,//设置透明度</span><br><span class="line">  &#125;); </span><br><span class="line">  // 两个参数分别为几何体geometry、材质material</span><br><span class="line">  mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh</span><br><span class="line">  //设置网格模型在三维空间中的位置坐标，默认是坐标原点</span><br><span class="line">  mesh.position.set(0,0,0);</span><br><span class="line">  scene.add(mesh); </span><br><span class="line">&#125;</span><br><span class="line">// 初始化相机</span><br><span class="line">function initCamera() &#123;</span><br><span class="line">  // 实例化一个透视投影相机对象</span><br><span class="line">  camera = new THREE.PerspectiveCamera(30, width/height, 1, 1000);</span><br><span class="line">  // 相机在Three.js三维坐标系中的位置</span><br><span class="line">  // 根据需要设置相机位置具体值</span><br><span class="line">  camera.position.set(200, 200, 200); </span><br><span class="line">  //相机观察目标指向Threejs 3D空间中某个位置</span><br><span class="line">  camera.lookAt(0, 0, 0); // 坐标原点</span><br><span class="line">&#125;</span><br><span class="line">// 初始化灯光</span><br><span class="line">function initLight() &#123;</span><br><span class="line">  // 环境光:没有特定方向，整体改变场景的光照明暗</span><br><span class="line">  const ambient = new THREE.AmbientLight(0xffffff, 0.4);</span><br><span class="line">  scene.add(ambient);</span><br><span class="line">  // 平行光</span><br><span class="line">  directionalLight = new THREE.DirectionalLight(0xffffff, 1);</span><br><span class="line">  // 设置光源的方向：通过光源position属性和目标指向对象的position属性计算</span><br><span class="line">  directionalLight.position.set(80, 50, 50);</span><br><span class="line">  // 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0</span><br><span class="line">  directionalLight.target = mesh;</span><br><span class="line">  scene.add(directionalLight);</span><br><span class="line">&#125;</span><br><span class="line">// 初始化渲染器</span><br><span class="line">function initRender() &#123;</span><br><span class="line">  // 创建渲染器对象</span><br><span class="line">  renderer = new THREE.WebGLRenderer();</span><br><span class="line">  renderer.setSize(width, height);</span><br><span class="line">  renderer.render(scene, camera); // 执行渲染操作</span><br><span class="line">  document.querySelector(&apos;#app&apos;).appendChild(renderer.domElement);</span><br><span class="line">&#125;</span><br><span class="line">// 初始化辅助开发工具</span><br><span class="line">function initHelper() &#123;</span><br><span class="line">  //创建stats对象</span><br><span class="line">  stats = new Stats();</span><br><span class="line">  //stats.domElement:web页面上输出计算结果,一个div元素，</span><br><span class="line">  document.body.appendChild(stats.domElement);</span><br><span class="line"></span><br><span class="line">  // DirectionalLightHelper：可视化平行光</span><br><span class="line">  const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5,0xff0000);</span><br><span class="line">  scene.add(dirLightHelper);</span><br><span class="line"></span><br><span class="line">  // AxesHelper：辅助观察的坐标系</span><br><span class="line">  const axesHelper = new THREE.AxesHelper(150);</span><br><span class="line">  scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line">  // 设置相机控件轨道控制器OrbitControls</span><br><span class="line">  const controls = new OrbitControls(camera, renderer.domElement);</span><br><span class="line">  // 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景</span><br><span class="line">  // controls.addEventListener(&apos;change&apos;, function () &#123;</span><br><span class="line">  //     renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">  // &#125;);//监听鼠标、键盘事件</span><br><span class="line">&#125;</span><br><span class="line">// 动画</span><br><span class="line">function animate() &#123;</span><br><span class="line">  mesh.rotateX(0.01);</span><br><span class="line">  mesh.rotateY(0.01);</span><br><span class="line">  stats.update();</span><br><span class="line">  renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">// 开始Threejs</span><br><span class="line">function start() &#123;</span><br><span class="line">  initScene();</span><br><span class="line">  initObject();</span><br><span class="line">  initCamera();</span><br><span class="line">  initLight();</span><br><span class="line">  initRender();</span><br><span class="line">  initHelper();</span><br><span class="line">  animate();</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Three.js基础入门学习&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="Threejs" scheme="/tags/Threejs/"/>
    
  </entry>
  
  <entry>
    <title>Three.js学习资源导航</title>
    <link href="/2024/06/03/Three-js%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    <id>/2024/06/03/Three-js学习资源导航/</id>
    <published>2024-06-03T01:56:22.000Z</published>
    <updated>2024-06-06T06:02:31.462Z</updated>
    
    <content type="html"><![CDATA[<p>Three.js相关学习资源导航链接<br><a id="more"></a></p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ul><li><a href="https://threejs.org/" target="_blank" rel="noopener">官网文档</a></li><li><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene" target="_blank" rel="noopener">官方API文档</a></li><li><a href="https://techbrood.com/threejs/docs" target="_blank" rel="noopener">中文文档</a></li><li><a href="https://threejs.org/manual/#zh/fundamentals" target="_blank" rel="noopener">官方入门教程</a></li><li><a href="http://www.hewebgl.com/article/articledir/1/" target="_blank" rel="noopener">初中高级教程</a></li><li><a href="http://www.webgl3d.cn/pages/4a14ce/" target="_blank" rel="noopener">基础教程</a></li><li><a href="https://blog.csdn.net/homula123/article/details/101197463" target="_blank" rel="noopener">从零构建3D智能仓库</a></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li><a href="https://threejs.org/examples/" target="_blank" rel="noopener">官网案例</a></li><li><a href="https://www.wjceo.com/blog/threejs/" target="_blank" rel="noopener">暮志未晚博客案例100篇</a></li><li><a href="http://www.yanhuangxueyuan.com/3D.html" target="_blank" rel="noopener">3D案例</a></li><li><a href="http://www.yanhuangxueyuan.com/3D/liangcang/" target="_blank" rel="noopener">物联网粮仓3D可视化</a></li><li><a href="https://ezshine.jnsii.com/cases/slowroads/" target="_blank" rel="noopener">3D版赛车游戏</a></li><li><a href="https://ezshine.jnsii.com/cases/avatarbuilder/" target="_blank" rel="noopener">Three.js开发的3D头像生成器 </a></li></ul><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/mrdoob/three.js/" target="_blank" rel="noopener">官方源码仓库</a></li><li><a href="https://github.com/mrdoob/three.js/tree/dev/examples" target="_blank" rel="noopener">官方示例仓库</a></li><li><a href="https://github.com/chandlerprall/Physijs" target="_blank" rel="noopener">Physijs-一款物理引擎，可以协助基于原生WebGL或使用three.js创建模拟物理现象，比如重力下落、物体碰撞等物理现象</a></li><li><a href="https://github.com/mrdoob/stats.js" target="_blank" rel="noopener">stats.js-提供了一个简单的信息框，可帮助您监视代码性能</a></li><li><a href="https://github.com/dataarts/dat.gui" target="_blank" rel="noopener">dat.gui-轻量级的icon形用户界面框架，可以用来控制Javascript的变量，比如WebGL中一个物体的尺寸、颜色</a></li><li><a href="https://github.com/tweenjs/tween.js/" target="_blank" rel="noopener">tween.js-一款可生成平滑动画效果的js动画库。可以非常方便的控制机械、游戏角色运动</a></li><li><a href="https://github.com/sshirokov/ThreeBSP" target="_blank" rel="noopener">ThreeBSP-可以将现有的模型组合出更多个性的模型来使用。如两个几何体的差集、并集、交集的展示</a></li><li><a href="https://free3d.com/3d-models/" target="_blank" rel="noopener">免费3D模型</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Three.js相关学习资源导航链接&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="Threejs" scheme="/tags/Threejs/"/>
    
      <category term="资源导航" scheme="/tags/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>windows系统安装Redis</title>
    <link href="/2024/05/30/windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85redis/"/>
    <id>/2024/05/30/windows系统安装redis/</id>
    <published>2024-05-30T08:06:09.000Z</published>
    <updated>2024-05-30T08:27:27.803Z</updated>
    
    <content type="html"><![CDATA[<p>windows系统下如何安装Redis<br><a id="more"></a></p><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，它提供了一个高效的键值存储解决方案，并支持多种数据结构，如字符串（Strings）、哈希（Hashes）、列表（Lists）、集合（Sets）和有序集合（Sorted Sets）等。它被广泛应用于缓存、消息队列、实时统计等场景。</p><h2 id="安装（windows）"><a href="#安装（windows）" class="headerlink" title="安装（windows）"></a>安装（windows）</h2><p><a href="https://github.com/zkteco-home/redis-windows" target="_blank" rel="noopener">Redis安装文件下载</a><br>将这个库clone到本地，之后以管理员身份执行<code>install_redis.cmd</code>这个文件后，就安装好了。<br><img src="/2024/05/30/windows系统安装redis/1.png" alt="img"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><code>redis-cli.exe</code>是客户端，可以连接redis服务进行操作<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET mykey &quot;Hello, World!&quot;</span><br><span class="line">GET mykey</span><br></pre></td></tr></table></figure></p><h3 id="卸载服务"><a href="#卸载服务" class="headerlink" title="卸载服务"></a>卸载服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-uninstall</span><br></pre></td></tr></table></figure><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-stop</span><br></pre></td></tr></table></figure><h3 id="开始服务"><a href="#开始服务" class="headerlink" title="开始服务"></a>开始服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-start</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个安装地址，<a href="https://github.com/microsoftarchive/redis" target="_blank" rel="noopener">Redis安装文件下载</a><br>但是这个库维护的Redis版本较低。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windows系统下如何安装Redis&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后端" scheme="/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>web视频播放浅析</title>
    <link href="/2024/04/19/web%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%85%E6%9E%90/"/>
    <id>/2024/04/19/web视频播放浅析/</id>
    <published>2024-04-19T02:32:53.000Z</published>
    <updated>2024-04-22T01:16:01.429Z</updated>
    
    <content type="html"><![CDATA[<p>简单的介绍html中video标签的几种使用场景,注意，视频播放是点播形式。<br><a id="more"></a></p><h2 id="视频知识"><a href="#视频知识" class="headerlink" title="视频知识"></a>视频知识</h2><p>web端以前用flash播放视频，但是由于安全原因，现在已经抛弃，使用html5的video标签。</p><blockquote><p>视频容器（也称为视频封装格式）是用来存储音频、视频和其他元数据（如字幕、章节信息等）的一种文件格式结构。它将音视频编码数据组织在一起，以便于播放器解析和呈现。容器的作用就像一个“包装盒”，将不同的轨道（视频流、音频流、字幕流等）按照一定的标准组织起来，使得各部分数据可以同步播放。</p></blockquote><h3 id="常见的视频文件格式"><a href="#常见的视频文件格式" class="headerlink" title="常见的视频文件格式"></a>常见的视频文件格式</h3><p><img src="/2024/04/19/web视频播放浅析/1.png" alt="img"></p><h3 id="常见的视频编码格式"><a href="#常见的视频编码格式" class="headerlink" title="常见的视频编码格式"></a>常见的视频编码格式</h3><p><img src="/2024/04/19/web视频播放浅析/2.png" alt="img"></p><h3 id="浏览器中的视频格式"><a href="#浏览器中的视频格式" class="headerlink" title="浏览器中的视频格式"></a>浏览器中的视频格式</h3><h4 id="WebM"><a href="#WebM" class="headerlink" title="WebM"></a>WebM</h4><p><img src="/2024/04/19/web视频播放浅析/3.png" alt="img"></p><h4 id="Ogg-Theora"><a href="#Ogg-Theora" class="headerlink" title="Ogg/Theora"></a>Ogg/Theora</h4><p><img src="/2024/04/19/web视频播放浅析/4.png" alt="img"></p><h4 id="MPEG-4-H-264"><a href="#MPEG-4-H-264" class="headerlink" title="MPEG-4/H.264"></a>MPEG-4/H.264</h4><p><img src="/2024/04/19/web视频播放浅析/5.png" alt="img"></p><h2 id="常见视频播放方法"><a href="#常见视频播放方法" class="headerlink" title="常见视频播放方法"></a>常见视频播放方法</h2><h3 id="基础方式"><a href="#基础方式" class="headerlink" title="基础方式"></a>基础方式</h3><p>使用<code>video</code>标签，<code>src</code>直接链接到一个完整的视频地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;video-basic&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      #video &#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        margin: 20px auto;</span><br><span class="line">        display: block;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;video id=&quot;video&quot; controls autoplay&gt;</span><br><span class="line">        &lt;source src=&quot;http://127.0.0.1:3000/video1.mp4&quot; type=&quot;&quot;&gt;</span><br><span class="line">      &lt;/video&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>这个例子是最基础最简单的。<br><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/basic-usage" target="_blank" rel="noopener">源码</a></p><h3 id="video-stream方式"><a href="#video-stream方式" class="headerlink" title="video-stream方式"></a>video-stream方式</h3><p>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;data:,&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Streaming&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        background-color: #000000;</span><br><span class="line">      &#125;</span><br><span class="line">      video &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        max-height: 100%;</span><br><span class="line">        max-width: 100%;</span><br><span class="line">        margin: auto;</span><br><span class="line">        object-fit: contain;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;video </span><br><span class="line">      src=&quot;http://localhost:3000/api/video/video.mp4&quot;</span><br><span class="line">      playsInline</span><br><span class="line">      muted</span><br><span class="line">      autoplay</span><br><span class="line">      controls </span><br><span class="line">      controlsList=&quot;nodownload&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>后端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">import Koa from &apos;koa&apos;</span><br><span class="line">import KoaRouter from &apos;koa-router&apos;</span><br><span class="line">import sendFile from &apos;koa-sendfile&apos;</span><br><span class="line">import url from &apos;url&apos;</span><br><span class="line">import path from &apos;path&apos;</span><br><span class="line">import fs from &apos;fs&apos;</span><br><span class="line">import util from &apos;util&apos;</span><br><span class="line"></span><br><span class="line">const __filename = url.fileURLToPath(import.meta.url)</span><br><span class="line">const __dirname = path.dirname(__filename)</span><br><span class="line"></span><br><span class="line">const PORT = parseInt(process.env.PORT, 10) || 3000</span><br><span class="line">const app = new Koa()</span><br><span class="line">const router = new KoaRouter()</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Serve HTML page containing the video player</span><br><span class="line">//</span><br><span class="line">router.get(&apos;/&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">    await sendFile(ctx, path.resolve(__dirname, &apos;public&apos;, &apos;index.html&apos;))</span><br><span class="line"></span><br><span class="line">    if (!ctx.status) &#123;</span><br><span class="line">        ctx.throw(404)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Serve video streaming</span><br><span class="line">//</span><br><span class="line">router.get(&apos;/api/video/:name&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; name &#125; = ctx.params</span><br><span class="line"></span><br><span class="line">    if (</span><br><span class="line">        !/^[a-z0-9-_ ]+\.mp4$/i.test(name)</span><br><span class="line">    ) &#123;</span><br><span class="line">        return next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; request, response &#125; = ctx</span><br><span class="line">    const &#123; range &#125; = request.headers</span><br><span class="line"></span><br><span class="line">    if (!range) &#123;</span><br><span class="line">        ctx.throw(400, &apos;Range not provided&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const videoPath = path.resolve(__dirname, &apos;videos&apos;, name)</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        await util.promisify(fs.access)(videoPath)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        if (err.code === &apos;ENOENT&apos;) &#123;</span><br><span class="line">            ctx.throw(404)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ctx.throw(err.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Calculate start Content-Range</span><br><span class="line">    //</span><br><span class="line">    const parts = range.replace(&apos;bytes=&apos;, &apos;&apos;).split(&apos;-&apos;)</span><br><span class="line">    const rangeStart = parts[0] &amp;&amp; parts[0].trim()</span><br><span class="line">    const start = rangeStart ? parseInt(rangeStart, 10) : 0</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Calculate video size and chunk size</span><br><span class="line">    //</span><br><span class="line">    const videoStat = await util.promisify(fs.stat)(videoPath)</span><br><span class="line">    const videoSize = videoStat.size</span><br><span class="line">    const chunkSize = 10 ** 6 // 1mb</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Calculate end Content-Range</span><br><span class="line">    //</span><br><span class="line">    // Safari/iOS first sends a request with bytes=0-1 range HTTP header</span><br><span class="line">    // probably to find out if the server supports byte ranges</span><br><span class="line">    //</span><br><span class="line">    const rangeEnd = parts[1] &amp;&amp; parts[1].trim()</span><br><span class="line">    const __rangeEnd = rangeEnd ? parseInt(rangeEnd, 10) : undefined</span><br><span class="line">    const end = __rangeEnd === 1 ? __rangeEnd : (Math.min(start + chunkSize, videoSize) - 1) // We remove 1 byte because start and end start from 0</span><br><span class="line">    const contentLength = end - start + 1 // We add 1 byte because start and end start from 0</span><br><span class="line"></span><br><span class="line">    response.set(&apos;Content-Range&apos;, `bytes $&#123;start&#125;-$&#123;end&#125;/$&#123;videoSize&#125;`)</span><br><span class="line">    response.set(&apos;Accept-Ranges&apos;, &apos;bytes&apos;)</span><br><span class="line">    response.set(&apos;Content-Length&apos;, contentLength)</span><br><span class="line"></span><br><span class="line">    const stream = fs.createReadStream(videoPath, &#123; start, end &#125;)</span><br><span class="line">    stream.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">        console.log(err.toString())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    response.status = 206</span><br><span class="line">    response.type = path.extname(name)</span><br><span class="line">    response.body = stream</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// We ignore ECONNRESET, ECANCELED and ECONNABORTED errors</span><br><span class="line">// because when the browser closes the connection, the server</span><br><span class="line">// tries to read the stream. So, the server says that it cannot</span><br><span class="line">// read a closed stream.</span><br><span class="line">//</span><br><span class="line">app.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">    if (![&apos;ECONNRESET&apos;, &apos;ECANCELED&apos;, &apos;ECONNABORTED&apos;].includes(err.code)) &#123;</span><br><span class="line">        console.log(err.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Add Koa Router middleware</span><br><span class="line">//</span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Start the server on the specified PORT</span><br><span class="line">//</span><br><span class="line">app.listen(PORT)</span><br><span class="line">console.log(&apos;Video Streaming Server is running on Port&apos;, PORT)</span><br></pre></td></tr></table></figure></p><p>可以看出，前端部分的代码跟第一个例子一样，直接给<code>video</code>标签的<code>src</code>一个视频链接地址，但是这个地址指向后台一个api接口。<br><code>video</code>标签默认会在请求头加上<code>Content-Range</code>属性，后端接口会根据这个属性去返回对应的数据。对于前端开发来说是无感的，因为浏览器已经自动完成了，只需要对后端接口做处理即可。<br><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/video-streaming" target="_blank" rel="noopener">源码</a></p><h3 id="mediaSource方式"><a href="#mediaSource方式" class="headerlink" title="mediaSource方式"></a>mediaSource方式</h3><p>这个方式用到了MediaSource这个API，允许JavaScript创建和处理媒体数据源，使得浏览器能够播放来自各种来源的自定义媒体数据，而不是只限于原始的文件或 URL。<br>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;video id=&quot;video&quot; width=&quot;800&quot; height=&quot;400&quot; webkit-playsinline=&quot;true&quot; controls playsinline=&quot;true&quot; type=&quot;video/mp4&quot; muted x5-video-player-type=&quot;h5&quot; &gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var PostbirdMp4ToBlob = &#123;</span><br><span class="line">        mediaSource:new MediaSource(),</span><br><span class="line">        // 检查是否支持 MediaSource 或者 mimeCodec</span><br><span class="line">        checkSupported: function (cb) &#123;</span><br><span class="line">            if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(this.mimeCodec)) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.video.src  = assetUrl; // 如果不支持，则直接将 src 修改成原始的url，保证兼容性</span><br><span class="line">                console.error(&apos;Unsupported MediaSource or unsupported MIME type or codec: &apos;, this.mimeCodec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 初始化 selector / assetUrl / mimeCodec / autoPlay</span><br><span class="line">        // selector：video的选择器 exp: &apos;#video&apos;</span><br><span class="line">        // assetUrl: video的请求地址 exp : &apos;./v.mp4&apos;</span><br><span class="line">        // mimeCodec: 编码模式  exp:  &apos;video/mp4; codecs=&quot;avc1.640028, mp4a.40.2&quot;&apos;</span><br><span class="line">        init: function (selector, assetUrl, mimeCodec) &#123;</span><br><span class="line">            this.video = document.querySelector(selector); // 获取vide dom</span><br><span class="line">            this.assetUrl = assetUrl;</span><br><span class="line">            this.mimeCodec = mimeCodec;</span><br><span class="line">            this.checkSupported();</span><br><span class="line">            this.start();// 开启</span><br><span class="line">        &#125;,</span><br><span class="line">        start: function () &#123;</span><br><span class="line">            console.log(this.mediaSource.readyState); // closed </span><br><span class="line">            this.video.src = URL.createObjectURL(this.mediaSource);</span><br><span class="line">            this.mediaSource.addEventListener(&apos;sourceopen&apos;, this.sourceOpen.bind(this));// bind(this) 保证回调</span><br><span class="line">        &#125;,</span><br><span class="line">        // MediaSource sourceopen 事件处理</span><br><span class="line">        sourceOpen: function (_) &#123;</span><br><span class="line">            var _this = this;</span><br><span class="line">            console.log(this.mediaSource.readyState); // open</span><br><span class="line">            var sourceBuffer = this.mediaSource.addSourceBuffer(this.mimeCodec);</span><br><span class="line">            this.fetchAB(this.assetUrl, function (buf) &#123;</span><br><span class="line">                sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123;</span><br><span class="line">                    _this.mediaSource.endOfStream();// 结束</span><br><span class="line">                    _this.video.play(); // 播放视频</span><br><span class="line">                    console.log(_this.mediaSource.readyState); // ended</span><br><span class="line">                &#125;);</span><br><span class="line">                sourceBuffer.appendBuffer(buf);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        // 基于 XHR 的简单封装</span><br><span class="line">        // arguments - url </span><br><span class="line">        // arguments - cb (回调函数)</span><br><span class="line">        fetchAB: function (url, cb) &#123;</span><br><span class="line">            var xhr = new XMLHttpRequest;</span><br><span class="line">            xhr.open(&apos;get&apos;, url);</span><br><span class="line">            xhr.responseType = &apos;arraybuffer&apos;;</span><br><span class="line">            xhr.onload = function () &#123;</span><br><span class="line">                cb(xhr.response);</span><br><span class="line">            &#125;;</span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var codec = &apos;video/mp4; codecs=&quot;avc1.42e01e, mp4a.40.2&quot;&apos;;</span><br><span class="line">        PostbirdMp4ToBlob.init(&apos;#video&apos;, &apos;/video/video1.mp4&apos;, codec);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>后端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const Router = require(&apos;koa-router&apos;);</span><br><span class="line">const static = require(&apos;koa-static&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;).promises;</span><br><span class="line"></span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const router = new Router();</span><br><span class="line"></span><br><span class="line">app.use(static(&apos;./static&apos;));</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(8080, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;server is run at 8080......&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后端是一个静态资源服务器</p><blockquote><p>这里需要注意下，用MediaSource接口来播放视频，对视频文件是有要求的，目前例子中的mp4文件可以播放，但是笔者试了很多方式来转换其它的视频文件都没有成功，目前也在尝试中。</p></blockquote><p><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/media-source" target="_blank" rel="noopener">源码</a></p><h3 id="m3u8-Hls方式"><a href="#m3u8-Hls方式" class="headerlink" title="m3u8 Hls方式"></a>m3u8 Hls方式</h3><p>.m3u8文件本质上是一个索引文件，其中包含了指向一系列多媒体片段（通常是经过加密或未加密的TS格式文件）的URL列表。<br>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;video-m3u8&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;video-list&quot;&gt;</span><br><span class="line">        &lt;div&gt;播放列表&lt;/div&gt;</span><br><span class="line">        &lt;ul&gt;&lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;video id=&quot;video&quot; controls autoplay&gt;&lt;/video&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &apos;./style.css&apos;;</span><br><span class="line">import Hls from &apos;hls.js&apos;;</span><br><span class="line">var video = document.getElementById(&apos;video&apos;);</span><br><span class="line">var videoList = [&apos;video1&apos;, &apos;video2&apos;, &apos;video3&apos;, &apos;video4&apos;, &apos;video5&apos;];</span><br><span class="line">// 创建buttons并插入dom</span><br><span class="line">var nUl = document.querySelector(&apos;.video-list ul&apos;);</span><br><span class="line">videoList.forEach(item=&gt; &#123;</span><br><span class="line">  var nLi= document.createElement(&apos;li&apos;);</span><br><span class="line">  var nBtn= document.createElement(&apos;button&apos;);</span><br><span class="line">  nBtn.textContent = item;</span><br><span class="line">  nLi.appendChild(nBtn);</span><br><span class="line">  nUl.appendChild(nLi);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">playVideo(videoList[0]);</span><br><span class="line"></span><br><span class="line">// 按钮添加事件</span><br><span class="line">var buttons = document.querySelectorAll(&apos;.video-list button&apos;);</span><br><span class="line">for(let btn of buttons) &#123;</span><br><span class="line">  btn.onclick = (evt)=&gt; &#123;</span><br><span class="line">    let videoName = evt.target.textContent;</span><br><span class="line">    playVideo(videoName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 播放video</span><br><span class="line">function playVideo(videoName) &#123;</span><br><span class="line">  if (Hls.isSupported()) &#123;</span><br><span class="line">    var hls = new Hls();</span><br><span class="line">    hls.loadSource(&apos;http://127.0.0.1:3000/&apos;+videoName+&apos;.m3u8&apos;);</span><br><span class="line">    hls.attachMedia(video);</span><br><span class="line">    hls.on(Hls.Events.MANIFEST_PARSED, function () &#123;</span><br><span class="line">      // video.play();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else if (video.canPlayType(&apos;application/vnd.apple.mpegurl&apos;)) &#123;</span><br><span class="line">    video.src = &apos;http://127.0.0.1:3000/&apos;+videoName+&apos;.m3u8&apos;;</span><br><span class="line">    video.addEventListener(&apos;loadedmetadata&apos;, function () &#123;</span><br><span class="line">      // video.play();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>js文件中需要<code>hls.js</code>库。</p><blockquote><p>hls.js 是一个开源的JavaScript库，专为解决在现代Web浏览器上播放基于HTTP Live Streaming (HLS)协议的视频内容而设计。HLS协议由苹果公司开发，被广泛用于在网络上分发实时和点播视频内容，尤其适用于移动端和桌面设备。<br>HLS协议的工作原理是将长视频文件切割成一系列小的媒体片段（通常为MPEG-2 Transport Stream格式，扩展名为.ts），并通过一个M3U8索引文件来组织这些片段。M3U8文件包含了指向各个视频片段的URL以及元数据，如分辨率、编码类型等信息。</p></blockquote><p><code>video.src = &#39;http://127.0.0.1:3000/&#39;+videoName+&#39;.m3u8&#39;</code>这段代码是指向一个<code>.m3u8</code>的文件，这个文件怎么生成的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// creatM3u8.js</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const fluentFFmpeg = require(&apos;fluent-ffmpeg&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">// 输入文件夹</span><br><span class="line">const inputFolder = path.resolve(__dirname, &apos;./sourceVideos&apos;);</span><br><span class="line">// 输入文件夹下的所有视频文件list</span><br><span class="line">const files = fs.readdirSync(inputFolder);</span><br><span class="line"></span><br><span class="line">// 输出目录，用于保存生成的 TS 文件和 M3U8 索引文件</span><br><span class="line">const outputDir = path.resolve(__dirname, &apos;./public&apos;);</span><br><span class="line">// FfmpegCommand实例变量</span><br><span class="line">let command;</span><br><span class="line">// 删除文件夹内容</span><br><span class="line">deleteFolderRecursiveSync(outputDir);</span><br><span class="line">// 循环files文件列表，逐个转换</span><br><span class="line">(async ()=&gt; &#123;</span><br><span class="line">  for(let file of files) &#123;</span><br><span class="line">    // 创建一个 FfmpegCommand 实例</span><br><span class="line">    command = fluentFFmpeg();</span><br><span class="line">    await creatVideos(file);</span><br><span class="line">    console.log(&apos;-----完成转换&apos;+file+&apos;-----&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">function creatVideos(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject )=&gt; &#123;</span><br><span class="line">    console.log(&apos;-----开始转换&apos;+file+&apos;-----&apos;);</span><br><span class="line">    const basenameWithExt = path.basename(file);</span><br><span class="line">    const extname = path.extname(basenameWithExt);</span><br><span class="line">    const fileNameWithoutExt = basenameWithExt.slice(0, -extname.length);</span><br><span class="line">    // 设置输出目录和 HLS 参数</span><br><span class="line">    command.input(`$&#123;inputFolder&#125;/$&#123;file&#125;`)</span><br><span class="line">    .output(`$&#123;outputDir&#125;/$&#123;fileNameWithoutExt&#125;.m3u8`)</span><br><span class="line">    .outputOptions([</span><br><span class="line">      &apos;-hls_time 10&apos;, // 每个切片时长为 10 秒</span><br><span class="line">      &apos;-hls_list_size 0&apos;, // 不限制播放列表的大小（无限循环）</span><br><span class="line">      `-hls_segment_filename $&#123;outputDir&#125;/$&#123;file&#125;_%03d.ts`, // 指定切片文件命名规则</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    // 执行转换过程</span><br><span class="line">    command</span><br><span class="line">    .on(&apos;progress&apos;, function(progress) &#123;</span><br><span class="line">      let per = parseInt(progress.percent || 0);</span><br><span class="line">      console.log(&apos;转换进度: &apos; + per + &apos;%&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      // console.log(&apos;HLS 转换完成！&apos;);</span><br><span class="line">      resolve(file);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">      console.error(&apos;An error occurred: &apos; + err.message);</span><br><span class="line">    &#125;)</span><br><span class="line">    .run();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 删除文件夹内容</span><br><span class="line">function deleteFolderRecursiveSync(folderPath) &#123;</span><br><span class="line">  if (!fs.existsSync(folderPath)) return;</span><br><span class="line"></span><br><span class="line">  const files = fs.readdirSync(folderPath);</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    const filePath = path.join(folderPath, files[i]);</span><br><span class="line"></span><br><span class="line">    if (fs.lstatSync(filePath).isDirectory()) &#123;</span><br><span class="line">      // 如果是子目录，则递归删除</span><br><span class="line">      deleteFolderRecursiveSync(filePath);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果是文件，则直接删除</span><br><span class="line">      fs.unlinkSync(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个文件读取目录<code>sourceVideos</code>文件夹下的mp4文件，并且分成n个视频片段和.m3u8文件，保存到了public目录下。<br>public目录是一个静态资源服务器文件夹，前端<code>hls.js</code>库会拿到<code>m3u8</code>文件，解析文件内容，加载视频片段并播放。<br><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/m3u8" target="_blank" rel="noopener">源码</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上简单介绍并列举了几种<code>video</code>标签在web视频播放中的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的介绍html中video标签的几种使用场景,注意，视频播放是点播形式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>npm安装不同版本的一个包</title>
    <link href="/2024/03/18/npm%E5%AE%89%E8%A3%85%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8C%85/"/>
    <id>/2024/03/18/npm安装不同版本的一个包/</id>
    <published>2024-03-18T02:30:03.000Z</published>
    <updated>2024-03-18T02:44:39.992Z</updated>
    
    <content type="html"><![CDATA[<p>在同一个项目中，安装不同版本的一个包<br><a id="more"></a><br>最近在开发中遇到项目需要同时依赖echarts的4.8.0版本和5.0.0版本，有两种方法解决。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>把下载的4.8.0版本中，dist文件夹下的echarts.js文件copy出来，放到需要引入的文件夹下，比如lib。</li><li>在使用的地方直接引入就可以，如：<code>import echarts from &quot;@/lib/echarts.js&quot;</code></li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用npm安装2个版本的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save echarts@npm:echarts@4.8.0</span><br></pre></td></tr></table></figure></p><p>安装后package.json中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;echarts&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;echarts-gl&quot;: &quot;^2.0.9&quot;,</span><br><span class="line">    &quot;echarts4&quot;: &quot;npm:echarts@^4.8.0&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>可以看到，echarts是正常安装的5.0.0版本，echarts4就是安装的4.8.0版本。<br>使用的时候<code>import * as echarts from &#39;echarts4&#39;</code>就可以。<br>再有就是，笔者在项目中用到了z-render，可以这样引入<code>import * as zrender from &#39;echarts4/node_modules/zrender&#39;;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在同一个项目中，安装不同版本的一个包&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>手写动画库</title>
    <link href="/2024/02/20/%E6%89%8B%E5%86%99%E5%8A%A8%E7%94%BB%E5%BA%93/"/>
    <id>/2024/02/20/手写动画库/</id>
    <published>2024-02-20T07:03:29.000Z</published>
    <updated>2024-02-20T07:28:47.419Z</updated>
    
    <content type="html"><![CDATA[<p>简单实现一个动画库<br><a id="more"></a></p><blockquote><p>本动画库学习参考winter老师教程实现</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2024/02/20/手写动画库/1.png" alt="img"><br>通过上面的思维导图，动画库有Timeline，Animate，Easing三个类构成，对应三个文件。</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>案例代码在vite环境下构建</p><h3 id="index-html文件"><a href="#index-html文件" class="headerlink" title="index.html文件"></a>index.html文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Vite App&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      #el1 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">      &#125;</span><br><span class="line">      #el2 &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: rgb(13, 50, 146);</span><br><span class="line">      &#125;</span><br><span class="line">      .btns &#123;</span><br><span class="line">        margin-top: 50px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;el1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;el2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;btns&quot;&gt;</span><br><span class="line">      &lt;button id=&quot;startBtn&quot;&gt;start&lt;/button&gt;</span><br><span class="line">      &lt;button id=&quot;pauseBtn&quot;&gt;pause&lt;/button&gt;</span><br><span class="line">      &lt;button id=&quot;resumeBtn&quot;&gt;resume&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="main-js文件"><a href="#main-js文件" class="headerlink" title="main.js文件"></a>main.js文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import animate, &#123; Linear, QuadraticIn, QuinticIn &#125; from &quot;./animate&quot;;</span><br><span class="line">// 使用方法</span><br><span class="line">// 获取时间线的实例</span><br><span class="line">let tl = animate();</span><br><span class="line">// 向时间线中加入动画实例</span><br><span class="line">tl.add(&#123;</span><br><span class="line">  el: &apos;#el1&apos;, // 动画元素，可以是string或dom元素</span><br><span class="line">  property: &apos;transform&apos;, // 动画的属性</span><br><span class="line">  startValue: 0, // 动画初始值</span><br><span class="line">  endValue: 500, // 动画的结束值</span><br><span class="line">  duration: 2, // 动画持续时间 秒单位</span><br><span class="line">  delay: 0, // 动画的延迟 秒单位</span><br><span class="line">  timingFunction: QuadraticIn, // 动画的移动效果，可以查看Easing.js文件</span><br><span class="line">  template: v=&gt; `translate($&#123;v&#125;px)`, // 动画执行的每一帧，返给属性加工后得知，比如返回“500px”等</span><br><span class="line">  startTime: new Date(&apos;2024-2-20 9:36:00&apos;), // 可以指定具体的时间让动画执行</span><br><span class="line">  loop: &apos;reverse&apos;, // 动画是否循环 loop值真时正常动画 reverse反向动画</span><br><span class="line">&#125;);</span><br><span class="line">// 下面是对同一个元素el2的两个属性添加动画效果</span><br><span class="line">tl.add(&#123;</span><br><span class="line">  el: &apos;#el2&apos;,</span><br><span class="line">  property: &apos;top&apos;, </span><br><span class="line">  startValue: 0, </span><br><span class="line">  endValue: 500, </span><br><span class="line">  duration: 2, </span><br><span class="line">  delay: 0, </span><br><span class="line">  timingFunction: Linear, </span><br><span class="line">  template: v=&gt; `$&#123;v&#125;px`,</span><br><span class="line">  loop: true</span><br><span class="line">&#125;);</span><br><span class="line">tl.add(&#123;</span><br><span class="line">  el: &apos;#el2&apos;,</span><br><span class="line">  property: &apos;left&apos;, </span><br><span class="line">  startValue: 0, </span><br><span class="line">  endValue: 500, </span><br><span class="line">  duration: 2, </span><br><span class="line">  delay: 0, </span><br><span class="line">  timingFunction: Linear, </span><br><span class="line">  template: v=&gt; `$&#123;v&#125;px`,</span><br><span class="line">  loop: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 按钮事件</span><br><span class="line">document.querySelector(&apos;#startBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">  tl.start();</span><br><span class="line">&#125;, false);</span><br><span class="line">// document.querySelector(&apos;#resetBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">//   tl.reset();</span><br><span class="line">// &#125;, false);</span><br><span class="line">document.querySelector(&apos;#pauseBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">  tl.pause();</span><br><span class="line">&#125;, false);</span><br><span class="line">document.querySelector(&apos;#resumeBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">  tl.resume();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/%E5%8A%A8%E7%94%BB%E5%BA%93/animate" target="_blank" rel="noopener">sourceCode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单实现一个动画库&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="手写" scheme="/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>npm link</title>
    <link href="/2024/02/18/npm-link/"/>
    <id>/2024/02/18/npm-link/</id>
    <published>2024-02-18T03:15:29.000Z</published>
    <updated>2024-02-18T06:05:45.427Z</updated>
    
    <content type="html"><![CDATA[<p>npm link用法<br><a id="more"></a></p><h2 id="本地调试用"><a href="#本地调试用" class="headerlink" title="本地调试用"></a>本地调试用</h2><p>假设要开发一个工具库，可以供多个项目使用。<br>一种方法是发布到npm仓库中去，使用的时候，直接<code>npm i moduleName</code>,但是，这种方式不利于开发时候使用，每次改动都需要发布，其它依赖的项目还要更新依赖包，非常麻烦。<br>另一种方法是使用<code>npm link</code>,在命令行下<code>npm link --help</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm link (in package dir)</span><br><span class="line">npm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]</span><br><span class="line"></span><br><span class="line">alias: ln</span><br></pre></td></tr></table></figure></p><h3 id="具体的使用示例"><a href="#具体的使用示例" class="headerlink" title="具体的使用示例:"></a>具体的使用示例:</h3><p>1.在&lt;工具库&gt;目录下，使用<code>npm link</code>命令，会根据目录下的package.json文件，将项目名称和入口文件，软连接到nodejs的全局环境下。可以使用<code>npm ls --global --depth 0</code>命令查看当前全局都有哪些包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\nodejs -&gt; .\</span><br><span class="line">+-- corepack@0.10.0</span><br><span class="line">+-- hexo-cli@4.3.1</span><br><span class="line">+-- http-server@14.1.1</span><br><span class="line">+-- nodemon@3.0.2</span><br><span class="line">+-- npm@8.1.2</span><br><span class="line">+-- pnpm@8.15.1</span><br><span class="line">`-- simple-mind-map@0.9.7 -&gt; .\..\..\..\jinux\test\思维导图\mind-map-main\simple-mind-map</span><br></pre></td></tr></table></figure></p><p>上面是笔者nodejs全局下的包，只有<a href="mailto:simple-mind-map@0.9.7" target="_blank" rel="noopener">simple-mind-map@0.9.7</a>这个包是通过<code>npm link</code>软连接生成的，其他的都是npm全局安装的。<br>2.利用<code>npm link</code>生成软链接后，在需要引用&lt;工具库&gt;的项目目录下执行<code>npm link &lt;工具库名称&gt;</code>,这时在node_modules下就安装了这个工具库，而且是指向前面生成的软连接。<br>3.按照步骤2的方式，可以在多个项目中这样使用。当更改&lt;工具库&gt;代码后，其它引用这个依赖的项目也会自动更改。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><ul><li>如果不需要依赖&lt;工具库&gt;时，可以在项目目录下执行<code>npm unlink &lt;工具库名称&gt;</code>。</li><li>全局删除软连接，<code>npm rm --global &lt;工具库名称&gt;</code>，有时候软链接可能删除了，但是还能使用,可以进入到nodejs全局安装的目录手动把这个包删除。</li></ul><h3 id="实际工作中的小技巧"><a href="#实际工作中的小技巧" class="headerlink" title="实际工作中的小技巧"></a>实际工作中的小技巧</h3><p>比如，&lt;工具库&gt;这个包已经发布到npm上了，本地又有很多项目依赖，如果想每次发布这个包后，所有项目都跟着更新，步骤如下：</p><ul><li>全局安装&lt;工具库&gt;这个包,<code>npm i &lt;工具库名称&gt; -g</code>.</li><li>在依赖&lt;工具库&gt;这个包的项目下，执行<code>npm link &lt;工具库名称&gt;</code>.</li><li>全局更新包<code>npm update &lt;工具库名称&gt; -g</code>,所有link这个包的项目都会更新.</li></ul><p>刚开始笔者也有疑问,全局安装的包不是在哪里都可以使用吗?为什么还要<code>link</code>呢?其实,<code>npm i -g moduleName</code>是将模块安装到全局目录下,但是只能在命令行下使用,项目代码中想require引用的话,还需要<code>npm link</code>后才能使用.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm link用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="调试" scheme="/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅析npm参数init,create,exec</title>
    <link href="/2024/01/17/%E6%B5%85%E6%9E%90npm%E5%8F%82%E6%95%B0init-create-exec/"/>
    <id>/2024/01/17/浅析npm参数init-create-exec/</id>
    <published>2024-01-17T05:11:33.000Z</published>
    <updated>2024-01-17T06:07:51.209Z</updated>
    
    <content type="html"><![CDATA[<p>npm [init,create,exec,innit],npx的使用<br><a id="more"></a></p><h2 id="npm-exec"><a href="#npm-exec" class="headerlink" title="npm exec"></a>npm exec</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// pkg是包名</span><br><span class="line">npm exec &lt;pkg&gt;</span><br><span class="line">// 还有一种简写形式</span><br><span class="line">// npm官方文档中指出x,其实就是exec的别名,npm exec、npm x,两个命令是完全等价的。</span><br><span class="line">npm x &lt;pkg&gt;</span><br></pre></td></tr></table></figure><h3 id="npm-exec-lt-pkg-gt-的执行流程"><a href="#npm-exec-lt-pkg-gt-的执行流程" class="headerlink" title="npm exec &lt;pkg&gt;的执行流程"></a><code>npm exec &lt;pkg&gt;</code>的执行流程</h3><ul><li>在本地查找是否有<code>&lt;pkg&gt;</code>对应的<code>npm</code>包,若找到,则运行这个包的<code>package.json</code>中<code>bin</code>字段对应的可执行文件,若未找到,在远程<code>npm</code>仓库查找是否有<code>&lt;pkg&gt;</code>对应的<code>npm</code>包,若找到,则下载到本地,下载完成后运行这个包<code>package.json</code>中<code>bin</code>字段对应的可执行文件。</li><li>在执行<code>bin</code>字段有几点注意的,如果<code>bin</code>只有一个入口,那么可以执行,如果<code>bin</code>有多个入口,则寻找和包名一样的那个入口,如果没找到,则<code>npm exec &lt;pkg&gt;</code>报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create-vite这个npm包的package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;create-vite&quot;</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line">      &quot;create-vite&quot;: &quot;index.js&quot;,</span><br><span class="line">      &quot;cva&quot;: &quot;index.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="npm-exec-lt-pkg-gt-的执行案例"><a href="#npm-exec-lt-pkg-gt-的执行案例" class="headerlink" title="npm exec &lt;pkg&gt;的执行案例"></a><code>npm exec &lt;pkg&gt;</code>的执行案例</h3><p>以<code>create-vite</code>这个包为例子<br>执行<code>npm exec crate-vite</code>这条命令后,首先本地查找是否有<code>create-vite</code>这个<code>npm</code>包,找到,则运行<code>create-vite</code>这个<code>npm</code>包中的<code>package.json</code>中<code>bin</code>字段对应的可执行文件,即<code>index.js</code>这个文件。若未找到,在远程<code>npm</code>仓库查找是否有<code>create-vite</code>这个包,如果有,则下载到本地,并执行<code>package.json</code>中<code>bin</code>字段对应的可执行文件。</p><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p><code>npm</code>文档中提到：<code>npx</code>的二进制文件在<code>npm v7.0.0</code>中被重写,而独立的<code>npx</code>包在当时已弃用。<code>npx</code>使用<code>npm exec</code>命令,而不是单独的参数解析器和安装过程。并提供了一些支持,以保持与它在以前版本中接受的参数的向后兼容性。<br>因此:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx = npm exec</span><br><span class="line">npx = npm x</span><br></pre></td></tr></table></figure></p><p>所以上面的<code>npm exec create-vite</code>也可以使用<code>npx create-vite</code>去执行</p><h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm init &lt;initializer&gt;</span><br></pre></td></tr></table></figure><h3 id="无initializer"><a href="#无initializer" class="headerlink" title="无initializer"></a>无initializer</h3><p>后面没有<code>&lt;initializer&gt;</code>是用来创建package.json文件</p><h3 id="有initializer"><a href="#有initializer" class="headerlink" title="有initializer"></a>有initializer</h3><p>这里的<code>npm init &lt;initializer&gt;</code>实际会调用<code>npm exec create-&lt;initializer&gt;</code>, 也相当于<code>npx create-&lt;initializer&gt;</code>。<br>比如在使用vite时,<code>npm init vite</code>,实际是执行<code>npm exec create-vite</code></p><h2 id="npm-create-npm-innit"><a href="#npm-create-npm-innit" class="headerlink" title="npm create,npm innit"></a>npm create,npm innit</h2><p><code>npm</code>官方文档中指出<code>create,innit</code>其实就是<code>init</code>的别名,也就是说<code>npm init,npm create,npm innit</code>三个命令是完全等价的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm [init,create,exec,innit],npx的使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="nodejs" scheme="/tags/nodejs/"/>
    
  </entry>
  
</feed>
