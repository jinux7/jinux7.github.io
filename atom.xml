<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2025-06-03T06:54:08.055Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Rust 锈化前端工具链</title>
    <link href="/2025/06/03/%E4%BD%BF%E7%94%A8-Rust-%E9%94%88%E5%8C%96%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>/2025/06/03/使用-Rust-锈化前端工具链/</id>
    <published>2025-06-03T06:12:23.000Z</published>
    <updated>2025-06-03T06:54:08.055Z</updated>
    
    <content type="html"><![CDATA[<p>使用Rust构建前端工具链<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来，Rust的受欢迎程度不断上升。首先，在操作系统领域，Rust 已成为 Linux 内核官方认可的开发语言之一，Windows 也宣布将使用 Rust 来重写内核，并重写部分驱动程序。此外，国内手机厂商 Vivo 也宣布使用 Rust 开发了名为“蓝河”的操作系统。除此之外，Rust 在图形渲染、游戏开发、中间件开发、边缘计算、计算安全等领域也是遍地开花，可以说，Rust 正在以惊人的速度重塑着各个领域的发展，让人不禁感叹 Rust 已经在重写万物了。</p><p>那回到前端领域，正在进行一场构建工具的革命，除了老牌的 Babel 竞争对手<a href="https://swc.rs/" target="_blank" rel="noopener">swc</a>，一些新兴的前端构建工具也都在使用 Rust 进行开发，例如<a href="https://turbo.build/pack" target="_blank" rel="noopener">Turbopack</a>、<a href="https://parceljs.org/" target="_blank" rel="noopener">Parcel</a>，对标 Webpack 的<a href="https://www.rspack.dev/" target="_blank" rel="noopener">Rspack</a>，对标 Vite 的<a href="https://farm-fe.github.io/" target="_blank" rel="noopener">Farm</a>等等。所以，对于广大前端同胞来说，C/C++ 太难，学习和掌握 Rust 是一个不错的选择，虽然 Rust 也不见得容易许多，它有着陡峭的学习曲线，但它或许是我们突破闭塞的前端区间的一把钥匙，帮助我们打开通往新世界的大门。</p><h2 id="锈化开发工具的方式"><a href="#锈化开发工具的方式" class="headerlink" title="锈化开发工具的方式"></a>锈化开发工具的方式</h2><p>虽说 Rust 的学习曲线可能相对陡峭，但笔者认为这是对于要全面掌握 Rust 这门语言而言的，而我们学习语言的目的最重要的是掌握一项可以帮我们解决问题的技能，因此，对于 Rust 不需要抱有太多的恐惧和敬畏之心，只需要摒除杂念立马开始学习 + 撸码，剩下的就交给时间来慢慢积累经验。此外，对于不是那么复杂应用来说，熟悉 Rust 基本语法和数据结构，翻过「所有权机制」和「生命周期」两座大山，基本也足以应付了。</p><p>本文建立在读者已经有一定的 Rust 知识基础上，对于 Rust 基本语法就不做赘述了。当前，大部分前端研发都是在 Node 环境下进行的，所以我们通过 Rust 来改造开发工具，主要有两种形式：</p><ul><li><p>使用 WASM 的方式，基于<a href="https://rustwasm.github.io/wasm-pack/" target="_blank" rel="noopener">wasm-pack</a>，将 Rust 代码编译成 WASM，以供 Node 调用</p></li><li><p>将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于napi-rs和neon来实现</p></li></ul><p>在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么此时就应该选择 Node addons 的方式了。而<a href="https://napi.rs/" target="_blank" rel="noopener">napi-rs</a>和<a href="https://neon-bindings.com/" target="_blank" rel="noopener">neon</a>的选择的话，napi-rs相对而言比较简单和轻量，而且针对不同版本的 Node 不需要重新编译，所以我们考虑选择napi-rs作为锈化开发工具的方式。</p><h2 id="初识-NAPI-RS"><a href="#初识-NAPI-RS" class="headerlink" title="初识 NAPI-RS"></a>初识 NAPI-RS</h2><p>我们可以通过 napi-rs 的开发工具 <strong>@napi-rs/cli</strong>以及<a href="https://github.com/napi-rs/package-template" target="_blank" rel="noopener">项目模板</a>来初始化一个应用，这里推荐使用项目模板，因为经过笔者的测试，开发工具创建的项目内容上相较于模板比较落后，对于后续深入使用上会造成一定的困惑。</p><p>从 napi-rs 项目模板内容上看，可以发现项目结构完善，工程化相关能力非常齐全，提供了构建工具、测试用例编写、Github CI 工作流等等必须的能力，我们只需要关注编码就可以了。</p><p>我们先来关注一下生成的 napi-rs 项目文件。从package.json和npm分析可以看出，一个 napi-rs 项目主要是由主包和 npm 下的针对不同平台的编译构建结果子包组成，napi-rs 会根据用户的配置，将用户的 Rust 代码构建为不同平台下的 Node 扩展 binding 文件，这些文件会放到 npm 下对应的平台目录中，再由 package.json 中 main 字段指定导出，用户在安装主包的时候，会根据用户电脑情况加载对应构建结果子包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@tarojs/parse-css-to-stylesheet-darwin-x64&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.25&quot;,</span><br><span class="line">  &quot;os&quot;: [</span><br><span class="line">    &quot;darwin&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;cpu&quot;: [</span><br><span class="line">    &quot;x64&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;main&quot;: &quot;parse-css-to-stylesheet.darwin-x64.node&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;parse-css-to-stylesheet.darwin-x64.node&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &quot;https://github.com/NervJS/parse-css-to-stylesheet&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在主包入口index.js中将根据用户宿主平台，加载对应的扩展文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">switch (platform) &#123;</span><br><span class="line">  case &apos;win32&apos;:</span><br><span class="line">    switch (arch) &#123;</span><br><span class="line">      case &apos;x64&apos;:</span><br><span class="line">        localFileExisted = existsSync(</span><br><span class="line">          join(__dirname, &apos;parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">        )</span><br><span class="line">        try &#123;</span><br><span class="line">          if (localFileExisted) &#123;</span><br><span class="line">            nativeBinding = require(&apos;./parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            nativeBinding = require(&apos;@tarojs/parse-css-to-stylesheet-win32-x64-msvc&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          loadError = e</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    break</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>从@napi-rs/triples这个包中可以看到所有支持的平台列表，而对于常规性的 Node 应用来说，我们不需要构建这么多平台，一般来说构建x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台也足够了，这样也能减少 CI 的构建时间。</p><p>napi-rs 默认构建的平台是x86_64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu，在<a href="https://github.com/napi-rs/napi-rs/blob/main/cli/src/utils/target.ts#L25" target="_blank" rel="noopener">这里</a>可以看到，所以为了增加 MAC Book M 系列电脑的支持，我们需要增加aarch64-apple-darwin的配置，可以在 package.json 中napi字段中添加，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;napi&quot;: &#123;</span><br><span class="line">  &quot;binaryName&quot;: &quot;taro&quot;,</span><br><span class="line">  &quot;triples&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: true,</span><br><span class="line">    &quot;additional&quot;: [</span><br><span class="line">      &quot;aarch64-apple-darwin&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>接下来就可以开始我们的编码之旅咯！</p><h2 id="基于-NAPI-RS-开发-Node-扩展"><a href="#基于-NAPI-RS-开发-Node-扩展" class="headerlink" title="基于 NAPI-RS 开发 Node 扩展"></a>基于 NAPI-RS 开发 Node 扩展</h2><p>基于 napi-rs 开发 Node 扩展，除了 Rust 编码本身外，无非需要关注两种情况，即 JavaScript 调用 Rust 和 Rust 调用 JavaScript。</p><h3 id="JavaScript-调用-Rust"><a href="#JavaScript-调用-Rust" class="headerlink" title="JavaScript 调用 Rust"></a>JavaScript 调用 Rust</h3><h4 id="调用-Rust-函数"><a href="#调用-Rust-函数" class="headerlink" title="调用 Rust 函数"></a>调用 Rust 函数</h4><p>这是最常见的用法，因为我们一般使用 Rust 开发 Node 扩展，也是为了将一些 CPU 密集型任务的任务使用 Rust 来实现，再暴露给 JS 来调用，从而达到提升应用性能的目的，最为常见的是 Rust 暴露方法给到 JS 调用，通过项目模板生成的 napi-rs 示例也可以看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/lib.rs </span><br><span class="line">use napi_derive::napi;</span><br><span class="line"></span><br><span class="line">#[napi]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码，通过给plus_100函数添加#[napi]属性宏，这样可以标记该函数，表示该函数可以通过 N-API 在 Node.js 中调用，在项目编译后的 typing 文件中，我们能看到对应生成了 JS 函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function plus100(input: number): number</span><br></pre></td></tr></table></figure></p><p>可以看到这里生成 JS 函数名是 napi-rs 自己的规则，我们也可以自定义暴露的函数名，通过js_name属性可以指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#[napi(js_name = &quot;plus_100&quot;)]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，除了暴露函数这一基本操作之外，我们还可以暴露常量、对象、类、enum 等等给到 JS 侧去调用，这些可以通过 napi-rs 的<a href="https://napi.rs/docs/concepts/values" target="_blank" rel="noopener">官方文档</a>可以查阅到。</p><h4 id="以-Object-作为参数"><a href="#以-Object-作为参数" class="headerlink" title="以 Object 作为参数"></a>以 Object 作为参数</h4><p>而在 JS 调用 Rust 编码中，最需要关注的是调用函数时，JS 侧给 Rust 传对象作为参数，这里为了提升性能，建议提前在 Rust 中定义好传递对象的数据结构，在 JS 中以引入该数据结构定义，规范数据传递即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 定义好数据结构</span><br><span class="line">// napi(object) 表示紧随其后的 struct （结构体）将通过 N-API 以 JavaScript 对象的形式暴露出去</span><br><span class="line">#[napi(object)]</span><br><span class="line">pub struct Project &#123;</span><br><span class="line">  pub project_root: String,</span><br><span class="line">  pub project_name: String,</span><br><span class="line">  pub npm: NpmType,</span><br><span class="line">  pub description: Option,</span><br><span class="line">  pub typescript: Option,</span><br><span class="line">  pub template: String,</span><br><span class="line">  pub css: CSSType,</span><br><span class="line">  pub auto_install: Option,</span><br><span class="line">  pub framework: FrameworkType,</span><br><span class="line">  pub template_root: String,</span><br><span class="line">  pub version: String,</span><br><span class="line">  pub date: Option,</span><br><span class="line">  pub compiler: Option,</span><br><span class="line">  pub period: PeriodType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JS 中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义，其中 Project 由 Rust binding 中暴露</span><br><span class="line">export function createProject(conf: Project)</span><br><span class="line"></span><br><span class="line">// 函数调用</span><br><span class="line">createProject(&#123;</span><br><span class="line">  projectRoot: projectDir,</span><br><span class="line">  projectName,</span><br><span class="line">  template,</span><br><span class="line">  npm,</span><br><span class="line">  framework,</span><br><span class="line">  css: this.conf.css || CSSType.None,</span><br><span class="line">  autoInstall: autoInstall,</span><br><span class="line">  templateRoot: getRootPath(),</span><br><span class="line">  version: getPkgVersion(),</span><br><span class="line">  typescript: this.conf.typescript,</span><br><span class="line">  date: this.conf.date,</span><br><span class="line">  description: this.conf.description,</span><br><span class="line">  compiler: this.conf.compiler,</span><br><span class="line">  period: PeriodType.CreateAPP,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Rust-调用-JavaScript"><a href="#Rust-调用-JavaScript" class="headerlink" title="Rust 调用 JavaScript"></a>Rust 调用 JavaScript</h3><p>而 Rust 中也可以调用 JS 提供的方法，这在做 Node 开发工具的时候非常有用，因为有时候我们需要读取开发人员的配置代码给到 Rust 调用，其中就可能会遇到 Rust 调用 JavaScript 中函数的情况。</p><h4 id="一个调用-JS-函数的简单例子"><a href="#一个调用-JS-函数的简单例子" class="headerlink" title="一个调用 JS 函数的简单例子"></a>一个调用 JS 函数的简单例子</h4><p>在 napi-rs 中调用 JS 函数主要通过ThreadsafeFunction来实现，请看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  for n in 0..100 &#123;</span><br><span class="line">    let tsfn = callback.clone();</span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述例子中，call_threadsafe_function函数接受了一个类型为ThreadsafeFunction<u32>的参数，这表明call_threadsafe_function被编译为 JS 函数后将接受一个回调函数作为参数，而该回调函数的有效参数为u32即number类型，而在call_threadsafe_function函数体中，通过thread::spawn开辟子线程，以阻塞的方式调用这个传入的回调函数。</u32></p><p>通过ThreadsafeFunction的call方法可以调用到传入的 JS 回调函数，但是我们会发现它拿不到返回值，如果我们需要获取到 JS 回调函数的返回值时，我们需要使用call_with_return_value和call_async两个方法。</p><h4 id="获取-JS-函数的返回值"><a href="#获取-JS-函数的返回值" class="headerlink" title="获取 JS 函数的返回值"></a>获取 JS 函数的返回值</h4><p>对比call与call_with_return_value的实现可以看出，call_with_return_value比call多一个回调函数参数，并且可以指定 JS 回调函数返回值的类型，并且该类型需要满足FromNapiValue这个 trait，因为call_with_return_value在处理 JS 回调函数时会调用它的from_napi_value方法将 JS 数据转为 Rust 的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/napi-rs/napi-rs/blob/main/crates/napi/src/threadsafe_function.rs#L428</span><br><span class="line">pub fn call(&amp;self, value: Result, mode: ThreadsafeFunctionCallMode) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::Direct,</span><br><span class="line">            callback: Box::new(|_d: Result| Ok(())),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn call_with_return_value Result&lt;()&gt;&gt;(</span><br><span class="line">  &amp;self,</span><br><span class="line">  value: Result,</span><br><span class="line">  mode: ThreadsafeFunctionCallMode,</span><br><span class="line">  cb: F,</span><br><span class="line">) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">            callback: Box::new(move |d: Result| &#123;</span><br><span class="line">              d.and_then(|d| D::from_napi_value(d.0.env, d.0.value).and_then(cb))</span><br><span class="line">            &#125;),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>call_with_return_value的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  callback.call_with_return_value(Ok(1), ThreadsafeFunctionCallMode::Blocking, move |result: u32| &#123;</span><br><span class="line">    println!(&quot;callback: &#123;result:?&#125;&quot;);</span><br><span class="line">    Ok(())</span><br><span class="line">  &#125;);</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，JS 回调函数的返回值是在call_with_return_value的第三个回调函数参数中获取到的，这就导致如果我们需要依赖这个 JS 函数返回值的话，我们后续的逻辑代码只能写在call_with_return_value的第三个回调函数参数中，对我们的代码逻辑书写造成诸多不便，代码可读性降低，所以推荐使用call_async方法来执行 JS 函数，并获取参数。</p><h4 id="使用call-async获取-JS-函数返回值"><a href="#使用call-async获取-JS-函数返回值" class="headerlink" title="使用call_async获取 JS 函数返回值"></a>使用call_async获取 JS 函数返回值</h4><p>从call_async的实现可以看出，它首先使用了tokio创建了一个 one-shot 通道，让 JS 函数以不阻塞的方式异步运行，并在执行完成后通过sender 发送操作结果，而使用receiver进行等待执行结果，并将结果返回，同时要使用call_async方法，需要在Cargo.toml中为napi依赖打开tokio_rt特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(feature = &quot;tokio_rt&quot;)]</span><br><span class="line">pub async fn call_async(&amp;self, value: Result) -&gt; Result &#123;</span><br><span class="line">  let (sender, receiver) = tokio::sync::oneshot::channel::&gt;();</span><br><span class="line"></span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Err(crate::Error::from_status(Status::Closing));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_status!(</span><br><span class="line">      unsafe &#123;</span><br><span class="line">        sys::napi_call_threadsafe_function(</span><br><span class="line">          self.handle.get_raw(),</span><br><span class="line">          Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">            ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">              data,</span><br><span class="line">              call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">              callback: Box::new(move |d: Result| &#123;</span><br><span class="line">                sender</span><br><span class="line">                  .send(d.and_then(|d| D::from_napi_value(d.0.env, d.0.value)))</span><br><span class="line">                  .map_err(|_| &#123;</span><br><span class="line">                    crate::Error::from_reason(&quot;Failed to send return value to tokio sender&quot;)</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)))</span><br><span class="line">          .cast(),</span><br><span class="line">          ThreadsafeFunctionCallMode::NonBlocking.into(),</span><br><span class="line">        )</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Threadsafe function call_async failed&quot;</span><br><span class="line">    )</span><br><span class="line">  &#125;)?;</span><br><span class="line">  receiver</span><br><span class="line">    .await</span><br><span class="line">    .map_err(|_| &#123;</span><br><span class="line">      crate::Error::new(</span><br><span class="line">        Status::GenericFailure,</span><br><span class="line">        &quot;Receive value from threadsafe function sender failed&quot;,</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">    .and_then(|ret| ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见call_async使用时将引入 Rust 的异步编程，我们可以使用async/await关键字来进行调用，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub async fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result &#123;</span><br><span class="line">  let result = match callback.call_async::(Ok(1)).await &#123;</span><br><span class="line">    Ok(res) =&gt; res,</span><br><span class="line">    Err(e) =&gt; &#123;</span><br><span class="line">      println!(&quot;Error: &#123;&#125;&quot;, e);</span><br><span class="line">      0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  println!(&quot;result: &#123;result:?&#125;&quot;);</span><br><span class="line">  Ok(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时生成的 JS 函数定义为如下，可以看出callThreadsafeFunction变成了一个异步函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function callThreadsafeFunction(callback: (err: Error | null, value: number) =&gt; any): Promise&lt;number&gt;</span><br></pre></td></tr></table></figure></p><p>所以在 JS 中调用方式及输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const result = await callThreadsafeFunction((err, value) =&gt; &#123;</span><br><span class="line">  return value + 1</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// result: 2</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p><h4 id="正确处理-JS-函数的返回值"><a href="#正确处理-JS-函数的返回值" class="headerlink" title="正确处理 JS 函数的返回值"></a>正确处理 JS 函数的返回值</h4><p>从前面call_async的实现可以看出，call_async返回的数据，也即 JS 函数返回值需要满足如下泛型约束D: ‘static + FromNapiValue，而 napi-rs 默认会为数值、字符串、布尔等基本 JS 数据类型实现FromNpiValuetrait，但是如果我们的 JS 回调想要返回一个对象时，则需要自己手动实现FromNpiValuetrait，这样可以让call_async获取到 JS 返回数据时自动调用FromNpiValuetrait 的from_napi_value方法将 JS 返回数据转换为 Rust 的数据格式，以下是一个简单的示例。</p><p>假如需要在 Rust 调用一个 JS 函数，JS 函数会返回一个对象，包含三个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  setPageName?: string,</span><br><span class="line">  changeExt?: boolean,</span><br><span class="line">  setSubPkgName?: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在 Rust 中获取到返回的对象，并转为 Rust 数据，那么首先我们可以定义一个类似的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">pub struct JSReturnObject &#123;</span><br><span class="line">  pub set_page_name: Option,</span><br><span class="line">  pub change_ext: Option,</span><br><span class="line">  pub set_sub_pkg_page_name: Option,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时为它实现FromNpiValuetrait 就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">impl FromNapiValue for JSReturnObject &#123;</span><br><span class="line">  unsafe fn from_napi_value(env: napi_env, napi_val: napi_value) -&gt; Result &#123;</span><br><span class="line">    let obj = JsObject::from_napi_value(env, napi_val)?;</span><br><span class="line">    let mut js_return_object = JSReturnObject &#123;</span><br><span class="line">      set_page_name: None,</span><br><span class="line">      change_ext: None,</span><br><span class="line">      set_sub_pkg_page_name: None,</span><br><span class="line">    &#125;;</span><br><span class="line">    let has_set_page_name = obj.has_named_property(&quot;setPageName&quot;)?;</span><br><span class="line">    let has_change_ext = obj.has_named_property(&quot;changeExt&quot;)?;</span><br><span class="line">    let has_set_sub_pkg_page_name = obj.has_named_property(&quot;setSubPkgName&quot;)?;</span><br><span class="line">    if has_set_page_name &#123;</span><br><span class="line">      js_return_object.set_page_name = Some(obj.get_named_property::(&quot;setPageName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_set_sub_pkg_page_name &#123;</span><br><span class="line">      js_return_object.set_sub_pkg_page_name = Some(obj.get_named_property::(&quot;setSubPkgName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_change_ext &#123;</span><br><span class="line">      js_return_object.change_ext = Some(obj.get_named_property::(&quot;changeExt&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(js_return_object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，先调用JsObject::from_napi_value方法将传入数据转为JsObject，然后调用</p><p>JsObject的has_named_property方法获取到对应的属性值，经过处理后可以构建出JSReturnObject结构体数据，并进行返回。而使用的时候，为call_async指定泛型参数类型为JSReturnObject，接下来就可以获取到 JS 返回值进行处理了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result: JSReturnObject = js_handler</span><br><span class="line">  .call_async(Ok(options.clone()))</span><br><span class="line">  .await</span><br><span class="line">  .with_context(|| format!(&quot;模板自定义函数调用失败: &#123;&#125;&quot;, file_relative_path))?;</span><br></pre></td></tr></table></figure></p><h2 id="使用-VSCode-进行调试"><a href="#使用-VSCode-进行调试" class="headerlink" title="使用 VSCode 进行调试"></a>使用 VSCode 进行调试</h2><p>我们可以使用 VSCode 来调试我们的 napi-rs 应用，我们可以参考Taro 项目，在项目的 .vscode 目录下新增 launch.json 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;lldb&quot;, // 调试器类型，这里指定为lldb，通常用于C/C++/Rust等语言</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;, // 请求类型，可以是&apos;launch&apos;或&apos;attach&apos;，&apos;launch&apos;表示启动一个新的调试会话</span><br><span class="line">      &quot;name&quot;: &quot;debug-init&quot;, // 配置名称，显示在VS Code的启动配置下拉菜单中</span><br><span class="line">      &quot;sourceLanguages&quot;: [&quot;rust&quot;], // 指定源码语言，此处为Rust</span><br><span class="line">      &quot;program&quot;: &quot;node&quot;, // 要调试的程序，这里是指Node.js的可执行文件</span><br><span class="line">      &quot;args&quot;: [</span><br><span class="line">        // 程序参数，这里指定了使用node运行taro-cli包的初始化命令，创建一个名为test_pro的新项目</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/packages/taro-cli/bin/taro&quot;,</span><br><span class="line">        &quot;init&quot;,</span><br><span class="line">        &quot;test_pro&quot;</span><br><span class="line">  ],</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 当前工作目录，这里指工作区根目录</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;build binding debug&quot;, // 调试前需要执行的任务的名称，这里指定了一个任务以在调试前构建项目</span><br><span class="line">      &quot;postDebugTask&quot;: &quot;remove test_pro&quot; // 调试后需要执行的任务的名称，此处指定了一个任务以在调试后清理或删除test_pro项目</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述配置中，指定调试器类型为lldb，启动一个新的调试会话来调试我们用 Rust 编写的程序，该程序主要通过 Node.js 来执行一个初始化新项目 test_pro 的命令，在调试开始前后会飞别执行 Rust binding 的构建以及 test_pro 项目的删除。</p><p>然后在要调试的代码处添加断点，然后执行调试即可。</p><h2 id="构建发布"><a href="#构建发布" class="headerlink" title="构建发布"></a>构建发布</h2><p>napi-rs 的项目模板默认基于 <a href="https://github.com/napi-rs/package-template/blob/main/.github/workflows/CI.yml" target="_blank" rel="noopener">Github Action</a> 来实现自动构建产物及发布，并且已经有相当完整的配置了，从Github Action配置文件中可以看到 CI 具体执行的任务，CI 任务首先会执行 package.json 中的构建命令，构建出各个端的 binding，并会actions/upload-artifact@v3action 将构建产物上传，然后会对构建产物执行相关测试，测试通过后会将构建产物下载下来，并执行artifacts命令将构建产物移动到目的文件夹下，最后会进行发布，当 git 提交信息为semver规范版本号时，将会触发 CI 发布，将包发到 NPM 中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;0.0.1&apos;</span><br></pre></td></tr></table></figure></p><p>前面提到我们一般只需要针对x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台进行构建，所以我们可以调整 Github Action 配置，去掉不需要构建的平台以提升 CI 速度。</p><p>此外，当我们有特殊需求的时候，例如不需要重新生成胶水 JS 代码、需要将构建产物移动到其他目录（默认是当前目录下的 npm 目录）下等等，可以查看<a href="https://github.com/napi-rs/napi-rs/tree/main/cli" target="_blank" rel="noopener">@napi-rs/cli</a>的文档进行相应调整。</p><p>不需要重新生成胶水 JS 代码，可以通过在napi build命令下添加–no-js实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;build&quot;: &quot;napi build --platform --release --no-js --dts binding.d.ts&quot;,</span><br><span class="line">  &quot;build:debug&quot;: &quot;napi build --platform --no-js --dts binding.d.ts&quot;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要将构建产物移动到其他目录，可以通过在napi artifacts命令下添加 –cwd 和 –npm-dir 参数来实现，前者指定工作目录，后者指定要移动的目录的相对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;artifacts&quot;: &quot;napi artifacts --npm-dir ../../npm2 --cwd ./&quot;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 在前端领域的应用无疑将成为未来的重要发展趋势，随着越来越多的公司和团队开始投入到这一领域，我们看到了 Rust 在前端研发生态构建中的独特优势和潜力，Rust 的高效性和安全性使其成为优化 Node 工具的理想选择。本文简单介绍了如何使用 NAPI-RS 来开发、调试和发布 Node 扩展，可以有效地优化我们的开发工具，并提升其性能。</p><p>在未来，我们可以预见 Rust 与前端结合的可能性将会更加广泛。随着 WebAssembly（WASM）的发展，我们可以期待 Rust 将在前端应用的性能优化、复杂应用的开发以及多线程等领域发挥更大的作用。同时，Rust 的出色的内存管理和错误处理机制也将帮助前端开发者构建更加健壮、安全的应用。</p><p>当然，Rust 与前端的结合并不仅仅限于性能优化，Rust 的优秀特性，如模式匹配、类型推断和零成本抽象，也为前端开发带来了新的编程范式和思维方式，这将有助于提升前端代码的可读性和可维护性，为前端开发提供了新的思考角度和工具，并可能引领前端开发进入一个全新的阶段。</p><p><a href="https://juejin.cn/post/7321410906426998810#heading-13" target="_blank" rel="noopener">来自</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Rust构建前端工具链&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="Rust" scheme="/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>solidity进阶</title>
    <link href="/2025/03/11/solidity%E8%BF%9B%E9%98%B6/"/>
    <id>/2025/03/11/solidity进阶/</id>
    <published>2025-03-11T01:56:30.000Z</published>
    <updated>2025-03-11T05:33:38.778Z</updated>
    
    <content type="html"><![CDATA[<p>solidity进阶-ERC20代币开发<br><a id="more"></a></p><h1 id="什么是ERC"><a href="#什么是ERC" class="headerlink" title="什么是ERC"></a>什么是ERC</h1><p>ERC 全称是“Ethereum Request for Comment”，表示以太坊的意见征求稿，ERC 中包含技术和组织等注意事项及标准。这套标准其实不光由以太坊官方提出，还由一些以太坊爱好者提出。是以太坊生态系统中被广泛使用的关键标准。</p><h2 id="代币-token-标准"><a href="#代币-token-标准" class="headerlink" title="代币(token)标准"></a>代币(token)标准</h2><ul><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/" target="_blank" rel="noopener">ERC-20</a> - 同质化（可互换）代币的标准接口，比如投票代币、质押代币或虚拟货币。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/" target="_blank" rel="noopener">ERC-721</a> - 非同质化代币的标准接口，比如艺术作品或歌曲的契约。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-777/" target="_blank" rel="noopener">ERC-777</a> - 关于 ERC-20 的代币标准改进。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/" target="_blank" rel="noopener">ERC-1155</a> - 一个能包括同质化和非同质化资产的代币标准。</li></ul><h2 id="ERC-20-代币"><a href="#ERC-20-代币" class="headerlink" title="ERC-20 代币"></a>ERC-20 代币</h2><p><code>千言万语汇成一句话：造钱</code></p><blockquote><p>什么叫做代币  代替货币 </p></blockquote><p>代币可以在以太坊中表示任何东西：</p><ul><li>在线平台中的信誉积分</li><li>游戏中一个角色的技能</li><li>彩票</li><li>金融资产类似于公司股份的资产</li><li>像美元一样的法定货币</li><li>一克黄金</li><li>以及更多</li></ul><blockquote><p>ERC-20以太坊代币标准是创建与更广泛的以太坊网络兼容的可替换代币的蓝图。以太坊，或称Ethereum，是一种加密货币，允许创建各种应用，包括代币，与大多数传统应用不同，它不需要中心化服务机构就可以运作。</p><p>简单来说，<strong>ERC-20</strong>就是一套<strong>基于以太坊网络的标准代币发行协议</strong>。有了ERC-20，<strong>开发者们得以高效、可靠、低成本地创造专属自己项目的代币；</strong>我们甚至可以将ERC-20视为以太坊网络为早期区块链世界做出的最重要贡献，也是以太坊网络第一个真正意义上的杀手级应用。</p></blockquote><p>如果我们把众多区块链项目的开发者，看作是在一个小区门口商铺里，经营不同业态的众多商户。这些商户根据自己的专长提供各自不同的商品和服务，也都希望发行自己店铺专属的消费储值卡。方便消费者光顾的同时，也能提升用户的体验和粘性</p><p>以太坊就像是运营这个小区底商的物业公司，它提供一整套标准化的储值卡发放协议和配套服务。借助这套叫做ERC-20的整体解决方案，每个商户（开发者）都可以傻瓜式地发行专属于自己店铺的消费储值卡，同时由于这种储值卡采用了统一的协议，可以非常方便地和其他商户的储值卡做无缝兑换。</p><p>于是借助ERC-20，用户可以通过持有其中一种储值卡（token）很方便地享受整个生态的各种服务；商户（开发者）则节约了开发运营成本、同时提升了获取用户的效率；而物业公司（以太坊基金会和矿工）则可以通过做大生态体量实现更多的租金（ETH增值）和储值卡结算手续费（Gas费用）收入。</p><p>ERC-20就是用这种做大生态价值的方式，实现了用户、开发者和以太坊网络三方面的共赢。</p><p><strong><em>ERC-20的应用案例</em></strong></p><p>为了让你对ERC-20有更具象化的认识，这里援引 <a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/author/alyssa.hertig" target="_blank" rel="noopener">Alyssa Hertig</a> 在 <a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">What is the ERC-20 Ethereum Token Standard?</a> 中列举的一些比较知名的基于ERC-20协议代币：</p><blockquote><p>Tether (USDT)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">Chainlink</a> (LINK)<br>Binance coin (BNB)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">USD coin</a> (USDC)<br>Wrapped bitcoin (WBTC)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">Dai</a> (DAI)</p></blockquote><p>需要特别指出的是，这上面提到的Tether发行的稳定币USDT除了基于ERC-20协议的版本之外，其实还有基于其他公链发行的多个版本，只不过ERC-20版的发行量最大，知名度也最高。</p><h1 id="openzeppelin-智能合约库"><a href="#openzeppelin-智能合约库" class="headerlink" title="openzeppelin 智能合约库"></a>openzeppelin 智能合约库</h1><p>官网：<a href="https://www.openzeppelin.com/" target="_blank" rel="noopener">https://www.openzeppelin.com/</a></p><p>GitHub：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts</a></p><p>OpenZeppelin 是一个使用以太坊智能合约语言 Solidity 进行构建的开发框架，可以简化智能合约和 Dapp 的开发。</p><p>OpenZeppelin合约和库已成为行业标准，其开源代码模板经历了以太坊及其他区块链的实战考验，帮助开发者最大限度降低风险。OpenZeppelin代码包括使用度最高的ERC标准及拓展部署，已被社区在各类指南以及操作教程中大量使用。</p><h2 id="Contract-Wizard"><a href="#Contract-Wizard" class="headerlink" title="Contract Wizard"></a>Contract Wizard</h2><p>OpenZeppelin开发了一种基于网络的线上智能合约交互式工具，它可能是使用OpenZeppelin代码编写智能合约最简单快捷的方式。这一工具称为<a href="https://docs.openzeppelin.com/contracts/4.x/wizard" target="_blank" rel="noopener">Contracts Wizard</a>。</p><h1 id="ERC-20-代币实现"><a href="#ERC-20-代币实现" class="headerlink" title="ERC-20 代币实现"></a>ERC-20 代币实现</h1><p><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top" target="_blank" rel="noopener">https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top</a></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</a></p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20" target="_blank" rel="noopener">https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol</a></p><p><a href="https://www.openzeppelin.com/contracts" target="_blank" rel="noopener">https://www.openzeppelin.com/contracts</a></p><p><a href="https://ethereum.org/zh/" target="_blank" rel="noopener">https://ethereum.org/zh/</a></p><p><a href="https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions" target="_blank" rel="noopener">https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions</a></p><p>ERC-20（以太坊意见征求 20）由 Fabian Vogelsteller 提出于 2015 年 11 月。这是一个能实现智能合约中代币的应用程序接口标准。</p><p>ERC-20 的功能示例包括：</p><ul><li>将代币从一个帐户转到另一个帐户</li><li>获取帐户的当前代币余额</li><li>获取网络上可用代币的总供应量</li><li>批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><p>如果智能合约实施了下列方法和事件，它可以被称为 ERC-20 代币合约， 一旦部署，将负责跟踪以太坊上创建的代币。</p><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function name() public view returns (string)</span><br><span class="line">function symbol() public view returns (string)</span><br><span class="line">function decimals() public view returns (uint8)</span><br><span class="line">function totalSupply() public view returns (uint256)</span><br><span class="line">function balanceOf(address _owner) public view returns (uint256 balance)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success)</span><br><span class="line">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span><br></pre></td></tr></table></figure><p>事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 _value)</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value)</span><br></pre></td></tr></table></figure><h2 id="代币1"><a href="#代币1" class="headerlink" title="代币1"></a>代币1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract QfCoin &#123;</span><br><span class="line">    event Transfer(address, address, uint256);</span><br><span class="line">    event Approval(address, address, uint256);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    // override 重载</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, string memory _symbol) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // transfer() 函数 IERC20 中的 transfer 函数， Token 实现。调用方 amount 币会增加 Token 数量，接收方此函数相应的狗改土，加入、分红、抽奖等。</span><br><span class="line">    //  转账函数</span><br><span class="line">    function transfer(address recipient, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // approve 函数</span><br><span class="line">    // approve() 函数：IERC20 的 approve 函数， Token 授权逻辑。被授权方 spender 可以控制授权方的 amount 数量的 Token 。</span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // transferFrom() 功能：IERC20 中的 transferFrom 函数，授权逻辑。被授权方将授权方实现 sender 的 amount 数量的 Token 授权给接收方 recipient。</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] == amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(uint256 amount) public &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代币2"><a href="#代币2" class="headerlink" title="代币2"></a>代币2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.9;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    /*</span><br><span class="line">    &#123;</span><br><span class="line">        addressA: 90,</span><br><span class="line">        addressB: 0,</span><br><span class="line">        addressC: 20,</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    event Transfer(address _from, address _to, uint256 _value);</span><br><span class="line">    event Approval(address _owner, address _spender, uint256 _value);</span><br><span class="line">    // 代币的名字与标识 数量</span><br><span class="line">    uint256 _totalSupply;</span><br><span class="line">    string _name;</span><br><span class="line">    string _symbol;</span><br><span class="line">    uint8 _decimals;</span><br><span class="line">    // 创建地址与余额的映射</span><br><span class="line">    mapping(address =&gt; uint256) _balanceOf;</span><br><span class="line">    // 创建授权额度的结构</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) _allowance;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    address1 : &#123;</span><br><span class="line">        address11:1000w</span><br><span class="line">        address22:200w</span><br><span class="line">    &#125; </span><br><span class="line">    address3:&#123;</span><br><span class="line">        address11:1000w</span><br><span class="line">        address22:200w</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        _name = &quot;HeHeCoin&quot;;</span><br><span class="line">        _symbol = &quot;HHC&quot;;</span><br><span class="line">        _decimals = 18;</span><br><span class="line">        _totalSupply = 100 * 10000 * 10**_decimals;</span><br><span class="line">        _balanceOf[msg.sender] += _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取一下代币的名字</span><br><span class="line">    function name() public view returns (string memory) &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function symbol() public view returns (string memory) &#123;</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decimals() public view returns (uint8) &#123;</span><br><span class="line">        return _decimals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据地址获取余额</span><br><span class="line">    function balanceOf(address _owner) public view returns (uint256) &#123;</span><br><span class="line">        return _balanceOf[_owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转账</span><br><span class="line">    function transfer(address _to, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        _balanceOf[msg.sender] -= _value;</span><br><span class="line">        _balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // token的逻辑授权 给被授权方一定的权限 可以直接转移授权方的同肯</span><br><span class="line">    function approve(address _spender, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        //  调用这个方法的人</span><br><span class="line">        _allowance[msg.sender][_spender] = _value;</span><br><span class="line">        emit Approval(msg.sender, _spender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看额度</span><br><span class="line">    function allowance(address _owner, address _spender)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return _allowance[_owner][_spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  被给与额度的账户主动的 划走代币</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) public returns (bool success) &#123;</span><br><span class="line">        // 额度减少</span><br><span class="line">        _allowance[_from][_to] -= _value;</span><br><span class="line">        // 被划走账户余额减少</span><br><span class="line">        _balanceOf[_from] -= _value;</span><br><span class="line">        // 划走账户的余额添加</span><br><span class="line">        _balanceOf[_to] += _value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</span><br><span class="line">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span><br><span class="line">0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  : &#123;</span><br><span class="line">       0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2: 100w,</span><br><span class="line">       0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db: 50w,</span><br><span class="line">   &#125;</span><br><span class="line">   0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB : &#123;</span><br><span class="line">       0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2:666,</span><br><span class="line">       0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db:777,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  100w </span><br><span class="line">授权   0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2  666</span><br><span class="line">授权   0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db  777</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="ERC-20代币部署"><a href="#ERC-20代币部署" class="headerlink" title="ERC-20代币部署"></a>ERC-20代币部署</h1><ol><li>将环境切换切MetaMask钱包环境并选择钱包账户</li></ol><p><img src="/2025/03/11/solidity进阶/1.png" alt="image-20221212212504003"></p><ol start="2"><li>点击Deploy ，输入代币的名字和表示 部署合约</li></ol><p><img src="/2025/03/11/solidity进阶/2.png" alt="image-20221212212645585"></p><p>部署成功结果</p><p><img src="/2025/03/11/solidity进阶/3.png" alt="image-20221212213033774"></p><p>合约地址 0x639DfECe957A8D705f028D1950890598C30789ed</p><p>交易hash 0x28aa84834efc9c787c4cd584128f456e16b933eddf250859833b395656153847</p><p>在metaMask 添加代币</p><p><img src="/2025/03/11/solidity进阶/4.png" alt="image-20221212214003856"></p><p><img src="/2025/03/11/solidity进阶/5.png" alt="image-20221212214043557"></p><p>智能合约初始化的时候没有规定代币的数量，所以添加结果为0MTC</p><p><img src="/2025/03/11/solidity进阶/6.png" alt="image-20221212214148279"></p><p>后续通过mint 铸造方法，添加货币</p><p><img src="/2025/03/11/solidity进阶/7.png" alt="image-20221212214355382"></p><p>接下来就可以在测试网络中进行代币转账了</p><h1 id="Web3-js-和-ether-js-介绍"><a href="#Web3-js-和-ether-js-介绍" class="headerlink" title="Web3.js 和 ether.js 介绍"></a>Web3.js 和 ether.js 介绍</h1><p>Web3.js 和 ethers.js 都是 JavaScript 库，其作用是使开发者可以与以太坊区块链交互。这两个库都很实用，都能满足大多数以太坊开发者的需求。下面将重点围绕 Web3.js 和 Ethers.js 的相同点和不同点来对它们进行比较，以便你能更好地理解它们的细微区别。</p><p> 什么是 web3.js？ </p><p><img src="/2025/03/11/solidity进阶/8.png" alt="image.png"></p><p>Web3.js 是一个由以太坊基金会开发和维护的开源JavaScript库，使用HTTP或 IPC(Inter-Process Communication进程间通信) 连接 或 WebSocket 来和本地或远程以太坊节点进行交互的库。类比于 JavaScript库 axios 对 Web 服务器进行 Ajax 调用，您可以使用Web3.js来读取和写入以太坊区块链。</p><p>web3.js。因此，有更广泛的支持，因为有更多的开发人员支持它。</p><p>Web3.js 库由一系列模块的集合，服务于以太坊生态系统的各个功能，如：</p><p>●web3-eth 用来与以太坊区块链及合约的交互；</p><p>●web3-shh Whisper 协议相关，进行p2p通信和广播；</p><p>●web3-bzz swarm 协议（去中心化文件存储）相关；</p><p>●web3-utils 包含一些对 DApp 开发者有用的方法。</p><p>官网：<a href="https://web3js.org/" target="_blank" rel="noopener">https://web3js.org</a></p><p>GitHub: <a href="https://github.com/web3/web3.js" target="_blank" rel="noopener">https://github.com/web3/web3.js</a></p><p> 什么是 ethers.js？ </p><p>ETHERS.JS</p><p><img src="/2025/03/11/solidity进阶/9.png" alt="image.png"></p><p>ethers.js库旨在为以太坊区块链及其生态系统提供一个小而完整的 JavaScript API 库，ethers.js 对比使用 web3.js 代码量更少，接口也更简洁。</p><p>可以通过<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a>、<a href="https://infura.io/" target="_blank" rel="noopener">INFURA</a>、<a href="https://etherscan.io/" target="_blank" rel="noopener">Etherscan</a>、<a href="https://alchemyapi.io/" target="_blank" rel="noopener">Alchemy</a>、<a href="https://developers.cloudflare.com/distributed-web/ethereum-gateway/" target="_blank" rel="noopener">Cloudflare</a>或<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>连接到以太坊节点。</p><p>与 web3.js 相似，ethers.js 常用模块有:</p><p>●Ethers.provider 封装与以太坊区块链的连接。它可以用于签发查询和发送已签名的交易，这将改变区块链的状态。</p><p>●Ethers.contract 部署智能合约并与它交互。具体来说，该模块中的函数用于侦听从智能合约发射的事件、调用智能合约提供的函数、获取有关智能合约的信息，以及部署智能合约。</p><p>●Ethers.utils 提供用于格式化数据和处理用户输入的实用程序函数。Ethers.utils 的作用方式与 web3-utils 相似，能够简化去中心化应用的构建流程。</p><p>●Ethers.wallets 提供的功能与我们目前讨论过的其他模块截然不同。Ethers.wallet 的作用是使你可以与现有钱包（以太坊地址）建立连接、创建新钱包以及对交易签名。</p><p>官网：<a href="https://ethers.org/" target="_blank" rel="noopener">https://ethers.org</a></p><p>GitHub：<a href="https://github.com/ethers-io/ethers.js" target="_blank" rel="noopener">https://github.com/ethers-io/ethers.js</a></p><p> web3.js 和 ethers.js 该如何选择 </p><p> 作者对比 </p><p>Web3.js 所有者是<a href="https://ethereum.org/en/" target="_blank" rel="noopener">以太坊基金会</a></p><p>ethers.js 所有者是Richard Moore</p><p>两个库都能够完成任务。Ethers.js 在近两年来越来越受欢迎，下载量和项目使用量都不断增加。Web3.js 一直以来都作为标杆存在，并且仍然拥有许多开发者共享资源。后面将介绍如何连接到 <a href="https://infura.io/dashboard" target="_blank" rel="noopener">Infura API</a> 并使用 web3.js 和 ethers.js 发送交易。</p><h1 id="web3-与智能合约"><a href="#web3-与智能合约" class="headerlink" title="web3 与智能合约"></a>web3 与智能合约</h1><ol><li>获取合约部署后的配置文件  在 <code>artifacts</code> 下的的 <code>合约名.json</code>文件</li><li><img src="/2025/03/11/solidity进阶/10.png" alt="image-20221212221505979"></li></ol><p><a href="https://web3js.readthedocs.io/en/v1.8.1/" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/v1.8.1/</a></p><h2 id="window-ethereum-API"><a href="#window-ethereum-API" class="headerlink" title="window.ethereum API"></a><strong>window.ethereum API</strong></h2><p>MetaMask会向网页注入一个全局的API变量window.ethereum，出于历史遗留原因， 这个全局API变量也可以使用window.web3.currentProvider来访问。该API允许 网站请求用户登录，可以从用户接入的区块链读取数据，并切能够提示用户签名 要提交的交易。</p><p>你可以使用这个API来检测一个浏览器是否注入了window.ethereum：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ethereum !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'MetaMask is installed!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ethereum API本身很简单，它同时也封装了以太坊JSON-RPC消息，就像那些流行的库例如web3、 truffle、ethjs、Embark等等一样。</p><h3 id="ethereum-isConnected"><a href="#ethereum-isConnected" class="headerlink" title="ethereum.isConnected()"></a>ethereum.isConnected()</h3><p>如果提供者连接到当前链返回true，否则返回false。</p><p>如果提供商未连接，则必须重新加载页面才能重新建立连接。</p><h3 id="eth-requestAccounts-请求用户授权"><a href="#eth-requestAccounts-请求用户授权" class="headerlink" title="eth_requestAccounts - 请求用户授权"></a>eth_requestAccounts - 请求用户授权</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方式1</span></span><br><span class="line">ethereum.request(&#123; <span class="attr">method</span>: <span class="string">'eth_requestAccounts'</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// You now have an array of accounts!</span></span><br><span class="line">    <span class="comment">// Currently only ever one:</span></span><br><span class="line">    <span class="comment">// ['0xFDEa65C8e26263F459A1B5de9555D2931A33b825']</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason === <span class="string">"User rejected provider access"</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="ethereum-selectedAddress-获取当前用户账号"><a href="#ethereum-selectedAddress-获取当前用户账号" class="headerlink" title="ethereum.selectedAddress - 获取当前用户账号"></a>ethereum.selectedAddress - 获取当前用户账号</h3><p>ethereum.selectedAddress 属性返回表示用户当前选择的以太坊账号，16进制字符串表示</p><h3 id="ethereum-isMetaMask-检测是否使用MetaMask"><a href="#ethereum-isMetaMask-检测是否使用MetaMask" class="headerlink" title="ethereum.isMetaMask - 检测是否使用MetaMask"></a>ethereum.isMetaMask - 检测是否使用MetaMask</h3><p>ethereum.isMetaMask返回true或false，表示当前用户是否安装了MetaMask。</p><h3 id="ethereum-autoRefreshOnNetworkChange-网络切换时是否自动刷新"><a href="#ethereum-autoRefreshOnNetworkChange-网络切换时是否自动刷新" class="headerlink" title="ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新"></a>ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新</h3><p>当用户切换网络时，MetaMask扩展会自动刷新。 ethereum.autoRefreshOnNetworkChange这个实验性质的属性允许你关闭 默认的网络切换自动刷新功能。</p><h3 id="ethereum-on-监听MetaMask事件"><a href="#ethereum-on-监听MetaMask事件" class="headerlink" title="ethereum.on() - 监听MetaMask事件"></a>ethereum.on() - 监听MetaMask事件</h3><p>ethereum.on()方法用来监听MetaMask的事件，其原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethereum.on(eventName, callback)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>eventName：要监听的事件名称</li><li>callback：事件触发时的回调函数</li></ul><p>目前支持下列事件：</p><ul><li>accountsChanged：当用户选中账号变化时触发</li><li>networkChanged：当所连接网络ID变化时触发</li></ul><p>注意：networkChanged事件只有当你禁用ethereum.autoRefreshOnNetworkChange属性时才有用。</p><p>下面的代码在用户切换MetaMask账号后输出新账号到控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ethereum.on(<span class="string">'accountsChanged'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(accounts[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="调用智能合约-MetaMask"><a href="#调用智能合约-MetaMask" class="headerlink" title="调用智能合约(MetaMask)"></a>调用智能合约(MetaMask)</h2><h3 id="实例web3"><a href="#实例web3" class="headerlink" title="实例web3"></a>实例web3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="keyword">import</span> mtcContract <span class="keyword">from</span> <span class="string">"./contracts/contract_Ballot.json"</span>;</span><br><span class="line"><span class="comment">// 链接上web3 格尔丽的环境</span></span><br><span class="line"><span class="keyword">const</span> geerliWS =</span><br><span class="line">  <span class="string">"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb"</span>;</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || geerliWS);</span><br></pre></td></tr></table></figure><h3 id="账户链接"><a href="#账户链接" class="headerlink" title="账户链接"></a>账户链接</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> account = <span class="keyword">await</span> web3.eth.requestAccounts();</span><br></pre></td></tr></table></figure><h3 id="实例合约"><a href="#实例合约" class="headerlink" title="实例合约"></a>实例合约</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> web3.eth.Contract(智能合约abi,合约地址)</span><br><span class="line"><span class="keyword">this</span>.votoContract = <span class="keyword">new</span> web3.eth.Contract(</span><br><span class="line">      mtcContract.abi,</span><br><span class="line">      <span class="string">"0x1D108E4B9162668e1adACD07727b3de749818d0a"</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>不需要消耗gas的方法 call (不修改数据的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.methods.myMethod([param1[, param2[, ...]]]).call(options [, defaultBlock] [, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the callback</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).call(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using the promise</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).call(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改数据消耗gas的方法 send</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.methods.myMethod([param1[, param2[, ...]]]).send(options[, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the callback</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).send(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, transactionHash</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using the promise</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).send(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">receipt</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// receipt can also be a new contract instance, when coming from a "contract.deploy(&#123;...&#125;).send()"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意:数据修改完成后根据需求监听<code>receipt</code>事件</p></li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.events.MyEvent([options][, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myContract.events.MyEvent(&#123;</span><br><span class="line">    filter: &#123;<span class="attr">myIndexedParam</span>: [<span class="number">20</span>,<span class="number">23</span>], <span class="attr">myOtherIndexedParam</span>: <span class="string">'0x123456789...'</span>&#125;, <span class="comment">// Using an array means OR: e.g. 20 or 23</span></span><br><span class="line">    fromBlock: <span class="number">0</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, event</span>)</span>&#123; <span class="built_in">console</span>.log(event); &#125;)</span><br><span class="line">.on(<span class="string">"connected"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">subscriptionId</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(subscriptionId);</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event); <span class="comment">// same results as the optional callback above</span></span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'changed'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// remove event from local database</span></span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, receipt</span>) </span>&#123; <span class="comment">// If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;web3 与智能合约&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;代币信息&lt;/h1&gt;</span><br><span class="line">    名称: &#123;&#123; name  &#125;&#125; &lt;br&gt;</span><br><span class="line">    标识: &#123;&#123; symbol &#125;&#125; &lt;br&gt;</span><br><span class="line">    发行量 &#123;&#123; web3.utils.fromWei(totalSupply,&quot;ether&quot; ) &#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;账户信息&lt;/h2&gt;</span><br><span class="line">    地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br&gt;</span><br><span class="line">    余额: &#123;&#123;web3.utils.fromWei(balanceOf,&quot;ether&quot;)&#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;操作&lt;/h2&gt;</span><br><span class="line">    收款方: &lt;input type=&quot;text&quot; v-model=&quot;toAddress&quot;&gt; &lt;br&gt;</span><br><span class="line">    金额:&lt;input type=&quot;text&quot; v-model=&quot;money&quot;&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;转账&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const Web3 = require(&quot;web3&quot;);</span><br><span class="line">import &#123; abi &#125; from &quot;./contracts/HHC.json&quot;;</span><br><span class="line">console.log(abi);</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:&quot;&quot;,</span><br><span class="line">      symbol:&quot;&quot;,</span><br><span class="line">      totalSupply: &quot;&quot;,</span><br><span class="line">      balanceOf: &quot;&quot;,</span><br><span class="line">      accounts:[],</span><br><span class="line">      toAddress: &quot;0xE251ddBe6191594922bfd3d338529EC9C613eB67&quot;,</span><br><span class="line">      money:1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 初始化web3实例</span><br><span class="line">    async initWeb3() &#123;</span><br><span class="line">      const geerliWS =</span><br><span class="line">        &quot;wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;;</span><br><span class="line">      this.web3 = new Web3(Web3.givenProvider || geerliWS);</span><br><span class="line">      // 获取metamask钱包使用的用户</span><br><span class="line">      this.accounts = await this.web3.eth.requestAccounts();</span><br><span class="line">      console.log( this.accounts)</span><br><span class="line">      this.initContract();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化智能合约</span><br><span class="line">    initContract() &#123;</span><br><span class="line">      // 代币 hhc 智能合约地址</span><br><span class="line">      this.HccCont = new this.web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        &quot;0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5&quot;</span><br><span class="line">      );</span><br><span class="line">      this.getCoinInfo();</span><br><span class="line">      this.addEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取代币的信息</span><br><span class="line">    async getCoinInfo() &#123;</span><br><span class="line">      // 不修改状态数据 不消耗gas</span><br><span class="line">      this.name = await this.HccCont.methods.name().call();</span><br><span class="line">      this.symbol = await this.HccCont.methods.symbol().call();</span><br><span class="line">      this.totalSupply = await this.HccCont.methods.totalSupply().call();</span><br><span class="line">      this.balanceOf = await this.HccCont.methods.balanceOf(this.accounts[0]).call();</span><br><span class="line">    &#125;,</span><br><span class="line">    send() &#123;</span><br><span class="line">      // 修改状态数据</span><br><span class="line">      const weiNum = this.web3.utils.toWei(String(this.money), &apos;ether&apos;);</span><br><span class="line">      console.log(weiNum)</span><br><span class="line">      this.HccCont.methods.transfer(this.toAddress,weiNum).send(&#123;</span><br><span class="line">        from: this.accounts[0],</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(&apos;receipt&apos;, function(receipt)&#123;</span><br><span class="line">        console.log(&quot;交易成功&quot;)</span><br><span class="line">        console.log(receipt)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    addEvents() &#123;</span><br><span class="line">      this.HccCont.events.Transfer(&#123;</span><br><span class="line">        filter: &#123;&#125;,</span><br><span class="line">        fromBlock: 8161338,</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(&quot;data&quot;,(event) =&gt; &#123;</span><br><span class="line">        console.log(&quot;events transfer&quot;);</span><br><span class="line">        console.log(event)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    if (typeof window.ethereum !== &quot;undefined&quot;) &#123;</span><br><span class="line">      console.log(&quot;MetaMask is installed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.initWeb3();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="调用智能合约-纯web3"><a href="#调用智能合约-纯web3" class="headerlink" title="调用智能合约(纯web3)"></a>调用智能合约(纯web3)</h2><blockquote><p>调用智能合约也相当于是通过web3 发起一个交易</p><p>核心在于  web3.eth.sendSignedTransaction(transHash)</p><p>在构建hash数据时候将调用的合约信息添加进入</p></blockquote><h3 id="构建调用智能合约交易hash"><a href="#构建调用智能合约交易hash" class="headerlink" title="构建调用智能合约交易hash"></a>构建调用智能合约交易hash</h3><p>将智能合约的方法调用 通过<code>encodeABI</code>进行转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contractData = <span class="keyword">await</span> contract.methods.transfer(<span class="string">"转账地址"</span>,web3.utils.toWei(<span class="string">'转账金额'</span>)).encodeABI()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建交易hash</span></span><br><span class="line"><span class="keyword">async</span> createTransationHx(key, fromAddress, toAddress, money) &#123;</span><br><span class="line">  <span class="comment">// key 私钥</span></span><br><span class="line">  <span class="comment">// fromAddress 发送方地址</span></span><br><span class="line">  <span class="comment">// toAddress 接受方地址</span></span><br><span class="line">  <span class="comment">// money 转账金额</span></span><br><span class="line">  <span class="comment">// 当前地址交易次数</span></span><br><span class="line">  <span class="keyword">const</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromAddress);</span><br><span class="line">  <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">  <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">  <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.utils.toWei(money);</span><br><span class="line"><span class="keyword">const</span> contractData = <span class="keyword">await</span> contract.methods.transfer(<span class="string">"0x9B0DbF610175F5c783ec169DAdDa5E8B17055626"</span>,web3.utils.toWei(<span class="string">'30000'</span>)).encodeABI()</span><br><span class="line">  <span class="comment">// 转账的记录对象</span></span><br><span class="line">  <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">    <span class="keyword">from</span>: fromAddress,</span><br><span class="line">    nonce: nonce,</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">    to:<span class="string">""</span>,<span class="comment">//智能合约地址,</span></span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    data: contractData, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">  <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">  rawTx.gas = gas;</span><br><span class="line">  <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">  <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">  tx.sign(privateKey);</span><br><span class="line">  <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">  <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">  <span class="keyword">return</span> transationHx;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="常规转账发起"><a href="#常规转账发起" class="headerlink" title="常规转账发起"></a>常规转账发起</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> sendToken() &#123;</span><br><span class="line">     <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">     <span class="keyword">let</span> keystore = <span class="keyword">this</span>.walletInfo.keystore;</span><br><span class="line">     <span class="keyword">let</span> wallet;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">       alert(<span class="string">"密码错误"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(prikey)</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">from</span>  = <span class="keyword">this</span>.walletInfo.lowerCaseAddress;</span><br><span class="line">     <span class="keyword">const</span> to = <span class="keyword">this</span>.to;</span><br><span class="line">     <span class="keyword">const</span> money = <span class="keyword">this</span>.money;</span><br><span class="line">     <span class="comment">// 获取交易hx</span></span><br><span class="line">     <span class="keyword">const</span> transHash = <span class="keyword">await</span> <span class="keyword">this</span>.createTransationHx(prikey,<span class="keyword">from</span>,to,money)</span><br><span class="line">     <span class="comment">// 发布交易信息</span></span><br><span class="line">     web3.eth</span><br><span class="line">       .sendSignedTransaction(transHash)</span><br><span class="line">       .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">       &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">         <span class="keyword">const</span> &#123; transactionHash &#125; = ret;</span><br><span class="line">         <span class="comment">// 从区块节点中获取交易hash</span></span><br><span class="line">         <span class="keyword">this</span>.createOrderData(transactionHash);</span><br><span class="line">       &#125;)</span><br><span class="line">       .on(<span class="string">'confirmation'</span>, (ret)=&gt;&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'confirmation'</span>,ret)</span><br><span class="line">       &#125;)</span><br><span class="line">       .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;web3 与智能合约&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;代币信息&lt;/</span>h1&gt;</span><br><span class="line">    名称: &#123;&#123; name &#125;&#125; &lt;br /&gt;</span><br><span class="line">    标识: &#123;&#123; symbol &#125;&#125; &lt;br /&gt;</span><br><span class="line">    发行量 &#123;&#123; web3.utils.fromWei(totalSupply, <span class="string">"ether"</span>) &#125;&#125; &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;账户信息&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br /</span>&gt;</span><br><span class="line">    eth余额: &#123;&#123; web3.utils.fromWei(ethBalance, <span class="string">"ether"</span>) &#125;&#125;&lt;br /&gt;</span><br><span class="line">    代币余额: &#123;&#123; web3.utils.fromWei(balanceOf, <span class="string">"ether"</span>) &#125;&#125; &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;操作&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    收款方: &lt;input type="text" v-model="toAddress" /</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    金额:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"money"</span> /&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    &lt;button @click=<span class="string">"send"</span>&gt;代币转账&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="sendEth"&gt;转账Eth&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="keyword">const</span> Tx = <span class="built_in">require</span>(<span class="string">"ethereumjs-tx"</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; abi &#125; <span class="keyword">from</span> <span class="string">"./contracts/HHC.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(abi);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">""</span>,</span><br><span class="line">      symbol: <span class="string">""</span>,</span><br><span class="line">      totalSupply: <span class="string">""</span>,</span><br><span class="line">      balanceOf: <span class="string">""</span>,</span><br><span class="line">      accounts: [],</span><br><span class="line">      toAddress: <span class="string">"0xE251ddBe6191594922bfd3d338529EC9C613eB67"</span>,</span><br><span class="line">      money: <span class="string">"1"</span>,</span><br><span class="line">      ethBalance: <span class="string">"0"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 初始化web3实例</span></span><br><span class="line">    <span class="keyword">async</span> initWeb3() &#123;</span><br><span class="line">      <span class="keyword">const</span> geerliWS =</span><br><span class="line">        <span class="string">"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb"</span>;</span><br><span class="line">      <span class="keyword">this</span>.web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || geerliWS);</span><br><span class="line">      <span class="comment">// 获取metamask钱包使用的用户</span></span><br><span class="line">      <span class="keyword">this</span>.accounts = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.requestAccounts();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.accounts);</span><br><span class="line">      <span class="keyword">this</span>.ethBalance = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getBalance(<span class="keyword">this</span>.accounts[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.ethBalance);</span><br><span class="line">      <span class="keyword">this</span>.initContract();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 初始化智能合约</span></span><br><span class="line">    initContract() &#123;</span><br><span class="line">      <span class="comment">// 代币 hhc 智能合约地址</span></span><br><span class="line">      <span class="keyword">this</span>.HccCont = <span class="keyword">new</span> <span class="keyword">this</span>.web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        <span class="string">"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">this</span>.getCoinInfo();</span><br><span class="line">      <span class="keyword">this</span>.addEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取代币的信息</span></span><br><span class="line">    <span class="keyword">async</span> getCoinInfo() &#123;</span><br><span class="line">      <span class="comment">// 不修改状态数据 不消耗gas</span></span><br><span class="line">      <span class="keyword">this</span>.name = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.name().call();</span><br><span class="line">      <span class="keyword">this</span>.symbol = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.symbol().call();</span><br><span class="line">      <span class="keyword">this</span>.totalSupply = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.totalSupply().call();</span><br><span class="line">      <span class="keyword">this</span>.balanceOf = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods</span><br><span class="line">        .balanceOf(<span class="keyword">this</span>.accounts[<span class="number">0</span>])</span><br><span class="line">        .call();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过metamask 调用智能合约</span></span><br><span class="line">    send() &#123;</span><br><span class="line">      <span class="comment">// 修改状态数据</span></span><br><span class="line">      <span class="keyword">const</span> weiNum = <span class="keyword">this</span>.web3.utils.toWei(<span class="built_in">String</span>(<span class="keyword">this</span>.money), <span class="string">"ether"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(weiNum);</span><br><span class="line">      <span class="keyword">this</span>.HccCont.methods</span><br><span class="line">        .transfer(<span class="keyword">this</span>.toAddress, weiNum)</span><br><span class="line">        .send(&#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="keyword">this</span>.accounts[<span class="number">0</span>],</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">receipt</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易成功"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(receipt);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 生成交易的hash 数据</span></span><br><span class="line">    <span class="keyword">async</span> createTransationHx(prikey,<span class="keyword">from</span>,to,money) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"money"</span>,<span class="keyword">typeof</span> money, money)</span><br><span class="line">       <span class="comment">// 当前地址交易次数</span></span><br><span class="line">      <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(prikey, <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">      <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getGasPrice();</span><br><span class="line">      <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">this</span>.web3.utils.toWei(money);</span><br><span class="line">      <span class="comment">// 转账的记录对象</span></span><br><span class="line">      <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        nonce: nonce,</span><br><span class="line">        gasPrice: gasPrice,</span><br><span class="line">        to,<span class="comment">//智能合约地址,</span></span><br><span class="line">        value: value,</span><br><span class="line">        data:<span class="string">""</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">       <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.estimateGas(rawTx);</span><br><span class="line">       rawTx.gas = gas;</span><br><span class="line">        <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">      <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">      <span class="keyword">return</span> transationHx;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代币转账</span></span><br><span class="line">    <span class="keyword">async</span> createCoinTransationHx(prikey,<span class="keyword">from</span>,to,money) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"money"</span>,<span class="keyword">typeof</span> money, money)</span><br><span class="line">       <span class="comment">// 当前地址交易次数</span></span><br><span class="line">      <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(prikey, <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">      <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getGasPrice();</span><br><span class="line">      <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">this</span>.web3.utils.toWei(money);</span><br><span class="line">      <span class="comment">// 转账的记录对象</span></span><br><span class="line">      <span class="comment">// 代币转账</span></span><br><span class="line">      <span class="keyword">const</span> contractAbi = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.transfer(to,value).encodeABI();</span><br><span class="line">      <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        nonce: nonce,</span><br><span class="line">        gasPrice: gasPrice,</span><br><span class="line">        to:<span class="string">'0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5'</span>,<span class="comment">//eth 转账 to 目标地址 ，智能合约 to 智能合约地址</span></span><br><span class="line">        value: <span class="number">0</span>, <span class="comment">//eth 转账 数量</span></span><br><span class="line">        data:contractAbi, <span class="comment">//智能合约方法的abi编码</span></span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">       <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.estimateGas(rawTx);</span><br><span class="line">       rawTx.gas = gas;</span><br><span class="line">        <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">      <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">      <span class="keyword">return</span> transationHx;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过纯web3调用智能合约</span></span><br><span class="line">    <span class="keyword">async</span> sendEth() &#123;</span><br><span class="line">      <span class="keyword">const</span> prikey =</span><br><span class="line">        <span class="string">"71676f2ff44e36e78a276b16ac389ee8536790c8dfb12392c002050d6f162902"</span>;</span><br><span class="line">      <span class="comment">// 获取转账的hash</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">from</span> = <span class="keyword">this</span>.accounts[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 代币hash</span></span><br><span class="line">      <span class="keyword">const</span> transHash = <span class="keyword">await</span> <span class="keyword">this</span>.createCoinTransationHx(prikey, <span class="keyword">from</span>, <span class="keyword">this</span>.toAddress, <span class="keyword">this</span>.money);</span><br><span class="line">      <span class="comment">// 珠链币的hash</span></span><br><span class="line">      <span class="comment">// const transHash = await this.createTransationHx(prikey, from, this.toAddress, this.money);</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"transHash"</span>,transHash);</span><br><span class="line">      <span class="comment">// 发起交易</span></span><br><span class="line">      <span class="keyword">this</span>.web3.eth</span><br><span class="line">        .sendSignedTransaction(transHash)</span><br><span class="line">        .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    addEvents() &#123;</span><br><span class="line">      <span class="keyword">this</span>.HccCont.events</span><br><span class="line">        .Transfer(&#123;</span><br><span class="line">          filter: &#123;&#125;,</span><br><span class="line">          fromBlock: <span class="number">8161338</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"data"</span>, (event) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"events transfer"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(event);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ethereum !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"MetaMask is installed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.initWeb3();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solidity进阶-ERC20代币开发&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>solidity入门</title>
    <link href="/2025/03/11/solidity%E5%85%A5%E9%97%A8/"/>
    <id>/2025/03/11/solidity入门/</id>
    <published>2025-03-11T01:53:27.000Z</published>
    <updated>2025-03-11T05:23:41.472Z</updated>
    
    <content type="html"><![CDATA[<p>solidity语法基础入门<br><a id="more"></a></p><h1 id="Solidity-开发环境"><a href="#Solidity-开发环境" class="headerlink" title="Solidity 开发环境"></a>Solidity 开发环境</h1><ol><li>Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。</li><li>以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常用的以太坊开发环境包括Truffle、Embark和Buidler （Hardhat）。</li><li>以太坊虚拟机：以太坊虚拟机（Ethereum Virtual Machine，EVM）是以太坊区块链的运行环境，用于在以太坊区块链上运行智能合约。常用的以太坊虚拟机包括ganache-cli和geth。</li><li>以太坊浏览器：以太坊浏览器是一种用于浏览、搜索和交互以太坊区块链数据的工具。常用的以太坊浏览器包括Etherscan、Etherchain和Blockchain Explorer。</li></ol><h2 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a><a href="https://hardhat.org/" target="_blank" rel="noopener">Hardhat</a></h2><p><a href="https://hardhat.org/" target="_blank" rel="noopener">https://hardhat.org/</a></p><p>Hardhat是目前最好的框架之一，支持快速测试，同时提供了最好的教程和最简单的集成。 老实说，每个喜欢JS框架的人都应该在某个时候试用Hardhat。它真的很容易上手，具有快速的测试， 而且入门非常简单。Hardhat的Discord也总是非常迅速地回答问题，因此，如果遇到问题，你 总是可以寻求帮助。Hathat使用Waffle和Ethers.js进行测试 —— 可以说是更好的JavaScript 智能合约框架 —— 开发人员的生活质量确实能得到一些改善。</p><p>Hardhat还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 这个项目给人一种很棒的感觉：很干净。它会执行你想要的操作。真的很快。该项目正在不断改进， Hardhat显然致力于使智能合约开发人员的生活更轻松。</p><p>Hardhat概要：</p><p>ETH基金会资助的项目，以前的名字是Builder<br>技术：Javascript，Web3.js和Ethers.js插件，OpenZeppelin可升级合同插件， Etherscan插件，区块链分叉<br>区块链：Hardhat运行时环境/本地、测试网、主网<br>测试支持：Waffle<br>维护：非常活跃<br>支持：活跃<br>开源</p><h2 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h2><p><a href="https://trufflesuite.com/" target="_blank" rel="noopener">https://trufflesuite.com/</a></p><p>几年来Truffle一直是以太坊智能合约的默认开发框架，这是有充分理由的。 Truffle是一个强大的框架，为其他许多人树立了标准。你很容易找到使用此平台的项目， 因此查找示例很容易。Truffle也可以很容易地与它的姊妹工具Drizzle和Ganache集成在一起。 特别是Ganache，它是工程师运行本地区块链的最流行方法之一。对于那些正在寻找更多工具的人， 你可以为升级的Truffle团队帐户付费，并可以访问智能合约的持续集成，可视化部署和监视。 Truffle还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 Truffle的开发团队显然是一群有才华的工程师，他们想要使世界成为一个更好的智能合约场所。</p><p>Truffle测试的运行速度不如hardhat那样快，并且由于用户数量众多，获得支持可能很困难。 我很期待看到被ConsenSys收购后他们将如何改善这个项目。Truffle的文档质量似乎开始下降 并且很难遵循，但是如果你用Google搜索遇到的错误，则很可能会遇到遇到该错误并已解决的人。 我发现改善项目的一些最佳方法是在GitHub上发布问题。无论如何，保持生态系统不断壮大是我们 的开源职责！</p><p>由于几乎每个人都熟悉它，因此获得同行的支持通常很容易。我真的希望看到团队在这个项目 上获得更多支持，因为他们有这么多用户。我希望他们能看到本文并致力于改善其文档，以使 其能够继续作为测试和部署智能合约的首选平台之一。</p><p>Truffle概要：</p><p>使用最广泛的平台；最近被ConsenSys收购（2020年11月）<br>技术：Javascript，Web3.js，OpenZeppelin可升级合同插件，Etherscan插件，区块链分叉<br>区块链：Ganache /本地，测试网，主网<br>有测试<br>维护：非常活跃<br>支持：活跃<br>开源，可以付费升级</p><h2 id="Embark"><a href="#Embark" class="headerlink" title="Embark"></a>Embark</h2><p>Embark是整个DAPP框架。这是一个全栈的区块链平台。在Gitter的 一些帮助下，我能够将Chainlink合约部署到Kovan网络。它带有一个UI，允许你在GUI中与区块链 和合约进行交互。Embark有一段学习曲线，我没有花足够的时间来克服，但它展示了其潜力。这就是 为什么我想将其包括在这里的原因，因为我觉得我没有完全消化很多东西。</p><p>我希望看到人们更多地尝试该框架并看到其功能。由于在项目中花费的时间有限，我觉得我可能 无法在这里做到公正。我确实认为将前端与后端解耦仍然是最佳做法，但是如果你需要启动一个 具有良好前端的项目并且不关心解耦，那么您应该100％尝试这个项目。</p><p>这是一个很酷的项目，如果有人喜欢Hardhat和Truffle，并且又想与全栈解决方案集成，那么我愿意 推荐Embark给他。</p><p>Embark概要：</p><p>具有大量功能的JavaScript框架用于前端开发<br>技术：JavaScript，Web3.js，代理合约支持<br>区块链：Ganache /本地，测试网，主网<br>支持测试<br>维护：轻度活跃<br>支持：活跃<br>开源</p><h1 id="Remix基本使用"><a href="#Remix基本使用" class="headerlink" title="Remix基本使用"></a>Remix基本使用</h1><p>Remix 是以太坊智能合约编程语言Solidity IDE，其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。<br><a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a> <a href="https://remix.ethereum.org/。" target="_blank" rel="noopener">https://remix.ethereum.org/。</a></p><h2 id="Remix基本功能"><a href="#Remix基本功能" class="headerlink" title="Remix基本功能"></a>Remix基本功能</h2><p><img src="/2025/03/11/solidity入门/1.png" alt="image-20221208134636521"></p><h2 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h2><ol><li><p>如上图创建一个空的工作空间</p></li><li><p>在工作空间下创建一个智能合约文件,ex: <code>HelloWord.sol</code></p><ul><li>智能合约文件以<code>.sol</code>结尾，</li><li>文件名采用大驼峰命名法</li><li>文件名和合约名保持一致</li></ul></li><li><p>编写合约代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/2.png" alt="image-20221208140310359"></p></li></ol><h2 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h2><p><img src="/2025/03/11/solidity入门/3.png" alt="image-20221208140810607"></p><p>编译结果：</p><p>目录产生一个<code>artifacts</code> 文件夹</p><p><img src="/2025/03/11/solidity入门/4.png" alt="image-20221208140957454"></p><h2 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h2><ol><li>通过第四个菜单进入部署界面</li><li>选择部署环境</li><li>选择部署合约的账户地址</li><li>设置gas限制</li><li>选择要部署的合约</li><li><p><code>deploy</code>按钮进行部署</p><p><img src="/2025/03/11/solidity入门/5.png" alt="image-20221208141436813"></p></li></ol><p>部署成功效果</p><p><img src="/2025/03/11/solidity入门/6.png" alt="image-20221208141815165"></p><h2 id="合约调试"><a href="#合约调试" class="headerlink" title="合约调试"></a>合约调试</h2><ol><li>通过函数的返回值查看变量</li></ol><p><img src="/2025/03/11/solidity入门/7.png" alt="image-20221208142340517"></p><ol start="2"><li>event Log </li></ol><p>​       solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/8.png" alt="image-20221208145721522"></p><h1 id="本地部署ReMix-IDE"><a href="#本地部署ReMix-IDE" class="headerlink" title="本地部署ReMix IDE"></a>本地部署ReMix IDE</h1><p>在线Remix访问缓慢，如果你有很好的网络环境也可以本地部署一套。<br>在本地部署Remix需要准备两个东西：一个是Remix-project，可以理解为Remix的前端；另一个是Remixd，可以理解为Remix的后端，它们的Github仓库地址分别是：<br><a href="https://github.com/ethereum/remix-project" target="_blank" rel="noopener">https://github.com/ethereum/remix-project</a><br><a href="https://github.com/ethereum/remix-project/tree/master/libs/remixd" target="_blank" rel="noopener">https://github.com/ethereum/remix-project/tree/master/libs/remixd</a></p><h2 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h2><p>如果要运行合并到主分支中的最新更改，请运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:latest</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:latest</span><br></pre></td></tr></table></figure><p>如果你想运行最新的 remix-live 版本运行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:remix_live</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:remix_live</span><br></pre></td></tr></table></figure><h2 id="docker-compose方式安装"><a href="#docker-compose方式安装" class="headerlink" title="docker-compose方式安装"></a>docker-compose方式安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> pull</span><br><span class="line">docker<span class="literal">-compose</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure><h2 id="部署-Remixd"><a href="#部署-Remixd" class="headerlink" title="部署 Remixd"></a>部署 Remixd</h2><p>Remixd 的安装使用步骤如下：</p><p>1.通过 npm 或者 yarn 安装 Remixd（建议用yarn）</p><p>npm 命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> @remix<span class="literal">-project</span>/remixd</span><br><span class="line">yarn add global @remix<span class="literal">-project</span>/remixd</span><br></pre></td></tr></table></figure><p>2.启动 Remix-IDE</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remixd <span class="literal">-s</span> ./shared_project <span class="literal">-u</span> http://localhost:<span class="number">8080</span></span><br></pre></td></tr></table></figure><p>3.在 Remix-IDE 上点两下</p><p>一个点 Solidity，选择相应环境；另一个点 Connect to Localhost，连接本地环境</p><p><img src="/2025/03/11/solidity入门/9.png" alt></p><p><img src="/2025/03/11/solidity入门/10.png" alt></p><h1 id="Solidity基础介绍"><a href="#Solidity基础介绍" class="headerlink" title="Solidity基础介绍"></a>Solidity基础介绍</h1><h2 id="认识一个最简单的存储合约"><a href="#认识一个最简单的存储合约" class="headerlink" title="认识一个最简单的存储合约"></a>认识一个最简单的存储合约</h2><p><img src="/2025/03/11/solidity入门/11.png" alt="image-20221214103704773"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">import &quot;&quot;;</span><br><span class="line">// 导入</span><br><span class="line"></span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    // 状态变量  </span><br><span class="line">    // 函数</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="授权协议"><a href="#授权协议" class="headerlink" title="授权协议"></a>授权协议</h3><ul><li>默认情况下，在发布源代码时加入机器可读许可证说明是很重要的。由于提供源代码总是涉及版权方面的法律问题，Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符,比如：<code>// SPDX-License-Identifier: MIT</code></li></ul><p>至于什么是SPDX 大家可以参考如下资料：</p><p>首先是SPDX，这是个组织名，其网站为：<br><a href="https://spdx.org/licenses/" target="_blank" rel="noopener">SPDX 许可证列表 |软件包数据交换 （SPDX）</a><br>SPDX-License-Identifier 组合起来就是在指SPDX的许可证列表<br>后面的格式为 ：+ SPDX的许可证列表中的某个许可证</p><p>比如上面例子中的MIT 许可：</p><p>MIT 基本信息<br>全名：MIT License <a href="https://spdx.org/licenses/MIT.html" target="_blank" rel="noopener">麻省理工学院许可证</a> 标志符：<a href="https://zh.wikipedia.org/zh-cn/MIT許可證" target="_blank" rel="noopener">MIT</a><br>MIT的具体内容<br>特此免费授予获得（“软件”）副本的任何人不受限制地处理本软件的许可，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或出售本软件副本的权利</p><h3 id="Solidity版本限制"><a href="#Solidity版本限制" class="headerlink" title="Solidity版本限制"></a>Solidity版本限制</h3><ul><li>第二行是告诉编译器源代码所适用的Solidity版本为&gt;=0.7.0 及 &lt;0.9.0 。这样的说明是为了确保合约不会在新的编译器版本中发生异常的行为。关键字 <code>pragma</code> 是告知编译器如何处理源代码的通用指令</li></ul><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>在一个去中心化的世界，我们的程序并不紧紧活一台机器的CPU 上, 在一个去中心化的世界是由很多节点组成的P2P 网络。合约代码会在各节点上[<a href="https://ethereum.org/en/developers/docs/nodes-and-clients/" target="_blank" rel="noopener">Full Node</a>]单独运行，而事实上P2P的各节点相互之间都不信任的，所以每个节点都会存一份自己的状态（Distributed Ledger,分布式账本），在该示例就是name，当调用set()的时候，大家都改变了name，此时需要一种共识机制（PoS），如果PoS认为name合法，此次调用完成。 否则回滚上一个name的值，因此每一次改变状态变量的调用都是以一个事务Transcation来执行。</p><h2 id="Api文档"><a href="#Api文档" class="headerlink" title="Api文档"></a>Api文档</h2><p><a href="https://solidity-by-example.org/" target="_blank" rel="noopener">https://solidity-by-example.org/</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p><strong>局部变量</strong></p></li><li><ul><li>在函数内部声明</li><li>不存储到链上</li></ul></li><li><p><strong>状态变量</strong></p></li><li><ul><li>在函数外部声明</li><li>状态变量是永久地存储在链上的值。</li></ul></li><li><p><strong>全局变量</strong> </p></li><li><ul><li>内置提供有关区块链的信息比如<code>block</code>、<code>msg</code>等</li></ul><p>全局变量 </p></li></ul><p>这些是全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">返回</th></tr></thead><tbody><tr><td style="text-align:left">blockhash(uint blockNumber) returns (bytes32)</td><td style="text-align:left">给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td></tr><tr><td style="text-align:left">block.coinbase (address payable)</td><td style="text-align:left">当前区块矿工的地址</td></tr><tr><td style="text-align:left">block.difficulty (uint)</td><td style="text-align:left">当前区块的难度</td></tr><tr><td style="text-align:left">block.gaslimit (uint)</td><td style="text-align:left">当前区块的gaslimit</td></tr><tr><td style="text-align:left">block.number (uint)</td><td style="text-align:left">当前区块的number</td></tr><tr><td style="text-align:left">block.timestamp (uint)</td><td style="text-align:left">当前区块的时间戳，为unix纪元以来的秒</td></tr><tr><td style="text-align:left">gasleft() returns (uint256)</td><td style="text-align:left">剩余 gas</td></tr><tr><td style="text-align:left">msg.data (bytes calldata)</td><td style="text-align:left">完成 calldata</td></tr><tr><td style="text-align:left">msg.sender (address payable)</td><td style="text-align:left">消息发送者 (当前 caller)</td></tr><tr><td style="text-align:left">msg.sig (bytes4)</td><td style="text-align:left">calldata的前四个字节 (function identifier)</td></tr><tr><td style="text-align:left">msg.value (uint)</td><td style="text-align:left">当前消息的wei值</td></tr><tr><td style="text-align:left">now (uint)</td><td style="text-align:left">当前块的时间戳</td></tr><tr><td style="text-align:left">tx.gasprice (uint)</td><td style="text-align:left">交易的gas价格</td></tr><tr><td style="text-align:left">tx.origin (address payable)</td><td style="text-align:left">交易的发送方</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function doSomething() public view returns(uint, address) &#123;</span><br><span class="line"></span><br><span class="line">        // 内置全局变量</span><br><span class="line">        uint timestamp = block.timestamp; // 获取区块时间戳</span><br><span class="line">        address sender = msg.sender; // 获取区块地址</span><br><span class="line">        return (timestamp,sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/12.png" alt="image-20221208152548299"></p><p>状态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    uint public nun = 123;</span><br><span class="line"></span><br><span class="line">    function doSomething() public&#123;</span><br><span class="line">        nun ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/13.png" alt="image-20221208152817271"></p><p>局部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    function doSomething() public pure  returns(uint)&#123;</span><br><span class="line">        uint num = 123;</span><br><span class="line">        num ++;</span><br><span class="line">        // 局部变量不保存每次使用都重置</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在为变量命名时，请记住以下规则。</p><ul><li>不应使用 Solidity 保留关键字作为变量名。例如，<code>break</code>或<code>boolean</code>变量名无效。</li><li>不应以数字(0-9)开头，必须以字母或下划线开头。例如，<code>123test</code>是一个无效的变量名，但是<code>_123test</code>是一个有效的变量名。</li><li>变量名区分大小写。例如，<code>Name</code>和<code>name</code>是两个不同的变量。</li></ul><h2 id="Solidity-可见性修饰符"><a href="#Solidity-可见性修饰符" class="headerlink" title="Solidity 可见性修饰符"></a><strong>Solidity 可见性修饰符</strong></h2><p>1.public – 所有合约与账号都可以调用<br>2.private -只有在定义该函数的合约可以调用<br>3.internal- 当前合约或者继承该合约的，类似java 里面的protected 关键字。<br>4.external – 只有其他合约或者账号可以调用,定义该函数的合约不能调用,除非使用 this 关键字</p><p><img src="/2025/03/11/solidity入门/14.png" alt="image-20221208153812857"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Storage &#123;</span><br><span class="line">    function set() public &#123; // 定义函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function OutsideFunc(uint x) pure returns (uint) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Solidity有两个关键字与函数输出相关：return和returns，他们的区别在于： </p><blockquote><p> returns加在函数名后面，用于声明返回的变量类型及变量名。</p><p>return用于函数主体中，返回指定的变量。</p></blockquote></li><li><p>view和pure的用法</p><blockquote><p>getter 类型的函数可以被view 或者 pure 修饰。 view 修饰的函数不能改变状态变量。pure 则既不能改变状态变量，也不取读取状态变量。</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ViewPureTest &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">    // 不能改变状态变量.</span><br><span class="line">    function addToX(uint y) public view returns (uint) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //函数中没有任何状态变量出现。</span><br><span class="line">    function add(uint i, uint j) public pure returns (uint) &#123;</span><br><span class="line">        return i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们无法确定该用view还是pure时，remix会给我们完善的提示信息</p><h2 id="错误Errors"><a href="#错误Errors" class="headerlink" title="错误Errors"></a>错误Errors</h2><blockquote><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   assert(bool condition)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  − 如果不满足条件，此方法调用将导致一个无效的操作码，对状态所做的任何更改将被还原。这个方法是用来处理内部错误的。</p><ul><li><p><code>require(bool condition)</code> − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。</p></li><li><p><code>require(bool condition, string memory message)</code> − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。它提供了一个提供自定义消息的选项。</p></li><li><p><code>revert()</code> − 此方法将中止执行并将所做的更改还原为执行前状态。</p></li><li><p><code>revert(string memory reason)</code> − 此方法将中止执行并将所做的更改还原为执行前状态。它提供了一个提供自定义消息的选项。</p></li></ul></blockquote><p>回退状态：但是gas费用是需要消耗</p><p>assert 合约内部错误</p><p>require 外部参数错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数被2整除</span><br></pre></td></tr></table></figure><p>assert 内部错误</p><p>Solidity 为应对失败，允许用户定义 <code>error</code> 来描述错误的名称和数据。 跟用错误字符串相比， <code>error</code> 更便宜并且允许你编码额外的数据，还可以用 NatSpec 为用户去描述错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">error NotFoundUser(address account, uint256 uid);</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">    mapping(address =&gt; uint256) users;</span><br><span class="line"></span><br><span class="line">    function getUser(address _account, uint256 _uid) public view &#123;</span><br><span class="line">        uint256 uid = users[msg.sender];</span><br><span class="line">        if (uid &lt; _uid) &#123;</span><br><span class="line">            revert NotFoundUser(_account, _uid);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br></pre></td></tr></table></figure><h2 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h2><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><p>  solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/15.png" alt="image-20221208145721522"></p><h1 id="变量的数据位置"><a href="#变量的数据位置" class="headerlink" title="变量的数据位置"></a>变量的数据位置</h1><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>在合约中声明和使用的变量都有一个数据位置，指明变量值应该存储在哪里。合约变量的数据位置将会影响Gas消耗量。</p><p>Solidity 提供4种类型的数据位置。</p><ul><li>Storage</li><li>Memory</li><li>Calldata</li><li>Stack</li></ul><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。</p><p>保存在存储区(Storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p><ul><li>存储中的数据是永久存在的。存储是一个key/value库</li><li>存储中的数据写入区块链，因此会修改状态，这也是存储使用成本高的原因。</li><li>占用一个256位的槽需要消耗20000 gas</li><li>修改一个已经使用的存储槽的值，需要消耗5000 gas</li><li>当清零一个存储槽时，会返还一定数量的gas</li><li>存储按256位的槽位分配，即使没有完全使用一个槽位，也需要支付其开销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct storage myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。</p><p>通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p><ul><li>内存是一个字节数组，槽大小位256位（32字节）</li><li>数据仅在函数执行期间存在，执行完毕后就被销毁</li><li>读或写一个内存槽都会消耗3gas</li><li>为了避免矿工的工作量过大，22个操作之后的单操作成本会上涨</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public view returns (MyStruct memory) &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct memory myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">        return myStruct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Calldata"><a href="#Calldata" class="headerlink" title="Calldata"></a>Calldata</h3><p>Calldata是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，Calldata是外部函数的参数(而不是返回参数)的默认位置。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>堆栈是由EVM (Ethereum虚拟机)维护的非持久性数据。EVM使用堆栈数据位置在执行期间加载变量。堆栈位置最多有1024个级别的限制。</p><p>可以看到，要永久性存储，可以保存在存储区(Storage)。</p><h2 id="数据位置规则"><a href="#数据位置规则" class="headerlink" title="数据位置规则"></a>数据位置规则</h2><h3 id="规则1-–-状态变量"><a href="#规则1-–-状态变量" class="headerlink" title="规则1 – 状态变量"></a>规则1 – 状态变量</h3><p>状态变量总是存储在存储区中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，不能显式地标记状态变量的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   uint storage stateVariable; // 错误  </span><br><span class="line">   uint[] memory stateArray; // 错误  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则2-–-函数参数与返回值"><a href="#规则2-–-函数参数与返回值" class="headerlink" title="规则2 – 函数参数与返回值"></a>规则2 – 函数参数与返回值</h3><p>函数参数包括返回参数都存储在内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line"></span><br><span class="line">   function calculate(uint num1, uint num2) public pure returns (uint result) &#123;</span><br><span class="line">       return num1 + num2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p><h3 id="规则3-–-局部变量"><a href="#规则3-–-局部变量" class="headerlink" title="规则3 – 局部变量"></a>规则3 – 局部变量</h3><p>值类型的局部变量存储在内存中。但是，对于引用类型，需要显式地指定数据位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract Locations &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是状态变量 */  </span><br><span class="line"></span><br><span class="line">  // 存储在storage中  </span><br><span class="line">  bool flag;  </span><br><span class="line">  uint number;  </span><br><span class="line">  address account;  </span><br><span class="line"></span><br><span class="line">  function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">    /* 此处都是局部变量  */  </span><br><span class="line"></span><br><span class="line">    // 值类型</span><br><span class="line">    // 所以它们被存储在内存中</span><br><span class="line">    bool flag2;  </span><br><span class="line">    uint number2;  </span><br><span class="line">    address account2;  </span><br><span class="line"></span><br><span class="line">    // 引用类型，需要显示指定数据位置，此处指定为内存</span><br><span class="line">    uint[] memory localArray;        </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能显式覆盖具有值类型的局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是局部变量  */  </span><br><span class="line">  // 值类型</span><br><span class="line">  bool memory flag2;  // 错误</span><br><span class="line">  uint Storage number2;  // 错误 </span><br><span class="line">  address account2;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则4-–-外部函数的参数"><a href="#规则4-–-外部函数的参数" class="headerlink" title="规则4 – 外部函数的参数"></a>规则4 – 外部函数的参数</h3><p>外部函数的参数(不包括返回参数)存储在Calldata中。</p><h2 id="赋值的数据位置规则"><a href="#赋值的数据位置规则" class="headerlink" title="赋值的数据位置规则"></a>赋值的数据位置规则</h2><h1 id="Solidity数据类型"><a href="#Solidity数据类型" class="headerlink" title="Solidity数据类型"></a>Solidity数据类型</h1><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。</p><p>Solidity中，变量类型有以下几大类：</p><ul><li>值类型</li><li>地址类型</li><li>引用类型</li></ul><p><img src="/2025/03/11/solidity入门/16.png" alt></p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">保留字</th><th style="text-align:left">取值</th></tr></thead><tbody><tr><td style="text-align:left">布尔型</td><td style="text-align:left">bool</td><td style="text-align:left">true/false</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int/uint</td><td style="text-align:left">有符号整数/无符号整数。</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int8 to int256</td><td style="text-align:left">8位到256位的带符号整型数。int256与int相同。</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">uint8 to uint256</td><td style="text-align:left">8位到256位的无符号整型。uint256和uint是一样的。</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">fixed/unfixed</td><td style="text-align:left">有符号和无符号的定长浮点型</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">fixedMxN</td><td style="text-align:left">带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">ufixedMxN</td><td style="text-align:left">无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr></tbody></table><h2 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h2><p>地址类型表示以太坊地址，长度为20字节。地址可以使用<code>.balance</code>方法获得余额，也可以使用<code>.transfer</code>方法将余额转到另一个地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address x = <span class="number">0x212</span>;</span><br><span class="line">address myAddress = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>) </span><br><span class="line">    x.transfer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="引用类型-复合数据类型"><a href="#引用类型-复合数据类型" class="headerlink" title="引用类型/复合数据类型"></a>引用类型/复合数据类型</h2><p>Solidity中，有一些数据类型由值类型组合而成，相比于简单的值类型，这些类型通常通过名称引用，被称为引用类型。</p><p>引用类型包括：</p><ul><li>数组 (字符串与bytes是特殊的数组，所以也是引用类型)</li><li>struct (结构体)</li><li>map (映射)</li></ul><p>“<code>undefined</code>”或“<code>null</code>”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。 要处理任何意外的值，应该使用错误处理来恢复整个交易，或者返回一个带有第二个<code>bool</code> 值的元组表示成功。</p><h2 id="bool-布尔类型"><a href="#bool-布尔类型" class="headerlink" title="bool/布尔类型"></a><strong>bool/布尔类型</strong></h2><p>布尔值的取值范围为 true 和 false 。</p><p>默认值：<code>false</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">  error NotEqual(bool A,bool B);</span><br><span class="line">bool public A; // false</span><br><span class="line">bool public B = true;//true</span><br><span class="line">  // require(A==B,&quot;A not equal B&quot;);</span><br><span class="line"></span><br><span class="line">  if (A != B) &#123;</span><br><span class="line">    error NotEqual(A,B);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符：<br>●!（逻辑非）<br>●&amp;&amp; （逻辑与， “and” ）<br>●|| （逻辑或， “or” ）<br>●== （等于）<br>●!= （不等于）</p><h2 id="int、uint-整数类型"><a href="#int、uint-整数类型" class="headerlink" title="int、uint/整数类型"></a><strong>int、uint/整数类型</strong></h2><blockquote><p><code>int/uint：</code>变长的<strong>有符号</strong>或<strong>无符号</strong>整型。变量支持的步长以<code>8</code>递增，支持从<code>uint8</code>到<code>uint256</code>，以及<code>int8</code>到<code>int256</code>。需要注意的是，<code>uint</code>和<code>int</code>默认代表的是<code>uint256</code>和<code>int256</code>。</p></blockquote><p><code>int</code> 有符号整型(包含负数)</p><p>默认为<code>int256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>int8</code> 取值范围：-(2 <strong> 7)到 2 </strong> 7 -1</li><li><code>int16</code>取值范围：-(2 <strong> 15)到 2 </strong> 15 -1</li><li>…</li><li><code>intX</code>取值范围：-(2<strong><code>X</code>-1)到 2</strong>(<code>X</code>-1) -1</li><li><code>int256</code>取值范围：-(2 <strong> 255)到 2 </strong> 255 -1</li></ul><p><code>uint</code> 无符号整型</p><p>默认为<code>uint256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>uint8</code>取值范围：0 到 2 ** 8 - 1</li><li><code>uint16</code>取值范围：0 到 2 ** 16 - 1</li><li>…</li><li><code>uintX</code>取值范围：0 到 2 ** <code>X</code> - 1</li><li><code>uint256</code>取值范围：0 到 2 ** 256 - 1</li></ul><p>对于整形 X，可以使用 type(X).min 和 type(X).max 去获取这个类型的最小值与最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestIntval &#123;</span><br><span class="line">  int8 public i8 = -1;</span><br><span class="line">    int public i256 = 456;</span><br><span class="line">    int public i = -123; // int 等同于 int256</span><br><span class="line">    // int 的最大最小值</span><br><span class="line">    int public minInt = type(int).min;</span><br><span class="line">    int public maxInt = type(int).max;</span><br><span class="line"></span><br><span class="line">    uint8 public u8 = 1;</span><br><span class="line">    uint256 public u256 = 456;</span><br><span class="line">    uint public u = 123; // uint  等同于 uint256 </span><br><span class="line">// uint 的最大最小值</span><br><span class="line">    uint public minUInt = type(uint).min;</span><br><span class="line">    uint public maxUInt = type(uint).max;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function mini() public pure returns(uint8)&#123;</span><br><span class="line">        return type(uint8).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="address-地址"><a href="#address-地址" class="headerlink" title="address/地址"></a><strong>address/地址</strong></h2><p>默认值: 0x0000000000000000000000000000000000000000</p><p>20字节的16进制地址用来表示一个账户 或者合约地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    //与其他机器语言相区别的类型就是这个address 类型，160-bit/20byte</span><br><span class="line">    address public myAddr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;</span><br><span class="line">    //合约自己的地址</span><br><span class="line">    address contractAddress = address(this);</span><br><span class="line">    //跟普通的地址类型一样，但多了两个方法 transfer/send 这两个方法后面章节会讲到</span><br><span class="line">    // address sender = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line">  //可以使用 balance 属性来查询一个地址的余额</span><br><span class="line">    function getBalance()</span><br><span class="line">        public view</span><br><span class="line">        returns (uint256, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        require(myAddr.balance &lt; contractAddress.balance, &quot;1 must lg 2&quot;);</span><br><span class="line">        return (myAddr.balance, contractAddress.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bytes-字节数组"><a href="#bytes-字节数组" class="headerlink" title="bytes/字节数组"></a><strong>bytes/字节数组</strong></h2><p>在计算机中的最小存储单位是 bit(位)</p><ul><li>1byte等于8位</li><li><p>Solidity中，byte可以赋值为</p></li><li><ul><li>16进制数字</li><li>单引号的单个或多个字符</li></ul></li></ul><p>定长字节数组</p><p>bytes1 后面数字1是表示1字节 bytes默认等于bytes1<br>Bytes2 后面数字2是表示2字节<br>Bytes3 后面数字3是表示3字节<br>bytes4 后面数字4是表示4字节</p><p>…</p><p>bytes32 后面数字32是表示32字节</p><p>bytes32 等价于 int256或uint256 的位数</p><p>成员变量</p><p><code>.length</code> 表示这个字节数组的长度（只读）</p><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string/字符串"></a><strong>string/字符串</strong></h2><ol><li>中文特殊字符需要用<code>unicode</code>编码</li><li>通过concat 方法进行拼接</li><li>bytes 和 string之间转化</li><li><code>string</code>字符串不能通过<code>length</code>方法获取其长度。</li><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code>可以通过这个方法比较两个字符串是否相等。</li><li><code>abi.encodePacked(s1, s2)</code>:通过这个方法进行字符串合并拼接。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    string public str1 = &quot;123&quot;;</span><br><span class="line">    // 中文不适用unicode编码报错</span><br><span class="line">    // string public str2 = =&quot;你好&quot;;</span><br><span class="line">    string public str2 = unicode&quot;abc&quot;;</span><br><span class="line">    function concat() public view returns(string memory) &#123;</span><br><span class="line">        string memory result = string.concat(str1,str2);</span><br><span class="line">        return  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function caoncat2(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        return string.concat(_a,_b);</span><br><span class="line">    &#125;</span><br><span class="line">     function caoncat3(string memory _a, string memory _b) public pure returns(bytes memory) &#123;</span><br><span class="line">          bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return bytes.concat(_ba,_bb);</span><br><span class="line">    &#125;</span><br><span class="line">      function caoncat4(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return string(bytes.concat(_ba,_bb));</span><br><span class="line">    &#125;</span><br><span class="line">     // 比较s1和s2是否相等，相等返回true，不相等返回false</span><br><span class="line">    function compareEqual(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;   </span><br><span class="line">        // 不支持字符直接比较</span><br><span class="line">        return s1 == s2;</span><br><span class="line">        // return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组</span><br><span class="line">    function mergeS1AndS2ReturnBytes(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encodePacked(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组转换为string</span><br><span class="line">    function mergeS1AndS2ReturnString(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return string(abi.encodePacked(s1, s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum(枚举)"></a>Enum(枚举)</h2><p>枚举将一个变量的取值限制为几个预定义值中的一个。精确使用枚举类型有助于减少代码中的bug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ontract UserState &#123;</span><br><span class="line">  // 枚举</span><br><span class="line">  //默认值是列表中的第一个元素</span><br><span class="line">  enum State &#123; </span><br><span class="line">    Online,  // 0</span><br><span class="line">    Offline,// 1</span><br><span class="line">    Unknown// 2</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  State public status;</span><br><span class="line">  function get() public view returns (State) &#123;</span><br><span class="line">      return status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过将uint传递到输入来更新状态</span><br><span class="line">  function set(State _status) public &#123;</span><br><span class="line">      status = _status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 也可以是这样确定属性的更新</span><br><span class="line">  function off() public &#123;</span><br><span class="line">      status = State.Offline;</span><br><span class="line">  &#125;</span><br><span class="line">  // delete 将枚举重置为其第一个值 0</span><br><span class="line">  function reset() public &#123;</span><br><span class="line">      delete status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array-数组"><a href="#array-数组" class="headerlink" title="array/数组"></a><strong>array/数组</strong></h2><blockquote><p>T[k]: 元素类型为T，固定长度为K的数组  uint[5] </p><p>T[]: 元素类型为T, 长度可以动态调整</p></blockquote><h3 id="一、固定长度的数组（Arrays）"><a href="#一、固定长度的数组（Arrays）" class="headerlink" title="一、固定长度的数组（Arrays）"></a>一、固定长度的数组（Arrays）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    // 创建定长数组</span><br><span class="line">    uint256[5] public arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    // 定长数组求和</span><br><span class="line">    function getAll() public view returns (uint256) &#123;</span><br><span class="line">        uint256 num = 0;</span><br><span class="line">        for (uint256 i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            num += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint256[5] memory) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取定长数组长度</span><br><span class="line">    function getLenth() public view returns (uint256) &#123;</span><br><span class="line">        return arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改长度失败</span><br><span class="line">    function changeLenth() public &#123;</span><br><span class="line">        // arr.length = 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改内部数据</span><br><span class="line">    function change(uint256 _idx, uint256 _val) public &#123;</span><br><span class="line">        arr[_idx] = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // push 修改</span><br><span class="line">    // function change(uint256 _val) public &#123;</span><br><span class="line">    //     arr.push(_val);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、可变长度的Arrays"><a href="#二、可变长度的Arrays" class="headerlink" title="二、可变长度的Arrays"></a>二、可变长度的Arrays</h3><p><code>uint [] T = [1,2,3,4,5]</code>，这句代码表示声明了一个可变长度的<code>T</code>数组，因为我们给它初始化了<code>5</code>个无符号整数，所以它的长度默认为<code>5</code>。</p><p><code>&gt;=0.5.0</code>的版本中<code>length</code>方法只读，不可修改。 5版本之前支持length属性修改，缺失的以0补位</p><p><img src="/2025/03/11/solidity入门/17.png" alt="image-20221214150932547"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint [] T = [1,2,3,4,5];</span><br></pre></td></tr></table></figure><h3 id="三、二维数组-数组里面放数组"><a href="#三、二维数组-数组里面放数组" class="headerlink" title="三、二维数组 - 数组里面放数组"></a>三、二维数组 - 数组里面放数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[2][3] T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line"></span><br><span class="line">    function T_len() public view returns (uint256) &#123;</span><br><span class="line">        return T.length; // uint256: 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function getT() public view returns (uint256[2][3] memory) &#123;</span><br><span class="line">        return T;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    function change() public &#123;</span><br><span class="line">        T[1][0] = 55;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uint [2][3] T = [[1,2],[3,4],[5,6]]</code>这是一个三行两列的数组，你会发现和Java、C语言等的其它语言中二位数组里面的列和行之间的顺序刚好相反。在其它语言中，上面的内容应该是这么存储<code>uint [2][3] T = [[1,2,3],[4,5,6]]</code>。</p><p>上面的<code>数组T</code>是<code>storage</code>类型的数组，对于<code>storage</code>类型的数组，数组里面可以存放任意类型的值（比如：其它数组，结构体，字典／映射等等）。对于<code>memory</code>类型的数组，如果它是一个<code>public</code>类型的函数的参数，那么它里面的内容不能是一个<code>mapping(映射／字典)</code>，并且它必须是一个<code>ABI</code>类型。</p><h3 id="四、数组字面量-Array-Literals-内联数组-Inline-Arrays"><a href="#四、数组字面量-Array-Literals-内联数组-Inline-Arrays" class="headerlink" title="四、数组字面量 Array Literals / 内联数组 Inline Arrays"></a>四、数组字面量 Array Literals / 内联数组 Inline Arrays</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    function f() pure public &#123;</span><br><span class="line">        g([1, 2, 3]); </span><br><span class="line">        g([uint(1),2,3])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function g(uint[3] memory _data) pure public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><blockquote><p>通过基本数据类型来组合成自定义复杂的数据类型</p></blockquote><p>语法结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 关键字  结构体名称 &#123;</span><br><span class="line">类型1  属性名1;</span><br><span class="line">类型2  属性名2；</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">uint8 age;</span><br><span class="line">string id;</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建结构变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构体 变量名 = 结构体(属性1，属性2，...)</span><br><span class="line">结构体 变量名 = 结构体(&#123;属性1：value1，属性2：value2Ï&#125;)</span><br><span class="line"></span><br><span class="line">Person student1 = Person(18,1,&quot;柯南&quot;)；</span><br><span class="line">Person student2 = Person(&#123;age:17, id: 2, name: &quot;迪迦Ï&quot;&#125;)</span><br></pre></td></tr></table></figure><p>修改结构体变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setStudent(uint _age, string _name) public &#123;</span><br><span class="line">student1.age = _age</span><br><span class="line">student1.name = _name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中返回结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getStudent() public view returns(Person) &#123;</span><br><span class="line">return student1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract Structs &#123;</span><br><span class="line">    struct Todo &#123;</span><br><span class="line">        string text;</span><br><span class="line">        bool completed;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构体数组</span><br><span class="line">  </span><br><span class="line">    Todo[] public todos;</span><br><span class="line"></span><br><span class="line">    // 初始化结构的3种方法</span><br><span class="line">    function create(string calldata _text) public &#123;</span><br><span class="line">        // 1.像函数一样调用它</span><br><span class="line">        todos.push(Todo(_text, false));</span><br><span class="line">        // 2. 键值对</span><br><span class="line">        todos.push(Todo(&#123;text: _text, completed: false&#125;));</span><br><span class="line">        // 3.初始化一个空结构，然后更新它</span><br><span class="line">        Todo memory todo;</span><br><span class="line">        todo.text = _text;</span><br><span class="line">        todos.push(todo);// completed 没有定义,默认为 false</span><br><span class="line">    &#125;</span><br><span class="line">    //通过索引获取结构体数组中一个元素,并更新内部的属性</span><br><span class="line">    function update(uint _index) public &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        todo.completed = !todo.completed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典／映射（Mappings"><a href="#字典／映射（Mappings" class="headerlink" title="字典／映射（Mappings)"></a>字典／映射（Mappings)</h2><blockquote><p>与数组和结构体一样，映射也是引用类型。</p><p>是一个一对一键值存储关系。</p><p>可以理解成js中的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(<span class="function"><span class="params">_KeyType</span> =&gt;</span> _ValueType)</span><br></pre></td></tr></table></figure><ul><li><code>_KeyType</code> – 可以是任何内置类型，或者bytes和字符串。不允许使用引用类型或复杂对象。</li><li><code>_ValueType</code> – 可以是任何类型。</li></ul><p><strong>注意</strong></p><ul><li>映射的数据位置(data location)只能是storage，通常用于状态变量。</li><li>映射可以标记为public，Solidity 自动为它创建getter。</li><li>mapping 不能直接在函数返回</li></ul><p>创建mapping </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint256 _amount) public &#123;</span><br><span class="line">        balances[msg.sender] = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAmount() public view  returns(uint)&#123;</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract LedgerBalance &#123;</span><br><span class="line">   mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">   function updateBalance(uint newBalance) public &#123;</span><br><span class="line">      balances[msg.sender] = newBalance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Updater &#123;</span><br><span class="line">   function updateBalance() public returns (uint) &#123;</span><br><span class="line">      LedgerBalance ledgerBalance = new LedgerBalance();</span><br><span class="line">      ledgerBalance.updateBalance(10);</span><br><span class="line">      return ledgerBalance.balances(address(this));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    //从地址到uint的映射</span><br><span class="line">    mapping(address =&gt; uint) public myMap;</span><br><span class="line"></span><br><span class="line">    function get(address _addr) public view returns (uint) &#123;</span><br><span class="line">        //映射始终返回一个值。</span><br><span class="line">//如果从未设置该值，它将返回默认值。</span><br><span class="line">        return myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新此地址的值 </span><br><span class="line">    function set(address _addr, uint _i) public &#123;</span><br><span class="line">        myMap[_addr] = _i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove(address _addr) public &#123;</span><br><span class="line">//将值重置为默认值</span><br><span class="line">        delete myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//嵌套 mapping</span><br><span class="line">contract NestedMapping &#123;</span><br><span class="line">    //嵌套映射（从地址映射到另一个映射）</span><br><span class="line">    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;</span><br><span class="line"></span><br><span class="line">    function get(address _addr1, uint _i) public view returns (bool) &#123;</span><br><span class="line">        // 可以从嵌套映射中获取值</span><br><span class="line">        return nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(</span><br><span class="line">        address _addr1,</span><br><span class="line">        uint _i,</span><br><span class="line">        bool _boo</span><br><span class="line">    ) public &#123;</span><br><span class="line">        nested[_addr1][_i] = _boo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除 mapping 的一个元素</span><br><span class="line">    function remove(address _addr1, uint _i) public &#123;</span><br><span class="line">        delete nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solidity运算符"><a href="#Solidity运算符" class="headerlink" title="Solidity运算符"></a>Solidity运算符</h1><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>+ (加)</strong> 求和 <strong>例:</strong> A + B = 30</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>– (减)</strong> 相减 <strong>例:</strong> A – B = -10</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>* (乘)</strong> 相乘 <strong>例:</strong> A * B = 200</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>/ (除)</strong> 相除 <strong>例:</strong> B / A = 2</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>% (取模)</strong> 取模运算 <strong>例:</strong> B % A = 0</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>++ (递增)</strong> 递增 <strong>例:</strong> A++ = 11</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>— (递减)</strong> 递减 <strong>例:</strong> A– = 9</td></tr></tbody></table><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>== (等于)</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>!= (不等于)</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>&gt; (大于)</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>&lt; (小于)</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>&gt;= (大于等于)</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>&lt;= (小于等于)</strong></td></tr></tbody></table><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>&amp;&amp; (逻辑与)</strong> 如果两个操作数都非零，则条件为真。 <strong>例:</strong> (A &amp;&amp; B) 为真</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">**\</td><td>\</td><td>(逻辑或)<strong> 如果这两个操作数中有一个非零，则条件为真。 </strong>例:** (A \</td><td>\</td><td>B) 为真</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>! (逻辑非)</strong> 反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。 <strong>例:</strong> ! (A &amp;&amp; B) 为假</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>&amp; (位与)</strong> 对其整数参数的每个位执行位与操作。 <strong>例:</strong> (A &amp; B) 为 2.</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">**\</td><td>(位或)<strong> 对其整数参数的每个位执行位或操作。 </strong>例:** (A \</td><td>B) 为 3.</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>^ (位异或)</strong> 对其整数参数的每个位执行位异或操作。 <strong>例:</strong> (A ^ B) 为 1.</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>~ (位非)</strong> 一元操作符，反转操作数中的所有位。 <strong>例:</strong> (~B) 为 -4.</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>&lt;&lt; (左移位))</strong> 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由0填充。将一个值向左移动一个位置相当于乘以2，移动两个位置相当于乘以4，以此类推。 <strong>例:</strong> (A &lt;&lt; 1) 为 4.</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>&gt;&gt; (右移位)</strong> 左操作数的值向右移动，移动位置数量由右操作数指定 <strong>例:</strong> (A &gt;&gt; 1) 为 1.</td></tr></tbody></table><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>solidity 支持的赋值运算符，如下表所示：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>= (简单赋值)</strong> 将右侧操作数的值赋给左侧操作数 <strong>例:</strong> C = A + B 表示 A + B 赋给 C</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>+= (相加赋值)</strong> 将右操作数添加到左操作数并将结果赋给左操作数。 <strong>例:</strong> C += A 等价于 C = C + A</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>−= (相减赋值)</strong> 从左操作数减去右操作数并将结果赋给左操作数。 <strong>例:</strong> C -= A 等价于 C = C – A</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>*= (相乘赋值)</strong> 将右操作数与左操作数相乘，并将结果赋给左操作数。 <strong>例:</strong> C <em>= A 等价于 C = C </em> A</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>/= (相除赋值)</strong> 将左操作数与右操作数分开，并将结果分配给左操作数。 <strong>例:</strong> C /= A 等价于 C = C / A</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>%= (取模赋值)</strong> 使用两个操作数取模，并将结果赋给左边的操作数。 <strong>例:</strong> C %= A 等价于 C = C % A</td></tr></tbody></table><blockquote><p><strong>注意</strong> – 同样的逻辑也适用于位运算符，因此它们将变成<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p></blockquote><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>? : (条件运算符 )</strong> 如果条件为真 ? 则取值X : 否则值Y</td></tr></tbody></table><h1 id="Solidity循环语句"><a href="#Solidity循环语句" class="headerlink" title="Solidity循环语句"></a>Solidity循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (表达式) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">        int256 start = 1;</span><br><span class="line">        while (start &lt;= max) &#123;</span><br><span class="line">            start++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>Solidity 中， do…while循环的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125; while (表达式);</span><br><span class="line">注意: 不要漏掉do后面的分号。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract TestBool &#123;</span><br><span class="line">   uint public num  = 10;</span><br><span class="line">   function test () public returns(uint) &#123;</span><br><span class="line">       int  start = 1;</span><br><span class="line">       int  max = 10;</span><br><span class="line">       do&#123;</span><br><span class="line">         start ++;</span><br><span class="line">         num ++;</span><br><span class="line">       &#125;while(start &lt;=max);</span><br><span class="line">       return num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 测试条件; 迭代语句) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         if(start == 1) &#123;</span><br><span class="line">            //  break;  // 跳出循环 num 10</span><br><span class="line">            continue; // 跳出本次循环</span><br><span class="line">        &#125;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solidity条件语句"><a href="#Solidity条件语句" class="headerlink" title="Solidity条件语句"></a>Solidity条件语句</h1><p>Solidity支持条件语句，让程序可以根据条件执行不同的操作。条件语句包括：</p><ul><li><code>if</code></li><li><code>if...else</code></li><li><code>if...else if</code></li></ul><p><img src="/2025/03/11/solidity入门/18.png" alt="image-20221208161811890"></p><h1 id="Solidity中的函数"><a href="#Solidity中的函数" class="headerlink" title="Solidity中的函数"></a>Solidity中的函数</h1><h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><blockquote><p>函数修饰符用于修改函数的行为。例如，向函数添加条件限制。</p><p>修饰符定义中出现特殊符号<code>_</code>的地方，用于插入函数体。如果在调用此函数时，满足了修饰符的条件，则执行该函数，否则将抛出异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    uint256 price = 10;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义修饰符 onlyOwner 不带参数</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用修饰符 onlyOwner 限制只有发布者才能调用</span><br><span class="line">    function changePrice(uint256 _price)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        onlyOwner</span><br><span class="line">        returns (address, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return (owner, _price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图函数（view）"><a href="#视图函数（view）" class="headerlink" title="视图函数（view）"></a>视图函数（view）</h2><blockquote><p>View(视图)函数 使用状态变量，但是不修改状态</p></blockquote><p>如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p><ul><li>修改状态变量。</li><li>触发事件。</li><li>创建合约。</li><li>使用<code>selfdestruct</code>。</li><li>发送以太。</li><li>调用任何不是视图函数或纯函数的函数</li><li>使用底层调用</li><li>使用包含某些操作码的内联程序集。</li></ul><p>Getter方法是默认的视图函数。声明视图函数，可以在函数声明里，添加<code>view</code>关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getResult() public view returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1; // 局部变量</span><br><span class="line">        uint256 b = 2;</span><br><span class="line">        uint256 product = a * b;</span><br><span class="line">        uint256 sum = a + b;</span><br><span class="line">        return (product, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯函数（Pure）"><a href="#纯函数（Pure）" class="headerlink" title="纯函数（Pure）"></a>纯函数（Pure）</h2><blockquote><p>Pure(纯)函数<strong>不读取</strong>或修改状态。</p><p>声明纯函数，可以在函数声明里，添加<code>pure</code>关键字。</p></blockquote><p>如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告</p><ul><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li><li>访问任何区块、交易、msg等特殊变量(msg.sig 与 msg.data 允许读取)。</li><li>调用任何不是纯函数的函数。</li><li>使用包含特定操作码的内联程序集。</li></ul><p>如果发生错误，纯函数可以使用<code>revert()</code>和<code>require()</code>函数来还原潜在的状态更改。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote><p>同一个作用域内，相同函数名可以定义多个函数。这些函数的参数(参数类型或参数数量)必须不一样。仅仅是返回值不一样不被允许。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getSum(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSum(</span><br><span class="line">        uint256 a,</span><br><span class="line">        uint256 b,</span><br><span class="line">        uint256 c</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><blockquote><p>Solidity 提供了常用的加密函数。以下是一些重要函数：</p><ul><li><code>keccak256(bytes memory) returns (bytes32)</code> 计算输入的Keccak-256散列。</li><li><code>sha256(bytes memory) returns (bytes32)</code> 计算输入的SHA-256散列。</li><li><code>ripemd160(bytes memory) returns (bytes20)</code> 计算输入的RIPEMD-160散列。</li><li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>从椭圆曲线签名中恢复与公钥相关的地址，或在出错时返回零。函数参数对应于签名的ECDSA值: r – 签名的前32字节; s: 签名的第二个32字节; v: 签名的最后一个字节。这个方法返回一个地址。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Test &#123;   </span><br><span class="line">   function callKeccak256() public pure returns(bytes32 result)&#123;</span><br><span class="line">      return keccak256(&quot;ABC&quot;);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><h2 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h2><blockquote><p>就像Java、C++中，类的继承一样，Solidity中，合约继承是扩展合约功能的一种方式。Solidity支持单继承和多继承。</p></blockquote><p>Solidity中，合约继承的重要特点：</p><ul><li>派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用<code>this</code>。</li><li>如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。</li><li>可以使用<code>super</code>关键字或父合同名称调用父合同的函数。</li><li>在多重继承的情况下，使用<code>super</code>的父合约函数调用，优先选择被最多继承的合约。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint256 private data;</span><br><span class="line">    uint256 public info;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        info = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increment(uint256 a) private pure returns (uint256) &#123;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateData(uint256 a) public &#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData() public view returns (uint256) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function compute(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is Base &#123;</span><br><span class="line">    uint256 private result;</span><br><span class="line">    Base private base;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        base = new Base();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getComputedResult() public &#123;</span><br><span class="line">        result = compute(3, 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getResult() public view returns (uint256) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>构造函数是使用<code>construct</code>关键字声明的特殊函数，用于初始化合约的状态变量。合约中构造函数是可选的，可以省略。</p></blockquote><p>构造函数有以下重要特性：</p><ul><li>一个合约只能有一个构造函数。</li><li>构造函数在创建合约时执行一次，用于初始化合约状态。</li><li>在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。</li><li>构造函数可以是公共的，也可以是内部的。</li><li>内部构造函数将合约标记为抽象合约。</li><li>如果没有定义构造函数，则使用默认构造函数。</li></ul><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solidity语法基础入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发</title>
    <link href="/2025/03/10/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91/"/>
    <id>/2025/03/10/以太坊钱包开发/</id>
    <published>2025-03-10T08:48:28.000Z</published>
    <updated>2025-03-11T04:12:09.781Z</updated>
    
    <content type="html"><![CDATA[<p>使用vue开发以太坊钱包<br><a id="more"></a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>版本信息:</p><p>Node  16.14</p><p>安装vue-cli </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>验证vue-cli 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vue -V</span><br><span class="line">// 结果 出现vue版本号 安装成功</span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure><p>通过vue-cli创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vue create &lt;项目名称&gt;</span><br><span class="line">// 选择配置</span><br><span class="line">Vue CLI v5.0.8</span><br><span class="line">? Please pick a preset: </span><br><span class="line">  Default ([Vue 3] babel, eslint) </span><br><span class="line">  Default ([Vue 2] babel, eslint) </span><br><span class="line">❯ Manually select features  `选择该项`</span><br></pre></td></tr></table></figure><p>选择自定义配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to </span><br><span class="line">toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line"> ◉ Babel `选择该项`</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◉ Router `选择该项`</span><br><span class="line"> ◯ Vuex</span><br><span class="line">❯◉ CSS Pre-processors `选择该项`</span><br><span class="line"> ◯ Linter / Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure><p>选择vue版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Choose a version of Vue.js that you want to start the project with (Use arrow </span><br><span class="line">keys)</span><br><span class="line">❯ 3.x </span><br><span class="line">  2.x</span><br></pre></td></tr></table></figure><p>选择路由设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router? (Requires proper server setup <span class="keyword">for</span> index fallback </span><br><span class="line"><span class="keyword">in</span> production) (Y/n) y  `输入y或者n`</span><br></pre></td></tr></table></figure><p>选择预处理语言</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported </span><br><span class="line">by default): </span><br><span class="line">  Sass/SCSS (with dart-sass) </span><br><span class="line">❯ Less </span><br><span class="line">  Stylus</span><br></pre></td></tr></table></figure><p>选择配置文件存放目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.? </span><br><span class="line">❯ In dedicated config files </span><br><span class="line">  In package.json</span><br></pre></td></tr></table></figure><p>安装成功后 运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 项目名称</span><br><span class="line">$ npm run serve</span><br></pre></td></tr></table></figure><p>成功界面 </p><p><img src="/2025/03/10/以太坊钱包开发/1.png" alt="image-20230102200435157"></p><h2 id="第三方包安装"><a href="#第三方包安装" class="headerlink" title="第三方包安装"></a>第三方包安装</h2><h3 id="web3相关第三方包"><a href="#web3相关第三方包" class="headerlink" title="web3相关第三方包"></a>web3相关第三方包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet</span><br></pre></td></tr></table></figure><blockquote><p>注： ethereumjs-tx 使用1.3.7 版本</p></blockquote><h3 id="node-polyfill-兼容文件配置"><a href="#node-polyfill-兼容文件配置" class="headerlink" title="node-polyfill 兼容文件配置"></a>node-polyfill 兼容文件配置</h3><ol><li><p>下载polyfill 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-polyfill-webpack-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js 文件中配置插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line">++ <span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">++  configureWebpack: &#123;</span><br><span class="line">++    plugins: [</span><br><span class="line">++      <span class="keyword">new</span> NodePolyfillWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置vant-ui-ui组件库"><a href="#配置vant-ui-ui组件库" class="headerlink" title="配置vant-ui ui组件库"></a>配置vant-ui ui组件库</h3><p><a href="https://vant-contrib.gitee.io/vant/#/zh-CN" target="_blank" rel="noopener">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vant</span><br><span class="line">$ npm i unplugin-vue-components -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在vue.config.js 文件中配置插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">"@vue/cli-service"</span>);</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// vant</span></span><br><span class="line">++ <span class="keyword">const</span> &#123; VantResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>);</span><br><span class="line">++ <span class="keyword">const</span> ComponentsPlugin = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> NodePolyfillWebpackPlugin(),</span><br><span class="line">++    ComponentsPlugin(&#123; <span class="attr">resolvers</span>: [VantResolver()]&#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试 在app.vue文件添加代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line"> &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/2.png" alt="image-20230102202255947"></p><h3 id="通过vw配置响应式"><a href="#通过vw配置响应式" class="headerlink" title="通过vw配置响应式"></a>通过vw配置响应式</h3><p><a href="https://www.cnblogs.com/hongrun/p/16130707.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongrun/p/16130707.html</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在根目录下创建 名为 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">"px"</span>, <span class="comment">// 要转化的单位</span></span><br><span class="line">      viewportWidth: <span class="number">375</span>, <span class="comment">// UI设计稿的宽度</span></span><br><span class="line">      unitPrecision: <span class="number">6</span>, <span class="comment">// 转换后的精度，即小数点位数</span></span><br><span class="line">      propList: [<span class="string">"*"</span>], <span class="comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span></span><br><span class="line">      viewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定需要转换成的视窗单位，默认vw</span></span><br><span class="line">      fontViewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名，</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 默认值1，小于或等于1px则不进行转换</span></span><br><span class="line">      mediaQuery: <span class="literal">true</span>, <span class="comment">// 是否在媒体查询的css代码中也进行转换，默认false</span></span><br><span class="line">      replace: <span class="literal">true</span>, <span class="comment">// 是否转换后直接更换属性值</span></span><br><span class="line">      exclude: [<span class="regexp">/node_modules/</span>], <span class="comment">// 设置忽略文件，用正则做目录名匹配</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="web3连接到以太坊网络（测试网、主网）"><a href="#web3连接到以太坊网络（测试网、主网）" class="headerlink" title="web3连接到以太坊网络（测试网、主网）"></a>web3连接到以太坊网络（测试网、主网）</h1><ol><li>什么是web3<br>web3是以太坊官方开提供的一个连接以太坊区块链的模块，允许您使用HTTP或IPC与本地或远程以太坊节点进行交互，它包含以太坊生态系统的几乎所有功能。web3模块主要连接以太坊暴露出来的RPC层。开发者利用web3连接RPC层，可以连接任何暴露了RPC接口的节点，从而与区块链交互。web3是一个集合库，支持多种开发语言使用wbe3，其中的JavaScript API叫做web3.js、另外还有web3.py、web3j，web3.js将是我们钱包开发项目的重点。</li></ol><p>web3.eth：用于与以太坊区块链和智能合约之间的交互。</p><p>web3.utils：包含一些辅助方法。</p><p>web3.shh：用于协议进行通信的P2P和广播。</p><p>web3.bzz：用于与群网络交互的Bzz模块。</p><p>github地址：<a href="https://github.com/web3/web3.js/tree/v1.0.0-beta.34" target="_blank" rel="noopener">https://github.com/web3/web3.js/tree/v1.0.0-beta.34</a></p><p>web3.js开发文档：<a href="https://web3js.readthedocs.io/en/v1.8.1/" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/v1.8.1/</a></p><p>web3.js 中文文档 : <a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p><ol start="2"><li>实例化web3对象<br>web3要与以坊节点进行交互，需要创建一个web3对象，下面看看如何创建。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="comment">// "Web3.providers.givenProvider" will be set if in an Ethereum supported browser.</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">'ws://some.local-or-remote.node:8546'</span>);</span><br></pre></td></tr></table></figure><p>根据API可知需要指定节点地址，我们将ws://some.local-or-remote.node:8546换成其它连接到以太坊网络的节点的地址，以此来确定连接的以太坊的网络。那么连接到以太坊网络的节点的地址是多少呢？这里我们需要使用到infura。</p><ol start="3"><li>获取连接到以太坊网络的节点地址<br>infura提供公开的 Ethereum主网和测试网络节点，到infura.io网站注册后即可获取各个网络的地址。请按照如下步骤获取地址。</li></ol><p>第一步：打开 infura网站地址：<a href="https://infura.io/dashboard，使用邮箱注册后登陆" target="_blank" rel="noopener">https://infura.io/dashboard，使用邮箱注册后登陆</a></p><p>第二步：点击上图标记的“create new project”按钮创建一个新项目。然后弹出如下弹框，在输入框输入项目名，如”MyEtherWallet“，然后点击“create project”按钮创建。</p><p><img src="/2025/03/10/以太坊钱包开发/3.png" alt></p><p>第三步：然后会显示如下界面，点击下图中的选择框，可以看到提供主网、Kovan测试网络、Ropsten测试网络、GoerLi测试网络的节点地址。</p><p><img src="/2025/03/10/以太坊钱包开发/4.png" alt="image.png"></p><p>第四步：选择GoerLi测试网络，然后复制地址，将获取到类似这样的地址：<a href="https://kovan.infura.io/v3/d93f......cd67，如下。" target="_blank" rel="noopener">https://kovan.infura.io/v3/d93f......cd67，如下。</a></p><p><img src="/2025/03/10/以太坊钱包开发/5.png" alt="image.png"></p><ol start="4"><li>连接到以太坊GoerLi测试网络<br>现在将复制的地址替换掉实例化web对象的地址，如下</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>)</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">'wss://goerli.infura.io/ws/v3/cb7e63cf28244e4499b4b6fb6162e746'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Web3:"</span>, web3)</span><br></pre></td></tr></table></figure><p>连接到以太坊主网与GoerLi测试网络一样的，只需复制主网节点的地址去实例化web3即可。由于在主网上交易需要花费gas，因此我们基于GoerLi测试网络进行开发，后续开发完成后可再切换到主网。</p><p><img src="/2025/03/10/以太坊钱包开发/6.png" alt="image-20230102215334761"></p><h1 id="Web3js-高频-Api"><a href="#Web3js-高频-Api" class="headerlink" title="Web3js 高频 Api"></a>Web3js 高频 Api</h1><h2 id="账号创建"><a href="#账号创建" class="headerlink" title="账号创建"></a>账号创建</h2><ol><li>创建账号需要使用web3.js的如下API</li></ol><p>API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create([entropy]);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/7.png" alt="image.png"><br>参数：</p><p>entropy - String (可选): 它是一个可选项，是一个随机字符串，将作为解锁账号的密码。如果没有传递字符串，则使用random生成随机字符串。</p><p>返回值：</p><p>Object：包含以下字段的一个帐户对象：</p><p>address- string：帐户地址。</p><p>privateKey- string：帐户私钥。前端永远不应该在localstorage中以未加密的方式共享或存储！</p><p>signTransaction(tx [, callback])- Function：签名交易的方法。</p><p>sign(data)- Function：签名二进制交易的方法。</p><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br><span class="line">&#123;</span><br><span class="line">address: <span class="string">"0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4"</span>,</span><br><span class="line">privateKey: <span class="string">"0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098"</span>,</span><br><span class="line">signTransaction: <span class="function"><span class="keyword">function</span>(<span class="params">tx</span>)</span>&#123;...&#125;,</span><br><span class="line">sign: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;,</span><br><span class="line">encrypt: <span class="function"><span class="keyword">function</span>(<span class="params">password</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>获取地址<br>使用API<code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>addreds</code>属性，即账户的私钥。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account = web3.eth.accounts.create(<span class="string">"123456"</span>)</span><br><span class="line"><span class="keyword">let</span> address = account.address</span><br><span class="line"><span class="comment">//address：0xfF0B5A0AA68249cD161b606679DB49CBD9a12cd0</span></span><br></pre></td></tr></table></figure><p>3.获取私钥</p><p>使用API<code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>privateKey</code>属性，即账户的私钥。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account = web3.eth.accounts.create()</span><br><span class="line"><span class="keyword">let</span> privateKey = account.privateKey</span><br><span class="line"><span class="comment">//privateKey:0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709</span></span><br></pre></td></tr></table></figure><h2 id="余额获取"><a href="#余额获取" class="headerlink" title="余额获取"></a>余额获取</h2><p>根据地址获取以wei为单位余额</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getBalance(address).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a>单位转换</h2><ol><li>Eth 转为 wei</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Web3 或者实例后的web3对象都可以</span><br><span class="line"><span class="keyword">const</span> num = Web3.utils.toWei(<span class="string">"0.3"</span>);</span><br><span class="line"><span class="keyword">const</span> num = web3.utils.toWei(<span class="string">"0.3"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"><span class="comment">// 300000000000000000</span></span><br></pre></td></tr></table></figure><ol start="2"><li>wei 转为Eth</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Web3 或者实例后的web3对象都可以</span><br><span class="line"> <span class="keyword">this</span>.balance = Web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br><span class="line"> <span class="keyword">this</span>.balance = web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br></pre></td></tr></table></figure><h2 id="Eth转账"><a href="#Eth转账" class="headerlink" title="Eth转账"></a>Eth转账</h2><p><strong>API</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendSignedTransaction(signedTransactionData [, callback])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p><code>signedTransactionData</code>-<code>String</code>：以HEX格式签名的交易数据。</p><p>交易数据对象可以包含如下字段：</p><ul><li><code>from</code>- <code>String|Number</code>：发送帐户的地址。如果未指定，则使用web3.eth.defaultAccount属性。或web3.eth.accounts.wallet中本地钱包的地址。</li><li><code>to</code>- <code>String</code>:(可选）消息的目标地址，若未定义则为合同发送消息。</li><li><code>value</code>- <code>Number|String|BN|BigNumber</code>:(可选）为wei中的交易转移的数量，如果是合约发送消息，则是捐赠给合约地址。</li><li><code>gas</code> - <code>Number</code>:(可选，默认：待定）用于交易的gas（未使用的gas会退还）。</li><li><code>gasPrice</code>- <code>Number|String|BN|BigNumber</code>:(可选）此交易的gas价格，以wei为单位，默认为<a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#eth-gasprice" target="_blank" rel="noopener">web3.eth.gasPrice</a>。</li><li><code>data</code>- <code>String</code>:(可选）包含合同上函数调用数据的<a href="http://solidity.readthedocs.io/en/latest/abi-spec.html" target="_blank" rel="noopener">ABI字节字符串</a>。</li><li><code>nonce</code>- <code>Number</code>:(可选）随机数的整数。</li></ul></li><li><p><code>callback</code>-<code>Function</code>：（可选）可选回调，将错误对象作为第一个参数返回，结果作为第二个参数返回。</p></li></ul><p><strong>返回</strong></p><p><code>PromiEvent</code>：promise组合的事件，将在交易完成时调用。包含以下事件</p><ul><li><code>&quot;transactionHash&quot;</code>返回<code>String</code>：在发送事务并且事务哈希可用之后立即触发。</li><li><code>&quot;receipt&quot;</code>返回<code>Object</code>：在交易确认时触发。</li><li><code>&quot;confirmation&quot;</code>返回<code>Number</code>，<code>Object</code>：每次确认都会被调用，直到第12次确认。接收确认编号作为第一个参数，将数据作为第二个参数。</li><li><code>&quot;error&quot;</code>返回<code>Error</code>：如果在发送过程中发生错误，则会触发。</li></ul><ol><li><p>构建转账参数</p><p>区块链转账和支付宝转账类似，需要 <code>发送方</code> 、<code>接收方</code>、<code>金额</code>、<code>密码</code></p><p>另外需要添加部分区块链参数：<code>矿工费gas</code>、<code>地址转账交易次数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取账户交易次数</span></span><br><span class="line"> <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromaddress);</span><br><span class="line"> <span class="comment">// 获取预计转账gas费</span></span><br><span class="line"> <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line"> <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line"> <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.utils.toWei(number);</span><br><span class="line"> <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">   <span class="keyword">from</span>: fromaddress,</span><br><span class="line">   nonce: nonce,</span><br><span class="line">   gasPrice: gasPrice,</span><br><span class="line">   to: toaddress,</span><br><span class="line">   value: balance,</span><br><span class="line">   data: <span class="string">"0x00"</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过转账参数计算最终gas费用，并将通过私钥将转账参数进行编码加密</p><blockquote><p>ethereumjs-tx 第三方库请选择1.3.7版本</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tx <span class="keyword">from</span> <span class="string">"ethereumjs-tx"</span>;  </span><br><span class="line"><span class="comment">// 将私钥去除“ox”后进行hex转化</span></span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(privatekey.slice(<span class="number">2</span>), <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">      <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">      rawTx.gas = gas;</span><br><span class="line">     <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>sendSignedTransaction</code> api发送转账交易，并且获取交易id</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web3.eth</span><br><span class="line">  .sendSignedTransaction(<span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>))</span><br><span class="line">  .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;)</span></span><br><span class="line">  <span class="comment">// .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;)</span></span><br><span class="line">  .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>区块链浏览器或者目标钱包产看转账结果</p><p>goerli区块链浏览器 <a href="https://goerli.etherscan.io/tx/交易id" target="_blank" rel="noopener">https://goerli.etherscan.io/tx/交易id</a></p></li></ol><h1 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在前面的教程中我们对以太坊钱包已经有了一定的认识，上一章也重点介绍了账号地址的生成过程，在以太坊钱包中一个重点就是账户系统，在这个模块中很多初学同学不是很清楚密码、keystore、助记词与私钥它们之间的关系。下面我们来看看它们之间到底有着怎样的爱恨情仇，让大家琢磨不透。</p></blockquote><p><code>密码</code></p><p>密码不是私钥，它是在创建账户时候的密码（可以修改）</p><p>密码在以下情况下会使用到：</p><ol><li>作为转账的支付密码</li><li>用keystore导入钱包的时候需要输入的密码，用来解锁keystore的</li></ol><p><code>私钥 Private Key</code></p><p>私钥由64位长度的十六进制的字符组成，比如：<code>0xA4356E49C88C8B7AB370AF7D5C0C54F0261AAA006F6BDE09CD4745CF54E0115A</code>，一个账户只有一个私钥且不能修改。<br>通常一个钱包中私钥和公钥是成对出现的，有了私钥，我们就可以通过一定的算法生成公钥，再通过公钥经过一定的算法生成地址，这一过程都是不可逆的。私钥一定要妥善保管，若被泄漏别人可以通过私钥解锁账号转出你的该账号的数字货币。</p><p><code>公钥 Public Key</code></p><p>公钥(Public Key)是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</p><p><code>Keystore</code></p><p>Keystore常见于以太坊钱包，它是将私钥以加密的方式保存为一份 JSON 文件，这份 JSON 文件就是 keystore，所以它就是加密后的私钥。Keystore必须配合钱包密码才能导入并使用该账号。当黑客盗取 Keystore 后，在没有密码情况下, 有可能通过暴力破解 Keystore 密码解开 Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。</p><p><code>助记词 Mnemonic</code></p><p>私钥是64位长度的十六进制的字符，不利于记录且容易记错，所以用算法将一串随机数转化为了一串12 ~ 24个容易记住的单词，方便保存记录。注意：</p><ol><li>助记词是私钥的另一种表现形式</li><li>助记词=私钥，这是不正确的说法，通过助记词可以获取相关联的多个私钥，但是通过其中一个私钥是不能获取助记词的，因此<strong>助记词≠私钥</strong>。</li></ol><p>BIP</p><p>要弄清楚助记词与私钥的关系，得清楚BIP协议，是<code>Bitcoin Improvement Proposals</code>的缩写，意思是Bitcoin 的改进建议，用于提出 Bitcoin 的新功能或改进措施。BIP协议衍生了很多的版本，主要有BIP32、BIP39、BIP44。</p><p><strong>BIP32</strong></p><p>BIP32是 HD钱包的核心提案，通过种子来生成主私钥，然后派生海量的子私钥和地址，种子是一串很长的随机数。</p><p><strong>BIP39</strong></p><p>由于种子是一串很长的随机数，不利于记录，所以我们用算法将种子转化为一串12 ~ 24个的单词，方便保存记录，这就是BIP39，它扩展了 HD钱包种子的生成算法。</p><p><strong>BIP44</strong></p><p>BIP44 是在 BIP32 和 BIP43 的基础上增加多币种，提出的层次结构非常全面，它允许处理多个币种，多个帐户，每个帐户有数百万个地址。</p><p>在BIP32路径中定义以下5个级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m/purpse&apos;/coin_type&apos;/account&apos;/change/address_index</span><br></pre></td></tr></table></figure><ul><li>purpose：在BIP43之后建议将常数设置为44’。表示根据BIP44规范使用该节点的子树。</li><li>Coin_type：币种，代表一个主节点（种子）可用于无限数量的独立加密币，如比特币，Litecoin或Namecoin。此级别为每个加密币创建一个单独的子树，避免重用已经在其它链上存在的地址。开发人员可以为他们的项目注册未使用的号码。</li><li>Account：账户，此级别为了设置独立的用户身份可以将所有币种放在一个的帐户中，从0开始按顺序递增。</li><li>Change：常量0用于外部链，常量1用于内部链，外部链用于钱包在外部用于接收和付款。内部链用于在钱包外部不可见的地址，如返回交易变更。</li><li>Address_index：地址索引，按顺序递增的方式从索引0开始编号。</li></ul><p>BIP44的规则使得 HD钱包非常强大，用户只需要保存一个种子，就能控制所有币种，所有账户的钱包，因此由BIP39 生成的助记词非常重要，所以一定安全妥善保管，那么会不会被破解呢？如果一个 HD 钱包助记词是 12 个单词，一共有 2048 个单词可能性，那么随机的生成的助记词所有可能性大概是<code>5e+39</code>，因此几乎不可能被破解。</p><p><code>HD钱包</code></p><p>通过BIP协议生成账号的钱包叫做HD钱包。这个HD钱包，并不是Hardware Wallet硬件钱包，这里的 HD 是<code>Hierarchical Deterministic</code>的缩写，意思是分层确定性，所以HD钱包的全称为比特币分成确定性钱包 。</p><h2 id="密码、私钥、keystore与助记词的关系"><a href="#密码、私钥、keystore与助记词的关系" class="headerlink" title="密码、私钥、keystore与助记词的关系"></a>密码、私钥、keystore与助记词的关系</h2><p><img src="/2025/03/10/以太坊钱包开发/8.png" alt="img"></p><h2 id="钱包的核心：私钥"><a href="#钱包的核心：私钥" class="headerlink" title="钱包的核心：私钥"></a>钱包的核心：私钥</h2><p>基于以上的分析，我们对以太坊钱包的账号系统有了一个很好的认识，那么我们在使用钱包的过程中，该如何保管自己的钱包呢？主要包含以下几种方式：</p><ul><li>私钥（Private Key）</li><li>Keystore+密码（Keystore+Password）</li><li>助记词（Mnemonic code）</li></ul><p>通过以上三种中的一种方式都可以解锁账号，然后掌控它，所以对于每种方式中的数据都必须妥善包括，如有泄漏，请尽快转移数字资产。</p><p>我们可以得到以下总结：</p><ul><li>通过私钥+密码可以生成keystore，即加密私钥；</li><li>通过keystore+密码可以获取私钥，即解密keystore。</li><li>通过助记词根据不同的路径获取不同的私钥，即使用HD钱包将助记词转化成种子来生成主私钥，然后派生海量的子私钥和地址。</li></ul><p>可以看出这几种方式的核心其实都是为了获得私钥，然后去解锁账号，因此钱包的核心功能是私钥的创建、存储和使用。</p><p><strong>参考资料</strong></p><p><a href="https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a><br><a href="https://github.com/ethereum/EIPs/issues/84" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/84</a><br><a href="https://github.com/ethereum/EIPs/issues/85" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/85</a></p><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><blockquote><p>从无到有创建一个新的账户</p></blockquote><h3 id="web3-直接创建账户"><a href="#web3-直接创建账户" class="headerlink" title="web3 直接创建账户"></a>web3 直接创建账户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br></pre></td></tr></table></figure><h3 id="助记词-创建账户"><a href="#助记词-创建账户" class="headerlink" title="助记词 创建账户"></a>助记词 创建账户</h3><p>需要使用<code>bip39</code>协议将助记词转换成种子，再通过<code>ethereumjs-wallet</code>库生成hd钱包，根据路径的不同从hd钱包中获取不同的keypair，keypair中就包含有公钥、私钥，再通过<code>ethereumjs-util</code>库将公钥生成地址，从而根据助记词获取所有关联的账号，能获取到公钥、私钥、地址等数据信息。</p><h4 id="1-依赖库"><a href="#1-依赖库" class="headerlink" title="1. 依赖库"></a>1. 依赖库</h4><p>需要用到三个库：bip39、ethereumjs-wallet/hdkey、ethereumjs-util。先安装依赖库，<code>cd</code>到项目跟路径运行命令<code>npm i bip39 ethereumjs-wallet ethereumjs-util</code>。</p><ul><li><a href="https://github.com/bitcoinjs/bip39" target="_blank" rel="noopener">bip39</a>：随机产生新的 mnemonic code，并可以将其转成 binary 的 seed。</li><li><a href="https://github.com/ethereumjs/ethereumjs-wallet" target="_blank" rel="noopener">ethereumjs-wallet</a>：生成和管理公私钥，下面使用其中 hdkey 子套件来创建 HD 钱包。</li><li><a href="https://github.com/ethereumjs/ethereumjs-util" target="_blank" rel="noopener">ethereumjs-util</a>：Ethereum 的一个工具库。</li><li><a href="https://iancoleman.io/bip39/" target="_blank" rel="noopener">https://iancoleman.io/bip39/</a></li></ul><h4 id="2-通过助记词创建账号"><a href="#2-通过助记词创建账号" class="headerlink" title="2. 通过助记词创建账号"></a>2. 通过助记词创建账号</h4><ul><li><p>创建助记词</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入bip39模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bip39 <span class="keyword">from</span> <span class="string">"bip39"</span>;</span><br><span class="line"><span class="comment">// 创建助记词 </span></span><br><span class="line"><span class="keyword">let</span> mnemonic = bip39.generateMnemonic();</span><br><span class="line"><span class="built_in">console</span>.log(mnemonic);</span><br><span class="line"><span class="comment">// 结果 12位助记词</span></span><br><span class="line"><span class="comment">// vote select solar shy embrace immense lizard stamp scrub vague negative forward</span></span><br></pre></td></tr></table></figure></li><li><p>根据助记词生成密钥对 keypair</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 导入分层钱包模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; hdkey &#125; <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;</span><br><span class="line">      <span class="comment">//1.将助记词转成seed</span></span><br><span class="line">      <span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.mnemonicToSeed(<span class="string">"12位助记词"</span>);</span><br><span class="line">      <span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line">      <span class="keyword">let</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">      <span class="comment">//4.生成钱包中在m/44'/60'/0'/0/i路径的keypair</span></span><br><span class="line">      <span class="keyword">let</span> keypair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(keypair);</span><br></pre></td></tr></table></figure><p>keypair 密钥对</p><p><img src="/2025/03/10/以太坊钱包开发/9.png" alt="image-20221208222354836"></p><h4 id="3-由keypair-获取钱包地址和私钥"><a href="#3-由keypair-获取钱包地址和私钥" class="headerlink" title="3. 由keypair 获取钱包地址和私钥"></a>3. 由keypair 获取钱包地址和私钥</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.getWallet();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"lowerCaseAddress"</span>, lowerCaseAddress);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"CheckSumAddress"</span>, CheckSumAddress);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"prikey"</span>, prikey);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lowerCaseAddress 0xd9fc0fd4412616c7075e68b151ab3a7bcb9a3f54</span></span><br><span class="line"><span class="comment">CheckSumAddress 0xd9fC0FD4412616c7075E68b151ab3A7bcB9A3f54</span></span><br><span class="line"><span class="comment">prikey 3fc11495517f1f015bbcb6c311da66e3b26b23e4c91c1285ccc4b69d9d274002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="导出账户"><a href="#导出账户" class="headerlink" title="导出账户"></a>导出账户</h2><blockquote><p>一个已经存在的账户导出 私钥 和 keystore</p></blockquote><ol><li>通过分层钱包对象 + 密码 创建keystore</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(data.pass1); <span class="comment">// 参数必须为 字符串</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过私钥和密码创建 keystore </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keystore = <span class="keyword">await</span> web3.eth.accounts.encrypt(<span class="string">"账户私钥"</span>,<span class="string">"密码"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟keystore数据</span></span><br><span class="line"><span class="keyword">const</span> keystoreJsonV3 = &#123;</span><br><span class="line">        version: <span class="number">3</span>,</span><br><span class="line">        id: <span class="string">"dbb70fb2-52ad-4e1f-9c19-0b50329f89c3"</span>,</span><br><span class="line">        address: <span class="string">"445b469888528dacd9b87246c5ce70407adaa411"</span>,</span><br><span class="line">        crypto: &#123;</span><br><span class="line">          ciphertext:</span><br><span class="line">            <span class="string">"1e53e7e775644422600188b8134907992db40d278064ea3a966da4dcdf80db64"</span>,</span><br><span class="line">          cipherparams: &#123; <span class="attr">iv</span>: <span class="string">"f9d2b047019674eee449b316f4a21491"</span> &#125;,</span><br><span class="line">          cipher: <span class="string">"aes-128-ctr"</span>,</span><br><span class="line">          kdf: <span class="string">"scrypt"</span>,</span><br><span class="line">          kdfparams: &#123;</span><br><span class="line">            dklen: <span class="number">32</span>,</span><br><span class="line">            salt: <span class="string">"153e074d78d0ba36fae3e46e582c42e53f61653cb5d4f1a3a3f68094e6ca0160"</span>,</span><br><span class="line">            n: <span class="number">8192</span>,</span><br><span class="line">            r: <span class="number">8</span>,</span><br><span class="line">            p: <span class="number">1</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          mac: <span class="string">"e91456c59b2505c16b80c2495ab7b4633273c2ae366cb6953f27de8cfebad629"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"> <span class="keyword">const</span> res = web3.eth.accounts.decrypt(keystoreJsonV3, <span class="string">"1235"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过keystore解密私钥</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br></pre></td></tr></table></figure><h2 id="导入账户"><a href="#导入账户" class="headerlink" title="导入账户"></a>导入账户</h2><blockquote><p>通过 私钥、助记词、keystore 导入一个已经存在的钱包账户 地址 和 私钥</p></blockquote><ol><li>通过keystore获取 私钥和地址 </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line"><span class="keyword">let</span> address = wallet.getAddressString()</span><br></pre></td></tr></table></figure><ol start="2"><li>通过助记词 获取地址和私钥</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mnemonic=prompt(<span class="string">"请输入助记词"</span>)</span><br><span class="line"><span class="keyword">let</span> seed = bip39.mnemonicToSeed(mnemonic)</span><br><span class="line"><span class="keyword">let</span> hdwallet = hdkey.fromMasterSeed(seed)</span><br><span class="line"><span class="keyword">let</span> keypair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.getWallet();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>通过私钥获取 地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;     </span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> Buffer( prompt(<span class="string">"请输入私钥"</span>), <span class="string">'hex'</span> )</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.fromPrivateKey(privatekey)</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br></pre></td></tr></table></figure></li></ol><h1 id="区块链钱包项目流程"><a href="#区块链钱包项目流程" class="headerlink" title="区块链钱包项目流程"></a>区块链钱包项目流程</h1><p><img src="/2025/03/10/以太坊钱包开发/10.png" alt="image-20221209110335777"></p><h3 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1.项目准备"></a>1.项目准备</h3><p>​         直接采用随堂demo创建的项目 不需要重新创建</p><h4 id="web3相关第三方包-1"><a href="#web3相关第三方包-1" class="headerlink" title="web3相关第三方包"></a>web3相关第三方包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet</span><br></pre></td></tr></table></figure><blockquote><p>注： ethereumjs-tx 使用1.3.7 版本</p></blockquote><h4 id="node-polyfill-兼容文件配置-1"><a href="#node-polyfill-兼容文件配置-1" class="headerlink" title="node-polyfill 兼容文件配置"></a>node-polyfill 兼容文件配置</h4><ol><li><p>下载polyfill 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-polyfill-webpack-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js 文件中配置插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line">++ <span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">++  configureWebpack: &#123;</span><br><span class="line">++    plugins: [</span><br><span class="line">++      <span class="keyword">new</span> NodePolyfillWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置vant-ui-ui组件库-1"><a href="#配置vant-ui-ui组件库-1" class="headerlink" title="配置vant-ui ui组件库"></a>配置vant-ui ui组件库</h4><p><a href="https://vant-contrib.gitee.io/vant/#/zh-CN" target="_blank" rel="noopener">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vant</span><br><span class="line">$ npm i unplugin-vue-components -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在vue.config.js 文件中配置插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">"@vue/cli-service"</span>);</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// vant</span></span><br><span class="line">++ <span class="keyword">const</span> &#123; VantResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>);</span><br><span class="line">++ <span class="keyword">const</span> ComponentsPlugin = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> NodePolyfillWebpackPlugin(),</span><br><span class="line">++    ComponentsPlugin(&#123; <span class="attr">resolvers</span>: [VantResolver()]&#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试 在app.vue文件添加代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line"> &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/11.png" alt="image-20230102202255947"></p><h4 id="通过vw配置响应式-1"><a href="#通过vw配置响应式-1" class="headerlink" title="通过vw配置响应式"></a>通过vw配置响应式</h4><p><a href="https://www.cnblogs.com/hongrun/p/16130707.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongrun/p/16130707.html</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在根目录下创建 名为 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">"px"</span>, <span class="comment">// 要转化的单位</span></span><br><span class="line">      viewportWidth: <span class="number">375</span>, <span class="comment">// UI设计稿的宽度</span></span><br><span class="line">      unitPrecision: <span class="number">6</span>, <span class="comment">// 转换后的精度，即小数点位数</span></span><br><span class="line">      propList: [<span class="string">"*"</span>], <span class="comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span></span><br><span class="line">      viewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定需要转换成的视窗单位，默认vw</span></span><br><span class="line">      fontViewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名，</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 默认值1，小于或等于1px则不进行转换</span></span><br><span class="line">      mediaQuery: <span class="literal">true</span>, <span class="comment">// 是否在媒体查询的css代码中也进行转换，默认false</span></span><br><span class="line">      replace: <span class="literal">true</span>, <span class="comment">// 是否转换后直接更换属性值</span></span><br><span class="line">      exclude: [<span class="regexp">/node_modules/</span>], <span class="comment">// 设置忽略文件，用正则做目录名匹配</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="封装缓存函数"><a href="#封装缓存函数" class="headerlink" title="封装缓存函数"></a>封装缓存函数</h4><p>整个项目为了保证钱包的安全性，所有账户相关的操作，不经过中心化服务器，只在缓存使用</p><p>在这里可以参考<code>webstorage</code>增加过期时间，cookie 等的封装</p><p>创建 src/utils/storage.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  setItem(key, val) &#123;</span><br><span class="line">    localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(val || <span class="string">""</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  getItem(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> val;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      val = <span class="built_in">JSON</span>.parse(localStorage.getItem(key));</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      val = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Storage();</span><br></pre></td></tr></table></figure><h4 id="app-vue-文件引入"><a href="#app-vue-文件引入" class="headerlink" title="app.vue 文件引入"></a>app.vue 文件引入</h4><p>在app.vue 引入文件并且初始化web3.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">   &lt;h3&gt; qf - eth -wallet&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// import * as util from &quot;ethereumjs-util&quot;;</span><br><span class="line">import ethwallet from &quot;ethereumjs-wallet&quot;;  </span><br><span class="line">import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import * as bip39 from &quot;bip39&quot;;</span><br><span class="line">import Tx from &quot;ethereumjs-tx&quot;;</span><br><span class="line">import Web3 from &quot;web3&quot;;</span><br><span class="line">import storage from &quot;@/utils/storage&quot;;</span><br><span class="line">var web3 = new Web3(</span><br><span class="line">  Web3.givenProvider ||</span><br><span class="line">    &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-通过Mnemonic助记词创建钱包"><a href="#2-通过Mnemonic助记词创建钱包" class="headerlink" title="2.通过Mnemonic助记词创建钱包"></a>2.通过Mnemonic助记词创建钱包</h3><blockquote><p> 判断缓存是否有 钱包对象</p><ol><li>有钱包对象显示钱包信息  地址 私钥  余额</li><li>没有钱包对象显示创建钱包按钮</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;qf - eth -wallet&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;创建钱包&lt;/h4&gt;</span><br><span class="line">    &lt;van-button type=&quot;primary&quot; @click=&quot;createWallet&quot;&gt; 创建钱包 &lt;/van-button&gt;</span><br><span class="line">    &lt;van-button type=&quot;primary&quot; @click=&quot;importWallet&quot;&gt;</span><br><span class="line">      导入钱包-助记词</span><br><span class="line">    &lt;/van-button&gt;</span><br><span class="line">    &lt;h4&gt;钱包信息&lt;/h4&gt;</span><br><span class="line">    &#123;&#123; wallet &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">// import * as util from &quot;ethereumjs-util&quot;;</span><br><span class="line">import ethwallet from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import * as bip39 from &quot;bip39&quot;;</span><br><span class="line">import Tx from &quot;ethereumjs-tx&quot;;</span><br><span class="line">import storage from &quot;@/utils/storage&quot;;</span><br><span class="line">import Web3 from &quot;web3&quot;;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;;</span><br><span class="line">var web3 = new Web3(</span><br><span class="line">  Web3.givenProvider ||</span><br><span class="line">    &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;</span><br><span class="line">);</span><br><span class="line">const wallet = reactive(storage.getItem(&quot;wallet&quot;) || &#123;&#125;);</span><br><span class="line">console.log(wallet);</span><br><span class="line">async function createWallet() &#123;</span><br><span class="line">  const pass = prompt(&quot;请输入您的钱包密码&quot;);</span><br><span class="line">  if (!pass) return false;</span><br><span class="line">  let mnemonic = bip39.generateMnemonic();</span><br><span class="line">  alert(&quot;您的助记词为:&quot; + mnemonic);</span><br><span class="line">  const checkMnemonic = prompt(&quot;请输入您的助记词&quot;);</span><br><span class="line">  if (mnemonic === checkMnemonic) &#123;</span><br><span class="line">    //1.将助记词转成seed</span><br><span class="line">    let seed = await bip39.mnemonicToSeed(mnemonic);</span><br><span class="line">    //3.通过hdkey将seed生成HD Wallet</span><br><span class="line">    let hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">    //4.生成钱包中在m/44&apos;/60&apos;/0&apos;/0/i路径的keypair</span><br><span class="line">    let keyPair = hdWallet.derivePath(&quot;m/44&apos;/60&apos;/0&apos;/0/0&quot;);</span><br><span class="line">    // 获取钱包对象</span><br><span class="line">    let wallet = keyPair.getWallet();</span><br><span class="line">    // 获取钱包地址</span><br><span class="line">    let lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">    // 获取钱包校验地址</span><br><span class="line">    let CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line">    // 获取私钥</span><br><span class="line">    let prikey = wallet.getPrivateKey().toString(&quot;hex&quot;);</span><br><span class="line">    let keystore = await wallet.toV3(pass);</span><br><span class="line">    console.log(keystore);</span><br><span class="line">    // 保存钱包信息</span><br><span class="line">    const walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: 0,</span><br><span class="line">      mnemonic, // 助记词不应该记录下来仅仅是为了便于演示</span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(&quot;wallet&quot;, walletInfo);</span><br><span class="line">    wallet = walletInfo;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(&quot;助记词错误请重新输入&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-显示余额"><a href="#3-显示余额" class="headerlink" title="3.显示余额"></a>3.显示余额</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balance = ref(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取余额</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!wallet.address) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 根据地址查询余额</span></span><br><span class="line">  web3.eth.getBalance(wallet.address).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    balance.value = web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">getBalance()</span><br></pre></td></tr></table></figure><h3 id="4-转账交易"><a href="#4-转账交易" class="headerlink" title="4.转账交易"></a>4.转账交易</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 获取用户输入金额 与 地址 </span><br><span class="line"><span class="number">2.</span> 调用send 方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keystore = storage.getItem(<span class="string">"wallet"</span>).keystore;</span><br><span class="line">  <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">  <span class="keyword">let</span> walletobj;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    walletobj = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    alert(<span class="string">"密码错误"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> key = walletobj.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">  <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">  <span class="comment">// console.log(privateKey);</span></span><br><span class="line">  <span class="keyword">const</span> fromaddress = wallet.address;</span><br><span class="line">  <span class="comment">// 获取账户交易次数</span></span><br><span class="line">  <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromaddress);</span><br><span class="line">  <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">  <span class="built_in">console</span>.log(number.value, <span class="keyword">typeof</span> number.value);</span><br><span class="line">  <span class="keyword">let</span> balance = Web3.utils.toWei(number.value);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">  <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">    <span class="keyword">from</span>: fromaddress,</span><br><span class="line">    nonce: nonce,</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">    to: toaddress.value,</span><br><span class="line">    value: balance,</span><br><span class="line">    data: <span class="string">"0x00"</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">  <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">  rawTx.gas = gas;</span><br><span class="line">  <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">  <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">  tx.sign(privateKey);</span><br><span class="line">  <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line"></span><br><span class="line">  web3.eth</span><br><span class="line">    .sendSignedTransaction(<span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>))</span><br><span class="line">    .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;)</span></span><br><span class="line">    <span class="comment">// .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;)</span></span><br><span class="line">    .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-导出账户信息"><a href="#5-导出账户信息" class="headerlink" title="5.导出账户信息"></a>5.导出账户信息</h3><ul><li>导出私钥</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">exportKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> walletObj;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        walletObj = <span class="keyword">await</span> ethwallet.fromV3(wallet.keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = walletObj.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">   alert(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导出keystore </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缓存对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exportKeyStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">JSON</span>.stringify(wallet.keystore))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-解锁账户信息"><a href="#6-解锁账户信息" class="headerlink" title="6.解锁账户信息"></a>6.解锁账户信息</h3><ul><li><p>助记词解锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">添加助记词导入钱包方法</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">importWallet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mnemonic = prompt(<span class="string">"请输入助记词"</span>);</span><br><span class="line">  <span class="keyword">const</span> pass = prompt(<span class="string">"请输入您的钱包密码"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!pass) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//1.将助记词转成seed</span></span><br><span class="line">    <span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.mnemonicToSeed(mnemonic);</span><br><span class="line">    <span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line">    <span class="keyword">let</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">    <span class="comment">//4.生成钱包中在m/44'/60'/0'/0/i路径的keypair</span></span><br><span class="line">    <span class="keyword">let</span> keyPair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line">    <span class="comment">// 获取钱包对象</span></span><br><span class="line">    <span class="keyword">let</span> wallet = keyPair.getWallet();</span><br><span class="line">    <span class="comment">// 获取钱包地址</span></span><br><span class="line">    <span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">    <span class="comment">// 获取钱包校验地址</span></span><br><span class="line">    <span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line">    <span class="comment">// 获取私钥</span></span><br><span class="line">    <span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">    <span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(pass);</span><br><span class="line">    <span class="built_in">console</span>.log(keystore);</span><br><span class="line">    <span class="comment">// 保存钱包信息</span></span><br><span class="line">    <span class="keyword">const</span> walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: <span class="number">0</span>,</span><br><span class="line">      mnemonic, <span class="comment">// 助记词不应该记录下来仅仅是为了便于演示</span></span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(<span class="string">"wallet"</span>, walletInfo);</span><br><span class="line">    wallet = walletInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>私钥解锁</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">importByPrivateKey</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> key = prompt(<span class="string">"请输入私钥"</span>)</span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> Buffer(key , <span class="string">'hex'</span> )</span><br><span class="line">  <span class="keyword">let</span> pass =  prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.fromPrivateKey(privatekey)</span><br><span class="line">  <span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(pass);</span><br><span class="line">  <span class="comment">// 获取钱包地址</span></span><br><span class="line">  <span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">  <span class="keyword">const</span> walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey: key,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(walletInfo)</span><br><span class="line">    storage.setItem(<span class="string">"wallet"</span>, walletInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>未来展望<ul><li>通过uniapp 、rn、electron 将项目变为app和桌面端应用</li><li>app添加扫码转账功能</li><li>增加erc20代币转账功能</li><li>增加nft数字藏品商城功能</li><li>增加Dao 应用</li></ul></li></ol><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol><li><p>通过智能合约文件 获取abi</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; abi &#125; <span class="keyword">from</span> <span class="string">"@/contract/HHC.json"</span>;</span><br></pre></td></tr></table></figure></li><li><p>在web3实例的基础上创建智能合约实例</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hhc = <span class="keyword">new</span> <span class="keyword">this</span>.web3.eth.Contract(</span><br><span class="line">  abi,</span><br><span class="line">  <span class="string">"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过智能合约实例获取代币余额</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> num = <span class="keyword">await</span> hhc.methods.balanceOf(address).call();</span><br><span class="line">Web3.utils.fromWei(num, <span class="string">"ether"</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>智能合约交易hash 创建</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> createCoinTransationHx(contractInstance, method, to, value) &#123;</span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">   <span class="keyword">let</span> wallet;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     alert(<span class="string">"密码错误"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">from</span> = <span class="keyword">this</span>.ownerAddress;</span><br><span class="line">   <span class="comment">// 当前地址交易次数</span></span><br><span class="line">   <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">   <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">   <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">   <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.getGasPrice();</span><br><span class="line">   <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">   <span class="keyword">let</span> weiValue = <span class="keyword">await</span> Web3.utils.toWei(value);</span><br><span class="line">   <span class="comment">// 转账的记录对象</span></span><br><span class="line">   <span class="comment">// 代币转账</span></span><br><span class="line">   <span class="comment">// this.HccCont = new this.web3.eth.Contract(</span></span><br><span class="line">   <span class="comment">//   abi,</span></span><br><span class="line">   <span class="comment">//   "0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">   <span class="comment">// );</span></span><br><span class="line">   <span class="keyword">const</span> contractAbi = <span class="keyword">await</span> contractInstance.methods[method](</span><br><span class="line">     to,</span><br><span class="line">     weiValue</span><br><span class="line">   ).encodeABI();</span><br><span class="line">   <span class="comment">// console.log(contractAbi);</span></span><br><span class="line">   <span class="comment">// console.log(contractInstance._address);</span></span><br><span class="line">   <span class="comment">// return false;</span></span><br><span class="line">   <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">     <span class="keyword">from</span>: <span class="keyword">this</span>.ownerAddress,</span><br><span class="line">     nonce: nonce,</span><br><span class="line">     gasPrice: gasPrice,</span><br><span class="line">     to: contractInstance._address, <span class="comment">//eth 转账 to 目标地址 ，智能合约 to 智能合约地址</span></span><br><span class="line">     value: <span class="number">0</span>, <span class="comment">//eth 转账 数量</span></span><br><span class="line">     data: contractAbi, <span class="comment">//智能合约方法的abi编码</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">   <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.estimateGas(rawTx);</span><br><span class="line">   rawTx.gas = gas;</span><br><span class="line">   <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">   <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">   tx.sign(privateKey);</span><br><span class="line">   <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">   <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">   <span class="keyword">return</span> transationHx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>智能合约代币转账</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.web3.eth</span><br><span class="line">      .sendSignedTransaction(hx)</span><br><span class="line">      .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">        cb &amp;&amp; cb(ret);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">        <span class="keyword">const</span> &#123; transactionHash &#125; = ret;</span><br><span class="line">        <span class="keyword">this</span>.createOrderData(transactionHash);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"latestBlockHash"</span>, (...arg) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"latestBlockHash"</span>, arg);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error:"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用vue开发以太坊钱包&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>RAG系统搭建(基础版)</title>
    <link href="/2025/02/20/RAG%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA-%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    <id>/2025/02/20/RAG系统搭建-基础版/</id>
    <published>2025-02-20T07:32:05.000Z</published>
    <updated>2025-02-21T06:11:52.607Z</updated>
    
    <content type="html"><![CDATA[<p>简单的搭建一个大语言模型的RAG系统<br><a id="more"></a><br>RAG（Retrieval-Augmented Generation）系统是一种结合了信息检索（Retrieval）和文本生成（Generation）能力的框架，通过将传统的基于检索的方法与现代的生成模型相结合，来提升对任务的回答质量和准确性。<br><img src="/2025/02/20/RAG系统搭建-基础版/1.png" alt="img"></p><h2 id="python环境搭建"><a href="#python环境搭建" class="headerlink" title="python环境搭建"></a>python环境搭建</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用Anaconda来安装python环境，可以直接在系统的应用商店中安装。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>打开Anaconda PowerShell Prompt<br>1.创建环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name envName python=3.10 // 目前最好使用3.10版本，对各种库的兼容性比较好</span><br></pre></td></tr></table></figure></p><p>2.激活环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate envName</span><br></pre></td></tr></table></figure></p><p>3.查看当前环境列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure></p><p>4.卸载环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 确保当前激活环境非要删除的envName</span><br><span class="line">conda env remove --name envName</span><br></pre></td></tr></table></figure></p><p>5.安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装单个包</span><br><span class="line">pip install package_name</span><br><span class="line"></span><br><span class="line">// 根据requirements.txt文件安装所有依赖</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p>6.更换镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">华为云：https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure></p><p>7.查看当前环境都安装了哪些依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></p><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p><a href="https://huggingface.co/models" target="_blank" rel="noopener">HuggingFace模型</a>，这个网站需要科学上网，所以国内使用<a href="https://modelscope.cn/models" target="_blank" rel="noopener">modelscope</a></p><h3 id="安装modelscope依赖库"><a href="#安装modelscope依赖库" class="headerlink" title="安装modelscope依赖库"></a>安装modelscope依赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install modelscope -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="Sentence-Transformer模型下载"><a href="#Sentence-Transformer模型下载" class="headerlink" title="Sentence Transformer模型下载"></a>Sentence Transformer模型下载</h3><p>在进行RAG之前，需要使用词向量模型进行Embedding，将文本进行向量化处理，执行下述命令下载模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 模型下载</span><br><span class="line">from modelscope import snapshot_download</span><br><span class="line"></span><br><span class="line"># model_id 模型的id</span><br><span class="line"># cache_dir 模型下载路径</span><br><span class="line">model_dir = snapshot_download(model_id=&apos;Ceceliachenen/paraphrase-multilingual-MiniLM-L12-v2&apos;, cache_dir=&apos;D:/jinux/models&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="LLM模型下载"><a href="#LLM模型下载" class="headerlink" title="LLM模型下载"></a>LLM模型下载</h3><p>这里选择千问0.5B大模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from modelscope import snapshot_download</span><br><span class="line"></span><br><span class="line">model_dir = snapshot_download(model_id=&apos;Qwen/Qwen2.5-0.5B-Instruct&apos;, cache_dir=&apos;D:/jinux/models&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><p>下边案例所需要的依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install llama_index -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install llama_index.llms.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install transformers -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install llama_index.embeddings.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure></p><h2 id="调用本地模型进行推理测试"><a href="#调用本地模型进行推理测试" class="headerlink" title="调用本地模型进行推理测试"></a>调用本地模型进行推理测试</h2><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from llama_index.llms.huggingface import HuggingFaceLLM</span><br><span class="line">from llama_index.core.llms import ChatMessage</span><br><span class="line"></span><br><span class="line"># 使用HuggingFace 加载本地大模型</span><br><span class="line">llm = HuggingFaceLLM(</span><br><span class="line">  # 给定的是本地模型的全路径</span><br><span class="line">  model_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字</span><br><span class="line">  tokenizer_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 模型名字</span><br><span class="line">  model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;,</span><br><span class="line">  tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;</span><br><span class="line">)</span><br><span class="line">rsp = llm.chat(messages=[ChatMessage(content=&quot;请简单的介绍一下jinux&quot;)])</span><br><span class="line">print(rsp)</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">Jenkins 是一个开源的自动化构建工具，它允许开发者......</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line"> JLinux 是一种基于 Linux 的开源操作系统，由阿里云......</span><br></pre></td></tr></table></figure><p>推理结果每次都是错的。</p><h2 id="创建知识库-RAG"><a href="#创建知识库-RAG" class="headerlink" title="创建知识库(RAG)"></a>创建知识库(RAG)</h2><h3 id="执行代码-1"><a href="#执行代码-1" class="headerlink" title="执行代码"></a>执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings</span><br><span class="line">from llama_index.embeddings.huggingface import HuggingFaceEmbedding</span><br><span class="line">from llama_index.llms.huggingface import HuggingFaceLLM</span><br><span class="line"></span><br><span class="line"># 初始化一个HuggingFaceEmbedding对象，用于将文本转换为向量表示</span><br><span class="line"># 指定了一个预训练的sentence-transformer模型的路径</span><br><span class="line">embed_model = HuggingFaceEmbedding(</span><br><span class="line">    model_name=r&quot;D:\jinux\models\Ceceliachenen\paraphrase-multilingual-MiniLM-L12-v2&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 将创建的嵌入模型赋值给全局设置的embed_model属性，</span><br><span class="line"># 这样在后续的索引构建过程中就会使用这个模型。</span><br><span class="line">Settings.embed_model = embed_model</span><br><span class="line"></span><br><span class="line"># 推理模型（生成模型）</span><br><span class="line">llm = HuggingFaceLLM(</span><br><span class="line">  # 给定的是本地模型的全路径</span><br><span class="line">  model_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字</span><br><span class="line">  tokenizer_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 模型名字</span><br><span class="line">  model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;,</span><br><span class="line">  tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置全局的llm属性，这样在索引查询时会使用这个模型</span><br><span class="line">Settings.llm = llm</span><br><span class="line"></span><br><span class="line"># RAG 系统构建过程</span><br><span class="line"># 从指定目录读取所有文档，并加载数据到内存中，required_exts 只加载指定扩展名的文档</span><br><span class="line">documents = SimpleDirectoryReader(&quot;./documents&quot;, required_exts=[&quot;.txt&quot;]).load_data()</span><br><span class="line"></span><br><span class="line"># 创建一个VectorStoreIndex，并使用之前加载的文档来构建索引</span><br><span class="line"># 此索引将文档转换为向量，并存储这些向量以便于快速检索</span><br><span class="line"># 默认是存储在内存中的</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line"></span><br><span class="line"># 创建一个查询引擎，这个引擎可以接收查询并返回相关文档的响应</span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(&quot;请简单的介绍一下jinux&quot;)</span><br><span class="line"></span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他是一个大龄前端程序员。</span><br><span class="line">他的工作经历和职业背景主要集中在工作中遇到的年龄危机以及他正在学习AI方面知识上。由于他是一位大龄程序员，他在工作中可能会面临一些挑战，比如可能被裁员的风险。因此，他需要不断学习新的技能和知识来应对这些风险。</span><br></pre></td></tr></table></figure><p>测试结果是正确的，因为提供的文档中有这些信息。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>上述代码原理见下图<br><img src="/2025/02/20/RAG系统搭建-基础版/2.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个RAG系统非常简单，但是基本原理是这样的，通过向量化的方式，将文本转换为向量，然后通过向量检索的方式，找到最相似的文本，最后再交给LLM模型进行推理，得到最终的答案。<br><a href="https://github.com/jinux7/study-collections/tree/master/python/AI" target="_blank" rel="noopener">源码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的搭建一个大语言模型的RAG系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>docker基础教程</title>
    <link href="/2025/02/06/docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>/2025/02/06/docker基础教程/</id>
    <published>2025-02-06T06:58:27.000Z</published>
    <updated>2025-03-05T06:07:35.720Z</updated>
    
    <content type="html"><![CDATA[<p>docker基础入门教程<br><a id="more"></a></p><blockquote><p>本文章运行环境是window11专业版 版本号24H2</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><ul><li>任务栏搜索”功能”，点击”启用或关闭windows功能”</li><li>勾选”适用于Linux的Windows子系统”和”虚拟机平台”,点击确定后重启电脑</li></ul><h3 id="安装wsl2"><a href="#安装wsl2" class="headerlink" title="安装wsl2"></a>安装wsl2</h3><ul><li>使用管理员身份打开CMD</li><li>输入命令<code>wsl --set-default-version 2</code></li><li>输入命令<code>wsl --update</code>也可以<code>wsl --update --web-download</code></li></ul><h3 id="下载docker"><a href="#下载docker" class="headerlink" title="下载docker"></a>下载docker</h3><ul><li><a href="https://www.docker.com/" target="_blank" rel="noopener">docker官网</a></li><li>下载后安装(intel core处理器下载AMD的安装文件)</li></ul><p>安装后可在CMD中执行<code>docker --version</code>查看docker版本</p><h2 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h2><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># 删除 image 文件</span><br><span class="line">docker image rm [imageName]</span><br></pre></td></tr></table></figure></p><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 是最重要、最常用的 image 仓库。</p><h2 id="实例（hello-world）"><a href="#实例（hello-world）" class="headerlink" title="实例（hello world）"></a>实例（hello world）</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello world</a>“，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站。</p><blockquote><p>1.右键点击系统托盘（右下角）的 Docker 图标，选择 Settings（或直接打开 Docker Desktop）。<br>  2.进入 Docker Engine 配置页面。<br>  3.在编辑框中修改 registry-mirrors 字段，添加国内镜像源地址<br>    {<br>      “builder”: {<br>        “gc”: {<br>          “defaultKeepStorage”: “20GB”,<br>          “enabled”: true<br>        }<br>      },<br>      “experimental”: false,<br>      “registry-mirrors”: [<br>        “<a href="https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;" target="_blank" rel="noopener">https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;</a>,<br>        “<a href="https://docker.m.daocloud.io&quot;" target="_blank" rel="noopener">https://docker.m.daocloud.io&quot;</a>,<br>        “<a href="https://hub-mirror.c.163.com&quot;" target="_blank" rel="noopener">https://hub-mirror.c.163.com&quot;</a>,<br>        “<a href="https://mirror.baidubce.com&quot;" target="_blank" rel="noopener">https://mirror.baidubce.com&quot;</a>,<br>        “<a href="https://your_preferred_mirror&quot;" target="_blank" rel="noopener">https://your_preferred_mirror&quot;</a>,<br>        “<a href="https://dockerhub.icu&quot;" target="_blank" rel="noopener">https://dockerhub.icu&quot;</a>,<br>        “<a href="https://docker.registry.cyou&quot;" target="_blank" rel="noopener">https://docker.registry.cyou&quot;</a>,<br>        “<a href="https://docker-cf.registry.cyou&quot;" target="_blank" rel="noopener">https://docker-cf.registry.cyou&quot;</a>,<br>        “<a href="https://dockercf.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://dockercf.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://docker.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://docker.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://dockertest.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://dockertest.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://mirror.aliyuncs.com&quot;" target="_blank" rel="noopener">https://mirror.aliyuncs.com&quot;</a>,<br>        “<a href="https://dockerproxy.com&quot;" target="_blank" rel="noopener">https://dockerproxy.com&quot;</a>,<br>        “<a href="https://mirror.baidubce.com&quot;" target="_blank" rel="noopener">https://mirror.baidubce.com&quot;</a>,<br>        “<a href="https://docker.m.daocloud.io&quot;" target="_blank" rel="noopener">https://docker.m.daocloud.io&quot;</a>,<br>        “<a href="https://docker.nju.edu.cn&quot;" target="_blank" rel="noopener">https://docker.nju.edu.cn&quot;</a>,<br>        “<a href="https://docker.mirrors.sjtug.sjtu.edu.cn&quot;" target="_blank" rel="noopener">https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</a>,<br>        “<a href="https://docker.mirrors.ustc.edu.cn&quot;" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn&quot;</a>,<br>        “<a href="https://mirror.iscas.ac.cn&quot;" target="_blank" rel="noopener">https://mirror.iscas.ac.cn&quot;</a>,<br>        “<a href="https://docker.rainbond.cc&quot;" target="_blank" rel="noopener">https://docker.rainbond.cc&quot;</a><br>      ]<br>    }<br>  4.点击 Apply &amp; Restart，等待 Docker 重启生效。</p></blockquote><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<code>library</code>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure></p><p>抓取成功以后，就可以在本机看到这个 image 文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><p>现在，运行这个 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure></p><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br></pre></td></tr></table></figure></p><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></p><p>对于那些不会自动终止的容器，必须使用<code>docker container kill</code> 命令手动终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container kill [containID]</span><br></pre></td></tr></table></figure></p><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure></p><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure></p><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="实例（制作自己的-Docker-容器）"><a href="#实例（制作自己的-Docker-容器）" class="headerlink" title="实例（制作自己的 Docker 容器）"></a>实例（制作自己的 Docker 容器）</h2><p>下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先下载源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jinux7/koa-demos.git</span><br><span class="line">cd koa-demos</span><br></pre></td></tr></table></figure></p><h3 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></p><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></p><p>上面代码一共五行，含义如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</span><br><span class="line">COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app：指定接下来的工作路径为/app。</span><br><span class="line">RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span><br><span class="line">EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br></pre></td></tr></table></figure></p><h3 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t koa-demo .</span><br><span class="line"># 或者</span><br><span class="line">docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"># 或者</span><br><span class="line">docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面命令的各个参数含义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p参数：容器的 3000 端口映射到本机的 8000 端口。</span><br><span class="line">-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span><br><span class="line">koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</span><br><span class="line">/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span><br></pre></td></tr></table></figure></p><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app#</span><br></pre></td></tr></table></figure></p><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app# node demos/01.js</span><br></pre></td></tr></table></figure></p><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not" target="_blank" rel="noopener">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 demo 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在本机的另一个终端窗口，查出容器的 ID</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 停止指定的容器运行</span><br><span class="line">docker container kill [containerID]</span><br></pre></td></tr></table></figure></p><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查出容器的 ID</span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"># 删除指定的容器文件</span><br><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure></p><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></p><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></p><h3 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>注册一个账户。然后，用下面的命令登录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></p><p>接着，为本地的 image 标注用户名和版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"># 实例</span><br><span class="line">docker image tag koa-demos:0.0.1 jinux/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></p><p>也可以不标注用户名，重新构建一下 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></p><p>最后，发布 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></p><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><blockquote><p>这里的<code>imageName</code>是镜像名，<code>username/repository</code>是用户名下的仓库名，<code>tag</code>版本对用着<code>imageName</code>镜像，一般来说一个仓库下包含着一个镜像的不同版本。</p></blockquote><h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><h3 id="docker-container-start"><a href="#docker-container-start" class="headerlink" title="docker container start"></a>docker container start</h3><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start [containerID]</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-stop"><a href="#docker-container-stop" class="headerlink" title="docker container stop"></a>docker container stop</h3><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop [containerID]</span><br></pre></td></tr></table></figure></p><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><h3 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a>docker container logs</h3><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [containerID]</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-exec"><a href="#docker-container-exec" class="headerlink" title="docker container exec"></a>docker container exec</h3><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-cp"><a href="#docker-container-cp" class="headerlink" title="docker container cp"></a>docker container cp</h3><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker基础入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="docker" scheme="/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>element-plus全局设置组件默认属性</title>
    <link href="/2025/01/09/element-plus%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7/"/>
    <id>/2025/01/09/element-plus全局设置组件默认属性/</id>
    <published>2025-01-09T08:17:43.000Z</published>
    <updated>2025-01-09T08:30:49.193Z</updated>
    
    <content type="html"><![CDATA[<p>element-plus全局设置组件默认属性<br><a id="more"></a><br>以Dialog组件的close-on-click-modal属性为例，默认是true，通过点击modal可以关闭Dialog。<br>现在全局把它设置成false</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementPlus, &#123; ElDialog &#125; from &quot;element-plus&quot;;</span><br><span class="line">ElDialog.props.closeOnclickModal.default = false;</span><br><span class="line">const app = Vue.createApp(App);</span><br><span class="line">app.use(ElementPlus);</span><br></pre></td></tr></table></figure><p><code>ElDialog.props.closeOnclickModal.default = false;</code>这句来修改默认属性</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementPlus from &quot;element-plus&quot;;</span><br><span class="line">const app = Vue.createApp(App);</span><br><span class="line">app.use(ElementPlus);</span><br><span class="line">app._context.components.ElDialog[&apos;props&apos;].closeOnClickModal.default = false;</span><br></pre></td></tr></table></figure><p><code>app._context.components.ElDialog[&#39;props&#39;].closeOnClickModal.default = false;</code>这句来修改默认属性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上举例了ElDialog组件，其他组件也可以这样设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;element-plus全局设置组件默认属性&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nodejs通过usb库调用tspl协议控制标签打印机GODEX(G500-U)</title>
    <link href="/2024/11/12/nodejs%E9%80%9A%E8%BF%87usb%E5%BA%93%E8%B0%83%E7%94%A8tspl%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%E6%A0%87%E7%AD%BE%E6%89%93%E5%8D%B0%E6%9C%BAGODEX-G500-U/"/>
    <id>/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/</id>
    <published>2024-11-12T07:30:31.000Z</published>
    <updated>2024-11-13T08:20:37.181Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs通过usb库调用tspl协议控制标签打印机GODEX<br><a id="more"></a></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>首先要下载Zadig，下载地址<a href="https://zadig.akeo.ie/" target="_blank" rel="noopener">传送门</a>，他是一个usb通用驱动程序，因为GODEX官方驱动执行device.open会报错。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>接上打印机并开机，然后按照下图做，以达到驱动能被open的目的。<br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/1.png" alt="img"><br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/2.png" alt="img"><br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/3.png" alt="img"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>安装nodejs依赖，方法为<code>npm install usb</code></p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usb = <span class="built_in">require</span>(<span class="string">'usb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 你的设备的vendorId和productId</span></span><br><span class="line"><span class="comment"> * 这两个id可以通过Zadig工具获取，也可以通过usb.getDeviceList()方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> vendorId = <span class="number">0x195F</span>;</span><br><span class="line"><span class="keyword">const</span> productId = <span class="number">0x1</span>;</span><br><span class="line"><span class="comment">// 打印方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintLabel</span>(<span class="params">cmds</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> device = usb.findByIds(vendorId, productId)</span><br><span class="line">device.open()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = device.interfaces.length ; i &lt; len ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, len2 = device.interfaces[i].endpoints.length ; j &lt; len2 ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (device.interfaces[i].endpoints[j].direction == <span class="string">'out'</span>) &#123;</span><br><span class="line">device.interfaces[i].claim() <span class="comment">// 找到了要用的对象后，首先要声明所有权</span></span><br><span class="line"><span class="keyword">let</span> outEndpoint = device.interfaces[i].endpoints[j]</span><br><span class="line">outEndpoint.transferType = <span class="number">2</span> <span class="comment">// bulk 批量传输</span></span><br><span class="line">outEndpoint.transfer(cmds, (err) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line">device.close()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">device.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commands = <span class="string">`</span></span><br><span class="line"><span class="string">  ^Q30,3</span></span><br><span class="line"><span class="string">  ^W50</span></span><br><span class="line"><span class="string">  ^H5</span></span><br><span class="line"><span class="string">  ^P1</span></span><br><span class="line"><span class="string">  ^S2</span></span><br><span class="line"><span class="string">  ^AT</span></span><br><span class="line"><span class="string">  ^C1</span></span><br><span class="line"><span class="string">  ^R0</span></span><br><span class="line"><span class="string">  ~Q+0</span></span><br><span class="line"><span class="string">  ^O0</span></span><br><span class="line"><span class="string">  ^D0</span></span><br><span class="line"><span class="string">  ^E12</span></span><br><span class="line"><span class="string">  ~R200</span></span><br><span class="line"><span class="string">  ^XSET,ROTATION,0</span></span><br><span class="line"><span class="string">  ^L</span></span><br><span class="line"><span class="string">  Dy2-me-dd</span></span><br><span class="line"><span class="string">  Th:m:s</span></span><br><span class="line"><span class="string">  BQ,26,15,2,46,40,0,0,WS003</span></span><br><span class="line"><span class="string">  AE,25,130,1,1,0,0,WS00301002</span></span><br><span class="line"><span class="string">  AD,90,178,1,1,0,0,WS003</span></span><br><span class="line"><span class="string">  AB,310,114,1,1,0,0,1241</span></span><br><span class="line"><span class="string">  XRB26,65,4,0,10</span></span><br><span class="line"><span class="string">  WS00301002</span></span><br><span class="line"><span class="string">  XRB325,71,4,0,4</span></span><br><span class="line"><span class="string">  1241</span></span><br><span class="line"><span class="string">  E</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// 调用打印方法</span></span><br><span class="line">PrintLabel(commands)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs通过usb库调用tspl协议控制标签打印机GODEX&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="打印" scheme="/tags/%E6%89%93%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>Web移动端在线IDE(online-editor)</title>
    <link href="/2024/09/18/Web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9C%A8%E7%BA%BFIDE-online-editor/"/>
    <id>/2024/09/18/Web移动端在线IDE-online-editor/</id>
    <published>2024-09-18T07:36:51.000Z</published>
    <updated>2024-09-18T11:09:55.061Z</updated>
    
    <content type="html"><![CDATA[<p>web在线编辑器，适配移动端<br><a id="more"></a></p><blockquote><p>常用的在线编辑器有：<br><a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox</a><br><a href="https://codepen.io/" target="_blank" rel="noopener">codepen</a><br><a href="https://stackblitz.com/" target="_blank" rel="noopener">stackblitz</a><br><a href="https://playcode.io/" target="_blank" rel="noopener">playcode</a><br><a href="https://jsfiddle.net/" target="_blank" rel="noopener">jsfiddle</a></p></blockquote><h2 id="IDE组成"><a href="#IDE组成" class="headerlink" title="IDE组成"></a>IDE组成</h2><p>在线编辑器由编辑区，预览区，打印输出区三部分组成。<br>对应的组件分别是：<code>Editor</code>,<code>Preview</code>,<code>Console</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Layout.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;layout-wrap&quot;&gt;</span><br><span class="line">    &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">    &lt;div class=&quot;content-wrap&quot;&gt;</span><br><span class="line">      &lt;Editor&gt;&lt;/Editor&gt;</span><br><span class="line">      &lt;Preview&gt;&lt;/Preview&gt;</span><br><span class="line">      &lt;Console&gt;&lt;/Console&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><p>编辑区就是输入代码的地方，前端常用的代码编辑工具是<code>vsCode</code>，<code>vsCode</code>有一个在线库<code>monaco-editor</code>，这个库是微软专门为浏览器开发的一个在线<code>vsCode</code>，功能与在本地使用的<code>vsCode</code>基本一样，所以，在编辑功能这里使用这个工具库。<br><code>monaco-editor</code>的具体使用可以参考官网<a href="https://github.com/microsoft/monaco-editor" target="_blank" rel="noopener">monaco-editor</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// Editor.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;editor-wrap&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;$store.languageType===1&quot;&gt;</span><br><span class="line">      &lt;div ref=&quot;refHtml&quot; class=&quot;html-wrap&quot;&gt;html&lt;/div&gt;</span><br><span class="line">      &lt;div ref=&quot;refJs&quot; class=&quot;js-wrap&quot;&gt;js&lt;/div&gt;</span><br><span class="line">      &lt;div ref=&quot;refCss&quot; class=&quot;css-wrap&quot;&gt;css&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else ref=&quot;refVue&quot; class=&quot;vue-wrap&quot;&gt;vue&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; onMounted, ref, getCurrentInstance, watch, nextTick &#125; from &apos;vue&apos;;</span><br><span class="line">import * as monaco from &apos;monaco-editor/esm/vs/editor/editor.api&apos;</span><br><span class="line">import &#123; languageMap &#125; from &apos;@/config/constants&apos;</span><br><span class="line"></span><br><span class="line">const &#123; proxy &#125; = getCurrentInstance();</span><br><span class="line">const refHtml = ref(null);</span><br><span class="line">const refJs = ref(null);</span><br><span class="line">const refCss = ref(null);</span><br><span class="line">const refVue = ref(null);</span><br><span class="line">const editorArr = [];</span><br><span class="line">const createEditor = async (el, language) =&gt; &#123;</span><br><span class="line">  const editor = monaco.editor.create(el, &#123;</span><br><span class="line">    model: null,</span><br><span class="line">    minimap: &#123;</span><br><span class="line">      enabled: false // 关闭小地图</span><br><span class="line">    &#125;,</span><br><span class="line">    wordWrap: &apos;on&apos;, // 代码超出换行</span><br><span class="line">    theme: &apos;vs-dark&apos;, // 主题</span><br><span class="line">    fontSize: 14,</span><br><span class="line">    fontFamily: &apos;Microsoft YaHei&apos;,</span><br><span class="line">    contextmenu: false, // 不显示右键菜单</span><br><span class="line">    fixedOverflowWidgets: true, // 让语法提示层能溢出容器</span><br><span class="line">    readOnly: false</span><br><span class="line">  &#125;)</span><br><span class="line">  // 设置文档内容</span><br><span class="line">  updateDoc(editor, proxy.$store[languageMap[language]], language)</span><br><span class="line">  // 支持textMate语法解析</span><br><span class="line">  // wire(language, editor)</span><br><span class="line">  // 监听编辑事件</span><br><span class="line">  editor.onDidChangeModelContent(() =&gt; &#123;</span><br><span class="line">    // console.log(&apos;code-change&apos;, editor.getValue())</span><br><span class="line">    proxy.$store[languageMap[language]] = editor.getValue();</span><br><span class="line">  &#125;)</span><br><span class="line">  // 监听失焦事件</span><br><span class="line">  editor.onDidBlurEditorText(() =&gt; &#123;</span><br><span class="line">    // console.log(&apos;blur&apos;, editor.getValue())</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // editor添加入数组保存</span><br><span class="line">  editorArr.push(editor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新编辑器文档模型</span><br><span class="line">const updateDoc = (editor, code, language) =&gt; &#123;</span><br><span class="line">  language = language===&apos;vue&apos;?&apos;html&apos;:language;</span><br><span class="line">  let oldModel = editor.getModel();</span><br><span class="line">  let newModel = monaco.editor.createModel(code, language);</span><br><span class="line">  editor.setModel(newModel);</span><br><span class="line">  if (oldModel) &#123;</span><br><span class="line">    oldModel.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onMounted(()=&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">watch(()=&gt; proxy.$store.languageType, async ()=&gt; &#123;</span><br><span class="line">  if(proxy.$store.languageType===1) &#123;</span><br><span class="line">    await nextTick(()=&gt; &#123;</span><br><span class="line">      createEditor(refHtml.value, &apos;html&apos;);</span><br><span class="line">      createEditor(refJs.value, &apos;javascript&apos;);</span><br><span class="line">      createEditor(refCss.value, &apos;css&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;else if(proxy.$store.languageType===2) &#123;</span><br><span class="line">    await nextTick(()=&gt; &#123;</span><br><span class="line">      createEditor(refVue.value, &apos;vue&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; immediate: true &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.editor-wrap &#123;</span><br><span class="line">  .html-wrap, .js-wrap, .css-wrap, .vue-wrap &#123;</span><br><span class="line">    min-height: 30vh;</span><br><span class="line">    border: 1px solid #eeeeee;</span><br><span class="line">    margin: 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .vue-wrap &#123;</span><br><span class="line">    min-height: 50vh;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><p>预览区域应该与主页面隔绝，避免预览的代码污染主体页面。所以需要弄一个沙箱环境，这里选择最简单的<code>iframe</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Preview.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;preview-wrap&quot;&gt;</span><br><span class="line">    &lt;p&gt;预览&lt;/p&gt;</span><br><span class="line">    &lt;iframe v-if=&quot;$store.iframeShow&quot; :srcdoc=&quot;$store.docContent&quot; :key=&quot;$store.docContent&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.preview-wrap &#123;</span><br><span class="line">  height: 50vh;</span><br><span class="line">  border: 1px solid #eeeeee;</span><br><span class="line">  margin: 5px;</span><br><span class="line">  iframe &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    border: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><code>iframe</code>的<code>srcdoc</code>内容是点击<code>运行</code>按钮生成的，这段代码在<code>Header</code>组件内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Header.vue</span><br><span class="line">// vanilla代码生成</span><br><span class="line">const createHtml = (htmlStr=&apos;&apos;, jsStr=&apos;&apos;, cssStr=&apos;&apos;)=&gt; &#123;</span><br><span class="line">  if(proxy.$store.languageType===1) &#123;</span><br><span class="line">    let head = `</span><br><span class="line">      &lt;title&gt;预览&lt;\/title&gt;</span><br><span class="line">      &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">          $&#123;cssStr&#125;</span><br><span class="line">      &lt;\/style&gt;</span><br><span class="line">    `;</span><br><span class="line">    let jsContent = `</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        $&#123;jsStr&#125;</span><br><span class="line">      &lt;\/script&gt;</span><br><span class="line">    `;</span><br><span class="line">    let body = `</span><br><span class="line">      $&#123;htmlStr&#125;</span><br><span class="line">      $&#123;jsContent&#125;</span><br><span class="line">    `;</span><br><span class="line">    return `&lt;!DOCTYPE html&gt;</span><br><span class="line">      &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">          &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">          $&#123;head&#125;</span><br><span class="line">      &lt;\/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/console.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        $&#123;body&#125;</span><br><span class="line">      &lt;\/body&gt;</span><br><span class="line">      &lt;\/html&gt;</span><br><span class="line">    `;</span><br><span class="line">  &#125;else if(proxy.$store.languageType===2) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// vue代码生成</span><br><span class="line">const createVue = (sfcStr)=&gt; &#123;</span><br><span class="line">  return `&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot; \/&gt;</span><br><span class="line">        &lt;title&gt;预览&lt;\/title&gt;</span><br><span class="line">      &lt;\/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/vue.runtime.global.prod.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/vue3-sfc-loader.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/console.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">          /* &lt;!-- */</span><br><span class="line">          const config = &#123;</span><br><span class="line">            files: &#123;</span><br><span class="line">              &apos;\/main.vue&apos;: \`$&#123;sfcStr&#125;\`,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          /* --&gt; */</span><br><span class="line"></span><br><span class="line">          const options = &#123;</span><br><span class="line">            devMode: true,</span><br><span class="line">            moduleCache: &#123;</span><br><span class="line">              vue: Vue,</span><br><span class="line">            &#125;,</span><br><span class="line">            async getFile(url) &#123;</span><br><span class="line">              </span><br><span class="line">              if ( config.files[url] )</span><br><span class="line">                return config.files[url];</span><br><span class="line">              </span><br><span class="line">              const res = await fetch(url);</span><br><span class="line">              if ( !res.ok )</span><br><span class="line">                throw Object.assign(new Error(res.statusText + &apos; &apos; + url), &#123; res &#125;);</span><br><span class="line">              return &#123;</span><br><span class="line">                getContentData: asBinary =&gt; asBinary ? res.arrayBuffer() : res.text(),</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            addStyle(textContent) &#123;</span><br><span class="line"></span><br><span class="line">              const style = Object.assign(document.createElement(&apos;style&apos;), &#123; textContent &#125;);</span><br><span class="line">              const ref = document.head.getElementsByTagName(&apos;style&apos;)[0] || null;</span><br><span class="line">              document.head.insertBefore(style, ref);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            handleModule: async function (type, getContentData, path, options) &#123;</span><br><span class="line"></span><br><span class="line">              switch (type) &#123; </span><br><span class="line">                case &apos;.png&apos;:</span><br><span class="line">                  return getContentData(true);</span><br><span class="line">              &#125; </span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            log(type, ...args) &#123;</span><br><span class="line"></span><br><span class="line">              console[type](...args);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          const app = Vue.createApp(Vue.defineAsyncComponent(() =&gt; window[&apos;vue3-sfc-loader&apos;].loadModule(&apos;/main.vue&apos;, options)))</span><br><span class="line">          app.mount(document.body);</span><br><span class="line"></span><br><span class="line">        &lt;\/script&gt;</span><br><span class="line">      &lt;\/body&gt;</span><br><span class="line">    &lt;\/html&gt;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p>打印输出，首先要把预览<code>iframe</code>里的<code>console</code>的所有方法拦截，之后用<code>window.parent.postMessage</code>方法，把信息发送给主页面。当然，主页面也需要注册<code>message</code>事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">window.addEventListener(&apos;message&apos;, (ev) =&gt; &#123;</span><br><span class="line">  if(ev.data.type === &apos;console&apos;) &#123;</span><br><span class="line">    proxy.$store.consoleContent.push(ev.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>iframe</code>中的拦截<code>console</code>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// public/lib/console.js</span><br><span class="line">function ProxyConsole() &#123;&#125;;</span><br><span class="line">// 拦截console的所有方法</span><br><span class="line">[</span><br><span class="line">    &apos;debug&apos;,</span><br><span class="line">    &apos;clear&apos;,</span><br><span class="line">    &apos;error&apos;,</span><br><span class="line">    &apos;info&apos;,</span><br><span class="line">    &apos;log&apos;,</span><br><span class="line">    &apos;warn&apos;,</span><br><span class="line">    &apos;dir&apos;,</span><br><span class="line">    &apos;props&apos;,</span><br><span class="line">    &apos;group&apos;,</span><br><span class="line">    &apos;groupEnd&apos;,</span><br><span class="line">    &apos;dirxml&apos;,</span><br><span class="line">    &apos;table&apos;,</span><br><span class="line">    &apos;trace&apos;,</span><br><span class="line">    &apos;assert&apos;,</span><br><span class="line">    &apos;count&apos;,</span><br><span class="line">    &apos;markTimeline&apos;,</span><br><span class="line">    &apos;profile&apos;,</span><br><span class="line">    &apos;profileEnd&apos;,</span><br><span class="line">    &apos;time&apos;,</span><br><span class="line">    &apos;timeEnd&apos;,</span><br><span class="line">    &apos;timeStamp&apos;,</span><br><span class="line">    &apos;groupCollapsed&apos;</span><br><span class="line">].forEach((method) =&gt; &#123;</span><br><span class="line">    let originMethod = console[method]</span><br><span class="line">    // 设置原型方法</span><br><span class="line">    ProxyConsole.prototype[method] = function (...args) &#123;</span><br><span class="line">        // 发送信息给父窗口</span><br><span class="line">        window.parent.postMessage(&#123;</span><br><span class="line">            type: &apos;console&apos;,</span><br><span class="line">            method,</span><br><span class="line">            data: any2str(args)</span><br><span class="line">        &#125;)</span><br><span class="line">        // 调用原始方法</span><br><span class="line">        originMethod.apply(ProxyConsole, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 覆盖原console对象</span><br><span class="line">window.console = new ProxyConsole()</span><br><span class="line"></span><br><span class="line">// 处理console的参数转字符串</span><br><span class="line">const any2str = (arr)=&gt; &#123;</span><br><span class="line">  let str = &apos;&apos;;</span><br><span class="line">  arr.forEach(item=&gt; &#123;</span><br><span class="line">    str += change2str(item) + &apos; &apos;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const type = arg=&gt; &#123;</span><br><span class="line">  return Object.prototype.toString.call(arg).slice(7, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const change2str = content=&gt; &#123;</span><br><span class="line">  let contentType = type(content)</span><br><span class="line">  switch (contentType) &#123;</span><br><span class="line">    case &apos;boolean&apos;: // 布尔值</span><br><span class="line">      content = content ? &apos;true&apos; : &apos;false&apos;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;null&apos;: // null</span><br><span class="line">      content = &apos;null&apos;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;undefined&apos;: // undefined</span><br><span class="line">      content = &apos;undefined&apos;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;symbol&apos;: // Symbol，Symbol不能直接通过postMessage进行传递，会报错，需要转成字符串</span><br><span class="line">      content = content.toString()</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return content;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>界面截图：<br><img src="/2024/09/18/Web移动端在线IDE-online-editor/1.png" alt="img"></p><p>本实例使用<code>vue3+webpack</code>开发，<code>monaco-editor</code>在<code>vite</code>中的兼容性不是很好，所以选择<code>webpack</code>。<br><a href="https://github.com/jinux7/study-collections/tree/master/onlineEditor" target="_blank" rel="noopener">本实例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web在线编辑器，适配移动端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript教程(二)</title>
    <link href="/2024/08/01/TypeScript%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
    <id>/2024/08/01/TypeScript教程-二/</id>
    <published>2024-08-01T06:37:21.000Z</published>
    <updated>2024-08-02T02:52:25.948Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript进阶教程<br><a id="more"></a></p><h1 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type-Challenges"></a>Type-Challenges</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学习完<code>TypeScript</code>一些基础知识后，已经可以熟练使用一些基本类型定义了，但对于<code>TypeScript</code>的高级用法却依旧无法入门，为了更有趣的学习<code>TypeScript</code>高级用法，选择<a href="https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md" target="_blank" rel="noopener">Type-Challenges</a>类型挑战来作为我们学习的目标。</p><p>在<code>Type-Challenges</code>中，可以从简单(<code>easy</code>)、中等(<code>medium</code>)、困难(<code>hard</code>)以及地狱(<code>extreme</code>)难度，循序渐进的学习<code>TypeScript</code>高级技巧。</p><p>如果你需要选择其它的方向来深入学习<code>TypeScript</code>高级技巧，这里也有一些推荐的开源项目：</p><ul><li>官方内置：在<code>lib.es5.d.ts</code>文件中，<code>TypeScript</code>官方默认内置了一些辅助工具函数，例如：<code>Partial</code>、<code>Required</code>、<code>Pick</code>以及<code>Record</code>等等。</li><li>其它开源库：<a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="noopener">utility-types</a>、<a href="https://github.com/millsp/ts-toolbelt" target="_blank" rel="noopener">ts-toolbelt</a>、<a href="https://github.com/andnp/SimplyTyped" target="_blank" rel="noopener">SimplyTyped</a></li></ul><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="加号和减号"><a href="#加号和减号" class="headerlink" title="加号和减号"></a>加号和减号</h3><blockquote><p>tip<br>加号和减号的用法类似。</p></blockquote><p>在一些内置工具中，可能会出现<code>+</code>或者<code>-</code>这些符号，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Required&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><p>观察以上结果可以得出结论：<code>-?</code>是去掉类型中属性后面的<code>?</code>，整个<code>Required</code>的实际效果是去掉<code>T</code>类型中所有属性键后面的<code>?</code>，让所有属性变成必填的。</p><h3 id="keyof-和-in"><a href="#keyof-和-in" class="headerlink" title="keyof 和 in"></a>keyof 和 in</h3><p><code>keyof</code>和<code>in</code>经常会连在一起使用，当它们连在一起使用时，通常表示一个迭代的过程。</p><h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>在<code>TS</code>中，<code>keyof T</code>这段代码表示获取<code>T</code>类型中所有属性键，这些属性键组合成一个联合类型，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = keyof Person</span><br></pre></td></tr></table></figure></p><p><code>TS</code>中的<code>keyof T</code>，它有点类似<code>JavaScript</code>中的<code>Object.keys()</code>，它们的共同点都是获取属性键的集合，只不过<code>keyof T</code>得到的结果是一个联合类型，而<code>Object.keys()</code>得到的是一个数组。</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p><code>in</code>操作符的右侧通常跟一个联合类型，可以使用<code>in</code>来迭代这个联合类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅演示使用, K为每次迭代的项</span></span><br><span class="line">K <span class="keyword">in</span> <span class="string">'name'</span> | <span class="string">'age'</span> | <span class="string">'sex'</span></span><br><span class="line">K = <span class="string">'name'</span> <span class="comment">// 第一次迭代结果</span></span><br><span class="line">K = <span class="string">'age'</span>  <span class="comment">// 第二次迭代结果</span></span><br><span class="line">K = <span class="string">'sex'</span>  <span class="comment">// 第三次迭代结果</span></span><br></pre></td></tr></table></figure></p><p>根据<code>keyof</code>和<code>in</code>的特点，我们可以撰写一些辅助工具，这里以<code>Readonly</code>为例。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; readony name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Readonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>[P in keyof T]</code>：这段代码表示遍历<code>T</code>中的每一个属性键，每次遍历时属性键取名为<code>P</code>，这和<code>JavaScript</code>中的<code>for in</code>非常类似：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的迭代</span></span><br><span class="line">P <span class="keyword">in</span> keyof T</span><br><span class="line"></span><br><span class="line"><span class="comment">// js中的迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure></li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>TS</code>中的<code>typeof</code>，可以用来获取一个<code>JavaScript</code>变量的类型，经常用于获取一个普通对象或者一个函数的类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'AAA'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：(a: number, b:number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> t1  = <span class="keyword">typeof</span> add</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> obj</span><br></pre></td></tr></table></figure></p><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>类型表示永远不会有值的一种类型。</p><p>例如，如果一个函数抛出一个错误，那么这个函数就可以用<code>never</code>或者<code>void</code>来表示其返回值，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never更适合用来表示永远没有返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void适合用来表示返回值为空的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>never</code>的另外一个知识点是：如果一个联合类型中存在<code>never</code>，那么实际的联合类型并不会包含<code>never</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span> | never</span><br><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span></span><br></pre></td></tr></table></figure></p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><code>extends</code>关键词，一般有两种用法：<strong>类型约束</strong>和<strong>条件类型</strong>。</p><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>类型约束经常和泛型一起使用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型约束</span></span><br><span class="line">U <span class="keyword">extends</span> keyof T</span><br></pre></td></tr></table></figure></p><p><code>keyof T</code>是一个整体，它表示一个联合类型。<code>U extends Union</code>这一整段表示<code>U</code>的类型被收缩在一个联合类型的范围内。例如： <code>U extends &#39;name&#39; | &#39;age&#39;</code>，则表示<code>U</code>只能为<code>name</code>或者<code>age</code>二者其中之一。</p><h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>常见的条件类型表现形式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? <span class="string">'Y'</span> : <span class="string">'N'</span></span><br></pre></td></tr></table></figure></p><p>我们发现条件类型有点像<code>JavaScript</code>中的三元表达式，事实上它们的工作原理是类似的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = <span class="literal">true</span> <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="literal">true</span> : <span class="literal">false</span>                    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span> | <span class="string">'age'</span> ? <span class="literal">true</span> : <span class="literal">false</span>           <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? <span class="literal">true</span> : <span class="literal">false</span>   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; ? <span class="literal">true</span> : <span class="literal">false</span>         <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>在条件类型中，有一个特别需要注意的东西就是：<strong>分布式条件类型</strong>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置工具：交集</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br><span class="line"><span class="keyword">type</span> type1 = <span class="string">'name'</span>|<span class="string">'age'</span></span><br><span class="line"><span class="keyword">type</span> type2 = <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集结果：'name'</span></span><br><span class="line"><span class="keyword">type</span> result = Extract&lt;type1, type2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推理步骤</span></span><br><span class="line"><span class="string">'name'</span>|<span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">step1： (<span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never) =&gt; <span class="string">'name'</span></span><br><span class="line">step2:  <span class="function">(<span class="params">'age' <span class="keyword">extends</span> 'name'|'address'|'sex' ? 'age' : never</span>)   =&gt;</span> never</span><br><span class="line">result: <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><p><code>T extends U ? T : never</code>：因为<code>T</code>是一个联合类型，所以这里适用于<strong>分布式条件类型</strong>的概念。根据其概念，在实际的过程中会把<code>T</code>类型中的每一个子类型进行迭代，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代：</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never</span><br><span class="line"><span class="comment">// 第二次迭代：</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure></li><li><p>在迭代完成之后，会把每次迭代的结果组合成一个新的联合类型(根据<code>never</code>类型的特点，最后的结果会剔除掉<code>never</code>)，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p><code>infer</code>关键词的作用是延时推导，它会在类型未推导时进行占位，等到真正推导成功后，它能准确的返回正确的类型。</p><p>为了更好的理解<code>infer</code>关键词的用法，我们使用<code>ReturnType</code>这个例子来说明，<code>ReturnType</code>是一个用来获取函数返回类型的工具。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: number</span></span><br><span class="line"><span class="keyword">type</span> result = ReturnType&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends (...args: any) =&gt; infer R</code>：如果不看<code>infer R</code>，这段代码实际表示：<code>T</code>是不是一个函数类型。</li><li><code>(...args: any) =&gt; infer R</code>：这段代码实际表示一个函数类型，其中把它的参数使用<code>args</code>来表示，把它的返回类型用<code>R</code>来进行占位。<br>如果<code>T</code>满足是一个函数类型，那么我们返回其函数的返回类型，也就是<code>R</code>；如果不是一个函数类型，就返回<code>never</code>。</li></ul><p><code>TS</code>中的<code>infer</code>占位更像<code>JavaScript</code>中的模板字符串：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的返回类型使用R占位表示</span></span><br><span class="line">(...args: <span class="built_in">any</span>) =&gt; info R</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串中的值，使用变量name占位表示</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><h3 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp; 符号"></a>&amp; 符号</h3><p>在<code>TS</code>中有两种类型值得我们重点关注：<strong>联合类型</strong>和<strong>交叉类型</strong>。</p><p>联合类型一般适用于基本类型的<strong>合并</strong>，它使用<code>|</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="number">1</span> | <span class="literal">true</span> | <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>而交叉类型则适用于对象或者函数的<strong>合并</strong>，它使用<code>&amp;</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = T &amp; U</span><br></pre></td></tr></table></figure></p><p><code>T &amp; U</code>表示一个新的类型，其中这个类型包含<code>T</code>和<code>U</code>中所有的键，这和<code>JavaScript</code>中的<code>Object.assign()</code>函数的作用非常类似。</p><p>根据交叉类型的概念，我们可以封装一个合并对象的<code>merge</code>函数，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.8.4以上版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> unknown <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> unknown <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts v4.8.4以下版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; name: <span class="string">'AAA'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; age: <span class="number">23</span> &#125;</span><br><span class="line"><span class="comment">// js结果：&#123; name：'AAA'; age: 23; &#125;</span></span><br><span class="line"><span class="comment">// ts结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">const</span> result = merge(obj1, obj2)</span><br></pre></td></tr></table></figure></p><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="内置Pick-选取"><a href="#内置Pick-选取" class="headerlink" title="内置Pick(选取)"></a>内置Pick(选取)</h3><p><link-and-solution num="4"></link-and-solution></p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>Pick</code>表示从一个类型中选取指定的几个字段组合成一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: &#123; name: string; address: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PickResult = Pick&lt;Person, <span class="string">'name'</span> | <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof T</code>：表示<code>K</code>只能是<code>keyof T</code>的子类型，如果我们在使用<code>Pick</code>的时候传递了不存在于<code>T</code>的字段，会报错：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：phone无法分配给keyof T</span></span><br><span class="line"><span class="keyword">type</span> result = MyPick&lt;Person, <span class="string">'name'</span> | <span class="string">'phone'</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Readonly-只读"><a href="#内置Readonly-只读" class="headerlink" title="内置Readonly(只读)"></a>内置Readonly(只读)</h3><p><link-and-solution num="7"></link-and-solution></p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p><code>Readonly</code>是用来让所有属性变为只读，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; readonly name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MyReadonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TupleToObject-元组转对象"><a href="#TupleToObject-元组转对象" class="headerlink" title="TupleToObject(元组转对象)"></a>TupleToObject(元组转对象)</h3><p><link-and-solution num="11"></link-and-solution></p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToObject&lt;T&gt;</code>是用来把一个元组转换成一个<code>key/value</code>相同的对象，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：readonly ['msg', 'name']</span></span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="string">'msg'</span>, <span class="string">'name'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 结果：&#123; msg: 'msg'; name: 'name'; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToObject&lt;<span class="keyword">typeof</span> tuple&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>as const</code>：常用来进行常量断言，在此处表示将<code>[&#39;msg&#39;,&#39;name&#39;]</code>推导常量元组，表示其不能新增、删除、修改元素，可以使用<code>as readonly</code>来辅助理解。</li><li><code>T[number]</code>：表示返回数组中所有数字型索引的元素，形成一个联合类型，例如：<code>&#39;msg&#39;|&#39;name&#39;</code>。</li></ul><h3 id="First-数组第一个元素"><a href="#First-数组第一个元素" class="headerlink" title="First(数组第一个元素)"></a>First(数组第一个元素)</h3><p><link-and-solution num="14"></link-and-solution></p><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>First&lt;T&gt;</code>用来返回数组的第一个元素，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = First&lt;[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result2 = First&lt;[]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? never : T[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 占位实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer R, ...infer L] ? R : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends []</code>：用来判断<code>T</code>是否是一个空数组。</li><li><code>T[0]</code>：根据下标取数组第一个元素。</li><li><code>infer R</code>： 表示数组第一个元素的占位。</li><li><code>...infer L</code>: 表示数组剩余元素的占位。</li></ul><h3 id="Length-元组的长度"><a href="#Length-元组的长度" class="headerlink" title="Length(元组的长度)"></a>Length(元组的长度)</h3><p><link-and-solution num="18"></link-and-solution></p><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>Length&lt;T&gt;</code>用来获取一个数组(包括类数组)的长度，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = Length&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：10</span></span><br><span class="line"><span class="keyword">type</span> result2 = Length&lt;&#123; <span class="number">5</span>: <span class="string">'5'</span>, length: <span class="number">10</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? T[<span class="string">'length'</span>] : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends { length: number; }</code>：判断<code>T</code>是否是<code>{ length: number; }</code>的子类型，如果是则代表<code>T</code>为数组或者类数组。</li><li><code>T[&#39;length&#39;]</code>：取<code>T</code>对象的<code>length</code>属性的值(注意，在<code>TypeScript</code>中不能使用<code>T.length</code>来取值，而应该使用<code>T[&#39;length&#39;]</code>)。</li></ul><h3 id="内置Exclude-排除"><a href="#内置Exclude-排除" class="headerlink" title="内置Exclude(排除)"></a>内置Exclude(排除)</h3><p><link-and-solution num="43"></link-and-solution></p><h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><p><code>Exclude</code>是排除的意思，它从<code>T</code>类型中排除属于<code>U</code>类型的子集，可以理解成取<code>T</code>对于<code>U</code>的差集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> ExcludeResult = Exclude&lt;<span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span>, <span class="string">'sex'</span>|<span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br></pre></td></tr></table></figure><ul><li><code>T extends U</code>：这段代码会从<code>T</code>的子类型开始分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U </span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span></span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'name'</span> |</span><br><span class="line">  <span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'age'</span> |</span><br><span class="line">  <span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'sex'</span></span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="PromiseType-promise包裹类型"><a href="#PromiseType-promise包裹类型" class="headerlink" title="PromiseType(promise包裹类型)"></a>PromiseType(promise包裹类型)</h3><p><link-and-solution num="189"></link-and-solution></p><h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseType</code>是用来获取<code>Promise</code>包裹类型的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span> (<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>|<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：(） =&gt; Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> getInfo</span><br><span class="line"><span class="comment">// 结果：Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> returnResult = ReturnType&lt;funcType&gt;</span><br><span class="line"><span class="comment">// 结果：string|number</span></span><br><span class="line"><span class="keyword">type</span> PromiseResult = PromiseType&lt;returnResult&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PromiseType&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer R&gt;</span><br><span class="line">    ? R <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">      ? PromiseType&lt;R&gt;</span><br><span class="line">      : R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends Promise&lt;infer R&gt;</code>：判断<code>T</code>是否是<code>Promise&lt;infer R&gt;</code>的子类型，也就是说<code>T</code>必须满足<code>Promise&lt;any&gt;</code>的形式。</li></ul><h3 id="If-判断"><a href="#If-判断" class="headerlink" title="If(判断)"></a>If(判断)</h3><p><link-and-solution num="268"></link-and-solution></p><h4 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h4><p><code>If&lt;C, T, F&gt;</code>用来表示根据<code>C</code>的值来返回<code>T</code>或者<code>F</code>，如果<code>C</code>为<code>true</code>，则返回<code>T</code>；如果<code>C</code>为<code>false</code>，则返回<code>F</code>，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a'</span></span><br><span class="line"><span class="keyword">type</span> result1 = If&lt;<span class="literal">true</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'b'</span></span><br><span class="line"><span class="keyword">type</span> result2 = If&lt;<span class="literal">false</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>根据上案例，我们可以直观的发现<code>If&lt;C, T, F&gt;</code>的作用有点类似<code>JavaScript</code>中的三元表达式：<code>C ? T : F</code>。</p><h4 id="实现方式-7"><a href="#实现方式-7" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> If&lt;C <span class="keyword">extends</span> <span class="built_in">boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>C extends boolean</code>：表示<code>C</code>为<code>boolean</code>类型的子类型，既<code>C</code>只能为<code>true</code>或者<code>false</code>，传递其它值报错。</li><li><code>C extends true</code>：如果用<code>JavaScript</code>来表示的话，相当于<code>C===true</code>.</li></ul><h3 id="Concat-数组concat方法"><a href="#Concat-数组concat方法" class="headerlink" title="Concat(数组concat方法)"></a>Concat(数组concat方法)</h3><p><link-and-solution num="533"></link-and-solution></p><h4 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h4><p><code>Concat&lt;T, U&gt;</code>用来将两个数组合并起来，类似实现数组的<code>concat</code>方法，使用方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Concat&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-8"><a href="#实现方式-8" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...U]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends any[]</code>：用来限制<code>T</code>是一个数组，如果传递非数组会报错，<code>U</code>也是一样的道理。</li><li><code>[...T, ...U]</code>：可以理解成<code>JavaScript</code>的扩展运算符<code>...</code>。</li></ul><h3 id="Includes-数组includes方法"><a href="#Includes-数组includes方法" class="headerlink" title="Includes(数组includes方法)"></a>Includes(数组includes方法)</h3><p><link-and-solution num="898"></link-and-solution></p><h4 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h4><p><code>Includes&lt;T, U&gt;</code>用来判断<code>U</code>是否在数组<code>T</code>中，类似实现数组的<code>includes</code>方法，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'1'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-9"><a href="#实现方式-9" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = U <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 完善版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> [infer R, ...infer L]</span><br><span class="line">    ? Equal&lt;R, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : MyIncludes&lt;L, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[number]</code>：它返回数组中所有数字类型键对应的值，将这些值构造成一个联合类型，例如：<code>1 | 2 | 3</code>。</li><li><code>U extends T[number]</code>：判断<code>U</code>是否是某个联合类型的子类型，例如：<code>1 extends 1 | 2 | 3</code>。</li><li><code>Equal</code>：是用来判断两个值是否相等的辅助方法。</li></ul><h3 id="Push-数组push方法"><a href="#Push-数组push方法" class="headerlink" title="Push(数组push方法)"></a>Push(数组push方法)</h3><p><link-and-solution num="3057"></link-and-solution></p><h4 id="用法-10"><a href="#用法-10" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Push&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-10"><a href="#实现方式-10" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push实现</span></span><br><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [...T, K]</span><br></pre></td></tr></table></figure><h3 id="Unshift-数组unshift方法"><a href="#Unshift-数组unshift方法" class="headerlink" title="Unshift(数组unshift方法)"></a>Unshift(数组unshift方法)</h3><p><link-and-solution num="3060"></link-and-solution></p><p>与<code>pop</code>和<code>push</code>方法相似的另外一对方法叫<code>shift</code>和<code>unshift</code>，它们的实现思路是一样的。</p><h4 id="用法-11"><a href="#用法-11" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[0, 1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unshift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-11"><a href="#实现方式-11" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unshift实现</span></span><br><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [K, ...T]</span><br></pre></td></tr></table></figure><h3 id="内置Parameters-函数的参数类型"><a href="#内置Parameters-函数的参数类型" class="headerlink" title="内置Parameters(函数的参数类型)"></a>内置Parameters(函数的参数类型)</h3><p><link-and-solution num="3312"></link-and-solution></p><h4 id="用法-12"><a href="#用法-12" class="headerlink" title="用法"></a>用法</h4><p><code>Parameters</code>是用来获取一个函数的参数类型的，其中获取的结果是一个元组，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// [number, string]</span></span><br><span class="line"><span class="keyword">type</span> result = MyParameters&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-12"><a href="#实现方式-12" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyParameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span> ? R : never</span><br></pre></td></tr></table></figure><h3 id="内置Partial-可填-和内置Required-必填"><a href="#内置Partial-可填-和内置Required-必填" class="headerlink" title="内置Partial(可填)和内置Required(必填)"></a>内置Partial(可填)和内置Required(必填)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-13"><a href="#用法-13" class="headerlink" title="用法"></a>用法</h4><p><code>Partial</code>和<code>Required</code>一个是让所有属性可填、另外一个是让所有属性必填，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name?: string; age?: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PartialResult = MyPartial&lt;Person&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> RequiredResult = MyRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-13"><a href="#实现方式-13" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPartial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置Record-构造"><a href="#内置Record-构造" class="headerlink" title="内置Record(构造)"></a>内置Record(构造)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-14"><a href="#用法-14" class="headerlink" title="用法"></a>用法</h4><p><code>Record&lt;K, T&gt;</code>用来将<code>K</code>的每一个键(<code>k</code>)指定为<code>T</code>类型，这样由多个<code>k/T</code>组合成了一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keys = <span class="string">'Cat'</span>|<span class="string">'Dot'</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  Cat: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  Dog: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> RecordResult = Record&lt;keys, Animal&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-14"><a href="#实现方式-14" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRecord&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof any</code>：此代码表示<code>K</code>是<code>keyof any</code>任意类型其所有键的子类型，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K为 'Dog'|'cat'</span></span><br><span class="line"><span class="keyword">type</span> UnionKeys = <span class="string">'Dog'</span> | <span class="string">'Cat'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K为'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TypeKeys = keyof Person</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Extract-交集"><a href="#内置Extract-交集" class="headerlink" title="内置Extract(交集)"></a>内置Extract(交集)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-15"><a href="#用法-15" class="headerlink" title="用法"></a>用法</h4><p><code>Extract&lt;T, U&gt;</code>用来取联合类型<code>T</code>和<code>U</code>的交集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'age'|'address'</span></span><br><span class="line"><span class="keyword">type</span> ExtractResult = Extract&lt;keyof Person, <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-15"><a href="#实现方式-15" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExtract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends U</code>：此代码会自动将<code>T</code>的子类型进行分发，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T extends U</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never |</span><br><span class="line">  <span class="string">'age'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never |</span><br><span class="line">  <span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'address'</span> ? <span class="string">'age'</span> : never</span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'age'</span>|<span class="string">'address'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="内置ReturnType-函数返回类型"><a href="#内置ReturnType-函数返回类型" class="headerlink" title="内置ReturnType(函数返回类型)"></a>内置ReturnType(函数返回类型)</h3><p><link-and-solution num="2"></link-and-solution></p><h4 id="用法-16"><a href="#用法-16" class="headerlink" title="用法"></a>用法</h4><p><code>ReturnType&lt;T&gt;</code>是用来获取一个函数的返回类型的，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span> (<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：number</span></span><br><span class="line">type result = ReturnType&lt;<span class="keyword">typeof</span> getRandom&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-16"><a href="#实现方式-16" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends (...args: any) =&gt; infer R</code>：判断<code>T</code>类型是否是一个函数的子类型，既<code>T</code>是不是一个函数。</li><li><code>infer R</code>：表示待推导的函数返回类型为<code>R</code>，后续可以在表达式中使用<code>R</code>来代替真正的返回类型。</li></ul><h3 id="内置Omit-移除"><a href="#内置Omit-移除" class="headerlink" title="内置Omit(移除)"></a>内置Omit(移除)</h3><p><link-and-solution num="3"></link-and-solution></p><h4 id="用法-17"><a href="#用法-17" class="headerlink" title="用法"></a>用法</h4><p><code>Omit</code>是移除的意思，它用来在<code>T</code>类型中移除指定的字段，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name？: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> OmitResult = Omit&lt;Person, <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-17"><a href="#实现方式-17" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Omit</code>可以借助在上面已经实现过的<code>Pick</code>和<code>Exclude</code>配合来实现，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Omit实现</span></span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K&gt; = MyPick&lt;T, MyExclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li>使用<code>MyExclude&lt;keyof T, K&gt;</code>，可以从<code>T</code>中移除指定的字段，移除后得到一个新的联合类型：<code>&#39;name&#39;|&#39;age&#39;</code></li><li>使用<code>MyPick&lt;T, &#39;name&#39;|&#39;age&#39;&gt;</code>，可以从<code>T</code>中选取这两个字段，组合成一个新的类型。</li></ul><h3 id="Readonly-按需Readonly"><a href="#Readonly-按需Readonly" class="headerlink" title="Readonly(按需Readonly)"></a>Readonly(按需Readonly)</h3><p><link-and-solution num="8"></link-and-solution></p><h4 id="用法-18"><a href="#用法-18" class="headerlink" title="用法"></a>用法</h4><p>不同于初级实现中的<code>Readonly</code>，在中级实现的<code>Readonly</code>中，如果我们传递了指定的字段，那么<code>Readonly</code>会表现为按需实现<code>readonly</code>，用法如下。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected1 &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected2 &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult1 = Readonly&lt;Todo&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult2 = Readonly&lt;Todo, <span class="string">'desc'</span>|<span class="string">'completed'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line"><span class="keyword">const</span> obj: ReadonlyResult2 = &#123;</span><br><span class="line">  title: <span class="string">'AAA'</span>,</span><br><span class="line">  desc: <span class="string">'23'</span>,</span><br><span class="line">  completed: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">obj.title = <span class="string">'aaa'</span></span><br><span class="line">obj.desc = <span class="string">'32'</span> <span class="comment">// error</span></span><br><span class="line">obj.completed = <span class="literal">false</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-18"><a href="#实现方式-18" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.4+版本可直接用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = T &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts v4.5+版本必须用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof T = keyof T</code>：如要传递了<code>K</code>，那么只能是<code>T</code>中已经存在的属性，不存在则报错；如果不传递，则默认值为<code>keyof T</code>，意味着全部属性都添加<code>readonly</code>。</li><li><code>T &amp; U</code>：在本例中表示将<code>T</code>和<code>U</code>中的字段结合起来，如果没有<code>&amp;</code>会丢失一些属性，例如<code>title</code>。</li></ul><h3 id="DeepReadonly-深度Readonly"><a href="#DeepReadonly-深度Readonly" class="headerlink" title="DeepReadonly(深度Readonly)"></a>DeepReadonly(深度Readonly)</h3><p><link-and-solution num="9"></link-and-solution></p><h4 id="用法-19"><a href="#用法-19" class="headerlink" title="用法"></a>用法</h4><p><code>DeepReadonly</code>用来将一个嵌套对象类型中所有字段全部添加<code>readonly</code>关键词，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：</span></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">  b: <span class="built_in">string</span></span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="built_in">boolean</span></span><br><span class="line">    e: <span class="literal">undefined</span>,</span><br><span class="line">    f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> Y = &#123;</span><br><span class="line">  readonly b: <span class="built_in">string</span></span><br><span class="line">  readonly c: &#123;</span><br><span class="line">    readonly d: <span class="built_in">boolean</span></span><br><span class="line">    readonly e: <span class="literal">undefined</span>,</span><br><span class="line">    readonly f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-19"><a href="#实现方式-19" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; ? DeepReadonly&lt;T[P]&gt; : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[P] extends { [key: string]: any }</code>：这段表示<code>T[P]</code>是否是一个包含索引签名的字段，如果包含我们认为它是一个嵌套对象，就可以递归调用<code>DeepReadonly</code>。</li></ul><h3 id="TupleToUnion-元组转联合类型"><a href="#TupleToUnion-元组转联合类型" class="headerlink" title="TupleToUnion(元组转联合类型)"></a>TupleToUnion(元组转联合类型)</h3><p><link-and-solution num="10"></link-and-solution></p><h4 id="用法-20"><a href="#用法-20" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToUnion</code>是用来将一个元组转换成联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'1' | '2' | '3'</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToUnion&lt;[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-20"><a href="#实现方式-20" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: T[number]</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>]</span><br><span class="line"><span class="comment">// way2: 递归</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">    ? R | TupleToUnion&lt;args&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[number]</code>：它会自动迭代元组的数字型索引，然后将所有元素组合成一个联合类型。</li><li><code>R | TupleToUnion&lt;args&gt;</code>：<code>R</code>表示每一次迭代中的第一个元素，它的迭代过程可以用下面伪代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'3'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">''</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | <span class="string">'3'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Chainable-可串联构造器"><a href="#Chainable-可串联构造器" class="headerlink" title="Chainable(可串联构造器)"></a>Chainable(可串联构造器)</h3><p><link-and-solution num="12"></link-and-solution></p><h4 id="用法-21"><a href="#用法-21" class="headerlink" title="用法"></a>用法</h4><p><code>Chainable</code>是用来让一个对象可以进行链式调用的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  foo: <span class="built_in">number</span></span><br><span class="line">  bar: &#123;</span><br><span class="line">    value: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> obj: Chainable&lt;&#123;&#125;&gt;</span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">const</span> result = obj</span><br><span class="line">  .options(<span class="string">'foo'</span>, <span class="number">123</span>)</span><br><span class="line">  .options(<span class="string">'bar'</span>, &#123; value: <span class="string">'Hello'</span> &#125;)</span><br><span class="line">  .options(<span class="string">'name'</span>, <span class="string">'TypeScript'</span>)</span><br><span class="line">  .get()</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-21"><a href="#实现方式-21" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chainable&lt;T&gt; = &#123;</span><br><span class="line">  options&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, V&gt;(key: K, value: V): Chainable&lt;T &amp; &#123;[k <span class="keyword">in</span> K]: V&#125;&gt;</span><br><span class="line">  <span class="keyword">get</span>(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>{[k in K]: V}</code>：每次调用<code>options</code>时，把<code>key/value</code>构造成一个对象，例如：<code>{ foo: 123 }</code>。</li><li><code>T &amp; U</code>：此处使用到<code>&amp;</code>关键词，用来合并<code>T</code>和<code>U</code>两个对象中的所有<code>key</code>。</li><li><code>Chainable&lt;&gt;</code>：递归调用<code>Chainable</code>，赋予新对象以链式调用的能力。</li></ul><h3 id="Last-数组最后一个元素"><a href="#Last-数组最后一个元素" class="headerlink" title="Last(数组最后一个元素)"></a>Last(数组最后一个元素)</h3><p><link-and-solution num="15"></link-and-solution></p><h4 id="用法-22"><a href="#用法-22" class="headerlink" title="用法"></a>用法</h4><p><code>Last</code>是用来获取数组中最后一个元素的，它和我们之前已经实现的<code>First</code>思路很相似。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = Last&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-22"><a href="#实现方式-22" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Last</code>的实现方式很巧妙，因为它既可以在索引上做文章来实现，也可以用占位的思想来实现。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1：索引思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [<span class="built_in">any</span>, ...T][T[<span class="string">'length'</span>]]</span><br><span class="line"><span class="comment">// way2: 后占位思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer R, infer L] ? L : never</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><p><code>[any, ...T]</code>：此代码表示我们构建了一个新数组，并添加了一个新元素到第一个位置，然后把原数组<code>T</code>中的元素依次扩展到新数组中，可以用以下伪代码表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 新数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="built_in">any</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 结果: 3</span></span><br><span class="line"><span class="keyword">const</span> result = arr[T[<span class="string">'length'</span>]]</span><br></pre></td></tr></table></figure></li><li><p><code>T[&#39;length&#39;]</code>：这里我们获取到的是原始<code>T</code>数组的长度，例如<code>[1, 2, 3]</code>，长度值为<code>3</code>。而在新数组中，索引为<code>3</code>的位置正好是最后一个元素的索引，通过这种方式就能达到我们的目的。</p></li><li><code>T extends [...infer R, infer L]</code>：这段代码表示，我们将原数组中最后一个元素使用<code>L</code>进行占位，而其它元素我们用一个<code>R</code>数组表示。这样，如果数组满足这种格式，就能正确返回最后一个元素的值。</li></ul><h3 id="Pop-数组Pop方法"><a href="#Pop-数组Pop方法" class="headerlink" title="Pop(数组Pop方法)"></a>Pop(数组Pop方法)</h3><p><link-and-solution num="16"></link-and-solution></p><p>继续沿用以上处理索引思想或占位的思想，我们能快速实现数组<code>pop</code>方法。</p><h4 id="用法-23"><a href="#用法-23" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Pop&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2：[]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Pop&lt;[]&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-23"><a href="#实现方式-23" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop实现</span></span><br><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> []</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> [...infer Rest, infer L]</span><br><span class="line">      ? Rest</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure><h3 id="PromiseAll返回类型"><a href="#PromiseAll返回类型" class="headerlink" title="PromiseAll返回类型"></a>PromiseAll返回类型</h3><p><link-and-solution num="20"></link-and-solution></p><h4 id="用法-24"><a href="#用法-24" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseAll</code>是用来取<code>Promise.all()</code>函数所有返回的类型，其用法如下<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result1 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result2 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result3 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)])</span><br><span class="line"><span class="keyword">const</span> result4 = PromiseAll&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1： Promise&lt;[1, 2, 3]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">typeof</span> result1</span><br><span class="line"><span class="comment">// 结果2： Promise&lt;[1, 2, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> result2</span><br><span class="line"><span class="comment">// 结果3： Promise&lt;[number, number, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="keyword">typeof</span> result3</span><br><span class="line"><span class="comment">// 结果4： Promise&lt;number[]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t4 = <span class="keyword">typeof</span> result4</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-24"><a href="#实现方式-24" class="headerlink" title="实现方式"></a>实现方式</h4><p>与之前的例子不同，<code>PromiseAll</code>我们声明的是一个<code>function</code>而不是<code>type</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Awaited为内置类型</span></span><br><span class="line"><span class="keyword">type</span> PromiseAllType&lt;T&gt; = <span class="built_in">Promise</span>&lt;&#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: Awaited&lt;T[P]&gt;</span><br><span class="line">&#125;&gt;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">values: readonly [...T]</span>): <span class="title">PromiseAllType</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li>因为<code>Promise.all()</code>函数接受的是一个数组，因此泛型<code>T</code>限制为一个<code>any[]</code>类型的数组。</li><li><code>PromiseAllType</code>的实现思路有点像之前的<code>PromiseType</code>，只不过这里多了一层<code>Promise</code>的包裹，因为<code>Promise.all()</code>的返回类型也是一个<code>Promise</code>。</li></ul><h3 id="LookUp-查找"><a href="#LookUp-查找" class="headerlink" title="LookUp(查找)"></a>LookUp(查找)</h3><p><link-and-solution num="62"></link-and-solution></p><h4 id="用法-25"><a href="#用法-25" class="headerlink" title="用法"></a>用法</h4><p><code>LookUp</code>是用来根据类型值查<code>type</code>找类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'cat'</span></span><br><span class="line">  color: <span class="string">'black'</span> | <span class="string">'orange'</span> | <span class="string">'gray'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'dog'</span></span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">  name: <span class="string">'wang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Dog</span></span><br><span class="line"><span class="keyword">type</span> result = LookUp&lt;Cat | Dog, <span class="string">'dog'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-25"><a href="#实现方式-25" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LookUp&lt;</span><br><span class="line">  U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: <span class="built_in">string</span>; &#125;,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: T &#125; ? U : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>U extends { type: string; }</code>：这段代码限制<code>U</code>的类型必须是具有属性为<code>type</code>的对象。</li><li><code>U extends { type: T }</code>：如果把<code>T</code>的值实际带入，为<code>U extends { type: &#39;dog&#39; }</code>，表示判断<code>U</code>中的<code>type</code>值是不是<code>dog</code>，是则返回<code>U</code>。</li></ul><h3 id="Trim、TrimLeft以及TrimRight"><a href="#Trim、TrimLeft以及TrimRight" class="headerlink" title="Trim、TrimLeft以及TrimRight"></a>Trim、TrimLeft以及TrimRight</h3><p>TrimLeft：<link-and-solution num="106"><br>TrimRight：<link-and-solution num="4803"><br>Trim：<link-and-solution num="108"></link-and-solution></link-and-solution></link-and-solution></p><h4 id="用法-26"><a href="#用法-26" class="headerlink" title="用法"></a>用法</h4><p><code>Trim</code>、<code>TrimLeft</code>以及<code>TrimRight</code>这几个工具比较好理解，它们都是用来移除字符串中的空白符的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = TrimLeft&lt;<span class="string">' str'</span>&gt;  <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t2 = Trim&lt;<span class="string">' str '</span>&gt;     <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t3 = TrimRight&lt;<span class="string">'str '</span>&gt; <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-26"><a href="#实现方式-26" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">' '</span> | <span class="string">'\n'</span> | <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? TrimLeft&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> (<span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> | <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span>) ? Trim&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> TrimRight&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span> ? TrimRight&lt;R&gt; : S</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>TrimLeft</code>和<code>TrimRight</code>的实现思路是相同的，区别在于空白符的占位出现在左侧还是右侧。</li><li><code>Trim</code>的实现就是把<code>TrimLeft</code>和<code>TrimRight</code>所做的事情结合起来。</li></ul><h3 id="Capitalize-首字母大写-和UnCapitalize-首字母小写"><a href="#Capitalize-首字母大写-和UnCapitalize-首字母小写" class="headerlink" title="Capitalize(首字母大写)和UnCapitalize(首字母小写)"></a>Capitalize(首字母大写)和UnCapitalize(首字母小写)</h3><p><link-and-solution num="110"></link-and-solution></p><h4 id="用法-27"><a href="#用法-27" class="headerlink" title="用法"></a>用法</h4><p><code>Capitalize</code>是用来将一个字符串的首字母变成大写的，而<code>UnCapitalize</code>所做的事情跟它相反，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = Capitalize&lt;<span class="string">'hello'</span>&gt;   <span class="comment">// 'Hello'</span></span><br><span class="line"><span class="keyword">type</span> t2 = UnCapitalize&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-27"><a href="#实现方式-27" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br><span class="line"><span class="keyword">type</span> UnCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>无论是<code>Capitalize</code>还是<code>UnCapitalize</code>，它们都依赖内置的工具函数<code>Uppercase</code>或者<code>Lowercase</code>。对于<code>Capitalize</code>而言，我们只需要把首字母隔离出来，然后调用<code>Uppercase</code>即可。对于<code>UnCapitalize</code>而言，我们把首字母调用<code>Lowercase</code>即可。</li></ul><h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><p><link-and-solution num="116"></link-and-solution></p><h4 id="用法-28"><a href="#用法-28" class="headerlink" title="用法"></a>用法</h4><p><code>Replace</code>是用来将字符串中第一次出现的某段内容，使用指定的字符串进行替换，而<code>ReplaceAll</code>是全部替换，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：'foofoobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： foobarbar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">''</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-28"><a href="#实现方式-28" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><p><link-and-solution num="119"></link-and-solution></p><h4 id="用法-29"><a href="#用法-29" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceAll</code>是用来将字符串中指定字符全部替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'foofoofoo'</span></span><br><span class="line"><span class="keyword">type</span> t = ReplaceAll&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-29"><a href="#实现方式-29" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceAll&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;ReplaceAll&lt;L, <span class="keyword">from</span>, to&gt;&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;ReplaceAll&lt;R, <span class="keyword">from</span>, to&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="AppendArgument-追加参数"><a href="#AppendArgument-追加参数" class="headerlink" title="AppendArgument(追加参数)"></a>AppendArgument(追加参数)</h3><p><link-and-solution num="191"></link-and-solution></p><h4 id="用法-30"><a href="#用法-30" class="headerlink" title="用法"></a>用法</h4><p><code>AppendArgument</code>是用来向一个函数追加一个参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结果：(a: number, b: number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> result = AppendArgument&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-30"><a href="#实现方式-30" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendArgument&lt;Fn, A&gt; = Fn <span class="keyword">extends</span> (...args: infer R) =&gt; infer T ? <span class="function">(<span class="params">...args: [...R, A]</span>) =&gt;</span> T : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>我们首先利用<code>infer</code>关键词得到了<code>Fn</code>函数的参数类型以及返回类型，然后把新的参数添加到参数列表，并原样返回其函数类型。</li></ul><h3 id="Permutation-排列组合"><a href="#Permutation-排列组合" class="headerlink" title="Permutation(排列组合)"></a>Permutation(排列组合)</h3><p><link-and-solution num="296"></link-and-solution></p><h4 id="用法-31"><a href="#用法-31" class="headerlink" title="用法"></a>用法</h4><p><code>Permutation</code>是用来将联合类型中的每一个类型进行排列组合，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['A', 'B'] | ['B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result1 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result2 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-31"><a href="#实现方式-31" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Permutation&lt;T, U = T&gt; = </span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [T, ...Permutation&lt;Exclude&lt;U, T&gt;&gt;]</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>[T] extends [never]</code>：这段代码主要是为了处理联合类型为空的情况。</li><li><code>T extends U</code>：这段代码主要是需要使用<strong>分布式条件类型</strong>这个知识点，当<code>T extends U</code>成立时，在其后的判断语句中，<code>T</code>代表当前迭代的类型。</li><li><code>&lt;Exclude&lt;U, T&gt;</code>：因为此时的<code>T</code>代表当前迭代的类型，所以我们从原始联合类型中排除当前类型，然后递归调用<code>Permutation</code>。当<code>T</code>为<code>A</code>时，递归调用<code>Permutation&lt;&#39;B&#39; | &#39;C&#39;&gt;</code>, 此时结果为<code>[&#39;A&#39;]</code> + <code>[&#39;B&#39;, &#39;C&#39;]</code> 或 <code>[&#39;A&#39;]</code> + <code>[&#39;C&#39;, &#39;B&#39;]</code>。</li></ul><h3 id="LengthOfString-字符串的长度"><a href="#LengthOfString-字符串的长度" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="298"></link-and-solution></p><h4 id="用法-32"><a href="#用法-32" class="headerlink" title="用法"></a>用法</h4><p><code>LengthOfString</code>是用来计算一个字符串长度的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-32"><a href="#实现方式-32" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;R, [...T, Char]&gt;</span><br><span class="line">      : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>我们通过一个泛型的辅助数组来帮计算字符串的长度，在第一次符合条件时，将其第一个字符添加到数组中，在后续的递归过程中，如果不符合条件，直接返回<code>T[&#39;length&#39;]</code>，这个过程可以用如下代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>], S = <span class="string">'hello'</span>, R = <span class="string">'ello'</span></span><br><span class="line"><span class="comment">// 第二次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>], S = <span class="string">'ello'</span>, R = <span class="string">'llo'</span></span><br><span class="line"><span class="comment">// 第三次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>], S = <span class="string">'llo'</span>, R = <span class="string">'lo'</span></span><br><span class="line"><span class="comment">// 第四次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>], S = <span class="string">'lo'</span>, R = <span class="string">'o'</span></span><br><span class="line"><span class="comment">// 第五次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>, <span class="string">'o'</span>], S = <span class="string">'o'</span>, R = <span class="string">''</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Flatten-数组降维"><a href="#Flatten-数组降维" class="headerlink" title="Flatten(数组降维)"></a>Flatten(数组降维)</h3><p><link-and-solution num="459"></link-and-solution></p><h4 id="用法-33"><a href="#用法-33" class="headerlink" title="用法"></a>用法</h4><p><code>Flatten</code>是用来将多维数组进行降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Flatten&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>]]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-33"><a href="#实现方式-33" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer L, ...infer R]</span><br><span class="line">      ? L <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">        ? [...Flatten&lt;L&gt;, ...Flatten&lt;R&gt;]</span><br><span class="line">        : [L, ...Flatten&lt;R&gt;]</span><br><span class="line">      : []</span><br></pre></td></tr></table></figure><p>代码详解：<code>Flatten</code>数组降维的主要思路是，遍历数组中的每一个元素，判断其是否为一个数组，如果是，则递归调用<code>Flatten</code>，进行降维。</p><h3 id="AppendToObject-对象添加新属性"><a href="#AppendToObject-对象添加新属性" class="headerlink" title="AppendToObject(对象添加新属性)"></a>AppendToObject(对象添加新属性)</h3><p><link-and-solution num="527"></link-and-solution></p><h4 id="用法-34"><a href="#用法-34" class="headerlink" title="用法"></a>用法</h4><p><code>AppendToObject</code>是用来向指定对象添加一个额外的属性(<code>key/value</code>)，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = AppendToObject&lt;&#123; id: <span class="built_in">number</span>; &#125;, <span class="string">'name'</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-34"><a href="#实现方式-34" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> basicKeyType = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line"><span class="keyword">type</span> AppendToObject&lt;T, K <span class="keyword">extends</span> basicKeyType, V&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T | K]: P <span class="keyword">extends</span> keyof T ? T[P] : V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>basicKeyType</code>：在<code>JavaScript</code>中，因为一个对象的属性只能是<code>string</code>、<code>number</code>或者<code>symbol</code>这三种类型，所以我们限定<code>K</code>必须满足此条件。</li><li><code>keyof T | K</code>：这里表示<code>keyof T</code>的联合类型和<code>K</code>，组合成一个新的联合类型。</li></ul><h3 id="Absolute-绝对值"><a href="#Absolute-绝对值" class="headerlink" title="Absolute(绝对值)"></a>Absolute(绝对值)</h3><p><link-and-solution num="529"></link-and-solution></p><h4 id="用法-35"><a href="#用法-35" class="headerlink" title="用法"></a>用法</h4><p><code>Absolute</code>是用来取一个数的绝对值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1："531"</span></span><br><span class="line"><span class="keyword">type</span> result1 = Absolute&lt;<span class="number">-531</span>&gt;</span><br><span class="line"><span class="comment">// 结果2："9999"</span></span><br><span class="line"><span class="keyword">type</span> result2 = Absolute&lt;<span class="number">9</span>_999n&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-35"><a href="#实现方式-35" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberLike = <span class="built_in">number</span> | <span class="built_in">string</span> | bigint</span><br><span class="line"><span class="keyword">type</span> Absolute&lt;T <span class="keyword">extends</span> NumberLike&gt; =  <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`-<span class="subst">$&#123;infer N&#125;</span>`</span> ? N : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>NumberLike</code>：我们认为<code>&#39;1&#39;</code>和<code>1</code>都是一个合法的数字，所以定义一个辅助的<code>NumberList</code>联合类型。</li><li><code>${T}</code> extends <code>-${infer N}</code>：这里判断我们传递的数字是否为负数，如果是则直接取其正数部分，否则直接返回。</li></ul><p><strong>注意</strong>：这里说到的取绝对值，最后的结果之所以是一个字符串类型，是因为<code>TS</code>对递归次数有限制。如果你想要真正的数字类型，可以考虑实现一个<code>MakeArray</code>辅助方法，使用此方法可以将字符串类型的数字，转换成一个真正的数字类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; =</span><br><span class="line">  N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span></span><br><span class="line">  ? T</span><br><span class="line">  : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = MakeArray&lt;<span class="string">'3'</span>&gt;[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="StringToArray-字符串转数组"><a href="#StringToArray-字符串转数组" class="headerlink" title="StringToArray(字符串转数组)"></a>StringToArray(字符串转数组)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-36"><a href="#用法-36" class="headerlink" title="用法"></a>用法</h4><p><code>StringToArray</code>是用来将一个字符串转换成一个数组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToArray&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-36"><a href="#实现方式-36" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToArray&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? StringToArray&lt;R, [...U, Char]&gt;</span><br><span class="line">      : U</span><br></pre></td></tr></table></figure><p>代码详解：<code>StringToArray</code>的实现主要是使用了递归的思想，它每次拿到字符串中一个字符，然后存入一个辅助数组中，当字符串为空时，直接返回这个辅助数组。</p><h3 id="StringToUnion-字符串转联合类型"><a href="#StringToUnion-字符串转联合类型" class="headerlink" title="StringToUnion(字符串转联合类型)"></a>StringToUnion(字符串转联合类型)</h3><p><link-and-solution num="531"></link-and-solution></p><h4 id="用法-37"><a href="#用法-37" class="headerlink" title="用法"></a>用法</h4><p>在实现<code>StringToArray</code>后，我们能够很容易实现<code>StringToUnion</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'h' | 'e' | 'l' | 'l' | 'o'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-37"><a href="#实现方式-37" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 递归思想</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? Char | StringToUnion&lt;R&gt;</span><br><span class="line">      : never</span><br><span class="line"><span class="comment">// way2: 借用StringToArray</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = StringToArray&lt;S&gt;[<span class="built_in">number</span>]</span><br></pre></td></tr></table></figure><p>代码详解：<code>StringToArray&lt;S&gt;</code>返回的是一个数组，<code>T[number]</code>表示对一个数组进行数字类型索引迭代，其迭代结果是每个元素组合成的一个联合类型。</p><h3 id="Merge-类型合并"><a href="#Merge-类型合并" class="headerlink" title="Merge(类型合并)"></a>Merge(类型合并)</h3><p><link-and-solution num="599"></link-and-solution></p><h4 id="用法-38"><a href="#用法-38" class="headerlink" title="用法"></a>用法</h4><p><code>Merge</code>是用来合并两个类型，如果有重复的字段类型，则第二个的字段类型覆盖第一个的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">  c: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Merge&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-38"><a href="#实现方式-38" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Merge&lt;F, S&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof F | keyof S]: P <span class="keyword">extends</span> keyof S ? S[P] : P <span class="keyword">extends</span> keyof F ? F[P] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>keyof F | keyof S</code>：这段代码的含义是将<code>F</code>和<code>S</code>这两个对象的键组合成一个新的联合类型。</li><li><code>P extends</code>：这里进行了两次<code>extends</code>判断，其中第二次不能直接写成<code>F[P]</code>，而应该多判断一次，当满足条件时才使用<code>F[P]</code>，这是因为<code>P</code>的类型判断无法作用于<code>:</code>符号后面。</li></ul><h3 id="KebabCase-字符串转连字符"><a href="#KebabCase-字符串转连字符" class="headerlink" title="KebabCase(字符串转连字符)"></a>KebabCase(字符串转连字符)</h3><p><link-and-solution num="612"></link-and-solution></p><h4 id="用法-39"><a href="#用法-39" class="headerlink" title="用法"></a>用法</h4><p><code>KebabCase</code>是用来将驼峰形式字符串，转成连字符形式字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：foo-bar-baz</span></span><br><span class="line"><span class="keyword">type</span> result = KebabCase&lt;<span class="string">'FooBarBaz'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-39"><a href="#实现方式-39" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KebabCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? S2 <span class="keyword">extends</span> Uncapitalize&lt;S2&gt;</span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span><span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span>-<span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="Diff-类型差异部分"><a href="#Diff-类型差异部分" class="headerlink" title="Diff(类型差异部分)"></a>Diff(类型差异部分)</h3><p><link-and-solution num="645"></link-and-solution></p><h4 id="用法-40"><a href="#用法-40" class="headerlink" title="用法"></a>用法</h4><p><code>Diff</code>是用来获取两个类型的不同部分的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; id: number; gender: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Diff&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-40"><a href="#实现方式-40" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiffKeys&lt;T, U&gt; = Exclude&lt;keyof T | keyof U, keyof (T | U)&gt;</span><br><span class="line"><span class="keyword">type</span> Diff&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> DiffKeys&lt;T, U&gt;]: K <span class="keyword">extends</span> keyof T ? T[K] : K <span class="keyword">extends</span> keyof U ? U[K] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>keyof Foo | keyof Bar</code>：这段代码是把<code>T</code>和<code>U</code>中的所有属性组合成一个新的联合类型。</li><li><code>keyof (T | U)</code>：这段代码是取<code>T</code>和<code>U</code>的公共属性。</li><li><code>Exclude&lt;K1, K2&gt;</code>：这段代码主要是用来从<code>K1</code>中排除<code>K2</code>，带入以上例子也就是排除掉所有公共属性。</li><li><code>Diff&lt;T, U&gt;</code>：在获取到<code>DiffKeys</code>后，就可以迭代的方式获取到每个属性<code>key</code>，它所对应的类型了。</li><li><code>K extends keyof U</code>：额外再判断一次，是因为<code>K</code>不能在三元表达式右侧使用。</li></ul><h3 id="AnyOf-数组元素真值判断"><a href="#AnyOf-数组元素真值判断" class="headerlink" title="AnyOf(数组元素真值判断)"></a>AnyOf(数组元素真值判断)</h3><p><link-and-solution num="949"></link-and-solution></p><h4 id="用法-41"><a href="#用法-41" class="headerlink" title="用法"></a>用法</h4><p><code>AnyOf</code>用来判断数组元素真假值的，如果任一值为真，返回<code>true</code>；数组为空或者全部为<code>false</code>，才返回<code>false</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AnyOf&lt;[<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>, &#123; name: <span class="string">'name'</span> &#125;]&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AnyOf&lt;[<span class="number">0</span>, <span class="string">''</span>, <span class="literal">false</span>, [], &#123;&#125;]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-41"><a href="#实现方式-41" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FalsyType = <span class="number">0</span> | <span class="string">''</span> | <span class="literal">false</span> | <span class="literal">undefined</span> | <span class="literal">null</span> | [] | &#123; [key: <span class="built_in">string</span>]: never &#125;</span><br><span class="line"><span class="keyword">type</span> AnyOf&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> FalsyType ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：因为我们就是要区分<code>true/false</code>，所以我们把所有为<code>false</code>的值全部列举出来，然后使用<code>T[number]</code>索引迭代，依次去跟<code>FalsyType</code>比较，其中<code>{ [key: string]: never }</code>表示空对象<code>{}</code>。</p><h3 id="IsNever-是否是Never类型"><a href="#IsNever-是否是Never类型" class="headerlink" title="IsNever(是否是Never类型)"></a>IsNever(是否是Never类型)</h3><p><link-and-solution num="1042"></link-and-solution></p><h4 id="用法-42"><a href="#用法-42" class="headerlink" title="用法"></a>用法</h4><p><code>IsNever</code>是用来判断是否为<code>never</code>类型，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsNever&lt;<span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsNever&lt;never&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result3 = IsNever&lt;never | <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-42"><a href="#实现方式-42" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 类型数组</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = T[] <span class="keyword">extends</span> never[] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 数组值</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way3: 值比较</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = Equal&lt;T, never&gt;</span><br></pre></td></tr></table></figure><h3 id="IsUnion-是否联合类型"><a href="#IsUnion-是否联合类型" class="headerlink" title="IsUnion(是否联合类型)"></a>IsUnion(是否联合类型)</h3><p><link-and-solution num="1097"></link-and-solution></p><h4 id="用法-43"><a href="#用法-43" class="headerlink" title="用法"></a>用法</h4><p><code>IsUnion</code>是用来判断一个类型是否为联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsUnion&lt;<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;never&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-43"><a href="#实现方式-43" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 排除法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [Exclude&lt;U, T&gt;] <span class="keyword">extends</span> [never]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 正反对比法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; = </span><br><span class="line">  (T <span class="keyword">extends</span> U</span><br><span class="line">    ? U <span class="keyword">extends</span> T</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : unknown</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  ) <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：上面的实现虽然代码不多，但可能无法一下子就弄明白，为了更好的理解这种实现方式，我们来看如下两个案例分析：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例一</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step1: <span class="built_in">string</span> | <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step2: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">number</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step3: <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">string</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">true</span></span><br><span class="line">result: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例二</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span></span><br><span class="line">step1: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">step2: [never] <span class="keyword">extends</span> [never] =&gt; <span class="literal">false</span></span><br><span class="line">result: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>根据之前我们学到的<strong>分布式条件类型</strong>知识，<code>T extends U</code>的时候，会把<code>T</code>进行子类型分发。</p><p>如案例一的<code>step3</code>、<code>step4</code>，在分发后会把每次迭代的结果联合起来，组合成最终的结果。</p><h3 id="ReplaceKeys-类型替换"><a href="#ReplaceKeys-类型替换" class="headerlink" title="ReplaceKeys(类型替换)"></a>ReplaceKeys(类型替换)</h3><p><link-and-solution num="1130"></link-and-solution></p><h4 id="用法-44"><a href="#用法-44" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceKeys</code>是用来在一个类型中，使用指定的Y类型来替换已经存在的T类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceKeys&lt;&#123; id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125;, <span class="string">'name'</span>, &#123; name: <span class="built_in">boolean</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-44"><a href="#实现方式-44" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceKeys&lt;U, T, Y&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof U]:</span><br><span class="line">    P <span class="keyword">extends</span> T</span><br><span class="line">      ? P <span class="keyword">extends</span> keyof Y</span><br><span class="line">        ? Y[P]</span><br><span class="line">        : never</span><br><span class="line">      : U[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RemoveIndexSignature-移除索引签名"><a href="#RemoveIndexSignature-移除索引签名" class="headerlink" title="RemoveIndexSignature(移除索引签名)"></a>RemoveIndexSignature(移除索引签名)</h3><p><link-and-solution num="1367"></link-and-solution></p><h4 id="用法-45"><a href="#用法-45" class="headerlink" title="用法"></a>用法</h4><p><code>RemoveIndexSignature</code>是用来移除一个类型中的索引签名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  foo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; foo(): void; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = RemoveIndexSignature&lt;Foo&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-45"><a href="#实现方式-45" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckIndexSignature&lt;T, P&gt; = P <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> RemoveIndexSignature&lt;T, K = PropertyKey&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never)] : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>CheckIndexSignature</code>：因为索引签名有一个特点，为<code>string | number | symbol</code>，所以我们通过<code>P extends T ? true : false</code>形式排除此索引签名。其原理如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooKeys = <span class="built_in">string</span> | <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">example1: T = <span class="string">'foo'</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">false</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">example2: T = <span class="built_in">string</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">true</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">step5: <span class="built_in">boolean</span></span><br></pre></td></tr></table></figure></li><li><p><code>as xxx</code>：在之前的案例中，我们介绍过<code>as</code>的用法，在这里有<strong>加工</strong>或<strong>再次断言</strong>的意思。在使用<code>in</code>操作符进行迭代时，对每一个<code>P</code>再使用<code>CheckIndexSignature</code>加工一下，如果是索引签名，这里的结果为<code>never</code>，为<code>never</code>时表示跳过当前迭代，进而达到排除索引签名的目的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代 P = 'foo'</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="literal">false</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; P</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代 P = string</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="built_in">boolean</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终结果</span></span><br><span class="line"><span class="keyword">type</span> result = &#123; foo(): <span class="built_in">void</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="PercentageParser-百分比解析"><a href="#PercentageParser-百分比解析" class="headerlink" title="PercentageParser(百分比解析)"></a>PercentageParser(百分比解析)</h3><p><link-and-solution num="1978"></link-and-solution></p><h4 id="用法-46"><a href="#用法-46" class="headerlink" title="用法"></a>用法</h4><p><code>PercentageParser</code>是用来解析百分比字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = PercentageParser&lt;<span class="string">'+85%'</span>&gt; <span class="comment">// ['+', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result2 = PercentageParser&lt;<span class="string">'-85%'</span>&gt; <span class="comment">// ['-', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result3 = PercentageParser&lt;<span class="string">'85'</span>&gt;   <span class="comment">// ['', '85', '']</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-46"><a href="#实现方式-46" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckPrefix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">'+'</span> | <span class="string">'-'</span> ? S : never</span><br><span class="line"><span class="keyword">type</span> CheckSuffix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>%`</span> ? [L, <span class="string">'%'</span>] : [S, <span class="string">''</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PercentageParser&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;CheckPrefix&lt;infer L&gt;&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? [L, ...CheckSuffix&lt;R&gt;]</span><br><span class="line">    : [<span class="string">''</span>, ...CheckSuffix&lt;S&gt;]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>CheckPrefix</code>是用来处理百分比字符串前面的符号的，如果存在<code>+</code>或者<code>-</code>，则原样返回，如果不存在则返回<code>never</code>，表示没有符号。</li><li><code>CheckSuffix</code>是用来处理百分比字符串后面的百分比符号的，如果存在，则返回一个数组(最后一项固定为百分比符号)；如果不存在，则返回的数组最后一个元素固定为空字符串。</li></ul><h3 id="DropChar-移除字符"><a href="#DropChar-移除字符" class="headerlink" title="DropChar(移除字符)"></a>DropChar(移除字符)</h3><p><link-and-solution num="2070"></link-and-solution></p><h4 id="用法-47"><a href="#用法-47" class="headerlink" title="用法"></a>用法</h4><p><code>DropChar</code>是用来在字符串中移除指定字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：butterfly!</span></span><br><span class="line"><span class="keyword">type</span> result = DropChar&lt;<span class="string">' b u t t e r f l y ! '</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-47"><a href="#实现方式-47" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropChar&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = C <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? DropChar&lt;<span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;R&#125;</span>`</span>, C&gt;</span><br><span class="line">    : S</span><br></pre></td></tr></table></figure><p>代码详解：<code>DropChar</code>和<code>ReplaceAll</code>的实现思路非常相似，首先需要判断待移除的字符是不是空字符串，如果是，则直接返回原始字符串；如果不是，先判断字符串中是否包含待移除的字符，包含则递归调用；不包含则直接返回原始字符串。</p><h3 id="MinusOne-减一"><a href="#MinusOne-减一" class="headerlink" title="MinusOne(减一)"></a>MinusOne(减一)</h3><p><link-and-solution num="2257"></link-and-solution></p><p><code>MinusOne</code>是用来实现数字减一的，其用法如下：</p><h4 id="用法-48"><a href="#用法-48" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：99</span></span><br><span class="line"><span class="keyword">type</span> result = MinusOne&lt;<span class="number">100</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-48"><a href="#实现方式-48" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinusOne&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = N <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">  ? T <span class="keyword">extends</span> [infer F, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : never</span><br><span class="line">  : MinusOne&lt;N, [<span class="number">0</span>, ...T]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：在实现<code>MinusOne</code>的时候，借用了一个空数组，首先判断数组的长度是否等于传递的数字<code>N</code>，如果相等则从数组中随意移除一位，然后返回剩下数组的长度即可；如果不相等，则往数组中添加一个元素，再递归调用<code>MinusOne</code>。</p><p><strong>注意</strong>：由于<code>TS</code>在递归调用时存在最大递归调用次数，所以对于比较大的数字会提示错误。</p><h3 id="PickByType-根据类型选取"><a href="#PickByType-根据类型选取" class="headerlink" title="PickByType(根据类型选取)"></a>PickByType(根据类型选取)</h3><p><link-and-solution num="2595"></link-and-solution></p><h4 id="用法-49"><a href="#用法-49" class="headerlink" title="用法"></a>用法</h4><p><code>PickByType</code>是用来根据类型选取属性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; isReadonly: boolean, isEnable: boolean &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = PickByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-49"><a href="#实现方式-49" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PickByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> U ? P : never]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：<code>PickByType</code>的实现，可以使用<code>as</code>进行第二次断言，当类型满足时就返回当前迭代的<code>P</code>，不满足类型时就返回<code>never</code>，因为<code>never</code>最后会被排除，所以最后的迭代结果只有满足类型的键。</p><h3 id="StartsWith-字符串startsWith方法"><a href="#StartsWith-字符串startsWith方法" class="headerlink" title="StartsWith(字符串startsWith方法)"></a>StartsWith(字符串startsWith方法)</h3><p><link-and-solution num="2688"></link-and-solution></p><h4 id="用法-50"><a href="#用法-50" class="headerlink" title="用法"></a>用法</h4><p><code>StartsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>startsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = StartsWith&lt;<span class="string">'abc'</span>, <span class="string">'ab'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-50"><a href="#实现方式-50" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StartsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="EndsWith-字符串endsWith方法"><a href="#EndsWith-字符串endsWith方法" class="headerlink" title="EndsWith(字符串endsWith方法)"></a>EndsWith(字符串endsWith方法)</h3><p><link-and-solution num="2693"></link-and-solution></p><h4 id="用法-51"><a href="#用法-51" class="headerlink" title="用法"></a>用法</h4><p><code>EndsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>endsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = endsWith&lt;<span class="string">'abc'</span>, <span class="string">'bc'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-51"><a href="#实现方式-51" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EndsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;C&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="PartialByKeys-按需可选"><a href="#PartialByKeys-按需可选" class="headerlink" title="PartialByKeys(按需可选)"></a>PartialByKeys(按需可选)</h3><p><link-and-solution num="2757"></link-and-solution></p><h4 id="用法-52"><a href="#用法-52" class="headerlink" title="用法"></a>用法</h4><p><code>PartialByKeys</code>是用来实现按需可选的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> UserPartialName &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserPartialName</span></span><br><span class="line"><span class="keyword">type</span> result = PartialByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-52"><a href="#实现方式-52" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PartialByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Omit</code>部分：根据之前介绍的<code>Omit</code>的知识，<code>Omit&lt;T, K&gt;</code>表示从<code>T</code>中剔除含有<code>K</code>的类型。</li><li><code>CopyKeys</code>部分：如果不使用<code>CopyKeys</code>，最后的结果为<code>T &amp; U</code>形式，它实际上与使用<code>CopyKeys</code>的结果是一样的。这里使用<code>CopyKeys</code>，很大程度上是为了测试。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用CopyKeys，结果为true；不使用，结果为false</span></span><br><span class="line"><span class="keyword">type</span> result1 = Equal&lt;PartialByKeys&lt;User, <span class="string">'name'</span>&gt;, UserPartialName&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RequiredByKeys-按需必填"><a href="#RequiredByKeys-按需必填" class="headerlink" title="RequiredByKeys(按需必填)"></a>RequiredByKeys(按需必填)</h3><p><link-and-solution num="2759"></link-and-solution></p><p>在实现<code>PartialByKeys</code>后，很容易按照相同的思路去实现<code>RequiredByKeys</code>。</p><h4 id="用法-53"><a href="#用法-53" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredByKeys</code>是用来实现按需必填的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UserRequiredName &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserRequiredName</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-53"><a href="#实现方式-53" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequiredByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]-?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：实现思路参考<code>PartialByKeys</code>。</p><h3 id="Mutable-可改"><a href="#Mutable-可改" class="headerlink" title="Mutable(可改)"></a>Mutable(可改)</h3><p><link-and-solution num="2793"></link-and-solution></p><h4 id="用法-54"><a href="#用法-54" class="headerlink" title="用法"></a>用法</h4><p><code>Mutable</code>是用来让所有属性变为可改的(移除<code>readonly</code>关键词)，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> MutableResult = MyMutable&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-54"><a href="#实现方式-54" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMutable&lt;T&gt; = &#123;</span><br><span class="line">  -readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：</p><ul><li><code>-readonly</code>：表示把<code>readonly</code>关键词去掉，去掉之后此字段变为可改的。</li></ul><h3 id="OmitByType-按类型移除"><a href="#OmitByType-按类型移除" class="headerlink" title="OmitByType(按类型移除)"></a>OmitByType(按类型移除)</h3><p><link-and-solution num="2852"></link-and-solution></p><p><code>OmitByType</code>的实现思路和<code>PickByType</code>类似。</p><h4 id="用法-55"><a href="#用法-55" class="headerlink" title="用法"></a>用法</h4><p><code>OmitByType</code>是用来按照类型移除的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ModelOmitBoolean &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelOmitBoolean</span></span><br><span class="line"><span class="keyword">type</span> result = OmitByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-55"><a href="#实现方式-55" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OmitByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> U <span class="keyword">extends</span> T[P] ? never : P]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：实现思路参考<code>PickByType</code>。</p><h3 id="ObjectEntries"><a href="#ObjectEntries" class="headerlink" title="ObjectEntries"></a>ObjectEntries</h3><p><link-and-solution num="2946"></link-and-solution></p><h4 id="用法-56"><a href="#用法-56" class="headerlink" title="用法"></a>用法</h4><p><code>ObjectEntries</code>是用来实现<code>JavaScript</code>中的<code>Object.entries()</code>方法，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  locations?: <span class="built_in">string</span>[] | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ModelEntries = [<span class="string">'name'</span>, <span class="built_in">string</span>] | [<span class="string">'age'</span>, <span class="built_in">number</span>] | [<span class="string">'locations'</span>, <span class="built_in">string</span>[] | <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelEntries</span></span><br><span class="line"><span class="keyword">type</span> result = ObjectEntries&lt;Model&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-56"><a href="#实现方式-56" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RemoveUndefined&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="literal">undefined</span>] ? T : Exclude&lt;T, <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">type</span> ObjectEntries&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: &#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? [P, RemoveUndefined&lt;T[P]&gt;] : [P, T[P]]</span><br><span class="line">&#125;[keyof T]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>RemoveUndefined</code>：当<code>T</code>仅为<code>undefined</code>，表示原始类型就是<code>undefined</code>; 当<code>T</code>为联合类型时，移除联合类型中的<code>undefined</code>。</li><li><code>[P in keyof T]-?</code>:  表示移除可选属性。</li><li><code>{} extends Pick&lt;T, P&gt;</code>: 判断当前的<code>P</code>是否为可选属性，是的话就是使用<code>RemoveUndefined</code>移除其中的<code>undefined</code>，否则取原始类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果都为true</span></span><br><span class="line"><span class="keyword">type</span> result1 = &#123;&#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; name: <span class="built_in">string</span>; &#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Shift-数组shift方法"><a href="#Shift-数组shift方法" class="headerlink" title="Shift(数组shift方法)"></a>Shift(数组shift方法)</h3><p><link-and-solution num="3062"></link-and-solution></p><h4 id="用法-57"><a href="#用法-57" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift结果：[2, 3]</span></span><br><span class="line"><span class="keyword">type</span> shiftResult = Shift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-57"><a href="#实现方式-57" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift实现</span></span><br><span class="line"><span class="keyword">type</span> Shift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer F, ...infer R] ? R : []</span><br></pre></td></tr></table></figure><h3 id="TupleToNestedObject-元组转嵌套对象"><a href="#TupleToNestedObject-元组转嵌套对象" class="headerlink" title="TupleToNestedObject(元组转嵌套对象)"></a>TupleToNestedObject(元组转嵌套对象)</h3><p><link-and-solution num="3188"></link-and-solution></p><h4 id="用法-58"><a href="#用法-58" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToNestedObject</code>是用来将元组转成嵌套对象的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; a: &#123; b: string; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToNestedObject&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-58"><a href="#实现方式-58" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToNestedObject&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">    ? &#123; [P <span class="keyword">in</span> F &amp; <span class="built_in">string</span>]: TupleToNestedObject&lt;R, U&gt; &#125;</span><br><span class="line">    : U</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>F &amp; string</code>: 等价于如下代码：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &amp; <span class="built_in">string</span> = F <span class="keyword">extends</span> <span class="built_in">string</span> ? F : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p><link-and-solution num="3192"></link-and-solution></p><h4 id="用法-59"><a href="#用法-59" class="headerlink" title="用法"></a>用法</h4><p><code>Reverse</code>是用来实现数组的<code>reverse()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['b', 'a']</span></span><br><span class="line"><span class="keyword">type</span> result = Reverse&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-59"><a href="#实现方式-59" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reverse&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [...infer R, infer L]</span><br><span class="line">    ? [L, ...Reverse&lt;R&gt;]</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><h3 id="FlipArguments-反转函数参数类型"><a href="#FlipArguments-反转函数参数类型" class="headerlink" title="FlipArguments(反转函数参数类型)"></a>FlipArguments(反转函数参数类型)</h3><p><link-and-solution num="3196"></link-and-solution></p><p>借助上面的<code>Reverse</code>方法，可以很容易实现函数参数的反转。</p><h4 id="用法-60"><a href="#用法-60" class="headerlink" title="用法"></a>用法</h4><p><code>FlipArguments</code>是用来实现反转函数参数类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：(a: number, b: string) =&gt; string | number</span></span><br><span class="line"><span class="keyword">type</span> result = FlipArguments&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-60"><a href="#实现方式-60" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlipArguments&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> (...args: infer A) =&gt; infer R</span><br><span class="line">    ? <span class="function">(<span class="params">...args: Reverse&lt;A&gt;</span>) =&gt;</span> R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><h3 id="FlattenDepth-数组按深度降维"><a href="#FlattenDepth-数组按深度降维" class="headerlink" title="FlattenDepth(数组按深度降维)"></a>FlattenDepth(数组按深度降维)</h3><p><link-and-solution num="3243"></link-and-solution></p><h4 id="用法-61"><a href="#用法-61" class="headerlink" title="用法"></a>用法</h4><p><code>FlattenDepth</code>是用来按深度进行数组降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4, [5]]</span></span><br><span class="line"><span class="keyword">type</span> result = FlattenDepth&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[[<span class="number">5</span>]]]], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-61"><a href="#实现方式-61" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlattenDepth&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">1</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? U[<span class="string">'length'</span>] <span class="keyword">extends</span> D</span><br><span class="line">    ? T</span><br><span class="line">    : F <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? [...FlattenDepth&lt;F, D, [<span class="number">0</span>, ...U]&gt;, ...FlattenDepth&lt;R, D&gt;]</span><br><span class="line">      : [F, ...FlattenDepth&lt;R, D, U&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure><p>代码详解：<code>FlattenDepth</code>的实现思路和<code>Flatten</code>基本一致，区别是按深度降维时需要一个数组去记录降维的次数(深度)。</p><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><link-and-solution num="3326"></link-and-solution></p><h4 id="用法-62"><a href="#用法-62" class="headerlink" title="用法"></a>用法</h4><p><code>BEM</code>是用来将字符串连接成CSS BEM格式的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'btn__primary--small' | 'btn__primary--mini' </span></span><br><span class="line"><span class="keyword">type</span> result = BEM&lt;<span class="string">'btn'</span>, [<span class="string">'primary'</span>], [<span class="string">'small'</span>, <span class="string">'mini'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-62"><a href="#实现方式-62" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArrayToString&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [] ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;T[<span class="built_in">number</span>]&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BEM&lt;</span><br><span class="line">  B <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="built_in">string</span>[],</span><br><span class="line">  M <span class="keyword">extends</span> <span class="built_in">string</span>[]</span><br><span class="line">&gt; = <span class="string">`<span class="subst">$&#123;B&#125;</span><span class="subst">$&#123;ArrayToString&lt;E, <span class="string">'--'</span>&gt;&#125;</span><span class="subst">$&#123;ArrayToString&lt;M, <span class="string">'__'</span>&gt;&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>代码详解：实现<code>BEM</code>的思路并不复杂，只需要记住如下两个知识点：</p><ul><li>判断是一个空数组，可以使用<code>T extends []</code>或者<code>T[&#39;length&#39;] extends 0</code>。</li><li><code>T[number]</code>会自动迭代数组，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果: 'A__B' | 'A__C' | 'A__D'</span></span><br><span class="line"><span class="keyword">type</span> result = <span class="string">`A__<span class="subst">$&#123;[<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>][<span class="built_in">number</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="InOrderTraversal-中序遍历"><a href="#InOrderTraversal-中序遍历" class="headerlink" title="InOrderTraversal(中序遍历)"></a>InOrderTraversal(中序遍历)</h3><p><link-and-solution num="3376"></link-and-solution></p><p><strong>先序遍历</strong>：<code>PreOrderTraversal</code>先访问根节点，然后访问左节点，最后访问右节点。<br><br><strong>中序遍历</strong>：<code>InOrderTraversal</code>先访问左节点，然后访问根节点，最后访问右节点。<br><br><strong>后序遍历</strong>：<code>PostOrderTraversal</code>先访问左节点，然后访问右节点，最后访问根节点。</p><h4 id="用法-63"><a href="#用法-63" class="headerlink" title="用法"></a>用法</h4><p><code>InOrderTraversal</code>是用来实现二叉树中序遍历的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  left: <span class="literal">null</span>,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: <span class="number">3</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: [1, 3, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = InOrderTraversal&lt;<span class="keyword">typeof</span> tree&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-63"><a href="#实现方式-63" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个二叉树节点</span></span><br><span class="line"><span class="keyword">interface</span> TreeNode &#123;</span><br><span class="line">  val: <span class="built_in">number</span>;</span><br><span class="line">  left: TreeNode | <span class="literal">null</span>;</span><br><span class="line">  right: TreeNode | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PreOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [T[<span class="string">'val'</span>], ...PreOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PreOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 中序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> InOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...InOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, T[<span class="string">'val'</span>], ...InOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 后序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PostOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...PostOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PostOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;, T[<span class="string">'val'</span>]]</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>[T] extends [TreeNode]</code>: 使用此形式而不用<code>T extends TreeNode</code>，这是因为<code>T</code>是一个<code>TreeNode | null</code>，在左侧会进行分布式条件类型，判断两次：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果Tree嵌套比较深的话，ts会报错</span></span><br><span class="line">TreeNode <span class="keyword">extends</span> TreeNode |</span><br><span class="line"><span class="literal">null</span> <span class="keyword">extends</span> TreeNode</span><br></pre></td></tr></table></figure></li><li><p>遍历方式：根据先序遍历<code>PreOrderTraversal</code>、中序遍历<code>InOrderTraversal</code>、后序遍历<code>PostOrderTraversal</code>的定义，只需要在递归的时候处理其访问顺序即可。</p></li></ul><h3 id="FlipObject-对象键值交换"><a href="#FlipObject-对象键值交换" class="headerlink" title="FlipObject(对象键值交换)"></a>FlipObject(对象键值交换)</h3><p><link-and-solution num="4179"></link-and-solution></p><h4 id="用法-64"><a href="#用法-64" class="headerlink" title="用法"></a>用法</h4><p><code>FlipObject</code>是用来将对象的键值交换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; pi: 'a' &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = FlipObject&lt;&#123; a: <span class="string">'pi'</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-64"><a href="#实现方式-64" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> FlipObject&lt;T <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, BasicType&gt;&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;T[P]&#125;</span>`</span>]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fibonacci-斐波那契数列"><a href="#Fibonacci-斐波那契数列" class="headerlink" title="Fibonacci(斐波那契数列)"></a>Fibonacci(斐波那契数列)</h3><p><link-and-solution num="4182"></link-and-solution></p><p><strong>菲波那切数列</strong>：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…</p><h4 id="用法-65"><a href="#用法-65" class="headerlink" title="用法"></a>用法</h4><p><code>Fibonacci</code>是用来实现斐波那契数列的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = Fibonacci&lt;<span class="number">5</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-65"><a href="#实现方式-65" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fibonacci&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>],</span><br><span class="line">  Prev <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Current <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>]</span><br><span class="line">&gt; = Index[<span class="string">'length'</span>] <span class="keyword">extends</span> N</span><br><span class="line">  ? Current[<span class="string">'length'</span>]</span><br><span class="line">  : Fibonacci&lt;N, [...Index, <span class="number">1</span>], Current, [...Prev, ...Current]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Index</code>：标记当前数列是第几项，从1开始。</li><li><code>Prev</code>：存储数列上一次计算的值，从0开始。</li><li><code>Current</code>: 标记当前数列的值，根据数列的特点，第N项的值，等于<code>N - 1</code>项 + <code>N - 2</code>项的值，即：<code>Current = [...Prev, ...Current]</code></li></ul><h3 id="AllCombinations-全排列"><a href="#AllCombinations-全排列" class="headerlink" title="AllCombinations(全排列)"></a>AllCombinations(全排列)</h3><p><link-and-solution num="4260"></link-and-solution></p><h4 id="用法-66"><a href="#用法-66" class="headerlink" title="用法"></a>用法</h4><p><code>AllCombinations</code>是用来列举全部排列组合可能性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'' | 'A' | 'AB' | 'B' | 'BA'</span></span><br><span class="line"><span class="keyword">type</span> result = AllCombinations&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-66"><a href="#实现方式-66" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? F | StringToUnion&lt;R&gt;</span><br><span class="line">    : never</span><br><span class="line"><span class="keyword">type</span> Combination&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span>,</span><br><span class="line">  K = S</span><br><span class="line">&gt; = [S] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? U</span><br><span class="line">  : K <span class="keyword">extends</span> S</span><br><span class="line">    ? Combination&lt;Exclude&lt;S, K&gt;, U | <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;K&#125;</span>`</span>&gt;</span><br><span class="line">    : U</span><br><span class="line"><span class="keyword">type</span> AllCombinations&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Combination&lt;StringToUnion&lt;S&gt;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>StringToUnion</code>是用来将字符串变成一个联合类型的，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 'A' | 'B'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Combination</code>是用来将联合类型进行排列组合的，以以上<code>&#39;A&#39; | &#39;B&#39;</code>这个联合类型为例，步骤如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：从'A' | 'B这个联合类型中排除当前迭代的字符'A'</span></span><br><span class="line">K = <span class="string">'A'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span>  =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'A'</span>&gt;</span><br><span class="line"><span class="comment">// 第一步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'B'</span>, <span class="string">''</span> | <span class="string">'A'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'A'</span>&#125;</span>B`</span> =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'AB'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：从'A' | 'B'这个联合类型中排除当前迭代的字符'B'</span></span><br><span class="line">K = <span class="string">'B'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span> =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 第二步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'A'</span>, <span class="string">''</span> | <span class="string">'B'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'B'</span>&#125;</span>A`</span> =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">'A'</span> | <span class="string">'BA'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：剔除相同元素</span></span><br><span class="line">result = <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'AB'</span> | <span class="string">'B'</span> | <span class="string">'BA'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="GreaterThan-大于"><a href="#GreaterThan-大于" class="headerlink" title="GreaterThan(大于)"></a>GreaterThan(大于)</h3><p><link-and-solution num="4425"></link-and-solution></p><h4 id="用法-67"><a href="#用法-67" class="headerlink" title="用法"></a>用法</h4><p><code>GreaterThan&lt;T, N&gt;</code>是来用判断正整数T是否大于正整数N的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = GreaterThan&lt;<span class="number">2</span>, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-67"><a href="#实现方式-67" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果比较的数比较大，会提示：Type instantiation is excessively deep and possibly infinite</span></span><br><span class="line"><span class="keyword">type</span> GreaterThan&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : N <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : GreaterThan&lt;T, N, [...R, <span class="number">0</span>]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：使用一个空数组来辅助，每次递归添加一个元素，如果正整数<code>T</code>先等于这个数组的长度，则为<code>false</code>；如果正整数<code>N</code>先等于这个数组的长度，则为<code>true</code>。</p><h3 id="Zip-按位置匹配"><a href="#Zip-按位置匹配" class="headerlink" title="Zip(按位置匹配)"></a>Zip(按位置匹配)</h3><p><link-and-solution num="4471"></link-and-solution></p><h4 id="用法-68"><a href="#用法-68" class="headerlink" title="用法"></a>用法</h4><p><code>Zip</code>是用来将两个元组按照相同索引位置组合成一个新数组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, true], [2, false]]</span></span><br><span class="line"><span class="keyword">type</span> result = Zip&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="literal">true</span>, <span class="literal">false</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-68"><a href="#实现方式-68" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zip&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? U <span class="keyword">extends</span> [infer Head, ...infer Tail]</span><br><span class="line">      ? [[First, Head], ...Zip&lt;Rest, Tail&gt;]</span><br><span class="line">      : []</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><h3 id="IsTuple-是否为元组"><a href="#IsTuple-是否为元组" class="headerlink" title="IsTuple(是否为元组)"></a>IsTuple(是否为元组)</h3><p><link-and-solution num="4484"></link-and-solution></p><h4 id="用法-69"><a href="#用法-69" class="headerlink" title="用法"></a>用法</h4><p><code>IsTuple</code>是用来判断是否为一个元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = IsTuple&lt;[<span class="built_in">number</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-69"><a href="#实现方式-69" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsTuple&lt;T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">      ? <span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码解析：以上代码中，比较关键的代码是<code>number extends T[&#39;length&#39;]</code>，这里不能写成<code>T[&#39;length&#39;] extends number</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1：需要返回false，因为它不定长，违反了元组的定义</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsTuple&lt;<span class="built_in">number</span>[]&gt;</span><br><span class="line"><span class="comment">// case2：需要返回true，因为它定长，只不过长度为0</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsTuple&lt;[]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case1计算逻辑，T['length']返回的是number，不是一个确定的值</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2计算逻辑，T['length']返回的是0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">=&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="Chunk-lodash分割数组"><a href="#Chunk-lodash分割数组" class="headerlink" title="Chunk(lodash分割数组)"></a>Chunk(lodash分割数组)</h3><p><link-and-solution num="4499"></link-and-solution></p><p><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash Chunk</a>: 将一个数组分割成长度为N的多个小数组。</p><h4 id="用法-70"><a href="#用法-70" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, 2], [3, 4]]</span></span><br><span class="line"><span class="keyword">type</span> result = Chunk&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-70"><a href="#实现方式-70" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chunk&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  Size <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> Size</span><br><span class="line">  ? [R, ...Chunk&lt;T, Size&gt;]</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Chunk&lt;L, Size, [...R, F]&gt;</span><br><span class="line">    : R[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? []</span><br><span class="line">      : [R]</span><br></pre></td></tr></table></figure><p>代码详解：实现<code>Chunk</code>大体思路是：借助一个辅助空数组，在遍历数组时往这个辅助数组中添加元素，一直到等于指定长度，然后进行下一次相同操作。</p><h3 id="Fill-数组fill方法"><a href="#Fill-数组fill方法" class="headerlink" title="Fill(数组fill方法)"></a>Fill(数组fill方法)</h3><p><link-and-solution num="4518"></link-and-solution></p><h4 id="用法-71"><a href="#用法-71" class="headerlink" title="用法"></a>用法</h4><p><code>Fill</code>是用来在一个数组中，用指定元素，替换开始索引和结束索引元素的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-71"><a href="#实现方式-71" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fill&lt;</span><br><span class="line">  T <span class="keyword">extends</span> unknown[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Start <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">0</span>,</span><br><span class="line">  End <span class="keyword">extends</span> <span class="built_in">number</span> = T[<span class="string">'length'</span>],</span><br><span class="line">  Count <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Flag <span class="keyword">extends</span> <span class="built_in">boolean</span> = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> Start ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> End</span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Flag <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">      ? [F, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>]&gt;]</span><br><span class="line">      : [N, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>], <span class="literal">true</span>&gt;]</span><br><span class="line">    : T</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Count</code>: 遍历标志位，从数组第一项开始，当等于<code>End</code>时，结束替换。</li><li><code>Flag</code>：遍历标志位，从数组第一项开始，当等于<code>Start</code>是，开始替换。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次遍历 Count = [], Flag = false, T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 满足Flag extends false条件，Count = [0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次遍历 Count = [0], Flag = true(计算而言)，T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0], T = [1, true, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次遍历 Count = [0, 0], Flag = true(主动传递), T =[1, true, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0, 0], T = [1, true, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次判断 Count = [0, 0, 0]，长度等于End，结束，T = [1, true, true]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Without-移除"><a href="#Without-移除" class="headerlink" title="Without(移除)"></a>Without(移除)</h3><p><link-and-solution num="5117"></link-and-solution></p><h4 id="用法-72"><a href="#用法-72" class="headerlink" title="用法"></a>用法</h4><p><code>Without</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[3]</span></span><br><span class="line"><span class="keyword">type</span> result = Without&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-72"><a href="#实现方式-72" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToUnion&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T</span><br><span class="line"><span class="keyword">type</span> Without&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  U = ToUnion&lt;F&gt;,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? First <span class="keyword">extends</span> U</span><br><span class="line">      ? Without&lt;Rest, F, U, [...R]&gt;</span><br><span class="line">      : Without&lt;Rest, F, U, [...R, First]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><p>代码详解：因为<code>F</code>支持单数字和数组，所以定义一个<code>ToUion</code>来统一处理成联合类型。随后直接遍历数组，如果当前迭代的元素在联合类型中，则直接跳过进行下一次迭代；否则，把当前迭代元素添加到<code>R</code>辅助数组中。</p><h3 id="Trunc-Math-trunc取整"><a href="#Trunc-Math-trunc取整" class="headerlink" title="Trunc(Math.trunc取整)"></a>Trunc(Math.trunc取整)</h3><p><link-and-solution num="5140"></link-and-solution></p><h4 id="用法-73"><a href="#用法-73" class="headerlink" title="用法"></a>用法</h4><p><code>Trunc</code>是用来实现<code>Math.trunc()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：100</span></span><br><span class="line"><span class="keyword">type</span> result1 = Trunc&lt;<span class="number">100.32</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：0</span></span><br><span class="line"><span class="keyword">type</span> result2 = Trunc&lt;<span class="number">.3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-73"><a href="#实现方式-73" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trunc&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">&gt; =<span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>.<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">  ? L <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">    ? <span class="string">'0'</span></span><br><span class="line">    : L</span><br><span class="line">  : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><h3 id="IndexOf-数组indexOf方法"><a href="#IndexOf-数组indexOf方法" class="headerlink" title="IndexOf(数组indexOf方法)"></a>IndexOf(数组indexOf方法)</h3><p><link-and-solution num="5153"></link-and-solution></p><h4 id="用法-74"><a href="#用法-74" class="headerlink" title="用法"></a>用法</h4><p><code>IndexOf</code>是用来实现数组<code>indexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2</span></span><br><span class="line"><span class="keyword">type</span> result = IndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-74"><a href="#实现方式-74" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;U, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Index[<span class="string">'length'</span>]</span><br><span class="line">    : IndexOf&lt;Rest, U, [...Index, <span class="number">0</span>]&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>代码详解：需要借助<code>IsEqual</code>来判断两个值是否相等，原因考虑如下案例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsEqual&lt;<span class="number">1</span>, <span class="built_in">number</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsEqual&lt;<span class="string">'a'</span>, <span class="built_in">string</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="Join-数组join方法"><a href="#Join-数组join方法" class="headerlink" title="Join(数组join方法)"></a>Join(数组join方法)</h3><p><link-and-solution num="5310"></link-and-solution></p><h4 id="用法-75"><a href="#用法-75" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现数组<code>join</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a-p-p-l-e'</span></span><br><span class="line"><span class="keyword">type</span> result = Join&lt;[<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'p'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>], <span class="string">'-'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-75"><a href="#实现方式-75" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Join&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      : Join&lt;Rest, U, <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span>&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><h3 id="LastIndexOf-数组lastIndexOf方法"><a href="#LastIndexOf-数组lastIndexOf方法" class="headerlink" title="LastIndexOf(数组lastIndexOf方法)"></a>LastIndexOf(数组lastIndexOf方法)</h3><p><link-and-solution num="5317"></link-and-solution></p><p>借助<code>IndexOf</code>的实现思路，很容易实现<code>lastIndexOf</code>方法。</p><h4 id="用法-76"><a href="#用法-76" class="headerlink" title="用法"></a>用法</h4><p><code>LastIndexOf</code>是用来实现数组<code>lastIndexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = LastIndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-76"><a href="#实现方式-76" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> LastIndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[], </span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [...infer Rest, infer Last]</span><br><span class="line">  ? IsEqual&lt;Last, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : LastIndexOf&lt;Rest, U&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="Unique-数组去重"><a href="#Unique-数组去重" class="headerlink" title="Unique(数组去重)"></a>Unique(数组去重)</h3><p><link-and-solution num="5360"></link-and-solution></p><h4 id="用法-77"><a href="#用法-77" class="headerlink" title="用法"></a>用法</h4><p><code>Unique</code>是用来实现数组去重的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unique&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-77"><a href="#实现方式-77" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>IsEqual</code>和<code>Includes</code>，很容易实现<code>Unique</code>数组去重。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> Includes&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;Last, U&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unique&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Includes&lt;R, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Unique&lt;Last, R&gt;</span><br><span class="line">    : Unique&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure></p><h3 id="MapTypes-类型转换"><a href="#MapTypes-类型转换" class="headerlink" title="MapTypes(类型转换)"></a>MapTypes(类型转换)</h3><p><link-and-solution num="5821"></link-and-solution></p><h4 id="用法-78"><a href="#用法-78" class="headerlink" title="用法"></a>用法</h4><p><code>MapTypes</code>是用来根据指定类型进行替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; type: number; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MapTypes&lt;&#123; <span class="keyword">type</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;, &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-78"><a href="#实现方式-78" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMapType&lt;</span><br><span class="line">  T, </span><br><span class="line">  R,</span><br><span class="line">  Type = R <span class="keyword">extends</span> &#123; mapFrom: T, mapTo: infer To &#125; ? To : never</span><br><span class="line">&gt; = [Type] <span class="keyword">extends</span> [never] ? T : Type</span><br><span class="line"><span class="keyword">type</span> MapTypes&lt;T, R&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: GetMapType&lt;T[P], R&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：在以上的实现中，最核心的代码是获取<code>Type</code>类型。</p><ul><li><code>R extends { mapFrom: T, mapTo: infer To }</code>：这段代码表示，<code>R</code>是不是右边的子类型，我们以以上案例来说明：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当P = 'type'时，</span></span><br><span class="line">T[P] = <span class="built_in">string</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">string</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; To = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; <span class="keyword">type</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当P = 'age'时</span></span><br><span class="line">T[P] = <span class="built_in">number</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">number</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; never</span><br><span class="line">=&gt; GetMapType&lt;T[P], R&gt; = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; age: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ConstructTuple-构造元组"><a href="#ConstructTuple-构造元组" class="headerlink" title="ConstructTuple(构造元组)"></a>ConstructTuple(构造元组)</h3><p><link-and-solution num="7544"></link-and-solution></p><h4 id="用法-79"><a href="#用法-79" class="headerlink" title="用法"></a>用法</h4><p><code>ConstructTuple</code>是用来构造指定长度的元组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[unknown, unknown]</span></span><br><span class="line"><span class="keyword">type</span> result = ConstructTuple&lt;<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-79"><a href="#实现方式-79" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConstructTuple&lt;</span><br><span class="line">  L <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> L</span><br><span class="line">  ? R</span><br><span class="line">  : ConstructTuple&lt;L, [...R, unknown]&gt;</span><br></pre></td></tr></table></figure><h3 id="NumberRange-限定范围数字"><a href="#NumberRange-限定范围数字" class="headerlink" title="NumberRange(限定范围数字)"></a>NumberRange(限定范围数字)</h3><p><link-and-solution num="8640"></link-and-solution></p><h4 id="用法-80"><a href="#用法-80" class="headerlink" title="用法"></a>用法</h4><p><code>NumberRange</code>是用来返回指定范围内的数字的，其返回的是一个联合类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"><span class="keyword">type</span> result = NumberRange&lt;<span class="number">2</span>, <span class="number">9</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-80"><a href="#实现方式-80" class="headerlink" title="实现方式"></a>实现方式</h4><p>实现思路参考：数组<code>Fill</code>方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberRange&lt;</span><br><span class="line">  L, </span><br><span class="line">  H,</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  F = I[<span class="string">'length'</span>] <span class="keyword">extends</span> L ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = I[<span class="string">'length'</span>] <span class="keyword">extends</span> H</span><br><span class="line">  ? I[<span class="built_in">number</span>] | H</span><br><span class="line">  : F <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">    ? NumberRange&lt;L, H, [...I, never]&gt;</span><br><span class="line">    : NumberRange&lt;L, H, [...I, I[<span class="string">'length'</span>]], <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Subsequence-元组子序列"><a href="#Subsequence-元组子序列" class="headerlink" title="Subsequence(元组子序列)"></a>Subsequence(元组子序列)</h3><p><link-and-solution num="8987"></link-and-solution></p><h4 id="用法-81"><a href="#用法-81" class="headerlink" title="用法"></a>用法</h4><p><code>Subsequence</code>是用来根据指定数组生成元组子序列的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[] | [1] | [2] | [1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = Subsequence&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-81"><a href="#实现方式-81" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subsequence&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Subsequence&lt;Last, R | [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>R | [...R, First]</code>: 在一个数组中，对一个联合类型的数组使用<code>...</code>扩展时，会自动进行元素分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['a', 'b'] | ['a', 'c']</span></span><br><span class="line"><span class="keyword">type</span> result = [<span class="string">'a'</span>, ...([<span class="string">'b'</span>] | [<span class="string">'c'</span>])]</span><br></pre></td></tr></table></figure></li></ul><h3 id="CheckRepeatedChars-是否包含相同字符"><a href="#CheckRepeatedChars-是否包含相同字符" class="headerlink" title="CheckRepeatedChars(是否包含相同字符)"></a>CheckRepeatedChars(是否包含相同字符)</h3><p><link-and-solution num="9142"></link-and-solution></p><h4 id="用法-82"><a href="#用法-82" class="headerlink" title="用法"></a>用法</h4><p><code>CheckRepeatedChars</code>是用来检查字符串中是否存在重复字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false </span></span><br><span class="line"><span class="keyword">type</span> result1 = CheckRepeatedChars&lt;<span class="string">'abc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = CheckRepeatedChars&lt;<span class="string">'abb'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-82"><a href="#实现方式-82" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckRepeatedChars&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : CheckRepeatedChars&lt;Last&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>${string}${First}${string}</code>：表示字符串包含<code>First</code>，也可以用<code>infer</code>来代替：<code>${infer Left}${First}${infer Right}</code>。</li></ul><h3 id="FirstUniqueCharIndex-字符串中第一个唯一字符"><a href="#FirstUniqueCharIndex-字符串中第一个唯一字符" class="headerlink" title="FirstUniqueCharIndex(字符串中第一个唯一字符)"></a>FirstUniqueCharIndex(字符串中第一个唯一字符)</h3><p><link-and-solution num="9286"></link-and-solution></p><h4 id="用法-83"><a href="#用法-83" class="headerlink" title="用法"></a>用法</h4><p><code>FirstUniqueCharIndex</code>是用来获取字符串中第一个唯一字符的索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： 0(字符l)</span></span><br><span class="line"><span class="keyword">type</span> result1 = FirstUniqueCharIndex&lt;<span class="string">'leetcode'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result2 = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-83"><a href="#实现方式-83" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>CheckRepeatedChars</code>的实现思路，很容易实现<code>FirstUniqueCharIndex</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FirstUniqueCharIndex&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? <span class="number">-1</span></span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? First <span class="keyword">extends</span> R[<span class="built_in">number</span>]</span><br><span class="line">      ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">      : Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">        ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">        : R[<span class="string">'length'</span>]</span><br><span class="line">    : <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>代码详解：此题的实现思路和<code>FirstUniqueCharIndex</code>类似，只是多了一层判断，以上面案例为例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代时：S = loveleetcode R = [] R[number] = never First = l</span></span><br><span class="line">=&gt; <span class="string">'l'</span> <span class="keyword">extends</span> never 不满足，<span class="string">'oveleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>l<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代时：S = oveleetcode R = ['l'] R[number] = 'l' First = o</span></span><br><span class="line">=&gt; <span class="string">'o'</span> <span class="keyword">extends</span> <span class="string">'l'</span> 不满足，<span class="string">'veleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>o<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代时：S = veleetcode R = ['l', '0'] R[number] = 'l' | 'o' First = v</span></span><br><span class="line">=&gt; <span class="string">'v'</span> <span class="keyword">extends</span> <span class="string">'l'</span> | <span class="string">'o'</span> 不满足，<span class="string">'eleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>v<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>不满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：R['length']</span></span><br><span class="line">=&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="ParseUrlParams-解析url路径参数"><a href="#ParseUrlParams-解析url路径参数" class="headerlink" title="ParseUrlParams(解析url路径参数)"></a>ParseUrlParams(解析url路径参数)</h3><p><link-and-solution num="9616"></link-and-solution></p><h4 id="用法-84"><a href="#用法-84" class="headerlink" title="用法"></a>用法</h4><p><code>ParseUrlParams</code>是用来解析<code>url</code>上参数名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'id' | 'user'</span></span><br><span class="line"><span class="keyword">type</span> result = ParseUrlParams&lt;<span class="string">'posts/:id/:user'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-84"><a href="#实现方式-84" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseUrlParams&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>:<span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span>/<span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">    ? Left | ParseUrlParams&lt;Right&gt;</span><br><span class="line">    : Last</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure><h3 id="GetMiddleElement-数组中位数"><a href="#GetMiddleElement-数组中位数" class="headerlink" title="GetMiddleElement(数组中位数)"></a>GetMiddleElement(数组中位数)</h3><p><link-and-solution num="9896"></link-and-solution></p><h4 id="用法-85"><a href="#用法-85" class="headerlink" title="用法"></a>用法</h4><p><code>GetMiddleElement</code>是用来取数组中位数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result2 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-85"><a href="#实现方式-85" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMiddleElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Middle, <span class="built_in">any</span>]</span><br><span class="line">    ? GetMiddleElement&lt;Middle&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[&#39;length&#39;] extends 0 | 1 | 2</code>：当数组长度小于等于而时，其中位数就是自身。</li><li><code>T extends [any, ...infer Middle, any]</code>: 当长度大于2时，每次迭代去掉首、尾元素，直至数组长度小于等于2，返回。</li></ul><h3 id="FindOnlyElements-数组只出现一次的元素"><a href="#FindOnlyElements-数组只出现一次的元素" class="headerlink" title="FindOnlyElements(数组只出现一次的元素)"></a>FindOnlyElements(数组只出现一次的元素)</h3><p><link-and-solution num="9898"></link-and-solution></p><h4 id="用法-86"><a href="#用法-86" class="headerlink" title="用法"></a>用法</h4><p><code>FindOnlyElements</code>是用来获取数组中只出现一次的元素，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [1]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-86"><a href="#实现方式-86" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindOnlyElements&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> [...U, ...Last][<span class="built_in">number</span>]</span><br><span class="line">    ? FindOnlyElements&lt;Last, [...U, First], R&gt;</span><br><span class="line">    : FindOnlyElements&lt;Last, [...U, First], [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><h3 id="CountArrayElement-计数数组中元素出现的次数"><a href="#CountArrayElement-计数数组中元素出现的次数" class="headerlink" title="CountArrayElement(计数数组中元素出现的次数)"></a>CountArrayElement(计数数组中元素出现的次数)</h3><p><link-and-solution num="9989"></link-and-solution></p><h4 id="用法-87"><a href="#用法-87" class="headerlink" title="用法"></a>用法</h4><p><code>CountArrayElement</code>是用来实现计算数组中元素出现次数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1: &#123; 1: 1, 2: 1, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result1 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2: &#123; 1: 2, 2: 2, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-87"><a href="#实现方式-87" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? [First] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? Flatten&lt;Last, R&gt; </span><br><span class="line">    : First <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? Flatten&lt;Last, [...R, ...Flatten&lt;First&gt;]&gt;</span><br><span class="line">      : Flatten&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjectCount&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">any</span>[]&gt; = &#123;&#125;</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> keyof R</span><br><span class="line">    ? ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [...R[First], <span class="number">0</span>]&gt;&gt;</span><br><span class="line">    : ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [<span class="number">0</span>]&gt;&gt;</span><br><span class="line">  : &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof R]: R[P][<span class="string">'length'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountArrayElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = ObjectCount&lt;Flatten&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Flatten</code>：实现<code>Flatten</code>，用来处理传递多维数组的情况，例如：<code>CountArrayElement&lt;[1, [1, 2], 3, [4, [5]]]&gt;</code></li><li><code>First extends keyof R</code>: 如果当前数组的遍历项是<code>R</code>对象中的一个键，则表明需要计数加一；如果不是，则代表是新项，需要计数为1；</li><li><code>[P in keyof R]: R[P][&#39;length&#39;]</code>: 因为最后结果需要返回数组，而非数组，所以迭代<code>R</code>对象，返回其每个属性的数组长度即可。</li></ul><h3 id="Integer-数字整数"><a href="#Integer-数字整数" class="headerlink" title="Integer(数字整数)"></a>Integer(数字整数)</h3><p><link-and-solution num="10969"></link-and-solution></p><h4 id="用法-88"><a href="#用法-88" class="headerlink" title="用法"></a>用法</h4><p><code>Integer</code>是用来返回数字的整数部分的，如果传入的数子包含小数，则返回<code>never</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：1</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1.1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-88"><a href="#实现方式-88" class="headerlink" title="实现方式"></a>实现方式</h4><p>根据<code>JavaScript</code>中<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">BigInt</a>的用法，其不能包含小数。所以实现方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;bigint&#125;</span>`</span> ? T : never</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>${T}</code> extends <code>${bigint}</code>：这里转成字符串形式比较，不能直接比较，因为<code>number</code>和<code>bigint</code>是两个不同的类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：都是false</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">number</span> <span class="keyword">extends</span> bigint ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = bigint <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ToPrimitive-转化基本类型"><a href="#ToPrimitive-转化基本类型" class="headerlink" title="ToPrimitive(转化基本类型)"></a>ToPrimitive(转化基本类型)</h3><p><link-and-solution num="16259"></link-and-solution></p><h4 id="用法-89"><a href="#用法-89" class="headerlink" title="用法"></a>用法</h4><p><code>ToPrimitive</code>是用来返回一个对象的类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonInfo = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">  married: <span class="literal">false</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="string">'123456'</span></span><br><span class="line">    phone: <span class="string">'13111111111'</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="string">'sing'</span>, <span class="string">'dance'</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="string">'test'</span>]</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  married: <span class="built_in">boolean</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="built_in">string</span></span><br><span class="line">    phone: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="built_in">string</span>]</span><br><span class="line">  fn: <span class="built_in">Function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = ToPrimitive&lt;PersonInfo&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-89"><a href="#实现方式-89" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToPrimitive&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> object</span><br><span class="line">  ? T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">    ? <span class="built_in">Function</span></span><br><span class="line">    : &#123; [P <span class="keyword">in</span> keyof T]: ToPrimitive&lt;T[P]&gt; &#125;</span><br><span class="line">  : T <span class="keyword">extends</span> &#123; valueOf: <span class="function"><span class="params">()</span> =&gt;</span> infer R &#125; ? R : T</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>对于函数来说：当满足<code>T extends (...args: any[]) =&gt; any</code>条件时，直接返回<code>Function</code>。</li><li>对于嵌套对象来说，递归调用<code>ToPrimitive</code>即可。</li><li>对于普通类型来说，判断其是否满足<code>T extends { valueOf: () =&gt; infer R }</code>，是则返回其类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的valueOf是js中的valueOf一样</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(num.valueOf()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="DeepMutable-深度Mutable"><a href="#DeepMutable-深度Mutable" class="headerlink" title="DeepMutable(深度Mutable)"></a>DeepMutable(深度Mutable)</h3><p><link-and-solution num="17973"></link-and-solution></p><h4 id="用法-90"><a href="#用法-90" class="headerlink" title="用法"></a>用法</h4><p><code>DeepMutable</code>是用来深度移除属性<code>readonly</code>修饰符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Test &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span></span><br><span class="line">  readonly description: <span class="built_in">string</span></span><br><span class="line">  readonly completed: <span class="built_in">boolean</span></span><br><span class="line">  readonly meta: &#123;</span><br><span class="line">    readonly author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Expected &#123;</span><br><span class="line">  title: <span class="built_in">string</span></span><br><span class="line">  description: <span class="built_in">string</span></span><br><span class="line">  completed: <span class="built_in">boolean</span></span><br><span class="line">  meta: &#123;</span><br><span class="line">    author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = DeepMutable&lt;Test&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-90"><a href="#实现方式-90" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepMutable&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; - readonly [P <span class="keyword">in</span> keyof T]: DeepMutable&lt;T[P]&gt; &#125;</span><br></pre></td></tr></table></figure><h3 id="AllMatch-数组元素是否与给定元素完全相同"><a href="#AllMatch-数组元素是否与给定元素完全相同" class="headerlink" title="AllMatch(数组元素是否与给定元素完全相同)"></a>AllMatch(数组元素是否与给定元素完全相同)</h3><p><link-and-solution num="18142"></link-and-solution></p><h4 id="用法-91"><a href="#用法-91" class="headerlink" title="用法"></a>用法</h4><p><code>AllMatch</code>是用来判断，数组元素是否与给定元素完全相同的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-91"><a href="#实现方式-91" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑边界情况，简易实现方法</span></span><br><span class="line"><span class="keyword">type</span> errTest1 = AllMatch&lt;[<span class="built_in">any</span>], unknown&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest2 = AllMatch&lt;[unknown], <span class="built_in">any</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest3 = AllMatch&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> U</span><br><span class="line">? <span class="literal">true</span></span><br><span class="line">: <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑边界情况：完整实现</span></span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? AllMatch&lt;Rest, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  : <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Filter-数组过滤"><a href="#Filter-数组过滤" class="headerlink" title="Filter(数组过滤)"></a>Filter(数组过滤)</h3><p><link-and-solution num="18220"></link-and-solution></p><h4 id="用法-92"><a href="#用法-92" class="headerlink" title="用法"></a>用法</h4><p><code>Filter</code>是用来实现数组过滤方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-92"><a href="#实现方式-92" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Filter&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> P</span><br><span class="line">    ? [First, ...Filter&lt;Rest, P&gt;]</span><br><span class="line">    : Filter&lt;Rest, P&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><h3 id="FindAllIndex-查找数组中给定元素所有索引"><a href="#FindAllIndex-查找数组中给定元素所有索引" class="headerlink" title="FindAllIndex(查找数组中给定元素所有索引)"></a>FindAllIndex(查找数组中给定元素所有索引)</h3><p><link-and-solution num="21104"></link-and-solution></p><h4 id="用法-93"><a href="#用法-93" class="headerlink" title="用法"></a>用法</h4><p><code>FindAllIndex</code>是用来返回字符串中所有匹配索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[11]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[2, 13]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'pe'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：[]</span></span><br><span class="line"><span class="keyword">type</span> result3 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">''</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-93"><a href="#实现方式-93" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindAll&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? []</span><br><span class="line">  : T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      ? FindAll&lt;Last, P, [...R, I[<span class="string">'length'</span>]], [...I, <span class="number">0</span>]&gt;</span><br><span class="line">      : FindAll&lt;Last, P, R, [...I, <span class="number">0</span>]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>I extends any[] = []</code>: 设置索引，字符串每迭代移除，<code>I</code>数组长度增加一。</li><li><code>T extends ${P}${string}</code>: 当满足条件时，向结果数组<code>R</code>中添加当前索引即可。</li></ul><h3 id="CombKeys-组合键"><a href="#CombKeys-组合键" class="headerlink" title="CombKeys(组合键)"></a>CombKeys(组合键)</h3><p><link-and-solution num="21106"></link-and-solution></p><h4 id="用法-94"><a href="#用法-94" class="headerlink" title="用法"></a>用法</h4><p><code>CombKeys</code>是用来实现组合键的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'cmd ctrl' | 'cmd opt' | 'cmd fn' | 'ctrl opt' | 'ctrl fn' | 'opt fn'</span></span><br><span class="line"><span class="keyword">type</span> result = CombKeys&lt;[<span class="string">'cmd'</span>, <span class="string">'ctrl'</span>, <span class="string">'opt'</span>, <span class="string">'fn'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-94"><a href="#实现方式-94" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CombKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span>, ...infer Last <span class="keyword">extends</span> <span class="built_in">string</span>[]]</span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;First&#125;</span> <span class="subst">$&#123;Last[<span class="built_in">number</span>]&#125;</span>`</span> | CombKeys&lt;Last&gt;</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure><h3 id="ReplaceFirst-替换元组中第一个匹配项"><a href="#ReplaceFirst-替换元组中第一个匹配项" class="headerlink" title="ReplaceFirst(替换元组中第一个匹配项)"></a>ReplaceFirst(替换元组中第一个匹配项)</h3><p><link-and-solution num="25170"></link-and-solution></p><h4 id="用法-95"><a href="#用法-95" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceFirst</code>是用来替换元组中第一个匹配项，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceFirst&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-95"><a href="#实现方式-95" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceFirst&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly unknown[],</span><br><span class="line">  From,</span><br><span class="line">  To</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> From</span><br><span class="line">    ? [To, ...Rest]</span><br><span class="line">    : [First, ...ReplaceFirst&lt;Rest, From, To&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><h3 id="SimpleVue-简单Vue类型"><a href="#SimpleVue-简单Vue类型" class="headerlink" title="SimpleVue(简单Vue类型)"></a>SimpleVue(简单Vue类型)</h3><p><link-and-solution num="6"></link-and-solution></p><h4 id="用法-96"><a href="#用法-96" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-96"><a href="#实现方式-96" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Currying-柯里化"><a href="#Currying-柯里化" class="headerlink" title="Currying(柯里化)"></a>Currying(柯里化)</h3><p><link-and-solution num="17"></link-and-solution></p><p>在<code>JavaScript</code>中<code>Currying</code>是用来实现函数柯里化的，其用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> three = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = Currying(add)</span><br><span class="line"><span class="keyword">const</span> five = curriedAdd(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h4 id="用法-97"><a href="#用法-97" class="headerlink" title="用法"></a>用法</h4><p><code>Currying</code>是用来实现<code>JavaScript</code>中的柯里化的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = Currying(<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span>, c: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 结果：(a: string) =&gt; (a: number) =&gt; (a: boolean) =&gt; true</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> func</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-97"><a href="#实现方式-97" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CurryFunction&lt;</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">  ? <span class="function"><span class="params">()</span> =&gt;</span> R</span><br><span class="line">  : P <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="function">(<span class="params">a: First</span>) =&gt;</span> R</span><br><span class="line">      : <span class="function">(<span class="params">a: First</span>) =&gt;</span> CurryFunction&lt;Rest, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Currying</span>&lt;<span class="title">F</span>&gt;(<span class="params">fn: F</span>):</span></span><br><span class="line"><span class="function">  <span class="title">F</span> <span class="title">extends</span> (<span class="params">...args: infer P</span>) =&gt; <span class="title">infer</span> <span class="title">R</span></span></span><br><span class="line"><span class="function">  ? <span class="title">CurryFunction</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="function">  : <span class="title">never</span></span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>P</code>：<code>P</code>为调用<code>Currying</code>函数时传递函数参数的参数数组，以上面为例，其值为：<code>[number, string, boolean]</code>。</li><li><code>P extends [infer First, ...infer Rest]</code>: 遍历参数列表，依次返回一个函数即可。</li></ul><h3 id="UnionToIntersection-元组取交集"><a href="#UnionToIntersection-元组取交集" class="headerlink" title="UnionToIntersection(元组取交集)"></a>UnionToIntersection(元组取交集)</h3><p><link-and-solution num="55"></link-and-solution></p><p>在实现<code>UnionToIntersection</code>之前，我们先来回顾一下<code>TS</code>中<code>&amp;</code>符号的作用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="number">1</span> &amp; <span class="string">'foo'</span> &amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; &amp; &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = <span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) &amp; (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)</span></span><br></pre></td></tr></table></figure></p><p>案例解析：</p><ul><li>案例一：因为<code>1</code>、<code>foo</code>以及<code>true</code>，没有交集部分，所以这里结果为<code>never</code>。</li><li>案例二：对于<code>a</code>和<code>c</code>属性而言，它们只存在于自身类型，所以交集部分是自身；对于<code>b</code>属性而言，它在两个类型中都存在，且其属性的类型存在交集部分，既：<code>number</code>。</li><li>案例三：对于函数的交叉类型，我们从函数参数、函数返回值这两个部分来说明。对于函数参数而言，取其联合类型；对于函数返回值而言，取其交叉类型。</li></ul><p>从以上几个案例中可以看出，<code>TS</code>中的<code>&amp;</code>符号是取交集的意思，也叫<strong>交叉类型</strong>。</p><h4 id="用法-98"><a href="#用法-98" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToIntersection</code>所做的事情和<code>&amp;</code>符号是一样的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToIntersection&lt;<span class="number">1</span> | <span class="string">'foo'</span> | <span class="literal">true</span>&gt;</span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToIntersection&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; | &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;&gt;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToIntersection&lt;<span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) | (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-98"><a href="#实现方式-98" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>U extends any ? X : Y</code>： 这里把<code>U</code>类型处理成<code>(x: U) =&gt; any</code>的函数类型。</li><li><code>T extends (x: infer V) =&gt; any ? V : never</code>：这里的<code>T</code>就是上一步的函数类型，如果<code>extends</code>成立，则返回<code>V</code>，此时的<code>V</code>必然满足<code>U &amp; V</code>。</li></ul><h3 id="RequiredKeys-所有必填字段"><a href="#RequiredKeys-所有必填字段" class="headerlink" title="RequiredKeys(所有必填字段)"></a>RequiredKeys(所有必填字段)</h3><p><link-and-solution num="89"></link-and-solution></p><h4 id="用法-99"><a href="#用法-99" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredKeys</code>是用来返回一个类型中所有必填字段，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-99"><a href="#实现方式-99" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequiredKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? never : P)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>{} extends Pick&lt;T, P&gt; ? never : P</code>：是用来判断当前遍历键是否可选键的。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> result = &#123;&#125; <span class="keyword">extends</span> &#123;&#125; | &#123; sex: <span class="literal">undefined</span> &#125; ? never : <span class="string">'sex'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="GetRequired-必填字段组成的类型"><a href="#GetRequired-必填字段组成的类型" class="headerlink" title="GetRequired(必填字段组成的类型)"></a>GetRequired(必填字段组成的类型)</h3><p><link-and-solution num="57"></link-and-solution></p><h4 id="用法-100"><a href="#用法-100" class="headerlink" title="用法"></a>用法</h4><p><code>GetRequired</code>是用来取一个类型中那些由必填字段组成的一个新类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; age: number; sex: undefined; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-100"><a href="#实现方式-100" class="headerlink" title="实现方式"></a>实现方式</h4><p>按照<code>RequiredKeys</code>的实现思路，能够很容易的实现<code>GetRequired</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? P : never)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>T[P] extends Required&lt;T&gt;[P] ? P : never</code>：用来判断当前遍历键的类型是否一致，一致则是必填类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P为name时</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">string</span> | <span class="literal">undefined</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">'name'</span> : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// P为age时</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="OptionalKeys-所有可选字段"><a href="#OptionalKeys-所有可选字段" class="headerlink" title="OptionalKeys(所有可选字段)"></a>OptionalKeys(所有可选字段)</h3><p><link-and-solution num="90"></link-and-solution></p><p><code>OptionalKeys</code>和<code>RequiredKeys</code>所做的事情相反，其获取的是所有可选字段。</p><h4 id="用法-101"><a href="#用法-101" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'sex' | 'address'</span></span><br><span class="line"><span class="keyword">type</span> result = OptionalKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-101"><a href="#实现方式-101" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionalKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? P : never)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：从上面代码中可以看出，它和<code>RequiredKeys</code>实现思路是一样的，区别只是在<code>extends</code>关键词后面的处理不同。</p><h3 id="GetOptional-可选字段组成的类型"><a href="#GetOptional-可选字段组成的类型" class="headerlink" title="GetOptional(可选字段组成的类型)"></a>GetOptional(可选字段组成的类型)</h3><p><link-and-solution num="59"></link-and-solution></p><h4 id="用法-102"><a href="#用法-102" class="headerlink" title="用法"></a>用法</h4><p>按照<code>OptionalKeys</code>的实现思路，能够很容易的实现<code>GetOptional</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; sex?: undefined; address?: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetOptional&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-102"><a href="#实现方式-102" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetOptional&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? never : P)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CapitalizeWords-所有单词首字母大写"><a href="#CapitalizeWords-所有单词首字母大写" class="headerlink" title="CapitalizeWords(所有单词首字母大写)"></a>CapitalizeWords(所有单词首字母大写)</h3><p><link-and-solution num="112"></link-and-solution></p><h4 id="用法-103"><a href="#用法-103" class="headerlink" title="用法"></a>用法</h4><p><code>CapitalizeWords</code>是用来把一个字符串中所有单词，变为大写字母的，其中这个字符串以固定的分隔符分割，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'Foobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = CapitalizeWords&lt;<span class="string">'foobar'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'Foo Bar.Hello,World'</span></span><br><span class="line"><span class="keyword">type</span> t2 = CapitalizeWords&lt;<span class="string">'foo bar.hello,world'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-103"><a href="#实现方式-103" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CapitalizeWords&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Uppercase&lt;First&gt; <span class="keyword">extends</span> Lowercase&lt;First&gt;</span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;Rest&gt;&#125;</span>`</span></span><br><span class="line">    : CapitalizeWords&lt;Rest, <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;</span><br><span class="line">  : Capitalize&lt;R&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Uppercase&lt;First&gt; extends Lowercase&lt;First&gt;</code>：为了找到连串的大写字符串，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S = foo bar.hello,world</span></span><br><span class="line">R = <span class="string">'foo'</span> First = <span class="string">' '</span> Rest = <span class="string">'bar.hello,world'</span></span><br><span class="line">=&gt; <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`foo `</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&gt;&#125;</span>`</span></span><br><span class="line">=&gt; <span class="string">`Foo <span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&#125;</span>`</span></span><br><span class="line">=&gt; ...</span><br><span class="line">=&gt; <span class="string">'Foo Bar.Hello,World'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CamelCase-下划线字符串转小驼峰"><a href="#CamelCase-下划线字符串转小驼峰" class="headerlink" title="CamelCase(下划线字符串转小驼峰)"></a>CamelCase(下划线字符串转小驼峰)</h3><p><link-and-solution num="114"></link-and-solution></p><h4 id="用法-104"><a href="#用法-104" class="headerlink" title="用法"></a>用法</h4><p>与<strong>中级</strong>章节实现不同，此章节中<code>CamelCase</code>是用来将下划线字符串转小驼峰的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'fooBarHelloWorld'</span></span><br><span class="line"><span class="keyword">type</span> result = CamelCase&lt;<span class="string">'foo_bar_hello_world'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-104"><a href="#实现方式-104" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsLetter&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Uppercase&lt;S&gt; <span class="keyword">extends</span> Lowercase&lt;S&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> CamelCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? CamelCase&lt;</span><br><span class="line">      Rest,</span><br><span class="line">      IsLetter&lt;First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? R <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer P&#125;</span>_`</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;Uppercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;Lowercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span></span><br><span class="line">    &gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>IsLetter</code>: 用来判断是否为字母的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsLetter&lt;<span class="string">'$'</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsLetter&lt;<span class="string">'A'</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>IsLetter&lt;L&gt; extends true</code>: 如果是字母的话，则根据是否以下划线结尾，如果是，则只需要紧邻下划线的字母<code>L</code>大写即可，否小写。</p></li></ul><h3 id="ParsePrintFormat-获取字符串格式化参数"><a href="#ParsePrintFormat-获取字符串格式化参数" class="headerlink" title="ParsePrintFormat(获取字符串格式化参数)"></a>ParsePrintFormat(获取字符串格式化参数)</h3><p><link-and-solution num="147"></link-and-solution></p><h4 id="用法-105"><a href="#用法-105" class="headerlink" title="用法"></a>用法</h4><p><code>ParsePrintFormat</code>是用来获取字符串格式化参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数映射表</span></span><br><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['string', 'dec']</span></span><br><span class="line"><span class="keyword">type</span> result = ParsePrintFormat&lt;<span class="string">'Hello %s: score is %d'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-105"><a href="#实现方式-105" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Char <span class="keyword">extends</span> keyof ControlMap</span><br><span class="line">      ? ParsePrintFormat&lt;S2, [...R, ControlMap[Char]]&gt;</span><br><span class="line">      : ParsePrintFormat&lt;S2, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="comment">// way2: 不借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Char <span class="keyword">extends</span> keyof ControlsMap</span><br><span class="line">    ? [ControlsMap[Char], ...ParsePrintFormat&lt;Rest&gt;]</span><br><span class="line">    : ParsePrintFormat&lt;Rest&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>代码详解：在以上实现方法中，借用了辅助数组的思想，拿上面案例来说，具体迭代分析如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">S满足条件 R = [] S1 = <span class="string">'Hello '</span> Char = <span class="string">'s'</span> S2 = <span class="string">': score is %d'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">S满足条件 R = [<span class="string">'string'</span>]  S1 = <span class="string">': score is '</span> Char = <span class="string">'d'</span> S2 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次迭代</span></span><br><span class="line">S不满足条件 R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">result = R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="VueBasicProps-Vue的Props类型"><a href="#VueBasicProps-Vue的Props类型" class="headerlink" title="VueBasicProps(Vue的Props类型)"></a>VueBasicProps(Vue的Props类型)</h3><p><link-and-solution num="213"></link-and-solution></p><h4 id="用法-106"><a href="#用法-106" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-106"><a href="#实现方式-106" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsAny和NotAny"><a href="#IsAny和NotAny" class="headerlink" title="IsAny和NotAny"></a>IsAny和NotAny</h3><p><link-and-solution num="223"></link-and-solution></p><h4 id="用法-107"><a href="#用法-107" class="headerlink" title="用法"></a>用法</h4><p><code>IsAny</code>是用来判断一个类型是否为<code>any</code>的，<code>NotAny</code>和它做的事情相反。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = IsAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t2 = IsAny&lt;never&gt;     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t3 = IsAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t4 = NotAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t5 = NotAny&lt;never&gt;     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t6 = NotAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-107"><a href="#实现方式-107" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsAny&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> (<span class="number">1</span> &amp; T) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> NotAny&lt;T&gt; = <span class="literal">true</span> <span class="keyword">extends</span> IsAny&lt;T&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：<code>1 &amp; T</code>的结果只能是：<code>1</code>、<code>never</code>或者<code>any</code>。当使用<code>0 extends</code>这三个结果的时候，只有<code>any</code>判断为真。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="number">0</span> <span class="keyword">extends</span> never ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="number">0</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="Get-字符串路径取值"><a href="#Get-字符串路径取值" class="headerlink" title="Get(字符串路径取值)"></a>Get(字符串路径取值)</h3><p><link-and-solution num="270"></link-and-solution></p><h4 id="用法-108"><a href="#用法-108" class="headerlink" title="用法"></a>用法</h4><p><code>Get</code>是用来进行字符串路径取值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      value: <span class="string">'foobar'</span>,</span><br><span class="line">      count: <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    include: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'foo.baz'</span>: <span class="literal">false</span></span><br><span class="line">  hello: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：world</span></span><br><span class="line"><span class="keyword">type</span> t1 = Get&lt;Data, <span class="string">'hello'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：foobar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Get&lt;Data, <span class="string">'foo.bar.value'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t3 = Get&lt;Data, <span class="string">'foo.baz'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> t4 = Get&lt;Data, <span class="string">'no.exits'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-108"><a href="#实现方式-108" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Get&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = K <span class="keyword">extends</span> keyof T</span><br><span class="line">  ? T[K]</span><br><span class="line">  : K <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line">    : T[K &amp; keyof T]</span><br></pre></td></tr></table></figure><p>代码详解：对于<code>Get</code>的实现，主要分为两部分：含有<code>.</code>符号的字符串和不含<code>.</code>符号的字符串。</p><ul><li><p>含有<code>.</code>符号的字符串：对于这种情况，我们先判断<code>.</code>符号左侧部分是否满足为<code>T</code>类型的某个<code>key</code>，如果满足，则递归调用<code>Get</code>；如果不满足，则直接返回<code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1如果是T的属性键，则返回S1；如果不是，则返回never</span></span><br><span class="line">Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S1 <span class="keyword">extends</span> keyof T ? Get&lt;T[S1], S2&gt; : never</span><br></pre></td></tr></table></figure></li><li><p>不含有<code>.</code>符号的字符串：对于这种情况，我们只需要判断它是否为<code>T</code>类型中的某个<code>key</code>，如果是，则直接取值；如果不是，则返回<code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K如果是T的属性键，则返回K；如果不是，则返回never</span></span><br><span class="line">T[K &amp; keyof T]</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S <span class="keyword">extends</span> keyof T ? T[S] : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="StringToNumber-字符串数字转数字"><a href="#StringToNumber-字符串数字转数字" class="headerlink" title="StringToNumber(字符串数字转数字)"></a>StringToNumber(字符串数字转数字)</h3><p><link-and-solution num="300"></link-and-solution></p><h4 id="用法-109"><a href="#用法-109" class="headerlink" title="用法"></a>用法</h4><p><code>StringToNumber</code>是用来将字符串形式的数字转换成真正数字类型数字的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：123</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-109"><a href="#实现方式-109" class="headerlink" title="实现方式"></a>实现方式</h4><p>在<code>JavaScript</code>中，我们可以很方便的调用<code>Number()</code>方法或者<code>parseInt()</code>方法来将字符串类型的数字，转换成数字类型的数字。但在<code>TS</code>中，并没有这样的方法，需要我们来手动实现。</p><p><code>StringToNumber</code>的实现并不容易理解，我们需要将其进行拆分，一步步来完善，其实现思路如下：</p><ul><li><p>第一步：可以很容易获取字符串<code>&#39;123&#39;</code>中每一位字符，我们将其存储在辅助数组<code>T</code>中，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? StringToNumber&lt;S2, [...T, S1]&gt;</span><br><span class="line">    : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['1', '2', '3']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二步：我们需要将单个字符串类型的数字，转换成真正数字类型的数字，可以借助中间数组来帮忙，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> =&gt; [<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">1</span></span><br><span class="line"><span class="string">'2'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">2</span></span><br><span class="line"><span class="string">'3'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'9'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure></li></ul><p>根据以上规律，我们封装一个<code>MakeArray</code>方法，它的实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t1 = MakeArray&lt;<span class="string">'1'</span>&gt; <span class="comment">// [0]</span></span><br><span class="line"><span class="keyword">type</span> t2 = MakeArray&lt;<span class="string">'2'</span>&gt; <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="keyword">type</span> t3 = MakeArray&lt;<span class="string">'3'</span>&gt; <span class="comment">// [0, 0, 0]</span></span><br></pre></td></tr></table></figure></p><ul><li>第三步：现在有了百位，十位和个位的数字，我们应该运用算术把它们按照一定的规律累加起来，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> target = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">1</span> + <span class="number">2</span> = <span class="number">12</span></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">12</span> + <span class="number">3</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">// 迭代规律</span></span><br><span class="line">target = <span class="number">10</span> * target + N</span><br></pre></td></tr></table></figure></li></ul><p>根据以上思路，我们还需要一个乘十的工具函数，对应到实际需求，就是需要把一个数组<code>copy</code>十次，因此我们封装一个<code>Multiply10</code>工具，其实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result = Multiply10&lt;[<span class="number">1</span>]&gt; <span class="comment">// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></span><br></pre></td></tr></table></figure></p><ul><li><p>第四步：根据前几步的分析，把所有东西串联起来，<code>StringToNumber</code>完整实现代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Digital = <span class="string">'0'</span>|<span class="string">'1'</span>|<span class="string">'2'</span>|<span class="string">'3'</span>|<span class="string">'4'</span>|<span class="string">'5'</span>|<span class="string">'6'</span>|<span class="string">'7'</span>|<span class="string">'8'</span>|<span class="string">'9'</span></span><br><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> Digital</span><br><span class="line">      ? StringToNumber&lt;S2, [...Multiply10&lt;T&gt;, ...MakeArray&lt;S1&gt;]&gt;</span><br><span class="line">      : never</span><br><span class="line">    : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></li><li><p>第五步：为了更好的理解递归的过程，我们拆解成如下步骤来说明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'123'</span> S1 = <span class="string">'1'</span> S2 = <span class="string">'23'</span> T = [<span class="number">0</span>] T[<span class="string">'length'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'23'</span>  S1 = <span class="string">'2'</span> S2 = <span class="string">'3'</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'3'</span>  S1 = <span class="string">'3'</span> S2 = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次递归，S不满足$&#123;infer S1&#125;$&#123;infer S2&#125; T['length']取值</span></span><br><span class="line">S = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="FilterOut-数组元素过滤"><a href="#FilterOut-数组元素过滤" class="headerlink" title="FilterOut(数组元素过滤)"></a>FilterOut(数组元素过滤)</h3><p><link-and-solution num="399"></link-and-solution></p><h4 id="用法-110"><a href="#用法-110" class="headerlink" title="用法"></a>用法</h4><p><code>FilterOut</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[2]</span></span><br><span class="line"><span class="keyword">type</span> result = FilterOut&lt;[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>], <span class="string">'a'</span> | <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-110"><a href="#实现方式-110" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterOut&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer R, ...infer args]</span><br><span class="line">      ? [R] <span class="keyword">extends</span> [F]</span><br><span class="line">        ? FilterOut&lt;args, F, [...K]&gt;</span><br><span class="line">        : FilterOut&lt;args, F, [...K, R]&gt;</span><br><span class="line">      : K</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>第一步：我们借用赋值函数来存放最后的结果。</li><li>第二步：迭代数组<code>T</code>，拿每一个元素去和指定的<code>F</code>进行判断，如果<code>R</code>是<code>F</code>的子类型，则不添加此元素到结果数组中，反之添加。</li><li>第三步：当迭代完毕时，直接返回结果数组<code>K</code>。</li></ul><h3 id="TupleToEnum-元组转枚举"><a href="#TupleToEnum-元组转枚举" class="headerlink" title="TupleToEnum(元组转枚举)"></a>TupleToEnum(元组转枚举)</h3><p><link-and-solution num="472"></link-and-solution></p><h4 id="用法-111"><a href="#用法-111" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToEnum</code>是用来将元组转换为枚举的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OperatingSystem = [<span class="string">'macOs'</span>, <span class="string">'Windows'</span>, <span class="string">'Linux'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> Expected1 = &#123;</span><br><span class="line">  readonly MacOs: <span class="string">'macOs'</span>;</span><br><span class="line">  readonly Windows: <span class="string">'Windows'</span>;</span><br><span class="line">  readonly Linux: <span class="string">'Linux'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected2 = &#123;</span><br><span class="line">  readonly MacOs: <span class="number">0</span>;</span><br><span class="line">  readonly Windows: <span class="number">1</span>;</span><br><span class="line">  readonly Linux: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> result1 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> result2 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem, <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-111"><a href="#实现方式-111" class="headerlink" title="实现方式"></a>实现方式</h4><p>在实现<code>TupleToEnum</code>之前，我们先来实现<code>TupleKeys</code>，它是用来获取所有元组索引组合成的联合类型的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">      ? TupleKeys&lt;args&gt; | args[<span class="string">'length'</span>]</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：0 | 1 | 2</span></span><br><span class="line"><span class="keyword">type</span> keys = TupleKeys&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br></pre></td></tr></table></figure></p><p>在有了以上<code>keys</code>后，就能很容易实现<code>TupleToEnum</code>了，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToEnum&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">string</span>[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">&gt; = &#123;</span><br><span class="line">  readonly [K <span class="keyword">in</span> TupleKeys&lt;T&gt; <span class="keyword">as</span> Capitalize&lt;T[K]&gt;]: N <span class="keyword">extends</span> <span class="literal">true</span> ? K : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Format-字符串格式化函数类型"><a href="#Format-字符串格式化函数类型" class="headerlink" title="Format(字符串格式化函数类型)"></a>Format(字符串格式化函数类型)</h3><p><link-and-solution num="545"></link-and-solution></p><p><code>%s</code>表示格式化为<code>(x: string) =&gt; any</code>形式，<code>%d</code>表示格式化为<code>(x: number) =&gt; any</code>形式。</p><h4 id="用法-112"><a href="#用法-112" class="headerlink" title="用法"></a>用法</h4><p><code>Format</code>是将字符串格式化为指定函数类型的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：(x: string) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result1 = Format&lt;<span class="string">'a%sbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：(x: number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result2 = Format&lt;<span class="string">'a%dbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：(x: number) =&gt; (x: string) =&gt; string&gt;</span></span><br><span class="line"><span class="keyword">type</span> result3 = Format&lt;<span class="string">'a%dbc%s'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-112"><a href="#实现方式-112" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FormatMaps = &#123;</span><br><span class="line">  <span class="string">'s'</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">'d'</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Format&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer P&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? P <span class="keyword">extends</span> keyof FormatMaps</span><br><span class="line">        ? <span class="function">(<span class="params">x: FormatMaps[P]</span>) =&gt;</span> Format&lt;S2&gt;</span><br><span class="line">        : <span class="built_in">string</span></span><br><span class="line">      : <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h3 id="LengthOfString-字符串的长度-1"><a href="#LengthOfString-字符串的长度-1" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="651"></link-and-solution></p><p>我们之前在<strong>中级</strong>大章节中已经实现过<code>LengthOfString</code>，但它面临的问题是，如果字符有上百个，由于<code>TS</code>对于递归的次数存在限制，会提示嵌套过深。</p><h4 id="用法-113"><a href="#用法-113" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：91</span></span><br><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-113"><a href="#实现方式-113" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S0&#125;</span><span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span><span class="subst">$&#123;infer S3&#125;</span><span class="subst">$&#123;infer S4&#125;</span><span class="subst">$&#123;infer S5&#125;</span><span class="subst">$&#123;infer S6&#125;</span><span class="subst">$&#123;infer S7&#125;</span><span class="subst">$&#123;infer S8&#125;</span><span class="subst">$&#123;infer S9&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;Rest, [...R, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&gt;</span><br><span class="line">      : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">          ? LengthOfString&lt;S2, [...R, S1]&gt;</span><br><span class="line">          : R[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure><p>代码解析：这里我们巧妙的使用占位的思想，<code>S extends ${infer S1}${infer S2}${infer S3}</code>，如果<code>S</code>满足这个占位形式，则表示<code>S</code>的长度至少为<code>2</code>，带入到上面的例子，解析步骤如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 第二弟递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="comment">// 最后一次递归</span></span><br><span class="line">S = <span class="string">'1'</span>不满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, ....., <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 最后结果</span></span><br><span class="line">R[<span class="string">'length'</span>] = <span class="number">91</span></span><br></pre></td></tr></table></figure></p><h3 id="UnionToTuple-联合类型转元组"><a href="#UnionToTuple-联合类型转元组" class="headerlink" title="UnionToTuple(联合类型转元组)"></a>UnionToTuple(联合类型转元组)</h3><p><link-and-solution num="730"></link-and-solution></p><h4 id="用法-114"><a href="#用法-114" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToTuple</code>是用来将联合类型转成元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToTuple&lt;<span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | never&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-114"><a href="#实现方式-114" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = (</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">  ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">  : never</span><br><span class="line">) <span class="keyword">extends</span> (x: infer R) =&gt; <span class="built_in">any</span> </span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LastUnion&lt;U&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line">    : never</span><br><span class="line">&gt; <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span></span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnionToTuple&lt;</span><br><span class="line">  T,</span><br><span class="line">  Last = LastUnion&lt;T&gt;</span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? []</span><br><span class="line">  : [...UnionToTuple&lt;Exclude&lt;T, Last&gt;&gt;, Last]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>UnionToIntersection</code>: 联合类型取交集，在之前已经实现过，这里不再赘述。主要理解以下案例：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载结果</span></span><br><span class="line"><span class="comment">// function (x: 1): 0;</span></span><br><span class="line"><span class="comment">// function (x: 2): 0;</span></span><br><span class="line"><span class="keyword">type</span> result = UnionToIntersection&lt;f1 | f2&gt;</span><br></pre></td></tr></table></figure></li></ul><p>对于函数参数的交集而言，不是简单的把参数取交集，而是”联合”起来，也就是构造一个新的函数类型，即：<strong>函数重载</strong></p><ul><li><code>LastUnion</code>: 取联合类型最后的一个元素，如果一个函数存在重载的情况，<code>TS</code>会取最后一个函数签名，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：2</span></span><br><span class="line"><span class="keyword">type</span> result1 = f1 &amp; f2 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br><span class="line"><span class="comment">// 结果2：1</span></span><br><span class="line"><span class="keyword">type</span> result2 = f2 &amp; f1 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="Join-字符串拼接"><a href="#Join-字符串拼接" class="headerlink" title="Join(字符串拼接)"></a>Join(字符串拼接)</h3><p><link-and-solution num="847"></link-and-solution></p><h4 id="用法-115"><a href="#用法-115" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现拼接字符串的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： ''</span></span><br><span class="line"><span class="keyword">const</span> Expected1 = join(<span class="string">'-'</span>)();</span><br><span class="line"><span class="comment">// 结果2： 'a'</span></span><br><span class="line"><span class="keyword">const</span> Expected2 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 结果3： 'abc'</span></span><br><span class="line"><span class="keyword">const</span> Expected3 = join(<span class="string">''</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 结果4： 'a-b-c'</span></span><br><span class="line"><span class="keyword">const</span> Expected4 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-115"><a href="#实现方式-115" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tail&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt; = T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Rest] ? Rest : []</span><br><span class="line"><span class="keyword">type</span> StringJoin&lt;</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">    ? <span class="string">''</span></span><br><span class="line">    : P <span class="keyword">extends</span> [infer Only]</span><br><span class="line">      ? Only</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;P[<span class="number">0</span>]&#125;</span><span class="subst">$&#123;D&#125;</span><span class="subst">$&#123;StringJoin&lt;D, Tail&lt;P&gt;&gt;&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">D</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">delimiter: D</span>): &lt;<span class="title">P</span> <span class="title">extends</span> <span class="title">string</span>[] = []&gt;(<span class="params">...parts: P</span>) =&gt; <span class="title">StringJoin</span>&lt;<span class="title">D</span>, <span class="title">P</span>&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="DeepPick-深层次Pick"><a href="#DeepPick-深层次Pick" class="headerlink" title="DeepPick(深层次Pick)"></a>DeepPick(深层次Pick)</h3><p><link-and-solution num="956"></link-and-solution></p><h4 id="用法-116"><a href="#用法-116" class="headerlink" title="用法"></a>用法</h4><p><code>DeepPick</code>是用来深层次获取属性值的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b: <span class="built_in">string</span>,</span><br><span class="line">  c:  <span class="built_in">boolean</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    d: <span class="built_in">number</span>,</span><br><span class="line">    e: <span class="built_in">string</span>,</span><br><span class="line">    f:  <span class="built_in">boolean</span>,</span><br><span class="line">    obj2: &#123;</span><br><span class="line">      g: <span class="built_in">number</span>,</span><br><span class="line">      h: <span class="built_in">string</span>,</span><br><span class="line">      i: <span class="built_in">boolean</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：Obj</span></span><br><span class="line"><span class="keyword">type</span> result1 = DeepPick&lt;Obj, <span class="string">''</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：&#123; a: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = DeepPick&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：&#123; a: number; &#125; &amp; &#123; obj: &#123; d: number; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result3 = DeepPick&lt;Obj, <span class="string">'a'</span>, <span class="string">'obj.d'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-116"><a href="#实现方式-116" class="headerlink" title="实现方式"></a>实现方式</h4><p>在之前，我们实现过根据属性路径取值<code>Get</code>，根据其思路我们很容易实现<code>DeepPick</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetType&lt;T, S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S1]: GetType&lt;T[S1], S2&gt; &#125;</span><br><span class="line">      : never</span><br><span class="line">    : S <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S]: T[K] &#125;</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeepPick&lt;</span><br><span class="line">  T,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> infer keys ? GetType&lt;T, keys&gt; : never</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Camelize-对象属性键转小驼峰"><a href="#Camelize-对象属性键转小驼峰" class="headerlink" title="Camelize(对象属性键转小驼峰)"></a>Camelize(对象属性键转小驼峰)</h3><p><link-and-solution num="1383"></link-and-solution></p><h4 id="用法-117"><a href="#用法-117" class="headerlink" title="用法"></a>用法</h4><p><code>Camelize</code>是用来将对象中的<code>key</code>全部转换为小驼峰的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  some_PROP: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123;</span><br><span class="line">    another_prop: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snake_case: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  someProp: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123; </span><br><span class="line">    anotherProp: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snakeCase: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = Camelize&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-117"><a href="#实现方式-117" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CamelCase&lt;S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>_<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;S1&gt;&#125;</span><span class="subst">$&#123;CamelCase&lt;Capitalize&lt;Lowercase&lt;S2&gt;&gt;&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camelize&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> CamelCase&lt;K&gt;]: </span><br><span class="line">    T[K] <span class="keyword">extends</span> [infer R]</span><br><span class="line">      ? [Camelize&lt;R&gt;]</span><br><span class="line">      : T[K] <span class="keyword">extends</span> <span class="built_in">Object</span></span><br><span class="line">        ? Camelize&lt;T[K]&gt;</span><br><span class="line">        : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：<code>CamelCase</code>的实现可以分为两个部分，第一部分来自于处理属性<code>key</code>转小驼峰的情况，第二部分来自于嵌套对象的情况。</p><ul><li>处理属性<code>key</code>：根据之前介绍过的<code>as</code>用法，我们可以在<code>in</code>迭代过程中使用<code>as</code>来进一步<strong>加工或者处理</strong>属性<code>key</code>，也就是<code>CamelCase</code>的部分。</li><li>处理嵌套对象：对于<code>T[P]</code>而言，我们考虑嵌套对象为数组和普通对象的情况，首先判断是否为数组类型，如果是则迭代数组递归调用<code>Camelize</code>；如果是普通对象，则直接调用<code>Camelize</code>；如果都不是，则直接返回<code>T[P]</code>即可。</li></ul><h3 id="DropString-移除全部字符"><a href="#DropString-移除全部字符" class="headerlink" title="DropString(移除全部字符)"></a>DropString(移除全部字符)</h3><p><link-and-solution num="2059"></link-and-solution></p><h4 id="用法-118"><a href="#用法-118" class="headerlink" title="用法"></a>用法</h4><p><code>DropString</code>是用来移除全部字符的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'ooar!'</span></span><br><span class="line"><span class="keyword">type</span> result = DropString&lt;<span class="string">'foobar!'</span>, <span class="string">'fb'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-118"><a href="#实现方式-118" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrngToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 | StrngToUnion&lt;S2&gt;</span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DropString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U = StrngToUnion&lt;R&gt;</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> U</span><br><span class="line">      ? DropString&lt;S2, R&gt;</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;S1&#125;</span><span class="subst">$&#123;DropString&lt;S2, R&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br></pre></td></tr></table></figure><p>代码详解：实现<code>DropString</code>的核心是将指定的字符串转换为联合类型，转换之后只需要迭代字符串，判断当前迭代的字符是不是在联合类型中，如果是则直接丢弃，不是则原样保留。</p><h3 id="Split-字符串Split方法"><a href="#Split-字符串Split方法" class="headerlink" title="Split(字符串Split方法)"></a>Split(字符串Split方法)</h3><p><link-and-solution num="2822"></link-and-solution></p><h4 id="用法-119"><a href="#用法-119" class="headerlink" title="用法"></a>用法</h4><p><code>Split</code>是用来实现字符串<code>split</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：["Hi!", "How", "are", "you?"]</span></span><br><span class="line"><span class="keyword">type</span> result = Split&lt;<span class="string">'Hi! How are you?'</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-119"><a href="#实现方式-119" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Split&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  SEP <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer _&#125;</span>`</span></span><br><span class="line">      ? S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;SEP&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">        ? Split&lt;S2, SEP, [...R, S1]&gt;</span><br><span class="line">        : S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">          ? SEP <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">            ? R</span><br><span class="line">            : [...R, S]</span><br><span class="line">          : [...R, S]</span><br><span class="line">      : <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure><h3 id="ClassPublicKeys-类的公共键"><a href="#ClassPublicKeys-类的公共键" class="headerlink" title="ClassPublicKeys(类的公共键)"></a>ClassPublicKeys(类的公共键)</h3><p><link-and-solution num="2828"></link-and-solution></p><h4 id="用法-120"><a href="#用法-120" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-120"><a href="#实现方式-120" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsRequiredKeys-是否为必填key"><a href="#IsRequiredKeys-是否为必填key" class="headerlink" title="IsRequiredKeys(是否为必填key)"></a>IsRequiredKeys(是否为必填key)</h3><p><link-and-solution num="2857"></link-and-solution></p><h4 id="用法-121"><a href="#用法-121" class="headerlink" title="用法"></a>用法</h4><p><code>IsRequiredKeys</code>是用来判断是否为必填<code>key</code>的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsRequiredKeys&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsRequiredKeys&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-121"><a href="#实现方式-121" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsRequiredKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T <span class="keyword">extends</span> Record&lt;K, T[K]&gt; ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>根据<code>IsRequiredKey</code>的实现思路，我们可以很容易实现<code>IsOptionalKey</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsOptionalKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;&#125; <span class="keyword">extends</span> &#123; [P <span class="keyword">in</span> K]: T[P] &#125; ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsOptionalKey&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsOptionalKey&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="ObjectEntries-对象Object-entries方法"><a href="#ObjectEntries-对象Object-entries方法" class="headerlink" title="ObjectEntries(对象Object.entries方法)"></a>ObjectEntries(对象Object.entries方法)</h3><p><link-and-solution num="2949"></link-and-solution></p><h4 id="用法-122"><a href="#用法-122" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-122"><a href="#实现方式-122" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsPalindrome-是否为回文"><a href="#IsPalindrome-是否为回文" class="headerlink" title="IsPalindrome(是否为回文)"></a>IsPalindrome(是否为回文)</h3><p><link-and-solution num="4037"></link-and-solution></p><h4 id="用法-123"><a href="#用法-123" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-123"><a href="#实现方式-123" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="MutableKeys-所有可写键"><a href="#MutableKeys-所有可写键" class="headerlink" title="MutableKeys(所有可写键)"></a>MutableKeys(所有可写键)</h3><p><link-and-solution num="5181"></link-and-solution></p><h4 id="用法-124"><a href="#用法-124" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-124"><a href="#实现方式-124" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Intersection-交集"><a href="#Intersection-交集" class="headerlink" title="Intersection(交集)"></a>Intersection(交集)</h3><p><link-and-solution num="5423"></link-and-solution></p><h4 id="用法-125"><a href="#用法-125" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-125"><a href="#实现方式-125" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="BinaryToDecimal-二进制转十进制"><a href="#BinaryToDecimal-二进制转十进制" class="headerlink" title="BinaryToDecimal(二进制转十进制)"></a>BinaryToDecimal(二进制转十进制)</h3><p><link-and-solution num="6141"></link-and-solution></p><h4 id="用法-126"><a href="#用法-126" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-126"><a href="#实现方式-126" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectKeyPaths-对象属性键路径"><a href="#ObjectKeyPaths-对象属性键路径" class="headerlink" title="ObjectKeyPaths(对象属性键路径)"></a>ObjectKeyPaths(对象属性键路径)</h3><p><link-and-solution num="7258"></link-and-solution></p><h4 id="用法-127"><a href="#用法-127" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-127"><a href="#实现方式-127" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="TwoSum-LeetCode两数之和"><a href="#TwoSum-LeetCode两数之和" class="headerlink" title="TwoSum(LeetCode两数之和)"></a>TwoSum(LeetCode两数之和)</h3><p><link-and-solution num="8804"></link-and-solution></p><h4 id="用法-128"><a href="#用法-128" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-128"><a href="#实现方式-128" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ValidDate-校验是否为合法日期"><a href="#ValidDate-校验是否为合法日期" class="headerlink" title="ValidDate(校验是否为合法日期)"></a>ValidDate(校验是否为合法日期)</h3><p><link-and-solution num="9155"></link-and-solution></p><h4 id="用法-129"><a href="#用法-129" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-129"><a href="#实现方式-129" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Assign-对象Object-assign方法"><a href="#Assign-对象Object-assign方法" class="headerlink" title="Assign(对象Object.assign方法)"></a>Assign(对象Object.assign方法)</h3><p><link-and-solution num="9160"></link-and-solution></p><h4 id="用法-130"><a href="#用法-130" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-130"><a href="#实现方式-130" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Maximum-数字中的最大值"><a href="#Maximum-数字中的最大值" class="headerlink" title="Maximum(数字中的最大值)"></a>Maximum(数字中的最大值)</h3><p><link-and-solution num="9384"></link-and-solution></p><h4 id="用法-131"><a href="#用法-131" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-131"><a href="#实现方式-131" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="DeepCapitalize-深度首字母大写"><a href="#DeepCapitalize-深度首字母大写" class="headerlink" title="DeepCapitalize(深度首字母大写)"></a>DeepCapitalize(深度首字母大写)</h3><p><link-and-solution num="9775"></link-and-solution></p><h4 id="用法-132"><a href="#用法-132" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-132"><a href="#实现方式-132" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="UnionReplace-联合类型替换"><a href="#UnionReplace-联合类型替换" class="headerlink" title="UnionReplace(联合类型替换)"></a>UnionReplace(联合类型替换)</h3><p><link-and-solution num="13580"></link-and-solution></p><h4 id="用法-133"><a href="#用法-133" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-133"><a href="#实现方式-133" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="FizzBuzz-Fizz和Buzz输出问题"><a href="#FizzBuzz-Fizz和Buzz输出问题" class="headerlink" title="FizzBuzz(Fizz和Buzz输出问题)"></a>FizzBuzz(Fizz和Buzz输出问题)</h3><p><link-and-solution num="14080"></link-and-solution></p><h4 id="用法-134"><a href="#用法-134" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-134"><a href="#实现方式-134" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="RLE-运行长度编码"><a href="#RLE-运行长度编码" class="headerlink" title="RLE(运行长度编码)"></a>RLE(运行长度编码)</h3><p><link-and-solution num="14188"></link-and-solution></p><h4 id="用法-135"><a href="#用法-135" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-135"><a href="#实现方式-135" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectPathArray-对象键路径数组"><a href="#ObjectPathArray-对象键路径数组" class="headerlink" title="ObjectPathArray(对象键路径数组)"></a>ObjectPathArray(对象键路径数组)</h3><p><link-and-solution num="15260"></link-and-solution></p><h4 id="用法-136"><a href="#用法-136" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-136"><a href="#实现方式-136" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="SnakeCase-字符串下划线连接"><a href="#SnakeCase-字符串下划线连接" class="headerlink" title="SnakeCase(字符串下划线连接)"></a>SnakeCase(字符串下划线连接)</h3><p><link-and-solution num="19458"></link-and-solution></p><h4 id="用法-137"><a href="#用法-137" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-137"><a href="#实现方式-137" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsNegativeNumber-是否为负数"><a href="#IsNegativeNumber-是否为负数" class="headerlink" title="IsNegativeNumber(是否为负数)"></a>IsNegativeNumber(是否为负数)</h3><p><link-and-solution num="25747"></link-and-solution></p><h4 id="用法-138"><a href="#用法-138" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-138"><a href="#实现方式-138" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="OptionalUndefined-按需转换为可选属性"><a href="#OptionalUndefined-按需转换为可选属性" class="headerlink" title="OptionalUndefined(按需转换为可选属性)"></a>OptionalUndefined(按需转换为可选属性)</h3><p><link-and-solution num="28143"></link-and-solution></p><h4 id="用法-139"><a href="#用法-139" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-139"><a href="#实现方式-139" class="headerlink" title="实现方式"></a>实现方式</h4><h2 id="地狱"><a href="#地狱" class="headerlink" title="地狱"></a>地狱</h2><p>撰写中…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript进阶教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript教程(一)</title>
    <link href="/2024/08/01/TypeScript%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
    <id>/2024/08/01/TypeScript教程-一/</id>
    <published>2024-08-01T06:37:09.000Z</published>
    <updated>2024-08-12T01:14:32.310Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript基础教程<br><a id="more"></a></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><code>TypeScript</code>是<code>JavaScript</code>的一个超集，主要提供了<strong>类型系统</strong>和对<strong>ES6</strong>的支持，它于2012年10月正式发布第一个版本。</p><p>优势：</p><ul><li>能在开发过程中更快的发现潜在问题。</li><li>对编辑器更友好的代码提示功能。</li><li>代码语义更清晰易懂。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>你首先需要在<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>按照你电脑的操作系统下载对应的<code>Node</code>版本进行安装。</p><h3 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>你需要使用如下命令全局安装<code>TypeScript</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">$ npm install -g typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后，查看版本号</span></span><br><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>如果你对具体版本有严格的要求，你同样可以按照指定版本号进行安装。</p></blockquote><p>如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按指定版本号进行安装</span></span><br><span class="line">$ npm install -g typescript@3.6.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后，查看版本号</span></span><br><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure></p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>在正式开始学习<code>TypeScript</code>之前，我们需要创建一个叫做<code>TypeScript</code>的文件夹：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">$ mkdir TypeScript</span><br></pre></td></tr></table></figure></p><p>随后在<code>TypeScript</code>文件夹中创建<code>demo.ts</code>文件，其代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello,world'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>.ts</code>中的代码一般而言是不能直接运行在浏览器的，需要我们把<code>typescript</code>代码进行编译成普通的<code>javascript</code>代码以后才能运行在浏览器，我们可以使用如下命令来进行编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译命令</span></span><br><span class="line">$ tsc demo.ts</span><br></pre></td></tr></table></figure></p><p>当编译完毕后，我们可以在文件夹中看到多出来了一个叫做<code>demo.js</code>文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- TypeScript</span><br><span class="line">|   |-- demo.js</span><br><span class="line">|   |-- demo.ts</span><br></pre></td></tr></table></figure></p><p>随后我们需要使用如下命令来执行我们编译后的<code>javascript</code>代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ node demo.js</span><br></pre></td></tr></table></figure></p><p>当执行完毕以上命令后，你可以在终端上看到输出一下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,world</span><br></pre></td></tr></table></figure></p><p><strong>简化过程</strong>：我们发现，如果要运行一个<code>.ts</code>文件，我们首先需要使用<code>tsc</code>命令去编译它，随后再使用<code>node</code>命令去执行它，那么有没有一种工具能够一个步骤就帮我们做完以上的事情呢？我们需要全局安装一个叫做<code>ts-node</code>的工具：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ts-node</span></span><br><span class="line">$ npm install ts-node -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕，查看版本号</span></span><br><span class="line">$ ts-node -v</span><br></pre></td></tr></table></figure></p><p>在<code>ts-node</code>安装完毕后，我们先删除<code>demo.js</code>文件，随后使用<code>ts-node</code>命令来编译并执行我们的代码：</p><blockquote><p>warning<br><code>ts-node</code>包有升级更新，如果运行<code>ts-node</code>命令报错，请按照<code>ts-node</code>最新文档进行处理。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除demo.js文件</span></span><br><span class="line">$ rm demo.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译并执行</span></span><br><span class="line">$ ts-node demo.ts</span><br></pre></td></tr></table></figure><p>以上命令执行完毕后，你将会看到与上面实例相同的输出结果。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>我们知道<code>JavaScript</code>分为<strong>原始数据类型</strong>和<strong>对象类型</strong>，原始数据类型包括：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>和<code>symbol</code>。<br>在<code>TypeScript</code>中，我们可以如下定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsNum: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> tsStr: <span class="built_in">string</span> = <span class="string">'AAA'</span></span><br><span class="line"><span class="keyword">let</span> tsFlag: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> tsNull: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> tsUndefined: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="void空值"><a href="#void空值" class="headerlink" title="void空值"></a>void空值</h4><p>我们知道在<code>JavaScript</code>中，是没有空值(<code>void</code>)的概念的，但在<code>TypeScript</code>中，可以使用<code>void</code>来表示一个没有返回值的函数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以定义一个<code>void</code>类型的变量，不过这样的变量并没有什么意义，因为我们只能给这种变量赋值为<code>null</code>或<code>undefined</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> voidValue1: <span class="built_in">void</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> voidValue2: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="void、null和undefined"><a href="#void、null和undefined" class="headerlink" title="void、null和undefined"></a>void、null和undefined</h4><p><code>void</code>和<code>null</code>与<code>undefined</code>是有一定区别的，在<code>TypeScript</code>中，<code>null</code>和<code>undefined</code>是所有类型的子类型，也就是说可以把<code>undefined</code>或<code>null</code>赋值给<code>number</code>等类型的变量:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsNumber1: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> tsNumber2: <span class="built_in">number</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>而对于<code>void</code>而言，它只能被赋值为<code>null</code>或者<code>undefined</code>：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两行代码会编译报错</span></span><br><span class="line"><span class="keyword">let</span> voidValue1: <span class="built_in">void</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> voidValue2: <span class="built_in">void</span> = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p>任意值<code>Any</code>用来表示可以接受任何类型的值。</p><p>在有以上内容的基础上，我们知道以下代码会报错：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量被定义为number，那么它只能接受number类型的值，不能改变其类型，会编译报错</span></span><br><span class="line"><span class="keyword">let</span> tsNumber: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line">tsNumber = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>但是如果一个变量被定义为<code>any</code>，那么代表它可以接受任何类型的值：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是正确的，编译成功</span></span><br><span class="line"><span class="keyword">let</span> tsAny: <span class="built_in">any</span> = <span class="number">123</span></span><br><span class="line">tsAny = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>现在我们来思考一个问题，如果我们定义了一个变量，没有指定其类型，也没有初始化，那么它默认为<code>any</code>类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是正确的，编译成功</span></span><br><span class="line"><span class="keyword">let</span> tsValue</span><br><span class="line">tsValue = <span class="number">123</span></span><br><span class="line">tsValue = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><h3 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h3><p>在以上的所有实例中，我们都为每一个变量提供了一个确定的类型，这种做法就叫做<strong>类型注解</strong>。而有些时候，当我们没有为其提供一个确定的类型，但提供了一个确定的值，那么<code>TypeScript</code>会根据我们给定的值的类型自动推断出这个变量的类型，这就叫<strong>类型推断</strong>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typescript会自动为num1变量推断为number</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typescript会自动为num4变量推断为number</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">456</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">789</span></span><br><span class="line"><span class="keyword">let</span> num4 = num2 + num3</span><br></pre></td></tr></table></figure></p><p>根据以上的案例，当我们给一个变量一个明确值的情况下，我们可以省略为其定义类型。但如果在函数参数中，则我们必须为其指定一个类型，如果不指定则默认为<code>any</code>:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者省略函数的返回值类型，因为typescript会基于num1和num1全部为number类型，从而推断出函数返回值为number类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>建议</strong>：始终为函数返回值提供一个确定的类型是有一个比较推荐的好习惯。</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p><strong>联合类型</strong>：表示取值可以为多种类型中的一种，多种类型使用<code>|</code>分隔开。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">value = <span class="number">123</span></span><br><span class="line">value = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>当我们使用联合类型的时候，因为<code>TypeScript</code>不确定到底是哪一个类型，所以我们只能访问此联合类型的所有类型公用的属性和方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span> (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码不会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueToStr</span> (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>warning<br>另外一个值得注意的地方就是，当联合类型被赋值后，<code>TypeScript</code>会根据类型推断来确定变量的类型，一旦确定后，则此变量只能使用这种类型的属性和方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsValue: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">tsValue = <span class="string">'123'</span></span><br><span class="line"><span class="built_in">console</span>.log(tsValue.length) <span class="comment">// 编译正确</span></span><br><span class="line">tsValue = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(tsValue.length) <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在<code>TypeScript</code>中，接口<code>interface</code>是一个比较重要的概念，它是对行为的抽象，而具体的行为需要由类去实现，接口<code>interface</code>中的任何代码都不会被最后编译到<code>JavaScript</code>中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，<code>person</code>变量它是<code>Person</code>类型的，那么此变量只能接受接口规定的属性，且属性值的类型也必须和接口中规定的一致，多一个属性或者少一个属性在<code>TypeScript</code>中都不是被允许的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">let</span> person1: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">let</span> person2: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的任意属性"><a href="#接口中的任意属性" class="headerlink" title="接口中的任意属性"></a>接口中的任意属性</h4><p>以上一个例子为基础，假设我们接口只对<code>name</code>和<code>age</code>做规定，其它任何属性都是可以的，那么我们可以如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  <span class="comment">// 任意属性</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的可选属性"><a href="#接口中的可选属性" class="headerlink" title="接口中的可选属性"></a>接口中的可选属性</h4><p>现在假设，我们有一个接口，它只对<code>name</code>做规定，但是对于是否包含<code>age</code>不做要求，那么可以如下方式进行处理：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  <span class="comment">// age属性是可选的</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成功</span></span><br><span class="line"><span class="keyword">let</span> person1: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的只读属性"><a href="#接口中的只读属性" class="headerlink" title="接口中的只读属性"></a>接口中的只读属性</h4><p>最后我们要介绍的知识点是只读属性，一旦在接口中标记了属性为只读的， 那么其不能被赋值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  readonly age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">person.age = <span class="number">32</span></span><br></pre></td></tr></table></figure></p><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>在<code>JavaScript</code>中，定义函数有三种表现形式：</p><ul><li>函数声明。</li><li>函数表达式。</li><li>箭头函数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> func2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> func3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数有参数，则必须在<code>TypeScript</code>中为其定义具体的类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">// 输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="string">'2'</span>))  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><h4 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h4><p>函数也可以使用接口来定义其类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AddInterface &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add: AddInterface = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure></p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>前面我们已经提到过，必须为具体的参数提供具体的类型，但如果一个函数接受一个参数，这个参数又是可选的，那么我们可以如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  b ? a * b : a * a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>))     <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>可选参数必须放在最后一个位置，否则会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">b?: <span class="built_in">number</span>, a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  b ? a * b : a * a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>在<code>JavaScript</code>中，函数允许我们给参数设置默认值，因此另外一种处理可选参数的方式是，为参数提供一个默认值，此时<code>TypeScript</code>将会把该参数识别为可选参数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span> = 1</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>))     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>给一个参数设置了默认值后，就不再受<code>TypeScript</code>可选参数必须在最后一个位置的限制了。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">b: <span class="built_in">number</span> = 1, a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时必须显示的传递一个undefined进行占位</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="literal">undefined</span>,<span class="number">4</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))        <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>在<code>ES6</code>中，我们可以使用<code>...</code>符号进行收缩剩余参数，在<code>TypeScript</code>中，我们依然可以这么做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest是一个数组，我们可以使用数组的类型来定义它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span> (<span class="params">a: number, ...rest: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)    <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(rest) <span class="comment">// [2, 3, 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,)</span><br></pre></td></tr></table></figure></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>因为在<code>JavaScript</code>中，并没有限制函数参数的个数或者类型，因此<code>JavaScript</code>没有函数重载的概念，在<code>TypeScript</code>中对于函数重载的理解是：只要函数参数的类型或者函数参数的数量不同时，就可以认为这是两个函数(重载)。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个为函数声明，最后一个才是函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">''</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'1'</span>, <span class="string">'2'</span>))  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>在有函数重载时，会优先从第一个进行逐一匹配，因此如果重载函数有包含关系，应该将最精准的函数定义写在最前面。</p></blockquote><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在上面联合类型中，我们知道可以变量可以是多个类型的，这可能会在代码编写的过程中带给我们一些困惑：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'student'</span></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'teacher'</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">person: Student | Teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 强制断言为Student类型</span></span><br><span class="line">    (person <span class="keyword">as</span> Student).sayHi()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 强制断言为Teacher类型</span></span><br><span class="line">    (person <span class="keyword">as</span> Teacher).sayHello()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> Student()</span><br><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> Teacher()</span><br><span class="line">print(stu)      <span class="comment">// student</span></span><br><span class="line">print(teacher)  <span class="comment">// teacher</span></span><br></pre></td></tr></table></figure></p><p>代码分析：在<code>print</code>函数中，我们接受的参数可以是<code>Student</code>或者<code>Teacher</code>，在此函数内部我们希望能够根据不同的类型来调用不同的方法。我们首先使用<code>instanceof</code>来判断参数是否为<code>Student</code>类的实例，是我们将<code>person</code>参数强制断言成<code>Student</code>类型，此时就可以安全的调用<code>sayHi</code>方法了，<code>Teacher</code>同理。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名用<code>type</code>关键字来给一个类型起一个新的名字，类型别名常用于联合类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> combineType = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> typeObj = &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> value1: combineType = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> obj: typeObj = &#123;</span><br><span class="line">  age: <span class="number">123</span>,</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型用来表示一个变量只能取某几个字符串值中的一个。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eventName = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span> (<span class="params">event: eventName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="string">'click'</span>)    <span class="comment">// click</span></span><br><span class="line">handleEvent(<span class="string">'scroll'</span>)   <span class="comment">// scroll</span></span><br><span class="line">handleEvent(<span class="string">'dbclick'</span>)  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>和普通的变量一样，数组中的类型定义也有一定的规则：类型+方括号表示<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number类型</span></span><br><span class="line"><span class="keyword">let</span> numArray: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 只允许存储string类型</span></span><br><span class="line"><span class="keyword">let</span> strArray: <span class="built_in">string</span>[] = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>值得一提的是，以上案例还有一种泛型方式的写法：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number类型</span></span><br><span class="line"><span class="keyword">let</span> numArray: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 只允许存储string类型</span></span><br><span class="line"><span class="keyword">let</span> strArray: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>在数组中也可以使用联合类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number和string类型的值</span></span><br><span class="line"><span class="keyword">let</span> tsArray: (<span class="built_in">number</span> | <span class="built_in">string</span>) [] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>我们知道，在数组中不仅可以存储基础数据类型，还可以存储对象类型，如果需要存储对象类型，可以用如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储对象仅有name和age，且name为string类型，age为number类型的对象</span></span><br><span class="line"><span class="keyword">let</span> objArray: (&#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;)[] = [</span><br><span class="line">  &#123; name: <span class="string">'AAA'</span>, age: <span class="number">23</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>为了更加方便的撰写代码，我们可以使用类型别名的方式来管理以上类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objArray: person[] = [</span><br><span class="line">  &#123; name: <span class="string">'AAA'</span>, age: <span class="number">23</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>对元组的理解是：一个数组如果知道它确定的长度，且每个位置的值的类型也是确定的，那么就可以把这样的数组称为元组。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple数组只有2个元素，并且第一个元素类型为string，第二个元素类型为number</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'AAA'</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>当访问元组中已知位置的索引时，将得到其对应正确的值；当访问元组中未知位置的索引时，会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'AAA'</span>, <span class="number">123</span>]</span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">1</span>]) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">2</span>]) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举<code>Enum</code>类型用来表示取值限定在指定的范围，例如一周只能有七天，颜色只能有红、绿、蓝等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors.red)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.green) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.blue)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>代码分析：我们定义一个<code>colors</code>的枚举类型，其取值只能是<code>red</code>、<code>green</code>、<code>blue</code>。我们可以在打印的内容发现，其输出值从0开始，依次累加1。这是枚举类型的默认行为，我们可以手动设置一个起始值：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red = <span class="number">10</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors.red)   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.green) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.blue)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><p>在枚举类型中，我们不仅可以正向的获取值，还可以通过值反向获取枚举：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red = <span class="number">10</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">10</span>]) <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">11</span>]) <span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">12</span>]) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>在<code>JavaScript</code>中，通过<code>extends</code>关键字来实现子类继承父类，子类也可以通过<code>super</code>关键字来访问父类的属性或者方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  sayTeacherHello () &#123;</span><br><span class="line">    <span class="comment">// 调用父类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sayHello()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> Teacher(<span class="string">'why'</span>)</span><br><span class="line">teacher.sayHello()        <span class="comment">// hello, why</span></span><br><span class="line">teacher.sayTeacherHello() <span class="comment">// hello, why</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>有一种关于类属性的简写方式，就是在类的构造函数中指明访问修饰符。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写形式</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>在<code>class</code>中，可以通过<code>getter</code>和<code>setter</code>来改变属性的读取和赋值行为。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">// 私有属性，只能在类中进行访问</span></span><br><span class="line">  <span class="keyword">private</span> _name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// why</span></span><br><span class="line">person.name = <span class="string">'AAA'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// AAA</span></span><br></pre></td></tr></table></figure></p><h4 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h4><p>所谓静态属性和静态方法，就是只能通过类来进行访问，不能通过类的实例来进行访问。在众多设计模式中，有一种设计模式叫做单例设计模式，可以使用<code>static</code>静态方法来辅助我们完成单例设计模式。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> _instance: Person</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> getInstance () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>._instance = <span class="keyword">new</span> Person()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = Person.getInstance()</span><br><span class="line"><span class="keyword">const</span> person2 = Person.getInstance()</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h4 id="TypeScript类的访问修饰符"><a href="#TypeScript类的访问修饰符" class="headerlink" title="TypeScript类的访问修饰符"></a>TypeScript类的访问修饰符</h4><p>在以上的实例中，我们使用到了<code>TypeScript</code>中关于类的几种访问修饰符，它有三种：</p><ul><li><code>public</code>：公有的，在任何地方都可以访问到。</li><li><code>protected</code>：受保护的，只能在类的内部及其类的子类内部使用。</li><li><code>private</code>：私有的，只能在类的内部进行使用。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> age: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">protected</span> address: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">age: <span class="built_in">number</span>, address: <span class="built_in">string</span>, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.address = address</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my addresss is <span class="subst">$&#123;<span class="keyword">this</span>.address&#125;</span>`</span>) <span class="comment">// my address is 广东广州</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)        <span class="comment">// my name is why</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)          <span class="comment">// 编译报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">21</span>, <span class="string">'广东广州'</span>, <span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age)     <span class="comment">// 编译报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address) <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>可以使用<code>readonly</code>关键字来表示属性是只读的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> readonly name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'AAA'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// AAA</span></span><br><span class="line">person.name = <span class="string">'BBB'</span>       <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在<code>TypeScript</code>中，可以使用<code>abstract</code>关键字来定义抽象类以及抽象类中的抽象方法，在使用抽象类的过程中，有几点需要注意：</p><ul><li>抽象类不能被实例化，只能被继承。</li><li>抽象类中的抽象方法必须被子类实现。</li></ul><p>抽象类不能被实例化：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> Animal&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal() <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><p>抽象类中的抽象方法必须被子类实现：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> eat (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">  <span class="comment">// 子类必须实现抽象类中的抽象方法</span></span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'person is eating'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line">person.eat()                <span class="comment">// person is eating</span></span><br></pre></td></tr></table></figure></p><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><blockquote><p>tip<br>一个类可以实现一个或者多个接口，用逗号分隔。</p></blockquote><p>如果我们定义了一个接口，然后类去实现它，那么这个接口中的属性和方法，在类中必须全部都要存在，否则会编译报错。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>在上面的案例中，我们使用到了类实现接口，其实一个接口还可以继承自另外一个接口。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="comment">// Person接口继承了Animal，就拥有了Animal种所有的属性和方法</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Person &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>在有些语言中，接口一般而言是不能继承类的，但在<code>TypeScript</code>中是可以继承的，接口继承类以后，就拥有类中所有的属性和方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  y: <span class="number">10</span>,</span><br><span class="line">  z: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(point3d)  <span class="comment">// &#123; x: 10, y: 10, z: 10 &#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型<code>generics</code>是指在定义函数、接口和类的时候，不预先指定其具体类型，而在使用的时候再去指定的一种特性。</p><h4 id="函数中的泛型"><a href="#函数中的泛型" class="headerlink" title="函数中的泛型"></a>函数中的泛型</h4><p>假设我们有如下一个函数，其中参数<code>a</code>和<code>b</code>接受的类型必须为相同的类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在没有了解到泛型之前，我们可以用联合类型来定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码分析：在以上的例子中，我们仅仅只是规定了<code>a</code>和<code>b</code>参数必须是<code>number</code>类型或者<code>string</code>类型，但并没有办法来限制<code>a</code>和<code>b</code>必须是同一个类型。这个时候我们可以使用泛型来表示：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>&gt; (<span class="params">a: T, b: T</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：我们在调用<code>join()</code>函数并进行传参的时候，<code>TypeScript</code>会自动帮我们推断参数的类型，以上三行代码也可以像如下方式进行撰写：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">string</span>&gt;(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>泛型可以是多个的。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt; (<span class="params">a: T, b: P</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>代码分析：在以上的案例中，<code>join</code>方法接受2个泛型类型，其中参数<code>a:T</code>，参数<code>b:p</code>，因此<code>console.log(join(1, &#39;2&#39;))</code>会正确被编译并输出12。</p><h4 id="类中的泛型"><a href="#类中的泛型" class="headerlink" title="类中的泛型"></a>类中的泛型</h4><p>泛型同样可以使用在类中。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CreateClass&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createNumber = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">createNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createString = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">createString.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createNumber.add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(createString.add(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>在<a href="mailto:`TypeScript@2.3" target="_blank" rel="noopener">`TypeScript@2.3</a>+`以后的版本，我们可以为泛型提供一个默认值。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CreateClass&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createNumber = <span class="keyword">new</span> CreateClass()</span><br><span class="line">createNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createString = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">createString.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createNumber.add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(createString.add(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>代码分析：在<code>CreateClass</code>类的定义部分，我们为泛型提供了一个默认值<code>number</code>，因此我们在实例<code>createNumber</code>初始化的时候就可以不用传递<code>number</code>了。</p><h4 id="接口中的泛型"><a href="#接口中的泛型" class="headerlink" title="接口中的泛型"></a>接口中的泛型</h4><p>像在类中一样，泛型可以存在于接口中。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArray &#123;</span><br><span class="line">  &lt;T&gt;(length: <span class="built_in">number</span>, value: T): T[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createArrayFunc: CreateArray = <span class="function"><span class="keyword">function</span> (<span class="params">length, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    result[index] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createArrayFunc(<span class="number">3</span>, <span class="string">'AAA'</span>))  <span class="comment">// ['AAA', 'AAA', 'AAA']</span></span><br><span class="line"><span class="built_in">console</span>.log(createArrayFunc(<span class="number">2</span>, <span class="literal">true</span>))   <span class="comment">// [true, true]</span></span><br></pre></td></tr></table></figure></p><h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。<br>声明合并，我们在上面已经有实例的案例了，那就是函数的重载。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">''</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'1'</span>, <span class="string">'2'</span>))  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><p>当重复定义同一个接口时，会进行接口合并：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p> warning<br>当合并的属性类型不一致时，会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="comment">// 报错，name类型冲突</span></span><br><span class="line">  name: <span class="built_in">number</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在我们以上所有案例中，我们编写的代码大多数是运行在<code>Node</code>环境下的，接下来我们来编写一些代码，让其在浏览器环境中运行。</p><p>首先我们需要创建如下的项目以及目录结构：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-- TypeScript</span><br><span class="line">|   |-- dist</span><br><span class="line">|   |   |-- index.html</span><br><span class="line">|   |-- src</span><br><span class="line">|   |   |-- page.ts</span><br><span class="line">|   |-- tsconfig.json</span><br></pre></td></tr></table></figure></p><p>其中，<code>tsconfig.json</code>的配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                </span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist"</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./src"</span>, </span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在配置完<code>tsconfig.json</code>以后，我们来撰写<code>page.ts</code>中的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Header &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Header'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Content &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Content'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Footer &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Footer'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Page &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Header()</span><br><span class="line">    <span class="keyword">new</span> Content()</span><br><span class="line">    <span class="keyword">new</span> Footer()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写完以上代码后，我们运行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译src下的*.ts文件到dist目录下</span></span><br><span class="line">$ tsc</span><br></pre></td></tr></table></figure></p><p>随后我们在<code>dist/index.html</code>中引用我们刚刚编译的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Page()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当我们在浏览器中运行<code>index.html</code>文件后，我们可以在浏览器下正确的看到我们想要的输出内容。</p><p>当我们在打开<code>page.js</code>文件时，我们可以发现：<br><img src="/2024/08/01/TypeScript教程-一/1.png" alt="page.js代码"></p><p><strong>在全局作用域环境下，我们一次性引入了四个全局变量</strong>：<code>Header</code>、<code>Content</code>、<code>Footer</code>和<code>Page</code>。要解决这个问题，我们可以使用<code>namespace</code>命令空间：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名空间包裹我们的代码并把Page类导出出去</span></span><br><span class="line"><span class="keyword">namespace</span> Home &#123;</span><br><span class="line">  <span class="keyword">class</span> Header &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Header'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> Content &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Content'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> Footer &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Footer'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Page &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> Header()</span><br><span class="line">      <span class="keyword">new</span> Content()</span><br><span class="line">      <span class="keyword">new</span> Footer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随后，再次使用<code>tsc</code>命令重新编译代码，编译后的<code>page.js</code>如下：<br><img src="/2024/08/01/TypeScript教程-一/2.png" alt="Page.js代码"></p><p>再次修改<code>index.html</code>中的代码，我们依然能够得到跟前面示例代码一样的输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Home.Page()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript基础教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>electron基础入门</title>
    <link href="/2024/07/17/electron%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>/2024/07/17/electron基础入门/</id>
    <published>2024-07-17T01:22:37.000Z</published>
    <updated>2025-03-04T01:18:48.933Z</updated>
    
    <content type="html"><![CDATA[<p>electron+vue3+pinia构建一个桌面应用<br><a id="more"></a><br>Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux。</p><p>本教程使用vite+vue3+pinia配合electron开发一个桌面应用。</p><blockquote><p>app应用功能，点击添加按钮，弹出dialog，填写内容后提交，将内容保存在<code>public/files</code>文件夹下，并且当前列表会展示出目前的文件列表。点击相应的文件会跳转到详情页展示。</p></blockquote><h1 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h1><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><h3 id="安装vue3"><a href="#安装vue3" class="headerlink" title="安装vue3"></a>安装vue3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>按照命令行提示输入项目名<code>base-tutorial</code>,之后选择<code>vue</code>项目，语言<code>javascript</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd base-tutorial</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>通过上边的命令可以启动vue3项目了。</p><h2 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h2><h3 id="安装electron"><a href="#安装electron" class="headerlink" title="安装electron"></a>安装electron</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron -D</span><br></pre></td></tr></table></figure><p>electron比较大，根据网络情况可能会安装失败，多尝试几次。</p><h3 id="安装nodemon"><a href="#安装nodemon" class="headerlink" title="安装nodemon"></a>安装nodemon</h3><p>开发方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon -D</span><br></pre></td></tr></table></figure></p><p>之后在<code>package.json</code>中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;nodemon --exec electron . --watch ./ --ext .js,.html,.css,.vue&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>监控<code>.js,.html,.css,.vue</code>这些文件变化，自动重启<code>electron</code>应用。</p><h3 id="安装electron-win-state"><a href="#安装electron-win-state" class="headerlink" title="安装electron-win-state"></a>安装electron-win-state</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-win-state --save</span><br></pre></td></tr></table></figure><p><code>electron-win-state</code>可以记录应用上次关闭前窗口大小和位置。</p><h3 id="编写electron应用"><a href="#编写electron应用" class="headerlink" title="编写electron应用"></a>编写electron应用</h3><p>在<code>package.json</code>中添加<code>electron</code>应用的主入口文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;main.js&quot;</span><br></pre></td></tr></table></figure></p><p>在项目根目录下新建<code>main.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; app, BrowserWindow &#125; from &apos;electron&apos;;</span><br><span class="line">import WinState from &apos;electron-win-state&apos;; // 保存窗口位置和大小的调整</span><br><span class="line"></span><br><span class="line">const createWindow = ()=&gt; &#123;</span><br><span class="line">  const winState = new WinState.default(&#123;</span><br><span class="line">    defaultWidth: 1000,</span><br><span class="line">    defaultHeight: 800,</span><br><span class="line">    electronStoreOptions: &#123;</span><br><span class="line">      name: &apos;window-state-main&apos; // 开启多个窗口的时候分别记录</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  const win = new BrowserWindow(&#123;</span><br><span class="line">    ...winState.winOptions,</span><br><span class="line">    show: false,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  win.loadURL(&apos;http://localhost:5173&apos;);</span><br><span class="line">  win.webContents.openDevTools();</span><br><span class="line">  winState.manage(win);</span><br><span class="line">  win.on(&apos;ready-to-show&apos;, ()=&gt; &#123;</span><br><span class="line">    win.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().then(()=&gt; &#123;</span><br><span class="line">  createWindow();</span><br><span class="line"></span><br><span class="line">  app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class="line">    if (BrowserWindow.getAllWindows().length === 0) &#123;</span><br><span class="line">      createWindow()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行<code>npm start</code>,app顺利启动<br>但是在调试工具打印台会看到<code>Electron Security Warning (Insecure Content-Security-Policy)</code>警告，解决办法是在index.html中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;self&apos;; img-src &apos;self&apos; data:; style-src &apos;self&apos; &apos;unsafe-inline&apos;&quot;&gt;</span><br></pre></td></tr></table></figure></p><h1 id="添加新功能"><a href="#添加新功能" class="headerlink" title="添加新功能"></a>添加新功能</h1><p>添加路由，状态管理，ui库，css预编译，css初始化，lodash等</p><h2 id="安装对应的库"><a href="#安装对应的库" class="headerlink" title="安装对应的库"></a>安装对应的库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router --save</span><br><span class="line">npm i stylus --save</span><br><span class="line">npm i pinia --save</span><br><span class="line">npm i normalize.css --save</span><br><span class="line">npm i lodash --save</span><br><span class="line">npm i element-plus --save</span><br></pre></td></tr></table></figure><h2 id="改造vue内容"><a href="#改造vue内容" class="headerlink" title="改造vue内容"></a>改造vue内容</h2><h3 id="修改App-vue"><a href="#修改App-vue" class="headerlink" title="修改App.vue"></a>修改App.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;electron基础入门&lt;/h1&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>添加路由插槽<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><h3 id="新建views"><a href="#新建views" class="headerlink" title="新建views"></a>新建views</h3><p>在<code>src</code>目录下，新建<code>views</code>文件夹<br>在<code>views</code>下新建<code>Home.vue，Detail.vue</code>文件</p><h3 id="新建router"><a href="#新建router" class="headerlink" title="新建router"></a>新建router</h3><p>在<code>src</code>目录下，新建<code>router</code>文件夹<br>在<code>router</code>下新建<code>index.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createRouter, createWebHashHistory &#125; from &apos;vue-router&apos;;</span><br><span class="line">import Home from &apos;@/views/Home.vue&apos;;</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    redirect: &apos;/home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/home&apos;,</span><br><span class="line">    name: &apos;home&apos;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/detail&apos;,</span><br><span class="line">    name: &apos;detail&apos;,</span><br><span class="line">    component: ()=&gt; import(&apos;@/views/Detail.vue&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure></p><h3 id="修改Home-vue"><a href="#修改Home-vue" class="headerlink" title="修改Home.vue"></a>修改Home.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted, nextTick &#125; from &apos;vue&apos;;</span><br><span class="line">import useLoadingStore from &apos;../store/loading&apos;;</span><br><span class="line">import List from &apos;./List.vue&apos;;</span><br><span class="line"></span><br><span class="line">const loadingSotate = useLoadingStore();</span><br><span class="line"></span><br><span class="line">const dialogVisible = ref(false);</span><br><span class="line">const list = ref([]);</span><br><span class="line">const refForm = ref(null);</span><br><span class="line">const form = reactive(&#123;</span><br><span class="line">  title: &apos;&apos;,</span><br><span class="line">  city: &apos;&apos;,</span><br><span class="line">  desc: &apos;&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">const rules = &#123;</span><br><span class="line">  title: [</span><br><span class="line">    &#123; required: true, message: &apos;请输入题目&apos;, trigger: &apos;blur&apos; &#125;  </span><br><span class="line">  ],</span><br><span class="line">  city: [</span><br><span class="line">    &#123; required: true, message: &apos;请选择城市&apos;, trigger: &apos;change&apos; &#125;  </span><br><span class="line">  ],</span><br><span class="line">  desc: [</span><br><span class="line">    &#123; required: true, message: &apos;请输入描述&apos;, trigger: &apos;blur&apos; &#125;  </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">const onAdd = ()=&gt; &#123;</span><br><span class="line">  dialogVisible.value = true;</span><br><span class="line">  nextTick(()=&gt; &#123;</span><br><span class="line">    refForm.value.resetFields();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const sunmitHandle = ()=&gt; &#123;</span><br><span class="line">  refForm.value.validate(async valid=&gt; &#123;</span><br><span class="line">    if(valid) &#123;</span><br><span class="line">      dialogVisible.value = false;</span><br><span class="line">      loadingSotate.set(true);</span><br><span class="line">      // 调用渲染进程提供的方法</span><br><span class="line">      await rendererApi.saveText(JSON.stringify(form));</span><br><span class="line">      loadingSotate.set(false);</span><br><span class="line">      getList();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const getList = async ()=&gt; &#123;</span><br><span class="line">  list.value = await rendererApi.getText();</span><br><span class="line">&#125;</span><br><span class="line">// 主进程调用vue侧的函数</span><br><span class="line">rendererApi.showAddDialog(()=&gt; &#123;</span><br><span class="line">  onAdd();</span><br><span class="line">&#125;);</span><br><span class="line">onMounted(async ()=&gt; &#123;</span><br><span class="line">  getList();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;onAdd&quot;&gt;+&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;List :listData=&quot;list&quot;&gt;&lt;/List&gt;</span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      v-model=&quot;dialogVisible&quot;</span><br><span class="line">      title=&quot;添加内容&quot;</span><br><span class="line">      width=&quot;80%&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;el-form :model=&quot;form&quot; ref=&quot;refForm&quot; :rules=&quot;rules&quot; label-width=&quot;auto&quot; style=&quot;max-width: 600px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;题目&quot; prop=&quot;title&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.title&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;城市&quot; prop=&quot;city&quot;&gt;</span><br><span class="line">        &lt;el-select v-model=&quot;form.city&quot; placeholder=&quot;请选择城市&quot;&gt;</span><br><span class="line">          &lt;el-option label=&quot;沈阳&quot; value=&quot;沈阳&quot; /&gt;</span><br><span class="line">          &lt;el-option label=&quot;大连&quot; value=&quot;大连&quot; /&gt;</span><br><span class="line">        &lt;/el-select&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;描述&quot; prop=&quot;desc&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.desc&quot; type=&quot;textarea&quot; :row=&quot;5&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">      &lt;template #footer&gt;</span><br><span class="line">        &lt;div class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot; @click=&quot;sunmitHandle&quot;&gt;</span><br><span class="line">            确定</span><br><span class="line">          &lt;/el-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="修改Detail-vue"><a href="#修改Detail-vue" class="headerlink" title="修改Detail.vue"></a>修改Detail.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useRoute, useRouter &#125; from &apos;vue-router&apos;;</span><br><span class="line"></span><br><span class="line">const route = useRoute();</span><br><span class="line">const router = useRouter();</span><br><span class="line">const query = route.query;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;go-back&quot;&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;router.go(-1)&quot;&gt;返回&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; query.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;来自-&#123;&#123; query.city &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;pre&gt;&#123;&#123; query.desc &#125;&#125;&lt;/pre&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.go-back &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="添加pinia"><a href="#添加pinia" class="headerlink" title="添加pinia"></a>添加pinia</h3><p>在<code>src</code>下新建<code>store</code>文件夹，新建<code>loading.js</code>文件。<br>此文件内容控制<code>Loading</code>组件显示隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &apos;pinia&apos;;</span><br><span class="line">const useLoadingStore = defineStore(&apos;websiteStore&apos;, &#123;</span><br><span class="line">state() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">bShow: false</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line">set(val) &#123;</span><br><span class="line">this.bShow = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">getBShow() &#123;</span><br><span class="line">      return this.bShow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">export default useLoadingStore;</span><br></pre></td></tr></table></figure></p><h3 id="添加loading"><a href="#添加loading" class="headerlink" title="添加loading"></a>添加loading</h3><p>在<code>App.vue</code>文件夹下添加<code>Loading</code>组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import useLoadingStore from &apos;../store/loading&apos;;</span><br><span class="line"></span><br><span class="line">const loadingSotate = useLoadingStore();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;loading-wrap&quot; v-if=&quot;loadingSotate.getBShow&quot;&gt;</span><br><span class="line">    &lt;svg class=&quot;circular&quot; viewBox=&quot;0 0 50 50&quot;&gt;&lt;circle class=&quot;path&quot; cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;20&quot; fill=&quot;none&quot;&gt;&lt;/circle&gt;&lt;/svg&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.loading-wrap &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background-color: rgba(255, 255, 255, .8);</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  .circular &#123;</span><br><span class="line">    stroke: #000000;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    animation: loading-rotate .5s linear infinite alternate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes loading-rotate &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">    opacity: 0</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(1.2);</span><br><span class="line">    opacity: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>比如在Home页面控制Loading组件显示隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loadingSotate.set(true);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  loadingSotate.set(false);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure></p><p>显示后3秒隐藏</p><h2 id="改造electron内容"><a href="#改造electron内容" class="headerlink" title="改造electron内容"></a>改造electron内容</h2><p><code>vue</code>侧提交内容后，需要将内容保存到文件里。需要修改<code>electron</code>的主进程和渲染进程</p><h3 id="electron主进程"><a href="#electron主进程" class="headerlink" title="electron主进程"></a>electron主进程</h3><h4 id="在main-js里新增"><a href="#在main-js里新增" class="headerlink" title="在main.js里新增"></a>在<code>main.js</code>里新增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webPreferences: &#123;</span><br><span class="line">  preload: path.resolve(__dirname, &apos;./preload/index.js&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>引入渲染进程文件。</p><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>在根目录下新建<code>controller</code>文件夹，再新建<code>saveText.js</code>文件，用于保存<code>vue</code>侧保存的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ipcMain &#125; from &apos;electron&apos;;</span><br><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import fs from &apos;fs&apos;;</span><br><span class="line">import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;</span><br><span class="line"></span><br><span class="line">ipcMain.handle(&apos;on-save-text-event&apos;, (e, str)=&gt; &#123;</span><br><span class="line">  const data = JSON.parse(str);</span><br><span class="line">  const filePath = path.resolve(__dirnameFn(import.meta.url), &apos;../public/files/&apos;, data.title + &apos;-&apos; + data.city + &apos;.txt&apos;);</span><br><span class="line">  fs.writeFileSync(filePath, data.desc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>ipcMain.handle</code>用来注册事件，渲染进程可以触发这个事件的回调函数。</p><h3 id="electron渲染进程"><a href="#electron渲染进程" class="headerlink" title="electron渲染进程"></a>electron渲染进程</h3><p>在根目录下新建<code>preload</code>文件夹，再新建<code>index.js</code>文件，这里都是渲染进程的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; contextBridge, ipcRenderer &#125; = require(&apos;electron&apos;)</span><br><span class="line"></span><br><span class="line">const saveText = async data=&gt; &#123;</span><br><span class="line">  let result = await ipcRenderer.invoke(&apos;on-save-text-event&apos;, data);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">contextBridge.exposeInMainWorld(&apos;myApi&apos;, &#123;</span><br><span class="line">  saveText,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>渲染进程将<code>saveText</code>这个方法暴露给vue侧，可以<code>window.saveText</code>来调用，调用时，渲染进程会触发主进程注册的对应事件的回调函数完成保存文件的功能。</p><blockquote><p>通过vue侧-&gt;渲染进程-&gt;主进程,也就是vue侧向主进程发起的通讯，后边还会实现electron主进程向vue侧发起的通讯。</p></blockquote><h2 id="后续修改略"><a href="#后续修改略" class="headerlink" title="后续修改略"></a>后续修改略</h2><p>之后还会对vue侧，渲染进程，主进程代码修改，这里就不一一列举。思路还是主进程注册事件，渲染进程暴漏给vue侧全局方法调用来触发主进程的事件回调函数。</p><h2 id="自定义Menu"><a href="#自定义Menu" class="headerlink" title="自定义Menu"></a>自定义Menu</h2><p>可以自定义<code>Menu</code>，这里为了使用主进程-&gt;渲染进程-&gt;vue侧的通讯，也就是在菜单中点击按钮，调用vue侧的一个方法。<br>这个流程与上面vue侧-&gt;渲染进程-&gt;主进程的调用正好相反。</p><h3 id="渲染进程新增事件注册"><a href="#渲染进程新增事件注册" class="headerlink" title="渲染进程新增事件注册"></a>渲染进程新增事件注册</h3><p>在preload的index.js中，新增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主进程触发渲染进程</span><br><span class="line">const showAddDialog = cb=&gt; ipcRenderer.on(&apos;on-show-add-dialog-event&apos;, (e, value)=&gt; &#123;</span><br><span class="line">  cb(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="vue侧调用"><a href="#vue侧调用" class="headerlink" title="vue侧调用"></a>vue侧调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主进程调用vue侧的函数</span><br><span class="line">rendererApi.showAddDialog(()=&gt; &#123;</span><br><span class="line">  onAdd();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="新建buildMenu-js"><a href="#新建buildMenu-js" class="headerlink" title="新建buildMenu.js"></a>新建buildMenu.js</h3><p>在<code>controller</code>下新建<code>buildMenu.js</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">import &#123; app, Menu, ipcMain &#125; from &apos;electron&apos;;</span><br><span class="line">import &#123; inject &#125; from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">const isMac = process.platform === &apos;darwin&apos;;</span><br><span class="line"></span><br><span class="line">let mainWindow = null;</span><br><span class="line"></span><br><span class="line">const template = [</span><br><span class="line">  // &#123; role: &apos;appMenu&apos; &#125;</span><br><span class="line">  ...(isMac</span><br><span class="line">    ? [&#123;</span><br><span class="line">        label: app.name,</span><br><span class="line">        submenu: [</span><br><span class="line">          &#123; role: &apos;about&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;services&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;hide&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;hideOthers&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;unhide&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;quit&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;]</span><br><span class="line">    : []),</span><br><span class="line">  // &#123; role: &apos;fileMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;File&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      isMac ? &#123; role: &apos;close&apos; &#125; : &#123; role: &apos;quit&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;editMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;Edit&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;undo&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;redo&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;cut&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;copy&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;paste&apos; &#125;,</span><br><span class="line">      ...(isMac</span><br><span class="line">        ? [</span><br><span class="line">            &#123; role: &apos;pasteAndMatchStyle&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;delete&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;selectAll&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              label: &apos;Speech&apos;,</span><br><span class="line">              submenu: [</span><br><span class="line">                &#123; role: &apos;startSpeaking&apos; &#125;,</span><br><span class="line">                &#123; role: &apos;stopSpeaking&apos; &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        : [</span><br><span class="line">            &#123; role: &apos;delete&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;selectAll&apos; &#125;</span><br><span class="line">          ])</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;viewMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;View&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;reload&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;forceReload&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;toggleDevTools&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;resetZoom&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoomIn&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoomOut&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;togglefullscreen&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;windowMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;Window&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;minimize&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoom&apos; &#125;,</span><br><span class="line">      ...(isMac</span><br><span class="line">        ? [</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;front&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;window&apos; &#125;</span><br><span class="line">          ]</span><br><span class="line">        : [</span><br><span class="line">            &#123; role: &apos;close&apos; &#125;</span><br><span class="line">          ])</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    role: &apos;help&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: &apos;Learn More&apos;,</span><br><span class="line">        click: async () =&gt; &#123;</span><br><span class="line">          const &#123; shell &#125; = require(&apos;electron&apos;)</span><br><span class="line">          await shell.openExternal(&apos;https://electronjs.org&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;actions&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: &apos;添加&apos;,</span><br><span class="line">        click: async ()=&gt; &#123;</span><br><span class="line">          // 触发renderer进程的on-show-add-dialog-event事件</span><br><span class="line">          mainWindow.webContents.send(&apos;on-show-add-dialog-event&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        accelerator: &apos;CommandOrControl+Alt+O&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const menu = Menu.buildFromTemplate(template)</span><br><span class="line">Menu.setApplicationMenu(menu)</span><br><span class="line">export const injectMainWindow = win=&gt; &#123;</span><br><span class="line">  mainWindow = win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在<code>vue</code>侧调用渲染进程暴露的函数，把需要执行的<code>vue</code>侧回调函数传进去。</li><li>渲染进程函数执行后注册了<code>on-show-add-dialog-event</code>这个渲染进程事件。</li><li><code>Menu</code>菜单点击后，主进程触发渲染进程事件，这个事件的回调函数中会执行<code>vue</code>侧提供的回调函数。</li></ul><p>通过上述步骤即可完成主进程-&gt;渲染进程-&gt;<code>vue</code>侧的通信</p><h1 id="托盘-amp-app图标"><a href="#托盘-amp-app图标" class="headerlink" title="托盘&amp;app图标"></a>托盘&amp;app图标</h1><h2 id="mac端"><a href="#mac端" class="headerlink" title="mac端"></a>mac端</h2><p>在<code>controller</code>下新建<code>tray.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 兼容mac电脑</span><br><span class="line">import &#123; Tray &#125; from &apos;electron&apos;;</span><br><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;</span><br><span class="line"></span><br><span class="line">const createTray = (app, win)=&gt; &#123;</span><br><span class="line">  const tray = new Tray(path.resolve(__dirnameFn(import.meta.url), &apos;../icon.png&apos;));</span><br><span class="line">  tray.setToolTip(&apos;electron-tutorial&apos;);</span><br><span class="line">  tray.on(&apos;click&apos;, e=&gt; &#123;</span><br><span class="line">    if(e.shiftKey) &#123;</span><br><span class="line">      app.quit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default createTray;</span><br></pre></td></tr></table></figure></p><p>在<code>main.js</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// tray 兼容mac托盘</span><br><span class="line">import createTray from &apos;./controller/tray.js&apos;;</span><br><span class="line"></span><br><span class="line">createTray(app, win);</span><br></pre></td></tr></table></figure></p><h2 id="window端"><a href="#window端" class="headerlink" title="window端"></a>window端</h2><p>在<code>main.js</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icon: nativeImage.createFromPath(path.resolve(__dirnameFn(import.meta.url), &apos;./icon.png&apos;)),</span><br></pre></td></tr></table></figure></p><h1 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h1><p>全屏功能可以应用在一些终端设备中，比如商场或者机场的自助终端。<br>在<code>main.js</code>中增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 取消浏览器头部菜单栏</span><br><span class="line">frame: false</span><br><span class="line">// 设置全屏</span><br><span class="line">win.maximize();</span><br></pre></td></tr></table></figure></p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @electron-forge/cli -D</span><br><span class="line">npm i @electron-forge/maker-squirrel -D</span><br></pre></td></tr></table></figure></p><h3 id="window端-1"><a href="#window端-1" class="headerlink" title="window端"></a>window端</h3><p>在根目录下新增<code>forge.config.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  makers: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;@electron-forge/maker-squirrel&apos;,</span><br><span class="line">      config: &#123;</span><br><span class="line">        certificateFile: &apos;./cert.pfx&apos;,</span><br><span class="line">        certificatePassword: process.env.CERTIFICATE_PASSWORD</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;make&quot;: &quot;electron-forge make&quot;</span><br></pre></td></tr></table></figure></p><p>执行<code>npm run make</code>,（网络不好有时会失败，重试几次），在根目录输出一个<code>out</code>文件夹。在里边找到项目名称的<code>exe</code>文件就是可执行app。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-packager -D</span><br></pre></td></tr></table></figure></p><h3 id="window端-2"><a href="#window端-2" class="headerlink" title="window端"></a>window端</h3><p>配置可以直接写在scripts脚本中,<code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;make2&quot;: &quot;electron-packager . godex-printer --platform=win32 --arch=x64 --icon=build/icon.ico --out=out --overwrite&quot;</span><br></pre></td></tr></table></figure></p><p>这个打包方式比第一个要快很多，<code>--icon=build/icon.ico</code>这个参数是生成的exe图标设置</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><blockquote><p>此方法可以打包生成安装文件</p></blockquote><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-builder -D</span><br></pre></td></tr></table></figure></p><p>在项目根目录下创建<code>electron-builder.yml</code>文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nsis:</span><br><span class="line">  oneClick: false # 创建一键安装程序还是辅助安装程序（默认是一键安装）</span><br><span class="line">  allowElevation: true # 是否允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序 （仅作用于辅助安装程序）</span><br><span class="line">  allowToChangeInstallationDirectory: true # 是否允许修改安装目录 （仅作用于辅助安装程序）</span><br><span class="line">  createStartMenuShortcut: true # 是否创建开始菜单快捷方式</span><br><span class="line">  artifactName: $&#123;productName&#125;-$&#123;version&#125;-$&#123;platform&#125;-$&#123;arch&#125;.$&#123;ext&#125;</span><br><span class="line">  shortcutName: $&#123;productName&#125;</span><br><span class="line">  uninstallDisplayName: $&#123;productName&#125;</span><br><span class="line">  createDesktopShortcut: always</span><br></pre></td></tr></table></figure></p><p>在<code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;makebuilder&quot;: &quot;electron-builder --win --config&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>第一次执行打包时需要下载打包工具，根据网络实际情况可能会失败，多尝试几次。<br>打包后在<code>dist</code>目录下的<code>.exe</code>文件就是安装执行文件，双击下一步即可安装。</p><h2 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h2><p>开发调试时，<code>main.js</code>中，引入<code>vue</code>侧是<code>win.loadURL(&#39;http://localhost:5173&#39;);</code>这样引入的，这样打包的话，执行<code>app</code>应用时还需要启动<code>vue</code>项目才可以使用。<br>如果想直接把<code>vue</code>侧直接打到<code>app</code>应用包中，修改<code>main.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// win.loadURL(&apos;http://localhost:5173&apos;);</span><br><span class="line">win.loadFile(path.resolve(__dirnameFn(import.meta.url), &apos;./dist/index.html&apos;));</span><br></pre></td></tr></table></figure></p><p>还需要修改<code>dist/index.html</code>中引入的js和css的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="line">&lt;!-- &lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;/assets/index-CrynHw1J.css&quot;&gt; --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;./assets/index-CrynHw1J.css&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>将绝对路径改成相对路径。</p><h2 id="打包后resources文件加密"><a href="#打包后resources文件加密" class="headerlink" title="打包后resources文件加密"></a>打包后resources文件加密</h2><p>在打包之后，输出的可执行exe文件夹下有一个resources文件夹，里边是源代码，因为执行时需要这些源代码文件，不能删除。但是，代码暴露了，为了安全，可以使用<code>asar</code>对源代码封装加密。</p><h3 id="安装asar"><a href="#安装asar" class="headerlink" title="安装asar"></a>安装asar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局安装</span><br><span class="line">npm i -g asar</span><br></pre></td></tr></table></figure><h3 id="执行asar封装源码"><a href="#执行asar封装源码" class="headerlink" title="执行asar封装源码"></a>执行asar封装源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asar pack src src.asar</span><br></pre></td></tr></table></figure><p>将src文件夹封装成了src.asar</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>比如，之前<code>main.js</code>文件需要调用<code>src</code>文件夹里的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./src/index.js&apos;;</span><br></pre></td></tr></table></figure></p><p>封装之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./src.asar/index.js&apos;;</span><br></pre></td></tr></table></figure></p><p>就这么简单，重新打包之后在resources下可以看到src.asar文件了，asar文件轻易破解不了的，起到了一定的安全性，这时可以把文件夹下src源代码删除，提供给客户使用。</p><h1 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h1><p>使用<code>electron-updater</code>实现应用更新<br>详情暂略</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上完成了一个简单的electron+vue的项目。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>本教程代码<a href="https://github.com/jinux7/study-collections/tree/master/electron/base-tutorial" target="_blank" rel="noopener">source</a></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>保存网站的app<br>代码<a href="https://github.com/jinux7/study-collections/tree/master/electron/readit" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;electron+vue3+pinia构建一个桌面应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
      <category term="electron" scheme="/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>pnpm创建monorepo项目</title>
    <link href="/2024/07/04/pnpm%E5%88%9B%E5%BB%BAmonorepo%E9%A1%B9%E7%9B%AE/"/>
    <id>/2024/07/04/pnpm创建monorepo项目/</id>
    <published>2024-07-04T08:15:46.000Z</published>
    <updated>2024-07-05T05:29:50.693Z</updated>
    
    <content type="html"><![CDATA[<p>使用pnpm工具创建monorepo项目<br><a id="more"></a><br>monorepo项目是当下非常流行的，例如React、Vue、Vite等项目都在使用。创建monorepo项目的方法很多，本文使用pnpm来创建。</p><h2 id="全局安装pnpm"><a href="#全局安装pnpm" class="headerlink" title="全局安装pnpm"></a>全局安装pnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>创建一个叫monorepo的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir monorepo</span><br></pre></td></tr></table></figure></p><h2 id="创建相关文件"><a href="#创建相关文件" class="headerlink" title="创建相关文件"></a>创建相关文件</h2><h3 id="初始化package-json"><a href="#初始化package-json" class="headerlink" title="初始化package.json"></a>初始化package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init</span><br></pre></td></tr></table></figure><h3 id="pnpm-workspace-yaml"><a href="#pnpm-workspace-yaml" class="headerlink" title="pnpm-workspace.yaml"></a>pnpm-workspace.yaml</h3><p>新建pnpm-workspace.yaml文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  - &apos;packages/*&apos;</span><br></pre></td></tr></table></figure></p><p>表示packages下是子项目</p><h3 id="npmignore"><a href="#npmignore" class="headerlink" title=".npmignore"></a>.npmignore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/</span><br></pre></td></tr></table></figure><p>这个文件设置发布的时候过滤掉node_modules文件夹的内容</p><h2 id="创建packages文件夹"><a href="#创建packages文件夹" class="headerlink" title="创建packages文件夹"></a>创建packages文件夹</h2><p>在packages下创建子项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir core utils api</span><br></pre></td></tr></table></figure></p><p>创建好三个子项目文件夹后，分别初始化package.json，之后需要修改package.json的name，加上npmjs上所对应的Organizations名字(名字前加@)。<br>再加上<code>&quot;publishConfig&quot;: {&quot;access&quot;: &quot;public&quot;}</code>，用来告诉npmjs这个是公开的（私有是收费的，发布的时候会报错）。<br>core package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/core&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;node ./index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@nux-monorepo/api&quot;: &quot;workspace:^&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>api package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/api&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@nux-monorepo/utils&quot;: &quot;workspace:^&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>utils package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/utils&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><h3 id="公共依赖"><a href="#公共依赖" class="headerlink" title="公共依赖"></a>公共依赖</h3><p>在monorepo目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add loadsh -w</span><br></pre></td></tr></table></figure></p><p><code>-w</code>表示在主项目目录下添加依赖</p><h3 id="局部依赖"><a href="#局部依赖" class="headerlink" title="局部依赖"></a>局部依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @nux-monorepo/utils -F @nux-monorepo/api</span><br></pre></td></tr></table></figure><p>表示给<code>@nux-monorepo/api</code>子项目添加了一个<code>@nux-monorepo/utils</code>的依赖。<br>再加一个依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @nux-monorepo/api -F @nux-monorepo/core</span><br></pre></td></tr></table></figure></p><p>可以看上边的package.json文件,添加依赖后的效果。<br>上边公共依赖和局部依赖执行命令都是在项目的根目录下执行即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以在子项目中运行<code>npm run dev</code>去执行,也可以在主项目下直接执行,在主项目的package.json下添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev:core&quot;: &quot;pnpm -F @nux-monorepo/core dev&quot;</span><br></pre></td></tr></table></figure></p><p>运行结果跟在子项目中是一样的。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="普通发布"><a href="#普通发布" class="headerlink" title="普通发布"></a>普通发布</h3><ul><li>在npmjs官网有一个账号</li><li>在npmjs新建一个Organizations,这个名字就是子项目package.json中name的前缀,<code>@nux-monorepo/core</code>中的<code>nux-monorepo</code></li><li>进入到子项目,执行<code>pnpm publish</code>,注意,这里需要把npm的源设置成官网的<code>https://registry.npmjs.org/</code>(因为npmjs的官方源下载速度慢，平时都会切换国内的镜像地址，这里需要注意下)</li></ul><p>每次发布时需要修改version版本号，一样的话发布会失败。</p><h3 id="脚本发布"><a href="#脚本发布" class="headerlink" title="脚本发布"></a>脚本发布</h3><p>上面的发布需要进入到每个子项目进行发布，非常麻烦，可以编写一个脚本，进行批量发布。<br>这里还有一点，可以在脚本中修改版本号，可以根据不同的规则修改，本文简单起见，把子项目中的version版本号都设置成主项目里的version，但是发布前主项目的version需要手动修改一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const &#123; exec &#125; = require(&apos;child_process&apos;);</span><br><span class="line"></span><br><span class="line">const packagesRoot = &apos;./packages&apos;;</span><br><span class="line">const packageName = &apos;package.json&apos;;</span><br><span class="line">let version;</span><br><span class="line">// 获取主项目package.json中的version</span><br><span class="line">let packageData = fs.readFileSync(path.resolve(&apos;./&apos;, packageName), &apos;utf8&apos;);</span><br><span class="line">version = JSON.parse(packageData).version;</span><br><span class="line">// 发布的命令行执行函数</span><br><span class="line">function publishPackage(packageDir) &#123;</span><br><span class="line">    exec(`cd $&#123;packageDir&#125; &amp;&amp; pnpm publish`, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">      if (error) &#123;</span><br><span class="line">        console.error(`Error publishing $&#123;packageDir&#125;:`, error);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(`Published: $&#123;packageDir&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 扫描子项目函数</span><br><span class="line">function scanAndPublish(directory) &#123;</span><br><span class="line">  fs.readdir(directory, &#123; withFileTypes: true &#125;, (err, files) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      console.error(&apos;Error reading directory:&apos;, err);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files.forEach((file) =&gt; &#123;</span><br><span class="line">      if (file.isDirectory()) &#123;</span><br><span class="line">        // 修改package.json中的version</span><br><span class="line">        let packagePath = path.resolve(&apos;./&apos;, packagesRoot, file.name, packageName);</span><br><span class="line">        let packageData = JSON.parse(fs.readFileSync(packagePath, &apos;utf8&apos;));</span><br><span class="line">        packageData.version = version;</span><br><span class="line">        let writeData = JSON.stringify(packageData, null, 2);</span><br><span class="line">        fs.writeFileSync(packagePath, writeData, &apos;utf8&apos;);</span><br><span class="line">        // 发布</span><br><span class="line">        publishPackage(path.dirname(packagePath));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主入口</span><br><span class="line">scanAndPublish(packagesRoot);</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @nux-monorepo/core</span><br></pre></td></tr></table></figure><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/monorepo/pnpm" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用pnpm工具创建monorepo项目&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="npm" scheme="/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>从零打造一个Web地图引擎</title>
    <link href="/2024/07/03/%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AAWeb%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E/"/>
    <id>/2024/07/03/从零打造一个Web地图引擎/</id>
    <published>2024-07-03T01:19:47.000Z</published>
    <updated>2024-07-03T02:27:57.898Z</updated>
    
    <content type="html"><![CDATA[<p>从零开始，实现一个web地图，类似百度地图的效果<br><a id="more"></a><br>本文clone来至<a href="https://github.com/wanglin2/front-article/blob/main/%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AAWeb%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E.md?plain=1" target="_blank" rel="noopener">wanglin2</a></p><p>说到地图，大家一定很熟悉，平时应该都使用过百度地图、高德地图、腾讯地图等，如果涉及到地图相关的开发需求，也有很多选择，比如前面的几个地图都会提供一套<code>js API</code>，此外也有一些开源地图框架可以使用，比如<code>OpenLayers</code>、<code>Leaflet</code>等。</p><p>那么大家有没有想过这些地图是怎么渲染出来的呢，为什么根据一个经纬度就能显示对应的地图呢，不知道没关系，本文会带各位从零实现一个简单的地图引擎，来帮助大家了解<code>GIS</code>基础知识及<code>Web</code>地图的实现原理。</p><h1 id="选个经纬度"><a href="#选个经纬度" class="headerlink" title="选个经纬度"></a>选个经纬度</h1><p>首先我们去高德地图上选个经纬度，作为我们后期的地图中心点，打开<a href="https://lbs.amap.com/tools/picker" target="_blank" rel="noopener">高德坐标拾取</a>工具，随便选择一个点：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/1.png" alt="1.png"></p><p>笔者选择了杭州的雷峰塔，经纬度为：<code>[120.148732,30.231006]</code>。</p><h1 id="瓦片url分析"><a href="#瓦片url分析" class="headerlink" title="瓦片url分析"></a>瓦片url分析</h1><p>地图瓦片我们使用高德的在线瓦片，地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>目前各大地图厂商的瓦片服务遵循的规则是有不同的：</p><blockquote><p>谷歌XYZ规范：谷歌地图、OpenStreetMap、高德地图、geoq、天地图，坐标原点在左上角</p><p>TMS规范：腾讯地图，坐标原点在左下角</p><p>WMTS规范：原点在左上角，瓦片不是正方形，而是矩形，这个应该是官方标准</p><p>百度地图比较特立独行，投影、分辨率、坐标系都跟其他厂商不一样，原点在经纬度都为0的位置，也就是中间，向右为X正方向，向上为Y正方向</p></blockquote><p>谷歌和<code>TMS</code>的瓦片区别可以通过该地址可视化的查看：<a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#1/25.12/-0.61" target="_blank" rel="noopener">地图瓦片</a>。</p><p>虽然规范不同，但原理基本是一致的，都是把地球投影成一个巨大的正方形世界平面图，然后按照四叉树进行分层切割，比如第一层，只有一张瓦片，显示整个世界的信息，所以基本只能看到洲和海的名称和边界线，第二层，切割成四张瓦片，显示信息稍微多了一点，以此类推，就像一个金字塔一样，底层分辨率最高，显示的细节最多，瓦片数也最多，顶层分辨率最低，显示的信息很少，瓦片数量相对也最少：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/2.png" alt="2.png"></p><p>每一层的瓦片数量计算公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(Math.pow(2, n), 2)// 行*列：2^n * 2^n</span><br></pre></td></tr></table></figure><p>十八层就需要<code>68719476736</code>张瓦片，所以一套地图瓦片整体数量是非常庞大的。</p><p>瓦片切好以后，通过行列号和缩放层级来保存，所以可以看到瓦片地址中有三个变量：<code>x</code>、<code>y</code>、<code>z</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x：行号</span><br><span class="line">y：列号</span><br><span class="line">z：分辨率，一般为0-18</span><br></pre></td></tr></table></figure><p>通过这三个变量就可以定位到一张瓦片，比如下面这个地址，行号为<code>109280</code>，列号为<code>53979</code>，缩放层级为<code>17</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>对应的瓦片为：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/3.png" alt="3.png"></p><p>关于瓦片的更多信息可以阅读<a href="https://segmentfault.com/a/1190000011276788" target="_blank" rel="noopener">瓦片地图原理</a>。</p><h1 id="坐标系简介"><a href="#坐标系简介" class="headerlink" title="坐标系简介"></a>坐标系简介</h1><p>高德地图使用的是<code>GCJ-02坐标系</code>，也称火星坐标系，由中国国家测绘局在02年发布，是在GPS坐标（<code>WGS-84</code>坐标系）基础上经加密后而来，也就是增加了非线性的偏移，让你摸不准真实位置，为了国家安全，国内地图服务商都需要使用<code>GCJ-02坐标系</code>。</p><p><code>WGS-84</code>坐标系是国际通用的标准，<code>EPSG</code>编号为<code>EPSG:4326</code>，通常GPS设备获取到的原始经纬度和国外的地图厂商使用的都是<code>WGS-84</code>坐标系。</p><p>这两种坐标系都是地理坐标系，球面坐标，单位为<code>度</code>，这种坐标方便在地球上定位，但是不方便展示和进行面积距离计算，我们印象中的地图都是平面的，所以就有了另外一种平面坐标系，平面坐标系是通过投影的方式从地理坐标系中转换过来，所以也称为投影坐标系，通常单位为<code>米</code>，投影坐标系根据投影方式的不同存在多种，在<code>Web</code>开发的场景里通常使用的是<code>Web墨卡托投影</code>，编号为<code>EPSG:3857</code>，它基于<code>墨卡托投影</code>，把<code>WGS-84</code>坐标系投影成正方形：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/4.png" alt="4.png"></p><p>这是通过舍弃了南北<code>85.051129纬度</code>以上的地区实现的，因为它是正方形，所以一个大的正方形可以很方便的被分割为更小的正方形。</p><p>坐标系更详细的信息可参考<a href="https://juejin.cn/post/6924478988307922957" target="_blank" rel="noopener">GIS之坐标系统</a>，<code>EPSG:3857</code>的详细信息可参考<a href="http://epsg.io/3857" target="_blank" rel="noopener">EPSG:3857</a>。</p><h1 id="经纬度定位行列号"><a href="#经纬度定位行列号" class="headerlink" title="经纬度定位行列号"></a>经纬度定位行列号</h1><p>上一节里我们简单介绍了一下坐标系，按照<code>Web</code>地图的标准，我们的地图引擎也选择支持<code>EPSG:3857</code>投影，但是我们通过高德工具获取到的是火星坐标系的经纬度坐标，所以第一步要把经纬度坐标转换为<code>Web墨卡托</code>投影坐标，这里为了简单，先直接把火星坐标当做<code>WGS-84</code>坐标，后面再来看这个问题。</p><p>转换方法网上一搜就有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 角度转弧度</span></span><br><span class="line"><span class="keyword">const</span> angleToRad = <span class="function">(<span class="params">angle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> angle * (<span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弧度转角度</span></span><br><span class="line"><span class="keyword">const</span> radToAngle = <span class="function">(<span class="params">rad</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rad * (<span class="number">180</span> / <span class="built_in">Math</span>.PI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地球半径</span></span><br><span class="line"><span class="keyword">const</span> EARTH_RAD = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4326转3857</span></span><br><span class="line"><span class="keyword">const</span> lngLat2Mercator = <span class="function">(<span class="params">lng, lat</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 经度先转弧度，然后因为 弧度 = 弧长 / 半径 ，得到弧长为 弧长 = 弧度 * 半径 </span></span><br><span class="line">    <span class="keyword">let</span> x = angleToRad(lng) * EARTH_RAD; </span><br><span class="line">    <span class="comment">// 纬度先转弧度</span></span><br><span class="line">    <span class="keyword">let</span> rad = angleToRad(lat)</span><br><span class="line">    <span class="comment">// 下面我就看不懂了，各位随意。。。</span></span><br><span class="line">    <span class="keyword">let</span> sin = <span class="built_in">Math</span>.sin(rad)</span><br><span class="line">    <span class="keyword">let</span> y = EARTH_RAD / <span class="number">2</span> * <span class="built_in">Math</span>.log((<span class="number">1</span> + sin) / (<span class="number">1</span> - sin))</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3857转4326</span></span><br><span class="line"><span class="keyword">const</span> mercatorTolnglat = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lng = radToAngle(x) / EARTH_RAD</span><br><span class="line">    <span class="keyword">let</span> lat = radToAngle((<span class="number">2</span> * <span class="built_in">Math</span>.atan(<span class="built_in">Math</span>.exp(y / EARTH_RAD)) - (<span class="built_in">Math</span>.PI / <span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> [lng, lat]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3857</code>坐标有了，它的单位是<code>米</code>，那么怎么转换成瓦片的行列号呢，这就涉及到<code>分辨率</code>的概念了，即地图上一像素代表实际多少米，分辨率如果能从地图厂商的文档里获取是最好的，如果找不到，也可以简单计算一下（如果使用计算出来的也不行，那就只能求助搜索引擎了），我们知道地球半径是<code>6378137</code>米，<code>3857</code>坐标系把地球当做正圆球体来处理，所以可以算出地球周长，投影是贴着地球赤道的：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/5.png" alt="5.png"></p><p>所以投影成正方形的世界平面图后的边长代表的就是地球的周长，前面我们也知道了每一层级的瓦片数量的计算方式，而一张瓦片的大小一般是<code>256*256</code>像素，所以用地球周长除以展开后的世界平面图的边长就知道了地图上每像素代表实际多少米：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地球周长</span></span><br><span class="line"><span class="keyword">const</span> EARTH_PERIMETER = <span class="number">2</span> * <span class="built_in">Math</span>.PI * EARTH_RAD</span><br><span class="line"><span class="comment">// 瓦片像素</span></span><br><span class="line"><span class="keyword">const</span> TILE_SIZE = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某一层级下的分辨率</span></span><br><span class="line"><span class="keyword">const</span> getResolution = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tileNums = <span class="built_in">Math</span>.pow(<span class="number">2</span>, n)</span><br><span class="line">    <span class="keyword">const</span> tileTotalPx = tileNums * TILE_SIZE</span><br><span class="line">    <span class="keyword">return</span> EARTH_PERIMETER / tileTotalPx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地球周长算出来是<code>40075016.68557849</code>，可以看到<code>OpenLayers</code>就是这么计算的：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/5-5.webp" alt="5-5.webp"></p><p><code>3857</code>坐标的单位是<code>米</code>，那么把坐标除以分辨率就可以得到对应的像素坐标，再除以<code>256</code>，就可以得到瓦片的行列号：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/6.png" alt="6.png"></p><p>函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据3857坐标及缩放层级计算瓦片行列号</span></span><br><span class="line"><span class="keyword">const</span> getTileRowAndCol = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resolution = getResolution(z)</span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">Math</span>.floor(x / resolution / TILE_SIZE)</span><br><span class="line">    <span class="keyword">let</span> col = <span class="built_in">Math</span>.floor(y / resolution / TILE_SIZE)</span><br><span class="line">    <span class="keyword">return</span> [row, col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们把层级固定为<code>17</code>，那么分辨率<code>resolution</code>就是<code>1.194328566955879</code>，雷峰塔的经纬度转成<code>3857</code>的坐标为：<code>[13374895.665697495, 3533278.205310311]</code>，使用上面的函数计算出来行列号为：<code>[43744, 11556]</code>，我们把这几个数据代入瓦片的地址里进行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=43744&amp;y=11556&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p><img src="/2024/07/03/从零打造一个Web地图引擎/7.png" alt="7.png"></p><p>一片空白，这是为啥呢，其实是因为原点不一样，<code>4326</code>和<code>3857</code>坐标系的原点在赤道和本初子午线相交点，非洲边上的海里，而瓦片的原点在左上角：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/8.png" alt="8.png"></p><p>再来看下图会更容易理解：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/9.png" alt="9.png"></p><p><code>3857</code>坐标系的原点相当于在世界平面图的中间，向右为<code>x</code>轴正方向，向上为<code>y</code>轴正方向，而瓦片地图的原点在左上角，所以我们需要根据图上【绿色虚线】的距离计算出【橙色实线】的距离，这也很简单，水平坐标就是水平绿色虚线的长度加上世界平面图的一半，垂直坐标就是世界平面图的一半减去垂直绿色虚线的长度，世界平面图的一半也就是地球周长的一半，修改<code>getTileRowAndCol</code>函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTileRowAndCol = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">  x += EARTH_PERIMETER / <span class="number">2</span>     <span class="comment">// ++</span></span><br><span class="line">  y = EARTH_PERIMETER / <span class="number">2</span> - y  <span class="comment">// ++</span></span><br><span class="line">  <span class="keyword">let</span> resolution = getResolution(z)</span><br><span class="line">  <span class="keyword">let</span> row = <span class="built_in">Math</span>.floor(x / resolution / TILE_SIZE)</span><br><span class="line">  <span class="keyword">let</span> col = <span class="built_in">Math</span>.floor(y / resolution / TILE_SIZE)</span><br><span class="line">  <span class="keyword">return</span> [row, col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次计算出来的瓦片行列号为<code>[109280, 53979]</code>，代入瓦片地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/10.png" alt="10.png"></p><p>可以看到雷峰塔出来了。</p><h1 id="瓦片显示位置计算"><a href="#瓦片显示位置计算" class="headerlink" title="瓦片显示位置计算"></a>瓦片显示位置计算</h1><p>我们现在能根据一个经纬度找到对应的瓦片，但是这还不够，我们的目标是要能在浏览器上显示出来，这就需要解决两个问题，一个是加载多少块瓦片，二是计算每一块瓦片的显示位置。</p><p>渲染瓦片我们使用<code>canvas</code>画布，模板如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"map"</span> <span class="attr">ref</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>地图画布容器<code>map</code>的大小我们很容易获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器大小</span></span><br><span class="line"><span class="keyword">let</span> &#123; width, height &#125; = <span class="keyword">this</span>.$refs.map.getBoundingClientRect()</span><br><span class="line"><span class="keyword">this</span>.width = width</span><br><span class="line"><span class="keyword">this</span>.height = height</span><br><span class="line"><span class="comment">// 设置画布大小</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="keyword">this</span>.$refs.canvas</span><br><span class="line">canvas.width = width</span><br><span class="line">canvas.height = height</span><br><span class="line"><span class="comment">// 获取绘图上下文</span></span><br><span class="line"><span class="keyword">this</span>.ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></table></figure><p>地图中心点我们设在画布中间，另外中心点的经纬度<code>center</code>和缩放层级<code>zoom</code>因为都是我们自己设定的，所以也是已知的，那么我们可以计算出中心坐标对应的瓦片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心点对应的瓦片</span></span><br><span class="line"><span class="keyword">let</span> centerTile = getTileRowAndCol(</span><br><span class="line">    ...lngLat2Mercator(...this.center),<span class="comment">// 4326转3857</span></span><br><span class="line">    <span class="keyword">this</span>.zoom<span class="comment">// 缩放层级</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>缩放层级还是设为<code>17</code>，中心点还是使用雷峰塔的经纬度，那么对应的瓦片行列号前面我们已经计算过了，为<code>[109280, 53979]</code>。</p><p>中心坐标对应的瓦片行列号知道了，那么该瓦片左上角在世界平面图中的像素位置我们也就知道了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心瓦片左上角对应的像素坐标</span></span><br><span class="line"><span class="keyword">let</span> centerTilePos = [centerTile[<span class="number">0</span>] * TILE_SIZE, centerTile[<span class="number">1</span>] * TILE_SIZE]</span><br></pre></td></tr></table></figure><p>计算出来为<code>[27975680, 13818624]</code>。这个坐标怎么转换到屏幕上呢，请看下图：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/11.png" alt="11.png"></p><p>中心经纬度的瓦片我们计算出来了，瓦片左上角的像素坐标也知道了，然后我们再计算出中心经纬度本身对应的像素坐标，那么和瓦片左上角的差值就可以计算出来，最后我们把画布的原点移动到画布中间（画布默认原点为左上角，x轴正方向向右，y轴正方向向下），也就是把中心经纬度作为坐标原点，那么中心瓦片的显示位置就是这个差值。</p><p>补充一下将经纬度转换成像素的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算4326经纬度对应的像素坐标</span></span><br><span class="line"><span class="keyword">const</span> getPxFromLngLat = <span class="function">(<span class="params">lng, lat, z</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [_x, _y] = lngLat2Mercator(lng, lat)<span class="comment">// 4326转3857</span></span><br><span class="line">  <span class="comment">// 转成世界平面图的坐标</span></span><br><span class="line">  _x += EARTH_PERIMETER / <span class="number">2</span></span><br><span class="line">  _y = EARTH_PERIMETER / <span class="number">2</span> - _y</span><br><span class="line">  <span class="keyword">let</span> resolution = resolutions[z]<span class="comment">// 该层级的分辨率</span></span><br><span class="line">  <span class="comment">// 米/分辨率得到像素</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">Math</span>.floor(_x / resolution)</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Math</span>.floor(_y / resolution)</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算中心经纬度对应的像素坐标：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心点对应的像素坐标</span></span><br><span class="line"><span class="keyword">let</span> centerPos = getPxFromLngLat(...this.center, <span class="keyword">this</span>.zoom)</span><br></pre></td></tr></table></figure><p>计算差值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心像素坐标距中心瓦片左上角的差值</span></span><br><span class="line"><span class="keyword">let</span> offset = [</span><br><span class="line">    centerPos[<span class="number">0</span>] - centerTilePos[<span class="number">0</span>],</span><br><span class="line">    centerPos[<span class="number">1</span>] - centerTilePos[<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后通过<code>canvas</code>来把中心瓦片渲染出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动画布原点到画布中间</span></span><br><span class="line"><span class="keyword">this</span>.ctx.translate(<span class="keyword">this</span>.width / <span class="number">2</span>, <span class="keyword">this</span>.height / <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 加载瓦片图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"><span class="comment">// 拼接瓦片地址</span></span><br><span class="line">img.src = getTileUrl(...centerTile, <span class="keyword">this</span>.zoom)</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 渲染到canvas</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.drawImage(img, -offset[<span class="number">0</span>], -offset[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先来看看<code>getTileUrl</code>方法的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接瓦片地址</span></span><br><span class="line"><span class="keyword">const</span> getTileUrl = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> domainIndexList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  <span class="keyword">let</span> domainIndex =</span><br><span class="line">    domainIndexList[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * domainIndexList.length)]</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`https://webrd0<span class="subst">$&#123;domainIndex&#125;</span>.is.autonavi.com/appmaptile?x=<span class="subst">$&#123;x&#125;</span>&amp;y=<span class="subst">$&#123;y&#125;</span>&amp;z=<span class="subst">$&#123;z&#125;</span>&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里随机了四个子域：<code>webrd01</code>、<code>webrd02</code>、<code>webrd03</code>、<code>webrd04</code>，这是因为浏览器对于同一域名同时请求的资源是有数量限制的，而当地图层级变大后需要加载的瓦片数量会比较多，那么均匀分散到各个子域下去请求可以更快的渲染出所有瓦片，减少排队等待时间，基本所有地图厂商的瓦片服务地址都支持多个子域。</p><p>为了方便看到中心点的位置，我们再额外渲染两条中心辅助线，效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/12.png" alt="12.png"></p><p>可以看到中心点确实是雷峰塔，当然这只是渲染了中心瓦片，我们要的是瓦片铺满整个画布，对于其他瓦片我们都可以根据中心瓦片计算出来，比如中心瓦片左边的一块，它的计算如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瓦片行列号，行号减1，列号不变</span></span><br><span class="line"><span class="keyword">let</span> leftTile = [centerTile[<span class="number">0</span>] - <span class="number">1</span>, centerTile[<span class="number">1</span>]]</span><br><span class="line"><span class="comment">// 瓦片显示坐标，x轴减去一个瓦片的大小，y轴不变</span></span><br><span class="line"><span class="keyword">let</span> leftTilePos = [</span><br><span class="line">    offset[<span class="number">0</span>] - TILE_SIZE * <span class="number">1</span>,</span><br><span class="line">    offset[<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以我们只要计算出中心瓦片四个方向各需要几块瓦片，然后用一个双重循环即可计算出画布需要的所有瓦片，计算需要的瓦片数量很简单，请看下图：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/13.png" alt="13.png"></p><p>画布宽高的一半减去中心瓦片占据的空间即可得到该方向剩余的空间，然后除以瓦片的尺寸就知道需要几块瓦片了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算瓦片数量</span></span><br><span class="line"><span class="keyword">let</span> rowMinNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.width / <span class="number">2</span> - offset[<span class="number">0</span>]) / TILE_SIZE)<span class="comment">// 左</span></span><br><span class="line"><span class="keyword">let</span> colMinNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.height / <span class="number">2</span> - offset[<span class="number">1</span>]) / TILE_SIZE)<span class="comment">// 上</span></span><br><span class="line"><span class="keyword">let</span> rowMaxNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.width / <span class="number">2</span> - (TILE_SIZE - offset[<span class="number">0</span>])) / TILE_SIZE)<span class="comment">// 右</span></span><br><span class="line"><span class="keyword">let</span> colMaxNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.height / <span class="number">2</span> - (TILE_SIZE - offset[<span class="number">1</span>])) / TILE_SIZE)<span class="comment">// 下</span></span><br></pre></td></tr></table></figure><p>我们把中心瓦片作为原点，坐标为<code>[0, 0]</code>，来个双重循环扫描一遍即可渲染出所有瓦片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上到下，从左到右，加载瓦片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = -colMinNum; j &lt;= colMaxNum; j++) &#123;</span><br><span class="line">        <span class="comment">// 加载瓦片图片</span></span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.src = getTileUrl(</span><br><span class="line">            centerTile[<span class="number">0</span>] + i,<span class="comment">// 行号</span></span><br><span class="line">            centerTile[<span class="number">1</span>] + j,<span class="comment">// 列号</span></span><br><span class="line">            <span class="keyword">this</span>.zoom</span><br><span class="line">        )</span><br><span class="line">        img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 渲染到canvas</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.drawImage(</span><br><span class="line">                img, </span><br><span class="line">                i * TILE_SIZE - offset[<span class="number">0</span>], </span><br><span class="line">                j * TILE_SIZE - offset[<span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/14.png" alt="14.png"></p><p>很完美。</p><h1 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h1><p>拖动可以这么考虑，前面已经实现了渲染指定经纬度的瓦片，当我们按住进行拖动时，可以知道鼠标滑动的距离，然后把该距离，也就是像素转换成经纬度的数值，最后我们再更新当前中心点的经纬度，并清空画布，调用之前的方法重新渲染，不停重绘造成是在移动的视觉假象。</p><p>监听鼠标相关事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"canvas"</span> @<span class="attr">mousedown</span>=<span class="string">"onMousedown"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isMousedown: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"mousemove"</span>, <span class="keyword">this</span>.onMousemove);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"mouseup"</span>, <span class="keyword">this</span>.onMouseup);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标按下</span></span><br><span class="line">        onMousedown(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.which === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.isMousedown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标移动</span></span><br><span class="line">        onMousemove(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isMousedown) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标松开</span></span><br><span class="line">        onMouseup() &#123;</span><br><span class="line">            <span class="keyword">this</span>.isMousedown = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onMousemove</code>方法里计算拖动后的中心经纬度及重新渲染画布：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算本次拖动的距离对应的经纬度数据</span></span><br><span class="line"><span class="keyword">let</span> mx = e.movementX * resolutions[<span class="keyword">this</span>.zoom];</span><br><span class="line"><span class="keyword">let</span> my = e.movementY * resolutions[<span class="keyword">this</span>.zoom];</span><br><span class="line"><span class="comment">// 把当前中心点经纬度转成3857坐标</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = lngLat2Mercator(...this.center);</span><br><span class="line"><span class="comment">// 更新拖动后的中心点经纬度</span></span><br><span class="line">center = mercatorToLngLat(x - mx, my + y);</span><br></pre></td></tr></table></figure><p><code>movementX</code>和<code>movementY</code>属性能获取本次和上一次鼠标事件中的移动值，兼容性不是很好，不过自己计算该值也很简单，详细请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/movementX" target="_blank" rel="noopener">MDN</a>。乘以当前分辨率把<code>像素</code>换算成<code>米</code>，然后把当前中心点经纬度也转成<code>3857</code>的<code>米</code>坐标，偏移本次移动的距离，最后再转回<code>4326</code>的经纬度坐标作为更新后的中心点即可。</p><p>为什么<code>x</code>是减，<code>y</code>是加呢，很简单，我们鼠标向右和向下移动时距离是正的，相应的地图会向右或向下移动，<code>4326</code>坐标系向右和向上为正方向，那么地图向右移动时，中心点显然是相对来说是向左移了，因为向右为正方向，所以中心点经度方向就是减少了，所以是减去移动的距离，而地图向下移动，中心点相对来说是向上移了，因为向上为正方向，所以中心点纬度方向就是增加了，所以加上移动的距离。</p><p>更新完中心经纬度，然后清空画布重新绘制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空画布</span></span><br><span class="line"><span class="keyword">this</span>.clear();</span><br><span class="line"><span class="comment">// 重新绘制，renderTiles方法就是上一节的代码逻辑封装</span></span><br><span class="line"><span class="keyword">this</span>.renderTiles();</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/15.gif" alt="15.gif"></p><p>可以看到已经凌乱了，这是为啥呢，其实是因为图片加载是一个异步的过程，我们鼠标移动过程中，会不断的计算出要加载的瓦片进行加载，但是可能上一批瓦片还没加载完成，鼠标已经移动到新的位置了，又计算出一批新的瓦片进行加载，此时上一批瓦片可能加载完成并渲染出来了，但是这些瓦片有些可能已经被移除画布，不需要显示，有些可能还在画布内，但是使用的还是之前的位置，渲染出来也是不对的，同时新的一批瓦片可能也加载完成并渲染出来，自然导致了最终显示的错乱。</p><p>知道原因就简单了，首先我们加个缓存对象，因为在拖动过程中，很多瓦片只是位置变了，不需要重新加载，同一个瓦片加载一次，后续只更新它的位置即可；另外再设置一个对象来记录当前画布上应该显示的瓦片，防止不应该出现的瓦片渲染出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缓存瓦片</span></span><br><span class="line">    tileCache: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 记录当前画布上需要的瓦片</span></span><br><span class="line">    currentTileCache: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为需要记录瓦片的位置、加载状态等信息，我们创建一个瓦片类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瓦片类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opt = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 画布上下文</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx</span><br><span class="line">    <span class="comment">// 瓦片行列号</span></span><br><span class="line">    <span class="keyword">this</span>.row = row</span><br><span class="line">    <span class="keyword">this</span>.col = col</span><br><span class="line">    <span class="comment">// 瓦片层级</span></span><br><span class="line">    <span class="keyword">this</span>.zoom = zoom</span><br><span class="line">    <span class="comment">// 显示位置</span></span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">    <span class="comment">// 一个函数，判断某块瓦片是否应该渲染</span></span><br><span class="line">    <span class="keyword">this</span>.shouldRender = shouldRender</span><br><span class="line">    <span class="comment">// 瓦片url</span></span><br><span class="line">    <span class="keyword">this</span>.url = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 缓存key</span></span><br><span class="line">    <span class="keyword">this</span>.cacheKey = <span class="keyword">this</span>.row + <span class="string">'_'</span> + <span class="keyword">this</span>.col + <span class="string">'_'</span> + <span class="keyword">this</span>.zoom</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">this</span>.img = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 图片是否加载完成</span></span><br><span class="line">    <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.createUrl()</span><br><span class="line">    <span class="keyword">this</span>.load()</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 生成url</span></span><br><span class="line">  createUrl() &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = getTileUrl(<span class="keyword">this</span>.row, <span class="keyword">this</span>.col, <span class="keyword">this</span>.zoom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载图片</span></span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="keyword">this</span>.img = <span class="keyword">new</span> Image()</span><br><span class="line">    <span class="keyword">this</span>.img.src = <span class="keyword">this</span>.url</span><br><span class="line">    <span class="keyword">this</span>.img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将图片渲染到canvas上</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.loaded || !<span class="keyword">this</span>.shouldRender(<span class="keyword">this</span>.cacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ctx.drawImage(<span class="keyword">this</span>.img, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 更新位置</span></span><br><span class="line">  updatePos(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改之前的双重循环渲染瓦片的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.currentTileCache = &#123;&#125;<span class="comment">// 清空缓存对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = -colMinNum; j &lt;= colMaxNum; j++) &#123;</span><br><span class="line">        <span class="comment">// 当前瓦片的行列号</span></span><br><span class="line">        <span class="keyword">let</span> row = centerTile[<span class="number">0</span>] + i</span><br><span class="line">        <span class="keyword">let</span> col = centerTile[<span class="number">1</span>] + j</span><br><span class="line">        <span class="comment">// 当前瓦片的显示位置</span></span><br><span class="line">        <span class="keyword">let</span> x = i * TILE_SIZE - offset[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> y = j * TILE_SIZE - offset[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 缓存key</span></span><br><span class="line">        <span class="keyword">let</span> cacheKey = row + <span class="string">'_'</span> + col + <span class="string">'_'</span> + <span class="keyword">this</span>.zoom</span><br><span class="line">        <span class="comment">// 记录画布当前需要的瓦片</span></span><br><span class="line">        <span class="keyword">this</span>.currentTileCache[cacheKey] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 该瓦片已加载过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tileCache[cacheKey]) &#123;</span><br><span class="line">            <span class="comment">// 更新到当前位置</span></span><br><span class="line">            <span class="keyword">this</span>.tileCache[cacheKey].updatePos(x, y).render()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未加载过</span></span><br><span class="line">            <span class="keyword">this</span>.tileCache[cacheKey] = <span class="keyword">new</span> Tile(&#123;</span><br><span class="line">                ctx: <span class="keyword">this</span>.ctx,</span><br><span class="line">                row,</span><br><span class="line">                col,</span><br><span class="line">                zoom: <span class="keyword">this</span>.zoom,</span><br><span class="line">                x,</span><br><span class="line">                y,</span><br><span class="line">                <span class="comment">// 判断瓦片是否在当前画布缓存对象上，是的话则代表需要渲染</span></span><br><span class="line">                shouldRender: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.currentTileCache[key]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/16.gif" alt="16.gif"></p><p>可以看到，拖动已经正常了，当然，上述实现还是很粗糙的，需要优化的地方很多，比如：</p><p>1.一般会先排个序，优先加载中心瓦片</p><p>2.缓存的瓦片越来越多肯定也会影响性能，所以还需要一些清除策略</p><p>这些问题有兴趣的可以自行思考。</p><h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><p>拖动是实时更新中心点经纬度，那么缩放自然更新缩放层级就行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 缩放层级范围</span></span><br><span class="line">            minZoom: <span class="number">3</span>,</span><br><span class="line">            maxZoom: <span class="number">18</span>,</span><br><span class="line">            <span class="comment">// 防抖定时器</span></span><br><span class="line">            zoomTimer: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'wheel'</span>, <span class="keyword">this</span>.onMousewheel)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标滚动</span></span><br><span class="line">        onMousewheel(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 层级变小</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &gt; <span class="keyword">this</span>.minZoom) <span class="keyword">this</span>.zoom--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 层级变大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &lt; <span class="keyword">this</span>.maxZoom) <span class="keyword">this</span>.zoom++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加个防抖，防止快速滚动加载中间过程的瓦片</span></span><br><span class="line">            <span class="keyword">this</span>.zoomTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.clear()</span><br><span class="line">                <span class="keyword">this</span>.renderTiles()</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/17.gif" alt="17.gif"></p><p>功能是有了，不过效果很一般，因为我们平常使用的地图缩放都是有一个放大或缩小的过渡动画，而这个是直接空白然后重新渲染，不仔细看都不知道是放大还是缩小。</p><p>所以我们不妨加个过渡效果，当我们鼠标滚动后，先将画布放大或缩小，动画结束后再根据最终的缩放值来渲染需要的瓦片。</p><p>画布默认缩放值为<code>1</code>，放大则在此基础上乘以<code>2</code>倍，缩小则除以<code>2</code>，然后动画到目标值，动画期间设置画布的缩放值及清空画布，重新绘制画布上的已有瓦片，达到放大或缩小的视觉效果，动画结束后再调用<code>renderTiles</code>重新渲染最终缩放值需要的瓦片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画使用popmotion库，https://popmotion.io/</span></span><br><span class="line"><span class="keyword">import</span> &#123; animate &#125; <span class="keyword">from</span> <span class="string">'popmotion'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            lastZoom: <span class="number">0</span>,</span><br><span class="line">            scale: <span class="number">1</span>,</span><br><span class="line">            scaleTmp: <span class="number">1</span>,</span><br><span class="line">            playback: <span class="literal">null</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标滚动</span></span><br><span class="line">        onMousewheel(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 层级变小</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &gt; <span class="keyword">this</span>.minZoom) <span class="keyword">this</span>.zoom--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 层级变大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &lt; <span class="keyword">this</span>.maxZoom) <span class="keyword">this</span>.zoom++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 层级未发生改变</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastZoom === <span class="keyword">this</span>.zoom) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.lastZoom = <span class="keyword">this</span>.zoom</span><br><span class="line">            <span class="comment">// 更新缩放比例，也就是目标缩放值</span></span><br><span class="line">            <span class="keyword">this</span>.scale *= e.deltaY &gt; <span class="number">0</span> ? <span class="number">0.5</span> : <span class="number">2</span></span><br><span class="line">            <span class="comment">// 停止上一次动画</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.playback) &#123;</span><br><span class="line">                <span class="keyword">this</span>.playback.stop()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启动画</span></span><br><span class="line">            <span class="keyword">this</span>.playback = animate(&#123;</span><br><span class="line">                <span class="keyword">from</span>: <span class="keyword">this</span>.scaleTmp,<span class="comment">// 当前缩放值</span></span><br><span class="line">                to: <span class="keyword">this</span>.scale,<span class="comment">// 目标缩放值</span></span><br><span class="line">                onUpdate: <span class="function">(<span class="params">latest</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 实时更新当前缩放值</span></span><br><span class="line">                    <span class="keyword">this</span>.scaleTmp = latest</span><br><span class="line">                    <span class="comment">// 保存画布之前状态，原因有二：</span></span><br><span class="line">                    <span class="comment">// 1.scale方法是会在之前的状态上叠加的，比如初始是1，第一次执行scale(2,2)，第二次执行scale(3,3)，最终缩放值不是3，而是6，所以每次缩放完就恢复状态，那么就相当于每次都是从初始值1开始缩放，效果就对了</span></span><br><span class="line">                    <span class="comment">// 2.保证缩放效果只对重新渲染已有瓦片生效，不会对最后的renderTiles()造成影响</span></span><br><span class="line">                    <span class="keyword">this</span>.ctx.save()</span><br><span class="line">                    <span class="keyword">this</span>.clear()</span><br><span class="line">                    <span class="keyword">this</span>.ctx.scale(latest, latest)</span><br><span class="line">                    <span class="comment">// 刷新当前画布上的瓦片</span></span><br><span class="line">                    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.currentTileCache).forEach(<span class="function">(<span class="params">tile</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.tileCache[tile].render()</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">// 恢复到画布之前状态</span></span><br><span class="line">                    <span class="keyword">this</span>.ctx.restore()</span><br><span class="line">                &#125;,</span><br><span class="line">                onComplete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 动画完成后将缩放值重置为1</span></span><br><span class="line">                    <span class="keyword">this</span>.scale = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">this</span>.scaleTmp = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 根据最终缩放值重新计算需要的瓦片并渲染</span></span><br><span class="line">                    <span class="keyword">this</span>.renderTiles()</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/17.gif" alt="17.gif"></p><p>虽然效果还是一般，不过至少能看出来是在放大还是缩小。</p><h1 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h1><p>前面还遗留了一个小问题，即我们把高德工具上选出的经纬度直接当做<code>4326</code>经纬度，前面也讲过，它们之间是存在偏移的，比如手机<code>GPS</code>获取到的经纬度一般都是<code>84</code>坐标，直接在高德地图显示，会发现和你实际位置不一样，所以就需要进行一个转换，有一些工具可以帮你做些事情，比如<a href="https://github.com/hujiulong/gcoord" target="_blank" rel="noopener">Gcoord</a>、<a href="https://github.com/wandergis/coordtransform" target="_blank" rel="noopener">coordtransform</a>等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述效果看着比较一般，其实只要在上面的基础上稍微加一点瓦片的淡出动画，效果就会好很多，目前一般都是使用<code>canvas</code>来渲染<code>2D</code>地图，如果自己实现动画不太方便，也有一些强大的<code>canvas</code>库可以选择，笔者最后使用<a href="https://konvajs.org/" target="_blank" rel="noopener">Konva.js</a>库重做了一版，加入了瓦片淡出动画，最终效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/18.gif" alt="18.gif"></p><p>另外只要搞清楚各个地图的瓦片规则，就能稍加修改支持更多的地图瓦片：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/19.webp" alt="19.webp"></p><p>具体实现限于篇幅不再展开，有兴趣的可以阅读本文源码。</p><p>本文详细的介绍了一个简单的<code>web</code>地图开发过程，上述实现原理仅是笔者的个人思路，不代表<code>openlayers</code>等框架的原理，因为笔者也是<code>GIS</code>的初学者，所以难免会有问题，或更好的实现，欢迎指出。</p><p>完整源码：<a href="https://github.com/jinux7/study-collections/tree/master/web%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从零开始，实现一个web地图，类似百度地图的效果&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
      <category term="canvas" scheme="/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>《Vue.js 设计与实现》速读</title>
    <link href="/2024/06/21/%E3%80%8AVue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%80%9F%E8%AF%BB/"/>
    <id>/2024/06/21/《Vue-js-设计与实现》速读/</id>
    <published>2024-06-21T02:21:16.000Z</published>
    <updated>2024-06-21T05:46:30.706Z</updated>
    
    <content type="html"><![CDATA[<p>《Vue.js 设计与实现》概要总结<br><a id="more"></a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这是一本没有带你阅读一行源码，却可以让你在阅读完成之后，对 <code>vue 3</code> 所有的核心逻辑 <strong>了如指掌</strong> 的书籍。</p><p>无论是 <strong>响应性、调度系统、惰性执行</strong> ，还是 <strong>渲染器、diff 算法、编辑器三大步 </strong>  ，甚至是 <strong>有限自动状态机</strong> 等所有你能想到知识，本书都可以给你答案。</p><p>它就是  <strong>尤雨溪亲自做序</strong> ，<strong>Vue 官方团队成员：霍春阳</strong> 编写的  <strong>Vue.js 设计与实现</strong>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当前这个时间段下，关于 <code>vue 3</code> 源码的书籍，主要有两本。</p><p>第一本就是，咱们本次要讲的  <strong>《Vue.js 设计与实现》</strong>。</p><p>第二本是，<strong>《vue.js 技术内幕》</strong>，作者是黄轶。</p><p>正巧，两本书我都买来了。</p><p>这两本书，虽然都是讲解 <code>vue 3</code> 源码的，但是在讲解的方式上，有非常大的区别。</p><p>首先是 《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 <strong>从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序）</strong>，以 <strong>提出问题 - 分析思路 - 解决问题</strong> 的方式，来讲解 <code>vue 3</code> 的核心设计。其内部，没有读一行 <code>vue3</code> 的源码，但却可以让我们对整个 <code>vue 3</code> 的核心，拥有一个非常清楚的认知。</p><p>其次是 《vue.js 技术内幕》：它是一个标准的 “源码分析” 书籍，内部对 <code>vue 3</code> 的很多源码，进行了逐一的解读。</p><p>如果大家想要学习 <code>vue 3</code> 的设计思路，掌握框架设计的思维方式。那么我强烈推荐你看一看《Vue.js 设计与实现》。</p><p>如果你想要对 <code>vue</code> 源码进行逐一解读，那么可以看一下《vue.js 技术内幕》。</p><p>那么明确好了现在市面上学习 <code>vue 3</code> 源码的方式之后，下面就让我们进入到 《Vue.js 设计与实现》的学习中去吧！</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>《Vue.js 设计与实现》的内容一共分为 6 篇， <code>18</code> 个章节：</p><ul><li>首先第一篇：对 <code>vue</code> 的整个框架设计，进行了概述</li><li>第二篇：主要讲解了 <code>vue</code> 中的响应式系统，除了大家所熟悉的 <code>proxy</code> 之外，额外还包含了：调度系统 <code>scheduler</code>、惰性执行 <code>lazy</code>、<code>ref</code> 的实现原理</li><li>第三篇：主要针对 <code>vue</code> 的渲染器（<code>renderer</code>）进行了讲解，额外还包含了 <code>diff</code> 算法的详细讲解</li><li>第四篇：是组件化。包含了 组件的渲染机制，以及对 <code>vue</code> 官方组件 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 的实现原理，进行了剖析</li><li>第五篇：是编译器（<code>compiler</code>）。在这一篇中，把编译器的三大步：<code>parse</code>、<code>transform</code>、<code>generate</code> 进行了分步的讲解。</li><li>最后：是服务端渲染。主要是 <code>CSR</code>、<code>SSR</code> 以及 同构渲染。</li></ul><h2 id="第一篇：框架设计概览"><a href="#第一篇：框架设计概览" class="headerlink" title="第一篇：框架设计概览"></a>第一篇：框架设计概览</h2><p>整个第一篇分为三个章节：</p><ol><li>权衡的艺术：这里主要涉及到了 <code>vue</code> 框架设计的一些基本概念，也是咱们讲解的重点</li><li>框架设计的核心要素：相对比较杂，都是一些零碎的知识点</li><li>Vue.js 3 的设计思路：这一章包含了 <code>vue</code> 框架设计的逻辑主线，也非常重要，但是内容并不多</li></ol><p>那么首先咱们先来看第一章。</p><h3 id="第一章：权衡的艺术"><a href="#第一章：权衡的艺术" class="headerlink" title="第一章：权衡的艺术"></a>第一章：权衡的艺术</h3><p>在这一章中，开头的一句话，描述了框架设计的精髓，这句话也是尤雨溪在多个开发者大会中经常提到的，那就是：<strong>框架的设计，本身就是一种权衡的艺术</strong>。</p><p>在这一章中，书中分别从三个方面来去分析了所谓权衡的艺术，到底是什么意思。</p><h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>首先第一个方面就是：<strong>命令式和声明式</strong> 的概念。</p><p>所谓 <strong>命令式</strong> 指的就是：<strong>关注过程</strong> 的范式。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231540415.png" alt="image-20230207231540415"></p><p>而 <strong>声明式</strong> 指的就是： <strong>关注结果</strong> 的范式。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231536123.png" alt="image-20230207231536123"></p><p>什么意思呢？我们来举一个小例子：</p><blockquote><p>张三的妈妈，让张三去买酱油。</p><p>那么对于张三而言，他就需要：拿钱、出门、下楼、进超市、拿酱油、付钱、回家。</p><p>而对于张三的妈妈来说，她完全不需要关心张三做了什么，只需要对张三说一声就可以了。</p></blockquote><p>那么在这个例子中，张三就是一个典型的命令式，他需要完成整件事情的所有过程。</p><p>而张三的妈妈，就是典型的声明式，她不关心过程只关心结果。</p><p>那么这里大家来想一下，<code>vue</code> 是声明式的？还是命令式的？</p><p>对于 <code>vue</code> 而言，它的内部实现一定是 <strong>命令式</strong> 的，而我们在使用 <code>vue</code> 的时候，则是通过 <strong>声明式</strong> 来使用的。</p><p>也就是说： <strong>vue 封装了命令式的过程，对外暴露出了声明式的结果</strong></p><h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>在明确好了命令式和声明式的概念之后。接下来咱们来看下从 <strong>性能</strong> 层面，<code>vue</code> 所体现出来的一种权衡的方式。</p><p>针对于性能的分析，主要从两个方面去说。</p><p>首先第一个方面：大家觉得 <strong>是命令式的性能更强，还是声明式的性能更强呢？</strong></p><p>答案是：<strong>命令式的性能 &gt; 声明式的性能</strong>。</p><p>其实原因非常简单，对于 <strong>命令式</strong> 的代码而言，它直接通过 <strong>原生的 <code>JavaScript</code> 进行实现</strong>，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 <code>1</code>。</p><p>而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 <code>1 + N</code> 的。</p><p>那么既然如此，<code>vue</code> 为什么还要对外暴露出声明式的接口呢？</p><p>这其实是因为：<strong>声明式的可维护性，要远远大于命令式的可维护性</strong>。</p><blockquote><p>大家从这两段代码（命令式和声明式代码）中就可以发现，声明式代码比命令式代码要简单的多。</p><p>越简单的代码，可维护性就越强</p></blockquote><p>当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 <code>vue</code> 的性能优化之下，它并不会比纯命令式的性能差太多）</p><p>而这样的一种权衡，在 <code>template</code> 模板中，更是体现的淋漓尽致。</p><p>在前端领域，想要使用 <code>JavaScript</code> 修改 <code>html</code> 的方式，主要有三种：<strong><code>原生 JavaScript、innerHTML、虚拟 DOM</code></strong></p><p>很多小伙伴都会认为 <code>虚拟 DOM</code> 的性能是最高的，其实不是。</p><p>我们来看这个对比。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207233547097.png" alt="image-20230207233547097" style="zoom:50%;"></p><p>从这个对比我们可以发现，<code>虚拟 DOM</code> 的性能，并不是最高的。</p><p>但是它的 <strong>心智负担（书写难度）最小</strong>， 从而带来了 <strong>可维护性最高</strong>。所以哪怕它的性能并不是最高的。<code>vue</code> 依然选择了 <code>虚拟 DOM</code> 来进行了渲染层的构建。</p><p>这个也是一种性能与可维护性的权衡。</p><h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>第一章的最后一部分，主要讲解的就是 <strong>运行时和编译时</strong>。</p><p>这两个名词，各位小伙伴在日常开发中，应该是经常听到的。</p><p>它们两个都是框架设计的一种方式，可单独出现，也可组合使用。</p><p>那么下面咱们就分别来介绍一下它们。</p><p>首先是 <strong>运行时：<code>runtime</code></strong>。</p><blockquote><p>它指的是：<strong>利用 render 函数，直接把 虚拟 <code>DOM</code>  转化为 真实 <code>DOM</code> 元素</strong> 的一种方式。</p><p>在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。</p></blockquote><p>其次是 <strong>编译时：compiler</strong>：</p><blockquote><p>它指的是：<strong>直接把 <code>template</code> 模板中的内容，转化为 真实 <code>DOM</code> 元素</strong>。</p><p>因为存在编译的过程，所以可以分析用户提供的内容。</p><p>同时，没有运行时理论上性能会更好。</p><p>目前该方式，有具体的实现库，那就是现在也非常火的 <code>Svelte</code></p><p>但是这里要注意： <strong>它的真实性能，没有办法达到理论数据。</strong></p></blockquote><p>最后是 <strong>运行时 + 编译时</strong>：</p><blockquote><p>它的过程被分为两步：</p><ol><li>先把 <code>template</code> 模板转化为 <code>render</code> 函数。也就是 <strong>编译时</strong></li><li>再利用 <code>render</code> 函数，把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code>。也就是 <strong>运行时</strong></li></ol><p>两者的结合，可以：</p><p>在 编译时，分析用户提供的内容<br>在 运行时，提供足够的灵活性</p><p>这也是 <code>vue</code> 的主要实现方式。</p></blockquote><h3 id="第二章：框架设计的核心要素"><a href="#第二章：框架设计的核心要素" class="headerlink" title="第二章：框架设计的核心要素"></a>第二章：框架设计的核心要素</h3><p>这一章主要讲解了，框架设计时一些凌乱的注意点。</p><p>比如：</p><ol><li>通过 环境变量 和 <code>TreeShanking</code> 控制打包之后的体积</li><li>构建不同的打包产物，以应用不同的场景</li><li>提供了 <code>callWithErrorHandling</code> 接口函数，来对错误进行统一处理</li><li>源码通过 <code>TypeScript</code> 开发，以保证可维护性。</li><li>内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。</li></ol><p>这些东西都是基于一个个的小点单独去说的，整体之间并没有一个完成的线性逻辑。</p><p>所以大家可以根据具体感兴趣或者不了解的点，单独去看就可以。</p><h3 id="第三章：Vue-js-3-的设计思路"><a href="#第三章：Vue-js-3-的设计思路" class="headerlink" title="第三章：Vue.js 3 的设计思路"></a>第三章：Vue.js 3 的设计思路</h3><p>在这一章中，作者站在一个高层的角度，以 <strong><code>UI</code> 形式、渲染器、组件、编辑器</strong> 为逻辑主线进行的讲解。</p><p>下面咱们就来捋一捋这条线。</p><p>在 <code>Vue</code> 中 <code>UI</code> 形式主要分为两种：</p><ul><li>声明式的模板描述<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170232727.png" alt="image-20230208170232727"></li><li>命令式的 render 函数<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170236795.png" alt="image-20230208170236795"></li></ul><p>而针对于 <strong>声明式的模板描述</strong> 而言，本质上就是咱们常用的 <code>tempalte</code> 模板。它会被 <strong>编辑器</strong> 编译，得到 <strong>渲染函数 <code>render</code></strong> 。</p><p>渲染器与渲染函数，并 <strong>不是</strong> 一个东西。</p><p>渲染器是 <strong>函数 <code>createRenderer</code> 的返回值，是一个对象。被叫做 <code>renderer</code></strong>。 <strong><code>renderer</code> 对象中有一个方法 <code>render</code></strong>，这个 <code>render</code> ，就是我们常说的<strong>渲染函数</strong>。</p><p>渲染函数接收两个参数 <code>VNode</code> 和 <code>container</code>。</p><p>其中 <code>VNode</code> 表示 <strong>虚拟 DOM</strong>，本质上是一个 <code>JS</code> 对象。<code>container</code> 是一个容器，表示被挂载的位置。而 <code>render</code> 函数的作用，就是： <strong>把 <code>vnode</code> 挂载到 <code>container</code> 上</strong>。</p><p>同时，因为 <code>Vue</code> 以组件代表最小颗粒度，所以 <code>vue</code> 内部的渲染，本质上是：<strong>大量的组件渲染</strong>。</p><p>而组件本质上是一组 <code>DOM</code> 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 <code>DOM</code>。也就是说，<code>Vue</code> 本质上是： <strong>以组件作为介质，来完成针对于一组、一组的 <code>DOM</code> 渲染。</strong></p><h3 id="第一篇总结"><a href="#第一篇总结" class="headerlink" title="第一篇总结"></a>第一篇总结</h3><p>在整个第一篇中，作者主要就是通过这三章的内容， <strong>自顶向下</strong> 的为我们介绍了 <code>vue</code> 的框架设计逻辑。其目的主要就是为了让我们了解， <code>Vue</code> 框架的运行逻辑和一些关键概念。</p><h2 id="第二篇：响应式系统"><a href="#第二篇：响应式系统" class="headerlink" title="第二篇：响应式系统"></a>第二篇：响应式系统</h2><p>第二篇主要是针对 <strong>响应式系统</strong> 的讲解。</p><p>同样也是被分为三章：</p><ul><li>首先第一章，也是最重要的一章，就是 <strong>响应系统的作用与实现</strong></li><li>第二章，主要针对 <strong>对象的响应性实现原理</strong> 进行了讲解</li><li>第三章，主要针对 <strong>非对象的响应性实现原理</strong> 进行了讲解</li></ul><h3 id="第四章：响应系统的作用与实现"><a href="#第四章：响应系统的作用与实现" class="headerlink" title="第四章：响应系统的作用与实现"></a>第四章：响应系统的作用与实现</h3><p>在这一章中，作者从 <strong>响应式数据的概念开始，讲解了响应式系统的实现。</strong> 然后针对于 <strong>计算属性与 <code>watch</code>  的实现原理，进行了分析。</strong> 在分析的过程中，也对其所设计到的 <strong><code>调度系统（scheduler）</code> 和  <code>惰性执行（lazy）</code> 的原理进行了明确。</strong> 最后讲解了在 <strong>竞态问题下，关于过期的副作用的处理逻辑。</strong> </p><h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><p>那么首先咱们先来看基本概念 <strong>副作用函数 与 响应式数据</strong>。</p><p>所谓 <strong>副作用函数</strong> 指的是 <strong>会产生副作用的函数</strong>，这样的函数非常的多。比如</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208190429676.png" alt="image-20230208190429676"></p><p>在这段代码中， <code>effect</code> 的触发会导致全局变化 <code>val</code> 发生变化，那么 <code>effect</code> 就可以被叫做<strong>副作用函数</strong>。而如果 <code>val</code> 这个数据的变化，导致了视图的变化，那么 <code>val</code> 就被叫做 <strong>响应式数据</strong>。</p><p>那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为：</p><ul><li>第一个是 <code>getter</code> 行为，也就是 <strong>数据读取</strong></li><li>第二个是 <code>setter</code> 行为，也就是 <strong>数据修改</strong></li></ul><p>在 <code>vue 2</code> 中，这样的两个行为通过 <code>Object.defineProperty</code> 进行的实现。</p><p>在 <code>vue 3</code> 中，这样的两个行为通过 <code>Proxy</code> 进行的实现。</p><p>那么具体的实现逻辑是什么呢？咱们来看下面的图示：</p><blockquote><p>首先是 <code>getter</code> 形式：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191120105.png" alt="image-20230208191120105" style="zoom:20%;"></p><p>在该函数中，存在一个 <code>effect</code> 方法，方法内部触发了 <code>getter</code> 行为。一旦 <code>getter</code> 行为被触发，则把对应的 <code>effect</code> 方法保存到一个 “桶（数据对象）” 中</p><p>当触发 <code>setter</code> 行为时：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191257788.png" alt="image-20230208191257788" style="zoom:23%;"></p><p>则会从 “桶” 中取出 <code>effect</code> 方法，并执行。</p><p>那么此时因为 <code>obj.text</code> 的值发生了变化，所以 <code>effect</code> 被执行时 <code>document.body.innerText</code> 会被赋上新的值。从而导致视图发生变化。</p></blockquote><p>这是一套构建响应式系统的基础逻辑。这一套逻辑足够应对大家在日常的 <strong>面试</strong> 或者 <strong>工作</strong> 中的基本需求。</p><p>而这套逻辑说起来简单，做起来还是有一些难度的。</p><h4 id="调度系统（scheduler）"><a href="#调度系统（scheduler）" class="headerlink" title="调度系统（scheduler）"></a>调度系统（scheduler）</h4><p>那么说完了基本的响应性之后，接下来咱们来看 <strong>调度系统（<code>scheduler</code>）</strong></p><p>所谓调度系统，指的就是 <strong>响应性的可调度性</strong>。</p><p>而所谓的可调度，指的就是 <strong>当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式</strong></p><p>比如，在这段打印中，决定打印的顺序</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208192343242.png" alt="image-20230208192343242" style="zoom:50%;"></p><p>而想要实现一个调度系统，则需要依赖 <strong><code>异步：Promise</code> 和 <code>队列：jobQueue</code></strong> 来进行实现。咱们需要 <strong>基于 <code>Set</code> 构建出一个基本的队列数组 <code>jobQueue</code>，利用 <code>Promise</code> 的异步特性，来控制执行的顺序</strong></p><h4 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h4><p>当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 <strong>计算属性（computed）</strong> 的实现了。</p><p>计算属性本质上是： <strong>一个属性值，当依赖的响应式数据发生变化时，重新计算</strong></p><p>那么它的实现就需要彻底依赖于 <strong>调度系统（scheduler）</strong> 来进行实现。</p><h4 id="惰性执行（lazy）"><a href="#惰性执行（lazy）" class="headerlink" title="惰性执行（lazy）"></a>惰性执行（lazy）</h4><p>说完计算属性，那么下面我们来看下 <code>watch</code> 监听器。</p><p><code>watch</code> 监听器本质上是 <strong>观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数</strong></p><p>这也就意味着，<code>watch</code> 很多时候并不需要立刻执行。</p><p>那么此时，就需要使用到 <strong>惰性执行（<code>lazy</code>）</strong> 来进行控制。</p><p>惰性执行的实现要比调度系统简单。它本质上 <strong>是一个 <code>boolean</code> 型的值，可以被添加到 <code>effect</code> 函数中，用来控制副作用的执行</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!lazy) &#123;</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watch-的实现原理"><a href="#watch-的实现原理" class="headerlink" title="watch 的实现原理"></a>watch 的实现原理</h4><p>基于 调度系统 与 惰性执行，那么就可以实现 <code>watch</code> 监听器了。</p><h4 id="过期的副作用"><a href="#过期的副作用" class="headerlink" title="过期的副作用"></a>过期的副作用</h4><p><code>watch</code> 监听器的实现非常广泛，有时候我们甚至可以在 <strong><code>watch</code> 中完成一些异步操作。</strong></p><p>但是大量的异步操作，极有可能会导致 <strong>竞态问题</strong>。</p><p>所谓的竞态问题，指的是 <strong>在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机</strong>。比如咱们来看这段代码</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208194352049.png" alt="image-20230208194352049" style="zoom:33%;"></p><blockquote><p>这段代码完成的是一个异步操作。</p><p>如果 <code>obj</code> 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 <code>data</code> 被赋值为 请求B 的结果。</p><p>但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 <code>data</code> 的值就会变为 请求 A 的返回值。</p><p>这个咱们的期望是不一样的。</p><p>那么这样的问题，就是 <strong>竞态问题</strong></p></blockquote><p>而如果想要解决这问题，那么就需要使用到 <code>watch</code> 回调函数的第三个参数 <code>onInvalidate</code>，它本身也是一个回调函数。并且 <strong>该回调函数（<code>onInvalidate</code>）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</strong></p><p>而 <code>onInvalidate</code> 的实现原理也非常简单，只需要 <strong>在副作用函数（effct）重新执行前，先触发 <code>onInvalidate</code></strong> 即可。</p><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><p>那么到这里，咱们就把 <strong>响应性系统的大致核心逻辑</strong> 明确完成了。从这个逻辑中，我们知道想要实现响应性数据，那么核心就是通过 <code>Proxy</code> 实现。</p><p>那么这个 <code>proxy</code> 具体怎么做呢？</p><p>接下来，咱们来看第五章。</p><h3 id="第五章：非原始值（对象）的响应性方案"><a href="#第五章：非原始值（对象）的响应性方案" class="headerlink" title="第五章：非原始值（对象）的响应性方案"></a>第五章：非原始值（对象）的响应性方案</h3><p>书中的第五章整体而言非常简单，主要就介绍了两个接口，<code>Proxy</code> 和 <code>Reflect</code>。</p><p>这两个接口通常会一起进行使用，其中：</p><ul><li><code>Proxy</code> 可以 <strong>代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象）</strong></li><li><code>Reflect</code> 可以 <strong>在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用</strong></li></ul><h3 id="第六章：原始值（非对象）的响应性方案"><a href="#第六章：原始值（非对象）的响应性方案" class="headerlink" title="第六章：原始值（非对象）的响应性方案"></a>第六章：原始值（非对象）的响应性方案</h3><p>如果大家熟悉 <code>proxy</code> 的话，那么可以知道，针对于 <code>proxy</code> 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。</p><p>但是，在 <code>vue</code> 中，我们可以通过 <code>ref</code> 构建简单数据类型的响应。</p><p>那么 <code>ref</code> 是如何进行实现的呢？</p><p>这里大家要注意：<strong>针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献</strong></p><p>在最新的 <code>vue 3.2</code> 代码中，<code>vue</code> 通过 <strong><code>get</code> 、<code>set</code>  函数标记符，让函数以属性调用的形式被触发。</strong>这两个修饰符，可以让我们 <strong>像调用属性一样，调用方法</strong>。 所以当我们平时 <strong>访问 ref.value 属性时，本质上是  value() 函数的执行</strong>。</p><h3 id="第二篇总结"><a href="#第二篇总结" class="headerlink" title="第二篇总结"></a>第二篇总结</h3><p>那么到这里咱们整个响应式系统的大概流程，就已经描述完成了。其核心逻辑主要就是在第四章中。</p><p>至于第五章和第六章，更多的偏向于具体的细节和代码逻辑。</p><h2 id="第三篇：渲染器"><a href="#第三篇：渲染器" class="headerlink" title="第三篇：渲染器"></a>第三篇：渲染器</h2><p>那么下面咱们来看 <strong>第三篇：渲染器</strong> 。</p><p>第三篇一共被分为 5 个章节。但是只讲解了三部分内容。</p><ul><li>首先第七章，主要讲解了<strong>渲染器的设计</strong>。</li><li>第八章，主要讲解了 <strong><code>DOM</code> 的挂载和更新的逻辑</strong>。</li><li>而 第九、十、十一 这三章，主要讲解了 <strong>Diff 算法</strong></li></ul><h3 id="第七章：渲染器的设计"><a href="#第七章：渲染器的设计" class="headerlink" title="第七章：渲染器的设计"></a>第七章：渲染器的设计</h3><p>在之前咱们说过 <strong>渲染器与渲染函数不是一个东西</strong></p><ul><li><strong>渲染器</strong> 是 <code>createRenderer</code> 的返回值，是一个对象。</li><li><strong>渲染函数</strong> 是渲染器对象中的 <code>render</code> 方法</li></ul><p>在 <code>vue 3.2.37</code> 的源码内部，<code>createRenderer</code> 函数的具体实现是通过 <code>baseCreateRenderer</code> 进行的。它的代码量非常庞大，涉及到了 <code>2000</code> 多行的代码。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209085155034.png" alt="image-20230209085155034" style="zoom:33%;"></p><p>代码量虽多，但是核心思路并不是特别复杂。总体可以被分为两部分：</p><ol><li><strong>在浏览器端渲染时，利用 <code>DOM API</code> 完成 <code>DOM</code> 操作</strong>：比如，如果渲染 <code>DOM</code> 那么就使用 <code>createElement</code>，如果要删除 <code>DOM</code> 那么就使用 <code>removeChild</code>。</li><li><strong>渲染器不能与宿主环境（浏览器）产生强耦合</strong>：因为 <code>vue</code> 不光有浏览器渲染，还包括了 <code>服务端</code> 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。</li></ol><p>在渲染的过程中，还有一个非常重要的概念 <code>vnode</code>。书中并没有专门的章节来介绍 <code>vnode</code>。所以为了避免各位小伙伴对 <code>vnode</code> 不了解，咱们单独把 <code>vnode</code> 说一下。</p><p>所谓 <code>vnode</code> 本身是 <strong>一个普通的 JavaScript 对象，代表了渲染的内容</strong>。对象中通过 <code>type</code> 表示渲染的 <code>DOM</code>。比如 <code>type === div</code>：则表示 <code>div</code> 标签、<code>type === Framgnet</code> 则表示渲染片段（vue 3 新增）、<code>type === Text</code> 则表示渲染文本节点。</p><h3 id="第八章：挂载与更新"><a href="#第八章：挂载与更新" class="headerlink" title="第八章：挂载与更新"></a>第八章：挂载与更新</h3><p>对于渲染器而言，它做的最核心的事情就是 <strong>对节点进行挂载、更新的操作</strong>。作者在第八章中，详细的介绍了对应的逻辑。</p><p>整个第八章分为两部分来讲解了这个事情：</p><ol><li><code>DOM</code> 节点操作</li><li>属性节点操作</li></ol><h4 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a><code>DOM</code> 节点操作</h4><p>首先先来看 <code>DOM</code> 节点操作。<code>DOM</code> 节点的操作可以分为三部分：</p><ul><li><strong>挂载</strong>：所谓挂载表示节点的初次渲染。比如，可以直接通过 <code>createElement</code> 方法新建一个 <code>DOM</code> 节点，再利用 <code>parentEl.insertBefore</code> 方法插入节点。</li><li><strong>更新</strong>：当响应性数据发生变化时，可能会涉及到 <code>DOM</code> 的更新。此时的更新本质上是属于 <strong>属性的更新</strong>。咱们等到属性节点操作那里再去说。</li><li><strong>卸载</strong>：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 <code>parentEl.removeChild</code> 进行。</li></ul><p>以上三种类型，是 <code>vue</code> 在进行 <code>DOM</code> 操作时的常见逻辑。基本上覆盖了 <code>DOM</code> 操作 <code>90% 以上</code> 的常见场景</p><h4 id="属性节点操作"><a href="#属性节点操作" class="headerlink" title="属性节点操作"></a>属性节点操作</h4><p>看完了 <code>DOM</code> 操作之后，接下来咱们来看属性节点操作。</p><p>针对于属性而言，大体可以分为两类：</p><ol><li><strong>属性</strong>：比如 <code>class</code>、<code>id</code>、<code>value</code>、<code>src</code>…</li><li><strong>事件</strong>：比如 <code>click</code>、<code>input</code>….</li></ol><p>那么咱们就先来看 <strong>非事件的属性部分</strong>。</p><p>想要了解 <code>vue</code> 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 <strong>浏览器中的属性分类</strong>。</p><p>在浏览器中 <code>DOM</code> 属性其实被分为了两类：</p><ul><li>第一类叫做 <code>HTML Attributes</code>：直接定义在 <code>HTML 标签</code> 上的属性，都属于这一类。</li><li><p>第二类叫做 <code>DOM Properties</code>：它是拿到 <code>DOM</code> 对象后定义的属性。咱们接下来主要要说的就是它。</p><p><code>HTML Attributes</code> 的定义相对而言比较简单和直观，但是问题在于 <strong>它只能在 <code>html</code> 中进行操作</strong>。</p></li></ul><p>而如果想要在 <code>JS</code> 中操作 <code>DOM</code> 属性，就必须要通过  <code>DOM Properties</code> 来进行实现。但是因为 <code>JS</code> 本身特性的问题，会导致某些 <code>DOM Properties</code> 的设置存在特殊性。比如 <code>class、type、value</code> 这三个。</p><p>所以为了保证 <code>DOM Properties</code> 的成功设置，那么我们就必须要知道 <strong>不同属性的 <code>DOM Properties</code> 定义方式 </strong>。</p><p>下面咱们来看一下。</p><p><code>DOM Properties</code> 的设置一共被分为两种：</p><ol><li><code>el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;)</code></li><li><code>. 属性赋值</code> ： <code>el.属性名 = 属性值</code> 或者 <code>el[属性名] = 属性值</code> 都属于 <code>.属性赋值</code>  </li></ol><p>我们来看这段代码：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209093545078.png" alt="image-20230209093545078" style="zoom:50%;"></p><blockquote><p>在这段代码中，我们为 <code>textarea</code> 利用 <code>DOM Properties</code> 的方式设置了三个不同的属性：</p><ul><li>首先是 <code>class</code>： <code>class</code> 在属性操作中是一个非常特殊的存在。它有两个名字 <code>class</code> 和 <code>className</code>。如果我们直接通过 <code>el.setAttribute</code> 的话，那么必须要用 <code>class</code> 才可以成功，而如果是通过 <code>. 属性</code> 的形式，那么必须要使用 <code>className</code> 才可以成功。</li><li>第二个是 <code>type</code>： <code>type</code> 仅支持 <code>el.setAttribute</code>  的方式，不支持 <code>.属性的方式</code></li><li>第三个是 <code>value</code>：<code>value</code> 不支持直接使用 <code>el.setAttribute</code>  设置，但是支持 <code>.属性</code> 的设置方式</li></ul></blockquote><p>除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>接下来，咱们来看 <code>vue</code> 对事件的处理操作。</p><p>事件的处理和属性、<code>DOM</code> 一样，也是分为 <strong>添加、删除、更新</strong> 三类。</p><ul><li>添加：添加比较简单，主要利用 <code>el.addEventListener</code> 进行实现即可。</li><li>删除：主要利用 <code>el.removeEventListener</code> 进行处理。</li><li>更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。</li></ul><p>通常情况下，我们所认知的事件更新应该是 <strong>删除旧事件、添加新事件</strong> 的过程。但是如果利用 <code>el.addEventListener</code> 和 <code>el.removeEventListener</code> 来完成这件事情，是一件非常消耗性能的事。</p><p>那么怎么能够节省性能，同时完成事件的更新呢？</p><p>这时，<code>vue</code> 对事件的更新提出了一个叫做 <code>vei</code> 的概念，这个概念的意思是： <strong>为 <code>addEventListener</code> 回调函数，设置了一个 <code>value</code> 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。</strong></p><p>这个代码比较多，大家如果想要查看具体代码的话，可以 <a href="https://github.com/lgd8981289/vue-next-mini" target="_blank" rel="noopener">在 github 搜索 vue-next-mini</a>，进入到 <code>packages/runtime-dom/src/modules/events.ts</code> 路径下查看。</p><h3 id="第九、十、十一章：Diff-算法"><a href="#第九、十、十一章：Diff-算法" class="headerlink" title="第九、十、十一章：Diff 算法"></a>第九、十、十一章：Diff 算法</h3><p>整个渲染器最后的三个章节全部都用来讲解了 <code>diff</code> 算法。</p><p>针对于 <code>diff</code> 而言，它的本质其实就是一个对比的方法，其描述的核心就是： <strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p><p>目前针对于 <code>vue 3.2.37</code> 的版本来说，整个的 <code>diff</code> 算法被分为 5 步（<strong>这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助</strong>）：</p><ol><li><code>sync from start</code>：自前向后的对比</li><li><code>sync from end</code>：自后向前的对比</li><li><code>common sequence + mount</code>：新节点多于旧节点，需要挂载</li><li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li><li><code>unknown sequence</code>：乱序</li></ol><p>而，针对于书中的这三章来说，本质上是按照 <strong>简单 diff 算法、双端 diff 算法、快速 diff 算法</strong> 的顺序把整个 <code>diff</code> 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。</p><p>所以说咱们在当前的这个分享中，肯定是没有办法为大家讲解具体算法逻辑的。</p><p>针对于这一块，我同样也是准备了另外的博客。</p><h3 id="第三篇总结"><a href="#第三篇总结" class="headerlink" title="第三篇总结"></a>第三篇总结</h3><p>针对于第三篇渲染器来说，咱们所描述的重点主要是围绕  <strong>渲染器的设计</strong> 和  <strong><code>DOM</code> 的挂载和更新的逻辑</strong> 来去说的。</p><p>针对于这两部分而言，大家要明确 <strong>渲染器与渲染函数的区别</strong>，同时要知道 <code>HTML Attributes</code> 和 <code>DOM Properties</code> 在行为上的差异性。另外关于事件更新的 <code>vei</code> 概念，应该也可以给大家带来一些新的思路。</p><p>而针对于 <code>diff</code>，咱们没有放在当前分享中去说，主要还是因为时长不够的原因。但是我为大家准备了额外的博客和视频，大家可以根据自己需要去进行查看。</p><h2 id="第四篇：组件化"><a href="#第四篇：组件化" class="headerlink" title="第四篇：组件化"></a>第四篇：组件化</h2><p>第四篇组件化，它应该算是比较简单的一个篇章，也是分为三部分来去讲解：</p><ol><li>组件的实现原理：这是咱们讲解的重心，但是不用担心，它并不复杂。</li><li>异步组件与函数式组件：这个比较冷僻，在实际开发中的使用场景有限</li><li>内建组件和模块：里面主要讲解了 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 这三个内置组件的实现逻辑</li></ol><h3 id="第十二章：组件的实现原理"><a href="#第十二章：组件的实现原理" class="headerlink" title="第十二章：组件的实现原理"></a>第十二章：组件的实现原理</h3><p>想要了解 <code>vue</code> 中组件的实现，那么首先我们需要知道什么是组件。</p><p>组件本质上就是一个 <code>JavaScript</code> 对象，比如，以下对象就是一个基本的组件</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209105953064.png" alt="image-20230209105953064" style="zoom:33%;"></p><p>而对于组件而言，同样需要使用 <code>vnode</code> 来进行表示，当 <code>vnode</code> 的 <code>type</code> 属性是一个 <strong>自定义对象</strong> 时，那么这个 <code>vnode</code> 就表示组件的 <code>vnode</code></p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110548502.png" alt="image-20230209110548502" style="zoom:33%;"></p><p>而组件的渲染，本质上是 <strong>组件包含的 <code>DOM</code> 的渲染。</strong> 对于组件而言，必然会包含一个 <code>render</code> 渲染函数。如果没有 <code>render</code> 函数，那么 <code>vue</code> 会把 <code>template</code> 模板编译为 <code>render</code> 函数。而组件渲染的内容，其实就是 <code>render</code> 函数返回的 <code>vnode</code>。具体的渲染逻辑，全部都通过渲染器执行。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110919710.png" alt="image-20230209110919710" style="zoom:33%;"></p><p><code>vue 3</code> 之后提出了 <code>composition API</code>，<code>composition API</code> 包含一个入口函数，也就是 <code>setup</code> 函数。 <code>setup</code> 函数包含两种类型的返回值：</p><ol><li><strong>返回一个函数</strong>：当 <code>setup</code> 返回一个函数时，那么该函数会被作为 <code>render</code> 函数直接渲染。</li><li><strong>返回一个对象</strong>：当 <code>setup</code> 返回一个对象时，那么 <code>vue</code> 会直接把该对象的属性，作为 <code>render</code> 渲染时的依赖数据</li></ol><p>同时，对于组件来说还有一个 <strong>插槽</strong> 的概念。插槽的实现并不神奇。插槽本质上 <strong>是一段 <code>innerHTML</code> 的内容，在 <code>vnode</code> 中以 <code>children</code> 属性进行呈现</strong>。当插槽被渲染时，只需要渲染 <code>children</code> 即可。</p><p>对于组件来说，除了咱们常用的 <strong>对象组件</strong> 之外，<code>vue</code> 还提供了额外的两种组件，也就是 <strong>异步组件与函数式组件</strong>。</p><h3 id="第十三章：异步组件与函数式组件"><a href="#第十三章：异步组件与函数式组件" class="headerlink" title="第十三章：异步组件与函数式组件"></a>第十三章：异步组件与函数式组件</h3><p>所谓异步组件，指的是： <strong>异步加载的组件</strong> 。</p><p>比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。</p><p>异步组件在 <strong>优化页面性能、拆包、服务端下发组件</strong> 时，会比较有用。</p><p>而对于 <strong>函数式组件</strong> 来说，相对就比较冷僻了。函数式组件指的是 <strong>没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 <code>props</code> 属性</strong> 。在实际开发中，并不常见。</p><h3 id="第十四章：内建组件和模块"><a href="#第十四章：内建组件和模块" class="headerlink" title="第十四章：内建组件和模块"></a>第十四章：内建组件和模块</h3><p>这一章中，主要描述了 <code>vue</code> 的三个内置组件。</p><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>首先第一个是 <code>KeepAlive</code>。</p><p>这是我们在日常开发中，非常常用的内置组件。它可以 <strong>缓存一个组件，避免该组件不断地销毁和创建</strong>。</p><p>看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 <strong>组件卸载</strong> 和 <strong>组件挂载</strong> 两个方面：</p><ul><li><strong>组件卸载</strong>：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中</li><li><strong>组件挂载</strong>：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。</li></ul><h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code> 是 <code>vue 3</code> 新增的组件，作用是 <strong>将 <code>Teleport</code> 插槽的内容渲染到其他的位置</strong>。比如我们可以把 <code>dialog</code> 渲染到 <code>body</code> 根标签之下。</p><p>它的实现原理，主要也是分为两部分：</p><ol><li>把 Teleport 组件的渲染逻辑，从渲染器中抽离</li><li>在指定的位置进行独立渲染</li></ol><h4 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h4><p><code>Transition</code> 是咱们常用的动画组件，作用是 <strong>实现动画逻辑</strong>。</p><p>其核心原理同样被总结为两点：</p><ol><li><code>DOM</code> 元素被挂载时，将动效附加到该 <code>DOM</code> 元素上</li><li><code>DOM</code> 元素被卸载时，等在 <code>DOM</code> 元素动效执行完成后，执行卸载 <code>DOM</code> 操作</li></ol><h3 id="第四篇总结"><a href="#第四篇总结" class="headerlink" title="第四篇总结"></a>第四篇总结</h3><p>整个第四篇，主要围绕着组件来去讲。所以内容并不复杂。</p><p>对于咱们的日常的开发与面试而言，其实只需要搞清楚 <strong>组件的原理</strong> 与 <strong>内建组件原理</strong> 即可。</p><h2 id="第五篇：编译器"><a href="#第五篇：编译器" class="headerlink" title="第五篇：编译器"></a>第五篇：编译器</h2><p>编译器是一个非常复杂的环节。作者主要通过 <strong>编辑器核心逻辑、解析器、编译优化</strong> 这三个方向进行了说明。</p><p>其中对于我们日常开发与面试来说，最核心的就是 <strong>第十五章：编译器核心技术概述</strong> 。这也是咱们在这一篇中的主要章节。</p><h3 id="第十五章：编译器核心技术概述"><a href="#第十五章：编译器核心技术概述" class="headerlink" title="第十五章：编译器核心技术概述"></a>第十五章：编译器核心技术概述</h3><p>在编译器核心技术概述，主要包含两个核心内容：</p><ol><li>模板 <code>DSL</code> 的编译器</li><li><code>Vue</code> 编译流程三大步</li></ol><h4 id="模板-DSL-的编译器"><a href="#模板-DSL-的编译器" class="headerlink" title="模板 DSL 的编译器"></a>模板 <code>DSL</code> 的编译器</h4><p>在任何一个编程语言中，都存在编译器的概念。 <code>vue</code> 的编译器是在 <strong>一种领域下，特定语言的编译器</strong> ，那么这种编译器被叫做 <code>DSL</code> 编译器。</p><p>而编译器的本质是 <strong>通过一段程序，可以把 A 语言翻译成 B 语言</strong>。在 <code>vue</code> 中的体现就是 <strong>把 <code>tempalte</code> 模板，编译成 <code>render</code> 渲染函数</strong></p><p>一个完整的编译器，一个分为 <strong>两个阶段、六个流程</strong>：</p><ul><li>编译前端：<ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>编译后端：<ul><li>中间代码生成</li><li>优化</li><li>目标代码生成</li></ul></li></ul><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113241592.png" alt="image-20230209113241592"></p><p>而对于 <code>vue</code> 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113421705.png" alt="image-20230209113421705"></p><ol><li><code>parse</code>：通过 <code>parse</code> 函数，把模板编译成 <code>AST</code> 对象</li><li><code>transform</code>：通过 <code>transform</code> 函数，把 <code>AST</code> 转化为 <code>JavaScript AST</code></li><li><code>generate</code>：通过 <code>generate</code> 函数，把 <code>JavaScript AST</code> 转化为 渲染函数（<code>render</code>）</li></ol><p>这三大步中，每一步都包含非常复杂的逻辑实现。</p><p>和之前一样，因为篇幅的问题，我们没有办法这里去详细讲解三大步的流程。</p><p>我依然为大家提供了 <a href="https://juejin.cn/post/7197977396603256890/42118200" target="_blank" rel="noopener">博客版</a></p><h4 id="第十六章：解析器（parse）"><a href="#第十六章：解析器（parse）" class="headerlink" title="第十六章：解析器（parse）"></a>第十六章：解析器（parse）</h4><p>这一章，主要详细讲解了 <strong>parse 解析逻辑</strong>。是在三大步中的 <code>parse</code> 逻辑的基础上，进行了一个加强。</p><p>所以这里咱们也按下不表</p><h4 id="第十七章：编译优化"><a href="#第十七章：编译优化" class="headerlink" title="第十七章：编译优化"></a>第十七章：编译优化</h4><p>最后就是编译优化。</p><p>编译优化也是一个非常大的概念，其核心就是 <strong>通过编译的手段提取关键信息，并以此知道生成最优代码的过程</strong>。</p><p>它的核心优化逻辑，主要是 <strong>把节点分为两类</strong>：</p><ul><li>第一类是 <strong>动态节点</strong>：也就是会 <strong>受数据变化影响</strong> 的节点</li><li>第二类是 <strong>静态节点</strong>：也就是 <strong>不受数据变化影响</strong> 的节点</li></ul><p>优化主要的点，就是 <strong>动态节点</strong>。</p><p>优化的方式主要是通过 <code>Block 树</code> 进行优化。</p><p><code>Block 树</code> 本质上就是一个 <strong>虚拟节点数对象</strong>，内部包含一个 <code>dynamicChildren</code> 属性，用来 <strong>收集所有的动态子节点</strong>，以达到提取关键点进行优化的目的。</p><p>除此之外，还有一些小的优化手段，比如：</p><ul><li>静态提升</li><li>预字符串化</li><li>缓存内联事件处理函数</li><li><code>v-once</code> 指令</li><li>…</li></ul><h3 id="第五篇总结"><a href="#第五篇总结" class="headerlink" title="第五篇总结"></a>第五篇总结</h3><p>其实第五篇编译器应该是整本书中，逻辑最复杂的一篇了。内部包含了特别多的代码实现。</p><p>但是因为篇幅问题，所以我们没有办法给大家进行详细介绍。只能是把大致的核心流程为大家进行明确。希望大家见谅。</p><h2 id="第六篇：服务端渲染"><a href="#第六篇：服务端渲染" class="headerlink" title="第六篇：服务端渲染"></a>第六篇：服务端渲染</h2><p>最后一篇只有一个章节，就是 <strong>同构渲染</strong>。</p><p>想要了解同构渲染，那么需要先搞明白 <code>CSR、SSR</code> 的概念。</p><ul><li><code>CSR</code>：所谓 <code>CSR</code> 指的是 <strong>客户端渲染</strong>。<ul><li>浏览器向服务器发起请求</li><li>服务器查询数据库，返回数据</li><li>浏览器得到数据，进行页面构建</li></ul></li><li><code>SSR</code>：表示 <strong>服务端渲染</strong><ul><li>览器向服务器发起请求</li><li>服务器查询数据库，根据数据，生成 <code>HTML</code> ，并进行返回</li><li>浏览器直接渲染 <code>HTML</code></li></ul></li></ul><p>两种方式各有利弊，所以同构渲染，指的就是 <strong>把 <code>CSR</code> 和 <code>SSR</code> 进行合并</strong>。既可以单独 <code>CSR</code> ，也可以单独 <code>SSR</code>，同时还可以 <strong>结合两者，在首次渲染时，通过 <code>SSR</code>，在非首次渲染时，通过 <code>CSR</code></strong>。</p><p>以下是三者的对比图</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209121227934.png" alt="image-20230209121227934" style="zoom:50%;"></p><p>而针对 <code>vue</code> 的服务端渲染来说，它是 <strong>将虚拟 <code>DOM</code>  渲染为 <code>HTML</code> 字符串</strong>，本质上是 <strong>解析的 <code>vnode</code> 对象，然后进行的 <code>html</code> 的字符串拼接</strong></p><p>最后又讲解了客户端激活的原理，大致分为两步：</p><ol><li>为页面中的 <code>DOM</code> 元素与虚拟节点对象之间建立联系</li><li>为页面中的 <code>DOM</code> 元素添加事件绑定</li></ol><p>这两步主要是通过 <code>renderer.hydrate()</code> 方法进行实现了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 那么到这里，整个 《Vue.js 设计与实现》就已经全部说完了。</p><p>整本书中，涉及到的内容是非常全面的，就像咱们开头所说的一样，它是一个 <strong>从高层的设计角度，来探讨框架需要关注的问题。</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Vue.js 设计与实现》概要总结&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>日语-N2文法</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-N2%E6%96%87%E6%B3%95/"/>
    <id>/2024/06/11/日语-N2文法/</id>
    <published>2024-06-11T03:11:15.000Z</published>
    <updated>2024-06-11T05:22:08.066Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之N2文法<br><a id="more"></a></p><h1 id="単元"><a href="#単元" class="headerlink" title="単元"></a>単元</h1><h2 id="第１７課"><a href="#第１７課" class="headerlink" title="第１７課"></a>第１７課</h2><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><h4 id="～ぬきで／～ぬきにして-本意是去除的意思，引申义是不是，不必，不需要，不的意思"><a href="#～ぬきで／～ぬきにして-本意是去除的意思，引申义是不是，不必，不需要，不的意思" class="headerlink" title="～ぬきで／～ぬきにして　本意是去除的意思，引申义是不是，不必，不需要，不的意思"></a>～ぬきで／～ぬきにして　本意是去除的意思，引申义是不是，不必，不需要，不的意思</h4><ul><li>堅苦しいあいさつはぬきにして思い切り飲みましょう。</li><li>これはお世辞抜きで面白いですよ。</li></ul><h4 id="～（よう）とする／としている-打算做-正要做，马上快要"><a href="#～（よう）とする／としている-打算做-正要做，马上快要" class="headerlink" title="～（よう）とする／としている　打算做/正要做，马上快要"></a>～（よう）とする／としている　打算做/正要做，马上快要</h4><ul><li>犯人は警察に捕まりそうになって，銃で自殺しょうとした。</li><li>复习：すると　一……就……，紧接着前项事情发生后项事情</li></ul><h4 id="据说的几种表达方式"><a href="#据说的几种表达方式" class="headerlink" title="据说的几种表达方式"></a>据说的几种表达方式</h4><ul><li>～といわれています（第3课）通常认为</li><li>～そうです （第4课）</li><li>～とのことです （第5课）</li><li>～ということです （第5课）</li><li>～とまで（さえ）いわれている （第17课）夸张的据说，极端情况下使用</li><li>蘇州は美しい街だ，東洋のベニスとさえいわれている。</li></ul><h2 id="第１8課"><a href="#第１8課" class="headerlink" title="第１8課"></a>第１8課</h2><h3 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h3><h4 id="在……的时候，期间"><a href="#在……的时候，期间" class="headerlink" title="在……的时候，期间"></a>在……的时候，期间</h4><ul><li>時　表示时间<ul><li>小さい時</li></ul></li><li>間　表示时间和空间<ul><li>皆が寝ている間に，～</li><li>東京と大阪の間に，～</li></ul></li><li>ところ　表示状态<ul><li>忙しいところですが，～</li></ul></li><li>うち　在……当中，在……期间，趁着（年轻等）<ul><li>～うちに　等同于～間に，表示在这个期间一定发生了动作<ul><li>母が外出しているうちに（間に），掃除をして部屋をピカピカにしよう。</li></ul></li><li>～うちは　表示在这个期间没有变化<ul><li>体が健康なうちは，妻と二人でのんびり暮らしたい。</li></ul></li></ul></li><li>折，節，際　和時一样，属于美化语</li></ul><h4 id="假定形＋幸いです／恐縮です-对方这么做我会很高兴-我这么做的化给对方添麻烦"><a href="#假定形＋幸いです／恐縮です-对方这么做我会很高兴-我这么做的化给对方添麻烦" class="headerlink" title="假定形＋幸いです／恐縮です　对方这么做我会很高兴/我这么做的化给对方添麻烦"></a>假定形＋幸いです／恐縮です　对方这么做我会很高兴/我这么做的化给对方添麻烦</h4><ul><li>後日こちらからお電話いたしますので，その折にご都合をお聞かせいただければ幸いです。</li><li>お忙しい中恐縮ですが，ご連絡いただければ幸いです。</li></ul><h4 id="AをBにした／とした-以A作为B的一部分-全部"><a href="#AをBにした／とした-以A作为B的一部分-全部" class="headerlink" title="AをBにした／とした　以A作为B的一部分/全部"></a>AをBにした／とした　以A作为B的一部分/全部</h4><ul><li>弊社では，「金星」をベースにした新感覚のカクテルもごよういしています。</li><li>この服は「エコロジー」をコンセプトとした素材でできています。</li></ul><h4 id="なお／また／さらに-另外，还有"><a href="#なお／また／さらに-另外，还有" class="headerlink" title="なお／また／さらに　另外，还有"></a>なお／また／さらに　另外，还有</h4><h2 id="第１９課"><a href="#第１９課" class="headerlink" title="第１９課"></a>第１９課</h2><h3 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋次第＋～-一……就……"><a href="#ます形＋次第＋～-一……就……" class="headerlink" title="ます形＋次第＋～　一……就……"></a>ます形＋次第＋～　一……就……</h4><ul><li>わかり次第ご連絡を差し上げます。</li><li>準備ができ次第，ご案内いたします。</li><li>复习：～たら，すぐに，～と</li></ul><h4 id="ます形＋つつある-表示动作正在逐渐变化或朝着一个方向发展"><a href="#ます形＋つつある-表示动作正在逐渐变化或朝着一个方向发展" class="headerlink" title="ます形＋つつある　表示动作正在逐渐变化或朝着一个方向发展"></a>ます形＋つつある　表示动作正在逐渐变化或朝着一个方向发展</h4><ul><li>中国国内の物価が上がりつつある。</li><li>复习：一方，ばかりだ，の一途をたどる，いく</li></ul><h4 id="～と評判だ-得到很高的评价"><a href="#～と評判だ-得到很高的评价" class="headerlink" title="～と評判だ　得到很高的评价"></a>～と評判だ　得到很高的评价</h4><ul><li>都内の浄水場で処理した水をボトルに詰めて販売していて，味も美味しいと評判だ。</li></ul><h4 id="～に伴って～-随着-，表示伴随着某个重大事件连带发生了另外的事件"><a href="#～に伴って～-随着-，表示伴随着某个重大事件连带发生了另外的事件" class="headerlink" title="～に伴って～　随着~，表示伴随着某个重大事件连带发生了另外的事件"></a>～に伴って～　随着~，表示伴随着某个重大事件连带发生了另外的事件</h4><ul><li>冷戦の終結に伴って，経済関係の重要性が強調されるようになってきた。</li><li>都市の緑化に伴って，駅周辺に花や木が増えってきた。</li><li>复习：～とともに</li></ul><h4 id="～のもと（で）-表示在……之下，之中。本意是表示位置靠下的部位"><a href="#～のもと（で）-表示在……之下，之中。本意是表示位置靠下的部位" class="headerlink" title="～のもと（で）　表示在……之下，之中。本意是表示位置靠下的部位"></a>～のもと（で）　表示在……之下，之中。本意是表示位置靠下的部位</h4><ul><li>国連の旗のもと，各国が協力して紛争の平和的な解決を目指している。</li><li>マイナス３０度吹雪という悪天候のものでも，観測作業は継続された。</li></ul><h4 id="一方-一边，一边，表示并列同时经行"><a href="#一方-一边，一边，表示并列同时经行" class="headerlink" title="一方　一边，一边，表示并列同时经行"></a>一方　一边，一边，表示并列同时经行</h4><ul><li>彼は大学で哲学を教える一方，大工として働いている。</li><li>复习：一方也有朝着趋势一直发展的意思</li></ul><h2 id="第２０課"><a href="#第２０課" class="headerlink" title="第２０課"></a>第２０課</h2><h3 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h3><h4 id="～だらけ-满是，沾满了，很多"><a href="#～だらけ-满是，沾满了，很多" class="headerlink" title="～だらけ　满是，沾满了，很多"></a>～だらけ　满是，沾满了，很多</h4><ul><li>ここのところ，失敗だらけなんです。</li><li>間違いだらけの答案を採点する。</li></ul><h4 id="と思ったら，～-刚一……就……，动作刚一发生，就发生了意外的事情"><a href="#と思ったら，～-刚一……就……，动作刚一发生，就发生了意外的事情" class="headerlink" title="~と思ったら，～　刚一……就……，动作刚一发生，就发生了意外的事情"></a>~と思ったら，～　刚一……就……，动作刚一发生，就发生了意外的事情</h4><ul><li>電車は発車したと思ったら大きな音を出して急停車した。</li><li>その学生は，就職したと思ったらさっさと辞めてしまった。</li></ul><h4 id="～というより-～というよりむしろ-比起这样说……还不如……-与其说是……不如说……"><a href="#～というより-～というよりむしろ-比起这样说……还不如……-与其说是……不如说……" class="headerlink" title="～というより/～というよりむしろ　比起这样说……还不如……/与其说是……不如说……"></a>～というより/～というよりむしろ　比起这样说……还不如……/与其说是……不如说……</h4><ul><li>正直に言えば，喜んで引き受けたというより思わず頷いたという形だった。</li><li>この料理は，中華料理というよりむしろ日本料理というほうが適切だ。</li></ul><h4 id="ばかり"><a href="#ばかり" class="headerlink" title="ばかり"></a>ばかり</h4><ul><li>～たばかりです　主观上觉得事情刚刚完成<ul><li>彼は3月に大学を卒業したばかりです。</li></ul></li><li>～ばかり～　全是，尽是，光是<ul><li>最近，変な夢ばかり見る。</li></ul></li><li>～てはばかりいる　消极的事情反复发生<ul><li>彼はよく遅れてばかりいる。</li></ul></li><li>～ばかりではなく　不仅……而且……<ul><li>その地方は寒いばかりではなく，乾燥しているため，農業には向いていない。</li></ul></li><li>～ばかりだ　朝着一个不好的方向不断发展<ul><li>病気はどんどん悪くなるばかりだ。</li></ul></li></ul><h4 id="～ほど-表示程度很高"><a href="#～ほど-表示程度很高" class="headerlink" title="～ほど　表示程度很高"></a>～ほど　表示程度很高</h4><ul><li>李さんは日本人と間違わるほど，日本語が上手だ。</li><li>その日は，部屋のコップの水さえ凍るほどの寒さだった。</li></ul><h4 id="Aを境にB-以A作为分水岭有了B这样的变化"><a href="#Aを境にB-以A作为分水岭有了B这样的变化" class="headerlink" title="Aを境にB　以A作为分水岭有了B这样的变化"></a>Aを境にB　以A作为分水岭有了B这样的变化</h4><ul><li>1970年代を境に，日本は高齢化社会になったといわれる。</li></ul><h1 id="単元-1"><a href="#単元-1" class="headerlink" title="単元"></a>単元</h1><h2 id="第２１課"><a href="#第２１課" class="headerlink" title="第２１課"></a>第２１課</h2><h3 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h3><h4 id="～分-与之相对应的，与另一部分做对比"><a href="#～分-与之相对应的，与另一部分做对比" class="headerlink" title="～分　与之相对应的，与另一部分做对比"></a>～分　与之相对应的，与另一部分做对比</h4><ul><li>急いだ分，仕上がりはよくない。</li><li>食べたら食べた分，運動をしないと，太ってしまいます。</li></ul><h4 id="～ずつ-在进行反复进行的动作时，每次动作实现需要的数量或分量"><a href="#～ずつ-在进行反复进行的动作时，每次动作实现需要的数量或分量" class="headerlink" title="～ずつ　在进行反复进行的动作时，每次动作实现需要的数量或分量"></a>～ずつ　在进行反复进行的动作时，每次动作实现需要的数量或分量</h4><ul><li>3人ずつ部屋に入ってください。</li><li>機械が壊れないように，電流を少しずつ流します。</li></ul><h4 id="わけ"><a href="#わけ" class="headerlink" title="わけ"></a>わけ</h4><ul><li>～わけだ　自然而然的<ul><li>田中さんは大学を卒業して3年だから，今年25歳になるというわけだ。</li></ul></li><li>～わけがない　没有道理<ul><li>食べる後にお金を上げないわけがない。</li></ul></li><li>～わけではない　并不是，不应该，不能<ul><li>皆がルールを守らないから，自分も守らなくていいというわけではない。</li></ul></li><li>～わけにはいかない　不能（没有道理的）<ul><li>ここであきらめいるわけにはいきません。</li></ul></li></ul><h4 id="必ずしも～ない-未必，表示部分否定，不强烈的否定"><a href="#必ずしも～ない-未必，表示部分否定，不强烈的否定" class="headerlink" title="必ずしも～ない　未必，表示部分否定，不强烈的否定"></a>必ずしも～ない　未必，表示部分否定，不强烈的否定</h4><ul><li>学校で学んだことが必ずしも生活に役に立つわけではない。</li><li>王さんの言うことが必ずしも正しいとは限らない。</li></ul><h4 id="～を始め-以……代表（为首）"><a href="#～を始め-以……代表（为首）" class="headerlink" title="～を始め　以……代表（为首）"></a>～を始め　以……代表（为首）</h4><ul><li>中国，日本，韓国を始めとするアジアの国々にとって経済的な協力関係は重要だ。</li></ul><h4 id="～に至るまで-意思和まで一样，多用于列举极端的事物"><a href="#～に至るまで-意思和まで一样，多用于列举极端的事物" class="headerlink" title="～に至るまで　意思和まで一样，多用于列举极端的事物"></a>～に至るまで　意思和まで一样，多用于列举极端的事物</h4><ul><li>この店には，日常使うもの，歯ブラシやせっけんはもちろん，整髪料に至るまでそろっている。</li></ul><h4 id="～といっても過言ではない-即使这么说也不过分"><a href="#～といっても過言ではない-即使这么说也不过分" class="headerlink" title="～といっても過言ではない　即使这么说也不过分"></a>～といっても過言ではない　即使这么说也不过分</h4><ul><li>私は本が好きだ。本を読まない日はないといっても過言ではない。</li><li>現在，中国の経済が世界経済の動向を決めるといっても言い過ぎではない。</li></ul><h2 id="第２２課"><a href="#第２２課" class="headerlink" title="第２２課"></a>第２２課</h2><h3 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋ながら／つつ"><a href="#ます形＋ながら／つつ" class="headerlink" title="ます形＋ながら／つつ"></a>ます形＋ながら／つつ</h4><ul><li>同时进行的动作，强调后面的动作<ul><li>彼は食べながらテレビを見る。</li><li>私は，今，お茶を飲みつつ手紙を書いています。</li></ul></li><li>虽然……但是……，表示转折<ul><li>彼は大学生でありながら，喫茶店を経営している。</li><li>何かしなければならないと思いつつ，時間が過ぎてしまった。</li></ul></li></ul><h4 id="まま-照旧，一如原样"><a href="#まま-照旧，一如原样" class="headerlink" title="まま　照旧，一如原样"></a>まま　照旧，一如原样</h4><ul><li>～たまま／～のまま　理应改变却没有改变</li><li>～ままに　表示顺从该动作或意志和～どおり有一样的意思<ul><li>お客様のご希望のままに，シェフが調理します。</li><li>あなたが望むままに生きていきなさい。</li></ul></li></ul><h4 id="～なしで／～抜きで-在不具备本来该有的某种东西的状态下做某事"><a href="#～なしで／～抜きで-在不具备本来该有的某种东西的状态下做某事" class="headerlink" title="～なしで／～抜きで　在不具备本来该有的某种东西的状态下做某事"></a>～なしで／～抜きで　在不具备本来该有的某种东西的状态下做某事</h4><ul><li>準備なしで発表をしたら，失敗した。</li><li>相談抜きで面白い。</li></ul><h4 id="～に加え（て）-不仅……而且……"><a href="#～に加え（て）-不仅……而且……" class="headerlink" title="～に加え（て）　不仅……而且……"></a>～に加え（て）　不仅……而且……</h4><ul><li>前回の勝利に加えて，今回も大差で勝った。</li></ul><h4 id="～たびに-每当……就会……"><a href="#～たびに-每当……就会……" class="headerlink" title="～たびに　每当……就会……"></a>～たびに　每当……就会……</h4><ul><li>海絵来るたびに，子供のころ溺れたことを思い出す。</li><li>卒業式のたびに校長先生は泣きながらあいさつをします。</li><li>拓展：～といつも／～時はいつも／～ごとに　意思和～たびに一样</li></ul><h4 id="次第"><a href="#次第" class="headerlink" title="次第"></a>次第</h4><ul><li>一……就……</li><li>～次第で　随着……，取决于……</li><li>この裁判では，あなたの証言次第で，被告は有罪になります。</li><li>今回の旅行でどこへ行くかは，予算次第です。</li></ul><h2 id="第２３課"><a href="#第２３課" class="headerlink" title="第２３課"></a>第２３課</h2><h3 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h3><h4 id="～だからこそ-正因为，こそ在这里起到了强调的作用"><a href="#～だからこそ-正因为，こそ在这里起到了强调的作用" class="headerlink" title="～だからこそ　正因为，こそ在这里起到了强调的作用"></a>～だからこそ　正因为，こそ在这里起到了强调的作用</h4><ul><li>偶然ではなく，~努力したからこそ教員試験に合格したんだ。</li></ul><h4 id="从……到……"><a href="#从……到……" class="headerlink" title="从……到……"></a>从……到……</h4><ul><li>～から～まで　具有连续性的准确范围<ul><li>3時から3時15分まで休憩します。</li></ul></li><li>～から～にかけて　断断续续，大致范围<ul><li>城を持たない水上都市として，明から清にかけて大きく発展した。</li></ul></li><li>～にわたって　时间长，跨度大，范围大<ul><li>10年にわたって研究開発によって，ようやく新しい農薬が完成した。</li></ul></li></ul><h4 id="时间＋を通して-表示整个时间范围"><a href="#时间＋を通して-表示整个时间范围" class="headerlink" title="时间＋を通して　表示整个时间范围"></a>时间＋を通して　表示整个时间范围</h4><ul><li>今週一週間を通して湿度が高く，蒸し暑い日が続くでしょう。</li></ul><h4 id="～ことがない-不会出现这样的情况"><a href="#～ことがない-不会出现这样的情况" class="headerlink" title="～ことがない　不会出现这样的情况"></a>～ことがない　不会出现这样的情况</h4><ul><li>その美しさはみ飽きることがない。</li></ul><h4 id="～ことはない-没必要，用不着"><a href="#～ことはない-没必要，用不着" class="headerlink" title="～ことはない　没必要，用不着"></a>～ことはない　没必要，用不着</h4><ul><li>ここまで来て，今さえ，やめることはない。</li></ul><h2 id="第２４課"><a href="#第２４課" class="headerlink" title="第２４課"></a>第２４課</h2><h3 id="文法-7"><a href="#文法-7" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋がち-往往会，容易会，表示消极的事项"><a href="#ます形＋がち-往往会，容易会，表示消极的事项" class="headerlink" title="ます形＋がち　往往会，容易会，表示消极的事项"></a>ます形＋がち　往往会，容易会，表示消极的事项</h4><ul><li>一般の視聴者にとって，CMは迷惑なものと考えられがちだ。</li><li>それは，小さい子にありがちな自己中心的な考え方です。</li></ul><h4 id="～以上（は）～／～からには～-既然……就……（建议，义务，表决心）"><a href="#～以上（は）～／～からには～-既然……就……（建议，义务，表决心）" class="headerlink" title="～以上（は）～／～からには～　既然……就……（建议，义务，表决心）"></a>～以上（は）～／～からには～　既然……就……（建议，义务，表决心）</h4><ul><li>応援する以上は最後まで応援したほうがいい。</li><li>視聴者が，企業の広告ではなく番組のためにテレビを見る以上，広告主の企業や放送局と視聴者の利害は常に対立することになる。</li></ul><h4 id="ます形／一类形容词去い＋がる-想做，觉得，用于第三人称"><a href="#ます形／一类形容词去い＋がる-想做，觉得，用于第三人称" class="headerlink" title="ます形／一类形容词去い＋がる　想做，觉得，用于第三人称"></a>ます形／一类形容词去い＋がる　想做，觉得，用于第三人称</h4><ul><li>恥ずかしがってばかりいないで，自分から発言してはどうですか。</li><li>その子供はジュースを食べたがっている。</li></ul><h1 id="単元-2"><a href="#単元-2" class="headerlink" title="単元"></a>単元</h1><h2 id="第２５課"><a href="#第２５課" class="headerlink" title="第２５課"></a>第２５課</h2><h3 id="文法-8"><a href="#文法-8" class="headerlink" title="文法"></a>文法</h3><h4 id="～ついに-终于，表示花费时间或经过艰苦努力终于完成某事"><a href="#～ついに-终于，表示花费时间或经过艰苦努力终于完成某事" class="headerlink" title="～ついに　终于，表示花费时间或经过艰苦努力终于完成某事"></a>～ついに　终于，表示花费时间或经过艰苦努力终于完成某事</h4><ul><li>あの二人は7年交際して，ついに婚約した。</li><li>やっと　侧重于期待的事情终于实现了</li><li>あの二人は7年交際して，やっよ婚約した。</li></ul><h4 id="よく"><a href="#よく" class="headerlink" title="よく"></a>よく</h4><ul><li>经常<ul><li>陳さんは東京によく遊びに行きます。</li></ul></li><li>程度<ul><li>李さん，その洋服よく似合いますね。</li></ul></li><li>意外或感叹<ul><li>それにしても，よく会場を押さえられましたよね</li></ul></li><li>以よくも的形式表示惊讶或憎恶<ul><li>裏切っておきながら，彼はよくも私たちの前に姿を見せられたものだ。</li></ul></li></ul><h4 id="ます形＋きる-表示动作或事情彻底完成，用于动作或事情实现起来有困难时"><a href="#ます形＋きる-表示动作或事情彻底完成，用于动作或事情实现起来有困难时" class="headerlink" title="ます形＋きる　表示动作或事情彻底完成，用于动作或事情实现起来有困难时"></a>ます形＋きる　表示动作或事情彻底完成，用于动作或事情实现起来有困难时</h4><ul><li>3人分の料理を1人で食べきった。</li><li>中国をはじめとしたアジアの国々，ヨーロッパやアメリカ，中東，ロシアなどにも，数えきれないほどの日本食レストランがある。</li><li>类似的表达还有ます形＋通す　不放弃，不会改变想法，把某一动作坚持做到最后<ul><li>演奏家は途中で間違えたが，最後までその曲を弾き通した。</li></ul></li></ul><h4 id="～に応じた（接名词）／～に応じて（接动词）-根据-适应-，书面语"><a href="#～に応じた（接名词）／～に応じて（接动词）-根据-适应-，书面语" class="headerlink" title="～に応じた（接名词）／～に応じて（接动词）　根据/适应~，书面语"></a>～に応じた（接名词）／～に応じて（接动词）　根据/适应~，书面语</h4><ul><li>賃金は働きに応じて支払われる。</li><li>外国で売られている寿司は，文化の違いに応じた「創作料理」になっていることが多い。</li></ul><h4 id="～から見ると／～から見ても／～から見れば-从……来看，从某种立场上审视，考虑问题。"><a href="#～から見ると／～から見ても／～から見れば-从……来看，从某种立场上审视，考虑问题。" class="headerlink" title="～から見ると／～から見ても／～から見れば　从……来看，从某种立场上审视，考虑问题。"></a>～から見ると／～から見ても／～から見れば　从……来看，从某种立场上审视，考虑问题。</h4><ul><li>日本人から見ると，寿司だとは思えないものもたくさんある。</li><li>私から見て，佐藤さんは素晴らしい上司だ。</li></ul><h4 id="～に即した／～に即して-按照……-根据……"><a href="#～に即した／～に即して-按照……-根据……" class="headerlink" title="～に即した／～に即して　按照……/根据……"></a>～に即した／～に即して　按照……/根据……</h4><ul><li>食べ物はその国の状況に即して変化するものなのだ。</li><li>現状に即して考えると，政府の予測は楽観的過ぎる。</li></ul><h4 id="ぬ，ず-都是古日语用于表示未然形"><a href="#ぬ，ず-都是古日语用于表示未然形" class="headerlink" title="ぬ，ず　都是古日语用于表示未然形"></a>ぬ，ず　都是古日语用于表示未然形</h4><ul><li>江戸前ならぬ，アメリカ前，ニュージーランド前の寿司をその土地のスタイルで楽しむのもよいのではないだろうか。</li></ul><h2 id="第２６課"><a href="#第２６課" class="headerlink" title="第２６課"></a>第２６課</h2><h3 id="文法-9"><a href="#文法-9" class="headerlink" title="文法"></a>文法</h3><h4 id="～だけあって-真不愧是……，一般和さすが连用"><a href="#～だけあって-真不愧是……，一般和さすが连用" class="headerlink" title="～だけあって　真不愧是……，一般和さすが连用"></a>～だけあって　真不愧是……，一般和さすが连用</h4><ul><li>さすが上海一の高級ホテルだけあって，素晴らしい会場ですね。</li></ul><h4 id="～だけに-正是由于……"><a href="#～だけに-正是由于……" class="headerlink" title="～だけに　正是由于……"></a>～だけに　正是由于……</h4><ul><li>今回のテストは簡単だっただけに，クラスの平均点は高かった。</li></ul><h4 id="古日语表示未然形"><a href="#古日语表示未然形" class="headerlink" title="古日语表示未然形"></a>古日语表示未然形</h4><ul><li>复习：ず（三类动词せず），ぬ</li><li>ざる<ul><li>ない形＋ざるをえない／～しかない　不得不……，只好……<ul><li>約束だから，明日までにやらざるをえません。</li><li>期限が迫っているので，決めざるを得ません。</li><li>パソコンがフリーズしたので，プログラムを終了するしかありません。</li></ul></li></ul></li></ul><h4 id="～にもかかわらず-尽管……-虽然……"><a href="#～にもかかわらず-尽管……-虽然……" class="headerlink" title="～にもかかわらず　尽管……/虽然……"></a>～にもかかわらず　尽管……/虽然……</h4><ul><li>何度も注意したにもかかわらず，娘はまた友達の悪口を言っている。</li><li>李さんは頭が痛いにもかかわらず，寝ないで仕事を続けた。</li></ul><h4 id="～どころか-从根本上否定，用于消极事项，类似はもちろん"><a href="#～どころか-从根本上否定，用于消极事项，类似はもちろん" class="headerlink" title="～どころか　从根本上否定，用于消极事项，类似はもちろん"></a>～どころか　从根本上否定，用于消极事项，类似はもちろん</h4><ul><li>忙しくて，昼ご飯どころか，朝ご飯も食べていない。</li><li>このところ支出が多くて，貯金するどころか，借金が増えてしまった。</li></ul><h4 id="ます形＋かねる／かねない-难以实现-不好的事情很容易很可能实现"><a href="#ます形＋かねる／かねない-难以实现-不好的事情很容易很可能实现" class="headerlink" title="ます形＋かねる／かねない　难以实现/不好的事情很容易很可能实现"></a>ます形＋かねる／かねない　难以实现/不好的事情很容易很可能实现</h4><ul><li>このままだと，プロジェクトは中止になりかねない。</li></ul><h2 id="第２７課"><a href="#第２７課" class="headerlink" title="第２７課"></a>第２７課</h2><h3 id="文法-10"><a href="#文法-10" class="headerlink" title="文法"></a>文法</h3><h4 id="Aなしには／では／て＋B-没有A是不可能完成B的"><a href="#Aなしには／では／て＋B-没有A是不可能完成B的" class="headerlink" title="Aなしには／では／て＋B　没有A是不可能完成B的"></a>Aなしには／では／て＋B　没有A是不可能完成B的</h4><ul><li>今回の成功は，彼らの協力なしにはありえなかったと思います。</li><li>お金もなしに，会社を成立することは不可能だ。</li></ul><h4 id="ます形＋える／うる-也表示为动词的可能态"><a href="#ます形＋える／うる-也表示为动词的可能态" class="headerlink" title="ます形＋える／うる　也表示为动词的可能态"></a>ます形＋える／うる　也表示为动词的可能态</h4><ul><li>この状態は，予想しえない事態だ。</li></ul><h4 id="字典形＋まい"><a href="#字典形＋まい" class="headerlink" title="字典形＋まい"></a>字典形＋まい</h4><ul><li>～ないだろう　表示否定推测，难道不是……<ul><li>この勝負の勝敗はすでに決まっていたのではあるまいか。</li></ul></li><li>～しないつもりだ　表示否定的意志<ul><li>こんな所にはもう二度と来るまい。</li></ul></li></ul><h4 id="～ずにはいられない-忍不住要……做"><a href="#～ずにはいられない-忍不住要……做" class="headerlink" title="～ずにはいられない　忍不住要……做"></a>～ずにはいられない　忍不住要……做</h4><ul><li>部屋が汚れていると，片づけずにはいられない。</li><li>その映画を見たら，泣かずにはいられない。</li></ul><h4 id="～のみならず-不仅……"><a href="#～のみならず-不仅……" class="headerlink" title="～のみならず　不仅……"></a>～のみならず　不仅……</h4><ul><li>中国のみならず，日本でも張一心は人気がある。</li><li>复习：和～ばかりでなく，～だけではなく意思一样</li></ul><h4 id="ちなみに～-顺便一提，附带，补充说明"><a href="#ちなみに～-顺便一提，附带，补充说明" class="headerlink" title="ちなみに～　顺便一提，附带，补充说明"></a>ちなみに～　顺便一提，附带，补充说明</h4><ul><li>玉袁譚公園では，日本から寄贈された桜を見ることができる。ちなみに，北京の桜は東京よりも3週間ほど開花が遅いそうだ。</li></ul><h2 id="第２８課"><a href="#第２８課" class="headerlink" title="第２８課"></a>第２８課</h2><h3 id="文法-11"><a href="#文法-11" class="headerlink" title="文法"></a>文法</h3><h4 id="～もんです-表示理由的ものです"><a href="#～もんです-表示理由的ものです" class="headerlink" title="～もんです　表示理由的ものです"></a>～もんです　表示理由的ものです</h4><ul><li>ここ数日忙しかったもんで，なかなかお電話できず申し訳ありませんでした。</li></ul><h4 id="ついでに-做某事同时又在做着其他事情"><a href="#ついでに-做某事同时又在做着其他事情" class="headerlink" title="ついでに　做某事同时又在做着其他事情"></a>ついでに　做某事同时又在做着其他事情</h4><ul><li>散歩に出たついでに，コンビニで買い物をして帰った。</li></ul><h4 id="だったらいいんです／ならいいんです-那就好"><a href="#だったらいいんです／ならいいんです-那就好" class="headerlink" title="だったらいいんです／ならいいんです　那就好"></a>だったらいいんです／ならいいんです　那就好</h4><ul><li>コンテストは大成功のうちに終わりました。<ul><li>だったらいいんです。</li></ul></li></ul><h4 id="～だけには～-唯独对……"><a href="#～だけには～-唯独对……" class="headerlink" title="～だけには～　唯独对……"></a>～だけには～　唯独对……</h4><ul><li>健康だけには自信があったのに。</li></ul><h4 id="Aに反してB-与A相反的B"><a href="#Aに反してB-与A相反的B" class="headerlink" title="Aに反してB　与A相反的B"></a>Aに反してB　与A相反的B</h4><ul><li>予想に反して，来場者は1万人を超えた。</li></ul><h4 id="そてらとは別に-另一方面，与～一方有相同的意思"><a href="#そてらとは別に-另一方面，与～一方有相同的意思" class="headerlink" title="そてらとは別に　另一方面，与～一方有相同的意思"></a>そてらとは別に　另一方面，与～一方有相同的意思</h4><ul><li>彼は英会話学校で動いています。しかし，それらとは別に芸術家として活動しています。</li></ul><h1 id="単元-3"><a href="#単元-3" class="headerlink" title="単元"></a>単元</h1><h2 id="第２９課"><a href="#第２９課" class="headerlink" title="第２９課"></a>第２９課</h2><h3 id="文法-12"><a href="#文法-12" class="headerlink" title="文法"></a>文法</h3><h4 id="～までもない-没必要"><a href="#～までもない-没必要" class="headerlink" title="～までもない　没必要"></a>～までもない　没必要</h4><ul><li>今さら言うまでもありません，すべて皆さんのおかげです。</li></ul><h4 id="～ぶり／～っぷり-……的样子"><a href="#～ぶり／～っぷり-……的样子" class="headerlink" title="～ぶり／～っぷり　……的样子"></a>～ぶり／～っぷり　……的样子</h4><ul><li>彼の歩きぶりから見せと，どうも足にけがをしているようだ。</li><li>佐藤さんはいつも食べっぷりがいい。</li><li>复习：时间＋ぶり表示时间间隔</li></ul><h4 id="たった-仅仅经常和だけ连用"><a href="#たった-仅仅经常和だけ连用" class="headerlink" title="たった　仅仅经常和だけ连用"></a>たった　仅仅经常和だけ连用</h4><ul><li>たった1年で，これだけ業績を上げたんですから。</li></ul><h4 id="～に決まっている-一定是……，绝对是……，肯定是……"><a href="#～に決まっている-一定是……，绝对是……，肯定是……" class="headerlink" title="～に決まっている　一定是……，绝对是……，肯定是……"></a>～に決まっている　一定是……，绝对是……，肯定是……</h4><ul><li>今から会社に帰っても，もう誰もいないにきまっている。</li></ul><h4 id="AうえでB／AたうえでB-为了A，在此之前先做B-先做A，然后做B"><a href="#AうえでB／AたうえでB-为了A，在此之前先做B-先做A，然后做B" class="headerlink" title="AうえでB／AたうえでB　为了A，在此之前先做B/先做A，然后做B"></a>AうえでB／AたうえでB　为了A，在此之前先做B/先做A，然后做B</h4><ul><li>外国に住むうえで，一番気を付けなければならないことは何ですか。</li><li>多額の資金を集めたうえで，会長に立候補した。</li></ul><h4 id="そう～ではない-并不是……"><a href="#そう～ではない-并不是……" class="headerlink" title="そう～ではない　并不是……"></a>そう～ではない　并不是……</h4><ul><li>日本語はそう難しくないと思います。</li></ul><h4 id="～とはいうものの-虽然这么说，尽管"><a href="#～とはいうものの-虽然这么说，尽管" class="headerlink" title="～とはいうものの　虽然这么说，尽管"></a>～とはいうものの　虽然这么说，尽管</h4><ul><li>とはいうものの，宇宙に持っていける食べ物には，いくつかの条件がある。</li><li>このはかりはデザインが斬新なものの，実用的ではない。</li></ul><h4 id="～にすら-尽然，连"><a href="#～にすら-尽然，连" class="headerlink" title="～にすら　尽然，连"></a>～にすら　尽然，连</h4><ul><li>そのことは，田中さんすら知らなかった。</li><li>疲れ切って，食事すらできない。</li></ul><h4 id="～にあたって-在……之际"><a href="#～にあたって-在……之际" class="headerlink" title="～にあたって　在……之际"></a>～にあたって　在……之际</h4><ul><li>海外に赴任するにあたって，いろいろな準備をしなければなりませんでした。</li></ul><h2 id="第３０課"><a href="#第３０課" class="headerlink" title="第３０課"></a>第３０課</h2><h3 id="文法-13"><a href="#文法-13" class="headerlink" title="文法"></a>文法</h3><h4 id="Aに先立ってB-在A之前先做B动作"><a href="#Aに先立ってB-在A之前先做B动作" class="headerlink" title="Aに先立ってB　在A之前先做B动作"></a>Aに先立ってB　在A之前先做B动作</h4><ul><li>トレーニングの開始に先立ち，細かいスケジュールを立てた。</li></ul><h4 id="Aを通してB-表示方法手段，通过A做B动作"><a href="#Aを通してB-表示方法手段，通过A做B动作" class="headerlink" title="Aを通してB　表示方法手段，通过A做B动作"></a>Aを通してB　表示方法手段，通过A做B动作</h4><ul><li>妻とは，私と妻の共通の友人を通して知り合いました。</li><li>复习：时间段+を通して　表示整个时间段</li></ul><h4 id="～できなくはない-不是不能"><a href="#～できなくはない-不是不能" class="headerlink" title="～できなくはない　不是不能"></a>～できなくはない　不是不能</h4><ul><li>その映画は原作を読まなくても理解できなくはないですが，よく分からないと思うころがたくさんあると思います。</li></ul><h4 id="～にしたがって／～につれて-随着……，按照……"><a href="#～にしたがって／～につれて-随着……，按照……" class="headerlink" title="～にしたがって／～につれて　随着……，按照……"></a>～にしたがって／～につれて　随着……，按照……</h4><ul><li>年を取るにしたがって，一日が短く感じられるのはなぜだろう。</li><li>太陽が沈むにしたがって，辺りは暗くなった。</li></ul><h4 id="～にすぎない-不过如此，没什么大不了的"><a href="#～にすぎない-不过如此，没什么大不了的" class="headerlink" title="～にすぎない　不过如此，没什么大不了的"></a>～にすぎない　不过如此，没什么大不了的</h4><ul><li>私はあくまで彼の代理で会議に出席したにすぎない。</li></ul><h4 id="～に位置している-位于，处于……位置"><a href="#～に位置している-位于，处于……位置" class="headerlink" title="～に位置している　位于，处于……位置"></a>～に位置している　位于，处于……位置</h4><ul><li>フランスはドイツの西に位置しています。</li></ul><h4 id="～にほかならない-正因为是……"><a href="#～にほかならない-正因为是……" class="headerlink" title="～にほかならない　正因为是……"></a>～にほかならない　正因为是……</h4><ul><li>落第の原因は，勉強不足にほかならない。</li></ul><h4 id="～としても，～-即使……也……"><a href="#～としても，～-即使……也……" class="headerlink" title="～としても，～　即使……也……"></a>～としても，～　即使……也……</h4><ul><li>両親が反対したとしても，私は留学します。</li><li>明日は忙しいので，そちらに伺えるとしても遅くなってしまうと思います。</li></ul><h2 id="第３１課"><a href="#第３１課" class="headerlink" title="第３１課"></a>第３１課</h2><h3 id="文法-14"><a href="#文法-14" class="headerlink" title="文法"></a>文法</h3><h4 id="～くせに-明明……却……"><a href="#～くせに-明明……却……" class="headerlink" title="～くせに　明明……却……"></a>～くせに　明明……却……</h4><ul><li>俺より2年後輩のくせに，すごいじゃないか。</li><li>私の息子は，学校で答えが分からないくせに，いつも手を挙げているそうだ。</li></ul><h4 id="（动词原形-形容词去い＋くある-名词和形动＋である）＋べき-表示第三人称的应该……"><a href="#（动词原形-形容词去い＋くある-名词和形动＋である）＋べき-表示第三人称的应该……" class="headerlink" title="（动词原形/形容词去い＋くある/名词和形动＋である）＋べき　表示第三人称的应该……"></a>（动词原形/形容词去い＋くある/名词和形动＋である）＋べき　表示第三人称的应该……</h4><ul><li>とにかく，先に栄転を受けるべきだよ。</li><li>すべての人は平等であるべきだ。</li><li>地球の自然はいつまでも美しくあるべきだ。</li></ul><h4 id="～もんか／～ものか-不……"><a href="#～もんか／～ものか-不……" class="headerlink" title="～もんか／～ものか　不……"></a>～もんか／～ものか　不……</h4><ul><li>こうなったら，もう心配なんてするもんか。</li><li>助けてやると言ったのに断るなんて，もう絶対に助けてやるものか。</li></ul><h4 id="～てやる-说话人给予对方利益，恩惠。"><a href="#～てやる-说话人给予对方利益，恩惠。" class="headerlink" title="～てやる　说话人给予对方利益，恩惠。"></a>～てやる　说话人给予对方利益，恩惠。</h4><ul><li>今日は俺がおごってやるよ。</li><li>娘に四捨五入の方法を教えてやる。</li></ul><h4 id="～とすると／～とすれば／～となると／～としたら-如果……"><a href="#～とすると／～とすれば／～となると／～としたら-如果……" class="headerlink" title="～とすると／～とすれば／～となると／～としたら　如果……"></a>～とすると／～とすれば／～となると／～としたら　如果……</h4><ul><li>公衆の面前でスピーチするとなると，緊張してしまいます。</li></ul><h4 id="～がなされる／～をする-古日语的用法，书面语"><a href="#～がなされる／～をする-古日语的用法，书面语" class="headerlink" title="～がなされる／～をする　古日语的用法，书面语"></a>～がなされる／～をする　古日语的用法，书面语</h4><ul><li>今回の研究会では活溌な議論がなされる。</li></ul><h2 id="第３２課"><a href="#第３２課" class="headerlink" title="第３２課"></a>第３２課</h2><h3 id="文法-15"><a href="#文法-15" class="headerlink" title="文法"></a>文法</h3><h4 id="～どころではない-顾不上……，不是做……的时候"><a href="#～どころではない-顾不上……，不是做……的时候" class="headerlink" title="～どころではない　顾不上……，不是做……的时候"></a>～どころではない　顾不上……，不是做……的时候</h4><ul><li>父は正月だというのに出かけるどころではなく，家で遅くまで仕事をしている。</li></ul><h4 id="～なりに-站在……立场上"><a href="#～なりに-站在……立场上" class="headerlink" title="～なりに　站在……立场上"></a>～なりに　站在……立场上</h4><ul><li>大阪で，僕なりに考えました。</li><li>あの子もあの子なりに意見があるのでしょうから，怒らないでまず話を聞いてあげてください。</li></ul><h4 id="～でしかない-不过是……"><a href="#～でしかない-不过是……" class="headerlink" title="～でしかない　不过是……"></a>～でしかない　不过是……</h4><ul><li>貯金しているといっても，まだ１０万円でしかない。</li><li>言葉というのはコミュニケーションをするための道具でしかない。</li></ul><h4 id="～恐れがある／～かねない（有依据时可以使用）-恐怕会……，很有可能……发生不好的事情"><a href="#～恐れがある／～かねない（有依据时可以使用）-恐怕会……，很有可能……发生不好的事情" class="headerlink" title="～恐れがある／～かねない（有依据时可以使用）　恐怕会……，很有可能……发生不好的事情"></a>～恐れがある／～かねない（有依据时可以使用）　恐怕会……，很有可能……发生不好的事情</h4><ul><li>台風が本州に上達する恐れがある。</li><li>あんな運転の仕方では，衝突事故でも起こしかねない。</li></ul><h4 id="～のみ-和だけ一样的意思，书面语"><a href="#～のみ-和だけ一样的意思，书面语" class="headerlink" title="～のみ　和だけ一样的意思，书面语"></a>～のみ　和だけ一样的意思，书面语</h4><ul><li>この商品は，予約している方のみ購入することができます。</li></ul><h4 id="～に至る-到……为止，书面语"><a href="#～に至る-到……为止，书面语" class="headerlink" title="～に至る　到……为止，书面语"></a>～に至る　到……为止，书面语</h4><ul><li>現在では1000羽以上が確認されるに至っている。</li><li>結婚に至るまで，二人の間にはいろんなことがありました。</li></ul><h4 id="AかたわらB-表示A和B同时进行，A是主要动作，B是次要动作"><a href="#AかたわらB-表示A和B同时进行，A是主要动作，B是次要动作" class="headerlink" title="AかたわらB　表示A和B同时进行，A是主要动作，B是次要动作"></a>AかたわらB　表示A和B同时进行，A是主要动作，B是次要动作</h4><ul><li>山本さんはコーチのかたわら，審判としても活躍している。</li></ul><h4 id="～に終わる（失敗，不調）-以不顺利的情况结束"><a href="#～に終わる（失敗，不調）-以不顺利的情况结束" class="headerlink" title="～に終わる（失敗，不調）　以不顺利的情况结束"></a>～に終わる（失敗，不調）　以不顺利的情况结束</h4><ul><li>今回の世界大会で，日本チームは実力が出せずに不調に終わった。</li></ul><h4 id="～をもって-以……分水岭，从……起，到……为止"><a href="#～をもって-以……分水岭，从……起，到……为止" class="headerlink" title="～をもって　以……分水岭，从……起，到……为止"></a>～をもって　以……分水岭，从……起，到……为止</h4><ul><li>私は，3月31日をもって，会社を退職することにいたしました。</li></ul><h4 id="～に際して-在……之际，……的时候，书面语"><a href="#～に際して-在……之际，……的时候，书面语" class="headerlink" title="～に際して　在……之际，……的时候，书面语"></a>～に際して　在……之际，……的时候，书面语</h4><ul><li>本ホームページのご利用に際しては，以かの点にご注意ください。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之N2文法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-N3文法</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-N3%E6%96%87%E6%B3%95/"/>
    <id>/2024/06/11/日语-N3文法/</id>
    <published>2024-06-11T03:10:55.000Z</published>
    <updated>2024-06-11T05:20:24.688Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之N3文法<br><a id="more"></a></p><h1 id="単元"><a href="#単元" class="headerlink" title="単元"></a>単元</h1><h2 id="第１課"><a href="#第１課" class="headerlink" title="第１課"></a>第１課</h2><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><h4 id="～くらい-ぐらい-ほど-接续：动词简体，形容词，形容动词＋な，名词"><a href="#～くらい-ぐらい-ほど-接续：动词简体，形容词，形容动词＋な，名词" class="headerlink" title="～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词"></a>～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词</h4><ol><li><p>接续：动词简体，形容词，形容动词+ な</p></li><li><p>……左右，大约……，可以和ほど替换</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：家から学校まで一時間ぐらいかかる。</span><br><span class="line">译：从家到学校大概要花1个小时左右。</span><br><span class="line"></span><br><span class="line">例：どのぐらい日本語を勉強していますか。</span><br><span class="line">译：大概学了多久日语呢？</span><br></pre></td></tr></table></figure><ol start="3"><li>表示动作或状态的程度，可以和ほど替换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：飛ぶほど嬉しい。</span><br><span class="line">译：高兴地飞起。</span><br><span class="line"></span><br><span class="line">例：今日は忙しくて、食事する時間もないくらいだ。</span><br><span class="line">译：今天太忙了以至于我连吃饭的时间都没有。</span><br></pre></td></tr></table></figure><ol start="4"><li>表示最低程度，至少</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：いくら忙しくても、電話ぐらいはできるでしょう。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：自分の事ぐらいは自分でやります。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ol start="5"><li>没有比……更……，可以和ほど替换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：朱さんぐらい可愛い人はいない。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：戦争ぐらい残酷なものはない。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="とは-というのは"><a href="#とは-というのは" class="headerlink" title="とは/というのは"></a>とは/というのは</h4><ol><li>所谓的~ 用于下定义和解释说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：JRとは、Japan Railwaysの略です。</span><br><span class="line">译：JR是Japan Railways的简写。</span><br></pre></td></tr></table></figure><ol start="2"><li>……是因为…… 前者是因为后者导致的，这时只能用～というのは～のだ</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は怒ったというのは、きっと酷い事を言われたのでしょう。</span><br><span class="line">译：他生气的原因一定是被说了很过分的话吧？</span><br></pre></td></tr></table></figure><h4 id="～というものは-ということは-用于说明该事物的本质特征"><a href="#～というものは-ということは-用于说明该事物的本质特征" class="headerlink" title="～というものは/ということは 用于说明该事物的本质特征"></a>～というものは/ということは 用于说明该事物的本质特征</h4><ol><li>～というものは 用于名词</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：人間というものは一人で生きていくことはできません。</span><br><span class="line">译：人类是一个人无法生存下去的吧。</span><br></pre></td></tr></table></figure><ol start="2"><li>～ということは 用于动词，也可以用于对事情原因的推测</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：一人で生活するということは、大変なことですね。</span><br><span class="line">译：一个人生活真是不容易呀。</span><br><span class="line"></span><br><span class="line">例：彼は怒ったということは、きっと酷い事を言われたのでしょう。</span><br><span class="line">译：他生气的原因一定是被说了很过分的话吧？</span><br></pre></td></tr></table></figure><ol start="3"><li>～ということは/つまり、～ということだ　也就是说……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日から会社へ来なくてもいい、つまり君はクビだということだ。</span><br><span class="line">译：明天就不用来公司上班了，也就是说你被解雇了。</span><br></pre></td></tr></table></figure><h4 id="～はもちろん-はもとより-自不必说"><a href="#～はもちろん-はもとより-自不必说" class="headerlink" title="～はもちろん/はもとより　自不必说"></a>～はもちろん/はもとより　自不必说</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：最近は仕事が忙しくて、土曜日はもちろん、日曜日も休めない。</span><br><span class="line">译：最近工作太忙了，星期六就不用说了，星期天也没法休息了。</span><br><span class="line"></span><br><span class="line">例：主要都市を結ぶ路線はもちろん、世界で初めて実用化されたリニアモーターカーも国営です。</span><br><span class="line">译：连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。</span><br></pre></td></tr></table></figure><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>日本には，JR，鉄道，公営の３種類の鉄道会社があります。JRとは，Japan Railwaysの略です。以前は国営の鉄道でしたが，１９８７年に民営化されました。世界的に有名な新幹線もJRの路線の１つで，日本の主要な都市と都市を結んでいます。最高時速は３００キロを超えます。最初に完成したのは東海道新幹線ですが，山陽新幹線，東北新幹線，九州新幹線など，路線がどんどん延びています。</p><p>中国の鉄道は，ほとんど国営です。主要都市を結ぶ路線はもちろん，世界で初めて実用化されたリニアモーターも国営です。</p><blockquote><p>在日本有JR、铁路、公营三种类型的铁路公司。JR是Japan Railways的简称。以前是属于国有铁路，1987年民营化了。世界有名的新干线就是JR的其中一条线路，把日本主要城市与城市之间连接起来。最高时速超过300公里。最初完成的是东海道新干线、山阳新干线以及九州新干线等等，渐渐的线路不断延伸。</p></blockquote><blockquote><p>中国的铁路基本都是国营的。连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。</p></blockquote><h2 id="第２課"><a href="#第２課" class="headerlink" title="第２課"></a>第２課</h2><h3 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h3><h4 id="～ものです。"><a href="#～ものです。" class="headerlink" title="～ものです。"></a>～ものです。</h4><ol><li>表示对事物的性质或变化的感慨或吃惊，经常与よく一起使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一人でよく返って来られたものですね。</span><br><span class="line">译：竟然能一个人回来呀。</span><br></pre></td></tr></table></figure><ol start="2"><li>AはBものです，A本质上具有B的性质、B是理所应当的事情</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：人の心は分からないものです。（本质）</span><br><span class="line">译：人心是最难懂的。</span><br><span class="line"></span><br><span class="line">例：約束の時間に遅れる時は，相手に連絡するものです。（理所应当）</span><br><span class="line">译：在约定的时间迟到了的话，应该和对方联系。</span><br></pre></td></tr></table></figure><h4 id="口语中经常使用～て来接续，书面语中使用ます形来接续"><a href="#口语中经常使用～て来接续，书面语中使用ます形来接续" class="headerlink" title="口语中经常使用～て来接续，书面语中使用ます形来接续"></a>口语中经常使用～て来接续，书面语中使用ます形来接续</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：深いお辞儀をし，相手の名刺をお辞儀をしながら受け取ります。</span><br><span class="line">译：深深地鞠躬，一边鞠躬一边接受对方的名片。</span><br></pre></td></tr></table></figure><h4 id="简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！"><a href="#简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！" class="headerlink" title="简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！"></a>简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：名刺を出す時も受け取る時も，両手を使うほうが丁寧です。</span><br><span class="line">译：名片递出和接收的时候，用双手是更加礼貌的。</span><br></pre></td></tr></table></figure><h4 id="いくら～ても～-无论……也……"><a href="#いくら～ても～-无论……也……" class="headerlink" title="いくら～ても～　无论……也……"></a>いくら～ても～　无论……也……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この店ではいくら食べても，１０００円です。</span><br><span class="line">译：这家店不管吃多少，只要1000日元。</span><br></pre></td></tr></table></figure><h3 id="课文-1"><a href="#课文-1" class="headerlink" title="课文"></a>课文</h3><p>仕事で初対面の人にあった時は，名刺を出します。名刺の出し方と受け取り方にも決まりがあります。相手が目上の時は，まず自分から名刺をだして深いお辞儀をし，次に相手の名刺をお辞儀をしながら受け取ります。出す時も受け取る時も，両手を使うほうが丁寧です。</p><p>また，話内容にも気をつけなけれならなりません。初対面の時は，個人的なことを聞かないのが普通です。特に仕事の場で出合った相手には，個人的な質問を避けたほうがいいでしょう。結婚しているかどうか，給料はいくらか，年齢はいくつかなどもは，普通は聞きません。</p><blockquote><p>工作场合下和对方第一次见面时，要递出名片。名片的递出和接收方法都是有规定的。对方是上级的时候，首先自己首先递出名片并深鞠躬，接着边鞠躬边接收对方的名片。名片递出和接收的时候，用双手是更加礼貌的。</p></blockquote><blockquote><p>另外聊天的内容也要注意。第一次见面时，个人相关的事情一般不要询问。特别是工作场合遇到对方，最好避免个人问题。结婚了没，工资多少，年龄多大了等问题一般不要询问。</p></blockquote><h2 id="第３課"><a href="#第３課" class="headerlink" title="第３課"></a>第３課</h2><h3 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h3><h4 id="～を含めて＋数量词-包括-在内的-「数量词」"><a href="#～を含めて＋数量词-包括-在内的-「数量词」" class="headerlink" title="～を含めて＋数量词 包括~在内的+「数量词」"></a>～を含めて＋数量词 包括~在内的+「数量词」</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今回の『金星』プロジェクトは，私を含めて４名のスタッフが担当いたします。</span><br><span class="line">译：这次金星项目包括我一共四人负责。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：～ほか＋数量词 除开……还有+「数量词」……</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今回のプロジェクトの担当者は，主任の李秀麗ほか３名のスタッフです。</span><br><span class="line">译：这次的项目负责人除了李秀丽以外还有3人。</span><br></pre></td></tr></table></figure><h4 id="～にとって-对……来说，表示从某人立场上来说，用于表明立场"><a href="#～にとって-对……来说，表示从某人立场上来说，用于表明立场" class="headerlink" title="～にとって 对……来说，表示从某人立场上来说，用于表明立场"></a>～にとって 对……来说，表示从某人立场上来说，用于表明立场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。</span><br><span class="line">译：对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><blockquote><p>～として，有和当事人有同一向想法的时候使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：困っている人を助けるのは，人間として当然のことです。</span><br><span class="line">译：帮助有困难的人，作为人来说是应当的。</span><br></pre></td></tr></table></figure><blockquote><p>～としては，站在客观立场上，强调自己的立场</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私としては，その案に反対です。</span><br><span class="line">译：我个人是反对这个方案的。</span><br></pre></td></tr></table></figure><blockquote><p>～にしたら・～してみれば・～にすれば 有希望对方理解的感觉</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大人には簡単でも，子供にしたら難しいでしょう。</span><br><span class="line">译：对大人来说简单，可对小孩子就困难的很。</span><br></pre></td></tr></table></figure><h4 id="～が，～けど-表示转折或者铺垫下文的说法"><a href="#～が，～けど-表示转折或者铺垫下文的说法" class="headerlink" title="～が，～けど 表示转折或者铺垫下文的说法"></a>～が，～けど 表示转折或者铺垫下文的说法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：すみませんが，今話してもいいでしょう。</span><br><span class="line">译：打扰一下，现在方便说话吗？</span><br><span class="line"></span><br><span class="line">例：李さんも日本語も上手ですけど，王さんも上手ですね。</span><br><span class="line">译：李桑日语说的很好，王桑也说的很好呀。</span><br></pre></td></tr></table></figure><h4 id="～わけには-もいきません-依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱"><a href="#～わけには-もいきません-依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱" class="headerlink" title="～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱"></a>～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：名字をつけないわけにはにいきません。</span><br><span class="line">译：不取名字是不行的。</span><br><span class="line"></span><br><span class="line">例：質問がたくさんあっても，無視するわけにもいかないので，きちんと答えています。</span><br><span class="line">译：即使问题有很多，也不能无视它，要好好地回答。</span><br></pre></td></tr></table></figure><h4 id="～といわれています-据说，通常认为，表示非说话人主观判断，而是一种普遍的常识"><a href="#～といわれています-据说，通常认为，表示非说话人主观判断，而是一种普遍的常识" class="headerlink" title="～といわれています　据说，通常认为，表示非说话人主观判断，而是一种普遍的常识"></a>～といわれています　据说，通常认为，表示非说话人主观判断，而是一种普遍的常识</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。</span><br><span class="line">译：日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。</span><br></pre></td></tr></table></figure><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li>佐藤：よろしくお願いします。李さんも日本語が上手ですけど，王さんも上手です。</li><li>王：ありがとうございます。出身は浙江省の紹興ですが，大学時代，日本に留学していたんです。ですから，今回のプロジェクトに大変興味があります。</li><li>佐藤：紹興ですか，１０年前に，一度だけ行ったことがあります。</li><li>王：そうでうか。</li><li>佐藤：ええ。私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">佐藤：请多关照。李桑日语说的很好，王桑也说的很好呀。</span><br><span class="line">王：谢谢夸奖。出生于浙江绍兴，大学地时候，去日本留学过。所以对这次地项目非常地有兴趣。</span><br><span class="line">佐藤：绍兴吗，10年前，去过一次呀。</span><br><span class="line">王：是吗？</span><br><span class="line">佐藤：是的呢。对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。</span><br></pre></td></tr></table></figure><h3 id="课文-2"><a href="#课文-2" class="headerlink" title="课文"></a>课文</h3><p>しかし，名字をつけないわけにはいきません。そこで，多くの人が，地名や地形から名字をつけましら。日本の名字に，『木』，『林』，『山』，『川』など自然に関係する名字が多いのは，そのためです。家が谷の中にあるから『中谷』，近くに大きな杉の木があるから『大杉』とつけられた名字もたくさんあります。日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。</p><blockquote><p>但是不取名字是不行的。所以大多数人的名字是来源于地名或地形。因此日本的名字中，『木』，『林』，『山』，『川』等等和自然有关的名字很多。家住在山谷中就叫『中谷』，附近有巨大的杉树就叫『大杉』这样的名字也有很多。日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。</p></blockquote><h2 id="第４課"><a href="#第４課" class="headerlink" title="第４課"></a>第４課</h2><h3 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h3><h4 id="信息的转述"><a href="#信息的转述" class="headerlink" title="信息的转述"></a>信息的转述</h4><ol><li>简体＋そうです</li></ol><ul><li>转述他人信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：李さんは明日会社を休むそうです。</span><br><span class="line">译：李桑明天休假。</span><br></pre></td></tr></table></figure><ul><li>听说传闻</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼女はもうすぐ結婚するそうです。</span><br><span class="line">译：她好像马上要结婚了。</span><br></pre></td></tr></table></figure><ul><li>样态，似乎、好像、看起来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この葡萄が美味しそうです。</span><br><span class="line">译：这个葡萄看起来很好吃的样子。</span><br></pre></td></tr></table></figure><ol start="2"><li>～とのことです、～ということです 听说，据说</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：このダムには３メートルくらいの魚がいるということです。</span><br><span class="line">译：听说这个水坝有3米长的鱼。</span><br><span class="line"></span><br><span class="line">例：山田さんがよろしくとのことです。</span><br><span class="line">译：听说山田人很好。</span><br></pre></td></tr></table></figure><ol start="3"><li>～といってもいました 记得说过，或者用于确认对方说的话</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：青木主任がちょっとお話しをしたいと言っていました。</span><br><span class="line">译：青木主任想和你说几句话。</span><br></pre></td></tr></table></figure><ol start="4"><li>简体＋って 与家人、朋友等亲密的人表示传闻，可以替换～と，～とは，～という人は</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日は雨だって。</span><br><span class="line">译：明天有雨。</span><br></pre></td></tr></table></figure><h4 id="思ったより-超出预想水平或范围"><a href="#思ったより-超出预想水平或范围" class="headerlink" title="思ったより 超出预想水平或范围"></a>思ったより 超出预想水平或范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：思ったより大変な仕事になりそうなんです。</span><br><span class="line">译：工作变得超乎想象的辛苦呢。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：予想以上に/想像以上に 比より更加正式程度也更强一些</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：今月の給料は予想以上に少なくて，がっかりしました。</span><br><span class="line">译：这个月的工资比预想的少多了，很失望。</span><br><span class="line"></span><br><span class="line">例：上海の変化は想像以上に速いですね。</span><br><span class="line">译：上海的变化比预想的还要快呀。</span><br></pre></td></tr></table></figure><h4 id="～といえば-说道-用于把名词作为话题提出，对话题进行说明"><a href="#～といえば-说道-用于把名词作为话题提出，对话题进行说明" class="headerlink" title="～といえば　说道~ 用于把名词作为话题提出，对话题进行说明"></a>～といえば　说道~ 用于把名词作为话题提出，对话题进行说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：かつて，日本のサラリーマンといえば，朝早く家を出て家に帰るのは深夜になり，残業や休日出勤をするのは当たり前でした。</span><br><span class="line">译：以前说到日本的上班族，很早出门深夜回家，加班和周末上班是理所应当的。</span><br></pre></td></tr></table></figure><h4 id="このように-综上所述"><a href="#このように-综上所述" class="headerlink" title="このように 综上所述"></a>このように 综上所述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このように，日本のサラリーマンの働き方は，かつてに比べると大きく変化しています。</span><br><span class="line">译：综上所述，日本的上班族的工作方式对比之前有了很大变化。</span><br></pre></td></tr></table></figure><h3 id="会话-1"><a href="#会话-1" class="headerlink" title="会话"></a>会话</h3><ul><li>青木：お忙しいところすみません。実は，上海支社で進めている『金星』プロジェクトが，思ったより大変な仕事になりそうなんです。</li><li>山田：そうですか。</li><li>青木：それで，東京本社でも『金星』プロジェクトの担当者を決めることになりました。突然ですが，山田さん，この仕事をしてもらえませんか。</li><li>山田：私が『金星』プロジェクトの担当者に？</li><li>青木：はい。上海支社の李さんからの要望なんです。</li><li>山田：李さんが，私を推薦してくれたんですか。</li><li>青木：ええ。山田さんは上海支社に行ったこともあるし，中国の事情に詳しいからということでした。</li><li>山田：分かりました。中国と関係のある仕事なら，ぜひやってみたいと思います。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">青木：这忙还打扰你。实际上上海分公司正在推进的金星项目，变得比预想还要麻烦呢。</span><br><span class="line">山田：是这样吗？</span><br><span class="line">青木：所以，东京总公司决定了金星项目的负责人。虽然有些突然，山田桑，这份工作你愿意接受吗？</span><br><span class="line">山田：我担任金星项目的负责人吗？</span><br><span class="line">青木：是的。上海分公司的李桑推荐的。</span><br><span class="line">山田：李桑推荐的我吗？</span><br><span class="line">青木：是的呢。山田桑去过上海分公司，对中国的事情也很了解。</span><br><span class="line">山田：我知道了。和中国有关系的工作，请一定要让我试试。</span><br></pre></td></tr></table></figure><h3 id="课文-3"><a href="#课文-3" class="headerlink" title="课文"></a>课文</h3><p>さらに，フレックスタイム制度を導入する会社も増えています。これは，自分の出勤と退勤の時間を自由に決められる制度です。労働者が自分の生活と仕事のバランスを取りながら，働くことができるように設けられました。</p><blockquote><p>另外，引入弹性时间制度的公司也增加了不少。这是项可以自己自由决定上班和下班时间的制度。这个是为劳动者既能平衡自己的生活和工作，也能工作所设计的。</p></blockquote><h1 id="単元-1"><a href="#単元-1" class="headerlink" title="単元"></a>単元</h1><h2 id="第５課"><a href="#第５課" class="headerlink" title="第５課"></a>第５課</h2><h3 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h3><h4 id="转换话题"><a href="#转换话题" class="headerlink" title="转换话题"></a>转换话题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ところで　         话说回来</span><br><span class="line">話しが変わりますが　说点别的</span><br><span class="line">さて　             那么</span><br><span class="line">それで　           然后</span><br><span class="line">けれども/でも　     不过/但是</span><br><span class="line">それでは/では　     那么（转换下一个话题）</span><br><span class="line">それはそうと　      先不说这个</span><br></pre></td></tr></table></figure><h4 id="～を～にして-以……为……"><a href="#～を～にして-以……为……" class="headerlink" title="～を～にして　以……为……"></a>～を～にして　以……为……</h4><ol><li>～をきっかけにして 以……为契机</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：コンテストで最高賞を受賞したのをきっかけにして，売れるようになりました。</span><br><span class="line">译：再一次竞赛后得到最高奖为契机，变得开始畅销。</span><br></pre></td></tr></table></figure><ol start="2"><li>～を手がかりにして 以……为线索</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：犯人が残したナイフを手がかりにして，事件を解決した。</span><br><span class="line">译：以犯人留下的小刀为线索，将事件解决了。</span><br></pre></td></tr></table></figure><ol start="3"><li>～を頼りにして　根据……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：李さんが書いてくれた地図を頼りにして，美術館を探した。</span><br><span class="line">译：我根据李桑画的地图找到了美术馆。</span><br></pre></td></tr></table></figure><h4 id="～ということからきた～-～に由来した～-由此而来的，源于"><a href="#～ということからきた～-～に由来した～-由此而来的，源于" class="headerlink" title="～ということからきた～/～に由来した～　由此而来的，源于"></a>～ということからきた～/～に由来した～　由此而来的，源于</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：相撲でぐらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。</span><br><span class="line">译：相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。</span><br><span class="line"></span><br><span class="line">例：『天ぷら』はボルトガル語の”tempera”に由来した言葉です。</span><br><span class="line">译：『天妇罗』的由来时葡萄牙语的“tempera”一词。</span><br></pre></td></tr></table></figure><h4 id="～のは間違いない-一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用"><a href="#～のは間違いない-一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用" class="headerlink" title="～のは間違いない　一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用"></a>～のは間違いない　一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：中国の体操選手がオリンピックで優勝するのは間違いない。</span><br><span class="line">译：中国的体操选手一定会在奥林匹克上获胜。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：～に違いない/～に相違ない（书面） 能和 <strong>きっと 多分</strong> 这样的词语一起使用 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：このガイドブックは内容が豊富で面白い。きっと売れるに違いない。</span><br><span class="line">译：这本指南的内容丰富有趣。一定买的很好。</span><br><span class="line"></span><br><span class="line">例：彼は十分な休みを取っていなかったに相違ない。</span><br><span class="line">译：他一定没有得到充分的休息。</span><br></pre></td></tr></table></figure><h4 id="～という点から-で-从……方面来"><a href="#～という点から-で-从……方面来" class="headerlink" title="～という点から/で　从……方面来"></a>～という点から/で　从……方面来</h4><ol><li>という点から分類する　从……方面来分类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語の単語を，元の言葉は何かという点から分類すると，……</span><br><span class="line">译：日语的单词是以它原来的语言是什么这一点来分类的。</span><br></pre></td></tr></table></figure><ol start="2"><li>という点から判断する 从……方面来判断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いろいろな証拠という点から判断するんですが，彼は犯人です。</span><br><span class="line">译：各种各样的证据判断出，他是犯人。</span><br></pre></td></tr></table></figure><ol start="3"><li>という点で　依据……性质来判断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：遅くまで開いているという点で，あの店は便利です。</span><br><span class="line">译：营业到很晚这一点来看，那家店很便利。</span><br></pre></td></tr></table></figure><h4 id="～を中心とした～-以……为中心"><a href="#～を中心とした～-以……为中心" class="headerlink" title="～を中心とした～　以……为中心"></a>～を中心とした～　以……为中心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉だ。</span><br><span class="line">译：外来语主要是19世纪以后，以西洋为中心的外国引进的语言。</span><br></pre></td></tr></table></figure><h4 id="AをBという-呼ぶ（书面）-把A叫做B"><a href="#AをBという-呼ぶ（书面）-把A叫做B" class="headerlink" title="AをBという/呼ぶ（书面）　把A叫做B"></a>AをBという/呼ぶ（书面）　把A叫做B</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。</span><br><span class="line">译：另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。</span><br></pre></td></tr></table></figure><h4 id="名词＋の-形容动词-な-简体＋ような（名词）-ように（动词）-像是……，类似……"><a href="#名词＋の-形容动词-な-简体＋ような（名词）-ように（动词）-像是……，类似……" class="headerlink" title="名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……"></a>名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：東京のような大都市では，家賃が高くて大変だ。</span><br><span class="line">译：像东京这样的大城市，房租太高了太不容易了。</span><br><span class="line"></span><br><span class="line">例：鳥が飛ぶように空を飛んでみたい。</span><br><span class="line">译：想像鸟一样在空中飞行。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><blockquote><p>～という/いったよう＋な/に　列举多个例子时使用，いった有<strong>没有列举完</strong>的语气，といったような可以省略为といった</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：エビ，イカ，卵といったようなコレステロの高い食品は避けた穂がいい。</span><br><span class="line">译：避免高胆固醇食物，如虾、鱿鱼和鸡蛋。</span><br><span class="line"></span><br><span class="line">例：テレビ，冷蔵庫，布団というように，一人暮らしで必要な物を買った。</span><br><span class="line">译：我买了一个人生活必需的东西，比如电视、冰箱和被褥。</span><br></pre></td></tr></table></figure><blockquote><p>～というふうな/に　用于列举多个具体事例，陈述处理办法或顺序，略显口语</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：北京，上海，広州というふうに，中国の大きな都市を順番に訪問した。</span><br><span class="line">译：我们依次参观了中国的大城市，如北京、上海和广州。</span><br></pre></td></tr></table></figure><h4 id="～に受ける-受欢迎"><a href="#～に受ける-受欢迎" class="headerlink" title="～に受ける　受欢迎"></a>～に受ける　受欢迎</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『金星』という名前は，中国人にうけるでしょう。</span><br><span class="line">译：金星这个名字，中国人会喜欢吧？</span><br></pre></td></tr></table></figure><h4 id="～に基づいた～-以……为根据"><a href="#～に基づいた～-以……为根据" class="headerlink" title="～に基づいた～　以……为根据"></a>～に基づいた～　以……为根据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：音読みとは，昔の中国語の発音に基づいた読み方だ。</span><br><span class="line">译：音读是指以以前中文的发音为根据的读法。</span><br></pre></td></tr></table></figure><h4 id="うち-在……当中"><a href="#うち-在……当中" class="headerlink" title="~うち　在……当中"></a>~うち　在……当中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：若いうち</span><br><span class="line">译：趁着年轻</span><br><span class="line"></span><br><span class="line">例：参加者のうち，賞品がもらえるのは３位までだ。</span><br><span class="line">译：参加人中，能得到奖品的只有三位。</span><br></pre></td></tr></table></figure><h3 id="会话-2"><a href="#会话-2" class="headerlink" title="会话"></a>会话</h3><ul><li>佐藤：ええ，『金星』は星の名前ですが，『金星』というのは，『すばらしい働きをすること』を表します。相撲でくらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">佐藤：『金星』是指星星的名字，这里的金星是指，有着出色工作表现的意思。相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。</span><br></pre></td></tr></table></figure><h3 id="课文-4"><a href="#课文-4" class="headerlink" title="课文"></a>课文</h3><p>日本の単語を，元の言葉は何かという点から分類すると，和語，漢語，外来語，混種語の４つに分かることができる。和語はもともと日本語にあった言葉で，漢語は中国から取り入れられた言葉だ。<br>漢語は『音読み』する。音読みとは，昔の中国の発音に基いた読み方だ。外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉で，普通片仮名でかく。<br>さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。『消しゴム』や『マラソン大会』『正月休み』などの言葉だ。</p><blockquote><p>日语的单词是以它原来的语言是什么这一点来分类的。可以分为和语、汉语、外来语、混合语四种。和语是最早日语就有的语言，汉语是从中国引入的语言。<br>汉语是音读。所谓的音读是指以以前中文的发音为根据的读法。外来语主要是19世纪以后，以西洋为中心的外国引进的语言，用普通片假名书写。<br>另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。诸如“橡皮擦”、“马拉松比赛”和“新年假期”之类的词。</p></blockquote><h2 id="第６課"><a href="#第６課" class="headerlink" title="第６課"></a>第６課</h2><h3 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h3><h4 id="～ちゃって-～じゃって-是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。"><a href="#～ちゃって-～じゃって-是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。" class="headerlink" title="～ちゃって/～じゃって　是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。"></a>～ちゃって/～じゃって　是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">食べてしまう　ー＞　食べちゃう　ー＞　食べちゃって</span><br><span class="line">飲んでしまう　ー＞　飲んでじゃう　ー＞　飲んでじゃって</span><br><span class="line"></span><br><span class="line">例：打ち合わせが長引いちゃって。</span><br><span class="line">译：会议拖了很长时间。</span><br></pre></td></tr></table></figure><h4 id="気になる-一直想着……-对某人有意思"><a href="#気になる-一直想着……-对某人有意思" class="headerlink" title="気になる 一直想着…… 对某人有意思"></a>気になる 一直想着…… 对某人有意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そんなことを聞くということは，佐藤さん，李さんのことが気になるのかしら。</span><br><span class="line">译：听到这样的话，佐藤桑，你是不是对李桑有意思呀。</span><br></pre></td></tr></table></figure><h4 id="～による-よって-根据……"><a href="#～による-よって-根据……" class="headerlink" title="～による/よって　根据……"></a>～による/よって　根据……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『はし』といっても，その形や材料は国や地域によって違う。</span><br><span class="line">译：虽说都是筷子，它的形态和材料会因为国家和地区而不同。</span><br></pre></td></tr></table></figure><h4 id="簡体＋といっても-虽说……"><a href="#簡体＋といっても-虽说……" class="headerlink" title="簡体＋といっても 虽说……"></a>簡体＋といっても 虽说……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：英語できないといっても，日常会話は十分にできる。</span><br><span class="line">译：虽说英语不行，但是日常对话应该够了。</span><br></pre></td></tr></table></figure><h4 id="簡体／名詞の＋ほか，～も-除了……之外，也……"><a href="#簡体／名詞の＋ほか，～も-除了……之外，也……" class="headerlink" title="簡体／名詞の＋ほか，～も 除了……之外，也……"></a>簡体／名詞の＋ほか，～も 除了……之外，也……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：材料は木や竹，プラスチックのほか，玉や金属の物もある。</span><br><span class="line">译：材料是木头或竹子，除了塑料以外，也有玉和金属的。</span><br></pre></td></tr></table></figure><h4 id="～をしている-状态的表示方法"><a href="#～をしている-状态的表示方法" class="headerlink" title="～をしている 状态的表示方法"></a>～をしている 状态的表示方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：韓国の箸は中国より少し短く，やや平らな形をしている。</span><br><span class="line">译：韩国的筷子比中国的短了一些，也要扁平一些。</span><br></pre></td></tr></table></figure><h4 id="～とされる-和-と考えられている-意思一样：被认为是……"><a href="#～とされる-和-と考えられている-意思一样：被认为是……" class="headerlink" title="～とされる 和 と考えられている 意思一样：被认为是……"></a>～とされる 和 と考えられている 意思一样：被认为是……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本では２月１４日のバレンタインデーは，女性が男性にチョコレートを贈る日だとされる。</span><br><span class="line">译：在日本2月14日情人节被认为是女性向男性赠送巧克力的日子。</span><br></pre></td></tr></table></figure><h4 id="面倒を見る-照顾"><a href="#面倒を見る-照顾" class="headerlink" title="面倒を見る　照顾"></a>面倒を見る　照顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：部下の面倒をよくみるし。</span><br><span class="line">译：很照顾自己的下属。</span><br></pre></td></tr></table></figure><h3 id="会话-3"><a href="#会话-3" class="headerlink" title="会话"></a>会话</h3><ul><li>中井さん：うん。明るくて，仕事熱心な人だっていったよ。部下の面倒をよく見るし，優しいし，まさに理想的な上司です。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中井桑：是的。人很开朗，对工作也很热心的人呢。对下属也很照顾，人也温柔，简直是理想的上司呢。</span><br></pre></td></tr></table></figure><h3 id="课文-5"><a href="#课文-5" class="headerlink" title="课文"></a>课文</h3><p>『はし』といっても，その形や材料は国や地域によって違う。中国の箸は長くて，先端が丸太さがあまり変わらない。材料は木や竹，プラスチックのほか，玉や金属の物もある。<br>韓国の箸は中国より少し短く，やや平らな形をしている。ステンレスなど，金属の物が一般的だ。<br>日本の箸は韓国の物に比べてさらに短く，先のほうは細くなっていて，尖っている。材質は木や竹が多く，漆が塗られていることがある。</p><blockquote><p>虽说都是筷子，它的形态和材料会因为国家和地区而不同。中国的筷子比较长，筷子前端的圆度没怎么变化。材料是木头或竹子，除了塑料以外，也有玉和金属的。<br>韩国的筷子比中国的短了一些，也要扁平一些。一般是不锈钢之类的金属。<br>日本的筷子相比韩国要短一些，前者很细很尖。材质大多数是木头或竹子，也有在表面涂漆的。</p></blockquote><h2 id="第７課"><a href="#第７課" class="headerlink" title="第７課"></a>第７課</h2><h3 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h3><h4 id="簡体＋参考にする-参考になる-把……作为参考-有参考价值"><a href="#簡体＋参考にする-参考になる-把……作为参考-有参考价值" class="headerlink" title="簡体＋参考にする/参考になる 把……作为参考/有参考价值"></a>簡体＋参考にする/参考になる 把……作为参考/有参考价值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：『燕醸造のCMを参考にする』と書いてあるけど，これはどいう意味？</span><br><span class="line">译：上面写着『燕牌啤酒的广告有参考价值』，这是什么意思呢？</span><br><span class="line"></span><br><span class="line">例：このCMは，きっと参考になるだろうと思います。</span><br><span class="line">译：这个广告一定有参考价值。</span><br></pre></td></tr></table></figure><h4 id="名詞の＋うえで-这……方面"><a href="#名詞の＋うえで-这……方面" class="headerlink" title="名詞の＋うえで 这……方面"></a>名詞の＋うえで 这……方面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ただし，仕事のうえでのメールや目上の人に送る場合は，いくつか気をつけなければならないことがある。</span><br><span class="line">译：然而工作上的邮件和发送给上级的场合下，有一些必须注意事项。</span><br></pre></td></tr></table></figure><h4 id="名词-さえ～ば，～-只要……就……"><a href="#名词-さえ～ば，～-只要……就……" class="headerlink" title="名词+さえ～ば，～ 只要……就……"></a>名词+さえ～ば，～ 只要……就……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お金と時間さえあれば，毎日演劇を見に行きたい。</span><br><span class="line">译：只要有钱和时间，每天都想去剧院。</span><br></pre></td></tr></table></figure><h4 id="～などという-这……之类的"><a href="#～などという-这……之类的" class="headerlink" title="～などという 这……之类的"></a>～などという 这……之类的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『こんにちは』『はじめまして』などという，メールの内容の分からない表現は避ける。</span><br><span class="line">译：邮件内容要避免『你好』『初次见面』之类的无法理解内容的表达方式。</span><br></pre></td></tr></table></figure><h4 id="～ごとに-表示每隔……（间隔）"><a href="#～ごとに-表示每隔……（间隔）" class="headerlink" title="～ごとに　表示每隔……（间隔）"></a>～ごとに　表示每隔……（间隔）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：１年ごとに，売り上げの目標作って，営業活動を頑張った。</span><br><span class="line">译：每年都会指定销售目标，努力开展营业活动。</span><br></pre></td></tr></table></figure><h3 id="课文-6"><a href="#课文-6" class="headerlink" title="课文"></a>课文</h3><p>件名を描く時は，用件を明確にする</p><p>宛て先と自分の名前を忘れずに入れる</p><p>用件は簡潔にする</p><p>最後に署名を入れる</p><blockquote><p>描述主题时，用词要明确<br>不要忘记写收件人和自己的名字<br>用词要简洁<br>最后要署上你的名字</p></blockquote><h2 id="第８課"><a href="#第８課" class="headerlink" title="第８課"></a>第８課</h2><h3 id="文法-7"><a href="#文法-7" class="headerlink" title="文法"></a>文法</h3><h4 id="だけ-仅仅"><a href="#だけ-仅仅" class="headerlink" title="だけ　仅仅"></a>だけ　仅仅</h4><ol><li>だけで　少量的事情或者事物就能引发后项结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと見ただけで，本物だとわかります。</span><br><span class="line">译：仅仅只是看了一眼，就知道是真的。</span><br></pre></td></tr></table></figure><ol start="2"><li>だけだ／だけではない　仅此/不仅</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そのだけです。</span><br><span class="line">译：仅此而已。</span><br><span class="line"></span><br><span class="line">例：中井さんは事件あった場所を知っているだけだ。</span><br><span class="line">译：田中桑仅仅只是知道发生时间的场所。</span><br></pre></td></tr></table></figure><ol start="3"><li>だけではすまない／だけですむ　仅仅这样是不行的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：課長に報告したら，注意されるだけではさまない。</span><br><span class="line">译：向课长报告的话，仅仅是注意是不行的。</span><br></pre></td></tr></table></figure><h4 id="～代わりに／～かわって／～に代わる-……被代替……"><a href="#～代わりに／～かわって／～に代わる-……被代替……" class="headerlink" title="～代わりに／～かわって／～に代わる　……被代替……"></a>～代わりに／～かわって／～に代わる　……被代替……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：相手は丼を使う代わりに紙コップを使い，その中に砕いたインスタントラーメンを入れる，お湯を注いで，食べ始めた。</span><br><span class="line">译：对方使用纸杯代替碗，在纸杯中放入碎的方便面，再放入开水，就可以开始吃了。</span><br><span class="line"></span><br><span class="line">例：手紙の代わりに電子メールをうちます。</span><br><span class="line">译：发送电子邮件代替信件。</span><br><span class="line"></span><br><span class="line">例：父に代わって長男がご挨拶に伺います。</span><br><span class="line">译：长子代替父亲前来问候。</span><br><span class="line"></span><br><span class="line">例：丼に代わる新しい容器が必要だ。</span><br><span class="line">译：使用新容器代替是有必要的。</span><br></pre></td></tr></table></figure><h4 id="～（ら）れるようにしなければいけない-努力做到"><a href="#～（ら）れるようにしなければいけない-努力做到" class="headerlink" title="～（ら）れるようにしなければいけない　努力做到"></a>～（ら）れるようにしなければいけない　努力做到</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：免許証はいつでも見せられるようにしなければいけない。</span><br><span class="line">译：驾照无论何时都需要能看到。</span><br></pre></td></tr></table></figure><h4 id="～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果"><a href="#～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果" class="headerlink" title="～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果"></a>～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：何度も失敗した末に，ようやく開発に成功した。</span><br><span class="line">译：经历无数次失败，最终成功开发出来。</span><br><span class="line"></span><br><span class="line">例：苦労したあげく，結局失敗した。</span><br><span class="line">译：辛苦的工作到最后还是失败了。</span><br></pre></td></tr></table></figure><h3 id="会話"><a href="#会話" class="headerlink" title="会話"></a>会話</h3><ul><li>王：はい。商品のPRだけじゃなくて，日本の文化を紹介するコーナーを作ってはどうかと考えています。日本の食べ物とか若者の意識とかを紹介するのも面白いとおもいます。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">王：是的。这不仅是商品的提案，我想做一个介绍日本文化的栏目。介绍日本的饮食什么的，年轻人的想法什么的都很有趣。</span><br></pre></td></tr></table></figure><h3 id="课文-7"><a href="#课文-7" class="headerlink" title="课文"></a>课文</h3><p>しかし，開発は簡単ではなかった。容器の材料は，ガラス，紙，プラスチック，金属，当時考えられるだけの物が集められた。様々な工夫のすえ，『発泡スチロール』が採用された。容器の形についても試作が繰り返された。片手を持てて，手から滑り落ちない形を理想として，現在の形が生まれた。</p><blockquote><p>然而，开发不是这么简单的。容器的材料有不锈钢、纸、塑料、金属，这些都是当时能想到的汇聚起来的东西。通过各种各样的方式方法，最终采用了泡沫塑料。关于容器的形状也多次尝试制作。以单手就能拿起，不容易从手中滑落为理想，诞生了现在的形状。</p></blockquote><h1 id="単元-2"><a href="#単元-2" class="headerlink" title="単元"></a>単元</h1><h2 id="第９課"><a href="#第９課" class="headerlink" title="第９課"></a>第９課</h2><h3 id="文法-8"><a href="#文法-8" class="headerlink" title="文法"></a>文法</h3><h4 id="自动词-てある-人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态"><a href="#自动词-てある-人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态" class="headerlink" title="自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态"></a>自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：「王風」という名札が付けてあります。</span><br><span class="line">译：上面挂有【王风】名字的牌子。</span><br><span class="line"></span><br><span class="line">例：玄関の電気がつけてあります。</span><br><span class="line">译：玄关的灯开着。</span><br></pre></td></tr></table></figure><h4 id="他动词-ている-自然状态持续着"><a href="#他动词-ている-自然状态持续着" class="headerlink" title="他动词 + ている 自然状态持续着"></a>他动词 + ている 自然状态持续着</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：窓が開けています。</span><br><span class="line">译：窗户开着。</span><br><span class="line"></span><br><span class="line">例：窓が開けてあります。</span><br><span class="line">译：窗户打开着。</span><br></pre></td></tr></table></figure><h4 id="自动词-ておく-有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。"><a href="#自动词-ておく-有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。" class="headerlink" title="自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。"></a>自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：ファイルは机の上に置いておきます。</span><br><span class="line">译：我把文件反正桌子上。</span><br><span class="line"></span><br><span class="line">例：朝起きられるように、時計を6時にセットしておく。</span><br><span class="line">译：为了能早起，我定了6点的闹钟。</span><br></pre></td></tr></table></figure><h4 id="名词-どおり-与～一样；按照～那样；预想；预计"><a href="#名词-どおり-与～一样；按照～那样；预想；预计" class="headerlink" title="名词 + どおり 与～一样；按照～那样；预想；预计"></a>名词 + どおり 与～一样；按照～那样；预想；预计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：予定通り17時30分に到着いたしましたが…</span><br><span class="line">译：和预计的一样17点30分到达了……</span><br><span class="line"></span><br><span class="line">例：田中さんは、希望通り大学院に進学しました。</span><br><span class="line">译：田中如愿升入研究生院。</span><br></pre></td></tr></table></figure><h4 id="後ほど；後（のち）で；あとで-前者更有礼貌"><a href="#後ほど；後（のち）で；あとで-前者更有礼貌" class="headerlink" title="後ほど；後（のち）で；あとで 前者更有礼貌"></a>後ほど；後（のち）で；あとで 前者更有礼貌</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：後ほど，お泊まりのホテルに届けいたします。</span><br><span class="line">译：稍后送到您住宿的酒店。</span><br><span class="line"></span><br><span class="line">例：詳細については後ほどご報告いたします。</span><br><span class="line">译：详细情况稍后汇报给您。</span><br></pre></td></tr></table></figure><blockquote><p>另外还有 先ほど</p></blockquote><h3 id="会话-4"><a href="#会话-4" class="headerlink" title="会话"></a>会话</h3><ul><li><p>王さん：ちょっと，いたい，いつまでも待ってばいいんですか。もう６時半ですよ。</p></li><li><p>手荷物係：申し訳ございません。ただ今お調べしております。もう少しお待ちいただけませんか。</p></li><li><p>王さん：そんな，困りますよ。ロビーで同僚が待っているんです。早くしてもらえませんか。</p></li><li><p>手荷物係：本当に申し訳ございません。後ほど，お泊まりのホテルに届けいたします。よろしいでしょうか。</p></li><li><p>王さん：仕方ないですね。できるだけ早く届けてくださいよ。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">王桑：喂，究竟要让我等到多久才好呀？已经6点半了呀！</span><br><span class="line">行李员：真的十分抱歉！但是现在还在调查中，请在稍等一下可以吗？</span><br><span class="line"></span><br><span class="line">王桑：怎么会这样，太麻烦了。前厅还有同事在等着我。能尽快找到还给我吗？</span><br><span class="line">行李员：真的非常抱歉，稍后送到您住宿的酒店，这样您觉得可以吗？</span><br><span class="line"></span><br><span class="line">王桑：只好这样了。快点送过来呀！</span><br></pre></td></tr></table></figure><h3 id="课文-8"><a href="#课文-8" class="headerlink" title="课文"></a>课文</h3><p>4月1日17時20分，憧れのローマに到着。荷物を受け取って，入国。旅行社の人が迎えに来ているはずだが，見つからない。もし来なかったらと思い，不安になった時，背の高い男性が，にこにこしながら近付いてきて何か言う。誰かと思ったら，我々を迎えに来たガイドさんだった。</p><blockquote><p>4月1日17点20分，憧憬的罗马到了。取到了托运的行李，入国。因该有旅行社的人来接我们，但是没有看见。正在想着如果没有来的话怎么办，感到不安的时候，有个背高高的男性笑眯眯的走过来说着什么。我正在想着这是谁，原来是来迎接我们的导游。</p></blockquote><h2 id="第１０課"><a href="#第１０課" class="headerlink" title="第１０課"></a>第１０課</h2><h3 id="文法-9"><a href="#文法-9" class="headerlink" title="文法"></a>文法</h3><h4 id="よう（更为正式）／ように-目的，为了……"><a href="#よう（更为正式）／ように-目的，为了……" class="headerlink" title="よう（更为正式）／ように　目的，为了……"></a>よう（更为正式）／ように　目的，为了……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：できるだけたくさんの取材ができるよう予定を立てました。</span><br><span class="line">译：为了尽可能多的采访，我们定了这样的行程。</span><br><span class="line"></span><br><span class="line">例：早く病気がなおるよう、安静にしていた。</span><br><span class="line">译：为了病能早点好，静养了一段时间。</span><br></pre></td></tr></table></figure><h4 id="～による／よって"><a href="#～による／よって" class="headerlink" title="～による／よって"></a>～による／よって</h4><h5 id="被动中提示动作的主体"><a href="#被动中提示动作的主体" class="headerlink" title="被动中提示动作的主体."></a>被动中提示动作的主体.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このレストランは，有名なデザイナーによって設計された。</span><br><span class="line">译：这个饭店是有名的设计师设计的。</span><br></pre></td></tr></table></figure><h5 id="根据，依据"><a href="#根据，依据" class="headerlink" title="根据，依据"></a>根据，依据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：林さんが行くかどうかによって，私もどうするかきめます。</span><br><span class="line">译：小林去不去决定了我怎么完成。</span><br></pre></td></tr></table></figure><h5 id="方式，方法"><a href="#方式，方法" class="headerlink" title="方式，方法"></a>方式，方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この薬の効果は，多くの実験によって確認されている。</span><br><span class="line">译：这个药的效果是经过了多次实验才确认的。</span><br></pre></td></tr></table></figure><h4 id="～になります-代替です／だ，语气更加的含蓄，委婉。"><a href="#～になります-代替です／だ，语气更加的含蓄，委婉。" class="headerlink" title="～になります　代替です／だ，语气更加的含蓄，委婉。"></a>～になります　代替です／だ，语气更加的含蓄，委婉。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お１人様１６０００円になりますが，よろしいですか。</span><br><span class="line">译：一个人16000日元，您觉得可以吗？</span><br></pre></td></tr></table></figure><h3 id="课文-9"><a href="#课文-9" class="headerlink" title="课文"></a>课文</h3><p>温泉地では，お客を集めるための工夫をしている。例えば，宿泊する人以外がホテルや旅館の入浴施設を有料で使用できる「日帰り温泉」がある。<br>「入浴＋昼ご飯」や，「入浴＋部屋で休憩」など，宿泊する時間のない人のためにさまざまなプランもある。最近では「日帰り入浴」専用の施設も増えてきている。</p><p>また銭湯といって，安い値段で入浴できる施設もある。銭湯とは，多くの家にお風呂がなかったころに作られた入浴施設のことだ。現在ではその数も少なくなってきているが，最近では，「スーパー銭湯」が出てきて人気を集めている。普通の銭湯より値段は高いが，いろいろな種類のお風呂やマッサージ，エステなどがあり，1日中たのしめる。「スーパー銭湯」は忙しい人たちのちょっとした癒しの場になっているのだ。</p><blockquote><p>泡温泉的地方为了能揽客下了很大的功夫。比如，有住宿以外的人可以通过付费使用旅馆的入浴设施【日归温泉】。还有【温泉+晚饭】和【温泉+房间休息】等等，没有住宿时间的人也有各种各样的方案。最近【日归温泉】专用设置也增加了许多。</p></blockquote><blockquote><p>另外还有钱汤，价格实惠的洗浴设施也有。所谓钱汤是指，以前许多家里没有可以泡温泉的地方，而建立的公用洗浴设施。现在这样的设施在慢慢减少，最近出现了很有人气的超级钱汤。比普通的钱汤价格稍微贵一点，但是有各种各样的种类，洗浴，按摩以及美容，可以享受一整天。超级钱汤正在成为给那些忙碌人难得消除身心疲惫的场所。</p></blockquote><h2 id="第１１課"><a href="#第１１課" class="headerlink" title="第１１課"></a>第１１課</h2><h3 id="文法-10"><a href="#文法-10" class="headerlink" title="文法"></a>文法</h3><h4 id="避免断定的说法"><a href="#避免断定的说法" class="headerlink" title="避免断定的说法"></a>避免断定的说法</h4><ul><li>难道不是吗？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">书面语：</span><br><span class="line"></span><br><span class="line">ではないか</span><br><span class="line">ではないだろうか</span><br><span class="line">ではないでしょうか。</span><br><span class="line"></span><br><span class="line">口语：</span><br><span class="line"></span><br><span class="line">ではありませんか</span><br><span class="line">ではないですか</span><br><span class="line">じゃありませんか</span><br><span class="line">じゃないですか</span><br><span class="line">じゃないか</span><br></pre></td></tr></table></figure><ul><li>～きがする　好像，对过去的某事尽管记忆模糊，但是认为是那样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：その時は，賛成した気がします。</span><br><span class="line">译：那个时候我好像是赞成的。</span><br></pre></td></tr></table></figure><ul><li>～と思う／～と思える／～と思われる　认为，～と思える／～と思われる 有自然而然地这样认为，而非专断的意见</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：彼女の言っていることは事実だと思う。</span><br><span class="line">译：我觉得她说的话是事实。</span><br><span class="line"></span><br><span class="line">例：私はこの方針が正しいと思えません。</span><br><span class="line">译：我不觉得这个方针是正确的。</span><br></pre></td></tr></table></figure><h4 id="～はずです-应该是……，基于推论或记忆认为理所应当成立的事情"><a href="#～はずです-应该是……，基于推论或记忆认为理所应当成立的事情" class="headerlink" title="～はずです　应该是……，基于推论或记忆认为理所应当成立的事情"></a>～はずです　应该是……，基于推论或记忆认为理所应当成立的事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は今年定年のはずです。</span><br><span class="line">译：他今年应该退休了。</span><br></pre></td></tr></table></figure><h4 id="～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。"><a href="#～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。" class="headerlink" title="～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。"></a>～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あの雲の様子から見て，明日は雨のようだ。</span><br><span class="line">译：从那个云的样子来看，明天可能要下雨。</span><br><span class="line"></span><br><span class="line">例：天気予報によると，今年の冬は暖かいらしい。</span><br><span class="line">译：天气预报说今年冬天可能会比较暖和。</span><br></pre></td></tr></table></figure><h4 id="～のところ-……的时刻，有包含这个的后续可能会发生某种变化的语气"><a href="#～のところ-……的时刻，有包含这个的后续可能会发生某种变化的语气" class="headerlink" title="～のところ　……的时刻，有包含这个的后续可能会发生某种变化的语气"></a>～のところ　……的时刻，有包含这个的后续可能会发生某种变化的语气</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：興行成績は現在のところ第２位ですが，来週はトップになる見込みです。</span><br><span class="line">译：票房成绩目前还是第二名，但下周有可能登顶。</span><br></pre></td></tr></table></figure><h4 id="～見込みです-很可能，有希望的意思"><a href="#～見込みです-很可能，有希望的意思" class="headerlink" title="～見込みです　很可能，有希望的意思"></a>～見込みです　很可能，有希望的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：来年の業績はかなり良い見込みです。</span><br><span class="line">译：明年的业已有希望相当好。</span><br></pre></td></tr></table></figure><h4 id="形容词去掉い＋まる（自动词：变得）／める（他动词：使……）-古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语"><a href="#形容词去掉い＋まる（自动词：变得）／める（他动词：使……）-古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语" class="headerlink" title="形容词去掉い＋まる（自动词：变得）／める（他动词：使……）　古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语"></a>形容词去掉い＋まる（自动词：变得）／める（他动词：使……）　古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そうそう，日本映画の人気も高まっていますよ。</span><br><span class="line">译：是的呢，日本电影的人气也变得很高。</span><br><span class="line"></span><br><span class="line">例：社員一人一人の節約の意識を，もう少し高めないといけない。</span><br><span class="line">译：必须提高每个社员的节约意识。</span><br></pre></td></tr></table></figure><h4 id="～に夢中になる-被什么东西吸引而聚精会神投入其中的状态"><a href="#～に夢中になる-被什么东西吸引而聚精会神投入其中的状态" class="headerlink" title="～に夢中になる　被什么东西吸引而聚精会神投入其中的状态"></a>～に夢中になる　被什么东西吸引而聚精会神投入其中的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：昔の子供は学校が終われると，外で遊ぶに夢中になったものです。</span><br><span class="line">译：以前的小孩放学后，会沉迷在外面玩。</span><br></pre></td></tr></table></figure><blockquote><p>知识拓展</p></blockquote><ul><li>夢中になって 专心致志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。</span><br><span class="line">译：来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。</span><br></pre></td></tr></table></figure><ul><li>夢中で/夢中だ　拼命的做</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：田中さんは今日仕事に夢中だから，しばらく結婚はしないでしょう。</span><br><span class="line">译：看田中桑今天拼命的工作，最近一段时间应该不会结婚吧？</span><br><span class="line"></span><br><span class="line">例：大きな犬に追いかけられて，夢中で逃げだ。</span><br><span class="line">译：被大型犬着，拼命地逃跑。</span><br></pre></td></tr></table></figure><h4 id="～うえに，～-不仅……而且……"><a href="#～うえに，～-不仅……而且……" class="headerlink" title="～うえに，～　不仅……而且……"></a>～うえに，～　不仅……而且……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日は気温が低いうえに，風が強いので，とても寒く感じる。</span><br><span class="line">译：今天不仅气温低风也很大，感觉非常冷啊。</span><br></pre></td></tr></table></figure><h4 id="～とともに，～-随着前向的变化，后向也因此伴随着变化，也有同时进行的意思"><a href="#～とともに，～-随着前向的变化，后向也因此伴随着变化，也有同时进行的意思" class="headerlink" title="～とともに，～　随着前向的变化，后向也因此伴随着变化，也有同时进行的意思"></a>～とともに，～　随着前向的变化，后向也因此伴随着变化，也有同时进行的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：その後，デジタル技術の開発が進むとともに，高画質のいきいきとした映像が生み出されるようになった。</span><br><span class="line">译：之后，随着数字技术的开发，产生了高画质的生动影像。</span><br><span class="line"></span><br><span class="line">例：原因を調査するとともに，再発を防ぐための努力もしていかなければならない。</span><br><span class="line">译：随着原因的调查，为了防止再次发生而不得不努力。</span><br></pre></td></tr></table></figure><h3 id="会話-1"><a href="#会話-1" class="headerlink" title="会話"></a>会話</h3><ul><li><p>担当者：ええ，若者は日本のものと外国のものを区別していないような気がします。彼らは，映画にしても音楽にしても，いいものならすぐに受け入れます。</p></li><li><p>王：そうですね。中国の若者も同じだという気がします。じゃあ，彼らの心をつかむには，どうすればいいんでしょうか。</p></li><li><p>担当者：うーん…，難しい質問ですね。やはり本当にいいものを作ることではないでしょうか。</p></li><li><p>王：本当にいいもの，ですか？</p></li><li><p>担当者：ええ。今の若者は，テレビCMより，同時代の人の口コミを信じます。映像でも音楽でも，本当にいいものを提供すれば，口コミで広がっていくはずです。</p></li><li><p>王：なるほど。ありがとうございます。とても参考になりました。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">担当者：是的，我觉得年轻人好像没有区分日本的东西和外国的东西。他们不管是电影还是音乐，只要是觉得好的马上就会接受。</span><br><span class="line">王：是这样呢，中国的年轻人好像也是这样。那么怎么做才能抓住他们的心呢？</span><br><span class="line"></span><br><span class="line">担当者：嗯，很难得问题呀。果然还是要真正做出好的东西对吧？</span><br><span class="line">王：真的好的东西，是吗？</span><br><span class="line"></span><br><span class="line">担当者：是的。现今的年轻人比起电视频道更相信同龄人的口碑。不管是电影还是音乐，提供真正好的东西的话，口碑应该也会越来越好。</span><br><span class="line">王：原来如此，谢谢。非常有参考价值。</span><br></pre></td></tr></table></figure><h3 id="课文-10"><a href="#课文-10" class="headerlink" title="课文"></a>课文</h3><p>日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。日本の漫画は，子供向けから成人向けまで，対象の年代ごとにさまざまな種類がある。</p><p>会社員の生活や，経済に関するものなど，大人にしか楽しめない内容の漫画が多くある。一方，子供向けの漫画でも，大人が楽しめるものも多い。近年，中国では「クレヨンしんちゃん」「ドラえもん」「ちびまる子ちゃん」などの漫画が子供だけでなく大人からも人気を集めている。</p><blockquote><p>来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。日本的漫画从孩子到成人，会因为看漫画对象的年代不同有着各种各样的分类。</p></blockquote><blockquote><p>公司职员的生活或者经济相关的漫画等等，有很多精彩的内容只有大人才能看的漫画有很多。另一方面，也有很多小孩子和大人都能看得的漫画。近几年，在中国像【蜡笔小新】、【哆啦A梦】【樱桃小丸子】等等这样的漫画不仅小孩子喜欢，也很受大人们的欢迎。</p></blockquote><h2 id="第１２課"><a href="#第１２課" class="headerlink" title="第１２課"></a>第１２課</h2><h3 id="文法-11"><a href="#文法-11" class="headerlink" title="文法"></a>文法</h3><h4 id="耳にする／目にする-表示没主动去看听，而是被动传入"><a href="#耳にする／目にする-表示没主动去看听，而是被动传入" class="headerlink" title="耳にする／目にする　表示没主动去看听，而是被动传入"></a>耳にする／目にする　表示没主动去看听，而是被动传入</h4><ul><li>最も大阪の方言が聞けると思っていたんですが，あまり耳にしませんでした。</li><li>携帯電話の普及で，最近公衆電話を目にしなくなりました。</li></ul><h4 id="～せい／せいで／せいか-事情的原因，原因不明确时用せいか"><a href="#～せい／せいで／せいか-事情的原因，原因不明确时用せいか" class="headerlink" title="～せい／せいで／せいか　事情的原因，原因不明确时用せいか"></a>～せい／せいで／せいか　事情的原因，原因不明确时用せいか</h4><ul><li>風邪を引いているせいか，今日は仕事に集中できない。</li><li>計画が失敗したのは，私のせいだ。</li></ul><h4 id="～おかけで／～おかけか-多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか"><a href="#～おかけで／～おかけか-多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか" class="headerlink" title="～おかけで／～おかけか　多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか"></a>～おかけで／～おかけか　多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか</h4><ul><li>林さんのおかけで，助かりました。</li><li>薬を飲んだおかけか，1日で熱が下がりました。</li></ul><h4 id="～です／だけれど，～-虽然……，但是……，意思和が，だけ一样的但是更有礼貌"><a href="#～です／だけれど，～-虽然……，但是……，意思和が，だけ一样的但是更有礼貌" class="headerlink" title="～です／だけれど，～　虽然……，但是……，意思和が，だけ一样的但是更有礼貌"></a>～です／だけれど，～　虽然……，但是……，意思和が，だけ一样的但是更有礼貌</h4><ul><li>せっかくですけれど，今日は遠慮しておきます。</li></ul><h4 id="～においても-对于，在……方面，就……而言"><a href="#～においても-对于，在……方面，就……而言" class="headerlink" title="～においても　对于，在……方面，就……而言"></a>～においても　对于，在……方面，就……而言</h4><ul><li>日本語においても，発音，文法，語彙など，地域による言葉の違いがある。</li></ul><h4 id="～ことになる-也就是说，变得……会这样"><a href="#～ことになる-也就是说，变得……会这样" class="headerlink" title="～ことになる　也就是说，变得……会这样"></a>～ことになる　也就是说，变得……会这样</h4><ul><li>参加者は男性３名，女性２名，５名ということになる。</li></ul><h3 id="课文-11"><a href="#课文-11" class="headerlink" title="课文"></a>课文</h3><p>中国は多民族国家で，民族によって使用する言語が異なっている。また中国語も一つではなく，かなりの数の方言が存在する。それぞれの方言は発音も文法も語彙も大きく違っている。</p><p>日本語においても，発音，文法，語彙など，地域による言葉の違いがある。</p><p>まず，発音やアクセントの違いがある。例えば，「はし」という言葉だ。「箸」の「はし」，「橋」の「はし」。ほかにも異なった意味があるが，この二つの意味で考えてみよう。</p><p>方言の違いによってこんな誤解が起きることもある。例えば，東北地方に「なげる」という方言がある。これは「捨てる」という意味だが，方言を知らない人が「これをなげす」と言われて，「投げる」だと解釈して，ごみを投げ返して怒られたという話がある。また，関西地方には「ほかす」という方言がある。やはり「捨てる」という意味が，これを「保管して」と聞き間違えて，要らないものを大切に保管してしまったという話もある。</p><h1 id="単元-3"><a href="#単元-3" class="headerlink" title="単元"></a>単元</h1><h2 id="第１３課"><a href="#第１３課" class="headerlink" title="第１３課"></a>第１３課</h2><h3 id="文法-12"><a href="#文法-12" class="headerlink" title="文法"></a>文法</h3><h4 id="折り入って～-诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫"><a href="#折り入って～-诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫" class="headerlink" title="折り入って～　诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫"></a>折り入って～　诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫</h4><ul><li>折り入ってお話したいのですが，今よろしいでしょうか。</li></ul><h4 id="もしかして／もしかすると・もしかしたら-该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句"><a href="#もしかして／もしかすると・もしかしたら-该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句" class="headerlink" title="もしかして／もしかすると・もしかしたら　该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句"></a>もしかして／もしかすると・もしかしたら　该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句</h4><ul><li>もしかして，上海の李さんも来るの？</li></ul><h4 id="～ことになりました-决定要……-有受到多种因素的影响后才做出的决定，自然的变成这样的"><a href="#～ことになりました-决定要……-有受到多种因素的影响后才做出的决定，自然的变成这样的" class="headerlink" title="～ことになりました　决定要…… 　有受到多种因素的影响后才做出的决定，自然的变成这样的"></a>～ことになりました　决定要…… 　有受到多种因素的影响后才做出的决定，自然的变成这样的</h4><ul><li>王さんが結婚式に出席してくれことになりました。</li><li>来年の春に結婚することになりました。</li></ul><h4 id="朝着一个方向不断发展，有～ていく的感觉"><a href="#朝着一个方向不断发展，有～ていく的感觉" class="headerlink" title="朝着一个方向不断发展，有～ていく的感觉"></a>朝着一个方向不断发展，有～ていく的感觉</h4><ul><li><p>～一方だ</p><ul><li>世界の人口は増加する一方が，日本の人口は減り始めている。</li><li>前后主语一样时表示同时做某事，可用于接续<ul><li>彼は事故の原因を調べる一方，被害の拡大を防いだ。</li></ul></li><li>前后主语不一样时表示对比，也可以用于接续<ul><li>出生率が下がる一方，平均寿命どんどん長くなっています。</li></ul></li></ul></li><li><p>～ばかりだ</p><ul><li>全是，尽是，光是<ul><li>最近，変な夢ばかり見る。</li><li>彼は週末になると博物館ばかり行っている</li></ul></li><li>朝着一个不好的方向不断发展<ul><li>病気はどんどん悪くなるばかりだ。</li></ul></li></ul></li><li><p>の一途をたどる　书面语</p><ul><li>出生率は減少の一途をたどっている。</li></ul></li></ul><h4 id="AのBにはCがある-AのB的原因之一有C"><a href="#AのBにはCがある-AのB的原因之一有C" class="headerlink" title="AのBにはCがある　AのB的原因之一有C"></a>AのBにはCがある　AのB的原因之一有C</h4><ul><li>事故の原因には整備不良がある。</li><li>「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。</li></ul><h4 id="Aに対する-对于A的……（态度，感情，动作），也有对比的意思"><a href="#Aに対する-对于A的……（态度，感情，动作），也有对比的意思" class="headerlink" title="Aに対する　对于A的……（态度，感情，动作），也有对比的意思"></a>Aに対する　对于A的……（态度，感情，动作），也有对比的意思</h4><ul><li>政府に対する国民の批判が高まっている。</li><li>地球温暖化に対して取り組みは国によってさまざまだ。</li><li>兄はおとなしく内向的なのに対して，弟はとても活発で外向的だ。</li></ul><h3 id="课文-12"><a href="#课文-12" class="headerlink" title="课文"></a>课文</h3><p>「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。例えば，結婚年齢が遅くなる「晩婚化」の傾向は，年々強まっている。結婚時の女性の平均年齢は，1977年には25.0歳であったが，1992年には26.0歳，2004年には27.8歳になった。</p><p>高年齢になると出産を控える傾向が強まり，一人の女性が出産する子供の数を示す「出生率」が下がる。それが少子化の原因に繋がっている。</p><h2 id="第１４課"><a href="#第１４課" class="headerlink" title="第１４課"></a>第１４課</h2><h3 id="文法-13"><a href="#文法-13" class="headerlink" title="文法"></a>文法</h3><h4 id="～を問わず-不论……，书面语"><a href="#～を問わず-不论……，书面语" class="headerlink" title="～を問わず　不论……，书面语"></a>～を問わず　不论……，书面语</h4><ul><li>男女を問わず，黒か濃い紺色，灰色の地味なスーツを指す。</li></ul><h4 id="～て初めて～-只有……才能……"><a href="#～て初めて～-只有……才能……" class="headerlink" title="～て初めて～　只有……才能……"></a>～て初めて～　只有……才能……</h4><ul><li>これらの試験をとっばして初めて内定をもらうことになる 。</li></ul><p>####　少しでも～　尽可能早的……</p><ul><li>少しでもいい席を取れるように，会場の前に朝早くから多くの人が並んでいる。</li></ul><h3 id="课文-13"><a href="#课文-13" class="headerlink" title="课文"></a>课文</h3><p>面接は話す場であり，文を読む場ではない。志望動機や自己PRなど，履歴書に書いたものをそのまま話すのはよくない。</p><p>会社の建物に入り，出るまでが採用試験である。受付での話し方や待合室での態度なども評価の対象になる。</p><p>面接でははじめの印象が大切である。清潔のあるきちんとした服装をすること。</p><h2 id="第１５課"><a href="#第１５課" class="headerlink" title="第１５課"></a>第１５課</h2><h3 id="文法-14"><a href="#文法-14" class="headerlink" title="文法"></a>文法</h3><h4 id="ちっとも／少しも／全然／真く＋～ない-一点也不"><a href="#ちっとも／少しも／全然／真く＋～ない-一点也不" class="headerlink" title="ちっとも／少しも／全然／真く＋～ない　一点也不"></a>ちっとも／少しも／全然／真く＋～ない　一点也不</h4><ul><li>学生の頃と，ちっとも変わってないわね。</li><li>課長は少しも部下の意見を聞いてくれない。</li><li>昨日の夜のことは全然覚えてない。</li><li>山田さんと町子さんが結婚することを真く知らなかった。</li></ul><h4 id="それはそうと-先不说那个，转换话题"><a href="#それはそうと-先不说那个，转换话题" class="headerlink" title="それはそうと　先不说那个，转换话题"></a>それはそうと　先不说那个，转换话题</h4><ul><li>今回は仕事で日本に来たんでしょう。</li></ul><h4 id="決して～ない-绝对不是这样，绝对不这样做"><a href="#決して～ない-绝对不是这样，绝对不这样做" class="headerlink" title="決して～ない　绝对不是这样，绝对不这样做"></a>決して～ない　绝对不是这样，绝对不这样做</h4><ul><li>彼は決して嘘はつきません</li><li>誰にも決してを分からない場所にお金を隠した。</li></ul><h3 id="课文-14"><a href="#课文-14" class="headerlink" title="课文"></a>课文</h3><p>日本の料理には，面白い名前のものがある。例えば，「親子丼」というのは，鶏肉と卵を調理してご飯にのせた料理である。鶏肉と卵は親と子であることからついた名前だ。<br>ほなに，「他人丼」という料理もある。豚肉や牛肉と卵を調理してご飯に載せた料理である。豚肉と卵は「親子」ではなく「他人」だからである。</p><p>では，「キツネうどん」というのはどんな料理だろうか。決して狐の肉が入ったうどんではない。うどんの上に，「油揚げ」という，豆腐を油揚げた物を載せた料理だ。<br>油揚げの色がキツネのような色だからとか，油揚げがキツネの好物だから，という理由でこんな名前が付けられたという。</p><h2 id="第１６課"><a href="#第１６課" class="headerlink" title="第１６課"></a>第１６課</h2><h3 id="文法-15"><a href="#文法-15" class="headerlink" title="文法"></a>文法</h3><h4 id="～ともに-一起做……和一緒に一样的意思"><a href="#～ともに-一起做……和一緒に一样的意思" class="headerlink" title="～ともに　一起做……和一緒に一样的意思"></a>～ともに　一起做……和一緒に一样的意思</h4><ul><li>今までともに助け合って，頑張ってきた。</li></ul><h4 id="～とも-全部，都"><a href="#～とも-全部，都" class="headerlink" title="～とも　全部，都"></a>～とも　全部，都</h4><ul><li>私たち姉妹は５人とも元気です。</li></ul><h4 id="～からといって～とは限らない／ない-虽然说……但也不一定-不"><a href="#～からといって～とは限らない／ない-虽然说……但也不一定-不" class="headerlink" title="～からといって～とは限らない／ない　虽然说……但也不一定/不"></a>～からといって～とは限らない／ない　虽然说……但也不一定/不</h4><ul><li>日本人だからといって，日本の文化に詳しいとは限らない。</li><li>森さんは，お酒を飲まないからといってお酒が嫌いではない。</li></ul><h3 id="会話-2"><a href="#会話-2" class="headerlink" title="会話"></a>会話</h3><p>中国には「白头偕老」という言葉があります。これは「ともに白髪になるまで一緒にいる」いう意味の言葉です。お二人とも，きっとこの言葉通りの幸せな夫婦になられるでしょう。</p><h3 id="课文-15"><a href="#课文-15" class="headerlink" title="课文"></a>课文</h3><p>キリスト教式で結婚式を上げるからといって，キリスト教の信者であるとは限らない。ウエディングドレスが着たいからとか，教会で挙式したいからなど，自分の好みで挙式のスタイルを決める人が多く，宗教で決める人は少数である。ほてるや結婚式場には，挙式の場所が設けられているので，実際に神社や教会へ行く人の数は少ない。さらに，海外で挙式をする人も多くなっている。</p><p>下のグラフは，ある出版社が首都圏の夫婦４００組に対して行ったアンケートの結果を求めたものである。これを見ると，挙式の形式が時代とともに変わってきていることが分かる。１９９４年には「キリスト教式結婚式」が56.6%，「人前結婚式」が5.4%であったのに対して，２００５年では，それぞれ74.4%，12.6%に増えた。一方，伝統的な挙式形式である「神前結婚式」は，２００５年には１９９４年の３分の１まで減少した。このように，結婚式に対する人々の意識は，時代にとともに変化してきている。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之N3文法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-(简敬)语</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E7%AE%80%E6%95%AC-%E8%AF%AD/"/>
    <id>/2024/06/11/日语-简敬-语/</id>
    <published>2024-06-11T03:10:38.000Z</published>
    <updated>2024-06-11T05:18:08.534Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之(简敬)语<br><a id="more"></a></p><h1 id="简体"><a href="#简体" class="headerlink" title="简体"></a>简体</h1><h2 id="变形规则"><a href="#变形规则" class="headerlink" title="变形规则"></a>变形规则</h2><h3 id="名词和形容动词"><a href="#名词和形容动词" class="headerlink" title="名词和形容动词"></a>名词和形容动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：だ，である</span><br><span class="line"></span><br><span class="line">一般否定：ではない、じゃない</span><br><span class="line"></span><br><span class="line">过去时：だった</span><br><span class="line"></span><br><span class="line">过去否定：ではなかった、じゃなかった</span><br></pre></td></tr></table></figure><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：寒い</span><br><span class="line"></span><br><span class="line">一般否定：寒くない</span><br><span class="line"></span><br><span class="line">过去时：寒かった</span><br><span class="line"></span><br><span class="line">过去否定：寒くなかった</span><br></pre></td></tr></table></figure><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：字典形</span><br><span class="line"></span><br><span class="line">一般否定：ない形</span><br><span class="line"></span><br><span class="line">过去时：た形</span><br><span class="line"></span><br><span class="line">过去否定：なかった</span><br></pre></td></tr></table></figure><h2 id="活用形"><a href="#活用形" class="headerlink" title="活用形"></a>活用形</h2><h3 id="终止形"><a href="#终止形" class="headerlink" title="终止形"></a>终止形</h3><blockquote><p>终止形即终止句子的形式<br>当名词和形容动词后面有か时可以省略だ</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动词简体</span><br><span class="line"></span><br><span class="line">形容词简体</span><br><span class="line"></span><br><span class="line">形容动词＋だ</span><br><span class="line"></span><br><span class="line">名词＋だ</span><br></pre></td></tr></table></figure><h3 id="连体形"><a href="#连体形" class="headerlink" title="连体形"></a>连体形</h3><blockquote><p>用于修饰名词, 所以连体形没有名词的变形</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动词简体</span><br><span class="line"></span><br><span class="line">形容词简体</span><br><span class="line"></span><br><span class="line">形容动词＋な</span><br></pre></td></tr></table></figure><h3 id="连用形"><a href="#连用形" class="headerlink" title="连用形"></a>连用形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I形: ます形</span><br><span class="line"></span><br><span class="line">II形: て形, た形</span><br></pre></td></tr></table></figure><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h3 id="简体可以修饰名词"><a href="#简体可以修饰名词" class="headerlink" title="简体可以修饰名词"></a>简体可以修饰名词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は四川語を話すことができます。</span><br><span class="line">译：我会说四川话。</span><br></pre></td></tr></table></figure><h3 id="简体＋といいます-引用别人说的话"><a href="#简体＋といいます-引用别人说的话" class="headerlink" title="简体＋といいます　引用别人说的话"></a>简体＋といいます　引用别人说的话</h3><ol><li>直接引用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：寝る前に、『おやしみ』といいます。</span><br><span class="line">译：睡觉之前一般会说“晚安”。</span><br></pre></td></tr></table></figure><ol start="2"><li>间接引用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ミーラさんは『来週東京へ出張する』といいます。</span><br><span class="line">译：米勒说下周要去东京出差。</span><br></pre></td></tr></table></figure><h3 id="动词和形容词简体-形容动词な-名词の＋とき-在……时候，动词简体过去式表示动作之后的情况"><a href="#动词和形容词简体-形容动词な-名词の＋とき-在……时候，动词简体过去式表示动作之后的情况" class="headerlink" title="动词和形容词简体/形容动词な/名词の＋とき　在……时候，动词简体过去式表示动作之后的情况"></a>动词和形容词简体/形容动词な/名词の＋とき　在……时候，动词简体过去式表示动作之后的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：暇なとき、遊びに来ましょうか。</span><br><span class="line">译：闲暇的时候，来玩吧！</span><br><span class="line"></span><br><span class="line">例：国へ帰るとき</span><br><span class="line">译：回国途中时……</span><br><span class="line"></span><br><span class="line">例：国へ帰ったとき</span><br><span class="line">译：回国后……</span><br></pre></td></tr></table></figure><h3 id="字典形＋と……-一怎么样"><a href="#字典形＋と……-一怎么样" class="headerlink" title="字典形＋と…… 一怎么样"></a>字典形＋と…… 一怎么样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：右へ曲がると郵便局があります。</span><br><span class="line">译：一右转就到邮局了。</span><br></pre></td></tr></table></figure><h3 id="简体-名词な＋んですか"><a href="#简体-名词な＋んですか" class="headerlink" title="简体/名词な＋んですか"></a>简体/名词な＋んですか</h3><ol><li>寻求更详细的说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうして遅れたんですか。</span><br><span class="line">译：为什么迟到了呢？</span><br></pre></td></tr></table></figure><ol start="2"><li>提起话题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：NHKを見学したいんですが、どうしたらいいですか。</span><br><span class="line">译：我想去NHK参观学习，怎做么才好呢？</span><br></pre></td></tr></table></figure><h3 id="终止形＋し＋终止形＋し＋终止形＋「から」"><a href="#终止形＋し＋终止形＋し＋终止形＋「から」" class="headerlink" title="终止形＋し＋终止形＋し＋终止形＋「から」"></a>终止形＋し＋终止形＋し＋终止形＋「から」</h3><ol><li>并列</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ワット先生は熱心だし真面目だし、経験もあります。</span><br><span class="line">译：瓦特老师既热心又认真，而且非常有经验。</span><br></pre></td></tr></table></figure><ol start="2"><li>列举理由，表示轻微的因果关系，暗示还有其他理由</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：駅から近いし、車でも来られるし、この店はとても便利です。</span><br><span class="line">译：离车站又近，坐车也能来，这家店真是便利呀。</span><br></pre></td></tr></table></figure><h3 id="动词字典形-动词ない形＋つもりです-下决心打算做某事"><a href="#动词字典形-动词ない形＋つもりです-下决心打算做某事" class="headerlink" title="动词字典形/动词ない形＋つもりです　下决心打算做某事"></a>动词字典形/动词ない形＋つもりです　下决心打算做某事</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：国へ帰っても柔道を続けるつもりです。</span><br><span class="line">译：即使回国也打算继续柔道。</span><br><span class="line"></span><br><span class="line">例：明日からは煙草を吸わないつもりです。</span><br><span class="line">译：打算从明天开始不再吸烟了。</span><br></pre></td></tr></table></figure><h3 id="动词字典形-名词の＋予定です-预计，预定的计划"><a href="#动词字典形-名词の＋予定です-预计，预定的计划" class="headerlink" title="动词字典形/名词の＋予定です　预计，预定的计划"></a>动词字典形/名词の＋予定です　预计，预定的计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：７月の終わりにドイツへ出張する予定です。</span><br><span class="line">译：预计7月完去德国出差。</span><br><span class="line"></span><br><span class="line">例：旅行は１週間ぐらいの予定です。</span><br><span class="line">译：预计旅行一周左右。</span><br></pre></td></tr></table></figure><h3 id="动词た形-ない形ない＋ほうがいいです。-最好做…-用于给别人提供建议和忠告"><a href="#动词た形-ない形ない＋ほうがいいです。-最好做…-用于给别人提供建议和忠告" class="headerlink" title="动词た形/ない形ない＋ほうがいいです。　最好做… 用于给别人提供建议和忠告"></a>动词た形/ない形ない＋ほうがいいです。　最好做… 用于给别人提供建议和忠告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：毎日運動したほうがいいです。</span><br><span class="line">译：最好每天运动。</span><br></pre></td></tr></table></figure><h3 id="终止形＋でしょう-表示说话人的推测"><a href="#终止形＋でしょう-表示说话人的推测" class="headerlink" title="终止形＋でしょう　表示说话人的推测"></a>终止形＋でしょう　表示说话人的推测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：明日は雨が降るでしょう。</span><br><span class="line">译：明天要下雨吧？</span><br><span class="line"></span><br><span class="line">例：楊さんは合格するでしょうか。</span><br><span class="line">译：杨同学及格了吧？</span><br></pre></td></tr></table></figure><h3 id="终止形＋かもしれません-可能，或许，可以简写为かも"><a href="#终止形＋かもしれません-可能，或许，可以简写为かも" class="headerlink" title="终止形＋かもしれません　可能，或许，可以简写为かも"></a>终止形＋かもしれません　可能，或许，可以简写为かも</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：約束の時間に合わないかもしれません。</span><br><span class="line">译：可能会错过了约定的时间。</span><br></pre></td></tr></table></figure><h3 id="字典形-た形＋とおりに、～-按照……做……"><a href="#字典形-た形＋とおりに、～-按照……做……" class="headerlink" title="字典形/た形＋とおりに、～　按照……做……"></a>字典形/た形＋とおりに、～　按照……做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：私はやるとおりに、やってください。</span><br><span class="line">译：请跟着我做。</span><br><span class="line"></span><br><span class="line">例：みたとおりに、話してください。</span><br><span class="line">译：请按照所看到的那样说。</span><br></pre></td></tr></table></figure><ul><li>拓展：～らしい　推测，传闻，……的样子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あそこにいる人は男らしい。</span><br><span class="line">译：那人像是个男的。</span><br><span class="line"></span><br><span class="line">例：彼はとても男らしい。</span><br><span class="line">译：她非常像一名男性。</span><br></pre></td></tr></table></figure><h3 id="ます形-名词の＋とおりに、～-正如，按照"><a href="#ます形-名词の＋とおりに、～-正如，按照" class="headerlink" title="ます形/名词の＋とおりに、～　正如，按照"></a>ます形/名词の＋とおりに、～　正如，按照</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：説明書のとおりに、組み立てました。</span><br><span class="line">译：我按照说明书组装好了。</span><br></pre></td></tr></table></figure><h3 id="た形-名词の＋あとで-……之后……-（する前に、した後で）"><a href="#た形-名词の＋あとで-……之后……-（する前に、した後で）" class="headerlink" title="た形/名词の＋あとで　……之后…… （する前に、した後で）"></a>た形/名词の＋あとで　……之后…… （する前に、した後で）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：仕事のあとで、飲みに行きませんか。</span><br><span class="line">译：下班后要去喝一杯吗？</span><br></pre></td></tr></table></figure><h3 id="可能态字典形-ない形ない＋ように、～-为了……而……-前方必须是非意志类词语，前后主语可以不一致"><a href="#可能态字典形-ない形ない＋ように、～-为了……而……-前方必须是非意志类词语，前后主语可以不一致" class="headerlink" title="可能态字典形/ない形ない＋ように、～　为了……而…… 前方必须是非意志类词语，前后主语可以不一致"></a>可能态字典形/ない形ない＋ように、～　为了……而…… 前方必须是非意志类词语，前后主语可以不一致</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：早く泳げるように、毎日練習しています。</span><br><span class="line">译：为了早点学会游泳，每天都在练习。</span><br><span class="line"></span><br><span class="line">例：忘れないように、メモしてください。</span><br><span class="line">译：为了不忘记，记了笔记。</span><br><span class="line"></span><br><span class="line">例：老人にも読めるように、新聞の字を大きくする。</span><br><span class="line">译：为了让老人也能阅读，放大了报纸上的字。</span><br></pre></td></tr></table></figure><h3 id="字典形-名词の＋ために、～-为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿"><a href="#字典形-名词の＋ために、～-为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿" class="headerlink" title="字典形/名词の＋ために、～　为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿"></a>字典形/名词の＋ために、～　为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：自分の店を持つために、貯金しています。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="可能态字典形-ない形なく＋ように、なります-变得……"><a href="#可能态字典形-ない形なく＋ように、なります-变得……" class="headerlink" title="可能态字典形/ない形なく＋ように、なります　变得……"></a>可能态字典形/ない形なく＋ように、なります　变得……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：毎日練習すれば、泳げように、なります。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：太りましたから、好きな服が着られなくように、なりました。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="字典形-ない形ない＋ように、します-努力（尽可能）做或不做……"><a href="#字典形-ない形ない＋ように、します-努力（尽可能）做或不做……" class="headerlink" title="字典形/ない形ない＋ように、します　努力（尽可能）做或不做……"></a>字典形/ない形ない＋ように、します　努力（尽可能）做或不做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：毎日運動して、何でも食べるように、しています。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：もっと野菜を食べるように、してください。（更有礼貌）</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="疑问词＋终止形＋か、～"><a href="#疑问词＋终止形＋か、～" class="headerlink" title="疑问词＋终止形＋か、～"></a>疑问词＋终止形＋か、～</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：結婚のお祝いは何がいいか、話しています。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：私たちが初めて会ったのはいつか、覚えていますか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="终止形（名词不加だ）＋かどうか、～"><a href="#终止形（名词不加だ）＋かどうか、～" class="headerlink" title="终止形（名词不加だ）＋かどうか、～"></a>终止形（名词不加だ）＋かどうか、～</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：その話は本堂かどうか、わかりません。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：まちがいがないかどうか、調べてください。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="名词-形容词去い-形容动词＋がる-有……的感觉-感觉……"><a href="#名词-形容词去い-形容动词＋がる-有……的感觉-感觉……" class="headerlink" title="名词/形容词去い/形容动词＋がる　有……的感觉, 感觉……"></a>名词/形容词去い/形容动词＋がる　有……的感觉, 感觉……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：嬉しがる</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：好きがる</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="名词に-形容词去い加く-形容动词に＋します-使……变成……-名词に还有选择和决定的意思"><a href="#名词に-形容词去い加く-形容动词に＋します-使……变成……-名词に还有选择和决定的意思" class="headerlink" title="名词に/形容词去い加く/形容动词に＋します　使……变成……　名词に还有选择和决定的意思"></a>名词に/形容词去い加く/形容动词に＋します　使……变成……　名词に还有选择和决定的意思</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：音を大きくします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：部屋を綺麗にします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：会議は明日にします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：部屋はシングルにしますか、ツインにしますか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="连体形-名词の＋場合は、～-如果……就……-后面一般接对策或导致的结果"><a href="#连体形-名词の＋場合は、～-如果……就……-后面一般接对策或导致的结果" class="headerlink" title="连体形/名词の＋場合は、～　如果……就……(后面一般接对策或导致的结果)"></a>连体形/名词の＋場合は、～　如果……就……(后面一般接对策或导致的结果)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：会議に間に合わない場合は、連絡してください。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：時間に遅れた場合は、会場に入れません。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="连体形-名词な＋のに、～-明明……却……-表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。"><a href="#连体形-名词な＋のに、～-明明……却……-表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。" class="headerlink" title="连体形/名词な＋のに、～　明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。"></a>连体形/名词な＋のに、～　明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：約束をしたのに、彼女はきませんでした。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：約束をしたのに、どうして来なかったですか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-～ている-た＋ところです-即将-正在-刚刚做了（5-10分钟的事情）"><a href="#动词字典形-～ている-た＋ところです-即将-正在-刚刚做了（5-10分钟的事情）" class="headerlink" title="动词字典形/～ている/~た＋ところです　即将/正在/刚刚做了（5-10分钟的事情）"></a>动词字典形/～ている/~た＋ところです　即将/正在/刚刚做了（5-10分钟的事情）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：会議は今から始まるところです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：今私は勉強しているところです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：たった今バスがでたところです</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-ない形ない-形容词-形容动词な-名词の＋はずです-应该会，确信的推断。"><a href="#动词字典形-ない形ない-形容词-形容动词な-名词の＋はずです-应该会，确信的推断。" class="headerlink" title="动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです　应该会，确信的推断。"></a>动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです　应该会，确信的推断。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：くるはずですよ</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="简体＋そうです-据说，传闻。"><a href="#简体＋そうです-据说，传闻。" class="headerlink" title="简体＋そうです　据说，传闻。"></a>简体＋そうです　据说，传闻。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：天気予報によると、明日はさむくなるそうです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：クララさんは子どもの時、フランスに住んでいたそうです</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-形容词-形容动词な-名词の＋ようです-好像，感官感受到的好像"><a href="#动词字典形-形容词-形容动词な-名词の＋ようです-好像，感官感受到的好像" class="headerlink" title="动词字典形/形容词/形容动词な/名词の＋ようです　好像，感官感受到的好像"></a>动词字典形/形容词/形容动词な/名词の＋ようです　好像，感官感受到的好像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：渡辺さんはこのごろはやくかえりますから、どうも恋人ができたようですね。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="～がします。-有……的感受"><a href="#～がします。-有……的感受" class="headerlink" title="～がします。　有……的感受"></a>～がします。　有……的感受</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：おと（こえ）がします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：あじがします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：においがします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：～顔がします　有~样的表情</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h1 id="敬语"><a href="#敬语" class="headerlink" title="敬语"></a>敬语</h1><h2 id="礼貌体"><a href="#礼貌体" class="headerlink" title="礼貌体"></a>礼貌体</h2><h3 id="です"><a href="#です" class="headerlink" title="です"></a>です</h3><p>普通形态：～です。<br>过去形态：～でした。<br>否定形态：～では（じゃ）ありません。<br>过去否定形态：～では（じゃ）ありませんでした。</p><h3 id="ます"><a href="#ます" class="headerlink" title="ます"></a>ます</h3><p>普通形态：～ます。<br>过去形态：～ました。<br>否定形态：～ません。<br>过去否定形态：～ませんでした。</p><h2 id="尊他语"><a href="#尊他语" class="headerlink" title="尊他语"></a>尊他语</h2><h3 id="被动形表达尊敬"><a href="#被动形表达尊敬" class="headerlink" title="被动形表达尊敬"></a>被动形表达尊敬</h3><ul><li>課長はもう帰られました。</li></ul><h3 id="お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～"><a href="#お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～" class="headerlink" title="お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～"></a>お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～</h3><ul><li><p>～ください　请……</p><ul><li>お待ちください。</li></ul></li><li><p>～になる</p><ul><li>社長はもうお帰りになりました。</li></ul></li></ul><h3 id="特殊动词的敬语变形"><a href="#特殊动词的敬语变形" class="headerlink" title="特殊动词的敬语变形"></a>特殊动词的敬语变形</h3><ul><li>いらっしゃる ー＞ いらっしゃいます　ー＞　いる、来る、行く</li><li>召し上がります　ー＞　食べる、飲む</li><li>おっしゃる　ー＞ おっしゃいます　ー＞　言う<ul><li>というと　ー＞　とおっしゃいますと</li></ul></li><li>なさる　ー＞ なさいます　ー＞　する</li><li>ご覧になります　ー＞　見る<ul><li>ご覧ください　―＞　見てください</li></ul></li><li>ご存じです　ー＞　知っています</li><li>くださる　ー＞　くださいます　ー＞　くれる</li></ul><h3 id="ます形＋まして-用于敬语中使前后敬语一致，使礼貌程度一致"><a href="#ます形＋まして-用于敬语中使前后敬语一致，使礼貌程度一致" class="headerlink" title="ます形＋まして　用于敬语中使前后敬语一致，使礼貌程度一致"></a>ます形＋まして　用于敬语中使前后敬语一致，使礼貌程度一致</h3><ul><li>ハンスが昨夜ねつをだしまして、今朝もまだ下がらないんです。</li></ul><h3 id="お＋形容词"><a href="#お＋形容词" class="headerlink" title="お＋形容词"></a>お＋形容词</h3><ul><li><p>お忙しい</p><ul><li>今日はお忙しいようですから，また明後日伺います。</li></ul></li><li><p>お詳しい</p><ul><li>御社が中国国内の酒類販売ルートにお詳しいことを，MTS社の聞くより伺いました。</li></ul></li></ul><h2 id="自谦语"><a href="#自谦语" class="headerlink" title="自谦语"></a>自谦语</h2><h3 id="お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～-1"><a href="#お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～-1" class="headerlink" title="お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～"></a>お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～</h3><ul><li><p>～＋する／いたします／できる</p><ul><li>今月のスケジュールはお送りします。</li><li>はい，ご用意できます。</li></ul></li><li><p>～＋申し上げる・申し上げます　同する一样的意思，但是敬意程度更高</p><ul><li>よろしくご検討くださいますようお願い申し上げます。</li></ul></li><li><p>お＋动词て型＋しております　～ています 的自谦语</p><ul><li>只今お調べしております。</li><li>お呼び出ししております。</li></ul></li></ul><h3 id="特殊动词的敬语变形-1"><a href="#特殊动词的敬语变形-1" class="headerlink" title="特殊动词的敬语变形"></a>特殊动词的敬语变形</h3><ul><li>差し上げります　ー＞　上げる</li><li>いただきます　ー＞　もらう，食べる，飲む</li><li>参ります　ー＞　行く、来る</li><li>おります　ー＞　いる</li><li>申します　ー＞　言う</li><li>いたします　ー＞　する</li><li>拝見します　ー＞　見る</li><li>伺います　ー＞　聞く、いる</li><li>存じます　ー＞　思う，知る<ul><li>ことと存じます　ー＞　と思います</li></ul></li><li>お目にかかります　ー＞　会う</li><li>お目にかけります　ー＞　見せる</li><li>私　ー＞　わたくし<ul><li>私たち　ー＞　わたくしども</li></ul></li><li>お～しております　ー＞　～ています、お～します</li><li>使役态表达自谦</li><li>常用组合形式为～＋させていただきます<ul><li>検討させていただきます</li></ul></li></ul><h2 id="礼貌语"><a href="#礼貌语" class="headerlink" title="礼貌语"></a>礼貌语</h2><ul><li>お手洗い　ー＞　洗手间</li><li>ございます　ー＞　ある</li><li>でございます　ー＞　です</li><li>よろしい　ー＞　いい</li><li>より　―＞　から</li><li>にて　―＞　で</li><li>～におかれましては／～には　―＞　～は　书函中表达敬意的写法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之(简敬)语&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-(形助副)词</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E5%BD%A2%E5%8A%A9%E5%89%AF-%E8%AF%8D/"/>
    <id>/2024/06/11/日语-形助副-词/</id>
    <published>2024-06-11T03:10:19.000Z</published>
    <updated>2024-06-11T03:28:17.307Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之(形助副)词<br><a id="more"></a></p><h1 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h1><h3 id="1-修饰名词"><a href="#1-修饰名词" class="headerlink" title="1. 修饰名词"></a>1. 修饰名词</h3><p>~い + 名词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：優しい人</span><br><span class="line">译：温柔的人</span><br></pre></td></tr></table></figure><h3 id="2-名词化"><a href="#2-名词化" class="headerlink" title="2. 名词化"></a>2. 名词化</h3><p>形容词（去い） + さ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：部長は頭の痛さを我慢して出張した。</span><br><span class="line">译：部长忍着头痛出差去了。</span><br></pre></td></tr></table></figure><h3 id="3-修饰动词"><a href="#3-修饰动词" class="headerlink" title="3. 修饰动词"></a>3. 修饰动词</h3><p>形容词（去い） + く</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：浅く笑う</span><br><span class="line">译：浅笑</span><br></pre></td></tr></table></figure><h3 id="4-句中接续"><a href="#4-句中接续" class="headerlink" title="4. 句中接续"></a>4. 句中接续</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼女は美しくて優しいです。</span><br><span class="line">译：她美丽温柔。</span><br></pre></td></tr></table></figure><h1 id="形容动词"><a href="#形容动词" class="headerlink" title="形容动词"></a>形容动词</h1><h3 id="1-修饰名词-1"><a href="#1-修饰名词-1" class="headerlink" title="1. 修饰名词"></a>1. 修饰名词</h3><p>形容动词 + な + 名词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：綺麗な景色</span><br><span class="line">译：美丽的风景</span><br></pre></td></tr></table></figure><h3 id="2-名词化-1"><a href="#2-名词化-1" class="headerlink" title="2. 名词化"></a>2. 名词化</h3><p>形容动词 + さ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あの店は家に近いので、便利さは一番です。</span><br><span class="line">译：那个商店离家很近，非常方便呀。</span><br></pre></td></tr></table></figure><h3 id="3-修饰动词-1"><a href="#3-修饰动词-1" class="headerlink" title="3. 修饰动词"></a>3. 修饰动词</h3><p>形容动词 + に</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：簡単にしました</span><br><span class="line">译：轻易地完成了</span><br></pre></td></tr></table></figure><h3 id="4-句中接续-1"><a href="#4-句中接续-1" class="headerlink" title="4. 句中接续"></a>4. 句中接续</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この町は綺麗で静かです。</span><br><span class="line">译：这坐小镇真是美丽安静呀。</span><br></pre></td></tr></table></figure><h1 id="助词"><a href="#助词" class="headerlink" title="助词"></a>助词</h1><p>助词是日语中的一大特色，它是日语语言中的黏着剂，串连起一个个完整的句子和含义。</p><h2 id="常用助词"><a href="#常用助词" class="headerlink" title="常用助词"></a>常用助词</h2><h3 id="1-を"><a href="#1-を" class="headerlink" title="1. を"></a>1. <code>を</code></h3><ul><li>提示宾语</li></ul><p>全員が無事であることをお祈りします。</p><blockquote><p>祈祷大家都没事。</p></blockquote><ul><li>表示经过的场所</li></ul><p>猫は塀の上を走っていった。  </p><blockquote><p>小猫从在墙上跑走了。</p></blockquote><ul><li>动作的出发点，起点</li></ul><p>彼は文房具を売る6階でエレベーターを降りた。</p><blockquote><p>他在买文具的6楼下了电梯。</p></blockquote><h3 id="2-に"><a href="#2-に" class="headerlink" title="2. に"></a>2. <code>に</code></h3><ul><li>动作作用的对象</li></ul><p>親に黙って、会社を辞めてしまった。</p><blockquote><p>瞒着父母辞掉了工作。</p></blockquote><ul><li>动作变化的结果</li></ul><p>温度がマイナスになると、水が氷になります。</p><blockquote><p>温度到达零度以下水就会结冰。</p></blockquote><ul><li>事物存在的场所</li></ul><p>その言葉にうそは少しもなかった。</p><blockquote><p>那些话里一点谎言也没有。</p></blockquote><ul><li>动作的着落点</li></ul><p>道に倒れている人を助けました。</p><blockquote><p>救助了倒在道路上的人。</p></blockquote><ul><li>表示目的</li></ul><p>スーパーへ買い物に行きます。</p><blockquote><p>去超市买东西。</p></blockquote><h3 id="3-が"><a href="#3-が" class="headerlink" title="3. が"></a>3. <code>が</code></h3><ul><li>固定搭配，前接表示感觉的词表示感觉</li></ul><p>さっき隣の部屋で人の話し声がしました。 </p><blockquote><p>我刚才听到隔壁有人说话的声音。</p></blockquote><ul><li>接在自动词前面</li></ul><p>新しくて白い建物が見えるでしょう。あれが王さんの家です。</p><blockquote><p>能看到那座又新又白的建筑吧，那就是小王的家。</p></blockquote><ul><li>表示转折或铺垫</li></ul><p>ちょっとお願いがあるんですが…</p><p>予定どおり１７時３０分に到着いたしましたが…</p><h3 id="4-で"><a href="#4-で" class="headerlink" title="4. で"></a>4. <code>で</code></h3><ul><li>表示交通工具手段</li></ul><p>バスで学校へ行きます。</p><blockquote><p>坐公交去学校。</p></blockquote><ul><li>表示动作发生的场所</li></ul><p>運動場で走ります。</p><blockquote><p>在运动场上跑步。</p></blockquote><ul><li>表示原因</li></ul><p>地震でビルが倒れた。</p><blockquote><p>地震把大楼震倒了。</p></blockquote><ul><li>表示范围</li></ul><p>クラスの中で李さんが一番かっこいいです。</p><blockquote><p>班里小李最帅。</p></blockquote><ul><li>表示限定</li></ul><p>明日いっぱいで仕事を終わらせてください。</p><blockquote><p>请在明天内完成工作。</p></blockquote><h3 id="5-と"><a href="#5-と" class="headerlink" title="5. と"></a>5. <code>と</code></h3><ul><li>表示共同动作的对象</li></ul><p>李さんと一緒に映画を見に行きます。</p><blockquote><p>和小李一起去看电影。</p></blockquote><ul><li>表示引用的内容</li></ul><p>ほら、見てごらん。あそこに｢危険｣と書いてありますよ。</p><blockquote><p>你瞧，那里写着“危险”两个字哦。</p></blockquote><h3 id="6-へ"><a href="#6-へ" class="headerlink" title="6. へ"></a>6. <code>へ</code></h3><ul><li>表示动作移动的方向</li></ul><p>買い物へいく途中王先生に会いました。</p><blockquote><p>去买东西的路上遇到了王老师。  </p></blockquote><h3 id="7-から"><a href="#7-から" class="headerlink" title="7. から"></a>7. <code>から</code></h3><ul><li>表示起点</li></ul><p>学校から家まで1時間かかります。</p><blockquote><p>从家到学校要花1个小时。</p></blockquote><ul><li>表示原因</li></ul><p>昨日試験がありましたから行かなかった。</p><blockquote><p>因为昨天有考试所以没去。</p></blockquote><ul><li>表示成分/材料</li></ul><p>この箱は紙からできた。</p><blockquote><p>这个箱子是纸做的。</p></blockquote><h3 id="8-まで"><a href="#8-まで" class="headerlink" title="8. まで"></a>8. <code>まで</code></h3><ul><li>表示终点</li></ul><p>試験は明日までです。</p><blockquote><p>考试到明天结束。</p></blockquote><h3 id="9-の"><a href="#9-の" class="headerlink" title="9. の"></a>9. <code>の</code></h3><ul><li>表示所属,属性</li></ul><p>高校時代最後の運動会は一生忘れられない。</p><blockquote><p>高中时代最后一次运动会终生难忘。</p></blockquote><ul><li>名词化</li></ul><p>あのう、赤いのがありますか。</p><blockquote><p>请问有红色的吗？</p></blockquote><ul><li>表解释说明</li></ul><p>昨日試験がありましたから、来なかったのです。</p><blockquote><p>因为昨天有考试所以没来。</p></blockquote><h3 id="9-～けど"><a href="#9-～けど" class="headerlink" title="9. ～けど"></a>9. <code>～けど</code></h3><ul><li>表示转折或铺垫</li></ul><p>あうの，荷物がでてこないんですけど…</p><blockquote><p>那个，我的行李还有没有出来，能不能……</p></blockquote><p>知っていたけど，言わなかっただけだ。</p><blockquote><p>我是知道的，只不过没有说罢了。</p></blockquote><h1 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h1><p>副词用作连用修饰语，表示用言的状态、程度，或者表明句子的陈述语气等的词叫作副词。</p><h2 id="常用副词"><a href="#常用副词" class="headerlink" title="常用副词"></a>常用副词</h2><h3 id="あ"><a href="#あ" class="headerlink" title="あ"></a>あ</h3><h4 id="あまり"><a href="#あまり" class="headerlink" title="あまり"></a>あまり</h4><p>后接动词，肯定：太，过于；否定：不那么，不怎么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あまり食べると毒だよ。</span><br><span class="line">译：吃太多会伤身。</span><br><span class="line"></span><br><span class="line">例：あまり良くない。</span><br><span class="line">译：不怎么好。</span><br></pre></td></tr></table></figure><h4 id="あるいは"><a href="#あるいは" class="headerlink" title="あるいは"></a>あるいは</h4><p>或者；或许</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すぐ行けば或いは間に合うかもしれない。</span><br><span class="line">译：马上出发的话或许能赶上也说不定。</span><br></pre></td></tr></table></figure><h4 id="あいにく"><a href="#あいにく" class="headerlink" title="あいにく"></a>あいにく</h4><p>不凑巧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あいにく彼は留守でした。</span><br><span class="line">译：不凑巧他不在家。</span><br></pre></td></tr></table></figure><h3 id="い"><a href="#い" class="headerlink" title="い"></a>い</h3><h4 id="いかが"><a href="#いかが" class="headerlink" title="いかが"></a>いかが</h4><p>如何；怎样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ご病人の具合はいかがでしょうか。</span><br><span class="line">译：病人的情况如何？</span><br></pre></td></tr></table></figure><h4 id="一番（いちばん）"><a href="#一番（いちばん）" class="headerlink" title="一番（いちばん）"></a>一番（いちばん）</h4><p>最</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼が一番よく知っている。</span><br><span class="line">译：他知道的最清楚。</span><br></pre></td></tr></table></figure><h4 id="一生懸命（いっしょうけんめい）"><a href="#一生懸命（いっしょうけんめい）" class="headerlink" title="一生懸命（いっしょうけんめい）"></a>一生懸命（いっしょうけんめい）</h4><p>拼命</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一生懸命努力する。</span><br><span class="line">译：拼命努力着。</span><br></pre></td></tr></table></figure><h4 id="一緒に（いっしょに）"><a href="#一緒に（いっしょに）" class="headerlink" title="一緒に（いっしょに）"></a>一緒に（いっしょに）</h4><p>一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一緒にビルを飲みましょう。</span><br><span class="line">译：一起去喝啤酒吧。</span><br></pre></td></tr></table></figure><h4 id="一層（いっそう）"><a href="#一層（いっそう）" class="headerlink" title="一層（いっそう）"></a>一層（いっそう）</h4><p>更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病気は一層悪くなった。</span><br><span class="line">译：病情更加恶化了。</span><br></pre></td></tr></table></figure><h4 id="一般に（いっぱんに）"><a href="#一般に（いっぱんに）" class="headerlink" title="一般に（いっぱんに）"></a>一般に（いっぱんに）</h4><p>一般地、普遍地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一般にイギリス発祥とされるゴルフ。</span><br><span class="line">译：一般认为高尔夫的发祥地是英国。</span><br></pre></td></tr></table></figure><h4 id="いつまでも"><a href="#いつまでも" class="headerlink" title="いつまでも"></a>いつまでも</h4><p>永远；无论到何时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いつまでも友達でいましょう。</span><br><span class="line">译：永远是朋友。</span><br></pre></td></tr></table></figure><h4 id="いつも"><a href="#いつも" class="headerlink" title="いつも"></a>いつも</h4><p>总是；经常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いつもニコニコしていたら，嫌なことが寄り付きません。</span><br><span class="line">译：经常面带微笑的话，不好的事情就不会靠近哦。</span><br></pre></td></tr></table></figure><h3 id="お"><a href="#お" class="headerlink" title="お"></a>お</h3><h4 id="凡そ（およそ）"><a href="#凡そ（およそ）" class="headerlink" title="凡そ（およそ）"></a>凡そ（およそ）</h4><ol><li>大约</li><li>凡是</li><li>完全（用于否定）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：君の話は凡そ分かった。</span><br><span class="line">译：你的话我大概明白了。</span><br><span class="line"></span><br><span class="line">例：凡そ人間として生まれた以上…</span><br><span class="line">译：本来既然生而为人……</span><br><span class="line"></span><br><span class="line">例：政治とは凡そ縁がない。</span><br><span class="line">译：与政治全然无缘。</span><br></pre></td></tr></table></figure><h3 id="か"><a href="#か" class="headerlink" title="か"></a>か</h3><h4 id="がっかり"><a href="#がっかり" class="headerlink" title="がっかり"></a>がっかり</h4><ol><li>失望</li><li>筋疲力竭</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そんなにがっかりするな。</span><br><span class="line">译：别那么丧气呀。</span><br><span class="line"></span><br><span class="line">例：疲れてがっかりした。</span><br><span class="line">译：累得精疲力竭了。</span><br></pre></td></tr></table></figure><h4 id="必ず（かならず）"><a href="#必ず（かならず）" class="headerlink" title="必ず（かならず）"></a>必ず（かならず）</h4><p>一定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：必ず失敗する。</span><br><span class="line">译：必定要失败。</span><br></pre></td></tr></table></figure><h4 id="かなり"><a href="#かなり" class="headerlink" title="かなり"></a>かなり</h4><p>相当（出乎意料的那种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：かなりの距離。</span><br><span class="line">译：相当远的距离。</span><br><span class="line"></span><br><span class="line">例：あの人は日本語がかなりできる。</span><br><span class="line">译：那个人日语相当不错。</span><br></pre></td></tr></table></figure><h3 id="き"><a href="#き" class="headerlink" title="き"></a>き</h3><h4 id="きちんと"><a href="#きちんと" class="headerlink" title="きちんと"></a>きちんと</h4><ol><li>整整齐齐地，干干净净地</li><li>规规矩矩地，准确地</li><li>正好，正巧，正合适</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：料金はきちんと払ってある。</span><br><span class="line">译：钱已经如数付清。</span><br><span class="line"></span><br><span class="line">例：3時にきちんと集まる。</span><br><span class="line">译：3点准时集合。</span><br><span class="line"></span><br><span class="line">例：きちんとした字。</span><br><span class="line">译：工整的字。</span><br></pre></td></tr></table></figure><h4 id="きっと"><a href="#きっと" class="headerlink" title="きっと"></a>きっと</h4><p>一定（经常和だろう/でしょう一起使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：きっと合格できる。</span><br><span class="line">译：一定能合格。</span><br></pre></td></tr></table></figure><h4 id="極めて（きわめて）"><a href="#極めて（きわめて）" class="headerlink" title="極めて（きわめて）"></a>極めて（きわめて）</h4><p>极其</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：極めて簡単な問題である。</span><br><span class="line">译：是个极其简单的问题。</span><br></pre></td></tr></table></figure><h3 id="け"><a href="#け" class="headerlink" title="け"></a>け</h3><h4 id="結局（けっきょく）"><a href="#結局（けっきょく）" class="headerlink" title="結局（けっきょく）"></a>結局（けっきょく）</h4><p>到底，终究</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：結局だれがやるのか。</span><br><span class="line">译：到底谁来做呢？</span><br></pre></td></tr></table></figure><h4 id="結構（けっこう-）"><a href="#結構（けっこう-）" class="headerlink" title="結構（けっこう ）"></a>結構（けっこう ）</h4><p>相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私の日本語も結構通（つう）じたようだ。</span><br><span class="line">译：我的日语还算讲的通了。</span><br></pre></td></tr></table></figure><h4 id="決して（けっして）"><a href="#決して（けっして）" class="headerlink" title="決して（けっして）"></a>決して（けっして）</h4><p>决不~ 后要接否定使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：決して屈（く）しない。</span><br><span class="line">译：绝不屈服。</span><br></pre></td></tr></table></figure><h3 id="さ"><a href="#さ" class="headerlink" title="さ"></a>さ</h3><h4 id="さっき"><a href="#さっき" class="headerlink" title="さっき"></a>さっき</h4><p>刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：さっき帰ったばかりだ。</span><br><span class="line">译：刚刚才回来。</span><br></pre></td></tr></table></figure><h4 id="早速（さっそく-）"><a href="#早速（さっそく-）" class="headerlink" title="早速（さっそく ）"></a>早速（さっそく ）</h4><p>立刻，马上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：早速返事をくれた。</span><br><span class="line">译：很快给我了反馈。</span><br></pre></td></tr></table></figure><h4 id="さっぱり"><a href="#さっぱり" class="headerlink" title="さっぱり"></a>さっぱり</h4><p>清爽；干净；直爽；清单；不油腻；完全；精光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例：さっぱりした身なりをしている。</span><br><span class="line">译：打扮得干净利落。</span><br><span class="line"></span><br><span class="line">例：この料理はさっぱりしている。</span><br><span class="line">译：这个菜很清淡。</span><br><span class="line"></span><br><span class="line">例：約束のことはきれいさっぱりと忘れてしまった。</span><br><span class="line">译：早把约定忘得干干净净</span><br><span class="line"></span><br><span class="line">例：この映画はさっぱりおもしろくない。</span><br><span class="line">译：这个电影一点也不好看。</span><br><span class="line"></span><br><span class="line">例：どうもさっぱりだ。</span><br><span class="line">译：真糟糕。</span><br></pre></td></tr></table></figure><h3 id="し"><a href="#し" class="headerlink" title="し"></a>し</h3><h4 id="しっかり"><a href="#しっかり" class="headerlink" title="しっかり"></a>しっかり</h4><p>牢牢地；紧紧地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しっかりつかまる。</span><br><span class="line">译：牢牢抓住。</span><br></pre></td></tr></table></figure><h4 id="じっと"><a href="#じっと" class="headerlink" title="じっと"></a>じっと</h4><p>一动不动地；一声不响地，忍耐着，不出声；目不转睛地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：じっと見つめる。</span><br><span class="line">译：盯着看。</span><br><span class="line"></span><br><span class="line">例：じっとしていられない。</span><br><span class="line">译：坐立不安。</span><br></pre></td></tr></table></figure><h4 id="実は（じつは）"><a href="#実は（じつは）" class="headerlink" title="実は（じつは）"></a>実は（じつは）</h4><p>说真的，老实说，事实是，说实在的，其实，原来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：実は私にもよく分からない。</span><br><span class="line">译：说真的，我也不太明白。</span><br></pre></td></tr></table></figure><h4 id="しばらく"><a href="#しばらく" class="headerlink" title="しばらく"></a>しばらく</h4><p>暂时，不久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらく待ってくれ。 </span><br><span class="line">译：（你）给我等一会儿。</span><br></pre></td></tr></table></figure><p>一时的，暂且</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらく辛抱する。</span><br><span class="line">译：姑且忍耐一时。</span><br></pre></td></tr></table></figure><p>许久，好久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらくでしたね。</span><br><span class="line">译：好久不见呀。</span><br></pre></td></tr></table></figure><h4 id="充分（じゅうぶん）"><a href="#充分（じゅうぶん）" class="headerlink" title="充分（じゅうぶん）"></a>充分（じゅうぶん）</h4><p>充分的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：自分の力を充分発揮する。</span><br><span class="line">译：充分发挥自己的才能。</span><br></pre></td></tr></table></figure><h3 id="す"><a href="#す" class="headerlink" title="す"></a>す</h3><h4 id="ずいぶん"><a href="#ずいぶん" class="headerlink" title="ずいぶん"></a>ずいぶん</h4><p>相当厉害；非常，很；颇，相当；特别；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病人は熱のためにずいぶん苦しんでいる。</span><br><span class="line">译：病人因发烧很难受。</span><br></pre></td></tr></table></figure><p>好久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ずいぶん捜した。</span><br><span class="line">译：找了好久。</span><br></pre></td></tr></table></figure><h4 id="すぐ"><a href="#すぐ" class="headerlink" title="すぐ"></a>すぐ</h4><p>立刻；马上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すぐ出かけましょう。</span><br><span class="line">译：马上出门吧。</span><br></pre></td></tr></table></figure><h4 id="すこし"><a href="#すこし" class="headerlink" title="すこし"></a>すこし</h4><p>一点点；稍微</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：少し疲れました。</span><br><span class="line">译：有点累了。</span><br></pre></td></tr></table></figure><h4 id="すっかり"><a href="#すっかり" class="headerlink" title="すっかり"></a>すっかり</h4><p>完全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すっかり忘れていた。</span><br><span class="line">译：全忘了。</span><br></pre></td></tr></table></figure><h4 id="ずっと"><a href="#ずっと" class="headerlink" title="ずっと"></a>ずっと</h4><p>一直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今朝からずっと待っていた。</span><br><span class="line">译：从今天早晨一直等到现在。</span><br></pre></td></tr></table></figure><p>远比…..更</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼の方がずっといい。</span><br><span class="line">译：他的方法好得多。</span><br></pre></td></tr></table></figure><p>径直（走）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ずっと前へ進み出た。</span><br><span class="line">译：径直走到前面。</span><br></pre></td></tr></table></figure><h4 id="すべて"><a href="#すべて" class="headerlink" title="すべて"></a>すべて</h4><p>全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題はすべて解決した。</span><br><span class="line">译：问题全部解决了。</span><br></pre></td></tr></table></figure><h3 id="せ"><a href="#せ" class="headerlink" title="せ"></a>せ</h3><h4 id="せっかく"><a href="#せっかく" class="headerlink" title="せっかく"></a>せっかく</h4><p>难得，好不容易</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：せっかく晩ご飯を作ったのに、みんなは外食にするなんて。</span><br><span class="line">译：我特意做了晚饭，大家却在外面吃饭。</span><br></pre></td></tr></table></figure><h4 id="ぜったい"><a href="#ぜったい" class="headerlink" title="ぜったい"></a>ぜったい</h4><p>绝对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ぜったい間違いない。</span><br><span class="line">译：绝对没有错。</span><br></pre></td></tr></table></figure><h4 id="ぜひ"><a href="#ぜひ" class="headerlink" title="ぜひ"></a>ぜひ</h4><p>一定；务必</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ぜひ遊びに来てね。</span><br><span class="line">译：一定要来玩哦。</span><br></pre></td></tr></table></figure><h4 id="全然（ぜんぜん）"><a href="#全然（ぜんぜん）" class="headerlink" title="全然（ぜんぜん）"></a>全然（ぜんぜん）</h4><p>一点也不…..（后接否定，表全否）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：全然興味がない。</span><br><span class="line">译：完全没了兴趣。</span><br></pre></td></tr></table></figure><h4 id="全部（ぜんぶ）"><a href="#全部（ぜんぶ）" class="headerlink" title="全部（ぜんぶ）"></a>全部（ぜんぶ）</h4><p>全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題は全部解決ずみだ。</span><br><span class="line">译：问题已经全部解决。</span><br></pre></td></tr></table></figure><h3 id="そ"><a href="#そ" class="headerlink" title="そ"></a>そ</h3><h4 id="相当（そうとう）"><a href="#相当（そうとう）" class="headerlink" title="相当（そうとう）"></a>相当（そうとう）</h4><p>相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日は相当（に）寒いです。</span><br><span class="line">译：今天相当的冷呀。</span><br></pre></td></tr></table></figure><h4 id="そろそろ"><a href="#そろそろ" class="headerlink" title="そろそろ"></a>そろそろ</h4><p>就要，快要；不久；时间差不多了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：もうそろそろ晚飯だ。</span><br><span class="line">译：就要吃晚饭了。</span><br></pre></td></tr></table></figure><p>渐渐；逐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そろそろ（と）寒くなってきた。</span><br><span class="line">译：渐渐地冷起来了。</span><br></pre></td></tr></table></figure><p>慢慢地；徐徐地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そろそろと歩く。</span><br><span class="line">译：慢慢地走。</span><br></pre></td></tr></table></figure><h4 id="それぞれ"><a href="#それぞれ" class="headerlink" title="それぞれ"></a>それぞれ</h4><p>各自；分别；各个；每个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：それぞれ別の道を行く。</span><br><span class="line">译：各走各的路。</span><br></pre></td></tr></table></figure><h4 id="それほど"><a href="#それほど" class="headerlink" title="それほど"></a>それほど</h4><p>那么，那样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語はそれほど難しくありません。</span><br><span class="line">译：语并不是那么难。</span><br></pre></td></tr></table></figure><h3 id="た"><a href="#た" class="headerlink" title="た"></a>た</h3><h4 id="だんだん"><a href="#だんだん" class="headerlink" title="だんだん"></a>だんだん</h4><p>渐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：だんだん秋めいてきた。</span><br><span class="line">译：渐有秋意了。</span><br></pre></td></tr></table></figure><h4 id="たまに"><a href="#たまに" class="headerlink" title="たまに"></a>たまに</h4><p>偶尔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たまにはご両親に電話を掛けなさい。</span><br><span class="line">译：偶尔请给你父母打个电话。</span><br></pre></td></tr></table></figure><h4 id="多分（たぶん）"><a href="#多分（たぶん）" class="headerlink" title="多分（たぶん）"></a>多分（たぶん）</h4><p>大概（经常和でしょう/だろう一起使用，表示推测，大概….）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼が言うことは多分本当だろう。</span><br><span class="line">译：他说的大概是真的吧！</span><br></pre></td></tr></table></figure><h4 id="大体（だいたい）"><a href="#大体（だいたい）" class="headerlink" title="大体（だいたい）"></a>大体（だいたい）</h4><p>大体上；大概</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大体以下のように規定する。</span><br><span class="line">译：大致规定如下。</span><br></pre></td></tr></table></figure><p>基本上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大体できた。 </span><br><span class="line">译：基本上完成了。</span><br></pre></td></tr></table></figure><h4 id="たいてい"><a href="#たいてい" class="headerlink" title="たいてい"></a>たいてい</h4><p>大致上，大都，差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題はたいてい出来た。</span><br><span class="line">译：问题大都产生了。</span><br></pre></td></tr></table></figure><p>大概，恐怕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たいてい大丈夫だろう。</span><br><span class="line">译：大概没问题吧。</span><br></pre></td></tr></table></figure><h4 id="たくさん"><a href="#たくさん" class="headerlink" title="たくさん"></a>たくさん</h4><p>许多（后接名词时要加の例：たくさんの人 动词可直接接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たくさんの人。</span><br><span class="line">译：很多人。</span><br></pre></td></tr></table></figure><h4 id="確か（たしか）"><a href="#確か（たしか）" class="headerlink" title="確か（たしか）"></a>確か（たしか）</h4><p>似乎，大概，表示根据记忆有相当把握的推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：確か2000円でした。</span><br><span class="line">译：要是没错，那是二千日元。</span><br></pre></td></tr></table></figure><h4 id="たとえ"><a href="#たとえ" class="headerlink" title="たとえ"></a>たとえ</h4><p>即使</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たとえ負けても後悔しない。</span><br><span class="line">译：即使输了也不后悔。</span><br></pre></td></tr></table></figure><h4 id="例えば（たとえば）"><a href="#例えば（たとえば）" class="headerlink" title="例えば（たとえば）"></a>例えば（たとえば）</h4><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：スポーツ，例えばバレーボールや卓球などをなさいますか。</span><br><span class="line">译：体育活动，例如排球、乒乓球，你参加吗？</span><br></pre></td></tr></table></figure><h3 id="ち"><a href="#ち" class="headerlink" title="ち"></a>ち</h3><h4 id="ちゃんと"><a href="#ちゃんと" class="headerlink" title="ちゃんと"></a>ちゃんと</h4><p>好好地；踏踏实实地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちゃんと仕事をする。</span><br><span class="line">译：踏踏实实地工作。</span><br></pre></td></tr></table></figure><p>整整齐齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：物をちゃんとかたづける。</span><br><span class="line">译：把东西收拾好。</span><br></pre></td></tr></table></figure><p>确实；的确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わたしがちゃんと見た。</span><br><span class="line">译：我确实看见了。</span><br></pre></td></tr></table></figure><h4 id="ちょうど"><a href="#ちょうど" class="headerlink" title="ちょうど"></a>ちょうど</h4><p>刚好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど居合わせる。</span><br><span class="line">译：正好在场。</span><br></pre></td></tr></table></figure><p>宛如，好像，恰似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど絵のようだ。</span><br><span class="line">译：好像一幅画。</span><br></pre></td></tr></table></figure><p>正，整。完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど８時。</span><br><span class="line">译：八点整。</span><br></pre></td></tr></table></figure><h4 id="ちょっと"><a href="#ちょっと" class="headerlink" title="ちょっと"></a>ちょっと</h4><p>一会儿，一下；表示数量不多，程度不深，时间很短等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと待ってください。</span><br><span class="line">译：请稍等一下。</span><br></pre></td></tr></table></figure><p>相当，颇。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと名の通った人</span><br><span class="line">译：颇有名望的人</span><br></pre></td></tr></table></figure><p>不太容易，表示没那么简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっとわからない。</span><br><span class="line">译：不太明白。</span><br></pre></td></tr></table></figure><p>试试，看看，以轻松的心情事做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと行ってくる。</span><br><span class="line">译：去去就来。</span><br></pre></td></tr></table></figure><h3 id="つ"><a href="#つ" class="headerlink" title="つ"></a>つ</h3><h4 id="ついでに"><a href="#ついでに" class="headerlink" title="ついでに"></a>ついでに</h4><p>顺便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：散歩のついでに、お菓子を買ってきた。</span><br><span class="line">译：去散步，顺便买来了点心。</span><br></pre></td></tr></table></figure><h4 id="ついに"><a href="#ついに" class="headerlink" title="ついに"></a>ついに</h4><p>终于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ついに出来上がった。</span><br><span class="line">译：终于完成了。</span><br></pre></td></tr></table></figure><p>直到最后（也不）；始终（不）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ついに会わずじまいだ。</span><br><span class="line">译：直到最后也未能见面。</span><br></pre></td></tr></table></figure><h4 id="次々（つぎつぎ）"><a href="#次々（つぎつぎ）" class="headerlink" title="次々（つぎつぎ）"></a>次々（つぎつぎ）</h4><p>连续不断、络绎不绝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：次々に仕掛け花火が打ち上げられる。</span><br><span class="line">译：一个接一个地放起烟火。</span><br></pre></td></tr></table></figure><h4 id="常に（つねに）"><a href="#常に（つねに）" class="headerlink" title="常に（つねに）"></a>常に（つねに）</h4><p>经常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：常にあることだ。</span><br><span class="line">译：常有的事。</span><br></pre></td></tr></table></figure><h4 id="つまり"><a href="#つまり" class="headerlink" title="つまり"></a>つまり</h4><p>总之，归根究底</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：つまり君は何を言いたいのか。</span><br><span class="line">译：究竟你想说什么呢？</span><br></pre></td></tr></table></figure><h3 id="て"><a href="#て" class="headerlink" title="て"></a>て</h3><h4 id="できるだけ"><a href="#できるだけ" class="headerlink" title="できるだけ"></a>できるだけ</h4><p>尽量地；尽可能地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：できるだけのことをする。</span><br><span class="line">译：尽力而为。</span><br></pre></td></tr></table></figure><h3 id="と"><a href="#と" class="headerlink" title="と"></a>と</h3><h4 id="どう"><a href="#どう" class="headerlink" title="どう"></a>どう</h4><p>如何；怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：それはどういうわけだ。</span><br><span class="line">译：那是为什么呢？</span><br><span class="line"></span><br><span class="line">例：もう一杯どう。 </span><br><span class="line">译：再来一杯怎么样？</span><br></pre></td></tr></table></figure><h4 id="どうか"><a href="#どうか" class="headerlink" title="どうか"></a>どうか</h4><p>请；务必</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あのことはどうかなるだろう。</span><br><span class="line">译：那件事总会有办法的吧。</span><br></pre></td></tr></table></figure><p>礼貌用语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうかよろしくお願いします。</span><br><span class="line">译：请多关照。</span><br></pre></td></tr></table></figure><p>不正常；异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は今日にどうかしている。</span><br><span class="line">译：他今天与往常不一样。</span><br></pre></td></tr></table></figure><p>怎么回事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：それはどうか分からない。</span><br><span class="line">译：不明白那是怎么回事。</span><br></pre></td></tr></table></figure><h4 id="どうして"><a href="#どうして" class="headerlink" title="どうして"></a>どうして</h4><p>为什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日はどうして学校を休みましたか。</span><br><span class="line">译：今天怎么没来上学呀。</span><br></pre></td></tr></table></figure><p>怎么样，怎么办，如何。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この機械をどうして動かすか教えてほしい。</span><br><span class="line">译：希望教给我怎样开动这个机器。</span><br></pre></td></tr></table></figure><p>岂止，岂料，意外，相反</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やさしそうに見えるが，どうして，なかなか気が強い。 </span><br><span class="line">译：看上去像很温柔，其实刚强得很。</span><br></pre></td></tr></table></figure><p>唉呀唉呀。出乎意料时表示吃惊或感叹的词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうして，たいした人気だ。</span><br><span class="line">译：唉呀唉呀，真红得不得了。</span><br></pre></td></tr></table></figure><h4 id="当然（とうぜん）"><a href="#当然（とうぜん）" class="headerlink" title="当然（とうぜん）"></a>当然（とうぜん）</h4><p>当然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：謝るのが当然だ。</span><br><span class="line">译：道歉是应当的。</span><br></pre></td></tr></table></figure><h4 id="ときどき"><a href="#ときどき" class="headerlink" title="ときどき"></a>ときどき</h4><p>偶尔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ときどき外食する。</span><br><span class="line">译：偶尔再外面吃饭。</span><br></pre></td></tr></table></figure><h4 id="とても"><a href="#とても" class="headerlink" title="とても"></a>とても</h4><p>非常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日はとても寒いです。</span><br><span class="line">译：今天非常的冷呀。</span><br></pre></td></tr></table></figure><h4 id="とにかく"><a href="#とにかく" class="headerlink" title="とにかく"></a>とにかく</h4><p>总之</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：とにかく仕事を続けたくない。</span><br><span class="line">译：总之我不想继续工作了。</span><br></pre></td></tr></table></figure><h4 id="ともに"><a href="#ともに" class="headerlink" title="ともに"></a>ともに</h4><p>一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：学友とともに恩師を訪ねる。 </span><br><span class="line">译：和学友一同访问恩师。</span><br></pre></td></tr></table></figure><p>同时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：残念であるとともに、くやしくも思う。</span><br><span class="line">译：感到遗憾的同时，也很悔恨。</span><br></pre></td></tr></table></figure><h4 id="どうぞ"><a href="#どうぞ" class="headerlink" title="どうぞ"></a>どうぞ</h4><p>请</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はい，どうぞ。</span><br><span class="line">译：请。</span><br></pre></td></tr></table></figure><p>礼貌用语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうぞよろしく。</span><br><span class="line">译：请多关照。</span><br></pre></td></tr></table></figure><h4 id="特に（とくに）"><a href="#特に（とくに）" class="headerlink" title="特に（とくに）"></a>特に（とくに）</h4><p>特别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：特に注意すべき点。</span><br><span class="line">译：应特别注意的地方。</span><br></pre></td></tr></table></figure><h3 id="な"><a href="#な" class="headerlink" title="な"></a>な</h3><h4 id="なお"><a href="#なお" class="headerlink" title="なお"></a>なお</h4><p>更加，愈发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：薬を飲んで、なお悪くなった。</span><br><span class="line">译：吃了药更加不好了。</span><br></pre></td></tr></table></figure><p>犹，尚，还，仍然，依然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今もなお夢中している。</span><br><span class="line">译：现在也仍然非常热衷。</span><br></pre></td></tr></table></figure><p>此外（接续）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なお、詳しいことは後で話します。</span><br><span class="line">译：此外，具体事宜稍后再谈。</span><br></pre></td></tr></table></figure><h4 id="なかなか"><a href="#なかなか" class="headerlink" title="なかなか"></a>なかなか</h4><p>后接形容词时表肯定：相当<br>后接动词ない型时：轻易(不)，怎么也….，表示动作很难完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：去年の冬はなかなか寒かったですね。</span><br><span class="line">译：去年冬天相当的冷呀。</span><br><span class="line"></span><br><span class="line">例：なかなか怒らない。</span><br><span class="line">译：轻易不生气。</span><br></pre></td></tr></table></figure><h4 id="なるべく"><a href="#なるべく" class="headerlink" title="なるべく"></a>なるべく</h4><p>尽量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なるべくなら明日来ていただけませんか。</span><br><span class="line">译：可能的话，请明天来怎么样？</span><br></pre></td></tr></table></figure><h4 id="なるほど"><a href="#なるほど" class="headerlink" title="なるほど"></a>なるほど</h4><p>诚然，的确；果然；怪不得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なるほど美しい人だ。</span><br><span class="line">译：的确是个美人。</span><br></pre></td></tr></table></figure><h4 id="なんとなく"><a href="#なんとなく" class="headerlink" title="なんとなく"></a>なんとなく</h4><p>不知为何，总觉得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：先輩の前では、なんとなく気兼ねする。</span><br><span class="line">译：在老前辈面前总觉得拘束。</span><br></pre></td></tr></table></figure><p>无意中，不自主地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なんとなく、口を滑らせてしまった。</span><br><span class="line">译：无意中说漏了嘴。</span><br></pre></td></tr></table></figure><h3 id="は"><a href="#は" class="headerlink" title="は"></a>は</h3><h4 id="はっきり"><a href="#はっきり" class="headerlink" title="はっきり"></a>はっきり</h4><p>清楚；明白</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はっきりと見える。</span><br><span class="line">译：清晰可见。</span><br></pre></td></tr></table></figure><h4 id="ばらばら"><a href="#ばらばら" class="headerlink" title="ばらばら"></a>ばらばら</h4><p>零散；散乱（形容动词）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ばらばらの髪の毛。</span><br><span class="line">译：披散的头发。</span><br></pre></td></tr></table></figure><p>忽地跳出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：悪漢共がばらばらと現れた。</span><br><span class="line">译：坏蛋们忽地跳了出来。</span><br></pre></td></tr></table></figure><p>哗啦啦的雨声</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大粒の雨がばらばらと降り出した。</span><br><span class="line">译：大雨点哗啦哗啦地下了起来。</span><br></pre></td></tr></table></figure><h3 id="ひ"><a href="#ひ" class="headerlink" title="ひ"></a>ひ</h3><h4 id="非常に（ひじょうに）"><a href="#非常に（ひじょうに）" class="headerlink" title="非常に（ひじょうに）"></a>非常に（ひじょうに）</h4><p>非常地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：血糖値が非常に高い。</span><br><span class="line">译：血糖值非常高。</span><br></pre></td></tr></table></figure><h4 id="びっくり"><a href="#びっくり" class="headerlink" title="びっくり"></a>びっくり</h4><p>吓一跳；吃惊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：びっくり仰天する。</span><br><span class="line">译：大吃一惊。</span><br></pre></td></tr></table></figure><h3 id="ほ"><a href="#ほ" class="headerlink" title="ほ"></a>ほ</h3><h4 id="ほとんど"><a href="#ほとんど" class="headerlink" title="ほとんど"></a>ほとんど</h4><p>几乎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ほとんど眠れなかった。</span><br><span class="line">译：几乎没有睡。</span><br></pre></td></tr></table></figure><p>大部分；大概；大致；大体上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：古い建物はほとんど取り払われた。</span><br><span class="line">译：旧房子差不多都拆掉了。</span><br></pre></td></tr></table></figure><h3 id="ま"><a href="#ま" class="headerlink" title="ま"></a>ま</h3><h4 id="まあまあ"><a href="#まあまあ" class="headerlink" title="まあまあ"></a>まあまあ</h4><p>一般般，尚可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まあまあいいだろう。</span><br><span class="line">译：还算可以吧。</span><br></pre></td></tr></table></figure><h4 id="また"><a href="#また" class="headerlink" title="また"></a>また</h4><p>又；再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：またにしましょう。</span><br><span class="line">译：改天再说〔去,来,做〕吧；下次再说吧！</span><br></pre></td></tr></table></figure><h4 id="まだ"><a href="#まだ" class="headerlink" title="まだ"></a>まだ</h4><p>还</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ完成していない。</span><br><span class="line">译：尚未完成。</span><br></pre></td></tr></table></figure><p>还，仍旧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ会議中だ。</span><br><span class="line">译：会议还在进行中。</span><br></pre></td></tr></table></figure><p>才，仅，刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ作ったばかりだ。</span><br><span class="line">译：刚刚做完。</span><br></pre></td></tr></table></figure><p>还，更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：理由はまだある。</span><br><span class="line">译：理由还有。</span><br></pre></td></tr></table></figure><p>还，还好，还算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このほうがまだましだ。</span><br><span class="line">译：这样还算好。</span><br></pre></td></tr></table></figure><h4 id="まっすぐ"><a href="#まっすぐ" class="headerlink" title="まっすぐ"></a>まっすぐ</h4><p>笔直；径直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに見る。</span><br><span class="line">译：直向前看。</span><br></pre></td></tr></table></figure><p>一直；照直；不绕弯；直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに家に帰る。</span><br><span class="line">译：直接回家。</span><br></pre></td></tr></table></figure><p>正直；坦率；耿直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに白状する。</span><br><span class="line">译：老实供认；坦白交代。</span><br></pre></td></tr></table></figure><h4 id="まったく"><a href="#まったく" class="headerlink" title="まったく"></a>まったく</h4><p>完全地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まったく健康になった。</span><br><span class="line">译：完全康复。</span><br></pre></td></tr></table></figure><p>全然；完全（否定）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お酒はまったく飲まない。</span><br><span class="line">译：全然不喝酒。</span><br></pre></td></tr></table></figure><p>真，实在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まったく困ったものだ。</span><br><span class="line">译：真难办。</span><br></pre></td></tr></table></figure><h4 id="ますます"><a href="#ますます" class="headerlink" title="ますます"></a>ますます</h4><p>越来越……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ますます元気になった。</span><br><span class="line">译：越来越有精神了。</span><br></pre></td></tr></table></figure><h4 id="間も無く（まもなく）"><a href="#間も無く（まもなく）" class="headerlink" title="間も無く（まもなく）"></a>間も無く（まもなく）</h4><p>马上就要……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：間も無く春休みがやって来る。</span><br><span class="line">译：春假不久就会来到。</span><br></pre></td></tr></table></figure><h4 id="まるで"><a href="#まるで" class="headerlink" title="まるで"></a>まるで</h4><p>简直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まるで違う。</span><br><span class="line">译：完全不一样。</span><br></pre></td></tr></table></figure><p>好像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まるで夢のようだ。</span><br><span class="line">译：好像做梦一样。</span><br></pre></td></tr></table></figure><h3 id="め"><a href="#め" class="headerlink" title="め"></a>め</h3><h4 id="めったに"><a href="#めったに" class="headerlink" title="めったに"></a>めったに</h4><p>（后接否定）几乎（不）……很（少），（不）常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：めったに怒らない。</span><br><span class="line">译：很少发火。</span><br></pre></td></tr></table></figure><h4 id="めっきり"><a href="#めっきり" class="headerlink" title="めっきり"></a>めっきり</h4><p>显著，急剧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病人はめっきりよくなってきた。</span><br><span class="line">译：病人明显好转了。</span><br></pre></td></tr></table></figure><h3 id="も"><a href="#も" class="headerlink" title="も"></a>も</h3><h4 id="もう"><a href="#もう" class="headerlink" title="もう"></a>もう</h4><p>已经</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：当地に来てもう半月になった。</span><br><span class="line">译：来到此地已经半个月了。</span><br></pre></td></tr></table></figure><h4 id="もし"><a href="#もし" class="headerlink" title="もし"></a>もし</h4><p>如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：もし彼が来たら，またせておいてください。</span><br><span class="line">译：要是他来了，请让他等一下。</span><br></pre></td></tr></table></figure><h4 id="もっと"><a href="#もっと" class="headerlink" title="もっと"></a>もっと</h4><p>更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：リンゴをもっとください。</span><br><span class="line">译：再给些苹果吧。</span><br></pre></td></tr></table></figure><h4 id="最も（もっとも）"><a href="#最も（もっとも）" class="headerlink" title="最も（もっとも）"></a>最も（もっとも）</h4><p>最</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：最もよい。</span><br><span class="line">译：最好。</span><br></pre></td></tr></table></figure><h3 id="や"><a href="#や" class="headerlink" title="や"></a>や</h3><h4 id="やがて"><a href="#やがて" class="headerlink" title="やがて"></a>やがて</h4><p>不久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やがて夜になった。</span><br><span class="line">译：天不久就黑了。</span><br></pre></td></tr></table></figure><p>大约，大致，差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やがて小１時間になる。</span><br><span class="line">译：差不多过了一个小时。</span><br></pre></td></tr></table></figure><h4 id="約（やく）"><a href="#約（やく）" class="headerlink" title="約（やく）"></a>約（やく）</h4><p>大约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：約4時間。</span><br><span class="line">译：约四小时。</span><br></pre></td></tr></table></figure><h4 id="やっと"><a href="#やっと" class="headerlink" title="やっと"></a>やっと</h4><p>好不容易；终于；总算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：終電にやっと間に合った。</span><br><span class="line">译：好不容易赶上了末班电车。</span><br></pre></td></tr></table></figure><p>勉勉强强；刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やっとでき上がった。</span><br><span class="line">译：好不容易才完成了。</span><br></pre></td></tr></table></figure><h4 id="やはり"><a href="#やはり" class="headerlink" title="やはり"></a>やはり</h4><p>果然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：注意したが、やはりミスがある。</span><br><span class="line">译：虽然注意了，但还是有错。</span><br></pre></td></tr></table></figure><p>虽然…仍旧…。归根到底仍然是最初预测的结论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やはり女がいた。 </span><br><span class="line">译：果然在外边有了女人。</span><br></pre></td></tr></table></figure><p>依然，仍旧。情况和以前一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今でも、やはり昔のままになっている。 </span><br><span class="line">译：即使到了现在，（它）仍旧保留着原来的风貌。</span><br></pre></td></tr></table></figure><h3 id="ゆ"><a href="#ゆ" class="headerlink" title="ゆ"></a>ゆ</h3><h4 id="ゆっくり"><a href="#ゆっくり" class="headerlink" title="ゆっくり"></a>ゆっくり</h4><p>慢慢地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ご飯をゆっくり食べる。</span><br><span class="line">译：慢慢地吃饭。</span><br></pre></td></tr></table></figure><p>有余地，宽敞舒适，充裕，舒畅，安静，舒适</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いまからでもゆっくり間に合う。</span><br><span class="line">译：即使从现在起也还来得及。</span><br></pre></td></tr></table></figure><h3 id="よ"><a href="#よ" class="headerlink" title="よ"></a>よ</h3><h4 id="ようやく"><a href="#ようやく" class="headerlink" title="ようやく"></a>ようやく</h4><p>终于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく試験が終わった。</span><br><span class="line">译：考试终于结束了。</span><br></pre></td></tr></table></figure><p>勉强，好不容易，总算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく間に合った。</span><br><span class="line">译：总算赶上了。</span><br></pre></td></tr></table></figure><p>渐渐，逐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく春らしくなってきた。</span><br><span class="line">译：渐渐有点春意了。</span><br></pre></td></tr></table></figure><h4 id="よほど"><a href="#よほど" class="headerlink" title="よほど"></a>よほど</h4><p>很，颇，相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：よほど自信があるのだろう。</span><br><span class="line">译：很有自信吧！</span><br></pre></td></tr></table></figure><p>差一点就…..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：よほど帰ろうかと思った。</span><br><span class="line">译：差点想回去。</span><br></pre></td></tr></table></figure><h3 id="わ"><a href="#わ" class="headerlink" title="わ"></a>わ</h3><h4 id="割合（わりあい）"><a href="#割合（わりあい）" class="headerlink" title="割合（わりあい）"></a>割合（わりあい）</h4><p>比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この子は割合と勉強する。</span><br><span class="line">译：这个孩子比较用功。</span><br></pre></td></tr></table></figure><h4 id="わざと"><a href="#わざと" class="headerlink" title="わざと"></a>わざと</h4><p>故意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わざと聞こえないふりにする。</span><br><span class="line">译：故意装作听不见。</span><br></pre></td></tr></table></figure><h4 id="わざわざ"><a href="#わざわざ" class="headerlink" title="わざわざ"></a>わざわざ</h4><p>特意地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そのために、わざわざ来たのだ。 </span><br><span class="line">译：为此特意过来的。</span><br></pre></td></tr></table></figure><p>故意地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わざわざいたずら書きをする。</span><br><span class="line">译：故意乱涂乱画。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之(形助副)词&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-动词变形</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/"/>
    <id>/2024/06/11/日语-动词变形/</id>
    <published>2024-06-11T03:09:46.000Z</published>
    <updated>2024-06-11T03:25:52.011Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之动词变形<br><a id="more"></a></p><h1 id="ます形"><a href="#ます形" class="headerlink" title="ます形"></a>ます形</h1><h2 id="变形规则："><a href="#变形规则：" class="headerlink" title="变形规则："></a>变形规则：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　い段＋ます</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ます</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　きます</span><br><span class="line">  サ变动词：する　ー＞　します</span><br></pre></td></tr></table></figure><h2 id="文法："><a href="#文法：" class="headerlink" title="文法："></a>文法：</h2><h3 id="1-ます形本身就是动词的敬语形态"><a href="#1-ます形本身就是动词的敬语形态" class="headerlink" title="1. ます形本身就是动词的敬语形态"></a>1. ます形本身就是动词的敬语形态</h3><h3 id="2-ますー＞ましょう-ましょうか-劝诱-积极主动为对方做某事"><a href="#2-ますー＞ましょう-ましょうか-劝诱-积极主动为对方做某事" class="headerlink" title="2. ますー＞ましょう/ましょうか　劝诱/积极主动为对方做某事"></a>2. ますー＞ましょう/ましょうか　劝诱/积极主动为对方做某事</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：一緒にビールを飲みましょ！</span><br><span class="line">译：一起去喝啤酒吧！</span><br><span class="line"></span><br><span class="line">例：傘を貸しましょうか？</span><br><span class="line">译：可以把伞借给我吗？</span><br></pre></td></tr></table></figure><h3 id="3-ますー＞ませんか-更有礼貌的询问对方"><a href="#3-ますー＞ませんか-更有礼貌的询问对方" class="headerlink" title="3. ますー＞ませんか　更有礼貌的询问对方"></a>3. ますー＞ませんか　更有礼貌的询问对方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あのシャツはありませんか？</span><br><span class="line">译：那件衬衫还有吗？</span><br></pre></td></tr></table></figure><h3 id="4-ます形可直接修饰名词"><a href="#4-ます形可直接修饰名词" class="headerlink" title="4. ます形可直接修饰名词"></a>4. ます形可直接修饰名词</h3><ul><li>做……的方法 ます形+方（かた）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：漢字の読み方</span><br><span class="line">译：汉字的读法</span><br></pre></td></tr></table></figure><h3 id="5-ます形＋ながら＋句子2-一边做……一般做……强调后面的动作"><a href="#5-ます形＋ながら＋句子2-一边做……一般做……强调后面的动作" class="headerlink" title="5. ます形＋ながら＋句子2  一边做……一般做……强调后面的动作"></a>5. ます形＋ながら＋句子2  一边做……一般做……强调后面的动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：音楽を聴きながら食事します。</span><br><span class="line">译：一边听音乐一边吃饭。</span><br></pre></td></tr></table></figure><h3 id="6-ます形-形容词去い-形容动词＋すぎる-过度做……-超过许可范围-不好的事情"><a href="#6-ます形-形容词去い-形容动词＋すぎる-过度做……-超过许可范围-不好的事情" class="headerlink" title="6. ます形/形容词去い/形容动词＋すぎる　过度做……, 超过许可范围, 不好的事情"></a>6. ます形/形容词去い/形容动词＋すぎる　过度做……, 超过许可范围, 不好的事情</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：働きすぎる。</span><br><span class="line">译：过度工作</span><br><span class="line"></span><br><span class="line">例：最近の車は操作が簡単すぎて、運転がおもしくないです。</span><br><span class="line">译：最近的车操作起来太简单了，都没有驾驶乐趣了。</span><br></pre></td></tr></table></figure><h3 id="7-ます形-形容词去い-形容动词＋そうです-样态助动词-看起来好像……"><a href="#7-ます形-形容词去い-形容动词＋そうです-样态助动词-看起来好像……" class="headerlink" title="7. ます形/形容词去い/形容动词＋そうです(样态助动词)　看起来好像……"></a>7. ます形/形容词去い/形容动词＋そうです(样态助动词)　看起来好像……</h3><p><em>特殊变形词语: いいー＞よさ　ないー＞なさ</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：今にも雨が降りそうです。</span><br><span class="line">译：今天看起好像要下雨了。</span><br><span class="line"></span><br><span class="line">例：その料理は辛そうです。</span><br><span class="line">译：这个料理看起来很辣的样子。</span><br><span class="line"></span><br><span class="line">例：この机は丈夫そうです。</span><br><span class="line">译：这张桌子看起来很结实。</span><br></pre></td></tr></table></figure><h3 id="8-ます形＋やすいです-客观觉得容易……"><a href="#8-ます形＋やすいです-客观觉得容易……" class="headerlink" title="8. ます形＋やすいです　客观觉得容易……"></a>8. ます形＋やすいです　客观觉得容易……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このパソコンは使いやすいです。</span><br><span class="line">译：这台电脑很容易使用。</span><br></pre></td></tr></table></figure><h3 id="9-ます形＋にくいです-客观觉得难……"><a href="#9-ます形＋にくいです-客观觉得难……" class="headerlink" title="9. ます形＋にくいです　客观觉得难……"></a>9. ます形＋にくいです　客观觉得难……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このカープは割れにくくて、安全ですよ。</span><br><span class="line">译：这个杯子很难裂开，很安全哟。</span><br></pre></td></tr></table></figure><h3 id="10-ます形＋がたいです-主观觉得难……-认知类-说话类的词语-书面语"><a href="#10-ます形＋がたいです-主观觉得难……-认知类-说话类的词语-书面语" class="headerlink" title="10. ます形＋がたいです　主观觉得难……　(认知类, 说话类的词语, 书面语)"></a>10. ます形＋がたいです　主观觉得难……　(认知类, 说话类的词语, 书面语)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この宿題はやりがたいです。</span><br><span class="line">译：这道题做起来很难。</span><br></pre></td></tr></table></figure><h3 id="11-ます形＋かねる-难以……-郑重书面语-与敬语连用"><a href="#11-ます形＋かねる-难以……-郑重书面语-与敬语连用" class="headerlink" title="11. ます形＋かねる　难以……　(郑重书面语, 与敬语连用)"></a>11. ます形＋かねる　难以……　(郑重书面语, 与敬语连用)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと断りかねる</span><br><span class="line">译：难以拒绝</span><br></pre></td></tr></table></figure><h1 id="た形"><a href="#た形" class="headerlink" title="た形"></a>た形</h1><h2 id="变形规则"><a href="#变形规则" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">    く、ぐ　ー＞　いた、いだ</span><br><span class="line">        特例：いく　ー＞　行った</span><br><span class="line">    う、つ、る　ー＞　った</span><br><span class="line">    ぬ、ぶ、む　ー＞　んだ</span><br><span class="line">    す　ー＞　した</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋た</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　きた</span><br><span class="line">    サ变动次：する　ー＞　した</span><br><span class="line"></span><br><span class="line">形容词：去掉 い+かった</span><br><span class="line">    ~かったり、～かったりです　既……又……</span><br><span class="line"></span><br><span class="line">形容动词：词语+だった</span><br><span class="line">    ~だったり、～だったりです　既……又……</span><br></pre></td></tr></table></figure><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h3 id="1-动词-形容词-形容动词的た形表示动词的简体过去式"><a href="#1-动词-形容词-形容动词的た形表示动词的简体过去式" class="headerlink" title="1. 动词/形容词/形容动词的た形表示动词的简体过去式"></a>1. 动词/形容词/形容动词的た形表示动词的简体过去式</h3><h3 id="2-～たことがあります-有过……的经历"><a href="#2-～たことがあります-有过……的经历" class="headerlink" title="2. ～たことがあります　有过……的经历"></a>2. ～たことがあります　有过……的经历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は日本へ行ったことがあります。</span><br><span class="line">译：我去过日本。</span><br></pre></td></tr></table></figure><h3 id="3-～たり、～たり-交替，反复的动作"><a href="#3-～たり、～たり-交替，反复的动作" class="headerlink" title="3. ～たり、～たり　交替，反复的动作"></a>3. ～たり、～たり　交替，反复的动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は歌ったり、ダンスしたりこができます。</span><br><span class="line">译：我可以边唱歌边跳舞。</span><br></pre></td></tr></table></figure><h3 id="4-疑问词＋～たらいいですか-做……才好呢？"><a href="#4-疑问词＋～たらいいですか-做……才好呢？" class="headerlink" title="4. 疑问词＋～たらいいですか　做……才好呢？"></a>4. 疑问词＋～たらいいですか　做……才好呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうしたらいいですか？</span><br><span class="line">译：怎么做才好呢？</span><br></pre></td></tr></table></figure><h3 id="5-～たら、～-如果……就……"><a href="#5-～たら、～-如果……就……" class="headerlink" title="5. ～たら、～　如果……就……"></a>5. ～たら、～　如果……就……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：雨が降ったら、行きません。</span><br><span class="line">译：如果下雨了，就不去了。</span><br></pre></td></tr></table></figure><h3 id="6-～た＋ばかりです-刚刚做了，比ところです更长的时间但是是主观觉得时间短"><a href="#6-～た＋ばかりです-刚刚做了，比ところです更长的时间但是是主观觉得时间短" class="headerlink" title="6. ～た＋ばかりです　刚刚做了，比ところです更长的时间但是是主观觉得时间短"></a>6. ～た＋ばかりです　刚刚做了，比ところです更长的时间但是是主观觉得时间短</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は3月に大学を卒業したばかりです。</span><br><span class="line">译：他3月份才刚刚从大学毕业。</span><br></pre></td></tr></table></figure><h1 id="て形"><a href="#て形" class="headerlink" title="て形"></a>て形</h1><h2 id="变形规则-1"><a href="#变形规则-1" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">    く、ぐ　ー＞　いて、いで</span><br><span class="line">        特例：いく　ー＞　行って</span><br><span class="line">    う、つ、る　ー＞　って</span><br><span class="line">    ぬ、ぶ、む　ー＞　んで</span><br><span class="line">    す　ー＞　して</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋て</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　きて</span><br><span class="line">    サ变动次：する　ー＞　して</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋くて</span><br><span class="line"></span><br><span class="line">形容动词和名词：～＋で</span><br></pre></td></tr></table></figure><h2 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h2><h3 id="1-～てください-请……（轻微的命令）"><a href="#1-～てください-请……（轻微的命令）" class="headerlink" title="1. ～てください　请……（轻微的命令）"></a>1. ～てください　请……（轻微的命令）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やめてください。</span><br><span class="line">译：请不要这么做！</span><br></pre></td></tr></table></figure><h3 id="2-～てもいいです-可以做……"><a href="#2-～てもいいです-可以做……" class="headerlink" title="2. ～てもいいです　可以做……"></a>2. ～てもいいです　可以做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：食べていいです。</span><br><span class="line">译：可以吃掉。</span><br></pre></td></tr></table></figure><h3 id="3-～てはいけません-不可以做……"><a href="#3-～てはいけません-不可以做……" class="headerlink" title="3. ～てはいけません　不可以做……"></a>3. ～てはいけません　不可以做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いま伝染病時から、旅行してはいけません。</span><br><span class="line">译：因为现在是疫情时期，不可以去旅行。</span><br></pre></td></tr></table></figure><h3 id="4-～ています"><a href="#4-～ています" class="headerlink" title="4. ～ています"></a>4. ～ています</h3><h4 id="4-1-正在做某事"><a href="#4-1-正在做某事" class="headerlink" title="4.1 正在做某事"></a>4.1 正在做某事</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ゲームしています。</span><br><span class="line">译：正在打游戏。</span><br></pre></td></tr></table></figure><h4 id="4-2-表示状态（结婚，认识某人，住在，有等）"><a href="#4-2-表示状态（结婚，认识某人，住在，有等）" class="headerlink" title="4.2 表示状态（结婚，认识某人，住在，有等）"></a>4.2 表示状态（结婚，认识某人，住在，有等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今大阪に住んでいます。</span><br><span class="line">译：目前我住在大版。</span><br></pre></td></tr></table></figure><h4 id="4-3-反复进行的动作或习惯（学习，工作等）"><a href="#4-3-反复进行的动作或习惯（学习，工作等）" class="headerlink" title="4.3 反复进行的动作或习惯（学习，工作等）"></a>4.3 反复进行的动作或习惯（学习，工作等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：勉強しています</span><br><span class="line">译：学习中……</span><br></pre></td></tr></table></figure><h3 id="5-～てあげます-为别人做……（我或我方为第三方做事情）"><a href="#5-～てあげます-为别人做……（我或我方为第三方做事情）" class="headerlink" title="5. ～てあげます　为别人做……（我或我方为第三方做事情）"></a>5. ～てあげます　为别人做……（我或我方为第三方做事情）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="5-1-比自己地位低的人，动物，植物可以用-やります"><a href="#5-1-比自己地位低的人，动物，植物可以用-やります" class="headerlink" title="5.1 比自己地位低的人，动物，植物可以用　やります"></a>5.1 比自己地位低的人，动物，植物可以用　やります</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="5-2-比自己地位高的人，可以用-あしあげます"><a href="#5-2-比自己地位高的人，可以用-あしあげます" class="headerlink" title="5.2 比自己地位高的人，可以用　あしあげます"></a>5.2 比自己地位高的人，可以用　あしあげます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="6-～てもらいます-主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）"><a href="#6-～てもらいます-主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）" class="headerlink" title="6. ～てもらいます　主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）"></a>6. ～てもらいます　主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="6-1-比自己地位高的人，可以用-～ていただきます"><a href="#6-1-比自己地位高的人，可以用-～ていただきます" class="headerlink" title="6.1 比自己地位高的人，可以用　～ていただきます"></a>6.1 比自己地位高的人，可以用　～ていただきます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="7-～てくれます-别人主动为我做……（别人为我或我方做事情，别人主动为我做）"><a href="#7-～てくれます-别人主动为我做……（别人为我或我方做事情，别人主动为我做）" class="headerlink" title="7. ～てくれます　别人主动为我做……（别人为我或我方做事情，别人主动为我做）"></a>7. ～てくれます　别人主动为我做……（别人为我或我方做事情，别人主动为我做）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="7-1-比自己地位高的人，可以用-～てくださいます"><a href="#7-1-比自己地位高的人，可以用-～てくださいます" class="headerlink" title="7.1 比自己地位高的人，可以用　～てくださいます"></a>7.1 比自己地位高的人，可以用　～てくださいます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="7-2-～てくださいませんか-超级有礼貌的表达方式"><a href="#7-2-～てくださいませんか-超级有礼貌的表达方式" class="headerlink" title="7.2 ～てくださいませんか　超级有礼貌的表达方式"></a>7.2 ～てくださいませんか　超级有礼貌的表达方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="7-3-～ていただけませんか-能帮我做……吗？"><a href="#7-3-～ていただけませんか-能帮我做……吗？" class="headerlink" title="7.3 ～ていただけませんか　能帮我做……吗？"></a>7.3 ～ていただけませんか　能帮我做……吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="8-～ても～-即使……也……"><a href="#8-～ても～-即使……也……" class="headerlink" title="8. ～ても～　即使……也……"></a>8. ～ても～　即使……也……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やっても、無理です。</span><br><span class="line">译：即使做了，也不行了。</span><br></pre></td></tr></table></figure><h3 id="9-～てしまいます-表示下决心、将来完成"><a href="#9-～てしまいます-表示下决心、将来完成" class="headerlink" title="9. ～てしまいます　表示下决心、将来完成"></a>9. ～てしまいます　表示下决心、将来完成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：昼ご飯までにレポートを書いてしまいます。</span><br><span class="line">译：我要在午饭前把报告写完。</span><br></pre></td></tr></table></figure><h3 id="10-～てしまいました"><a href="#10-～てしまいました" class="headerlink" title="10. ～てしまいました"></a>10. ～てしまいました</h3><h4 id="10-1-强调某个行为已经全部完成了"><a href="#10-1-强调某个行为已经全部完成了" class="headerlink" title="10.1. 强调某个行为已经全部完成了"></a>10.1. 强调某个行为已经全部完成了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：漢字の宿題はもうやってしまいました。</span><br><span class="line">译：汉字的作业已经全部做完了。</span><br></pre></td></tr></table></figure><h4 id="10-2-为难状态下的困惑，后悔（发生了不好的事情）"><a href="#10-2-为难状态下的困惑，后悔（发生了不好的事情）" class="headerlink" title="10.2. 为难状态下的困惑，后悔（发生了不好的事情）"></a>10.2. 为难状态下的困惑，后悔（发生了不好的事情）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：パスポートをなくしてしまいました。</span><br><span class="line">译：护照弄丢了。</span><br></pre></td></tr></table></figure><h3 id="11-～てあります"><a href="#11-～てあります" class="headerlink" title="11. ～てあります"></a>11. ～てあります</h3><h4 id="11-1-表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）"><a href="#11-1-表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）" class="headerlink" title="11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）"></a>11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：机の上にメモが置いてあります。</span><br><span class="line">译：桌子上放着笔记本。</span><br></pre></td></tr></table></figure><h4 id="11-2-表示状态时和ています的区别"><a href="#11-2-表示状态时和ています的区别" class="headerlink" title="11.2. 表示状态时和ています的区别"></a>11.2. 表示状态时和ています的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动词，强调窗户的状态</span><br><span class="line">例：窓が閉まっています。</span><br><span class="line">译：窗户关闭着。</span><br><span class="line"></span><br><span class="line">他动词，强调不知道被谁关了窗户这件事的结果</span><br><span class="line">例：窓が閉めてあります</span><br><span class="line">译：窗户关闭着</span><br></pre></td></tr></table></figure><h4 id="11-3-表示为将来提前做准备"><a href="#11-3-表示为将来提前做准备" class="headerlink" title="11.3. 表示为将来提前做准备"></a>11.3. 表示为将来提前做准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：誕生日のプレゼントはもう買ってあります。</span><br><span class="line">译：生日礼物已经买好了。</span><br></pre></td></tr></table></figure><h3 id="12-～ておきます"><a href="#12-～ておきます" class="headerlink" title="12. ～ておきます"></a>12. ～ておきます</h3><h4 id="12-1-做某件事之前必要做的事情"><a href="#12-1-做某件事之前必要做的事情" class="headerlink" title="12.1. 做某件事之前必要做的事情"></a>12.1. 做某件事之前必要做的事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：旅行の前に切符を買っておきます。</span><br><span class="line">译：旅行之前要把票买好。</span><br></pre></td></tr></table></figure><h4 id="12-2-为下次使用而完成必要的动作"><a href="#12-2-为下次使用而完成必要的动作" class="headerlink" title="12.2. 为下次使用而完成必要的动作"></a>12.2. 为下次使用而完成必要的动作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はさみを使ったら、元の所に戻して置いてください。</span><br><span class="line">译：用完剪刀后，请放回原来的地方。</span><br></pre></td></tr></table></figure><h4 id="12-3-让状态持续下去"><a href="#12-3-让状态持续下去" class="headerlink" title="12.3. 让状态持续下去"></a>12.3. 让状态持续下去</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日会議がありますから、いすはこのままにして置いてください。</span><br><span class="line">译：明天还有会议，椅子就这样保持下去吧。</span><br></pre></td></tr></table></figure><h4 id="12-4-临时的措施"><a href="#12-4-临时的措施" class="headerlink" title="12.4. 临时的措施"></a>12.4. 临时的措施</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：資料は後で見ておきます、そこに置いといてください。</span><br><span class="line">译：资料之后要看，请放在哪里。</span><br></pre></td></tr></table></figure><h4 id="12-5-～ておきます-ー＞-～ときます（口语）"><a href="#12-5-～ておきます-ー＞-～ときます（口语）" class="headerlink" title="12.5. ～ておきます　ー＞　～ときます（口语）"></a>12.5. ～ておきます　ー＞　～ときます（口语）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そこにおいといてください。</span><br><span class="line">译：请放到那里。</span><br></pre></td></tr></table></figure><h3 id="13-まだ～ていません-事情或者动作还没有发生"><a href="#13-まだ～ていません-事情或者动作还没有发生" class="headerlink" title="13. まだ～ていません　事情或者动作还没有发生"></a>13. まだ～ていません　事情或者动作还没有发生</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：銀行はまだ開いていません。</span><br><span class="line">译：银行还没有开门。</span><br></pre></td></tr></table></figure><h3 id="14-～てみる-试着做……"><a href="#14-～てみる-试着做……" class="headerlink" title="14. ～てみる　试着做……"></a>14. ～てみる　试着做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：も一度考えてみます。</span><br><span class="line">译：在试着思考一次。</span><br><span class="line"></span><br><span class="line">例：このズボンをはいてみてもいいですか。</span><br><span class="line">译：可以试穿一下这条裤子吗？</span><br></pre></td></tr></table></figure><h3 id="15-（て形-ない形-ないで）＋动词2-在动词1的情况下做动词2-有「没有做……而是做……」的意思"><a href="#15-（て形-ない形-ないで）＋动词2-在动词1的情况下做动词2-有「没有做……而是做……」的意思" class="headerlink" title="15. （て形/ない形+ないで）＋动词2  在动词1的情况下做动词2 　有「没有做……而是做……」的意思"></a>15. （て形/ない形+ないで）＋动词2  在动词1的情况下做动词2 　有「没有做……而是做……」的意思</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：醤油を付けて食べます。</span><br><span class="line">译：沾着酱油吃。</span><br><span class="line"></span><br><span class="line">例：醤油を付けないで食べます。</span><br><span class="line">译：不要沾着酱油吃。</span><br><span class="line"></span><br><span class="line">例：日曜日はどこも行かないで、うちでゆっくり休みます。</span><br><span class="line">译：周日哪里也不去，在家里好好休息。</span><br></pre></td></tr></table></figure><h3 id="16-～て来ます"><a href="#16-～て来ます" class="headerlink" title="16. ～て来ます"></a>16. ～て来ます</h3><h4 id="16-1-做某个动作之后再回来-有去去就回的感觉"><a href="#16-1-做某个动作之后再回来-有去去就回的感觉" class="headerlink" title="16.1. 做某个动作之后再回来, 有去去就回的感觉"></a>16.1. 做某个动作之后再回来, 有去去就回的感觉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと煙草を買ってきます。</span><br><span class="line">译：我去买包香烟。</span><br></pre></td></tr></table></figure><h4 id="16-2-有逐渐变化的意思"><a href="#16-2-有逐渐变化的意思" class="headerlink" title="16.2. 有逐渐变化的意思"></a>16.2. 有逐渐变化的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：消えて来ます。</span><br><span class="line">译：慢慢消失了。</span><br></pre></td></tr></table></figure><h1 id="ない形"><a href="#ない形" class="headerlink" title="ない形"></a>ない形</h1><h2 id="变形规则-2"><a href="#变形规则-2" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">う段　ー＞　あ段＋ない</span><br><span class="line">    以う结尾的动词，要去掉う变成わない。買うー＞買わない</span><br><span class="line">    ある的ない形就是ない</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ない</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　来（こ）ない</span><br><span class="line">    サ变动次：する　ー＞　しない</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋くない</span><br><span class="line"></span><br><span class="line">形容动词和名词：～＋では（じゃ）ない</span><br></pre></td></tr></table></figure><h2 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h2><h3 id="1-一般用于否定"><a href="#1-一般用于否定" class="headerlink" title="1. 一般用于否定"></a>1. 一般用于否定</h3><h3 id="2-～ないでください-请不要做……"><a href="#2-～ないでください-请不要做……" class="headerlink" title="2. ～ないでください　请不要做……"></a>2. ～ないでください　请不要做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="3-必须做……"><a href="#3-必须做……" class="headerlink" title="3. 必须做……"></a>3. 必须做……</h3><ul><li>～なければ、なりません</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ul><li>～ないと、いけません</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ul><li>～ないと</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="4-～なくてもいいです-不做……也可以"><a href="#4-～なくてもいいです-不做……也可以" class="headerlink" title="4. ～なくてもいいです　不做……也可以"></a>4. ～なくてもいいです　不做……也可以</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h1 id="可能态"><a href="#可能态" class="headerlink" title="可能态"></a>可能态</h1><h2 id="变形规则-3"><a href="#变形规则-3" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　え段＋る</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋られる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：くる　ー＞　こられる</span><br><span class="line">    サ变动词：する　ー＞　できる</span><br></pre></td></tr></table></figure><h2 id="变化后的词性"><a href="#变化后的词性" class="headerlink" title="变化后的词性"></a>变化后的词性</h2><ul><li>变化之后都是二类动词</li><li>变化之后都是自动词</li></ul><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><h3 id="1-事物的性质"><a href="#1-事物的性质" class="headerlink" title="1.事物的性质"></a>1.事物的性质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この野菜は生で食べらない。</span><br><span class="line">译：这个蔬菜不能生吃。</span><br></pre></td></tr></table></figure><h3 id="2-表示可能性"><a href="#2-表示可能性" class="headerlink" title="2.表示可能性"></a>2.表示可能性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：この事は両親に言えません。</span><br><span class="line">译：这件事不能对父母说。</span><br><span class="line"></span><br><span class="line">例：今は社長に会えません。</span><br><span class="line">译：现在无法会见社长。</span><br><span class="line"></span><br><span class="line">例：事務所の人は誰もそのコンーピュータを使えます。</span><br><span class="line">译：事务所的人谁都不会使用那台电脑。</span><br></pre></td></tr></table></figure><h3 id="3-能力"><a href="#3-能力" class="headerlink" title="3.能力"></a>3.能力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語を話せます。</span><br><span class="line">译：会说日语。</span><br></pre></td></tr></table></figure><h1 id="假定形"><a href="#假定形" class="headerlink" title="假定形"></a>假定形</h1><h2 id="变形规则-4"><a href="#变形规则-4" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段　ー＞　え段＋ば</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋れば</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　くれば</span><br><span class="line">    サ变动次：する　ー＞　すれば</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋ければ</span><br><span class="line"></span><br><span class="line">形容动词和名词：〜＋なら「ば」</span><br></pre></td></tr></table></figure><h2 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h2><h3 id="1-一般条件：一……就……"><a href="#1-一般条件：一……就……" class="headerlink" title="1. 一般条件：一……就……"></a>1. 一般条件：一……就……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いい天気なら、向こうに島が見えます。</span><br><span class="line">译：天气好的话，你可以看到对面的小岛。</span><br></pre></td></tr></table></figure><h3 id="2-假定条件：如果……就……"><a href="#2-假定条件：如果……就……" class="headerlink" title="2. 假定条件：如果……就……"></a>2. 假定条件：如果……就……</h3><blockquote><p>PS: 前句是意志类词语，后句是对听话人提要求的话，只能用たら，たら范围最大。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：時間がなかったら、テレビを見ません。</span><br><span class="line">译：没时间我就不看电视了。</span><br><span class="line"></span><br><span class="line">例：時間がなければ、テレビを見ません。</span><br><span class="line">译：没时间我就不看电视了。</span><br><span class="line"></span><br><span class="line">例：よがったら、助けてもらいますか。</span><br><span class="line">译：可以的话，能帮下忙吗？</span><br></pre></td></tr></table></figure><h3 id="3-名词-なら-可用于对方提出的话题，再提供一些信息"><a href="#3-名词-なら-可用于对方提出的话题，再提供一些信息" class="headerlink" title="3. 名词+なら　可用于对方提出的话题，再提供一些信息"></a>3. 名词+なら　可用于对方提出的话题，再提供一些信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：温泉に行きたいんですが、どこか良い所がありませんか。</span><br><span class="line">译：非常想去泡温泉呀，有什么好地方吗？</span><br><span class="line"></span><br><span class="line">例：温泉なら、白馬がいいですよ。</span><br><span class="line">译：如果是温泉的话，白马县挺不错的哦。</span><br></pre></td></tr></table></figure><h3 id="4-疑问词＋假定形＋いいですか-等同于-〜たらいいですか-怎么做才好呢？"><a href="#4-疑问词＋假定形＋いいですか-等同于-〜たらいいですか-怎么做才好呢？" class="headerlink" title="4. 疑问词＋假定形＋いいですか　等同于　〜たらいいですか　怎么做才好呢？"></a>4. 疑问词＋假定形＋いいですか　等同于　〜たらいいですか　怎么做才好呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：本を借りたいですが、どうすればいいですか。</span><br><span class="line">译：想借本书，怎么做才好呢？</span><br></pre></td></tr></table></figure><h3 id="5-假定形＋连体形＋ほど〜-越……越……"><a href="#5-假定形＋连体形＋ほど〜-越……越……" class="headerlink" title="5. 假定形＋连体形＋ほど〜　越……越……"></a>5. 假定形＋连体形＋ほど〜　越……越……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：パソコンは操作が簡単なら簡単なほどいいです。</span><br><span class="line">译：电脑的操作越简单越好呀。</span><br></pre></td></tr></table></figure><h1 id="被动形"><a href="#被动形" class="headerlink" title="被动形"></a>被动形</h1><h2 id="变形规则-5"><a href="#变形规则-5" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段　ー＞　あ段＋れる</span><br><span class="line"></span><br><span class="line">二类动词：去る＋られる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　来られる</span><br><span class="line">    サ变动次：する　ー＞　される</span><br></pre></td></tr></table></figure><h2 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h2><h3 id="AはBに＋被动形-A被B……"><a href="#AはBに＋被动形-A被B……" class="headerlink" title="AはBに＋被动形　A被B……"></a>AはBに＋被动形　A被B……</h3><blockquote><p>中性，好坏都可表达<br>当A是作品或者发明时，被动形前面要加上よって</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：私は先生に褒められました。</span><br><span class="line">译：我被老师表扬了。</span><br><span class="line"></span><br><span class="line">例：私は犬に噛まれました。</span><br><span class="line">译：我被狗咬了。</span><br><span class="line"></span><br><span class="line">例：電話はベルによって発明されました。</span><br><span class="line">译：电话是被贝尔发明的。</span><br></pre></td></tr></table></figure><h3 id="AはBに＋なにを被动形-A的なに被B……"><a href="#AはBに＋なにを被动形-A的なに被B……" class="headerlink" title="AはBに＋なにを被动形 A的なに被B……"></a>AはBに＋なにを被动形 A的なに被B……</h3><blockquote><p>中性，不好的事情<br>A和~是从属关系（A的~），但是不能直接使用『Aの~』作为主语</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は犬に手を噛まれました。</span><br><span class="line">译：我的手被狗咬了。</span><br></pre></td></tr></table></figure><h1 id="使役态"><a href="#使役态" class="headerlink" title="使役态"></a>使役态</h1><h2 id="变形规则-6"><a href="#变形规则-6" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　あ段＋せる</span><br><span class="line">う结尾　ー＞　わせる</span><br><span class="line"></span><br><span class="line">二类动词：去る＋させる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　こさせる</span><br><span class="line">  サ变动词：する　ー＞　させる</span><br></pre></td></tr></table></figure><h2 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h2><h3 id="～を自动词使役态-让名词（某人）做"><a href="#～を自动词使役态-让名词（某人）做" class="headerlink" title="～を自动词使役态　让名词（某人）做~"></a>～を自动词使役态　让名词（某人）做~</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：息子をイギリスヘ留学させます。 </span><br><span class="line">译：让我的儿子去英国留学。</span><br></pre></td></tr></table></figure><h3 id="～に～を他动词使役态-让名词（某人）做"><a href="#～に～を他动词使役态-让名词（某人）做" class="headerlink" title="～に～を他动词使役态　让名词（某人）做~"></a>～に～を他动词使役态　让名词（某人）做~</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：娘にピアノを習わせます。</span><br><span class="line">译：让女儿学习钢琴</span><br></pre></td></tr></table></figure><h1 id="意志形"><a href="#意志形" class="headerlink" title="意志形"></a>意志形</h1><h2 id="变形规则-7"><a href="#变形规则-7" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　お段＋う</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋よう</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　こよう</span><br><span class="line">  サ变动词：する　ー＞　しよう</span><br></pre></td></tr></table></figure><h2 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h2><h3 id="自己的意志"><a href="#自己的意志" class="headerlink" title="自己的意志"></a>自己的意志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと休まない。</span><br><span class="line">译：要不休息一下？</span><br><span class="line"></span><br><span class="line">例：うん、休もう。</span><br><span class="line">译：嗯，去休息吧！</span><br></pre></td></tr></table></figure><h3 id="劝诱"><a href="#劝诱" class="headerlink" title="劝诱"></a>劝诱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：て伝おうか。</span><br><span class="line">译：能帮我一下吗？</span><br></pre></td></tr></table></figure><h3 id="提议-大家一起做"><a href="#提议-大家一起做" class="headerlink" title="提议(大家一起做)"></a>提议(大家一起做)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：みんなですごし休もうか。</span><br><span class="line">译：大家一起休息一下吧？</span><br></pre></td></tr></table></figure><h3 id="意志形＋とおもっています-很久以前就打算做……"><a href="#意志形＋とおもっています-很久以前就打算做……" class="headerlink" title="意志形＋とおもっています　很久以前就打算做……"></a>意志形＋とおもっています　很久以前就打算做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：週末は海に行こうとおもっています。</span><br><span class="line">译：很久以前就打算周末去海边呢。</span><br></pre></td></tr></table></figure><h3 id="意志形＋とおもいます-刚刚有这样的打算……"><a href="#意志形＋とおもいます-刚刚有这样的打算……" class="headerlink" title="意志形＋とおもいます　刚刚有这样的打算……"></a>意志形＋とおもいます　刚刚有这样的打算……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今から銀行へ行こうとおもいます。</span><br><span class="line">译：我今天才打算去银行。</span><br></pre></td></tr></table></figure><h2 id="敬体"><a href="#敬体" class="headerlink" title="敬体"></a>敬体</h2><h3 id="～ましょう"><a href="#～ましょう" class="headerlink" title="～ましょう"></a>～ましょう</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：休みましょう。</span><br><span class="line">译：休息一下吧！</span><br></pre></td></tr></table></figure><h1 id="命令形"><a href="#命令形" class="headerlink" title="命令形"></a>命令形</h1><h2 id="变形规则-8"><a href="#变形规则-8" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　え段</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ろ</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：くる　ー＞　こい</span><br><span class="line">    サ变动词：する　ー＞　しろ</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h1 id="命令形和禁止形"><a href="#命令形和禁止形" class="headerlink" title="命令形和禁止形"></a>命令形和禁止形</h1><h2 id="变形规则-9"><a href="#变形规则-9" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典形＋な</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之动词变形&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
</feed>
