<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2025-11-10T08:08:03.586Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ComfyUI教程</title>
    <link href="/2025/10/14/ComfyUI%E6%95%99%E7%A8%8B/"/>
    <id>/2025/10/14/ComfyUI教程/</id>
    <published>2025-10-14T08:30:45.000Z</published>
    <updated>2025-11-10T08:08:03.586Z</updated>
    
    <content type="html"><![CDATA[<p>ComfyUI入门教程<br><a id="more"></a><br>ComfyUI是最强大的开源基于节点的生成式人工智能应用。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://www.comfy.org/zh-cn/" target="_blank" rel="noopener">ComfyUI</a></p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://www.comflowy.com/zh-CN/docs" target="_blank" rel="noopener">Comflowy</a><br><a href="https://www.digitfold.com/" target="_blank" rel="noopener">数字折叠</a></p><h2 id="工作流例子"><a href="#工作流例子" class="headerlink" title="工作流例子"></a>工作流例子</h2><p><a href="https://comfyanonymous.github.io/ComfyUI_examples/" target="_blank" rel="noopener">ComfyUI_examples</a></p><h2 id="视频学习"><a href="#视频学习" class="headerlink" title="视频学习"></a>视频学习</h2><p><a href="https://aistudio.baidu.com/course/introduce/32359" target="_blank" rel="noopener">PP飞桨</a></p><h2 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h2><p><a href="https://blog.csdn.net/Misdirection_XG/article/details/147550911" target="_blank" rel="noopener">ComfyUI常见错误</a></p><h2 id="在线ComfyUI云平台"><a href="#在线ComfyUI云平台" class="headerlink" title="在线ComfyUI云平台"></a>在线ComfyUI云平台</h2><p><a href="https://www.runninghub.cn/" target="_blank" rel="noopener">RunningHUB</a><br><a href="https://www.catimind.com/" target="_blank" rel="noopener">CATIMIND</a></p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>由于ComfyUI的节点需要从github下载，所以需要设置代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正常下载</span><br><span class="line">git clone https://github.com/comfyanonymous/ComfyUI.git</span><br><span class="line">代理下载,在地址前加 https://mirror.ghproxy.com/</span><br><span class="line">git clone https://mirror.ghproxy.com/https://github.com/comfyanonymous/ComfyUI.git</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ComfyUI入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python&amp;rust" scheme="/categories/python-rust/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门到精通</title>
    <link href="/2025/08/28/Rust%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>/2025/08/28/Rust入门到精通/</id>
    <published>2025-08-28T07:14:11.000Z</published>
    <updated>2025-08-28T07:43:13.825Z</updated>
    
    <content type="html"><![CDATA[<p>用36张图片学习Rust，从入门到精通<br><a id="more"></a></p><h2 id="Rust入门：Rust发展史、Rust特性与优势、Rust应用场景、Rust开发环境搭建"><a href="#Rust入门：Rust发展史、Rust特性与优势、Rust应用场景、Rust开发环境搭建" class="headerlink" title="Rust入门：Rust发展史、Rust特性与优势、Rust应用场景、Rust开发环境搭建"></a>Rust入门：Rust发展史、Rust特性与优势、Rust应用场景、Rust开发环境搭建</h2><p><img src="/2025/08/28/Rust入门到精通/1.png" alt="img"></p><h2 id="Cargo工具：Cargo介绍、Cargo-toml文件解析、Cargo常用命令、依赖管理"><a href="#Cargo工具：Cargo介绍、Cargo-toml文件解析、Cargo常用命令、依赖管理" class="headerlink" title="Cargo工具：Cargo介绍、Cargo.toml文件解析、Cargo常用命令、依赖管理"></a>Cargo工具：Cargo介绍、Cargo.toml文件解析、Cargo常用命令、依赖管理</h2><p><img src="/2025/08/28/Rust入门到精通/2.png" alt="img"></p><h2 id="Rust基础语法：变量与可变性、基本数据类型、常量与静态变量、注释"><a href="#Rust基础语法：变量与可变性、基本数据类型、常量与静态变量、注释" class="headerlink" title="Rust基础语法：变量与可变性、基本数据类型、常量与静态变量、注释"></a>Rust基础语法：变量与可变性、基本数据类型、常量与静态变量、注释</h2><p><img src="/2025/08/28/Rust入门到精通/3.png" alt="img"></p><h2 id="所有权系统：所有权概念、移动与克隆、引用与借用、生命周期基础"><a href="#所有权系统：所有权概念、移动与克隆、引用与借用、生命周期基础" class="headerlink" title="所有权系统：所有权概念、移动与克隆、引用与借用、生命周期基础"></a>所有权系统：所有权概念、移动与克隆、引用与借用、生命周期基础</h2><p><img src="/2025/08/28/Rust入门到精通/4.png" alt="img"></p><h2 id="结构体与枚举：定义结构体、结构体方法、枚举类型、Option与Result枚举"><a href="#结构体与枚举：定义结构体、结构体方法、枚举类型、Option与Result枚举" class="headerlink" title="结构体与枚举：定义结构体、结构体方法、枚举类型、Option与Result枚举"></a>结构体与枚举：定义结构体、结构体方法、枚举类型、Option与Result枚举</h2><p><img src="/2025/08/28/Rust入门到精通/5.png" alt="img"></p><h2 id="模式匹配：match表达式、if-let语法、while-let语法、模式匹配进阶"><a href="#模式匹配：match表达式、if-let语法、while-let语法、模式匹配进阶" class="headerlink" title="模式匹配：match表达式、if let语法、while let语法、模式匹配进阶"></a>模式匹配：match表达式、if let语法、while let语法、模式匹配进阶</h2><p><img src="/2025/08/28/Rust入门到精通/6.png" alt="img"></p><h2 id="错误处理：panic-宏、Result类型、unwrap与expect、自定义错误类型"><a href="#错误处理：panic-宏、Result类型、unwrap与expect、自定义错误类型" class="headerlink" title="错误处理：panic!宏、Result类型、unwrap与expect、自定义错误类型"></a>错误处理：panic!宏、Result类型、unwrap与expect、自定义错误类型</h2><p><img src="/2025/08/28/Rust入门到精通/7.png" alt="img"></p><h2 id="泛型与特征：泛型函数与结构体、特征定义与实现、特征约束、derive特征"><a href="#泛型与特征：泛型函数与结构体、特征定义与实现、特征约束、derive特征" class="headerlink" title="泛型与特征：泛型函数与结构体、特征定义与实现、特征约束、derive特征"></a>泛型与特征：泛型函数与结构体、特征定义与实现、特征约束、derive特征</h2><p><img src="/2025/08/28/Rust入门到精通/8.png" alt="img"></p><h2 id="集合类型：Vector、String、HashMap、HashSet常用操作与性能分析"><a href="#集合类型：Vector、String、HashMap、HashSet常用操作与性能分析" class="headerlink" title="集合类型：Vector、String、HashMap、HashSet常用操作与性能分析"></a>集合类型：Vector、String、HashMap、HashSet常用操作与性能分析</h2><p><img src="/2025/08/28/Rust入门到精通/9.png" alt="img"></p><h2 id="迭代器与闭包：闭包语法、迭代器适配器、消费器、自定义迭代器"><a href="#迭代器与闭包：闭包语法、迭代器适配器、消费器、自定义迭代器" class="headerlink" title="迭代器与闭包：闭包语法、迭代器适配器、消费器、自定义迭代器"></a>迭代器与闭包：闭包语法、迭代器适配器、消费器、自定义迭代器</h2><p><img src="/2025/08/28/Rust入门到精通/10.png" alt="img"></p><h2 id="模块系统：模块定义与组织、use关键字、pub可见性、文件系统模块"><a href="#模块系统：模块定义与组织、use关键字、pub可见性、文件系统模块" class="headerlink" title="模块系统：模块定义与组织、use关键字、pub可见性、文件系统模块"></a>模块系统：模块定义与组织、use关键字、pub可见性、文件系统模块</h2><p><img src="/2025/08/28/Rust入门到精通/11.png" alt="img"></p><h2 id="并发编程：线程创建、消息传递-mpsc-、共享状态-Mutex-Arc-、Send与Sync特征"><a href="#并发编程：线程创建、消息传递-mpsc-、共享状态-Mutex-Arc-、Send与Sync特征" class="headerlink" title="并发编程：线程创建、消息传递(mpsc)、共享状态(Mutex/Arc)、Send与Sync特征"></a>并发编程：线程创建、消息传递(mpsc)、共享状态(Mutex/Arc)、Send与Sync特征</h2><p><img src="/2025/08/28/Rust入门到精通/12.png" alt="img"></p><h2 id="异步编程：async-await语法、Future特征、tokio运行时、异步IO操作"><a href="#异步编程：async-await语法、Future特征、tokio运行时、异步IO操作" class="headerlink" title="异步编程：async/await语法、Future特征、tokio运行时、异步IO操作"></a>异步编程：async/await语法、Future特征、tokio运行时、异步IO操作</h2><p><img src="/2025/08/28/Rust入门到精通/13.png" alt="img"></p><h2 id="智能指针：Box、Rc、Arc、RefCell与内部可变性模式"><a href="#智能指针：Box、Rc、Arc、RefCell与内部可变性模式" class="headerlink" title="智能指针：Box、Rc、Arc、RefCell与内部可变性模式"></a>智能指针：Box、Rc、Arc、RefCell与内部可变性模式</h2><p><img src="/2025/08/28/Rust入门到精通/14.png" alt="img"></p><h2 id="宏编程：声明宏、过程宏基础、derive宏、属性宏与函数宏"><a href="#宏编程：声明宏、过程宏基础、derive宏、属性宏与函数宏" class="headerlink" title="宏编程：声明宏、过程宏基础、derive宏、属性宏与函数宏"></a>宏编程：声明宏、过程宏基础、derive宏、属性宏与函数宏</h2><p><img src="/2025/08/28/Rust入门到精通/15.png" alt="img"></p><h2 id="Unsafe-Rust：unsafe关键字、裸指针操作、调用外部函数、实现不安全特征"><a href="#Unsafe-Rust：unsafe关键字、裸指针操作、调用外部函数、实现不安全特征" class="headerlink" title="Unsafe Rust：unsafe关键字、裸指针操作、调用外部函数、实现不安全特征"></a>Unsafe Rust：unsafe关键字、裸指针操作、调用外部函数、实现不安全特征</h2><p><img src="/2025/08/28/Rust入门到精通/16.png" alt="img"></p><h2 id="FFI编程：与C语言交互、绑定生成工具、调用Rust库、内存安全考虑"><a href="#FFI编程：与C语言交互、绑定生成工具、调用Rust库、内存安全考虑" class="headerlink" title="FFI编程：与C语言交互、绑定生成工具、调用Rust库、内存安全考虑"></a>FFI编程：与C语言交互、绑定生成工具、调用Rust库、内存安全考虑</h2><p><img src="/2025/08/28/Rust入门到精通/17.png" alt="img"></p><h2 id="性能优化：基准测试、内联优化、内存布局、零成本抽象实践"><a href="#性能优化：基准测试、内联优化、内存布局、零成本抽象实践" class="headerlink" title="性能优化：基准测试、内联优化、内存布局、零成本抽象实践"></a>性能优化：基准测试、内联优化、内存布局、零成本抽象实践</h2><p><img src="/2025/08/28/Rust入门到精通/18.png" alt="img"></p><h2 id="Web开发：actix-web框架、路由处理、中间件、数据库集成"><a href="#Web开发：actix-web框架、路由处理、中间件、数据库集成" class="headerlink" title="Web开发：actix-web框架、路由处理、中间件、数据库集成"></a>Web开发：actix-web框架、路由处理、中间件、数据库集成</h2><p><img src="/2025/08/28/Rust入门到精通/19.png" alt="img"></p><h2 id="命令行工具：clap参数解析、终端交互、子命令实现、彩色输出"><a href="#命令行工具：clap参数解析、终端交互、子命令实现、彩色输出" class="headerlink" title="命令行工具：clap参数解析、终端交互、子命令实现、彩色输出"></a>命令行工具：clap参数解析、终端交互、子命令实现、彩色输出</h2><p><img src="/2025/08/28/Rust入门到精通/20.png" alt="img"></p><h2 id="网络编程：TCP-UDP编程、HTTP客户端、WebSocket实现、QUIC协议基础"><a href="#网络编程：TCP-UDP编程、HTTP客户端、WebSocket实现、QUIC协议基础" class="headerlink" title="网络编程：TCP/UDP编程、HTTP客户端、WebSocket实现、QUIC协议基础"></a>网络编程：TCP/UDP编程、HTTP客户端、WebSocket实现、QUIC协议基础</h2><p><img src="/2025/08/28/Rust入门到精通/21.png" alt="img"></p><h2 id="GUI开发：GTK绑定、iced框架基础、事件处理、自定义组件"><a href="#GUI开发：GTK绑定、iced框架基础、事件处理、自定义组件" class="headerlink" title="GUI开发：GTK绑定、iced框架基础、事件处理、自定义组件"></a>GUI开发：GTK绑定、iced框架基础、事件处理、自定义组件</h2><p><img src="/2025/08/28/Rust入门到精通/22.png" alt="img"></p><h2 id="游戏开发：ggez引擎、ECS架构实现、2D渲染、输入处理"><a href="#游戏开发：ggez引擎、ECS架构实现、2D渲染、输入处理" class="headerlink" title="游戏开发：ggez引擎、ECS架构实现、2D渲染、输入处理"></a>游戏开发：ggez引擎、ECS架构实现、2D渲染、输入处理</h2><p><img src="/2025/08/28/Rust入门到精通/23.png" alt="img"></p><h2 id="区块链开发：区块链基础概念、智能合约编写、Substrate框架入门"><a href="#区块链开发：区块链基础概念、智能合约编写、Substrate框架入门" class="headerlink" title="区块链开发：区块链基础概念、智能合约编写、Substrate框架入门"></a>区块链开发：区块链基础概念、智能合约编写、Substrate框架入门</h2><p><img src="/2025/08/28/Rust入门到精通/24.png" alt="img"></p><h2 id="嵌入式开发：no-std环境、硬件抽象层、寄存器操作、嵌入式并发模式"><a href="#嵌入式开发：no-std环境、硬件抽象层、寄存器操作、嵌入式并发模式" class="headerlink" title="嵌入式开发：no_std环境、硬件抽象层、寄存器操作、嵌入式并发模式"></a>嵌入式开发：no_std环境、硬件抽象层、寄存器操作、嵌入式并发模式</h2><p><img src="/2025/08/28/Rust入门到精通/25.png" alt="img"></p><h2 id="WASM应用：wasm-pack工具、与JavaScript互操作、性能优化、前端框架集成"><a href="#WASM应用：wasm-pack工具、与JavaScript互操作、性能优化、前端框架集成" class="headerlink" title="WASM应用：wasm-pack工具、与JavaScript互操作、性能优化、前端框架集成"></a>WASM应用：wasm-pack工具、与JavaScript互操作、性能优化、前端框架集成</h2><p><img src="/2025/08/28/Rust入门到精通/26.png" alt="img"></p><h2 id="数据库操作：SQLx使用、ORM框架比较、连接池管理、事务处理"><a href="#数据库操作：SQLx使用、ORM框架比较、连接池管理、事务处理" class="headerlink" title="数据库操作：SQLx使用、ORM框架比较、连接池管理、事务处理"></a>数据库操作：SQLx使用、ORM框架比较、连接池管理、事务处理</h2><p><img src="/2025/08/28/Rust入门到精通/27.png" alt="img"></p><h2 id="测试与文档：单元测试、集成测试、文档注释、基准测试"><a href="#测试与文档：单元测试、集成测试、文档注释、基准测试" class="headerlink" title="测试与文档：单元测试、集成测试、文档注释、基准测试"></a>测试与文档：单元测试、集成测试、文档注释、基准测试</h2><p><img src="/2025/08/28/Rust入门到精通/28.png" alt="img"></p><h2 id="发布与部署：跨平台编译、Docker集成、CI-CD配置、性能监控"><a href="#发布与部署：跨平台编译、Docker集成、CI-CD配置、性能监控" class="headerlink" title="发布与部署：跨平台编译、Docker集成、CI/CD配置、性能监控"></a>发布与部署：跨平台编译、Docker集成、CI/CD配置、性能监控</h2><p><img src="/2025/08/28/Rust入门到精通/29.png" alt="img"></p><h2 id="设计模式：Rust惯用模式、类型系统模式、并发模式、宏模式"><a href="#设计模式：Rust惯用模式、类型系统模式、并发模式、宏模式" class="headerlink" title="设计模式：Rust惯用模式、类型系统模式、并发模式、宏模式"></a>设计模式：Rust惯用模式、类型系统模式、并发模式、宏模式</h2><p><img src="/2025/08/28/Rust入门到精通/30.png" alt="img"></p><h2 id="高级生命周期：生命周期标注、生命周期省略规则、高阶生命周期"><a href="#高级生命周期：生命周期标注、生命周期省略规则、高阶生命周期" class="headerlink" title="高级生命周期：生命周期标注、生命周期省略规则、高阶生命周期"></a>高级生命周期：生命周期标注、生命周期省略规则、高阶生命周期</h2><p><img src="/2025/08/28/Rust入门到精通/31.png" alt="img"></p><h2 id="类型系统进阶：关联类型、默认类型参数、PhantomData、类型转换"><a href="#类型系统进阶：关联类型、默认类型参数、PhantomData、类型转换" class="headerlink" title="类型系统进阶：关联类型、默认类型参数、PhantomData、类型转换"></a>类型系统进阶：关联类型、默认类型参数、PhantomData、类型转换</h2><p><img src="/2025/08/28/Rust入门到精通/32.png" alt="img"></p><h2 id="元编程：编译期计算、常量泛型、类型级编程技巧"><a href="#元编程：编译期计算、常量泛型、类型级编程技巧" class="headerlink" title="元编程：编译期计算、常量泛型、类型级编程技巧"></a>元编程：编译期计算、常量泛型、类型级编程技巧</h2><p><img src="/2025/08/28/Rust入门到精通/33.png" alt="img"></p><h2 id="安全审计：常见漏洞模式、模糊测试、静态分析工具、形式化验证"><a href="#安全审计：常见漏洞模式、模糊测试、静态分析工具、形式化验证" class="headerlink" title="安全审计：常见漏洞模式、模糊测试、静态分析工具、形式化验证"></a>安全审计：常见漏洞模式、模糊测试、静态分析工具、形式化验证</h2><p><img src="/2025/08/28/Rust入门到精通/34.png" alt="img"></p><h2 id="生态系统：重要crate推荐、社区资源、学习路径、职业发展方向"><a href="#生态系统：重要crate推荐、社区资源、学习路径、职业发展方向" class="headerlink" title="生态系统：重要crate推荐、社区资源、学习路径、职业发展方向"></a>生态系统：重要crate推荐、社区资源、学习路径、职业发展方向</h2><p><img src="/2025/08/28/Rust入门到精通/35.png" alt="img"></p><h2 id="项目实战：从零构建完整Rust应用，包含需求分析、架构设计、编码实现与部署"><a href="#项目实战：从零构建完整Rust应用，包含需求分析、架构设计、编码实现与部署" class="headerlink" title="项目实战：从零构建完整Rust应用，包含需求分析、架构设计、编码实现与部署"></a>项目实战：从零构建完整Rust应用，包含需求分析、架构设计、编码实现与部署</h2><p><img src="/2025/08/28/Rust入门到精通/36.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用36张图片学习Rust，从入门到精通&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python&amp;rust" scheme="/categories/python-rust/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="后端" scheme="/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程</title>
    <link href="/2025/08/19/Rust%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>/2025/08/19/Rust入门教程/</id>
    <published>2025-08-19T02:20:32.000Z</published>
    <updated>2025-09-09T07:25:56.319Z</updated>
    
    <content type="html"><![CDATA[<p>Rust基础入门教程<br><a id="more"></a></p><blockquote><p>本教程运行环境 Windows 11 专业版</p></blockquote><p><a href="https://www.rust-lang.org/zh-CN/" target="_blank" rel="noopener">Rust官方</a><br>为什么选择 Rust?</p><ul><li>高性能 Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</li><li>可靠性 Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</li><li>生产力 Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="noopener">rust安装文件</a><br>下载后双击运行即可</p><h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p><code>rustup update</code> 升级Rust<br><code>rustup self uninstall</code> 卸载Rust<br><code>rustup doc</code> 查看本地Rust文档<br><code>rustc --version</code> 查看版本信息</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>使用<code>vscode</code>编写Rust程序,安装<code>rust-analyzer</code>插件提高开发效率<br>安装插件后，需要做一下配置，<br><code>ctrl+shift+p</code>打开命令面板，<br>输入<code>Open Workspace Settings (JSON)</code>，<br>在<code>settings.json</code>文件里加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;rust-analyzer.linkedProjects&quot;:[</span><br><span class="line">    &quot;D:/jinux/study/rust/first/Cargo.toml&quot; // 这个是项目的Cargo.toml文件路径</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>插件会重新启动，需要从远程下载东西，所以比较慢，也可能会失败，多试几次。</p><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><h3 id="基础运行"><a href="#基础运行" class="headerlink" title="基础运行"></a>基础运行</h3><p>创建<code>main.rs</code>文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  println!(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure></p><p>编译完后会在当前目录下生成<code>main.exe</code>和<code>main.pdb</code>文件<br><code>main.exe</code>是可执行文件<br><code>main.pdb</code>里边包含调试信息(只在windows下会生成这个文件)<br>在命令行下执行main.exe文件，可以看到打印结果</p><h3 id="cargo运行"><a href="#cargo运行" class="headerlink" title="cargo运行"></a>cargo运行</h3><p>cargo是rust的包管理工具，使用cargo可以创建、编译、运行rust项目<br>安装rust，cargo会自动安装到你的系统里<br><code>cargo --version</code> 查看cargo版本</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br></pre></td></tr></table></figure><p>项目目录结构<br>hello_cargo/<br>├── src<br>│   └── main.rs<br>├── .gitignore<br>└── Cargo.toml<br><code>Cargo.toml</code>文件是Cargo的核心配置文件，它定义了项目的依赖关系、构建信息、包信息等等<br><code>main.rs</code>是项目的入口文件</p><h4 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h4><p><code>cargo build</code><br>生成可执行文件,在target/debug/目录下</p><h4 id="构建并运行项目"><a href="#构建并运行项目" class="headerlink" title="构建并运行项目"></a>构建并运行项目</h4><p><code>cargo run</code></p><h4 id="检查代码"><a href="#检查代码" class="headerlink" title="检查代码"></a>检查代码</h4><p><code>cargo check</code><br>检查命令比构建命令快得多，提高效率</p><h4 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h4><p><code>cargo build --release</code><br>生成优化的二进制文件，在target/release/目录下，但是编译时间更长</p><h4 id="cargo的crate源修改"><a href="#cargo的crate源修改" class="headerlink" title="cargo的crate源修改"></a>cargo的crate源修改</h4><p><code>config.toml</code>文件位置：<code>C盘/用户/用户名/.cargo/config.toml</code>，没有的话新建一个<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"https://github.com/rust-lang/crates.io-index"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换成你偏好的镜像源</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">'ustc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清华大学</span></span><br><span class="line"><span class="section">[source.tuna]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中国科学技术大学</span></span><br><span class="line"><span class="section">[source.ustc]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"git://mirrors.ustc.edu.cn/crates.io-index"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上海交通大学</span></span><br><span class="line"><span class="section">[source.sjtu]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rustcc社区</span></span><br><span class="line"><span class="section">[source.rustcc]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"git://crates.rustcc.cn/crates.io-index"</span></span><br></pre></td></tr></table></figure></p><p>这里用的是清华大学ustc镜像源</p><h4 id="Cargo-toml中的包管理"><a href="#Cargo-toml中的包管理" class="headerlink" title="Cargo.toml中的包管理"></a>Cargo.toml中的包管理</h4><p>如果想引入一个<code>rand</code>这个依赖包<br><a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a><br>在这里搜索到<code>rand</code>的包，查看版本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;hello_cargo&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2024&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">rand = &quot;0.9.2&quot;</span><br></pre></td></tr></table></figure></p><p>之后，运行项目会自动下载依赖的包</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://course.rs/about-book.html" target="_blank" rel="noopener">Rust语言圣经(Rust Course)</a><br><a href="https://kaisery.github.io/trpl-zh-cn/title-page.html" target="_blank" rel="noopener">Rust 程序设计语言 简体中文版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rust基础入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python&amp;rust" scheme="/categories/python-rust/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="后端" scheme="/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Chrome浏览器插件开发</title>
    <link href="/2025/08/13/Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>/2025/08/13/Chrome-浏览器插件开发/</id>
    <published>2025-08-13T08:50:17.000Z</published>
    <updated>2025-08-15T01:55:15.954Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome浏览器插件开发入门<br><a id="more"></a></p><h2 id="Chrome插件是什么？"><a href="#Chrome插件是什么？" class="headerlink" title="Chrome插件是什么？"></a>Chrome插件是什么？</h2><blockquote><p>Chrome 插件（也称为扩展程序）是使用 HTML、CSS 和 JavaScript 构建的小型程序，可以自定义和增强你的浏览体验。</p></blockquote><h2 id="创建插件项目"><a href="#创建插件项目" class="headerlink" title="创建插件项目"></a>创建插件项目</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一个基本的 Chrome 插件需要以下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-first-extension/</span><br><span class="line">├── manifest.json      # 必需：插件的“身份证”</span><br><span class="line">├── popup.html         # 可选：点击插件图标时弹出的页面</span><br><span class="line">├── popup.js           # 可选：popup.html 的脚本</span><br><span class="line">├── popup.css          # 可选：popup.html 的样式</span><br><span class="line">├── background.js      # 可选：后台运行的脚本</span><br><span class="line">├── content.js         # 可选: 内容脚本，运行在网页中的脚本</span><br><span class="line">└── icon.png           # 可选：插件图标 (建议 128x128)</span><br></pre></td></tr></table></figure></p><h3 id="核心文件：manifest-json"><a href="#核心文件：manifest-json" class="headerlink" title="核心文件：manifest.json"></a>核心文件：manifest.json</h3><p>这是插件的配置文件，必须放在根目录，Chrome 插件现在使用Manifest V3。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;manifest_version&quot;: 3, // 指定使用 V3 版本</span><br><span class="line">  &quot;name&quot;: &quot;我的第一个插件&quot;, // 插件名称</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;, // 版本号</span><br><span class="line"></span><br><span class="line">  // 基本信息（可选）</span><br><span class="line">  &quot;description&quot;: &quot;一个简单的 Chrome 插件示例&quot;,</span><br><span class="line"></span><br><span class="line">  // 图标（可选）</span><br><span class="line">  &quot;icons&quot;: &#123;</span><br><span class="line">    &quot;16&quot;: &quot;icon.png&quot;,</span><br><span class="line">    &quot;48&quot;: &quot;icon.png&quot;,</span><br><span class="line">    &quot;128&quot;: &quot;icon.png&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 弹出页面（可选）</span><br><span class="line">  &quot;action&quot;: &#123;</span><br><span class="line">    &quot;default_popup&quot;: &quot;popup.html&quot;,</span><br><span class="line">    &quot;default_title&quot;: &quot;点击打开弹窗&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 背景服务工作线程（可选，V3 使用 service_worker 替代 background scripts）</span><br><span class="line">  &quot;background&quot;: &#123;</span><br><span class="line">    &quot;service_worker&quot;: &quot;background.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 权限声明（根据需要添加）</span><br><span class="line">  &quot;permissions&quot;: [</span><br><span class="line">    &quot;activeTab&quot;, // 访问当前标签页的权限（安全推荐）</span><br><span class="line">    // &quot;storage&quot; // 如果需要持久化存储</span><br><span class="line">    // &quot;tabs&quot; // 如果需要操作标签页</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // 内容脚本（可选：注入到网页中的脚本）</span><br><span class="line">  &quot;content_scripts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;], // 在哪些网页上注入</span><br><span class="line">      &quot;js&quot;: [&quot;content.js&quot;] // 注入的 JS 文件</span><br><span class="line">      // &quot;css&quot;: [&quot;content.css&quot;] // 注入的 CSS 文件</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="弹出页面-popup-html"><a href="#弹出页面-popup-html" class="headerlink" title="弹出页面 popup.html"></a>弹出页面 popup.html</h3><p>当用户点击插件图标时显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;我的插件&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;popup.css&quot;&gt;</span><br><span class="line">  &lt;!-- 弹出页面的宽度和高度最好明确设置 --&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      width: 300px;</span><br><span class="line">      padding: 20px;</span><br><span class="line">      font-family: Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;你好，世界！&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;这是一个简单的 Chrome 插件。&lt;/p&gt;</span><br><span class="line">  &lt;button id=&quot;changeColor&quot;&gt;改变页面背景色&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 必须在 HTML 中直接引入 JS，不能使用内联脚本 --&gt;</span><br><span class="line">  &lt;script src=&quot;popup.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="弹出页面交互逻辑-popup-js"><a href="#弹出页面交互逻辑-popup-js" class="headerlink" title="弹出页面交互逻辑 popup.js"></a>弹出页面交互逻辑 popup.js</h3><p>popup.html引入的js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取按钮元素</span><br><span class="line">const changeColorButton = document.getElementById(&apos;changeColor&apos;);</span><br><span class="line"></span><br><span class="line">// 当按钮被点击时</span><br><span class="line">changeColorButton.addEventListener(&apos;click&apos;, async () =&gt; &#123;</span><br><span class="line">  // 使用 Chrome 扩展 API 获取当前活动标签页</span><br><span class="line">  let [tab] = await chrome.tabs.query(&#123;</span><br><span class="line">    active: true,</span><br><span class="line">    currentWindow: true</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 向当前标签页发送消息，让 content script 执行操作</span><br><span class="line">  chrome.tabs.sendMessage(tab.id, &#123; action: &quot;changeColor&quot;, color: &quot;yellow&quot; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="操作网页内容-content-js"><a href="#操作网页内容-content-js" class="headerlink" title="操作网页内容 content.js"></a>操作网页内容 content.js</h3><p>这个脚本会被注入到匹配的网页中，可以直接操作 DOM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 监听来自 popup 或 background 的消息</span><br><span class="line">chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; &#123;</span><br><span class="line">  if (request.action === &quot;changeColor&quot;) &#123;</span><br><span class="line">    // 改变页面背景色</span><br><span class="line">    document.body.style.backgroundColor = request.color;</span><br><span class="line">    // 可以发送响应（如果需要）</span><br><span class="line">    // sendResponse(&#123;status: &quot;success&quot;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="后台逻辑-background-js"><a href="#后台逻辑-background-js" class="headerlink" title="后台逻辑 background.js"></a>后台逻辑 background.js</h3><p>后台脚本（V3 中是 Service Worker）在插件安装后常驻内存，处理事件和长期任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 监听扩展图标被点击的事件</span><br><span class="line">chrome.action.onClicked.addListener(async (tab) =&gt; &#123;</span><br><span class="line">  // 例如：可以在这里执行一些后台操作</span><br><span class="line">  console.log(&apos;插件图标被点击了！当前标签页:&apos;, tab.url);</span><br><span class="line">  // 也可以向内容脚本发送消息</span><br><span class="line">  // chrome.tabs.sendMessage(tab.id, &#123;action: &quot;doSomething&quot;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 监听来自 content script 或 popup 的消息</span><br><span class="line">chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; &#123;</span><br><span class="line">  if (request.action === &quot;getData&quot;) &#123;</span><br><span class="line">    // 执行一些后台逻辑</span><br><span class="line">    const data = &quot;来自后台的数据&quot;;</span><br><span class="line">    sendResponse(&#123;data: data&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果使用 sendResponse，需要返回 true（异步情况下）</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="加载并测试插件"><a href="#加载并测试插件" class="headerlink" title="加载并测试插件"></a>加载并测试插件</h3><ul><li>打开 Chrome 浏览器。</li><li>在地址栏输入 chrome://extensions 并回车。</li><li>打开右上角的 “开发者模式” 开关。</li><li>点击 “加载已解压的扩展程序”。</li><li>选择你创建的 my-first-extension 文件夹。</li><li>成功加载后，你会在浏览器右上角看到你的插件图标。</li></ul><h3 id="核心概念与API"><a href="#核心概念与API" class="headerlink" title="核心概念与API"></a>核心概念与API</h3><ul><li>Manifest V3: 最新版本，更安全（例如用 service_worker 替代了持久化 background scripts，用 declarativeNetRequest 替代部分 webRequest）。</li><li>权限 (Permissions): 插件需要明确声明所需权限（如 activeTab, storage, tabs 等），用户安装时会提示。</li><li>消息传递 (Messaging): 不同部分（popup, content script, background）之间通过 chrome.runtime.sendMessage 和 chrome.runtime.onMessage 进行通信。</li><li>内容脚本 (Content Scripts): 注入到网页 DOM 中的脚本，可以直接读取和修改页面内容，但运行在独立的环境中。</li><li>Service Worker (Background): 处理事件、管理状态、执行长期任务。注意：V3 的 Service Worker 是非持久化的，可能被暂停。</li><li>存储 (chrome.storage): 用于持久化存储数据，比 localStorage 更好（支持同步、配额更大）。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>安全性: 不要注入不安全的内联脚本。使用 Content Security Policy (CSP)。<br>性能: 避免在 content script 或 background 中执行耗时操作。<br>Manifest V3: 确保遵循 V3 规范，旧的 V2 插件未来可能不被支持。<br>调试:</p><blockquote><p>popup.html: 右键点击插件图标 -&gt; “检查弹出窗口”。<br>content.js: 在目标网页的开发者工具中找到对应的 content script 标签页。<br>background.js: 在 chrome://extensions 页面，找到你的插件，点击 “service worker” 链接进行调试。</p></blockquote><h3 id="preview-amp-source"><a href="#preview-amp-source" class="headerlink" title="preview&amp;source"></a>preview&amp;source</h3><p><img src="/2025/08/13/Chrome-浏览器插件开发/1.gif" alt="img"><br><a href="https://github.com/jinux7/study-collections/tree/master/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/my-first-extension" target="_blank" rel="noopener">源码</a></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>一个简单的翻译插件<br><img src="/2025/08/13/Chrome-浏览器插件开发/2.gif" alt="img"><br><a href="https://github.com/jinux7/study-collections/tree/master/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/%E7%BF%BB%E8%AF%91" target="_blank" rel="noopener">源码</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://18055975947.github.io/extension/" target="_blank" rel="noopener">Chrome 浏览器插件开发实践指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chrome浏览器插件开发入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="浏览器" scheme="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Chrome DevTools面板功能详解</title>
    <link href="/2025/07/24/Chrome-DevTools%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/"/>
    <id>/2025/07/24/Chrome-DevTools面板功能详解/</id>
    <published>2025-07-24T06:49:07.000Z</published>
    <updated>2025-08-06T05:18:26.584Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome DevTools面板的功能介绍<br><a id="more"></a><br>Chrome DevTools是一组内置在Google Chrome浏览器中的web开发者工具。凭借着简单、快捷、强大的功能，使得越来越受到开发者的青睐。</p><h2 id="Elements面板"><a href="#Elements面板" class="headerlink" title="Elements面板"></a>Elements面板</h2><h3 id="css调试"><a href="#css调试" class="headerlink" title="css调试"></a>css调试</h3><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p>选中目标节点，element 面版，查看 style-&gt;:hov, 选择对应的状态即可<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements1.png" alt="img"><br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements2.png" alt="img"></p><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>有时候样式覆盖过多，查看起来很麻烦，<code>computed</code>就派上用场了<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements3.png" alt="img"><br>点击某个样式可以直接跳转至对应<code>css</code>定义</p><h4 id="调整某个元素的数值"><a href="#调整某个元素的数值" class="headerlink" title="调整某个元素的数值"></a>调整某个元素的数值</h4><p>选中想要更改的值，按方向键上下就可以 + / - 1 个单位的值</p><blockquote><p>alt + 方向键 可以 ×10 调整单位值<br>Ctrl + 方向键 可以 ×100 调整单位值<br>shift + 方向键 可以 /10 调整单位</p></blockquote><h3 id="html-调试"><a href="#html-调试" class="headerlink" title="html 调试"></a>html 调试</h3><h4 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h4><p>选中节点，直接按键盘<code>H</code>可以直接让元素<code>显示/隐藏</code>，不用手动敲样式了，效果等同<code>visibility: hidden</code>，还是要占据盒模型空间的。<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements4.png" alt="img"></p><h4 id="将某个元素存储到全局临时变量中"><a href="#将某个元素存储到全局临时变量中" class="headerlink" title="将某个元素存储到全局临时变量中"></a>将某个元素存储到全局临时变量中</h4><p>选中节点，右键，<code>Store as global variable</code>（在<code>network</code>面板中也能用，尤其是筛选接口的返回值很方便）<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements5.png" alt="img"></p><h4 id="滚动到某个节点"><a href="#滚动到某个节点" class="headerlink" title="滚动到某个节点"></a>滚动到某个节点</h4><p>如果页面很长，想找一个文本节点的显示位置又不想手动滑动可以试试<code>Scroll into view</code><br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements6.png" alt="img"></p><h4 id="Edge专属的3D视图"><a href="#Edge专属的3D视图" class="headerlink" title="Edge专属的3D视图"></a>Edge专属的3D视图</h4><p>使用<code>chromium</code>后的<code>Edge</code>真的是改头换面<code>3D</code>视图可以帮忙定位一些定位层级还有<code>DOM</code>嵌套的问题，页面结构写的好不好看很直观的可以看出来 (跟辅助功能里面的<code>dom</code>树结合使用很舒服)<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements7.png" alt="img"><br>目前<code>chrome</code>还是没有这项功能的，<code>Edge</code>打开位置：<code>F12</code>=&gt;切换面板最后<code>+</code>(更多工具) 选择<code>3D</code>视图面板</p><h3 id="DOM-断点"><a href="#DOM-断点" class="headerlink" title="DOM 断点"></a>DOM 断点</h3><p>可以监听到<code>DOM</code>节点的变更(子节点变动/属性变更/元素移除)，并断点至变更<code>DOM</code>状态的<code>js</code>代码行：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/elements8.png" alt="img"></p><h2 id="Console面板"><a href="#Console面板" class="headerlink" title="Console面板"></a>Console面板</h2><h3 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h3><p>首先看一下 console 对象下面都有哪些方法:<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/console1.png" alt="img"></p><h4 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a>console.clear()</h4><p>清空控制台</p><h4 id="console-log-info-warn-error"><a href="#console-log-info-warn-error" class="headerlink" title="console.log(), info(), warn(), error()"></a>console.log(), info(), warn(), error()</h4><p>这些是比较常用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;普通信息&apos;)</span><br><span class="line">console.info(&apos;提示性信息&apos;)</span><br><span class="line">console.error(&apos;错误信息&apos;)</span><br><span class="line">console.warn(&apos;警示信息&apos;)</span><br></pre></td></tr></table></figure></p><h4 id="使用占位符"><a href="#使用占位符" class="headerlink" title="使用占位符"></a>使用占位符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 支持逗号分隔参数，不需要每个参数都单独打印</span><br><span class="line">console.log(1, &apos;2&apos;, +&apos;3&apos;)</span><br><span class="line">// 占位符</span><br><span class="line">// %s </span><br><span class="line">console.log(&apos;今晚%s 老虎&apos;, &apos;打&apos;, &apos;？？？&apos;)</span><br><span class="line">// %c </span><br><span class="line">console.log(&apos;今晚%s%c 老虎&apos;, &apos;打&apos;, &apos;color: red&apos;, &apos;？？？&apos;)</span><br><span class="line">// 带有占位符的参数之后的若干参数属于占位符的配置参数</span><br></pre></td></tr></table></figure><p>其余的占位符列表还有：</p><table><thead><tr><th>占位符</th><th>功能</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%d</td><td>数字</td></tr><tr><td>%i</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%o</td><td>对象</td></tr><tr><td>%c</td><td>css样式</td></tr></tbody></table><h4 id="console-time-timeEnd"><a href="#console-time-timeEnd" class="headerlink" title="console.time(), timeEnd()"></a>console.time(), timeEnd()</h4><p><code>time</code>和<code>timeEnd</code>一般放在一起用，传入一个参数用来标识起始位置用于统计时间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;t&apos;)</span><br><span class="line">Array(900000).fill(&#123;&#125;).forEach((v, index) =&gt; v.index = index)</span><br><span class="line">console.timeEnd(&apos;t&apos;)</span><br><span class="line">// t: 28.18603515625ms</span><br></pre></td></tr></table></figure></p><p>会打印出中间代码的执行时间</p><h4 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h4><p>计数, 可以用来统计某个函数的执行次数，也可以传入一个参数，并且根据传入的参数分组统计调用的次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(type = &apos;&apos;) &#123;</span><br><span class="line">  type ? console.count(type) : console.count()</span><br><span class="line">  return &apos;type：&apos; + type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&apos;A&apos;) //A: 1</span><br><span class="line">foo(&apos;B&apos;) //B: 1</span><br><span class="line">foo()    //default: 1</span><br><span class="line">foo()    //default: 2</span><br><span class="line">foo()    //default: 3</span><br><span class="line">foo(&apos;A&apos;) //A: 2</span><br></pre></td></tr></table></figure></p><h4 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace()"></a>console.trace()</h4><p>用于追踪代码的调用栈，不用专门断点去看了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.trace()</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.trace()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><h4 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h4><p>console.table() 方法可以将复合类型的数据转为表格显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">  &#123; name: &apos;梅西&apos;, qq: 10 &#125;,</span><br><span class="line">  &#123; name: &apos;C 罗&apos;, qq: 7 &#125;,</span><br><span class="line">  &#123; name: &apos;内马尔&apos;, qq: 11 &#125;,</span><br><span class="line">]</span><br><span class="line">console.table(arr)</span><br></pre></td></tr></table></figure></p><h4 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir()"></a>console.dir()</h4><p>按便于阅读和打印的形式将对象打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;justwe7&apos;,</span><br><span class="line">  age: 26,</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    alert(&apos;justwe7&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj)</span><br><span class="line">console.dir(obj)</span><br></pre></td></tr></table></figure></p><h4 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h4><p>断言，用来进行条件判断。当表达式为 false 时，则显示错误信息，不会中断程序执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var val = 1</span><br><span class="line">console.assert(val === 1, &apos;等于 1&apos;)</span><br><span class="line">console.assert(val !== 1, &apos;不等于 1&apos;)</span><br><span class="line">console.log(&apos;代码往下执行呢啊&apos;)</span><br></pre></td></tr></table></figure></p><h4 id="console-group-groupEnd"><a href="#console-group-groupEnd" class="headerlink" title="console.group(), groupEnd()"></a>console.group(), groupEnd()</h4><p>分组输出信息，可以用鼠标折叠/展开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.group(&apos;分组 1&apos;)</span><br><span class="line">console.log(&apos;分组 1-1111&apos;)</span><br><span class="line">console.log(&apos;分组 1-2222&apos;)</span><br><span class="line">console.log(&apos;分组 1-3333&apos;)</span><br><span class="line">console.groupEnd()</span><br><span class="line">console.group(&apos;分组 2&apos;)</span><br><span class="line">console.log(&apos;分组 2-1111&apos;)</span><br><span class="line">console.log(&apos;分组 2-2222&apos;)</span><br><span class="line">console.log(&apos;分组 2-3333&apos;)</span><br><span class="line">console.groupEnd()</span><br></pre></td></tr></table></figure></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="$ 选择器"></a>$ 选择器</h3><h4 id><a href="#" class="headerlink" title="$_"></a>$_</h4><p>可以记录上次计算的结果，直接用于代码执行:<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/console2.png" alt="img"></p><h4 id="0-1…-4"><a href="#0-1…-4" class="headerlink" title="$0,$1…$4"></a>$0,$1…$4</h4><p>代表最近 5 个审查元素选中过的 DOM 节点，看图（是要选中一下，我更喜欢用存储全局变量的方式玩，省的自己手残又选了一个节点）：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/console3.png" alt="img"></p><h4 id="和"><a href="#和" class="headerlink" title="$和?"></a>$和?</h4><ul><li>$(selector)是原生 document.querySelector() 的封装。</li><li>?(selector)返回的是所有满足选择条件的元素的一个集合，是 document.querySelectorAll() 的封装</li></ul><h4 id="x"><a href="#x" class="headerlink" title="$x"></a>$x</h4><p>将所匹配的节点放在一个数组里返回<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>li 下的 p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>li 下的 p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>li 下的 p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>外面的 p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$x(<span class="string">'//li'</span>) <span class="comment">// 所有的 li</span></span><br><span class="line">$x(<span class="string">'//p'</span>) <span class="comment">// 所有的 p</span></span><br><span class="line">$x(<span class="string">'//li//p'</span>) <span class="comment">// 所有的 li 下的 p</span></span><br><span class="line">$x(<span class="string">'//li[p]'</span>) <span class="comment">// 所有的 li 下的 p</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/console4.png" alt="img"></p><h4 id="keys-values"><a href="#keys-values" class="headerlink" title="keys(), values()"></a>keys(), values()</h4><p>跟 ES6 对象扩展方法，<code>Object.keys()</code>和<code>Object.values()</code>相同<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys(obj);</span><br><span class="line">values(obj);</span><br></pre></td></tr></table></figure></p><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>可以直接将变量复制到剪贴板<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(temp1)</span><br></pre></td></tr></table></figure></p><h2 id="Sources面板"><a href="#Sources面板" class="headerlink" title="Sources面板"></a>Sources面板</h2><p>主要用来调试页面中的 JavaScript</p><h3 id="自定义代码片段-Snippets"><a href="#自定义代码片段-Snippets" class="headerlink" title="自定义代码片段 Snippets"></a>自定义代码片段 Snippets</h3><blockquote><p>经常有些<code>JavaScript</code>的代码想在控制台中调试，假如代码量多的情况下直接在<code>console</code>下写比较麻烦，在<code>Snippets</code>中写非常方便。</p></blockquote><p>如图所示，在 Sources 这个tab栏下，有个 Snippets 标签，在里面可以添加一些常用的代码片段。<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources1.png" alt="img"></p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="断点的面板"><a href="#断点的面板" class="headerlink" title="断点的面板"></a>断点的面板</h4><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources2.png" alt="img"><br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources3.png" alt="img"></p><h4 id="指定位置的中断"><a href="#指定位置的中断" class="headerlink" title="指定位置的中断"></a>指定位置的中断</h4><p>找到源代码，点击要中断代码执行的位置，点击红色按钮的位置。然后再触发该方法执行，因为已知点击按钮可以触发，精准的定位到代码行就可以了:<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources4.png" alt="img"></p><h4 id="全局事件中断"><a href="#全局事件中断" class="headerlink" title="全局事件中断"></a>全局事件中断</h4><p>假如不知道代码执行的位置，如以下场景：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources5.png" alt="img"><br>看接口返回的列表总数应该是 20 条，但是页面到 15 条就显示到底部了<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources6.png" alt="img"><br>看代码写的判断条件有点问题，但从编译后的代码找到对应位置进行调试就相当于大海捞针了。想试试自己的设想的解决方式是否正确：</p><ul><li>1.因为列表是提拉加载，所以肯定会触发网络请求，可以在事件侦听器里面打一个XHR的断点</li><li>2.然后提拉加载页面触发接口请求，如预期的，代码中断执行了。但提示找不到sourcemap，暂时把 js 的资源映射给关掉<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources7.png" alt="img"><br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources8.png" alt="img"></li><li>3.再次触发断点，发现可以查看到中断的代码了，因为肯定是页面中的业务代码将请求推入到执行堆栈的，所以可以在堆栈中找到对应的方法名：<code>getVideoList</code><br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources9.png" alt="img"></li><li>4.点击方法名可以跳转到对应的源码，可以看到圈起来的代码和所猜想的问题代码应该是同一处<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources10.png" alt="img"></li><li>5.回过来看下问题原因： 页面请求完新数据后直接 pageNum 自增，然后直接就用于是否结束的判断了，有点不够严谨，不如直接比对当前的列表长度与接口返回的数据总数来判断:<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources11.png" alt="img"></li><li>6.记住要修改的代码，在这个文件开头，也就是 191.xxx.js<br>第一行先打个断点，push 方法之前再打一个断点:<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources12.png" alt="img"><br>(如果没有再刷新一下)<br>然后刷新页面，找到刚刚想要修改的代码: 用<code>t.recommendList.length</code>替换掉<code>n.pageSize*t.pageNo</code>（前两步是为了避免 js 开始解析问题代码，先阻塞一下运行</li><li>7.再<code>Ctrl+S</code>，保存一下，然后看下页面效果，列表可以全部加载出来了:<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources13.png" alt="img"><blockquote><p>在美化代码的面板中是不支持直接修改页面代码的</p></blockquote></li></ul><h4 id="黑盒模式"><a href="#黑盒模式" class="headerlink" title="黑盒模式"></a>黑盒模式</h4><p>把脚本文件放入 Blackbox(黑盒)，可以忽略来自第三方库的调用堆栈<br>默认（不开启黑盒）：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources14.png" alt="img"><br>开启黑盒：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/sources15.png" alt="img"></p><ul><li>打开方式①<blockquote><p>打开<code>DevTools Settings</code>(设置)<br>在左侧的导航菜单中，单击<code>Blackboxing</code>(黑箱)<br>点击<code>Add pattern...</code>(添加模式) 按钮。<br>在<code>Pattern</code>(模式) 文本框输入您希望从调用堆栈中排除的文件名模式。<code>DevTools</code>会排除该模式匹配的任何脚本。<br>在文本字段右侧的下拉菜单中，选择<code>Blackbox</code>(黑箱)以执行脚本文件但是排除来自调用堆栈的调用，或选择<code>Disabled</code>(禁用)来阻止文件执行。<br>点击<code>Add</code>(添加) 保存</p></blockquote></li><li>打开方式②<br>直接在想要忽略的堆栈信息上<code>blackbox script</code></li></ul><h4 id="DOM-断点-1"><a href="#DOM-断点-1" class="headerlink" title="DOM 断点"></a>DOM 断点</h4><p>查看<code>element</code>面板<a href="#DOM-断点"><code>DOM</code>断点</a></p><h2 id="Network面板"><a href="#Network面板" class="headerlink" title="Network面板"></a>Network面板</h2><blockquote><p>可以查看通过网络请求的资源的相关详细信息</p></blockquote><p>按区域划分大概分为如下几个区域：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network1.png" alt="img"></p><blockquote><ul><li><code>Controls</code>-控制<code>Network</code>功能选项，以及一些展示外观</li><li><code>Filters</code>-控制在<code>Requests Table</code>中显示哪些类型的资源(tips：按住<code>Cmd(Mac)</code>或<code>Ctrl (Windows/Linux)</code>并点击筛选项可以同时选择多个筛选项)</li><li><code>Overview</code>-此图表显示了资源检索时间的时间线。如果看到多条竖线堆叠在一起，则说明这些资源被同时检索</li><li><code>Requests Table</code>-此表格列出了检索的每一个资源。 默认情况下，此表格按时间顺序排序，最早的资源在顶部。点击资源的名称可以显示更多信息。 提示：右键点击<code>Timeline</code>以外的任何一个表格标题可以添加或移除信息列</li><li><code>Summary</code>-可以一目了然地看到页面的请求总数、传输的数据总量、加载时间</li></ul></blockquote><h3 id="Controls，Filters-区域"><a href="#Controls，Filters-区域" class="headerlink" title="Controls，Filters 区域"></a>Controls，Filters 区域</h3><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/network2.png" alt="img"><br>Filters 控制的展示：</p><ul><li>使用大请求行-默认情况下，<code>Requests Table</code>一个资源只显示很小的一行。选中<code>Use large resource rows</code>(使用大资源行) 按钮可以显示两个文本字段：主要字段和次要字段。</li><li>捕获屏幕截图-将鼠标悬停在某个屏幕截图上的时候，<code>Timeline/Waterfall</code>(时间轴) 会显示一条垂直的黄线，指示该帧是何时被捕获的</li><li>显示概述 - 展示页面整个生命周期的各个阶段（Overview 区域）的耗时（蓝色绿色的那些横杠）</li></ul><h3 id="Overview-区域"><a href="#Overview-区域" class="headerlink" title="Overview 区域"></a>Overview 区域</h3><p>页面整个生命周期的各个阶段网络资源加载耗时信息的汇总，可以选择区域来筛选<code>Requests Table</code>的详细资源信息</p><h3 id="Requests-Table-区域"><a href="#Requests-Table-区域" class="headerlink" title="Requests Table 区域"></a>Requests Table 区域</h3><p>标题栏的对应描述：</p><blockquote><ul><li><code>Name</code>(名称): 资源的名称。</li><li><code>Status</code>(状态): <code>HTTP</code> 状态代码。</li><li><code>Type</code>(类型): 请求的资源的 <code>MIME</code> 类型。</li><li><code>Initiator</code>(发起): 发起请求的对象或进程。它可能有以下几种值：<br>  <code>Parser</code>(解析器): <code>Chrome</code> 的 <code>HTML</code> 解析器发起了请求。<br>  <code>Redirect</code>(重定向): <code>HTTP</code> 重定向启动了请求。<br>  <code>Script</code>(脚本): 脚本启动了请求。<br>  <code>Other</code>(其他): 一些其他进程或动作发起请求，例如用户点击链接跳转到页面，或在地址栏中输入网址。</li><li><code>Size</code>(大小): 响应头的大小（通常是几百字节）加上响应数据，由服务器提供。</li><li><code>Time</code>(时间): 总持续时间，从请求的开始到接收响应中的最后一个字节</li><li><code>Timeline/Waterfall</code>(时间轴): 显示所有网络请求的可视化统计信息</li></ul></blockquote><p>在标题栏如 (Name 上) 右键，可以添加或删除信息列。比如可以多加一列<code>Response Header =&gt; Content-Encoding</code>选项来总览页面资源的<code>gzip</code>压缩情况:</p><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/network3.png" alt="img"></p><h4 id="重新发起xhr请求"><a href="#重新发起xhr请求" class="headerlink" title="重新发起xhr请求"></a>重新发起xhr请求</h4><p>在平时和后端联调时，我们用的最多的可能就是Network面板了。但是每次想重新查看一个请求通过刷新页面、点击按钮等方式去触发xhr请求，这种方式有时显得会比较麻烦，可以通过Replay XHR的方式去发起一条新的请求：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network4.png" alt="img"></p><h4 id="查看-HTTP-相关信息"><a href="#查看-HTTP-相关信息" class="headerlink" title="查看 HTTP 相关信息"></a>查看 HTTP 相关信息</h4><p>查看网络请求的参数<br>可以通过点击<code>query string parameters</code>(查询字符串参数) 旁边的<code>view URL encoded</code>(查看 URL 编码) 或<code>view decoded</code>(查看解码) 链接，查看<code>URL</code>编码或解码格式的<code>query string parameters</code>(查询字符串参数)。在使用<code>postman</code>复制相关入参时尤其实用。<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network5.png" alt="img"><br>查看<code>HTTP</code>响应内容 点击<code>Response</code>(响应) 标签页可以查看该资源未格式化的<code>HTTP</code>响应内容<br>接口的返回值 (在<code>preview</code>中）同样也可以<code>Save global variable</code>存储一个全局变量<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network6.png" alt="img"></p><h4 id="Size-和-Time-为什么有两行参数？"><a href="#Size-和-Time-为什么有两行参数？" class="headerlink" title="Size 和 Time 为什么有两行参数？"></a>Size 和 Time 为什么有两行参数？</h4><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/network7.png" alt="img"></p><h5 id="Size列"><a href="#Size列" class="headerlink" title="Size列"></a>Size列</h5><p>第一行表示的是数据的传输时的大小，例如上图中的<code>190KB</code><br>第二行表示的是数据实际的大小<code>708KB</code></p><blockquote><p>在服务器端采取<code>gzip</code>压缩算法将原有<code>708KB</code>压缩至<code>190KB</code>, 传输大小缩短<code>3.7</code>倍，大大的提高了资源传输的效率</p></blockquote><p>需要注意的点：<br><code>gzip</code>压缩只会压缩响应体内容，所以适用于返回数据量大的时候，如果数据量太小的话，有可能会导致数据传输时的大小比实际大小要大 (加入了一些额外的响应头)</p><h5 id="Time列"><a href="#Time列" class="headerlink" title="Time列"></a>Time列</h5><p>第一行表示从客户端发送请求到服务端返回所有数据所花费的总时间，对于上图来说就是<code>471ms</code><br>第二行表示的是从客户端发送请求到服务器端返回第一个字节所表示的时间，对于上图来说就是<code>55ms</code></p><blockquote><p>第一行的时间代表了所有项目：例如解析<code>dns</code>，建立连接，等待服务器返回数据，传输数据等<br>第二行的时间是 总时间-数据传输的时间</p></blockquote><p>从上面的分析中我们看到 从客户端请求到服务器处理结束准备返回数据花了<code>55ms</code>，但是在进行传输数据的时候花费了<code>471ms</code><br>对于网慢的用户来说，可能会耗费更长的时间，所以在写代码（接口）的时候，返回的数据量要尽量精简</p><h4 id="Waterfall"><a href="#Waterfall" class="headerlink" title="Waterfall"></a>Waterfall</h4><p>点击某个资源会展示出详细的网络加载信息：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network8.png" alt="img"><br>相关字段描述:</p><ul><li><p><code>Queuing</code> (排队)</p><blockquote><p>浏览器在以下情况下对请求排队</p><ul><li>存在更高优先级的请求, 请求被渲染引擎推迟，这经常发生在<code>images</code>（图像）上, 因为它被认为比关键资源（如脚本 / 样式）的优先级低。</li><li>此源已打开六个<code>TCP</code>连接，达到限值，仅适用于<code>HTTP/1.0</code>和<code>HTTP/1.1</code>。在等待一个即将被释放的不可用的<code>TCP socket</code></li><li>浏览器正在短暂分配磁盘缓存中的空间，生成磁盘缓存条目（通常非常快）</li></ul></blockquote></li><li><p><code>Stalled</code>(停滞)-发送请求之前等待的时间。它可能因为进入队列的任意原因而被阻塞，这个时间包括代理协商的时间。请求可能会因<code>Queueing</code>中描述的任何原因而停止。</p></li><li><code>DNS lookup</code>(DNS 查找) - 浏览器正在解析请求<code>IP</code>地址，页面上的每个新域都需要完整的往返(<code>roundtrip</code>)才能进行<code>DNS</code>查找</li><li><code>Proxy Negotiation</code>-浏览器正在与代理服务器协商请求</li><li><code>initial connection</code>(初始连接)-建立连接所需的时间，包括<code>TCP</code>握手/重试和协商<code>SSL</code>。</li><li><code>SSL handshake</code>(SSL握手)-完成<code>SSL</code>握手所用的时间</li><li><code>Request sent</code>(请求发送)-发出网络请求所花费的时间，通常是几分之一毫秒。</li><li><code>Waiting</code>(等待)-等待初始响应所花费的时间，也称为<code>Time To First Byte</code>(接收到第一个字节所花费的时间)。这个时间除了等待服务器传递响应所花费的时间之外，还包括<code>1</code>次往返延迟时间及服务器准备响应所用的时间（服务器发送数据的延迟时间）</li><li><code>Content Download</code>(内容下载)-接收响应数据所花费的时间 (从接收到第一个字节开始，到下载完最后一个字节结束)</li><li><code>ServiceWorker Preparation</code>-浏览器正在启动<code>Service Worker</code></li><li><code>Request to ServiceWorker</code>-正在将请求发送到<code>Service Worker</code></li><li><code>Receiving Push</code>-浏览器正在通过<code>HTTP/2</code>服务器推送接收此响应的数据</li><li><code>Reading Push</code>-浏览器正在读取之前收到的本地数据<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network8-1.png" alt="img"><h3 id="Summary-区域"><a href="#Summary-区域" class="headerlink" title="Summary 区域"></a>Summary 区域</h3><img src="/2025/07/24/Chrome-DevTools面板功能详解/network9.png" alt="img"><br><code>requests</code>查看请求的总数量|<code>transferred</code>查看请求的总大小|<code>resources</code>资源|<code>Finish</code>所有<code>http</code>请求响应完成的时间|<code>DOMContentLoaded</code>时间|<code>load</code>时间<br>当页面的初始的标记被解析完时，会触发<code>DOMContentLoaded</code>。它在<code>Network</code>(网络) 面板上的显示：<blockquote><ul><li>在<code>Overview</code>(概览) 窗格中的蓝色垂直线表示这个事件。</li><li>在<code>Requests Table</code>(请求列表) 中的红色垂直线也表示这个事件。</li><li>在<code>Summary</code>(概要) 窗格中，您可以查看事件的确切时间。</li></ul></blockquote></li></ul><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/network10.png" alt="img"><br>当页面完全加载时触发<code>load</code>事件。</p><blockquote><ul><li>在<code>Overview</code>(概览)窗格的红色垂直线表示这个事件。</li><li>在<code>Requests Table</code>(请求列表)中的红色垂直线也表示这个事件。</li><li>在<code>Summary</code>(概要)中，可以查看改事件的确切时间。</li></ul></blockquote><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/network11.png" alt="img"></p><blockquote><ul><li><code>DOMContentLoaded</code>会比<code>Load</code>时间小，两者时间差大致等于外部资源加载（一般是图片 / 字体）的时间</li><li><code>Finish</code>时间是页面上所有<code>http</code>请求发送到响应完成的时间（如果页面存在一个轮询的接口，这个值也会累加的）。<code>HTTP1.0/1.1</code>协议限定单个域名的请求并发量是<code>6</code>个，即<code>Finish</code>是所有请求（不只是<code>XHR</code>请求，还包括<code>DOC，img，js，css</code>等资源的请求）在并发量为<code>6</code>的限制下完成的时间。<ul><li><code>Finish</code>的时间比<code>Load</code>大，意味着页面有相当部分的请求量</li><li><code>Finish</code>的时间比<code>Load</code>小，意味着页面请求量很少，如果页面是只有一个<code>html</code>文档请求的静态页面，<code>Finish</code>时间基本就等于<code>HTML</code>文档请求的时间</li></ul></li><li>所以<code>Finish</code>时间与<code>DOMContentLoaded</code>和<code>Load</code>并无直接关系</li></ul></blockquote><h3 id="使用-Network-面板进行网络优化"><a href="#使用-Network-面板进行网络优化" class="headerlink" title="使用 Network 面板进行网络优化"></a>使用 Network 面板进行网络优化</h3><h4 id="排队或停止阻塞"><a href="#排队或停止阻塞" class="headerlink" title="排队或停止阻塞"></a>排队或停止阻塞</h4><p>最常见的问题是很多个请求排队或被阻塞。这表示从单个客户端检索的资源太多。在<code>HTTP 1.0/1.1</code>连接协议中，<code>Chrome</code>限制每个域名最多执行<code>6</code>个<code>TCP</code> 连接。如果一次请求十二个资源，前<code>6</code>个将开始，后<code>6</code>个将排队。一旦其中一个请求完成，队列中的第一个请求项目将开始其请求过程。<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network12.png" alt="img"><br>要解决传统<code>HTTP 1</code>的此问题，需要用多个子域名提供服务资源，将资源拆分到多个子域中，均匀分配。</p><blockquote><p>上面说的修复<code>HTTP 1</code>连接数问题，不适用于<code>HTTP 2</code>连接，如果已部署<code>HTTP 2</code>，不要对资源进行域划分，因为它会影响<code>HTTP 2</code>的工作原理（在 <code>HTTP 2</code>中<code>TCP</code>连接多路复用连接的）。取消了<code>HTTP 1</code>的<code>6</code>个连接限制，并且可以通过单个连接同时传输多个资源。</p></blockquote><h4 id="接收到第一个字节的时间很慢"><a href="#接收到第一个字节的时间很慢" class="headerlink" title="接收到第一个字节的时间很慢"></a>接收到第一个字节的时间很慢</h4><p>绿色的块占据比例很高：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network13.png" alt="img"><br><code>TTFB</code>就是等待第一个响应字节的时间，建议在<code>200ms</code>以下，以下情况可能会导致高<code>TTFB</code>:</p><ul><li>客户端和服务器之间的网络条件差</li><li>要么，服务器端程序响应很慢</li></ul><blockquote><p>为了解决高<code>TTFB</code>，首先去排除尽可能多的网络连接。理想情况下，在本地托管应用程序（部署在本地），并查看是否仍有一个大的<code>TTFB</code>。如果有，那么需要优化应用程序针的响应速度。这可能意味着优化数据库查询，为内容的某些部分实现高速缓存，或修改<code>Web</code>服务器配置。后端可能很慢的原因有很多。您需要对您的程序进行研究，并找出不符合您预期的内容。<br>如果本地<code>TTFB</code>低，那么是您的客户端和服务器之间的网络问题。网络传输可能被很多种事情干扰阻碍。在客户端和服务器之间有很多点，每个都有自己的连接限制，可能会导致问题。测试减少这种情况的最简单的方法是将您的应用程序放在另一台主机上，看看<code>TTFB</code>是否改进。</p></blockquote><h4 id="加载缓慢"><a href="#加载缓慢" class="headerlink" title="加载缓慢"></a>加载缓慢</h4><p>蓝色的块占据比例很高：<br><img src="/2025/07/24/Chrome-DevTools面板功能详解/network14.png" alt="img"><br>如果<code>Content Download</code>(内容下载)阶段花费了很多时间，提高服务响应速度、并行下载等优化措施帮助都不大。主要的解决方案是发送更少的字节（比如一张高质量的大图可能几<code>M</code>的大小，这时可以酌情优化一下图片的宽高/清晰度）</p><h2 id="Performance面板"><a href="#Performance面板" class="headerlink" title="Performance面板"></a>Performance面板</h2><p><a href="https://juejin.cn/post/7149093181244571678" target="_blank" rel="noopener">参考</a></p><h2 id="Memory面板"><a href="#Memory面板" class="headerlink" title="Memory面板"></a>Memory面板</h2><p><a href="https://juejin.cn/post/7064778114177433636" target="_blank" rel="noopener">参考</a></p><h2 id="Application面板"><a href="#Application面板" class="headerlink" title="Application面板"></a>Application面板</h2><p><a href="https://juejin.cn/post/7072651028113391646" target="_blank" rel="noopener">参考</a></p><h2 id="Security面板"><a href="#Security面板" class="headerlink" title="Security面板"></a>Security面板</h2><blockquote><p>用于检测当面页面的安全性</p></blockquote><p>该面板可以区分两种类型的不安全的页面：</p><ul><li>如果被请求的页面通过<code>HTTP</code>提供服务，那么这个主源就会被标记为不安全。</li><li>如果被请求的页面是通过<code>HTTP</code> 获取的，但这个页面接着通过<code>HTTP</code>继续从其他来源检索内容，那么这个页面仍然被标记为不安全。这就是所谓的混合内容页面, 混合内容页面只是部分受到保护, 因为<code>HTTP</code>内容 (非加密的内容通信使用明文) 可能会被窃听, 容易受到中间人攻击。如 163，虽然证书是有效的，但是页面有一部分<code>http</code>资源：</li></ul><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/security.png" alt="img"></p><h2 id="Lighthouse面板"><a href="#Lighthouse面板" class="headerlink" title="Lighthouse面板"></a>Lighthouse面板</h2><blockquote><p><code>Lighthouse</code>是一个开源的自动化工具，用于改进网络应用的质量。您可以将其作为一个<code>Chrome</code>扩展程序运行，或从命令行运行。您为<code>Lighthouse</code>提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告，会对页面的加载进行分析，然后给出提高页面性能的建议。</p></blockquote><p><img src="/2025/07/24/Chrome-DevTools面板功能详解/lighthouse.png" alt="img"></p><ul><li><code>Performance</code>性能</li><li><code>accessibility</code>无障碍使用</li><li><code>Best Practice</code>用户体验</li><li><code>SEO</code>优化</li><li><code>Progressive Web App</code>页对于<code>PWA</code>的兼容性</li></ul><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><h3 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h3><p>快捷键<code>Ctrl + Shift + P</code></p><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>快捷键<code>Ctrl + P</code></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><p><code>Ctrl + Shift + P</code>进入快捷模式，输入<code>capture</code>，选择<code>capture full size screenshot</code>是全屏截图，选择<code>capture node screenshot</code>是当前节点的截图。</p><h4 id="js覆盖率"><a href="#js覆盖率" class="headerlink" title="js覆盖率"></a>js覆盖率</h4><p><code>Ctrl + Shift + P</code>进入快捷模式，输入<code>show coverage</code>。</p><h4 id="css-overview"><a href="#css-overview" class="headerlink" title="css overview"></a>css overview</h4><p><code>Ctrl + Shift + P</code>进入快捷模式，输入<code>show css overview</code>。</p><p><a href="https://juejin.cn/post/7063005570898329636" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chrome DevTools面板的功能介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="浏览器" scheme="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Yjs协同库入门</title>
    <link href="/2025/07/22/Yjs%E5%8D%8F%E5%90%8C%E5%BA%93%E5%85%A5%E9%97%A8/"/>
    <id>/2025/07/22/Yjs协同库入门/</id>
    <published>2025-07-22T03:09:17.000Z</published>
    <updated>2025-07-23T05:50:10.318Z</updated>
    
    <content type="html"><![CDATA[<p>Yjs协同库介绍及入门<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://yjs.dev/" target="_blank" rel="noopener">Yjs</a>是一个基于 ‌CRDT (Conflict-Free Replicated Data Type)‌ 技术的 JavaScript 库，专为构建‌高性能、实时的协同编辑应用‌而设计，例如在线文档编辑器（类似 Google Docs）、设计工具（如 Figma）或多人在线白板‌。它提供了一套核心的‌模块化构建块‌，开发者可以轻松将其集成到现有或新项目中，以实现复杂的多用户实时协作功能‌。</p><h2 id="核心特性与优势"><a href="#核心特性与优势" class="headerlink" title="核心特性与优势"></a>核心特性与优势</h2><h3 id="‌基于CRDT算法‌："><a href="#‌基于CRDT算法‌：" class="headerlink" title="‌基于CRDT算法‌："></a>‌基于CRDT算法‌：</h3><p>这是Yjs的核心基础。CRDT 是一种数据结构，确保即使在网络延迟、消息乱序或用户并发编辑的情况下，所有参与者的数据最终都能达成一致状态，无需中心化协调或复杂的冲突解决逻辑‌。<br>官方测试表明，Yjs 是‌目前性能最高的 CRDT 实现之一‌‌。</p><h3 id="‌模块化设计‌："><a href="#‌模块化设计‌：" class="headerlink" title="‌模块化设计‌："></a>‌模块化设计‌：</h3><p>Yjs本身提供数据结构（如 Y.Array, Y.Map, Y.Text）和协同算法。它不是一个大而全的框架，而是专注于解决协同编辑的底层数据一致性难题‌。<br>这种设计使其能灵活地与各种‌编辑器框架‌（如 Quill, Monaco, CodeMirror, TipTap, Slate 等）和‌网络传输协议‌（WebSockets, WebRTC, 甚至本地通信或离线存储）集成‌。‌</p><h3 id="高性能‌："><a href="#高性能‌：" class="headerlink" title="高性能‌："></a>高性能‌：</h3><p>优化了操作同步和状态合并的效率，能够处理大量用户的高频编辑操作‌。</p><h3 id="离线优先与实时同步‌："><a href="#离线优先与实时同步‌：" class="headerlink" title="离线优先与实时同步‌："></a>离线优先与实时同步‌：</h3><p>支持用户离线编辑，并在重新上线后自动同步更改‌。<br>提供近乎实时的协作体验。</p><h3 id="丰富的生态系统‌："><a href="#丰富的生态系统‌：" class="headerlink" title="丰富的生态系统‌："></a>丰富的生态系统‌：</h3><p>提供了官方适配器，简化了与流行编辑器的集成（如 y-quill, y-prosemirror, y-monaco 等）‌。<br>支持多种网络通信后端（如 y-websocket, y-webrtc）和持久化存储方案（如 y-indexeddb）‌。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import * as Y from &apos;yjs&apos;</span><br><span class="line">// Yjs文档是会自动同步的共享对象集合</span><br><span class="line">const ydoc = new Y.Doc()</span><br><span class="line">// 定义一个共享的Y.Map实例</span><br><span class="line">const ymap = ydoc.getMap()</span><br><span class="line">ymap.set(&apos;keyA&apos;, &apos;valueA&apos;)</span><br><span class="line">// 创建另一个Yjs文档(模拟远程用户)并创建一些冲突的更改</span><br><span class="line">const ydocRemote = new Y.Doc()</span><br><span class="line">const ymapRemote = ydocRemote.getMap()</span><br><span class="line">ymapRemote.set(&apos;keyB&apos;, &apos;valueB&apos;)</span><br><span class="line">// 合并来自远程的更改</span><br><span class="line">const update = Y.encodeStateAsUpdate(ydocRemote)</span><br><span class="line">Y.applyUpdate(ydoc, update)</span><br><span class="line">// 观察更改已合并</span><br><span class="line">console.log(ymap.toJSON()) // =&gt; &#123; keyA: &apos;valueA&apos;, keyB: &apos;valueB&apos; &#125;</span><br></pre></td></tr></table></figure><h2 id="Yjs-quill"><a href="#Yjs-quill" class="headerlink" title="Yjs+quill"></a>Yjs+quill</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>vite对nodejs的版本有要求，根据提示信息切换nodejs版本。<br>创建项目选择Vanilla</p><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm i --save yjs y-websocket y-quill quill quill-cursors</span><br><span class="line"></span><br><span class="line">// 参考依赖包版本</span><br><span class="line">&quot;quill&quot;: &quot;^2.0.3&quot;,</span><br><span class="line">&quot;quill-cursors&quot;: &quot;^4.0.4&quot;,</span><br><span class="line">&quot;y-quill&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">&quot;y-websocket&quot;: &quot;2.0.4&quot;,</span><br><span class="line">&quot;yjs&quot;: &quot;^13.6.27&quot;</span><br></pre></td></tr></table></figure><h3 id="修改main-js"><a href="#修改main-js" class="headerlink" title="修改main.js"></a>修改main.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import Quill from &apos;quill&apos;;</span><br><span class="line">import QuillCursors from &apos;quill-cursors&apos;;</span><br><span class="line">import &apos;quill/dist/quill.snow.css&apos;; // 使用了 snow 主题色</span><br><span class="line">import * as Y from &apos;yjs&apos;;</span><br><span class="line">import &#123; QuillBinding &#125; from &apos;y-quill&apos;;</span><br><span class="line">import &#123; WebsocketProvider &#125; from &apos;y-websocket&apos;;</span><br><span class="line"></span><br><span class="line">const ydoc = new Y.Doc(); // y 文档对象，保存需要共享的数据</span><br><span class="line">const ytext = ydoc.getText(&apos;quill&apos;); // 创建名为 quill 的 Text 对象</span><br><span class="line"></span><br><span class="line">// 使用 cursors 插件</span><br><span class="line">Quill.register(&apos;modules/cursors&apos;, QuillCursors);</span><br><span class="line"></span><br><span class="line">const quill = new Quill(document.querySelector(&apos;#app&apos;), &#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    cursors: true,</span><br><span class="line">    toolbar: [</span><br><span class="line">      [&#123; header: [1, 2, false] &#125;],</span><br><span class="line">      [&apos;bold&apos;, &apos;italic&apos;, &apos;underline&apos;],</span><br><span class="line">      [&apos;image&apos;, &apos;code-block&apos;],</span><br><span class="line">    ],</span><br><span class="line">    history: &#123;</span><br><span class="line">      userOnly: true, // 用户自己实现历史记录</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  placeholder: &apos;前端西瓜哥...&apos;,</span><br><span class="line">  theme: &apos;snow&apos;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 连接到 websocket 服务端</span><br><span class="line">const provider = new WebsocketProvider(&apos;ws://localhost:1234&apos;, &apos;quill-demo-room&apos;, ydoc);</span><br><span class="line">// 数据模型绑定，再额外绑上了光标对象</span><br><span class="line">const binding = new QuillBinding(ytext, quill, provider.awareness);</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><h4 id="启动web前端"><a href="#启动web前端" class="headerlink" title="启动web前端"></a>启动web前端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h4 id="启动websocket服务端"><a href="#启动websocket服务端" class="headerlink" title="启动websocket服务端"></a>启动websocket服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST=localhost PORT=1234 npx y-websocket</span><br></pre></td></tr></table></figure><p>这句命令要在git bash中执行。<br><code>y-websocket</code>这个包使用的是<code>2.0.4</code>版本，新版本的package.json中已经删除了bin的执行命令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上对Yjs这个协同编辑库做了简单入门。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yjs协同库介绍及入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>下载M3U8格式视频</title>
    <link href="/2025/07/01/%E4%B8%8B%E8%BD%BDM3U8%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91/"/>
    <id>/2025/07/01/下载M3U8格式视频/</id>
    <published>2025-07-01T06:42:45.000Z</published>
    <updated>2025-07-04T06:58:24.173Z</updated>
    
    <content type="html"><![CDATA[<p>使用nodejs下载M3U8格式视频<br><a id="more"></a></p><h2 id="M3U8格式视频播放"><a href="#M3U8格式视频播放" class="headerlink" title="M3U8格式视频播放"></a>M3U8格式视频播放</h2><p>如何播放M3U8格式视频请参考<a href="https://jinux.top/2024/04/19/web%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">这里</a></p><h2 id="M3U8格式视频下载"><a href="#M3U8格式视频下载" class="headerlink" title="M3U8格式视频下载"></a>M3U8格式视频下载</h2><h3 id="解析M3U8文件"><a href="#解析M3U8文件" class="headerlink" title="解析M3U8文件"></a>解析M3U8文件</h3><p>使用<code>m3u8-parser</code>这个库解析。<br>解析后可以得到一个数组，里边有下载ts格式文件的链接等信息。</p><h3 id="下载ts文件"><a href="#下载ts文件" class="headerlink" title="下载ts文件"></a>下载ts文件</h3><p>下载ts文件可以使用<code>axios</code>这个库。<br>为了提高下载速度，可以并行下载多个ts文件，也就是同时使用axios发起多个请求。<br>这里注意一下，同时发起请求的时候别使用<code>Promise.all</code>这个函数，因为<code>Promise.all</code>这个函数等待所有请求成功后执行回调，但是一般一个视频会包含上百个ts文件，好多请求会失败，所以这里使用了<code>Promise.allSettled</code>函数，这个函数等待所有请求都执行完毕，并且执行结果会标注成功或者失败，利用这个特性可以制作<code>fileList.txt</code>文件，后续<code>ffmpeg</code>利用这个文件将ts文件合并成mp4文件。</p><h3 id="创建fileList-txt文件"><a href="#创建fileList-txt文件" class="headerlink" title="创建fileList.txt文件"></a>创建fileList.txt文件</h3><p>fileList.txt文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file qThMvh4b.ts</span><br><span class="line">file JYFQD1Ml.ts</span><br><span class="line">file UxTCj4Lz.ts</span><br><span class="line">file fLEDwwSM.ts</span><br><span class="line">file fbA1SzC5.ts</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="合并ts文件转成mp4"><a href="#合并ts文件转成mp4" class="headerlink" title="合并ts文件转成mp4"></a>合并ts文件转成mp4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg()</span><br><span class="line">.input(path.resolve(TEMPFOLDER, &apos;fileList.txt&apos;))</span><br><span class="line">.inputFormat(&apos;concat&apos;)</span><br><span class="line">.videoCodec(&apos;copy&apos;)</span><br><span class="line">.audioCodec(&apos;copy&apos;)</span><br><span class="line">.format(&apos;mp4&apos;)</span><br><span class="line">.save(path.resolve(&apos;./&apos;, OUTPUTFILENAME));</span><br></pre></td></tr></table></figure><p>这里需要注意，<code>fluent-ffmpeg</code>是nodejs下方便调用ffmpeg的库，所以必须事先在电脑中已经安装好ffmpeg，并且<code>ffmpeg</code>的安装目录必须添加到环境变量中。</p><h3 id="清除ts文件"><a href="#清除ts文件" class="headerlink" title="清除ts文件"></a>清除ts文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.rm(folderPath, &#123; recursive: true, force: true &#125;, (err) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">      throw err;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`$&#123;folderPath&#125; 已被删除`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="electron集成"><a href="#electron集成" class="headerlink" title="electron集成"></a>electron集成</h2><p>上边已经实现了nodejs下载M3U8格式视频，但是使用起来不是很方便，所以这里将代码封装成electron程序，实现界面化操作。<br>具体实现很简单，代码见下面，electron的基础知识参考<a href="https://jinux.top/2024/07/17/electron%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">electron基础入门</a><br><img src="/2025/07/01/下载M3U8格式视频/0.png" alt="img"><br><img src="/2025/07/01/下载M3U8格式视频/1.png" alt="img"><br><img src="/2025/07/01/下载M3U8格式视频/2.png" alt="img"><br><img src="/2025/07/01/下载M3U8格式视频/3.png" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/%E4%B8%8B%E8%BD%BDm3u8%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91" target="_blank" rel="noopener">基础版本代码</a><br><a href="https://github.com/jinux7/study-collections/tree/master/electron/download-m3u8" target="_blank" rel="noopener">集成electron代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用nodejs下载M3U8格式视频&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>uniapp开发纪要</title>
    <link href="/2025/06/09/uniapp%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/"/>
    <id>/2025/06/09/uniapp开发纪要/</id>
    <published>2025-06-09T07:17:23.000Z</published>
    <updated>2025-07-14T01:13:38.398Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些uniapp开发中遇到的问题和解决技巧<br><a id="more"></a></p><h2 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h2><blockquote><p>手机：荣耀200<br>  系统：MagicOs 9.0<br>  HBuilderX版本：4.66</p></blockquote><ul><li>HBuilderX的工具—&gt;设置—&gt;运行配置—&gt;adb路径，换成HBuilderX目录下plugins/launcher-tools/tools/adbs/1.0.36/adb.exe</li><li>设置—&gt;系统和更新—&gt;开发人员选项【USB调试】打开</li><li>设置—&gt;系统和更新—&gt;开发人员选项【“仅充电”模式下允许ADB调试】打开</li><li>设置—&gt;系统和更新—&gt;开发人员选项【选择USB配置】RNDIS(USB以太网)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些uniapp开发中遇到的问题和解决技巧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="uniapp" scheme="/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js实战之Py与Js模型互转</title>
    <link href="/2025/06/04/Tensorflow-js%E5%AE%9E%E6%88%98%E4%B9%8BPy%E4%B8%8EJs%E6%A8%A1%E5%9E%8B%E4%BA%92%E8%BD%AC/"/>
    <id>/2025/06/04/Tensorflow-js实战之Py与Js模型互转/</id>
    <published>2025-06-04T06:31:13.000Z</published>
    <updated>2025-06-05T05:04:44.641Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js-Py与Js模型互转<br><a id="more"></a></p><h2 id="Python模型"><a href="#Python模型" class="headerlink" title="Python模型"></a>Python模型</h2><p>通过Python版本的Tensorflow/Keras生成的模型。<br>包括：Tensorflow Saved Model、Keras HDF5 Model等</p><h2 id="Javascript模型"><a href="#Javascript模型" class="headerlink" title="Javascript模型"></a>Javascript模型</h2><p>可以在Tensorflow.js中运行的模型。<br>包括：tfjs_layers_model、tfjs_graph_model等</p><h2 id="模型互转"><a href="#模型互转" class="headerlink" title="模型互转"></a>模型互转</h2><h3 id="Py模型转Js模型"><a href="#Py模型转Js模型" class="headerlink" title="Py模型转Js模型"></a>Py模型转Js模型</h3><p>使用<a href="https://github.com/tensorflow/tfjs/tree/master/tfjs-converter" target="_blank" rel="noopener">Tensorflow.js-converter</a>工具转换</p><h4 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h4><p>使用conda创建一个Python环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name tfjs python=3.6.8</span><br></pre></td></tr></table></figure></p><h4 id="安装Tensorflow-js-converter包"><a href="#安装Tensorflow-js-converter包" class="headerlink" title="安装Tensorflow.js-converter包"></a>安装Tensorflow.js-converter包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflowjs==2.8.4 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h4 id="转换模型"><a href="#转换模型" class="headerlink" title="转换模型"></a>转换模型</h4><h5 id="tf-saved-model-gt-tfjs-graph-model"><a href="#tf-saved-model-gt-tfjs-graph-model" class="headerlink" title="tf_saved_model-&gt;tfjs_graph_model"></a>tf_saved_model-&gt;tfjs_graph_model</h5><p><a href="https://www.kaggle.com/models/google/mobilenet-v2" target="_blank" rel="noopener">下载tf_saved_model模型</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 转换命令</span><br><span class="line">tensorflowjs_converter --input_format=tf_saved_model --output_format=tfjs_graph_model --signature_name=serving_default --saved_model_tags=serve D:\jinux\github\tensorflow.js-tutorial\code\Py与Js模型互转\source\model\Py\saveModel D:\jinux\github\tensorflow.js-tutorial\code\Py与Js模型互转\source\model\Js\graphModel</span><br></pre></td></tr></table></figure></p><p>见<code>source/example</code>目录下引用转换后模型的案例。</p><blockquote><p>目前其他格式转换报错，还在研究中……</p></blockquote><h3 id="Js模型转Py模型"><a href="#Js模型转Py模型" class="headerlink" title="Js模型转Py模型"></a>Js模型转Py模型</h3><p>很少会用到这种转换</p><h3 id="Js模型转jS模型"><a href="#Js模型转jS模型" class="headerlink" title="Js模型转jS模型"></a>Js模型转jS模型</h3><p>分片、量化、加速</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/Py%E4%B8%8EJs%E6%A8%A1%E5%9E%8B%E4%BA%92%E8%BD%AC/source" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js-Py与Js模型互转&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js实战之预训练模型使用</title>
    <link href="/2025/06/04/Tensorflow-js%E5%AE%9E%E6%88%98%E4%B9%8B%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/"/>
    <id>/2025/06/04/Tensorflow-js实战之预训练模型使用/</id>
    <published>2025-06-04T06:29:07.000Z</published>
    <updated>2025-06-05T05:00:33.627Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js使用预训练模型<br><a id="more"></a><br>这里列举了一些利用Tensorflow.js框架使用预训练模型的例子。</p><h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/图像分类.gif" alt="图像分类"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="视频识物"><a href="#视频识物" class="headerlink" title="视频识物"></a>视频识物</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/视频识物.gif" alt="视频识物"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E8%A7%86%E9%A2%91%E8%AF%86%E7%89%A9/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/语音识别.gif" alt="语音识别"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="面部定位"><a href="#面部定位" class="headerlink" title="面部定位"></a>面部定位</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/面部定位.gif" alt="面部定位"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E9%9D%A2%E9%83%A8%E5%AE%9A%E4%BD%8D/source" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js使用预训练模型&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js实战之训练模型</title>
    <link href="/2025/06/04/Tensorflow-js%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <id>/2025/06/04/Tensorflow-js实战之训练模型/</id>
    <published>2025-06-04T06:27:48.000Z</published>
    <updated>2025-06-05T01:34:13.752Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js自己训练模型<br><a id="more"></a><br>这里列举了一些从头开始利用Tensorflow.js框架训练模型的例子。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/线性回归.gif" alt="线性回归"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="线性回归归一化"><a href="#线性回归归一化" class="headerlink" title="线性回归归一化"></a>线性回归归一化</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/线性回归归一化.gif" alt="线性回归归一化"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%BD%92%E4%B8%80%E5%8C%96/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/逻辑回归.gif" alt="逻辑回归"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="多层神经网络XOR"><a href="#多层神经网络XOR" class="headerlink" title="多层神经网络XOR"></a>多层神经网络XOR</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/多层神经网络XOR.gif" alt="多层神经网络XOR"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CXOR/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/多分类.gif" alt="多分类"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%88%86%E7%B1%BB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/手写数字识别.gif" alt="手写数字识别"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="迁移学习-图像分类"><a href="#迁移学习-图像分类" class="headerlink" title="迁移学习-图像分类"></a>迁移学习-图像分类</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/迁移学习-图像分类.gif" alt="迁移学习-图像分类"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="迁移学习-语音识别"><a href="#迁移学习-语音识别" class="headerlink" title="迁移学习-语音识别"></a>迁移学习-语音识别</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/迁移学习-语音识别.gif" alt="迁移学习-语音识别"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js自己训练模型&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js入门</title>
    <link href="/2025/06/04/Tensorflow-js%E5%85%A5%E9%97%A8/"/>
    <id>/2025/06/04/Tensorflow-js入门/</id>
    <published>2025-06-04T06:25:15.000Z</published>
    <updated>2025-06-04T06:50:06.357Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js简单入门教程<br><a id="more"></a></p><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><h3 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h3><ul><li>机器学习是对能通过经验自动改进的计算机算法的研究。</li><li>机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。</li></ul><h3 id="机器学习如何运作？"><a href="#机器学习如何运作？" class="headerlink" title="机器学习如何运作？"></a>机器学习如何运作？</h3><ul><li>神经网络。</li><li>决策树，支持向量机，贝叶斯分类器，强化学习等。</li></ul><h3 id="什么是神经网络？"><a href="#什么是神经网络？" class="headerlink" title="什么是神经网络？"></a>什么是神经网络？</h3><ul><li>神经网络指的是人工神经网络</li><li>人工神经网络是一种运算模型（就是输入输出的映射），由大量的节点（或称神经元）之间相互联接构成。</li></ul><h3 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h3><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><ul><li>给大量输入和输出，算出神经网络里所有神经元的权重，偏置，然后给定新的输入，可以算出新的输出。</li><li>在机器学习里输入输出被称为特征和标签，大量输入输出被称为训练集。</li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul><li>初始化：随机生成一些权重和偏置。</li><li>计算损失：给定特征，计算出标签，得到它与真实标签差得多远。</li><li>优化：微调权重和偏置，使损失变小。</li></ul><h4 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h4><ul><li>使用损失函数</li><li>损失函数有均方误差，对数损失，交叉熵等。</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>使用优化器</li><li>优化器有随机梯度下降（SGD），Adam等。</li></ul><h2 id="Tensorflow-js基础"><a href="#Tensorflow-js基础" class="headerlink" title="Tensorflow.js基础"></a>Tensorflow.js基础</h2><h3 id="Tensorflow-js是什么？"><a href="#Tensorflow-js是什么？" class="headerlink" title="Tensorflow.js是什么？"></a>Tensorflow.js是什么？</h3><ul><li>一个用javascript实现的机器学习库。</li><li>可以直接在浏览器和Node.js中使用机器学习技术。</li></ul><h3 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h3><ul><li>运行现有模型。</li><li>重新训练现有模型。</li><li>使用javascript从0开发机器学习模型。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="在浏览器中安装"><a href="#在浏览器中安装" class="headerlink" title="在浏览器中安装"></a>在浏览器中安装</h4><p>使用script标签引入TensorFlow.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;!-- Load TensorFlow.js --&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Place your code in the script tag below. You can also use an external .js file --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // Notice there is no &apos;import&apos; statement. &apos;tf&apos; is available on the index-page</span><br><span class="line">      // because of the script tag above.</span><br><span class="line"></span><br><span class="line">      // Define a model for linear regression.</span><br><span class="line">      const model = tf.sequential();</span><br><span class="line">      model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));</span><br><span class="line"></span><br><span class="line">      // Prepare the model for training: Specify the loss and the optimizer.</span><br><span class="line">      model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);</span><br><span class="line"></span><br><span class="line">      // Generate some synthetic data for training.</span><br><span class="line">      const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);</span><br><span class="line">      const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);</span><br><span class="line"></span><br><span class="line">      // Train the model using the data.</span><br><span class="line">      model.fit(xs, ys).then(() =&gt; &#123;</span><br><span class="line">        // Use the model to do inference on a data point the model hasn&apos;t seen before:</span><br><span class="line">        // Open the browser devtools to see the output</span><br><span class="line">        model.predict(tf.tensor2d([5], [1, 1])).print();</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>使用NPM包安装，并使用Parcel，Webpack，vite等构建工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import * as tf from &apos;@tensorflow/tfjs&apos;;</span><br><span class="line"></span><br><span class="line">//定义一个线性回归模型。</span><br><span class="line">const model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));</span><br><span class="line"></span><br><span class="line">model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);</span><br><span class="line"></span><br><span class="line">// 为训练生成一些合成数据</span><br><span class="line">const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);</span><br><span class="line">const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);</span><br><span class="line"></span><br><span class="line">// 使用数据训练模型</span><br><span class="line">model.fit(xs, ys, &#123;epochs: 10&#125;).then(() =&gt; &#123;</span><br><span class="line">  // 在该模型从未看到过的数据点上使用模型进行推理</span><br><span class="line">  model.predict(tf.tensor2d([5], [1, 1])).print();</span><br><span class="line">  //  打开浏览器开发工具查看输出</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="在Node-js中安装"><a href="#在Node-js中安装" class="headerlink" title="在Node.js中安装"></a>在Node.js中安装</h4><p>安装带有原生C++绑定的TensorFlow.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs-node</span><br><span class="line">或</span><br><span class="line">npm install @tensorflow/tfjs-node-gpu</span><br></pre></td></tr></table></figure></p><ul><li>安装纯javascript版本，这个性能比较慢。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure></li></ul><h3 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量(Tensor)"></a>张量(Tensor)</h3><p>TensorFlow.js中数据的中心单位是张量：一组数值形成一个或多个维度的数组。 张量实例具有定义数组形状的形状属性。<br>Tensorflow.js中数据的主要表现形式就是tensor（张量）：由 一组数值形成一维或多维数组。一个Tensor实例有一个shape属性来定义这一组数值如何组成张量,而最主要的Tensor实例的构造函数就是 tf.tensor 函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 2x3 Tensor</span><br><span class="line">const shape = [2, 3]; // 2 行, 3 列</span><br><span class="line">const a = tf.tensor([1.0, 2.0, 3.0, 10.0, 20.0, 30.0], shape);</span><br><span class="line">a.print(); // 打印张量值</span><br><span class="line">// 输出:    [[1 , 2 , 3 ],</span><br><span class="line">//          [10, 20, 30]]</span><br><span class="line"></span><br><span class="line">// shape也可以用下面的方式实现:</span><br><span class="line">const b = tf.tensor([[1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]);</span><br><span class="line">b.print();</span><br><span class="line">// 输出:    [[1 , 2 , 3 ],</span><br><span class="line">//          [10, 20, 30]]</span><br></pre></td></tr></table></figure></p><p>但是，为了构造低秩张量，我们推荐使用下面的函数来增强代码的可读性：tf.scalar（零维）, tf.tensor1d（一维）, tf.tensor2d（二维）, tf.tensor3d（三维）、tf.tensor4d（四维）以及 tf.ones（值全是1）或者tf.zeros（值全是0） ，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const a = tf.scalar(3.14);</span><br><span class="line">a.print(); // 输出零维张量</span><br><span class="line"></span><br><span class="line">const b = tf.tensor2d([[2, 3, 4], [5, 6, 7]]);</span><br><span class="line">b.print(); // 输出二维张量</span><br><span class="line"></span><br><span class="line">const c = tf.zeros([2, 3]);</span><br><span class="line">c.print(); // 输出2行3列的值全是0的张量</span><br><span class="line"></span><br><span class="line">const d = tf.ones([3, 5]);</span><br><span class="line">d.print(); // 输出3行5列的值全是1的张量</span><br></pre></td></tr></table></figure></p><p>在TensorFlow.js中，张量是不变的; 一旦创建你就不能改变它们的值。 但是，您可以对它们执行操作来生成新的张量。</p><h3 id="变量-variables"><a href="#变量-variables" class="headerlink" title="变量(variables)"></a>变量(variables)</h3><p>Variables变量是通过张量进行初始化得到的。不像Tensor的值不可变，变量的值是可变的。你可以使用变量的assign方法分配一个新的tensor到这个变量上，这是变量就会改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const initialValues = tf.zeros([5]);</span><br><span class="line">const biases = tf.variable(initialValues); // 初始化biases</span><br><span class="line">biases.print(); // 输出: [0, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">const updatedValues = tf.tensor1d([0, 1, 0, 1, 0]);</span><br><span class="line">biases.assign(updatedValues); // 更新 biases的值</span><br><span class="line">biases.print(); // 输出: [0, 1, 0, 1, 0]</span><br></pre></td></tr></table></figure></p><p>如上所示，首先使用tf.zeros得到一个张量，然后利用这个张量初始化得到一个变量，接着我们就可以打印这个变量，并且通Object.prototype.toString.call(biases)方法可以判断变量也是一个对象，接着，我们再生成一个张量，然后变量调用assign方法传入这个张量，就可以得到一个新的变量了，如下：<br><img src="/2025/06/04/Tensorflow-js入门/1.png" alt="img"><br>由此我们可以得出一个结论：变量由张量生成，且张量不可变而变量可变。<br>以上就是Tensorflow.js 张量和变量的相关介绍，希望对大家有所帮助。</p><h3 id="操作-operations"><a href="#操作-operations" class="headerlink" title="操作(operations)"></a>操作(operations)</h3><p>ensors 可以用保存数据，而 operations 可以操作数据。TensorFlow.js 提供了多种适用于张量的线性代数和机器学习的运算的 operations。由于张量是不可改变的，所以 operations 操作并不会改变 tensors 的值，而是返回新的张量。</p><h4 id="operations-提供了类似-square-等一元运算"><a href="#operations-提供了类似-square-等一元运算" class="headerlink" title="operations 提供了类似 square 等一元运算"></a>operations 提供了类似 square 等一元运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);</span><br><span class="line">x.square().print();  // or tf.square(x)</span><br><span class="line">// [1, 4, 1.9999999, 1]</span><br><span class="line"></span><br><span class="line">const x = tf.tensor1d([1, 2, 4, -1]);</span><br><span class="line">x.sqrt().print();  // or tf.sqrt(x)</span><br><span class="line">// [1, 1.4142135, 2, NaN]</span><br></pre></td></tr></table></figure><h4 id="operations-提供了类似-add、sub-等二元运算"><a href="#operations-提供了类似-add、sub-等二元运算" class="headerlink" title="operations 提供了类似 add、sub 等二元运算"></a>operations 提供了类似 add、sub 等二元运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = tf.tensor1d([1, 2, 3, 4]);</span><br><span class="line">const b = tf.tensor1d([10, 20, 30, 40]);</span><br><span class="line"></span><br><span class="line">a.add(b).print();  // or tf.add(a, b)</span><br><span class="line">// [11, 22, 33, 44]</span><br></pre></td></tr></table></figure><h4 id="支持链式操作"><a href="#支持链式操作" class="headerlink" title="支持链式操作"></a>支持链式操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const e = tf.tensor2d([[1.0, 2.0], [3.0, 4.0]]);</span><br><span class="line">const f = tf.tensor2d([[5.0, 6.0], [7.0, 8.0]])</span><br><span class="line">const sq_sum = e.add(f).square();</span><br><span class="line">sq_sum.print();</span><br><span class="line">// Output: [[36 , 64 ],</span><br><span class="line">//          [100, 144]]</span><br><span class="line"></span><br><span class="line">// 所有的操作都暴露在函数的命名空间中，也可以进行下面操作，得到相同的结果</span><br><span class="line">const sq_sum = tf.square(tf.add(e, f));</span><br></pre></td></tr></table></figure><h3 id="模型-model"><a href="#模型-model" class="headerlink" title="模型(model)"></a>模型(model)</h3><p>机器学习中，一个 model 是一个带有可训练参数的函数。这个函数将输入转化为输出。通俗的来说，这个函数表达了输入和输出之间的变换关系。我们通过在数据集上训练模型来获得最佳参数。训练好的模型可以精确的将输入数据转换为我们想得到的输出。<br>TensorFlow.js 有两种创建机器学习的方法：<br>用 Layers API（用 layers 来创建模型）<br>用 Core API（底端算子，例如 tf.matMul() 或 tf.add() 等）来建立模型<br>我们首先会用高层API：Layers API来建立模型。然后，我们会展示如何用Core API来搭建相同的模型。</p><h4 id="用Layers-API创建模型"><a href="#用Layers-API创建模型" class="headerlink" title="用Layers API创建模型"></a>用Layers API创建模型</h4><p>Layers API有两种方式创建模型：第一种是创建 sequential 模型，第二种是创建 functional 模型。下面两段会分别解释这两种模型创建方式。</p><h5 id="使用sequential-model"><a href="#使用sequential-model" class="headerlink" title="使用sequential model"></a>使用sequential model</h5><p>最常见的模型是 Sequential 模型。Sequential 模型将网络的每一层简单的叠在一起。您可以将需要的层按顺序写在一个列表里，然后将列表作为 sequential() 函数的输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const model = tf.sequential(&#123;</span><br><span class="line"> layers: [</span><br><span class="line">   tf.layers.dense(&#123;inputShape: [784], units: 32, activation: &apos;relu&apos;&#125;),</span><br><span class="line">   tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;),</span><br><span class="line"> ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>或用 add() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123;inputShape: [784], units: 32, activation: &apos;relu&apos;&#125;));</span><br><span class="line">model.add(tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;));</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：模型的第一层需要“输入形状”参数（inputShape）。不要在“输入型状”中包含 batch size（批次大小）。假设您要向模型输入一个形状为[B, 784]的张量（B 是任意batch size），您只需要将“输入型状”设为[784]。</p></blockquote><p>您可以通过model.layers来使用模型中的每一层。例如，您可以用 model.inputLayers 和 model.outputLayers 来调用输入层和输出层。</p><h5 id="使用functional-model"><a href="#使用functional-model" class="headerlink" title="使用functional model"></a>使用functional model</h5><p>我们也可以通过 tf.model() 来创建 LayersModel。tf.model() 和 tf.sequential() 的主要区别为，您可以用 tf.model() 来创建任何非闭环的计算图。<br>以下是一段如何用 tf.model() API 建立和上文相同模型的列子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 用apply()方法创建任意计算图</span><br><span class="line">const input = tf.input(&#123;shape: [784]&#125;);</span><br><span class="line">const dense1 = tf.layers.dense(&#123;units: 32, activation: &apos;relu&apos;&#125;).apply(input);</span><br><span class="line">const dense2 = tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;).apply(dense1);</span><br><span class="line">const model = tf.model(&#123;inputs: input, outputs: dense2&#125;);</span><br></pre></td></tr></table></figure></p><p>我们在每一层用 apply() 将上一层的输出作为本层的输入。apply() 返回一个 SymbolicTensor（类似于张量，但不包含任何数值）<br>不同于 sequential model 使用 inputShape 来定义第一层的输入，我们用 tf.input() 创建的 SymbolicTensor 作为第一层的输入<br>如果您向 apply() 输入一个数值张量，它会进行计算并返还一个数值张量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const t = tf.tensor([-2, 1, 0, 5]);</span><br><span class="line">const o = tf.layers.activation(&#123;activation: &apos;relu&apos;&#125;).apply(t);</span><br><span class="line">o.print(); // [0, 1, 0, 5]</span><br></pre></td></tr></table></figure></p><p>这个方式适用于单独测试每一层并检查它们的输出。<br>和 sequential model 一样，您可以通过 model.layers 来使用模型中的每一层。例如，您可以用 model.inputLayers 和 model.outputLayers 来调用输入层和输出层。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>Sequential model和functional model都属于 LayersModel类。使用 LayersModels 让验证更方便：它要求您定义输入形状，并用您定义的形状来验证您对模型的输入。LayersModel 会自动计算模型中所有张量的形状。知道张量的形状后，模型就可以自动创建它所需要的参数。您也可以用形状信息来判断两层相邻的层是否相互兼容。</p><h4 id="模型总览"><a href="#模型总览" class="headerlink" title="模型总览"></a>模型总览</h4><p>使用 model.summary() 可以显示很多模型的重要信息，包括：</p><ul><li>每一层的名字和类型</li><li>每一层的输出形状</li><li>每一层的权重数量</li><li>每一层的输入</li><li>一个模型拥有的可训练参数总量，和不可训练参数总量</li></ul><p>用前面定义的模型来做例子，我们可以在命令行中得到以下信息：</p><table><thead><tr><th>Layer(type)</th><th>Output shape</th><th>Param #</th></tr></thead><tbody><tr><td>dense_Dense1 (Dense)</td><td>[null,32]</td><td>25120</td></tr><tr><td>dense_Dense2 (Dense)</td><td>[null,10]</td><td>330</td></tr><tr><td>Total params: 25450 Trainable params: 25450 Non-trainable params: 0</td><td></td><td></td></tr></tbody></table><p>注意：每一层的输出形状中都含有 null 值。模型的输入形状包含了批次大小，而批次大小是可以灵活更变的，所以批次的值在张量形状中以 null 显示。</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>相对于底端API而言，使用 LayersModel的另一个好处是方便存储、加载模型。LayersModel 包含如下信息：</p><ul><li>可用于重建模型的模型架构信息</li><li>模型的权重</li><li>训练配置（例如损失函数，优化器和评估方式）</li><li>优化器的状态（可用于继续训练模型）</li></ul><p>存储和加载模型只需要一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const saveResult = await model.save(&apos;localstorage://my-model-1&apos;);</span><br><span class="line">const model = await tf.loadLayersModel(&apos;localstorage://my-model-1&apos;);</span><br></pre></td></tr></table></figure></p><p>在这个例子中，模型被存储在浏览器的本地存储里。请访问 model.save() 和 save and load 了解如何把模型保存在不同的媒介中（例如 file storage, IndexedDB, 触发下载到浏览器等等）。</p><h4 id="自定义层"><a href="#自定义层" class="headerlink" title="自定义层"></a>自定义层</h4><p>层是创建模型的基础。如果您的模型需要定制化计算模块，您可以写一个自定义层并插入模型中。下面的例子是一个计算平方和的自定义层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SquaredSumLayer extends tf.layers.Layer &#123;</span><br><span class="line"> constructor() &#123;</span><br><span class="line">   super(&#123;&#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> // In this case, the output is a scalar.</span><br><span class="line"> computeOutputShape(inputShape) &#123; return []; &#125;</span><br><span class="line"></span><br><span class="line"> // call() is where we do the computation.</span><br><span class="line"> call(input, kwargs) &#123; return input.square().sum();&#125;</span><br><span class="line"></span><br><span class="line"> // Every layer needs a unique name.</span><br><span class="line"> getClassName() &#123; return &apos;SquaredSum&apos;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用 apply() 方法在一个张量上测试这个自定义层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const t = tf.tensor([-2, 1, 0, 5]);</span><br><span class="line">const o = new SquaredSumLayer().apply(t);</span><br><span class="line">o.print(); // prints 30</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：如果您在模型中包含了自定义层，模型将不能序列化</p></blockquote><h4 id="用Core-API创建模型"><a href="#用Core-API创建模型" class="headerlink" title="用Core API创建模型"></a>用Core API创建模型</h4><p>本文开头提到了两种在 TensorFlow.js 中建立模型的方法。最常用的方式是使用 Layers API，因为它的模式是基于广泛应用的 Keras API（详情见 best practices and reduces cognitive load）。Layers API 提供了大量方便的工具，例如权重初始化，模型序列化，训练监测，可迁移性和安全检查。<br>当您遇到如下情况时，可能会需要使用 Core API：</p><ul><li>您需要更多灵活性和控制</li><li>您不需要序列化或可以创造自己的序列化方法</li></ul><p>用 Core API 写的模型包含了一系列的函数。这些函数以一个或多个张量作为输入，并输出另一个张量。我们可以用 Core API 来重写之前定义的模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The weights and biases for the two dense layers.</span><br><span class="line">const w1 = tf.variable(tf.randomNormal([784, 32]));</span><br><span class="line">const b1 = tf.variable(tf.randomNormal([32]));</span><br><span class="line">const w2 = tf.variable(tf.randomNormal([32, 10]));</span><br><span class="line">const b2 = tf.variable(tf.randomNormal([10]));</span><br><span class="line"></span><br><span class="line">function model(x) &#123;</span><br><span class="line">  return x.matMul(w1).add(b1).relu().matMul(w2).add(b2).softmax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Core API 中，我们需要自己创建和初始化权重。每个权重都是一个 Variable，TensorFlow.js 会把 Variable 权重设为可训练张量。您可以用 tf.variable() 创建 Variable 或把一个已存在的张量放到 Variable 中。</p><h3 id="内存管理-dispose-amp-tidy"><a href="#内存管理-dispose-amp-tidy" class="headerlink" title="内存管理(dispose&amp;tidy)"></a>内存管理(dispose&amp;tidy)</h3><p>因为TensorFlow.js使用了GPU来加速数学运算，因此当tensorflow处理张量和变量时就有必要来管理GPU内存。在TensorFlow.js中，我们可以通过dispose 和 tf.tidy这两种方法来管理内存。</p><h4 id="dispose"><a href="#dispose" class="headerlink" title="dispose"></a>dispose</h4><p>您可以在张量或变量上调用dispose来清除它并释放其GPU内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const x = tf.tensor2d([[0.0, 2.0], [4.0, 6.0]]);</span><br><span class="line">const x_squared = x.square();</span><br><span class="line"></span><br><span class="line">x.dispose();</span><br><span class="line">x_squared.dispose();</span><br></pre></td></tr></table></figure></p><h4 id="tf-tidy"><a href="#tf-tidy" class="headerlink" title="tf.tidy"></a>tf.tidy</h4><p>进行大量的张量操作时使用dispose可能会很麻烦。 TensorFlow.js提供了另一个函数tf.tidy，它对JavaScript中的常规范围起到类似的作用，不同的是它针对GPU支持的张量。<br>tf.tidy执行一个函数并清除所有创建的中间张量，释放它们的GPU内存。 它不清除内部函数的返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const average = tf.tidy(() =&gt; &#123;</span><br><span class="line">  const y = tf.tensor1d([1.0, 2.0, 3.0, 4.0]);</span><br><span class="line">  const z = tf.ones([4]);</span><br><span class="line"></span><br><span class="line">  return y.sub(z).square().mean();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">average.print()</span><br></pre></td></tr></table></figure></p><p>使用tf.tidy将有助于防止应用程序中的内存泄漏。它也可以用来更谨慎地控制内存何时回收。</p><h4 id="两个重要的注意事项"><a href="#两个重要的注意事项" class="headerlink" title="两个重要的注意事项"></a>两个重要的注意事项</h4><p>传递给tf.tidy的函数应该是同步的，并且不会返回Promise。我们建议在tf.tidy内不要有更新UI或在发出远程请求的代码。<br>tf.tidy不会清理变量。变量通常持续到机器学习模型的整个生命周期，因此TensorFlow.js不会清理它们，即使它们是在tidy中创建的。不过，您可以手动调用dispose处理它们。</p><h2 id="Tensorflow-js实战例子"><a href="#Tensorflow-js实战例子" class="headerlink" title="Tensorflow.js实战例子"></a>Tensorflow.js实战例子</h2><p>TensorFlow.js的工作依然是围绕神经网络展开的，基本的工作过程包含了如下几个典型步骤：<br><img src="/2025/06/04/Tensorflow-js入门/2.png" alt="img"><br>下面将通过TensorFlow.js官方网站提供的数据拟合的示例来了解整个流程。</p><h3 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h3><p>Define 阶段是使用TensorFlow.js的第一步，这个阶段中需要初始化神经网络模型，你可以在TensorFlow的tf.layers对象上找到具备各种功能和特征的隐藏层，通过模型实例的add方法将其逐层添加到神经网络中，从而实现张量变形处理、卷积神经网络、循环神经网络等复杂模型，当内置模型无法满足需求时，还可以自定义模型层，TensorFlow的高阶API可以帮助开发者以声明式的编码来完成神经网络的结构搭建，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*创建模型*/</span><br><span class="line">function createModel() &#123;</span><br><span class="line">   const model = tf.sequential(); </span><br><span class="line">   model.add(tf.layers.dense(&#123;inputShape: [1], units: 1, useBias: true&#125;));</span><br><span class="line">   model.add(tf.layers.dense(&#123;units: 1, useBias: true&#125;));</span><br><span class="line">   return model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile阶段需要对训练过程进行一些参数预设，你可以先温习一下上一章中介绍过的BP神经网络的工作过程，然后再来理解下面的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.compile(&#123;</span><br><span class="line">   optimizer: tf.train.adam(),</span><br><span class="line">   loss: tf.losses.meanSquaredError,</span><br><span class="line">   metrics: [&apos;mse&apos;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>loss（损失）用于定义损失函数，它是神经网络的实际输出和期望输出之间偏差的量化评估标准，最常用的损失函数就是均方差损失（tf.losses.meanSquaredError），其他损失函数可以在TensorFlow的API文档中进行查看；optimizer(优化器)是指误差反向传播结束后，神经网络进行权重调整时所使用的的算法。权重调整的目的就是为了使损失函数达到极小值，所以通常采用“梯度下降”的思想来进行逼近，梯度方向是指函数在某一点变化最显著的方向，但实际的情况往往并没有这么简单，假设下图是一个神经网络的损失函数曲线：<br><img src="/2025/06/04/Tensorflow-js入门/3.png" alt="img"><br>可以看到损失函数的形态、初始参数的位置以及优化过程的步长等都可能对训练过程和训练结果产生影响，这就需要在optimizer配置项中指定优化算法来达到较好的训练效果；metrics配置项用于指定模型的度量指标，大多数情况下可以直接使用损失函数来作为度量标准。</p><h3 id="Fit"><a href="#Fit" class="headerlink" title="Fit"></a>Fit</h3><p>Fit 阶段执行的是模型训练的工作（fit本身是拟合的意思），通过调用模型的fit方法就可以启动训练循环，官方示例代码如下(fit方法接收的参数分别为输入张量集、输出张量集和配置参数)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const batchSize = 32;</span><br><span class="line">const epochs = 50;</span><br><span class="line"></span><br><span class="line">await model.fit(inputs, labels, &#123;</span><br><span class="line">   batchSize,</span><br><span class="line">   epochs,</span><br><span class="line">   shuffle: true,</span><br><span class="line">   callbacks: tfvis.show.fitCallbacks(</span><br><span class="line">      &#123; name: &apos;Training Performance&apos; &#125;,</span><br><span class="line">      [&apos;loss&apos;, &apos;mse&apos;], </span><br><span class="line">      &#123; height: 200, callbacks: [&apos;onEpochEnd&apos;] &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>相关参数说明如下（其他参数可参考官方开发文档）：</p><ul><li>batchSize（批大小）指每个循环中使用的样本数，通常取值为32~512</li><li>epochs指定整个训练集上的数据的总循环次数</li><li>shuffle指是否在每个epochs中打乱训练样本的次序</li><li>callbacks指定了训练过程中的回调函数</li></ul><p>神经网络的训练是循环进行的，假设总训练样本大小为320个，那么上面的示例代码所描述的训练过程是：先使用下标为0^31的样本来训练神经网络，然后使用optimizer来更新一次权重，再使用下标为32^63的样本进行训练，再更新权重，直到总样本中所有数据均被使用过一次，上述过程被称为一个epoch，接着打乱整个训练样本的次序，再重复共计50轮，callbacks回调函数参数直接关联了tfvis库，它是TensorFlow提供的专用可视化工具模块。</p><h3 id="Evaluate"><a href="#Evaluate" class="headerlink" title="Evaluate"></a>Evaluate</h3><p>Evaluate阶段需要对模型的训练结果进行评估，调用模型实例的evaluate方法就可以使用测试数据来获得损失函数和度量标准的数值。你可能已经注意到TensorFlow在定制训练过程时更加关注如何使用样本数据，而并没有将“度量指标小于给定阈值”作为训练终止的条件（例如brain.js中就可以通过设置errorthresh参数），在复杂神经网络的构建和设计中，开发者很可能需要一边构建一边进行非正式的训练测试，度量指标最终并不一定能够降低到给定的阈值以下，以此作为训练终止条件很可能会使训练过程陷入无限循环，所以使用固定的训练次数配合可视化工具来观察训练过程就更为合理。</p><h3 id="Predict"><a href="#Predict" class="headerlink" title="Predict"></a>Predict</h3><p>Predict阶段是使用神经网络模型进行预测的阶段，这也是前端工程师参与度最高的部分，毕竟模型输出的结果只是数据，如何利用这些预测结果来制作一些更有趣或者更加智能化的应用或许才是前端工程师更应该关注的问题。从前文的过程中不难看出，TensorFlow.js提供的能力是围绕神经网络模型展开的，应用层很难直接使用，开发者通常都需要借助官方模型仓库中提供的预训练模型或者使用其他基于TensorFlow.js构建的第三方应用，例如人脸识别框架face-api.js（它可以在浏览器端和Node.js中实现快速的人脸追踪和身份识别），语义化更加明确的机器学习框架ml5.js（可以直接调用API来实现图像分类、姿势估计、人物抠图、风格迁移、物体识别等更加具体的任务），可以实现手部跟踪的handtrack.js等等，如果TensorFlow的相关知识让你觉得过于晦涩，也可以先尝试使用这些更高层的框架来构建一些有趣的程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是对Tensorflow.js的简单介绍，下边列出几个常用的链接，对学习Tensorflow.js有更加详细的了解<br><a href="https://tensorflow.google.cn/js?hl=zh-cn" target="_blank" rel="noopener">TensorFlow.js中文官网</a><br><a href="https://www.w3cschool.cn/tensorflowjs/" target="_blank" rel="noopener">w3cschool</a><br><a href="https://www.kaggle.com/models" target="_blank" rel="noopener">TensorFlow.js模型下载</a><br><a href="https://modelscope.cn/datasets" target="_blank" rel="noopener">训练数据集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js简单入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust 锈化前端工具链</title>
    <link href="/2025/06/03/%E4%BD%BF%E7%94%A8-Rust-%E9%94%88%E5%8C%96%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>/2025/06/03/使用-Rust-锈化前端工具链/</id>
    <published>2025-06-03T06:12:23.000Z</published>
    <updated>2025-06-03T06:54:08.055Z</updated>
    
    <content type="html"><![CDATA[<p>使用Rust构建前端工具链<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来，Rust的受欢迎程度不断上升。首先，在操作系统领域，Rust 已成为 Linux 内核官方认可的开发语言之一，Windows 也宣布将使用 Rust 来重写内核，并重写部分驱动程序。此外，国内手机厂商 Vivo 也宣布使用 Rust 开发了名为“蓝河”的操作系统。除此之外，Rust 在图形渲染、游戏开发、中间件开发、边缘计算、计算安全等领域也是遍地开花，可以说，Rust 正在以惊人的速度重塑着各个领域的发展，让人不禁感叹 Rust 已经在重写万物了。</p><p>那回到前端领域，正在进行一场构建工具的革命，除了老牌的 Babel 竞争对手<a href="https://swc.rs/" target="_blank" rel="noopener">swc</a>，一些新兴的前端构建工具也都在使用 Rust 进行开发，例如<a href="https://turbo.build/pack" target="_blank" rel="noopener">Turbopack</a>、<a href="https://parceljs.org/" target="_blank" rel="noopener">Parcel</a>，对标 Webpack 的<a href="https://www.rspack.dev/" target="_blank" rel="noopener">Rspack</a>，对标 Vite 的<a href="https://farm-fe.github.io/" target="_blank" rel="noopener">Farm</a>等等。所以，对于广大前端同胞来说，C/C++ 太难，学习和掌握 Rust 是一个不错的选择，虽然 Rust 也不见得容易许多，它有着陡峭的学习曲线，但它或许是我们突破闭塞的前端区间的一把钥匙，帮助我们打开通往新世界的大门。</p><h2 id="锈化开发工具的方式"><a href="#锈化开发工具的方式" class="headerlink" title="锈化开发工具的方式"></a>锈化开发工具的方式</h2><p>虽说 Rust 的学习曲线可能相对陡峭，但笔者认为这是对于要全面掌握 Rust 这门语言而言的，而我们学习语言的目的最重要的是掌握一项可以帮我们解决问题的技能，因此，对于 Rust 不需要抱有太多的恐惧和敬畏之心，只需要摒除杂念立马开始学习 + 撸码，剩下的就交给时间来慢慢积累经验。此外，对于不是那么复杂应用来说，熟悉 Rust 基本语法和数据结构，翻过「所有权机制」和「生命周期」两座大山，基本也足以应付了。</p><p>本文建立在读者已经有一定的 Rust 知识基础上，对于 Rust 基本语法就不做赘述了。当前，大部分前端研发都是在 Node 环境下进行的，所以我们通过 Rust 来改造开发工具，主要有两种形式：</p><ul><li><p>使用 WASM 的方式，基于<a href="https://rustwasm.github.io/wasm-pack/" target="_blank" rel="noopener">wasm-pack</a>，将 Rust 代码编译成 WASM，以供 Node 调用</p></li><li><p>将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于napi-rs和neon来实现</p></li></ul><p>在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么此时就应该选择 Node addons 的方式了。而<a href="https://napi.rs/" target="_blank" rel="noopener">napi-rs</a>和<a href="https://neon-bindings.com/" target="_blank" rel="noopener">neon</a>的选择的话，napi-rs相对而言比较简单和轻量，而且针对不同版本的 Node 不需要重新编译，所以我们考虑选择napi-rs作为锈化开发工具的方式。</p><h2 id="初识-NAPI-RS"><a href="#初识-NAPI-RS" class="headerlink" title="初识 NAPI-RS"></a>初识 NAPI-RS</h2><p>我们可以通过 napi-rs 的开发工具 <strong>@napi-rs/cli</strong>以及<a href="https://github.com/napi-rs/package-template" target="_blank" rel="noopener">项目模板</a>来初始化一个应用，这里推荐使用项目模板，因为经过笔者的测试，开发工具创建的项目内容上相较于模板比较落后，对于后续深入使用上会造成一定的困惑。</p><p>从 napi-rs 项目模板内容上看，可以发现项目结构完善，工程化相关能力非常齐全，提供了构建工具、测试用例编写、Github CI 工作流等等必须的能力，我们只需要关注编码就可以了。</p><p>我们先来关注一下生成的 napi-rs 项目文件。从package.json和npm分析可以看出，一个 napi-rs 项目主要是由主包和 npm 下的针对不同平台的编译构建结果子包组成，napi-rs 会根据用户的配置，将用户的 Rust 代码构建为不同平台下的 Node 扩展 binding 文件，这些文件会放到 npm 下对应的平台目录中，再由 package.json 中 main 字段指定导出，用户在安装主包的时候，会根据用户电脑情况加载对应构建结果子包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@tarojs/parse-css-to-stylesheet-darwin-x64&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.25&quot;,</span><br><span class="line">  &quot;os&quot;: [</span><br><span class="line">    &quot;darwin&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;cpu&quot;: [</span><br><span class="line">    &quot;x64&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;main&quot;: &quot;parse-css-to-stylesheet.darwin-x64.node&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;parse-css-to-stylesheet.darwin-x64.node&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &quot;https://github.com/NervJS/parse-css-to-stylesheet&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在主包入口index.js中将根据用户宿主平台，加载对应的扩展文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">switch (platform) &#123;</span><br><span class="line">  case &apos;win32&apos;:</span><br><span class="line">    switch (arch) &#123;</span><br><span class="line">      case &apos;x64&apos;:</span><br><span class="line">        localFileExisted = existsSync(</span><br><span class="line">          join(__dirname, &apos;parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">        )</span><br><span class="line">        try &#123;</span><br><span class="line">          if (localFileExisted) &#123;</span><br><span class="line">            nativeBinding = require(&apos;./parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            nativeBinding = require(&apos;@tarojs/parse-css-to-stylesheet-win32-x64-msvc&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          loadError = e</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    break</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>从@napi-rs/triples这个包中可以看到所有支持的平台列表，而对于常规性的 Node 应用来说，我们不需要构建这么多平台，一般来说构建x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台也足够了，这样也能减少 CI 的构建时间。</p><p>napi-rs 默认构建的平台是x86_64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu，在<a href="https://github.com/napi-rs/napi-rs/blob/main/cli/src/utils/target.ts#L25" target="_blank" rel="noopener">这里</a>可以看到，所以为了增加 MAC Book M 系列电脑的支持，我们需要增加aarch64-apple-darwin的配置，可以在 package.json 中napi字段中添加，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;napi&quot;: &#123;</span><br><span class="line">  &quot;binaryName&quot;: &quot;taro&quot;,</span><br><span class="line">  &quot;triples&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: true,</span><br><span class="line">    &quot;additional&quot;: [</span><br><span class="line">      &quot;aarch64-apple-darwin&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>接下来就可以开始我们的编码之旅咯！</p><h2 id="基于-NAPI-RS-开发-Node-扩展"><a href="#基于-NAPI-RS-开发-Node-扩展" class="headerlink" title="基于 NAPI-RS 开发 Node 扩展"></a>基于 NAPI-RS 开发 Node 扩展</h2><p>基于 napi-rs 开发 Node 扩展，除了 Rust 编码本身外，无非需要关注两种情况，即 JavaScript 调用 Rust 和 Rust 调用 JavaScript。</p><h3 id="JavaScript-调用-Rust"><a href="#JavaScript-调用-Rust" class="headerlink" title="JavaScript 调用 Rust"></a>JavaScript 调用 Rust</h3><h4 id="调用-Rust-函数"><a href="#调用-Rust-函数" class="headerlink" title="调用 Rust 函数"></a>调用 Rust 函数</h4><p>这是最常见的用法，因为我们一般使用 Rust 开发 Node 扩展，也是为了将一些 CPU 密集型任务的任务使用 Rust 来实现，再暴露给 JS 来调用，从而达到提升应用性能的目的，最为常见的是 Rust 暴露方法给到 JS 调用，通过项目模板生成的 napi-rs 示例也可以看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/lib.rs </span><br><span class="line">use napi_derive::napi;</span><br><span class="line"></span><br><span class="line">#[napi]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码，通过给plus_100函数添加#[napi]属性宏，这样可以标记该函数，表示该函数可以通过 N-API 在 Node.js 中调用，在项目编译后的 typing 文件中，我们能看到对应生成了 JS 函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function plus100(input: number): number</span><br></pre></td></tr></table></figure></p><p>可以看到这里生成 JS 函数名是 napi-rs 自己的规则，我们也可以自定义暴露的函数名，通过js_name属性可以指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#[napi(js_name = &quot;plus_100&quot;)]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，除了暴露函数这一基本操作之外，我们还可以暴露常量、对象、类、enum 等等给到 JS 侧去调用，这些可以通过 napi-rs 的<a href="https://napi.rs/docs/concepts/values" target="_blank" rel="noopener">官方文档</a>可以查阅到。</p><h4 id="以-Object-作为参数"><a href="#以-Object-作为参数" class="headerlink" title="以 Object 作为参数"></a>以 Object 作为参数</h4><p>而在 JS 调用 Rust 编码中，最需要关注的是调用函数时，JS 侧给 Rust 传对象作为参数，这里为了提升性能，建议提前在 Rust 中定义好传递对象的数据结构，在 JS 中以引入该数据结构定义，规范数据传递即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 定义好数据结构</span><br><span class="line">// napi(object) 表示紧随其后的 struct （结构体）将通过 N-API 以 JavaScript 对象的形式暴露出去</span><br><span class="line">#[napi(object)]</span><br><span class="line">pub struct Project &#123;</span><br><span class="line">  pub project_root: String,</span><br><span class="line">  pub project_name: String,</span><br><span class="line">  pub npm: NpmType,</span><br><span class="line">  pub description: Option,</span><br><span class="line">  pub typescript: Option,</span><br><span class="line">  pub template: String,</span><br><span class="line">  pub css: CSSType,</span><br><span class="line">  pub auto_install: Option,</span><br><span class="line">  pub framework: FrameworkType,</span><br><span class="line">  pub template_root: String,</span><br><span class="line">  pub version: String,</span><br><span class="line">  pub date: Option,</span><br><span class="line">  pub compiler: Option,</span><br><span class="line">  pub period: PeriodType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JS 中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义，其中 Project 由 Rust binding 中暴露</span><br><span class="line">export function createProject(conf: Project)</span><br><span class="line"></span><br><span class="line">// 函数调用</span><br><span class="line">createProject(&#123;</span><br><span class="line">  projectRoot: projectDir,</span><br><span class="line">  projectName,</span><br><span class="line">  template,</span><br><span class="line">  npm,</span><br><span class="line">  framework,</span><br><span class="line">  css: this.conf.css || CSSType.None,</span><br><span class="line">  autoInstall: autoInstall,</span><br><span class="line">  templateRoot: getRootPath(),</span><br><span class="line">  version: getPkgVersion(),</span><br><span class="line">  typescript: this.conf.typescript,</span><br><span class="line">  date: this.conf.date,</span><br><span class="line">  description: this.conf.description,</span><br><span class="line">  compiler: this.conf.compiler,</span><br><span class="line">  period: PeriodType.CreateAPP,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Rust-调用-JavaScript"><a href="#Rust-调用-JavaScript" class="headerlink" title="Rust 调用 JavaScript"></a>Rust 调用 JavaScript</h3><p>而 Rust 中也可以调用 JS 提供的方法，这在做 Node 开发工具的时候非常有用，因为有时候我们需要读取开发人员的配置代码给到 Rust 调用，其中就可能会遇到 Rust 调用 JavaScript 中函数的情况。</p><h4 id="一个调用-JS-函数的简单例子"><a href="#一个调用-JS-函数的简单例子" class="headerlink" title="一个调用 JS 函数的简单例子"></a>一个调用 JS 函数的简单例子</h4><p>在 napi-rs 中调用 JS 函数主要通过ThreadsafeFunction来实现，请看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  for n in 0..100 &#123;</span><br><span class="line">    let tsfn = callback.clone();</span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述例子中，call_threadsafe_function函数接受了一个类型为ThreadsafeFunction<u32>的参数，这表明call_threadsafe_function被编译为 JS 函数后将接受一个回调函数作为参数，而该回调函数的有效参数为u32即number类型，而在call_threadsafe_function函数体中，通过thread::spawn开辟子线程，以阻塞的方式调用这个传入的回调函数。</u32></p><p>通过ThreadsafeFunction的call方法可以调用到传入的 JS 回调函数，但是我们会发现它拿不到返回值，如果我们需要获取到 JS 回调函数的返回值时，我们需要使用call_with_return_value和call_async两个方法。</p><h4 id="获取-JS-函数的返回值"><a href="#获取-JS-函数的返回值" class="headerlink" title="获取 JS 函数的返回值"></a>获取 JS 函数的返回值</h4><p>对比call与call_with_return_value的实现可以看出，call_with_return_value比call多一个回调函数参数，并且可以指定 JS 回调函数返回值的类型，并且该类型需要满足FromNapiValue这个 trait，因为call_with_return_value在处理 JS 回调函数时会调用它的from_napi_value方法将 JS 数据转为 Rust 的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/napi-rs/napi-rs/blob/main/crates/napi/src/threadsafe_function.rs#L428</span><br><span class="line">pub fn call(&amp;self, value: Result, mode: ThreadsafeFunctionCallMode) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::Direct,</span><br><span class="line">            callback: Box::new(|_d: Result| Ok(())),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn call_with_return_value Result&lt;()&gt;&gt;(</span><br><span class="line">  &amp;self,</span><br><span class="line">  value: Result,</span><br><span class="line">  mode: ThreadsafeFunctionCallMode,</span><br><span class="line">  cb: F,</span><br><span class="line">) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">            callback: Box::new(move |d: Result| &#123;</span><br><span class="line">              d.and_then(|d| D::from_napi_value(d.0.env, d.0.value).and_then(cb))</span><br><span class="line">            &#125;),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>call_with_return_value的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  callback.call_with_return_value(Ok(1), ThreadsafeFunctionCallMode::Blocking, move |result: u32| &#123;</span><br><span class="line">    println!(&quot;callback: &#123;result:?&#125;&quot;);</span><br><span class="line">    Ok(())</span><br><span class="line">  &#125;);</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，JS 回调函数的返回值是在call_with_return_value的第三个回调函数参数中获取到的，这就导致如果我们需要依赖这个 JS 函数返回值的话，我们后续的逻辑代码只能写在call_with_return_value的第三个回调函数参数中，对我们的代码逻辑书写造成诸多不便，代码可读性降低，所以推荐使用call_async方法来执行 JS 函数，并获取参数。</p><h4 id="使用call-async获取-JS-函数返回值"><a href="#使用call-async获取-JS-函数返回值" class="headerlink" title="使用call_async获取 JS 函数返回值"></a>使用call_async获取 JS 函数返回值</h4><p>从call_async的实现可以看出，它首先使用了tokio创建了一个 one-shot 通道，让 JS 函数以不阻塞的方式异步运行，并在执行完成后通过sender 发送操作结果，而使用receiver进行等待执行结果，并将结果返回，同时要使用call_async方法，需要在Cargo.toml中为napi依赖打开tokio_rt特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(feature = &quot;tokio_rt&quot;)]</span><br><span class="line">pub async fn call_async(&amp;self, value: Result) -&gt; Result &#123;</span><br><span class="line">  let (sender, receiver) = tokio::sync::oneshot::channel::&gt;();</span><br><span class="line"></span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Err(crate::Error::from_status(Status::Closing));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_status!(</span><br><span class="line">      unsafe &#123;</span><br><span class="line">        sys::napi_call_threadsafe_function(</span><br><span class="line">          self.handle.get_raw(),</span><br><span class="line">          Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">            ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">              data,</span><br><span class="line">              call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">              callback: Box::new(move |d: Result| &#123;</span><br><span class="line">                sender</span><br><span class="line">                  .send(d.and_then(|d| D::from_napi_value(d.0.env, d.0.value)))</span><br><span class="line">                  .map_err(|_| &#123;</span><br><span class="line">                    crate::Error::from_reason(&quot;Failed to send return value to tokio sender&quot;)</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)))</span><br><span class="line">          .cast(),</span><br><span class="line">          ThreadsafeFunctionCallMode::NonBlocking.into(),</span><br><span class="line">        )</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Threadsafe function call_async failed&quot;</span><br><span class="line">    )</span><br><span class="line">  &#125;)?;</span><br><span class="line">  receiver</span><br><span class="line">    .await</span><br><span class="line">    .map_err(|_| &#123;</span><br><span class="line">      crate::Error::new(</span><br><span class="line">        Status::GenericFailure,</span><br><span class="line">        &quot;Receive value from threadsafe function sender failed&quot;,</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">    .and_then(|ret| ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见call_async使用时将引入 Rust 的异步编程，我们可以使用async/await关键字来进行调用，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub async fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result &#123;</span><br><span class="line">  let result = match callback.call_async::(Ok(1)).await &#123;</span><br><span class="line">    Ok(res) =&gt; res,</span><br><span class="line">    Err(e) =&gt; &#123;</span><br><span class="line">      println!(&quot;Error: &#123;&#125;&quot;, e);</span><br><span class="line">      0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  println!(&quot;result: &#123;result:?&#125;&quot;);</span><br><span class="line">  Ok(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时生成的 JS 函数定义为如下，可以看出callThreadsafeFunction变成了一个异步函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function callThreadsafeFunction(callback: (err: Error | null, value: number) =&gt; any): Promise&lt;number&gt;</span><br></pre></td></tr></table></figure></p><p>所以在 JS 中调用方式及输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const result = await callThreadsafeFunction((err, value) =&gt; &#123;</span><br><span class="line">  return value + 1</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// result: 2</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p><h4 id="正确处理-JS-函数的返回值"><a href="#正确处理-JS-函数的返回值" class="headerlink" title="正确处理 JS 函数的返回值"></a>正确处理 JS 函数的返回值</h4><p>从前面call_async的实现可以看出，call_async返回的数据，也即 JS 函数返回值需要满足如下泛型约束D: ‘static + FromNapiValue，而 napi-rs 默认会为数值、字符串、布尔等基本 JS 数据类型实现FromNpiValuetrait，但是如果我们的 JS 回调想要返回一个对象时，则需要自己手动实现FromNpiValuetrait，这样可以让call_async获取到 JS 返回数据时自动调用FromNpiValuetrait 的from_napi_value方法将 JS 返回数据转换为 Rust 的数据格式，以下是一个简单的示例。</p><p>假如需要在 Rust 调用一个 JS 函数，JS 函数会返回一个对象，包含三个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  setPageName?: string,</span><br><span class="line">  changeExt?: boolean,</span><br><span class="line">  setSubPkgName?: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在 Rust 中获取到返回的对象，并转为 Rust 数据，那么首先我们可以定义一个类似的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">pub struct JSReturnObject &#123;</span><br><span class="line">  pub set_page_name: Option,</span><br><span class="line">  pub change_ext: Option,</span><br><span class="line">  pub set_sub_pkg_page_name: Option,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时为它实现FromNpiValuetrait 就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">impl FromNapiValue for JSReturnObject &#123;</span><br><span class="line">  unsafe fn from_napi_value(env: napi_env, napi_val: napi_value) -&gt; Result &#123;</span><br><span class="line">    let obj = JsObject::from_napi_value(env, napi_val)?;</span><br><span class="line">    let mut js_return_object = JSReturnObject &#123;</span><br><span class="line">      set_page_name: None,</span><br><span class="line">      change_ext: None,</span><br><span class="line">      set_sub_pkg_page_name: None,</span><br><span class="line">    &#125;;</span><br><span class="line">    let has_set_page_name = obj.has_named_property(&quot;setPageName&quot;)?;</span><br><span class="line">    let has_change_ext = obj.has_named_property(&quot;changeExt&quot;)?;</span><br><span class="line">    let has_set_sub_pkg_page_name = obj.has_named_property(&quot;setSubPkgName&quot;)?;</span><br><span class="line">    if has_set_page_name &#123;</span><br><span class="line">      js_return_object.set_page_name = Some(obj.get_named_property::(&quot;setPageName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_set_sub_pkg_page_name &#123;</span><br><span class="line">      js_return_object.set_sub_pkg_page_name = Some(obj.get_named_property::(&quot;setSubPkgName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_change_ext &#123;</span><br><span class="line">      js_return_object.change_ext = Some(obj.get_named_property::(&quot;changeExt&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(js_return_object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，先调用JsObject::from_napi_value方法将传入数据转为JsObject，然后调用</p><p>JsObject的has_named_property方法获取到对应的属性值，经过处理后可以构建出JSReturnObject结构体数据，并进行返回。而使用的时候，为call_async指定泛型参数类型为JSReturnObject，接下来就可以获取到 JS 返回值进行处理了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result: JSReturnObject = js_handler</span><br><span class="line">  .call_async(Ok(options.clone()))</span><br><span class="line">  .await</span><br><span class="line">  .with_context(|| format!(&quot;模板自定义函数调用失败: &#123;&#125;&quot;, file_relative_path))?;</span><br></pre></td></tr></table></figure></p><h2 id="使用-VSCode-进行调试"><a href="#使用-VSCode-进行调试" class="headerlink" title="使用 VSCode 进行调试"></a>使用 VSCode 进行调试</h2><p>我们可以使用 VSCode 来调试我们的 napi-rs 应用，我们可以参考Taro 项目，在项目的 .vscode 目录下新增 launch.json 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;lldb&quot;, // 调试器类型，这里指定为lldb，通常用于C/C++/Rust等语言</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;, // 请求类型，可以是&apos;launch&apos;或&apos;attach&apos;，&apos;launch&apos;表示启动一个新的调试会话</span><br><span class="line">      &quot;name&quot;: &quot;debug-init&quot;, // 配置名称，显示在VS Code的启动配置下拉菜单中</span><br><span class="line">      &quot;sourceLanguages&quot;: [&quot;rust&quot;], // 指定源码语言，此处为Rust</span><br><span class="line">      &quot;program&quot;: &quot;node&quot;, // 要调试的程序，这里是指Node.js的可执行文件</span><br><span class="line">      &quot;args&quot;: [</span><br><span class="line">        // 程序参数，这里指定了使用node运行taro-cli包的初始化命令，创建一个名为test_pro的新项目</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/packages/taro-cli/bin/taro&quot;,</span><br><span class="line">        &quot;init&quot;,</span><br><span class="line">        &quot;test_pro&quot;</span><br><span class="line">  ],</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 当前工作目录，这里指工作区根目录</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;build binding debug&quot;, // 调试前需要执行的任务的名称，这里指定了一个任务以在调试前构建项目</span><br><span class="line">      &quot;postDebugTask&quot;: &quot;remove test_pro&quot; // 调试后需要执行的任务的名称，此处指定了一个任务以在调试后清理或删除test_pro项目</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述配置中，指定调试器类型为lldb，启动一个新的调试会话来调试我们用 Rust 编写的程序，该程序主要通过 Node.js 来执行一个初始化新项目 test_pro 的命令，在调试开始前后会飞别执行 Rust binding 的构建以及 test_pro 项目的删除。</p><p>然后在要调试的代码处添加断点，然后执行调试即可。</p><h2 id="构建发布"><a href="#构建发布" class="headerlink" title="构建发布"></a>构建发布</h2><p>napi-rs 的项目模板默认基于 <a href="https://github.com/napi-rs/package-template/blob/main/.github/workflows/CI.yml" target="_blank" rel="noopener">Github Action</a> 来实现自动构建产物及发布，并且已经有相当完整的配置了，从Github Action配置文件中可以看到 CI 具体执行的任务，CI 任务首先会执行 package.json 中的构建命令，构建出各个端的 binding，并会actions/upload-artifact@v3action 将构建产物上传，然后会对构建产物执行相关测试，测试通过后会将构建产物下载下来，并执行artifacts命令将构建产物移动到目的文件夹下，最后会进行发布，当 git 提交信息为semver规范版本号时，将会触发 CI 发布，将包发到 NPM 中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;0.0.1&apos;</span><br></pre></td></tr></table></figure></p><p>前面提到我们一般只需要针对x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台进行构建，所以我们可以调整 Github Action 配置，去掉不需要构建的平台以提升 CI 速度。</p><p>此外，当我们有特殊需求的时候，例如不需要重新生成胶水 JS 代码、需要将构建产物移动到其他目录（默认是当前目录下的 npm 目录）下等等，可以查看<a href="https://github.com/napi-rs/napi-rs/tree/main/cli" target="_blank" rel="noopener">@napi-rs/cli</a>的文档进行相应调整。</p><p>不需要重新生成胶水 JS 代码，可以通过在napi build命令下添加–no-js实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;build&quot;: &quot;napi build --platform --release --no-js --dts binding.d.ts&quot;,</span><br><span class="line">  &quot;build:debug&quot;: &quot;napi build --platform --no-js --dts binding.d.ts&quot;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要将构建产物移动到其他目录，可以通过在napi artifacts命令下添加 –cwd 和 –npm-dir 参数来实现，前者指定工作目录，后者指定要移动的目录的相对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;artifacts&quot;: &quot;napi artifacts --npm-dir ../../npm2 --cwd ./&quot;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 在前端领域的应用无疑将成为未来的重要发展趋势，随着越来越多的公司和团队开始投入到这一领域，我们看到了 Rust 在前端研发生态构建中的独特优势和潜力，Rust 的高效性和安全性使其成为优化 Node 工具的理想选择。本文简单介绍了如何使用 NAPI-RS 来开发、调试和发布 Node 扩展，可以有效地优化我们的开发工具，并提升其性能。</p><p>在未来，我们可以预见 Rust 与前端结合的可能性将会更加广泛。随着 WebAssembly（WASM）的发展，我们可以期待 Rust 将在前端应用的性能优化、复杂应用的开发以及多线程等领域发挥更大的作用。同时，Rust 的出色的内存管理和错误处理机制也将帮助前端开发者构建更加健壮、安全的应用。</p><p>当然，Rust 与前端的结合并不仅仅限于性能优化，Rust 的优秀特性，如模式匹配、类型推断和零成本抽象，也为前端开发带来了新的编程范式和思维方式，这将有助于提升前端代码的可读性和可维护性，为前端开发提供了新的思考角度和工具，并可能引领前端开发进入一个全新的阶段。</p><p><a href="https://juejin.cn/post/7321410906426998810#heading-13" target="_blank" rel="noopener">来自</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Rust构建前端工具链&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="Rust" scheme="/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>solidity进阶</title>
    <link href="/2025/03/11/solidity%E8%BF%9B%E9%98%B6/"/>
    <id>/2025/03/11/solidity进阶/</id>
    <published>2025-03-11T01:56:30.000Z</published>
    <updated>2025-03-11T05:33:38.778Z</updated>
    
    <content type="html"><![CDATA[<p>solidity进阶-ERC20代币开发<br><a id="more"></a></p><h1 id="什么是ERC"><a href="#什么是ERC" class="headerlink" title="什么是ERC"></a>什么是ERC</h1><p>ERC 全称是“Ethereum Request for Comment”，表示以太坊的意见征求稿，ERC 中包含技术和组织等注意事项及标准。这套标准其实不光由以太坊官方提出，还由一些以太坊爱好者提出。是以太坊生态系统中被广泛使用的关键标准。</p><h2 id="代币-token-标准"><a href="#代币-token-标准" class="headerlink" title="代币(token)标准"></a>代币(token)标准</h2><ul><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/" target="_blank" rel="noopener">ERC-20</a> - 同质化（可互换）代币的标准接口，比如投票代币、质押代币或虚拟货币。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/" target="_blank" rel="noopener">ERC-721</a> - 非同质化代币的标准接口，比如艺术作品或歌曲的契约。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-777/" target="_blank" rel="noopener">ERC-777</a> - 关于 ERC-20 的代币标准改进。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/" target="_blank" rel="noopener">ERC-1155</a> - 一个能包括同质化和非同质化资产的代币标准。</li></ul><h2 id="ERC-20-代币"><a href="#ERC-20-代币" class="headerlink" title="ERC-20 代币"></a>ERC-20 代币</h2><p><code>千言万语汇成一句话：造钱</code></p><blockquote><p>什么叫做代币  代替货币 </p></blockquote><p>代币可以在以太坊中表示任何东西：</p><ul><li>在线平台中的信誉积分</li><li>游戏中一个角色的技能</li><li>彩票</li><li>金融资产类似于公司股份的资产</li><li>像美元一样的法定货币</li><li>一克黄金</li><li>以及更多</li></ul><blockquote><p>ERC-20以太坊代币标准是创建与更广泛的以太坊网络兼容的可替换代币的蓝图。以太坊，或称Ethereum，是一种加密货币，允许创建各种应用，包括代币，与大多数传统应用不同，它不需要中心化服务机构就可以运作。</p><p>简单来说，<strong>ERC-20</strong>就是一套<strong>基于以太坊网络的标准代币发行协议</strong>。有了ERC-20，<strong>开发者们得以高效、可靠、低成本地创造专属自己项目的代币；</strong>我们甚至可以将ERC-20视为以太坊网络为早期区块链世界做出的最重要贡献，也是以太坊网络第一个真正意义上的杀手级应用。</p></blockquote><p>如果我们把众多区块链项目的开发者，看作是在一个小区门口商铺里，经营不同业态的众多商户。这些商户根据自己的专长提供各自不同的商品和服务，也都希望发行自己店铺专属的消费储值卡。方便消费者光顾的同时，也能提升用户的体验和粘性</p><p>以太坊就像是运营这个小区底商的物业公司，它提供一整套标准化的储值卡发放协议和配套服务。借助这套叫做ERC-20的整体解决方案，每个商户（开发者）都可以傻瓜式地发行专属于自己店铺的消费储值卡，同时由于这种储值卡采用了统一的协议，可以非常方便地和其他商户的储值卡做无缝兑换。</p><p>于是借助ERC-20，用户可以通过持有其中一种储值卡（token）很方便地享受整个生态的各种服务；商户（开发者）则节约了开发运营成本、同时提升了获取用户的效率；而物业公司（以太坊基金会和矿工）则可以通过做大生态体量实现更多的租金（ETH增值）和储值卡结算手续费（Gas费用）收入。</p><p>ERC-20就是用这种做大生态价值的方式，实现了用户、开发者和以太坊网络三方面的共赢。</p><p><strong><em>ERC-20的应用案例</em></strong></p><p>为了让你对ERC-20有更具象化的认识，这里援引 <a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/author/alyssa.hertig" target="_blank" rel="noopener">Alyssa Hertig</a> 在 <a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">What is the ERC-20 Ethereum Token Standard?</a> 中列举的一些比较知名的基于ERC-20协议代币：</p><blockquote><p>Tether (USDT)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">Chainlink</a> (LINK)<br>Binance coin (BNB)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">USD coin</a> (USDC)<br>Wrapped bitcoin (WBTC)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">Dai</a> (DAI)</p></blockquote><p>需要特别指出的是，这上面提到的Tether发行的稳定币USDT除了基于ERC-20协议的版本之外，其实还有基于其他公链发行的多个版本，只不过ERC-20版的发行量最大，知名度也最高。</p><h1 id="openzeppelin-智能合约库"><a href="#openzeppelin-智能合约库" class="headerlink" title="openzeppelin 智能合约库"></a>openzeppelin 智能合约库</h1><p>官网：<a href="https://www.openzeppelin.com/" target="_blank" rel="noopener">https://www.openzeppelin.com/</a></p><p>GitHub：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts</a></p><p>OpenZeppelin 是一个使用以太坊智能合约语言 Solidity 进行构建的开发框架，可以简化智能合约和 Dapp 的开发。</p><p>OpenZeppelin合约和库已成为行业标准，其开源代码模板经历了以太坊及其他区块链的实战考验，帮助开发者最大限度降低风险。OpenZeppelin代码包括使用度最高的ERC标准及拓展部署，已被社区在各类指南以及操作教程中大量使用。</p><h2 id="Contract-Wizard"><a href="#Contract-Wizard" class="headerlink" title="Contract Wizard"></a>Contract Wizard</h2><p>OpenZeppelin开发了一种基于网络的线上智能合约交互式工具，它可能是使用OpenZeppelin代码编写智能合约最简单快捷的方式。这一工具称为<a href="https://docs.openzeppelin.com/contracts/4.x/wizard" target="_blank" rel="noopener">Contracts Wizard</a>。</p><h1 id="ERC-20-代币实现"><a href="#ERC-20-代币实现" class="headerlink" title="ERC-20 代币实现"></a>ERC-20 代币实现</h1><p><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top" target="_blank" rel="noopener">https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top</a></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</a></p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20" target="_blank" rel="noopener">https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol</a></p><p><a href="https://www.openzeppelin.com/contracts" target="_blank" rel="noopener">https://www.openzeppelin.com/contracts</a></p><p><a href="https://ethereum.org/zh/" target="_blank" rel="noopener">https://ethereum.org/zh/</a></p><p><a href="https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions" target="_blank" rel="noopener">https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions</a></p><p>ERC-20（以太坊意见征求 20）由 Fabian Vogelsteller 提出于 2015 年 11 月。这是一个能实现智能合约中代币的应用程序接口标准。</p><p>ERC-20 的功能示例包括：</p><ul><li>将代币从一个帐户转到另一个帐户</li><li>获取帐户的当前代币余额</li><li>获取网络上可用代币的总供应量</li><li>批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><p>如果智能合约实施了下列方法和事件，它可以被称为 ERC-20 代币合约， 一旦部署，将负责跟踪以太坊上创建的代币。</p><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function name() public view returns (string)</span><br><span class="line">function symbol() public view returns (string)</span><br><span class="line">function decimals() public view returns (uint8)</span><br><span class="line">function totalSupply() public view returns (uint256)</span><br><span class="line">function balanceOf(address _owner) public view returns (uint256 balance)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success)</span><br><span class="line">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span><br></pre></td></tr></table></figure><p>事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 _value)</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value)</span><br></pre></td></tr></table></figure><h2 id="代币1"><a href="#代币1" class="headerlink" title="代币1"></a>代币1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract QfCoin &#123;</span><br><span class="line">    event Transfer(address, address, uint256);</span><br><span class="line">    event Approval(address, address, uint256);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    // override 重载</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, string memory _symbol) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // transfer() 函数 IERC20 中的 transfer 函数， Token 实现。调用方 amount 币会增加 Token 数量，接收方此函数相应的狗改土，加入、分红、抽奖等。</span><br><span class="line">    //  转账函数</span><br><span class="line">    function transfer(address recipient, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // approve 函数</span><br><span class="line">    // approve() 函数：IERC20 的 approve 函数， Token 授权逻辑。被授权方 spender 可以控制授权方的 amount 数量的 Token 。</span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // transferFrom() 功能：IERC20 中的 transferFrom 函数，授权逻辑。被授权方将授权方实现 sender 的 amount 数量的 Token 授权给接收方 recipient。</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] == amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(uint256 amount) public &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代币2"><a href="#代币2" class="headerlink" title="代币2"></a>代币2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.9;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    /*</span><br><span class="line">    &#123;</span><br><span class="line">        addressA: 90,</span><br><span class="line">        addressB: 0,</span><br><span class="line">        addressC: 20,</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    event Transfer(address _from, address _to, uint256 _value);</span><br><span class="line">    event Approval(address _owner, address _spender, uint256 _value);</span><br><span class="line">    // 代币的名字与标识 数量</span><br><span class="line">    uint256 _totalSupply;</span><br><span class="line">    string _name;</span><br><span class="line">    string _symbol;</span><br><span class="line">    uint8 _decimals;</span><br><span class="line">    // 创建地址与余额的映射</span><br><span class="line">    mapping(address =&gt; uint256) _balanceOf;</span><br><span class="line">    // 创建授权额度的结构</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) _allowance;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    address1 : &#123;</span><br><span class="line">        address11:1000w</span><br><span class="line">        address22:200w</span><br><span class="line">    &#125; </span><br><span class="line">    address3:&#123;</span><br><span class="line">        address11:1000w</span><br><span class="line">        address22:200w</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        _name = &quot;HeHeCoin&quot;;</span><br><span class="line">        _symbol = &quot;HHC&quot;;</span><br><span class="line">        _decimals = 18;</span><br><span class="line">        _totalSupply = 100 * 10000 * 10**_decimals;</span><br><span class="line">        _balanceOf[msg.sender] += _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取一下代币的名字</span><br><span class="line">    function name() public view returns (string memory) &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function symbol() public view returns (string memory) &#123;</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decimals() public view returns (uint8) &#123;</span><br><span class="line">        return _decimals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据地址获取余额</span><br><span class="line">    function balanceOf(address _owner) public view returns (uint256) &#123;</span><br><span class="line">        return _balanceOf[_owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转账</span><br><span class="line">    function transfer(address _to, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        _balanceOf[msg.sender] -= _value;</span><br><span class="line">        _balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // token的逻辑授权 给被授权方一定的权限 可以直接转移授权方的同肯</span><br><span class="line">    function approve(address _spender, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        //  调用这个方法的人</span><br><span class="line">        _allowance[msg.sender][_spender] = _value;</span><br><span class="line">        emit Approval(msg.sender, _spender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看额度</span><br><span class="line">    function allowance(address _owner, address _spender)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return _allowance[_owner][_spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  被给与额度的账户主动的 划走代币</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) public returns (bool success) &#123;</span><br><span class="line">        // 额度减少</span><br><span class="line">        _allowance[_from][_to] -= _value;</span><br><span class="line">        // 被划走账户余额减少</span><br><span class="line">        _balanceOf[_from] -= _value;</span><br><span class="line">        // 划走账户的余额添加</span><br><span class="line">        _balanceOf[_to] += _value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</span><br><span class="line">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span><br><span class="line">0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  : &#123;</span><br><span class="line">       0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2: 100w,</span><br><span class="line">       0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db: 50w,</span><br><span class="line">   &#125;</span><br><span class="line">   0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB : &#123;</span><br><span class="line">       0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2:666,</span><br><span class="line">       0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db:777,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  100w </span><br><span class="line">授权   0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2  666</span><br><span class="line">授权   0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db  777</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="ERC-20代币部署"><a href="#ERC-20代币部署" class="headerlink" title="ERC-20代币部署"></a>ERC-20代币部署</h1><ol><li>将环境切换切MetaMask钱包环境并选择钱包账户</li></ol><p><img src="/2025/03/11/solidity进阶/1.png" alt="image-20221212212504003"></p><ol start="2"><li>点击Deploy ，输入代币的名字和表示 部署合约</li></ol><p><img src="/2025/03/11/solidity进阶/2.png" alt="image-20221212212645585"></p><p>部署成功结果</p><p><img src="/2025/03/11/solidity进阶/3.png" alt="image-20221212213033774"></p><p>合约地址 0x639DfECe957A8D705f028D1950890598C30789ed</p><p>交易hash 0x28aa84834efc9c787c4cd584128f456e16b933eddf250859833b395656153847</p><p>在metaMask 添加代币</p><p><img src="/2025/03/11/solidity进阶/4.png" alt="image-20221212214003856"></p><p><img src="/2025/03/11/solidity进阶/5.png" alt="image-20221212214043557"></p><p>智能合约初始化的时候没有规定代币的数量，所以添加结果为0MTC</p><p><img src="/2025/03/11/solidity进阶/6.png" alt="image-20221212214148279"></p><p>后续通过mint 铸造方法，添加货币</p><p><img src="/2025/03/11/solidity进阶/7.png" alt="image-20221212214355382"></p><p>接下来就可以在测试网络中进行代币转账了</p><h1 id="Web3-js-和-ether-js-介绍"><a href="#Web3-js-和-ether-js-介绍" class="headerlink" title="Web3.js 和 ether.js 介绍"></a>Web3.js 和 ether.js 介绍</h1><p>Web3.js 和 ethers.js 都是 JavaScript 库，其作用是使开发者可以与以太坊区块链交互。这两个库都很实用，都能满足大多数以太坊开发者的需求。下面将重点围绕 Web3.js 和 Ethers.js 的相同点和不同点来对它们进行比较，以便你能更好地理解它们的细微区别。</p><p> 什么是 web3.js？ </p><p><img src="/2025/03/11/solidity进阶/8.png" alt="image.png"></p><p>Web3.js 是一个由以太坊基金会开发和维护的开源JavaScript库，使用HTTP或 IPC(Inter-Process Communication进程间通信) 连接 或 WebSocket 来和本地或远程以太坊节点进行交互的库。类比于 JavaScript库 axios 对 Web 服务器进行 Ajax 调用，您可以使用Web3.js来读取和写入以太坊区块链。</p><p>web3.js。因此，有更广泛的支持，因为有更多的开发人员支持它。</p><p>Web3.js 库由一系列模块的集合，服务于以太坊生态系统的各个功能，如：</p><p>●web3-eth 用来与以太坊区块链及合约的交互；</p><p>●web3-shh Whisper 协议相关，进行p2p通信和广播；</p><p>●web3-bzz swarm 协议（去中心化文件存储）相关；</p><p>●web3-utils 包含一些对 DApp 开发者有用的方法。</p><p>官网：<a href="https://web3js.org/" target="_blank" rel="noopener">https://web3js.org</a></p><p>GitHub: <a href="https://github.com/web3/web3.js" target="_blank" rel="noopener">https://github.com/web3/web3.js</a></p><p> 什么是 ethers.js？ </p><p>ETHERS.JS</p><p><img src="/2025/03/11/solidity进阶/9.png" alt="image.png"></p><p>ethers.js库旨在为以太坊区块链及其生态系统提供一个小而完整的 JavaScript API 库，ethers.js 对比使用 web3.js 代码量更少，接口也更简洁。</p><p>可以通过<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a>、<a href="https://infura.io/" target="_blank" rel="noopener">INFURA</a>、<a href="https://etherscan.io/" target="_blank" rel="noopener">Etherscan</a>、<a href="https://alchemyapi.io/" target="_blank" rel="noopener">Alchemy</a>、<a href="https://developers.cloudflare.com/distributed-web/ethereum-gateway/" target="_blank" rel="noopener">Cloudflare</a>或<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>连接到以太坊节点。</p><p>与 web3.js 相似，ethers.js 常用模块有:</p><p>●Ethers.provider 封装与以太坊区块链的连接。它可以用于签发查询和发送已签名的交易，这将改变区块链的状态。</p><p>●Ethers.contract 部署智能合约并与它交互。具体来说，该模块中的函数用于侦听从智能合约发射的事件、调用智能合约提供的函数、获取有关智能合约的信息，以及部署智能合约。</p><p>●Ethers.utils 提供用于格式化数据和处理用户输入的实用程序函数。Ethers.utils 的作用方式与 web3-utils 相似，能够简化去中心化应用的构建流程。</p><p>●Ethers.wallets 提供的功能与我们目前讨论过的其他模块截然不同。Ethers.wallet 的作用是使你可以与现有钱包（以太坊地址）建立连接、创建新钱包以及对交易签名。</p><p>官网：<a href="https://ethers.org/" target="_blank" rel="noopener">https://ethers.org</a></p><p>GitHub：<a href="https://github.com/ethers-io/ethers.js" target="_blank" rel="noopener">https://github.com/ethers-io/ethers.js</a></p><p> web3.js 和 ethers.js 该如何选择 </p><p> 作者对比 </p><p>Web3.js 所有者是<a href="https://ethereum.org/en/" target="_blank" rel="noopener">以太坊基金会</a></p><p>ethers.js 所有者是Richard Moore</p><p>两个库都能够完成任务。Ethers.js 在近两年来越来越受欢迎，下载量和项目使用量都不断增加。Web3.js 一直以来都作为标杆存在，并且仍然拥有许多开发者共享资源。后面将介绍如何连接到 <a href="https://infura.io/dashboard" target="_blank" rel="noopener">Infura API</a> 并使用 web3.js 和 ethers.js 发送交易。</p><h1 id="web3-与智能合约"><a href="#web3-与智能合约" class="headerlink" title="web3 与智能合约"></a>web3 与智能合约</h1><ol><li>获取合约部署后的配置文件  在 <code>artifacts</code> 下的的 <code>合约名.json</code>文件</li><li><img src="/2025/03/11/solidity进阶/10.png" alt="image-20221212221505979"></li></ol><p><a href="https://web3js.readthedocs.io/en/v1.8.1/" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/v1.8.1/</a></p><h2 id="window-ethereum-API"><a href="#window-ethereum-API" class="headerlink" title="window.ethereum API"></a><strong>window.ethereum API</strong></h2><p>MetaMask会向网页注入一个全局的API变量window.ethereum，出于历史遗留原因， 这个全局API变量也可以使用window.web3.currentProvider来访问。该API允许 网站请求用户登录，可以从用户接入的区块链读取数据，并切能够提示用户签名 要提交的交易。</p><p>你可以使用这个API来检测一个浏览器是否注入了window.ethereum：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ethereum !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'MetaMask is installed!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ethereum API本身很简单，它同时也封装了以太坊JSON-RPC消息，就像那些流行的库例如web3、 truffle、ethjs、Embark等等一样。</p><h3 id="ethereum-isConnected"><a href="#ethereum-isConnected" class="headerlink" title="ethereum.isConnected()"></a>ethereum.isConnected()</h3><p>如果提供者连接到当前链返回true，否则返回false。</p><p>如果提供商未连接，则必须重新加载页面才能重新建立连接。</p><h3 id="eth-requestAccounts-请求用户授权"><a href="#eth-requestAccounts-请求用户授权" class="headerlink" title="eth_requestAccounts - 请求用户授权"></a>eth_requestAccounts - 请求用户授权</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方式1</span></span><br><span class="line">ethereum.request(&#123; <span class="attr">method</span>: <span class="string">'eth_requestAccounts'</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// You now have an array of accounts!</span></span><br><span class="line">    <span class="comment">// Currently only ever one:</span></span><br><span class="line">    <span class="comment">// ['0xFDEa65C8e26263F459A1B5de9555D2931A33b825']</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason === <span class="string">"User rejected provider access"</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="ethereum-selectedAddress-获取当前用户账号"><a href="#ethereum-selectedAddress-获取当前用户账号" class="headerlink" title="ethereum.selectedAddress - 获取当前用户账号"></a>ethereum.selectedAddress - 获取当前用户账号</h3><p>ethereum.selectedAddress 属性返回表示用户当前选择的以太坊账号，16进制字符串表示</p><h3 id="ethereum-isMetaMask-检测是否使用MetaMask"><a href="#ethereum-isMetaMask-检测是否使用MetaMask" class="headerlink" title="ethereum.isMetaMask - 检测是否使用MetaMask"></a>ethereum.isMetaMask - 检测是否使用MetaMask</h3><p>ethereum.isMetaMask返回true或false，表示当前用户是否安装了MetaMask。</p><h3 id="ethereum-autoRefreshOnNetworkChange-网络切换时是否自动刷新"><a href="#ethereum-autoRefreshOnNetworkChange-网络切换时是否自动刷新" class="headerlink" title="ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新"></a>ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新</h3><p>当用户切换网络时，MetaMask扩展会自动刷新。 ethereum.autoRefreshOnNetworkChange这个实验性质的属性允许你关闭 默认的网络切换自动刷新功能。</p><h3 id="ethereum-on-监听MetaMask事件"><a href="#ethereum-on-监听MetaMask事件" class="headerlink" title="ethereum.on() - 监听MetaMask事件"></a>ethereum.on() - 监听MetaMask事件</h3><p>ethereum.on()方法用来监听MetaMask的事件，其原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethereum.on(eventName, callback)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>eventName：要监听的事件名称</li><li>callback：事件触发时的回调函数</li></ul><p>目前支持下列事件：</p><ul><li>accountsChanged：当用户选中账号变化时触发</li><li>networkChanged：当所连接网络ID变化时触发</li></ul><p>注意：networkChanged事件只有当你禁用ethereum.autoRefreshOnNetworkChange属性时才有用。</p><p>下面的代码在用户切换MetaMask账号后输出新账号到控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ethereum.on(<span class="string">'accountsChanged'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(accounts[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="调用智能合约-MetaMask"><a href="#调用智能合约-MetaMask" class="headerlink" title="调用智能合约(MetaMask)"></a>调用智能合约(MetaMask)</h2><h3 id="实例web3"><a href="#实例web3" class="headerlink" title="实例web3"></a>实例web3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="keyword">import</span> mtcContract <span class="keyword">from</span> <span class="string">"./contracts/contract_Ballot.json"</span>;</span><br><span class="line"><span class="comment">// 链接上web3 格尔丽的环境</span></span><br><span class="line"><span class="keyword">const</span> geerliWS =</span><br><span class="line">  <span class="string">"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb"</span>;</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || geerliWS);</span><br></pre></td></tr></table></figure><h3 id="账户链接"><a href="#账户链接" class="headerlink" title="账户链接"></a>账户链接</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> account = <span class="keyword">await</span> web3.eth.requestAccounts();</span><br></pre></td></tr></table></figure><h3 id="实例合约"><a href="#实例合约" class="headerlink" title="实例合约"></a>实例合约</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> web3.eth.Contract(智能合约abi,合约地址)</span><br><span class="line"><span class="keyword">this</span>.votoContract = <span class="keyword">new</span> web3.eth.Contract(</span><br><span class="line">      mtcContract.abi,</span><br><span class="line">      <span class="string">"0x1D108E4B9162668e1adACD07727b3de749818d0a"</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>不需要消耗gas的方法 call (不修改数据的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.methods.myMethod([param1[, param2[, ...]]]).call(options [, defaultBlock] [, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the callback</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).call(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using the promise</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).call(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改数据消耗gas的方法 send</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.methods.myMethod([param1[, param2[, ...]]]).send(options[, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the callback</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).send(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, transactionHash</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using the promise</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).send(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">receipt</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// receipt can also be a new contract instance, when coming from a "contract.deploy(&#123;...&#125;).send()"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意:数据修改完成后根据需求监听<code>receipt</code>事件</p></li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.events.MyEvent([options][, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myContract.events.MyEvent(&#123;</span><br><span class="line">    filter: &#123;<span class="attr">myIndexedParam</span>: [<span class="number">20</span>,<span class="number">23</span>], <span class="attr">myOtherIndexedParam</span>: <span class="string">'0x123456789...'</span>&#125;, <span class="comment">// Using an array means OR: e.g. 20 or 23</span></span><br><span class="line">    fromBlock: <span class="number">0</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, event</span>)</span>&#123; <span class="built_in">console</span>.log(event); &#125;)</span><br><span class="line">.on(<span class="string">"connected"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">subscriptionId</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(subscriptionId);</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event); <span class="comment">// same results as the optional callback above</span></span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'changed'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// remove event from local database</span></span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, receipt</span>) </span>&#123; <span class="comment">// If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;web3 与智能合约&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;代币信息&lt;/h1&gt;</span><br><span class="line">    名称: &#123;&#123; name  &#125;&#125; &lt;br&gt;</span><br><span class="line">    标识: &#123;&#123; symbol &#125;&#125; &lt;br&gt;</span><br><span class="line">    发行量 &#123;&#123; web3.utils.fromWei(totalSupply,&quot;ether&quot; ) &#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;账户信息&lt;/h2&gt;</span><br><span class="line">    地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br&gt;</span><br><span class="line">    余额: &#123;&#123;web3.utils.fromWei(balanceOf,&quot;ether&quot;)&#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;操作&lt;/h2&gt;</span><br><span class="line">    收款方: &lt;input type=&quot;text&quot; v-model=&quot;toAddress&quot;&gt; &lt;br&gt;</span><br><span class="line">    金额:&lt;input type=&quot;text&quot; v-model=&quot;money&quot;&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;转账&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const Web3 = require(&quot;web3&quot;);</span><br><span class="line">import &#123; abi &#125; from &quot;./contracts/HHC.json&quot;;</span><br><span class="line">console.log(abi);</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:&quot;&quot;,</span><br><span class="line">      symbol:&quot;&quot;,</span><br><span class="line">      totalSupply: &quot;&quot;,</span><br><span class="line">      balanceOf: &quot;&quot;,</span><br><span class="line">      accounts:[],</span><br><span class="line">      toAddress: &quot;0xE251ddBe6191594922bfd3d338529EC9C613eB67&quot;,</span><br><span class="line">      money:1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 初始化web3实例</span><br><span class="line">    async initWeb3() &#123;</span><br><span class="line">      const geerliWS =</span><br><span class="line">        &quot;wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;;</span><br><span class="line">      this.web3 = new Web3(Web3.givenProvider || geerliWS);</span><br><span class="line">      // 获取metamask钱包使用的用户</span><br><span class="line">      this.accounts = await this.web3.eth.requestAccounts();</span><br><span class="line">      console.log( this.accounts)</span><br><span class="line">      this.initContract();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化智能合约</span><br><span class="line">    initContract() &#123;</span><br><span class="line">      // 代币 hhc 智能合约地址</span><br><span class="line">      this.HccCont = new this.web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        &quot;0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5&quot;</span><br><span class="line">      );</span><br><span class="line">      this.getCoinInfo();</span><br><span class="line">      this.addEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取代币的信息</span><br><span class="line">    async getCoinInfo() &#123;</span><br><span class="line">      // 不修改状态数据 不消耗gas</span><br><span class="line">      this.name = await this.HccCont.methods.name().call();</span><br><span class="line">      this.symbol = await this.HccCont.methods.symbol().call();</span><br><span class="line">      this.totalSupply = await this.HccCont.methods.totalSupply().call();</span><br><span class="line">      this.balanceOf = await this.HccCont.methods.balanceOf(this.accounts[0]).call();</span><br><span class="line">    &#125;,</span><br><span class="line">    send() &#123;</span><br><span class="line">      // 修改状态数据</span><br><span class="line">      const weiNum = this.web3.utils.toWei(String(this.money), &apos;ether&apos;);</span><br><span class="line">      console.log(weiNum)</span><br><span class="line">      this.HccCont.methods.transfer(this.toAddress,weiNum).send(&#123;</span><br><span class="line">        from: this.accounts[0],</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(&apos;receipt&apos;, function(receipt)&#123;</span><br><span class="line">        console.log(&quot;交易成功&quot;)</span><br><span class="line">        console.log(receipt)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    addEvents() &#123;</span><br><span class="line">      this.HccCont.events.Transfer(&#123;</span><br><span class="line">        filter: &#123;&#125;,</span><br><span class="line">        fromBlock: 8161338,</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(&quot;data&quot;,(event) =&gt; &#123;</span><br><span class="line">        console.log(&quot;events transfer&quot;);</span><br><span class="line">        console.log(event)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    if (typeof window.ethereum !== &quot;undefined&quot;) &#123;</span><br><span class="line">      console.log(&quot;MetaMask is installed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.initWeb3();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="调用智能合约-纯web3"><a href="#调用智能合约-纯web3" class="headerlink" title="调用智能合约(纯web3)"></a>调用智能合约(纯web3)</h2><blockquote><p>调用智能合约也相当于是通过web3 发起一个交易</p><p>核心在于  web3.eth.sendSignedTransaction(transHash)</p><p>在构建hash数据时候将调用的合约信息添加进入</p></blockquote><h3 id="构建调用智能合约交易hash"><a href="#构建调用智能合约交易hash" class="headerlink" title="构建调用智能合约交易hash"></a>构建调用智能合约交易hash</h3><p>将智能合约的方法调用 通过<code>encodeABI</code>进行转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contractData = <span class="keyword">await</span> contract.methods.transfer(<span class="string">"转账地址"</span>,web3.utils.toWei(<span class="string">'转账金额'</span>)).encodeABI()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建交易hash</span></span><br><span class="line"><span class="keyword">async</span> createTransationHx(key, fromAddress, toAddress, money) &#123;</span><br><span class="line">  <span class="comment">// key 私钥</span></span><br><span class="line">  <span class="comment">// fromAddress 发送方地址</span></span><br><span class="line">  <span class="comment">// toAddress 接受方地址</span></span><br><span class="line">  <span class="comment">// money 转账金额</span></span><br><span class="line">  <span class="comment">// 当前地址交易次数</span></span><br><span class="line">  <span class="keyword">const</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromAddress);</span><br><span class="line">  <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">  <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">  <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.utils.toWei(money);</span><br><span class="line"><span class="keyword">const</span> contractData = <span class="keyword">await</span> contract.methods.transfer(<span class="string">"0x9B0DbF610175F5c783ec169DAdDa5E8B17055626"</span>,web3.utils.toWei(<span class="string">'30000'</span>)).encodeABI()</span><br><span class="line">  <span class="comment">// 转账的记录对象</span></span><br><span class="line">  <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">    <span class="keyword">from</span>: fromAddress,</span><br><span class="line">    nonce: nonce,</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">    to:<span class="string">""</span>,<span class="comment">//智能合约地址,</span></span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    data: contractData, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">  <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">  rawTx.gas = gas;</span><br><span class="line">  <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">  <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">  tx.sign(privateKey);</span><br><span class="line">  <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">  <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">  <span class="keyword">return</span> transationHx;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="常规转账发起"><a href="#常规转账发起" class="headerlink" title="常规转账发起"></a>常规转账发起</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> sendToken() &#123;</span><br><span class="line">     <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">     <span class="keyword">let</span> keystore = <span class="keyword">this</span>.walletInfo.keystore;</span><br><span class="line">     <span class="keyword">let</span> wallet;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">       alert(<span class="string">"密码错误"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(prikey)</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">from</span>  = <span class="keyword">this</span>.walletInfo.lowerCaseAddress;</span><br><span class="line">     <span class="keyword">const</span> to = <span class="keyword">this</span>.to;</span><br><span class="line">     <span class="keyword">const</span> money = <span class="keyword">this</span>.money;</span><br><span class="line">     <span class="comment">// 获取交易hx</span></span><br><span class="line">     <span class="keyword">const</span> transHash = <span class="keyword">await</span> <span class="keyword">this</span>.createTransationHx(prikey,<span class="keyword">from</span>,to,money)</span><br><span class="line">     <span class="comment">// 发布交易信息</span></span><br><span class="line">     web3.eth</span><br><span class="line">       .sendSignedTransaction(transHash)</span><br><span class="line">       .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">       &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">         <span class="keyword">const</span> &#123; transactionHash &#125; = ret;</span><br><span class="line">         <span class="comment">// 从区块节点中获取交易hash</span></span><br><span class="line">         <span class="keyword">this</span>.createOrderData(transactionHash);</span><br><span class="line">       &#125;)</span><br><span class="line">       .on(<span class="string">'confirmation'</span>, (ret)=&gt;&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'confirmation'</span>,ret)</span><br><span class="line">       &#125;)</span><br><span class="line">       .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;web3 与智能合约&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;代币信息&lt;/</span>h1&gt;</span><br><span class="line">    名称: &#123;&#123; name &#125;&#125; &lt;br /&gt;</span><br><span class="line">    标识: &#123;&#123; symbol &#125;&#125; &lt;br /&gt;</span><br><span class="line">    发行量 &#123;&#123; web3.utils.fromWei(totalSupply, <span class="string">"ether"</span>) &#125;&#125; &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;账户信息&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br /</span>&gt;</span><br><span class="line">    eth余额: &#123;&#123; web3.utils.fromWei(ethBalance, <span class="string">"ether"</span>) &#125;&#125;&lt;br /&gt;</span><br><span class="line">    代币余额: &#123;&#123; web3.utils.fromWei(balanceOf, <span class="string">"ether"</span>) &#125;&#125; &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;操作&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    收款方: &lt;input type="text" v-model="toAddress" /</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    金额:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"money"</span> /&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    &lt;button @click=<span class="string">"send"</span>&gt;代币转账&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="sendEth"&gt;转账Eth&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="keyword">const</span> Tx = <span class="built_in">require</span>(<span class="string">"ethereumjs-tx"</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; abi &#125; <span class="keyword">from</span> <span class="string">"./contracts/HHC.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(abi);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">""</span>,</span><br><span class="line">      symbol: <span class="string">""</span>,</span><br><span class="line">      totalSupply: <span class="string">""</span>,</span><br><span class="line">      balanceOf: <span class="string">""</span>,</span><br><span class="line">      accounts: [],</span><br><span class="line">      toAddress: <span class="string">"0xE251ddBe6191594922bfd3d338529EC9C613eB67"</span>,</span><br><span class="line">      money: <span class="string">"1"</span>,</span><br><span class="line">      ethBalance: <span class="string">"0"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 初始化web3实例</span></span><br><span class="line">    <span class="keyword">async</span> initWeb3() &#123;</span><br><span class="line">      <span class="keyword">const</span> geerliWS =</span><br><span class="line">        <span class="string">"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb"</span>;</span><br><span class="line">      <span class="keyword">this</span>.web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || geerliWS);</span><br><span class="line">      <span class="comment">// 获取metamask钱包使用的用户</span></span><br><span class="line">      <span class="keyword">this</span>.accounts = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.requestAccounts();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.accounts);</span><br><span class="line">      <span class="keyword">this</span>.ethBalance = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getBalance(<span class="keyword">this</span>.accounts[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.ethBalance);</span><br><span class="line">      <span class="keyword">this</span>.initContract();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 初始化智能合约</span></span><br><span class="line">    initContract() &#123;</span><br><span class="line">      <span class="comment">// 代币 hhc 智能合约地址</span></span><br><span class="line">      <span class="keyword">this</span>.HccCont = <span class="keyword">new</span> <span class="keyword">this</span>.web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        <span class="string">"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">this</span>.getCoinInfo();</span><br><span class="line">      <span class="keyword">this</span>.addEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取代币的信息</span></span><br><span class="line">    <span class="keyword">async</span> getCoinInfo() &#123;</span><br><span class="line">      <span class="comment">// 不修改状态数据 不消耗gas</span></span><br><span class="line">      <span class="keyword">this</span>.name = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.name().call();</span><br><span class="line">      <span class="keyword">this</span>.symbol = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.symbol().call();</span><br><span class="line">      <span class="keyword">this</span>.totalSupply = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.totalSupply().call();</span><br><span class="line">      <span class="keyword">this</span>.balanceOf = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods</span><br><span class="line">        .balanceOf(<span class="keyword">this</span>.accounts[<span class="number">0</span>])</span><br><span class="line">        .call();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过metamask 调用智能合约</span></span><br><span class="line">    send() &#123;</span><br><span class="line">      <span class="comment">// 修改状态数据</span></span><br><span class="line">      <span class="keyword">const</span> weiNum = <span class="keyword">this</span>.web3.utils.toWei(<span class="built_in">String</span>(<span class="keyword">this</span>.money), <span class="string">"ether"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(weiNum);</span><br><span class="line">      <span class="keyword">this</span>.HccCont.methods</span><br><span class="line">        .transfer(<span class="keyword">this</span>.toAddress, weiNum)</span><br><span class="line">        .send(&#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="keyword">this</span>.accounts[<span class="number">0</span>],</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">receipt</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易成功"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(receipt);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 生成交易的hash 数据</span></span><br><span class="line">    <span class="keyword">async</span> createTransationHx(prikey,<span class="keyword">from</span>,to,money) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"money"</span>,<span class="keyword">typeof</span> money, money)</span><br><span class="line">       <span class="comment">// 当前地址交易次数</span></span><br><span class="line">      <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(prikey, <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">      <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getGasPrice();</span><br><span class="line">      <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">this</span>.web3.utils.toWei(money);</span><br><span class="line">      <span class="comment">// 转账的记录对象</span></span><br><span class="line">      <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        nonce: nonce,</span><br><span class="line">        gasPrice: gasPrice,</span><br><span class="line">        to,<span class="comment">//智能合约地址,</span></span><br><span class="line">        value: value,</span><br><span class="line">        data:<span class="string">""</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">       <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.estimateGas(rawTx);</span><br><span class="line">       rawTx.gas = gas;</span><br><span class="line">        <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">      <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">      <span class="keyword">return</span> transationHx;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代币转账</span></span><br><span class="line">    <span class="keyword">async</span> createCoinTransationHx(prikey,<span class="keyword">from</span>,to,money) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"money"</span>,<span class="keyword">typeof</span> money, money)</span><br><span class="line">       <span class="comment">// 当前地址交易次数</span></span><br><span class="line">      <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(prikey, <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">      <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getGasPrice();</span><br><span class="line">      <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">this</span>.web3.utils.toWei(money);</span><br><span class="line">      <span class="comment">// 转账的记录对象</span></span><br><span class="line">      <span class="comment">// 代币转账</span></span><br><span class="line">      <span class="keyword">const</span> contractAbi = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.transfer(to,value).encodeABI();</span><br><span class="line">      <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        nonce: nonce,</span><br><span class="line">        gasPrice: gasPrice,</span><br><span class="line">        to:<span class="string">'0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5'</span>,<span class="comment">//eth 转账 to 目标地址 ，智能合约 to 智能合约地址</span></span><br><span class="line">        value: <span class="number">0</span>, <span class="comment">//eth 转账 数量</span></span><br><span class="line">        data:contractAbi, <span class="comment">//智能合约方法的abi编码</span></span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">       <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.estimateGas(rawTx);</span><br><span class="line">       rawTx.gas = gas;</span><br><span class="line">        <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">      <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">      <span class="keyword">return</span> transationHx;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过纯web3调用智能合约</span></span><br><span class="line">    <span class="keyword">async</span> sendEth() &#123;</span><br><span class="line">      <span class="keyword">const</span> prikey =</span><br><span class="line">        <span class="string">"71676f2ff44e36e78a276b16ac389ee8536790c8dfb12392c002050d6f162902"</span>;</span><br><span class="line">      <span class="comment">// 获取转账的hash</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">from</span> = <span class="keyword">this</span>.accounts[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 代币hash</span></span><br><span class="line">      <span class="keyword">const</span> transHash = <span class="keyword">await</span> <span class="keyword">this</span>.createCoinTransationHx(prikey, <span class="keyword">from</span>, <span class="keyword">this</span>.toAddress, <span class="keyword">this</span>.money);</span><br><span class="line">      <span class="comment">// 珠链币的hash</span></span><br><span class="line">      <span class="comment">// const transHash = await this.createTransationHx(prikey, from, this.toAddress, this.money);</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"transHash"</span>,transHash);</span><br><span class="line">      <span class="comment">// 发起交易</span></span><br><span class="line">      <span class="keyword">this</span>.web3.eth</span><br><span class="line">        .sendSignedTransaction(transHash)</span><br><span class="line">        .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    addEvents() &#123;</span><br><span class="line">      <span class="keyword">this</span>.HccCont.events</span><br><span class="line">        .Transfer(&#123;</span><br><span class="line">          filter: &#123;&#125;,</span><br><span class="line">          fromBlock: <span class="number">8161338</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"data"</span>, (event) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"events transfer"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(event);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ethereum !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"MetaMask is installed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.initWeb3();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solidity进阶-ERC20代币开发&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>solidity入门</title>
    <link href="/2025/03/11/solidity%E5%85%A5%E9%97%A8/"/>
    <id>/2025/03/11/solidity入门/</id>
    <published>2025-03-11T01:53:27.000Z</published>
    <updated>2025-03-11T05:23:41.472Z</updated>
    
    <content type="html"><![CDATA[<p>solidity语法基础入门<br><a id="more"></a></p><h1 id="Solidity-开发环境"><a href="#Solidity-开发环境" class="headerlink" title="Solidity 开发环境"></a>Solidity 开发环境</h1><ol><li>Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。</li><li>以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常用的以太坊开发环境包括Truffle、Embark和Buidler （Hardhat）。</li><li>以太坊虚拟机：以太坊虚拟机（Ethereum Virtual Machine，EVM）是以太坊区块链的运行环境，用于在以太坊区块链上运行智能合约。常用的以太坊虚拟机包括ganache-cli和geth。</li><li>以太坊浏览器：以太坊浏览器是一种用于浏览、搜索和交互以太坊区块链数据的工具。常用的以太坊浏览器包括Etherscan、Etherchain和Blockchain Explorer。</li></ol><h2 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a><a href="https://hardhat.org/" target="_blank" rel="noopener">Hardhat</a></h2><p><a href="https://hardhat.org/" target="_blank" rel="noopener">https://hardhat.org/</a></p><p>Hardhat是目前最好的框架之一，支持快速测试，同时提供了最好的教程和最简单的集成。 老实说，每个喜欢JS框架的人都应该在某个时候试用Hardhat。它真的很容易上手，具有快速的测试， 而且入门非常简单。Hardhat的Discord也总是非常迅速地回答问题，因此，如果遇到问题，你 总是可以寻求帮助。Hathat使用Waffle和Ethers.js进行测试 —— 可以说是更好的JavaScript 智能合约框架 —— 开发人员的生活质量确实能得到一些改善。</p><p>Hardhat还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 这个项目给人一种很棒的感觉：很干净。它会执行你想要的操作。真的很快。该项目正在不断改进， Hardhat显然致力于使智能合约开发人员的生活更轻松。</p><p>Hardhat概要：</p><p>ETH基金会资助的项目，以前的名字是Builder<br>技术：Javascript，Web3.js和Ethers.js插件，OpenZeppelin可升级合同插件， Etherscan插件，区块链分叉<br>区块链：Hardhat运行时环境/本地、测试网、主网<br>测试支持：Waffle<br>维护：非常活跃<br>支持：活跃<br>开源</p><h2 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h2><p><a href="https://trufflesuite.com/" target="_blank" rel="noopener">https://trufflesuite.com/</a></p><p>几年来Truffle一直是以太坊智能合约的默认开发框架，这是有充分理由的。 Truffle是一个强大的框架，为其他许多人树立了标准。你很容易找到使用此平台的项目， 因此查找示例很容易。Truffle也可以很容易地与它的姊妹工具Drizzle和Ganache集成在一起。 特别是Ganache，它是工程师运行本地区块链的最流行方法之一。对于那些正在寻找更多工具的人， 你可以为升级的Truffle团队帐户付费，并可以访问智能合约的持续集成，可视化部署和监视。 Truffle还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 Truffle的开发团队显然是一群有才华的工程师，他们想要使世界成为一个更好的智能合约场所。</p><p>Truffle测试的运行速度不如hardhat那样快，并且由于用户数量众多，获得支持可能很困难。 我很期待看到被ConsenSys收购后他们将如何改善这个项目。Truffle的文档质量似乎开始下降 并且很难遵循，但是如果你用Google搜索遇到的错误，则很可能会遇到遇到该错误并已解决的人。 我发现改善项目的一些最佳方法是在GitHub上发布问题。无论如何，保持生态系统不断壮大是我们 的开源职责！</p><p>由于几乎每个人都熟悉它，因此获得同行的支持通常很容易。我真的希望看到团队在这个项目 上获得更多支持，因为他们有这么多用户。我希望他们能看到本文并致力于改善其文档，以使 其能够继续作为测试和部署智能合约的首选平台之一。</p><p>Truffle概要：</p><p>使用最广泛的平台；最近被ConsenSys收购（2020年11月）<br>技术：Javascript，Web3.js，OpenZeppelin可升级合同插件，Etherscan插件，区块链分叉<br>区块链：Ganache /本地，测试网，主网<br>有测试<br>维护：非常活跃<br>支持：活跃<br>开源，可以付费升级</p><h2 id="Embark"><a href="#Embark" class="headerlink" title="Embark"></a>Embark</h2><p>Embark是整个DAPP框架。这是一个全栈的区块链平台。在Gitter的 一些帮助下，我能够将Chainlink合约部署到Kovan网络。它带有一个UI，允许你在GUI中与区块链 和合约进行交互。Embark有一段学习曲线，我没有花足够的时间来克服，但它展示了其潜力。这就是 为什么我想将其包括在这里的原因，因为我觉得我没有完全消化很多东西。</p><p>我希望看到人们更多地尝试该框架并看到其功能。由于在项目中花费的时间有限，我觉得我可能 无法在这里做到公正。我确实认为将前端与后端解耦仍然是最佳做法，但是如果你需要启动一个 具有良好前端的项目并且不关心解耦，那么您应该100％尝试这个项目。</p><p>这是一个很酷的项目，如果有人喜欢Hardhat和Truffle，并且又想与全栈解决方案集成，那么我愿意 推荐Embark给他。</p><p>Embark概要：</p><p>具有大量功能的JavaScript框架用于前端开发<br>技术：JavaScript，Web3.js，代理合约支持<br>区块链：Ganache /本地，测试网，主网<br>支持测试<br>维护：轻度活跃<br>支持：活跃<br>开源</p><h1 id="Remix基本使用"><a href="#Remix基本使用" class="headerlink" title="Remix基本使用"></a>Remix基本使用</h1><p>Remix 是以太坊智能合约编程语言Solidity IDE，其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。<br><a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a> <a href="https://remix.ethereum.org/。" target="_blank" rel="noopener">https://remix.ethereum.org/。</a></p><h2 id="Remix基本功能"><a href="#Remix基本功能" class="headerlink" title="Remix基本功能"></a>Remix基本功能</h2><p><img src="/2025/03/11/solidity入门/1.png" alt="image-20221208134636521"></p><h2 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h2><ol><li><p>如上图创建一个空的工作空间</p></li><li><p>在工作空间下创建一个智能合约文件,ex: <code>HelloWord.sol</code></p><ul><li>智能合约文件以<code>.sol</code>结尾，</li><li>文件名采用大驼峰命名法</li><li>文件名和合约名保持一致</li></ul></li><li><p>编写合约代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/2.png" alt="image-20221208140310359"></p></li></ol><h2 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h2><p><img src="/2025/03/11/solidity入门/3.png" alt="image-20221208140810607"></p><p>编译结果：</p><p>目录产生一个<code>artifacts</code> 文件夹</p><p><img src="/2025/03/11/solidity入门/4.png" alt="image-20221208140957454"></p><h2 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h2><ol><li>通过第四个菜单进入部署界面</li><li>选择部署环境</li><li>选择部署合约的账户地址</li><li>设置gas限制</li><li>选择要部署的合约</li><li><p><code>deploy</code>按钮进行部署</p><p><img src="/2025/03/11/solidity入门/5.png" alt="image-20221208141436813"></p></li></ol><p>部署成功效果</p><p><img src="/2025/03/11/solidity入门/6.png" alt="image-20221208141815165"></p><h2 id="合约调试"><a href="#合约调试" class="headerlink" title="合约调试"></a>合约调试</h2><ol><li>通过函数的返回值查看变量</li></ol><p><img src="/2025/03/11/solidity入门/7.png" alt="image-20221208142340517"></p><ol start="2"><li>event Log </li></ol><p>​       solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/8.png" alt="image-20221208145721522"></p><h1 id="本地部署ReMix-IDE"><a href="#本地部署ReMix-IDE" class="headerlink" title="本地部署ReMix IDE"></a>本地部署ReMix IDE</h1><p>在线Remix访问缓慢，如果你有很好的网络环境也可以本地部署一套。<br>在本地部署Remix需要准备两个东西：一个是Remix-project，可以理解为Remix的前端；另一个是Remixd，可以理解为Remix的后端，它们的Github仓库地址分别是：<br><a href="https://github.com/ethereum/remix-project" target="_blank" rel="noopener">https://github.com/ethereum/remix-project</a><br><a href="https://github.com/ethereum/remix-project/tree/master/libs/remixd" target="_blank" rel="noopener">https://github.com/ethereum/remix-project/tree/master/libs/remixd</a></p><h2 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h2><p>如果要运行合并到主分支中的最新更改，请运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:latest</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:latest</span><br></pre></td></tr></table></figure><p>如果你想运行最新的 remix-live 版本运行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:remix_live</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:remix_live</span><br></pre></td></tr></table></figure><h2 id="docker-compose方式安装"><a href="#docker-compose方式安装" class="headerlink" title="docker-compose方式安装"></a>docker-compose方式安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> pull</span><br><span class="line">docker<span class="literal">-compose</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure><h2 id="部署-Remixd"><a href="#部署-Remixd" class="headerlink" title="部署 Remixd"></a>部署 Remixd</h2><p>Remixd 的安装使用步骤如下：</p><p>1.通过 npm 或者 yarn 安装 Remixd（建议用yarn）</p><p>npm 命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> @remix<span class="literal">-project</span>/remixd</span><br><span class="line">yarn add global @remix<span class="literal">-project</span>/remixd</span><br></pre></td></tr></table></figure><p>2.启动 Remix-IDE</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remixd <span class="literal">-s</span> ./shared_project <span class="literal">-u</span> http://localhost:<span class="number">8080</span></span><br></pre></td></tr></table></figure><p>3.在 Remix-IDE 上点两下</p><p>一个点 Solidity，选择相应环境；另一个点 Connect to Localhost，连接本地环境</p><p><img src="/2025/03/11/solidity入门/9.png" alt></p><p><img src="/2025/03/11/solidity入门/10.png" alt></p><h1 id="Solidity基础介绍"><a href="#Solidity基础介绍" class="headerlink" title="Solidity基础介绍"></a>Solidity基础介绍</h1><h2 id="认识一个最简单的存储合约"><a href="#认识一个最简单的存储合约" class="headerlink" title="认识一个最简单的存储合约"></a>认识一个最简单的存储合约</h2><p><img src="/2025/03/11/solidity入门/11.png" alt="image-20221214103704773"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">import &quot;&quot;;</span><br><span class="line">// 导入</span><br><span class="line"></span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    // 状态变量  </span><br><span class="line">    // 函数</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="授权协议"><a href="#授权协议" class="headerlink" title="授权协议"></a>授权协议</h3><ul><li>默认情况下，在发布源代码时加入机器可读许可证说明是很重要的。由于提供源代码总是涉及版权方面的法律问题，Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符,比如：<code>// SPDX-License-Identifier: MIT</code></li></ul><p>至于什么是SPDX 大家可以参考如下资料：</p><p>首先是SPDX，这是个组织名，其网站为：<br><a href="https://spdx.org/licenses/" target="_blank" rel="noopener">SPDX 许可证列表 |软件包数据交换 （SPDX）</a><br>SPDX-License-Identifier 组合起来就是在指SPDX的许可证列表<br>后面的格式为 ：+ SPDX的许可证列表中的某个许可证</p><p>比如上面例子中的MIT 许可：</p><p>MIT 基本信息<br>全名：MIT License <a href="https://spdx.org/licenses/MIT.html" target="_blank" rel="noopener">麻省理工学院许可证</a> 标志符：<a href="https://zh.wikipedia.org/zh-cn/MIT許可證" target="_blank" rel="noopener">MIT</a><br>MIT的具体内容<br>特此免费授予获得（“软件”）副本的任何人不受限制地处理本软件的许可，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或出售本软件副本的权利</p><h3 id="Solidity版本限制"><a href="#Solidity版本限制" class="headerlink" title="Solidity版本限制"></a>Solidity版本限制</h3><ul><li>第二行是告诉编译器源代码所适用的Solidity版本为&gt;=0.7.0 及 &lt;0.9.0 。这样的说明是为了确保合约不会在新的编译器版本中发生异常的行为。关键字 <code>pragma</code> 是告知编译器如何处理源代码的通用指令</li></ul><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>在一个去中心化的世界，我们的程序并不紧紧活一台机器的CPU 上, 在一个去中心化的世界是由很多节点组成的P2P 网络。合约代码会在各节点上[<a href="https://ethereum.org/en/developers/docs/nodes-and-clients/" target="_blank" rel="noopener">Full Node</a>]单独运行，而事实上P2P的各节点相互之间都不信任的，所以每个节点都会存一份自己的状态（Distributed Ledger,分布式账本），在该示例就是name，当调用set()的时候，大家都改变了name，此时需要一种共识机制（PoS），如果PoS认为name合法，此次调用完成。 否则回滚上一个name的值，因此每一次改变状态变量的调用都是以一个事务Transcation来执行。</p><h2 id="Api文档"><a href="#Api文档" class="headerlink" title="Api文档"></a>Api文档</h2><p><a href="https://solidity-by-example.org/" target="_blank" rel="noopener">https://solidity-by-example.org/</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p><strong>局部变量</strong></p></li><li><ul><li>在函数内部声明</li><li>不存储到链上</li></ul></li><li><p><strong>状态变量</strong></p></li><li><ul><li>在函数外部声明</li><li>状态变量是永久地存储在链上的值。</li></ul></li><li><p><strong>全局变量</strong> </p></li><li><ul><li>内置提供有关区块链的信息比如<code>block</code>、<code>msg</code>等</li></ul><p>全局变量 </p></li></ul><p>这些是全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">返回</th></tr></thead><tbody><tr><td style="text-align:left">blockhash(uint blockNumber) returns (bytes32)</td><td style="text-align:left">给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td></tr><tr><td style="text-align:left">block.coinbase (address payable)</td><td style="text-align:left">当前区块矿工的地址</td></tr><tr><td style="text-align:left">block.difficulty (uint)</td><td style="text-align:left">当前区块的难度</td></tr><tr><td style="text-align:left">block.gaslimit (uint)</td><td style="text-align:left">当前区块的gaslimit</td></tr><tr><td style="text-align:left">block.number (uint)</td><td style="text-align:left">当前区块的number</td></tr><tr><td style="text-align:left">block.timestamp (uint)</td><td style="text-align:left">当前区块的时间戳，为unix纪元以来的秒</td></tr><tr><td style="text-align:left">gasleft() returns (uint256)</td><td style="text-align:left">剩余 gas</td></tr><tr><td style="text-align:left">msg.data (bytes calldata)</td><td style="text-align:left">完成 calldata</td></tr><tr><td style="text-align:left">msg.sender (address payable)</td><td style="text-align:left">消息发送者 (当前 caller)</td></tr><tr><td style="text-align:left">msg.sig (bytes4)</td><td style="text-align:left">calldata的前四个字节 (function identifier)</td></tr><tr><td style="text-align:left">msg.value (uint)</td><td style="text-align:left">当前消息的wei值</td></tr><tr><td style="text-align:left">now (uint)</td><td style="text-align:left">当前块的时间戳</td></tr><tr><td style="text-align:left">tx.gasprice (uint)</td><td style="text-align:left">交易的gas价格</td></tr><tr><td style="text-align:left">tx.origin (address payable)</td><td style="text-align:left">交易的发送方</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function doSomething() public view returns(uint, address) &#123;</span><br><span class="line"></span><br><span class="line">        // 内置全局变量</span><br><span class="line">        uint timestamp = block.timestamp; // 获取区块时间戳</span><br><span class="line">        address sender = msg.sender; // 获取区块地址</span><br><span class="line">        return (timestamp,sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/12.png" alt="image-20221208152548299"></p><p>状态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    uint public nun = 123;</span><br><span class="line"></span><br><span class="line">    function doSomething() public&#123;</span><br><span class="line">        nun ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/13.png" alt="image-20221208152817271"></p><p>局部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    function doSomething() public pure  returns(uint)&#123;</span><br><span class="line">        uint num = 123;</span><br><span class="line">        num ++;</span><br><span class="line">        // 局部变量不保存每次使用都重置</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在为变量命名时，请记住以下规则。</p><ul><li>不应使用 Solidity 保留关键字作为变量名。例如，<code>break</code>或<code>boolean</code>变量名无效。</li><li>不应以数字(0-9)开头，必须以字母或下划线开头。例如，<code>123test</code>是一个无效的变量名，但是<code>_123test</code>是一个有效的变量名。</li><li>变量名区分大小写。例如，<code>Name</code>和<code>name</code>是两个不同的变量。</li></ul><h2 id="Solidity-可见性修饰符"><a href="#Solidity-可见性修饰符" class="headerlink" title="Solidity 可见性修饰符"></a><strong>Solidity 可见性修饰符</strong></h2><p>1.public – 所有合约与账号都可以调用<br>2.private -只有在定义该函数的合约可以调用<br>3.internal- 当前合约或者继承该合约的，类似java 里面的protected 关键字。<br>4.external – 只有其他合约或者账号可以调用,定义该函数的合约不能调用,除非使用 this 关键字</p><p><img src="/2025/03/11/solidity入门/14.png" alt="image-20221208153812857"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Storage &#123;</span><br><span class="line">    function set() public &#123; // 定义函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function OutsideFunc(uint x) pure returns (uint) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Solidity有两个关键字与函数输出相关：return和returns，他们的区别在于： </p><blockquote><p> returns加在函数名后面，用于声明返回的变量类型及变量名。</p><p>return用于函数主体中，返回指定的变量。</p></blockquote></li><li><p>view和pure的用法</p><blockquote><p>getter 类型的函数可以被view 或者 pure 修饰。 view 修饰的函数不能改变状态变量。pure 则既不能改变状态变量，也不取读取状态变量。</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ViewPureTest &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">    // 不能改变状态变量.</span><br><span class="line">    function addToX(uint y) public view returns (uint) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //函数中没有任何状态变量出现。</span><br><span class="line">    function add(uint i, uint j) public pure returns (uint) &#123;</span><br><span class="line">        return i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们无法确定该用view还是pure时，remix会给我们完善的提示信息</p><h2 id="错误Errors"><a href="#错误Errors" class="headerlink" title="错误Errors"></a>错误Errors</h2><blockquote><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   assert(bool condition)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  − 如果不满足条件，此方法调用将导致一个无效的操作码，对状态所做的任何更改将被还原。这个方法是用来处理内部错误的。</p><ul><li><p><code>require(bool condition)</code> − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。</p></li><li><p><code>require(bool condition, string memory message)</code> − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。它提供了一个提供自定义消息的选项。</p></li><li><p><code>revert()</code> − 此方法将中止执行并将所做的更改还原为执行前状态。</p></li><li><p><code>revert(string memory reason)</code> − 此方法将中止执行并将所做的更改还原为执行前状态。它提供了一个提供自定义消息的选项。</p></li></ul></blockquote><p>回退状态：但是gas费用是需要消耗</p><p>assert 合约内部错误</p><p>require 外部参数错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数被2整除</span><br></pre></td></tr></table></figure><p>assert 内部错误</p><p>Solidity 为应对失败，允许用户定义 <code>error</code> 来描述错误的名称和数据。 跟用错误字符串相比， <code>error</code> 更便宜并且允许你编码额外的数据，还可以用 NatSpec 为用户去描述错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">error NotFoundUser(address account, uint256 uid);</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">    mapping(address =&gt; uint256) users;</span><br><span class="line"></span><br><span class="line">    function getUser(address _account, uint256 _uid) public view &#123;</span><br><span class="line">        uint256 uid = users[msg.sender];</span><br><span class="line">        if (uid &lt; _uid) &#123;</span><br><span class="line">            revert NotFoundUser(_account, _uid);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br></pre></td></tr></table></figure><h2 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h2><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><p>  solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/15.png" alt="image-20221208145721522"></p><h1 id="变量的数据位置"><a href="#变量的数据位置" class="headerlink" title="变量的数据位置"></a>变量的数据位置</h1><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>在合约中声明和使用的变量都有一个数据位置，指明变量值应该存储在哪里。合约变量的数据位置将会影响Gas消耗量。</p><p>Solidity 提供4种类型的数据位置。</p><ul><li>Storage</li><li>Memory</li><li>Calldata</li><li>Stack</li></ul><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。</p><p>保存在存储区(Storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p><ul><li>存储中的数据是永久存在的。存储是一个key/value库</li><li>存储中的数据写入区块链，因此会修改状态，这也是存储使用成本高的原因。</li><li>占用一个256位的槽需要消耗20000 gas</li><li>修改一个已经使用的存储槽的值，需要消耗5000 gas</li><li>当清零一个存储槽时，会返还一定数量的gas</li><li>存储按256位的槽位分配，即使没有完全使用一个槽位，也需要支付其开销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct storage myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。</p><p>通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p><ul><li>内存是一个字节数组，槽大小位256位（32字节）</li><li>数据仅在函数执行期间存在，执行完毕后就被销毁</li><li>读或写一个内存槽都会消耗3gas</li><li>为了避免矿工的工作量过大，22个操作之后的单操作成本会上涨</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public view returns (MyStruct memory) &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct memory myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">        return myStruct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Calldata"><a href="#Calldata" class="headerlink" title="Calldata"></a>Calldata</h3><p>Calldata是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，Calldata是外部函数的参数(而不是返回参数)的默认位置。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>堆栈是由EVM (Ethereum虚拟机)维护的非持久性数据。EVM使用堆栈数据位置在执行期间加载变量。堆栈位置最多有1024个级别的限制。</p><p>可以看到，要永久性存储，可以保存在存储区(Storage)。</p><h2 id="数据位置规则"><a href="#数据位置规则" class="headerlink" title="数据位置规则"></a>数据位置规则</h2><h3 id="规则1-–-状态变量"><a href="#规则1-–-状态变量" class="headerlink" title="规则1 – 状态变量"></a>规则1 – 状态变量</h3><p>状态变量总是存储在存储区中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，不能显式地标记状态变量的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   uint storage stateVariable; // 错误  </span><br><span class="line">   uint[] memory stateArray; // 错误  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则2-–-函数参数与返回值"><a href="#规则2-–-函数参数与返回值" class="headerlink" title="规则2 – 函数参数与返回值"></a>规则2 – 函数参数与返回值</h3><p>函数参数包括返回参数都存储在内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line"></span><br><span class="line">   function calculate(uint num1, uint num2) public pure returns (uint result) &#123;</span><br><span class="line">       return num1 + num2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p><h3 id="规则3-–-局部变量"><a href="#规则3-–-局部变量" class="headerlink" title="规则3 – 局部变量"></a>规则3 – 局部变量</h3><p>值类型的局部变量存储在内存中。但是，对于引用类型，需要显式地指定数据位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract Locations &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是状态变量 */  </span><br><span class="line"></span><br><span class="line">  // 存储在storage中  </span><br><span class="line">  bool flag;  </span><br><span class="line">  uint number;  </span><br><span class="line">  address account;  </span><br><span class="line"></span><br><span class="line">  function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">    /* 此处都是局部变量  */  </span><br><span class="line"></span><br><span class="line">    // 值类型</span><br><span class="line">    // 所以它们被存储在内存中</span><br><span class="line">    bool flag2;  </span><br><span class="line">    uint number2;  </span><br><span class="line">    address account2;  </span><br><span class="line"></span><br><span class="line">    // 引用类型，需要显示指定数据位置，此处指定为内存</span><br><span class="line">    uint[] memory localArray;        </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能显式覆盖具有值类型的局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是局部变量  */  </span><br><span class="line">  // 值类型</span><br><span class="line">  bool memory flag2;  // 错误</span><br><span class="line">  uint Storage number2;  // 错误 </span><br><span class="line">  address account2;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则4-–-外部函数的参数"><a href="#规则4-–-外部函数的参数" class="headerlink" title="规则4 – 外部函数的参数"></a>规则4 – 外部函数的参数</h3><p>外部函数的参数(不包括返回参数)存储在Calldata中。</p><h2 id="赋值的数据位置规则"><a href="#赋值的数据位置规则" class="headerlink" title="赋值的数据位置规则"></a>赋值的数据位置规则</h2><h1 id="Solidity数据类型"><a href="#Solidity数据类型" class="headerlink" title="Solidity数据类型"></a>Solidity数据类型</h1><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。</p><p>Solidity中，变量类型有以下几大类：</p><ul><li>值类型</li><li>地址类型</li><li>引用类型</li></ul><p><img src="/2025/03/11/solidity入门/16.png" alt></p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">保留字</th><th style="text-align:left">取值</th></tr></thead><tbody><tr><td style="text-align:left">布尔型</td><td style="text-align:left">bool</td><td style="text-align:left">true/false</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int/uint</td><td style="text-align:left">有符号整数/无符号整数。</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int8 to int256</td><td style="text-align:left">8位到256位的带符号整型数。int256与int相同。</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">uint8 to uint256</td><td style="text-align:left">8位到256位的无符号整型。uint256和uint是一样的。</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">fixed/unfixed</td><td style="text-align:left">有符号和无符号的定长浮点型</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">fixedMxN</td><td style="text-align:left">带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">ufixedMxN</td><td style="text-align:left">无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr></tbody></table><h2 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h2><p>地址类型表示以太坊地址，长度为20字节。地址可以使用<code>.balance</code>方法获得余额，也可以使用<code>.transfer</code>方法将余额转到另一个地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address x = <span class="number">0x212</span>;</span><br><span class="line">address myAddress = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>) </span><br><span class="line">    x.transfer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="引用类型-复合数据类型"><a href="#引用类型-复合数据类型" class="headerlink" title="引用类型/复合数据类型"></a>引用类型/复合数据类型</h2><p>Solidity中，有一些数据类型由值类型组合而成，相比于简单的值类型，这些类型通常通过名称引用，被称为引用类型。</p><p>引用类型包括：</p><ul><li>数组 (字符串与bytes是特殊的数组，所以也是引用类型)</li><li>struct (结构体)</li><li>map (映射)</li></ul><p>“<code>undefined</code>”或“<code>null</code>”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。 要处理任何意外的值，应该使用错误处理来恢复整个交易，或者返回一个带有第二个<code>bool</code> 值的元组表示成功。</p><h2 id="bool-布尔类型"><a href="#bool-布尔类型" class="headerlink" title="bool/布尔类型"></a><strong>bool/布尔类型</strong></h2><p>布尔值的取值范围为 true 和 false 。</p><p>默认值：<code>false</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">  error NotEqual(bool A,bool B);</span><br><span class="line">bool public A; // false</span><br><span class="line">bool public B = true;//true</span><br><span class="line">  // require(A==B,&quot;A not equal B&quot;);</span><br><span class="line"></span><br><span class="line">  if (A != B) &#123;</span><br><span class="line">    error NotEqual(A,B);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符：<br>●!（逻辑非）<br>●&amp;&amp; （逻辑与， “and” ）<br>●|| （逻辑或， “or” ）<br>●== （等于）<br>●!= （不等于）</p><h2 id="int、uint-整数类型"><a href="#int、uint-整数类型" class="headerlink" title="int、uint/整数类型"></a><strong>int、uint/整数类型</strong></h2><blockquote><p><code>int/uint：</code>变长的<strong>有符号</strong>或<strong>无符号</strong>整型。变量支持的步长以<code>8</code>递增，支持从<code>uint8</code>到<code>uint256</code>，以及<code>int8</code>到<code>int256</code>。需要注意的是，<code>uint</code>和<code>int</code>默认代表的是<code>uint256</code>和<code>int256</code>。</p></blockquote><p><code>int</code> 有符号整型(包含负数)</p><p>默认为<code>int256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>int8</code> 取值范围：-(2 <strong> 7)到 2 </strong> 7 -1</li><li><code>int16</code>取值范围：-(2 <strong> 15)到 2 </strong> 15 -1</li><li>…</li><li><code>intX</code>取值范围：-(2<strong><code>X</code>-1)到 2</strong>(<code>X</code>-1) -1</li><li><code>int256</code>取值范围：-(2 <strong> 255)到 2 </strong> 255 -1</li></ul><p><code>uint</code> 无符号整型</p><p>默认为<code>uint256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>uint8</code>取值范围：0 到 2 ** 8 - 1</li><li><code>uint16</code>取值范围：0 到 2 ** 16 - 1</li><li>…</li><li><code>uintX</code>取值范围：0 到 2 ** <code>X</code> - 1</li><li><code>uint256</code>取值范围：0 到 2 ** 256 - 1</li></ul><p>对于整形 X，可以使用 type(X).min 和 type(X).max 去获取这个类型的最小值与最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestIntval &#123;</span><br><span class="line">  int8 public i8 = -1;</span><br><span class="line">    int public i256 = 456;</span><br><span class="line">    int public i = -123; // int 等同于 int256</span><br><span class="line">    // int 的最大最小值</span><br><span class="line">    int public minInt = type(int).min;</span><br><span class="line">    int public maxInt = type(int).max;</span><br><span class="line"></span><br><span class="line">    uint8 public u8 = 1;</span><br><span class="line">    uint256 public u256 = 456;</span><br><span class="line">    uint public u = 123; // uint  等同于 uint256 </span><br><span class="line">// uint 的最大最小值</span><br><span class="line">    uint public minUInt = type(uint).min;</span><br><span class="line">    uint public maxUInt = type(uint).max;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function mini() public pure returns(uint8)&#123;</span><br><span class="line">        return type(uint8).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="address-地址"><a href="#address-地址" class="headerlink" title="address/地址"></a><strong>address/地址</strong></h2><p>默认值: 0x0000000000000000000000000000000000000000</p><p>20字节的16进制地址用来表示一个账户 或者合约地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    //与其他机器语言相区别的类型就是这个address 类型，160-bit/20byte</span><br><span class="line">    address public myAddr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;</span><br><span class="line">    //合约自己的地址</span><br><span class="line">    address contractAddress = address(this);</span><br><span class="line">    //跟普通的地址类型一样，但多了两个方法 transfer/send 这两个方法后面章节会讲到</span><br><span class="line">    // address sender = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line">  //可以使用 balance 属性来查询一个地址的余额</span><br><span class="line">    function getBalance()</span><br><span class="line">        public view</span><br><span class="line">        returns (uint256, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        require(myAddr.balance &lt; contractAddress.balance, &quot;1 must lg 2&quot;);</span><br><span class="line">        return (myAddr.balance, contractAddress.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bytes-字节数组"><a href="#bytes-字节数组" class="headerlink" title="bytes/字节数组"></a><strong>bytes/字节数组</strong></h2><p>在计算机中的最小存储单位是 bit(位)</p><ul><li>1byte等于8位</li><li><p>Solidity中，byte可以赋值为</p></li><li><ul><li>16进制数字</li><li>单引号的单个或多个字符</li></ul></li></ul><p>定长字节数组</p><p>bytes1 后面数字1是表示1字节 bytes默认等于bytes1<br>Bytes2 后面数字2是表示2字节<br>Bytes3 后面数字3是表示3字节<br>bytes4 后面数字4是表示4字节</p><p>…</p><p>bytes32 后面数字32是表示32字节</p><p>bytes32 等价于 int256或uint256 的位数</p><p>成员变量</p><p><code>.length</code> 表示这个字节数组的长度（只读）</p><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string/字符串"></a><strong>string/字符串</strong></h2><ol><li>中文特殊字符需要用<code>unicode</code>编码</li><li>通过concat 方法进行拼接</li><li>bytes 和 string之间转化</li><li><code>string</code>字符串不能通过<code>length</code>方法获取其长度。</li><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code>可以通过这个方法比较两个字符串是否相等。</li><li><code>abi.encodePacked(s1, s2)</code>:通过这个方法进行字符串合并拼接。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    string public str1 = &quot;123&quot;;</span><br><span class="line">    // 中文不适用unicode编码报错</span><br><span class="line">    // string public str2 = =&quot;你好&quot;;</span><br><span class="line">    string public str2 = unicode&quot;abc&quot;;</span><br><span class="line">    function concat() public view returns(string memory) &#123;</span><br><span class="line">        string memory result = string.concat(str1,str2);</span><br><span class="line">        return  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function caoncat2(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        return string.concat(_a,_b);</span><br><span class="line">    &#125;</span><br><span class="line">     function caoncat3(string memory _a, string memory _b) public pure returns(bytes memory) &#123;</span><br><span class="line">          bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return bytes.concat(_ba,_bb);</span><br><span class="line">    &#125;</span><br><span class="line">      function caoncat4(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return string(bytes.concat(_ba,_bb));</span><br><span class="line">    &#125;</span><br><span class="line">     // 比较s1和s2是否相等，相等返回true，不相等返回false</span><br><span class="line">    function compareEqual(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;   </span><br><span class="line">        // 不支持字符直接比较</span><br><span class="line">        return s1 == s2;</span><br><span class="line">        // return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组</span><br><span class="line">    function mergeS1AndS2ReturnBytes(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encodePacked(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组转换为string</span><br><span class="line">    function mergeS1AndS2ReturnString(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return string(abi.encodePacked(s1, s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum(枚举)"></a>Enum(枚举)</h2><p>枚举将一个变量的取值限制为几个预定义值中的一个。精确使用枚举类型有助于减少代码中的bug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ontract UserState &#123;</span><br><span class="line">  // 枚举</span><br><span class="line">  //默认值是列表中的第一个元素</span><br><span class="line">  enum State &#123; </span><br><span class="line">    Online,  // 0</span><br><span class="line">    Offline,// 1</span><br><span class="line">    Unknown// 2</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  State public status;</span><br><span class="line">  function get() public view returns (State) &#123;</span><br><span class="line">      return status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过将uint传递到输入来更新状态</span><br><span class="line">  function set(State _status) public &#123;</span><br><span class="line">      status = _status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 也可以是这样确定属性的更新</span><br><span class="line">  function off() public &#123;</span><br><span class="line">      status = State.Offline;</span><br><span class="line">  &#125;</span><br><span class="line">  // delete 将枚举重置为其第一个值 0</span><br><span class="line">  function reset() public &#123;</span><br><span class="line">      delete status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array-数组"><a href="#array-数组" class="headerlink" title="array/数组"></a><strong>array/数组</strong></h2><blockquote><p>T[k]: 元素类型为T，固定长度为K的数组  uint[5] </p><p>T[]: 元素类型为T, 长度可以动态调整</p></blockquote><h3 id="一、固定长度的数组（Arrays）"><a href="#一、固定长度的数组（Arrays）" class="headerlink" title="一、固定长度的数组（Arrays）"></a>一、固定长度的数组（Arrays）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    // 创建定长数组</span><br><span class="line">    uint256[5] public arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    // 定长数组求和</span><br><span class="line">    function getAll() public view returns (uint256) &#123;</span><br><span class="line">        uint256 num = 0;</span><br><span class="line">        for (uint256 i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            num += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint256[5] memory) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取定长数组长度</span><br><span class="line">    function getLenth() public view returns (uint256) &#123;</span><br><span class="line">        return arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改长度失败</span><br><span class="line">    function changeLenth() public &#123;</span><br><span class="line">        // arr.length = 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改内部数据</span><br><span class="line">    function change(uint256 _idx, uint256 _val) public &#123;</span><br><span class="line">        arr[_idx] = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // push 修改</span><br><span class="line">    // function change(uint256 _val) public &#123;</span><br><span class="line">    //     arr.push(_val);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、可变长度的Arrays"><a href="#二、可变长度的Arrays" class="headerlink" title="二、可变长度的Arrays"></a>二、可变长度的Arrays</h3><p><code>uint [] T = [1,2,3,4,5]</code>，这句代码表示声明了一个可变长度的<code>T</code>数组，因为我们给它初始化了<code>5</code>个无符号整数，所以它的长度默认为<code>5</code>。</p><p><code>&gt;=0.5.0</code>的版本中<code>length</code>方法只读，不可修改。 5版本之前支持length属性修改，缺失的以0补位</p><p><img src="/2025/03/11/solidity入门/17.png" alt="image-20221214150932547"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint [] T = [1,2,3,4,5];</span><br></pre></td></tr></table></figure><h3 id="三、二维数组-数组里面放数组"><a href="#三、二维数组-数组里面放数组" class="headerlink" title="三、二维数组 - 数组里面放数组"></a>三、二维数组 - 数组里面放数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[2][3] T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line"></span><br><span class="line">    function T_len() public view returns (uint256) &#123;</span><br><span class="line">        return T.length; // uint256: 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function getT() public view returns (uint256[2][3] memory) &#123;</span><br><span class="line">        return T;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    function change() public &#123;</span><br><span class="line">        T[1][0] = 55;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uint [2][3] T = [[1,2],[3,4],[5,6]]</code>这是一个三行两列的数组，你会发现和Java、C语言等的其它语言中二位数组里面的列和行之间的顺序刚好相反。在其它语言中，上面的内容应该是这么存储<code>uint [2][3] T = [[1,2,3],[4,5,6]]</code>。</p><p>上面的<code>数组T</code>是<code>storage</code>类型的数组，对于<code>storage</code>类型的数组，数组里面可以存放任意类型的值（比如：其它数组，结构体，字典／映射等等）。对于<code>memory</code>类型的数组，如果它是一个<code>public</code>类型的函数的参数，那么它里面的内容不能是一个<code>mapping(映射／字典)</code>，并且它必须是一个<code>ABI</code>类型。</p><h3 id="四、数组字面量-Array-Literals-内联数组-Inline-Arrays"><a href="#四、数组字面量-Array-Literals-内联数组-Inline-Arrays" class="headerlink" title="四、数组字面量 Array Literals / 内联数组 Inline Arrays"></a>四、数组字面量 Array Literals / 内联数组 Inline Arrays</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    function f() pure public &#123;</span><br><span class="line">        g([1, 2, 3]); </span><br><span class="line">        g([uint(1),2,3])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function g(uint[3] memory _data) pure public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><blockquote><p>通过基本数据类型来组合成自定义复杂的数据类型</p></blockquote><p>语法结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 关键字  结构体名称 &#123;</span><br><span class="line">类型1  属性名1;</span><br><span class="line">类型2  属性名2；</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">uint8 age;</span><br><span class="line">string id;</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建结构变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构体 变量名 = 结构体(属性1，属性2，...)</span><br><span class="line">结构体 变量名 = 结构体(&#123;属性1：value1，属性2：value2Ï&#125;)</span><br><span class="line"></span><br><span class="line">Person student1 = Person(18,1,&quot;柯南&quot;)；</span><br><span class="line">Person student2 = Person(&#123;age:17, id: 2, name: &quot;迪迦Ï&quot;&#125;)</span><br></pre></td></tr></table></figure><p>修改结构体变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setStudent(uint _age, string _name) public &#123;</span><br><span class="line">student1.age = _age</span><br><span class="line">student1.name = _name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中返回结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getStudent() public view returns(Person) &#123;</span><br><span class="line">return student1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract Structs &#123;</span><br><span class="line">    struct Todo &#123;</span><br><span class="line">        string text;</span><br><span class="line">        bool completed;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构体数组</span><br><span class="line">  </span><br><span class="line">    Todo[] public todos;</span><br><span class="line"></span><br><span class="line">    // 初始化结构的3种方法</span><br><span class="line">    function create(string calldata _text) public &#123;</span><br><span class="line">        // 1.像函数一样调用它</span><br><span class="line">        todos.push(Todo(_text, false));</span><br><span class="line">        // 2. 键值对</span><br><span class="line">        todos.push(Todo(&#123;text: _text, completed: false&#125;));</span><br><span class="line">        // 3.初始化一个空结构，然后更新它</span><br><span class="line">        Todo memory todo;</span><br><span class="line">        todo.text = _text;</span><br><span class="line">        todos.push(todo);// completed 没有定义,默认为 false</span><br><span class="line">    &#125;</span><br><span class="line">    //通过索引获取结构体数组中一个元素,并更新内部的属性</span><br><span class="line">    function update(uint _index) public &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        todo.completed = !todo.completed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典／映射（Mappings"><a href="#字典／映射（Mappings" class="headerlink" title="字典／映射（Mappings)"></a>字典／映射（Mappings)</h2><blockquote><p>与数组和结构体一样，映射也是引用类型。</p><p>是一个一对一键值存储关系。</p><p>可以理解成js中的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(<span class="function"><span class="params">_KeyType</span> =&gt;</span> _ValueType)</span><br></pre></td></tr></table></figure><ul><li><code>_KeyType</code> – 可以是任何内置类型，或者bytes和字符串。不允许使用引用类型或复杂对象。</li><li><code>_ValueType</code> – 可以是任何类型。</li></ul><p><strong>注意</strong></p><ul><li>映射的数据位置(data location)只能是storage，通常用于状态变量。</li><li>映射可以标记为public，Solidity 自动为它创建getter。</li><li>mapping 不能直接在函数返回</li></ul><p>创建mapping </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint256 _amount) public &#123;</span><br><span class="line">        balances[msg.sender] = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAmount() public view  returns(uint)&#123;</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract LedgerBalance &#123;</span><br><span class="line">   mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">   function updateBalance(uint newBalance) public &#123;</span><br><span class="line">      balances[msg.sender] = newBalance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Updater &#123;</span><br><span class="line">   function updateBalance() public returns (uint) &#123;</span><br><span class="line">      LedgerBalance ledgerBalance = new LedgerBalance();</span><br><span class="line">      ledgerBalance.updateBalance(10);</span><br><span class="line">      return ledgerBalance.balances(address(this));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    //从地址到uint的映射</span><br><span class="line">    mapping(address =&gt; uint) public myMap;</span><br><span class="line"></span><br><span class="line">    function get(address _addr) public view returns (uint) &#123;</span><br><span class="line">        //映射始终返回一个值。</span><br><span class="line">//如果从未设置该值，它将返回默认值。</span><br><span class="line">        return myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新此地址的值 </span><br><span class="line">    function set(address _addr, uint _i) public &#123;</span><br><span class="line">        myMap[_addr] = _i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove(address _addr) public &#123;</span><br><span class="line">//将值重置为默认值</span><br><span class="line">        delete myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//嵌套 mapping</span><br><span class="line">contract NestedMapping &#123;</span><br><span class="line">    //嵌套映射（从地址映射到另一个映射）</span><br><span class="line">    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;</span><br><span class="line"></span><br><span class="line">    function get(address _addr1, uint _i) public view returns (bool) &#123;</span><br><span class="line">        // 可以从嵌套映射中获取值</span><br><span class="line">        return nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(</span><br><span class="line">        address _addr1,</span><br><span class="line">        uint _i,</span><br><span class="line">        bool _boo</span><br><span class="line">    ) public &#123;</span><br><span class="line">        nested[_addr1][_i] = _boo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除 mapping 的一个元素</span><br><span class="line">    function remove(address _addr1, uint _i) public &#123;</span><br><span class="line">        delete nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solidity运算符"><a href="#Solidity运算符" class="headerlink" title="Solidity运算符"></a>Solidity运算符</h1><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>+ (加)</strong> 求和 <strong>例:</strong> A + B = 30</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>– (减)</strong> 相减 <strong>例:</strong> A – B = -10</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>* (乘)</strong> 相乘 <strong>例:</strong> A * B = 200</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>/ (除)</strong> 相除 <strong>例:</strong> B / A = 2</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>% (取模)</strong> 取模运算 <strong>例:</strong> B % A = 0</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>++ (递增)</strong> 递增 <strong>例:</strong> A++ = 11</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>— (递减)</strong> 递减 <strong>例:</strong> A– = 9</td></tr></tbody></table><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>== (等于)</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>!= (不等于)</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>&gt; (大于)</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>&lt; (小于)</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>&gt;= (大于等于)</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>&lt;= (小于等于)</strong></td></tr></tbody></table><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>&amp;&amp; (逻辑与)</strong> 如果两个操作数都非零，则条件为真。 <strong>例:</strong> (A &amp;&amp; B) 为真</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">**\</td><td>\</td><td>(逻辑或)<strong> 如果这两个操作数中有一个非零，则条件为真。 </strong>例:** (A \</td><td>\</td><td>B) 为真</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>! (逻辑非)</strong> 反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。 <strong>例:</strong> ! (A &amp;&amp; B) 为假</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>&amp; (位与)</strong> 对其整数参数的每个位执行位与操作。 <strong>例:</strong> (A &amp; B) 为 2.</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">**\</td><td>(位或)<strong> 对其整数参数的每个位执行位或操作。 </strong>例:** (A \</td><td>B) 为 3.</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>^ (位异或)</strong> 对其整数参数的每个位执行位异或操作。 <strong>例:</strong> (A ^ B) 为 1.</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>~ (位非)</strong> 一元操作符，反转操作数中的所有位。 <strong>例:</strong> (~B) 为 -4.</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>&lt;&lt; (左移位))</strong> 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由0填充。将一个值向左移动一个位置相当于乘以2，移动两个位置相当于乘以4，以此类推。 <strong>例:</strong> (A &lt;&lt; 1) 为 4.</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>&gt;&gt; (右移位)</strong> 左操作数的值向右移动，移动位置数量由右操作数指定 <strong>例:</strong> (A &gt;&gt; 1) 为 1.</td></tr></tbody></table><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>solidity 支持的赋值运算符，如下表所示：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>= (简单赋值)</strong> 将右侧操作数的值赋给左侧操作数 <strong>例:</strong> C = A + B 表示 A + B 赋给 C</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>+= (相加赋值)</strong> 将右操作数添加到左操作数并将结果赋给左操作数。 <strong>例:</strong> C += A 等价于 C = C + A</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>−= (相减赋值)</strong> 从左操作数减去右操作数并将结果赋给左操作数。 <strong>例:</strong> C -= A 等价于 C = C – A</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>*= (相乘赋值)</strong> 将右操作数与左操作数相乘，并将结果赋给左操作数。 <strong>例:</strong> C <em>= A 等价于 C = C </em> A</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>/= (相除赋值)</strong> 将左操作数与右操作数分开，并将结果分配给左操作数。 <strong>例:</strong> C /= A 等价于 C = C / A</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>%= (取模赋值)</strong> 使用两个操作数取模，并将结果赋给左边的操作数。 <strong>例:</strong> C %= A 等价于 C = C % A</td></tr></tbody></table><blockquote><p><strong>注意</strong> – 同样的逻辑也适用于位运算符，因此它们将变成<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p></blockquote><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>? : (条件运算符 )</strong> 如果条件为真 ? 则取值X : 否则值Y</td></tr></tbody></table><h1 id="Solidity循环语句"><a href="#Solidity循环语句" class="headerlink" title="Solidity循环语句"></a>Solidity循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (表达式) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">        int256 start = 1;</span><br><span class="line">        while (start &lt;= max) &#123;</span><br><span class="line">            start++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>Solidity 中， do…while循环的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125; while (表达式);</span><br><span class="line">注意: 不要漏掉do后面的分号。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract TestBool &#123;</span><br><span class="line">   uint public num  = 10;</span><br><span class="line">   function test () public returns(uint) &#123;</span><br><span class="line">       int  start = 1;</span><br><span class="line">       int  max = 10;</span><br><span class="line">       do&#123;</span><br><span class="line">         start ++;</span><br><span class="line">         num ++;</span><br><span class="line">       &#125;while(start &lt;=max);</span><br><span class="line">       return num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 测试条件; 迭代语句) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         if(start == 1) &#123;</span><br><span class="line">            //  break;  // 跳出循环 num 10</span><br><span class="line">            continue; // 跳出本次循环</span><br><span class="line">        &#125;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solidity条件语句"><a href="#Solidity条件语句" class="headerlink" title="Solidity条件语句"></a>Solidity条件语句</h1><p>Solidity支持条件语句，让程序可以根据条件执行不同的操作。条件语句包括：</p><ul><li><code>if</code></li><li><code>if...else</code></li><li><code>if...else if</code></li></ul><p><img src="/2025/03/11/solidity入门/18.png" alt="image-20221208161811890"></p><h1 id="Solidity中的函数"><a href="#Solidity中的函数" class="headerlink" title="Solidity中的函数"></a>Solidity中的函数</h1><h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><blockquote><p>函数修饰符用于修改函数的行为。例如，向函数添加条件限制。</p><p>修饰符定义中出现特殊符号<code>_</code>的地方，用于插入函数体。如果在调用此函数时，满足了修饰符的条件，则执行该函数，否则将抛出异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    uint256 price = 10;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义修饰符 onlyOwner 不带参数</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用修饰符 onlyOwner 限制只有发布者才能调用</span><br><span class="line">    function changePrice(uint256 _price)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        onlyOwner</span><br><span class="line">        returns (address, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return (owner, _price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图函数（view）"><a href="#视图函数（view）" class="headerlink" title="视图函数（view）"></a>视图函数（view）</h2><blockquote><p>View(视图)函数 使用状态变量，但是不修改状态</p></blockquote><p>如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p><ul><li>修改状态变量。</li><li>触发事件。</li><li>创建合约。</li><li>使用<code>selfdestruct</code>。</li><li>发送以太。</li><li>调用任何不是视图函数或纯函数的函数</li><li>使用底层调用</li><li>使用包含某些操作码的内联程序集。</li></ul><p>Getter方法是默认的视图函数。声明视图函数，可以在函数声明里，添加<code>view</code>关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getResult() public view returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1; // 局部变量</span><br><span class="line">        uint256 b = 2;</span><br><span class="line">        uint256 product = a * b;</span><br><span class="line">        uint256 sum = a + b;</span><br><span class="line">        return (product, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯函数（Pure）"><a href="#纯函数（Pure）" class="headerlink" title="纯函数（Pure）"></a>纯函数（Pure）</h2><blockquote><p>Pure(纯)函数<strong>不读取</strong>或修改状态。</p><p>声明纯函数，可以在函数声明里，添加<code>pure</code>关键字。</p></blockquote><p>如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告</p><ul><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li><li>访问任何区块、交易、msg等特殊变量(msg.sig 与 msg.data 允许读取)。</li><li>调用任何不是纯函数的函数。</li><li>使用包含特定操作码的内联程序集。</li></ul><p>如果发生错误，纯函数可以使用<code>revert()</code>和<code>require()</code>函数来还原潜在的状态更改。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote><p>同一个作用域内，相同函数名可以定义多个函数。这些函数的参数(参数类型或参数数量)必须不一样。仅仅是返回值不一样不被允许。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getSum(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSum(</span><br><span class="line">        uint256 a,</span><br><span class="line">        uint256 b,</span><br><span class="line">        uint256 c</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><blockquote><p>Solidity 提供了常用的加密函数。以下是一些重要函数：</p><ul><li><code>keccak256(bytes memory) returns (bytes32)</code> 计算输入的Keccak-256散列。</li><li><code>sha256(bytes memory) returns (bytes32)</code> 计算输入的SHA-256散列。</li><li><code>ripemd160(bytes memory) returns (bytes20)</code> 计算输入的RIPEMD-160散列。</li><li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>从椭圆曲线签名中恢复与公钥相关的地址，或在出错时返回零。函数参数对应于签名的ECDSA值: r – 签名的前32字节; s: 签名的第二个32字节; v: 签名的最后一个字节。这个方法返回一个地址。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Test &#123;   </span><br><span class="line">   function callKeccak256() public pure returns(bytes32 result)&#123;</span><br><span class="line">      return keccak256(&quot;ABC&quot;);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><h2 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h2><blockquote><p>就像Java、C++中，类的继承一样，Solidity中，合约继承是扩展合约功能的一种方式。Solidity支持单继承和多继承。</p></blockquote><p>Solidity中，合约继承的重要特点：</p><ul><li>派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用<code>this</code>。</li><li>如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。</li><li>可以使用<code>super</code>关键字或父合同名称调用父合同的函数。</li><li>在多重继承的情况下，使用<code>super</code>的父合约函数调用，优先选择被最多继承的合约。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint256 private data;</span><br><span class="line">    uint256 public info;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        info = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increment(uint256 a) private pure returns (uint256) &#123;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateData(uint256 a) public &#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData() public view returns (uint256) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function compute(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is Base &#123;</span><br><span class="line">    uint256 private result;</span><br><span class="line">    Base private base;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        base = new Base();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getComputedResult() public &#123;</span><br><span class="line">        result = compute(3, 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getResult() public view returns (uint256) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>构造函数是使用<code>construct</code>关键字声明的特殊函数，用于初始化合约的状态变量。合约中构造函数是可选的，可以省略。</p></blockquote><p>构造函数有以下重要特性：</p><ul><li>一个合约只能有一个构造函数。</li><li>构造函数在创建合约时执行一次，用于初始化合约状态。</li><li>在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。</li><li>构造函数可以是公共的，也可以是内部的。</li><li>内部构造函数将合约标记为抽象合约。</li><li>如果没有定义构造函数，则使用默认构造函数。</li></ul><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solidity语法基础入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发</title>
    <link href="/2025/03/10/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91/"/>
    <id>/2025/03/10/以太坊钱包开发/</id>
    <published>2025-03-10T08:48:28.000Z</published>
    <updated>2025-03-11T04:12:09.781Z</updated>
    
    <content type="html"><![CDATA[<p>使用vue开发以太坊钱包<br><a id="more"></a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>版本信息:</p><p>Node  16.14</p><p>安装vue-cli </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>验证vue-cli 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vue -V</span><br><span class="line">// 结果 出现vue版本号 安装成功</span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure><p>通过vue-cli创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vue create &lt;项目名称&gt;</span><br><span class="line">// 选择配置</span><br><span class="line">Vue CLI v5.0.8</span><br><span class="line">? Please pick a preset: </span><br><span class="line">  Default ([Vue 3] babel, eslint) </span><br><span class="line">  Default ([Vue 2] babel, eslint) </span><br><span class="line">❯ Manually select features  `选择该项`</span><br></pre></td></tr></table></figure><p>选择自定义配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to </span><br><span class="line">toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line"> ◉ Babel `选择该项`</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◉ Router `选择该项`</span><br><span class="line"> ◯ Vuex</span><br><span class="line">❯◉ CSS Pre-processors `选择该项`</span><br><span class="line"> ◯ Linter / Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure><p>选择vue版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Choose a version of Vue.js that you want to start the project with (Use arrow </span><br><span class="line">keys)</span><br><span class="line">❯ 3.x </span><br><span class="line">  2.x</span><br></pre></td></tr></table></figure><p>选择路由设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router? (Requires proper server setup <span class="keyword">for</span> index fallback </span><br><span class="line"><span class="keyword">in</span> production) (Y/n) y  `输入y或者n`</span><br></pre></td></tr></table></figure><p>选择预处理语言</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported </span><br><span class="line">by default): </span><br><span class="line">  Sass/SCSS (with dart-sass) </span><br><span class="line">❯ Less </span><br><span class="line">  Stylus</span><br></pre></td></tr></table></figure><p>选择配置文件存放目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.? </span><br><span class="line">❯ In dedicated config files </span><br><span class="line">  In package.json</span><br></pre></td></tr></table></figure><p>安装成功后 运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 项目名称</span><br><span class="line">$ npm run serve</span><br></pre></td></tr></table></figure><p>成功界面 </p><p><img src="/2025/03/10/以太坊钱包开发/1.png" alt="image-20230102200435157"></p><h2 id="第三方包安装"><a href="#第三方包安装" class="headerlink" title="第三方包安装"></a>第三方包安装</h2><h3 id="web3相关第三方包"><a href="#web3相关第三方包" class="headerlink" title="web3相关第三方包"></a>web3相关第三方包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet</span><br></pre></td></tr></table></figure><blockquote><p>注： ethereumjs-tx 使用1.3.7 版本</p></blockquote><h3 id="node-polyfill-兼容文件配置"><a href="#node-polyfill-兼容文件配置" class="headerlink" title="node-polyfill 兼容文件配置"></a>node-polyfill 兼容文件配置</h3><ol><li><p>下载polyfill 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-polyfill-webpack-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js 文件中配置插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line">++ <span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">++  configureWebpack: &#123;</span><br><span class="line">++    plugins: [</span><br><span class="line">++      <span class="keyword">new</span> NodePolyfillWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置vant-ui-ui组件库"><a href="#配置vant-ui-ui组件库" class="headerlink" title="配置vant-ui ui组件库"></a>配置vant-ui ui组件库</h3><p><a href="https://vant-contrib.gitee.io/vant/#/zh-CN" target="_blank" rel="noopener">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vant</span><br><span class="line">$ npm i unplugin-vue-components -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在vue.config.js 文件中配置插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">"@vue/cli-service"</span>);</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// vant</span></span><br><span class="line">++ <span class="keyword">const</span> &#123; VantResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>);</span><br><span class="line">++ <span class="keyword">const</span> ComponentsPlugin = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> NodePolyfillWebpackPlugin(),</span><br><span class="line">++    ComponentsPlugin(&#123; <span class="attr">resolvers</span>: [VantResolver()]&#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试 在app.vue文件添加代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line"> &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/2.png" alt="image-20230102202255947"></p><h3 id="通过vw配置响应式"><a href="#通过vw配置响应式" class="headerlink" title="通过vw配置响应式"></a>通过vw配置响应式</h3><p><a href="https://www.cnblogs.com/hongrun/p/16130707.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongrun/p/16130707.html</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在根目录下创建 名为 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">"px"</span>, <span class="comment">// 要转化的单位</span></span><br><span class="line">      viewportWidth: <span class="number">375</span>, <span class="comment">// UI设计稿的宽度</span></span><br><span class="line">      unitPrecision: <span class="number">6</span>, <span class="comment">// 转换后的精度，即小数点位数</span></span><br><span class="line">      propList: [<span class="string">"*"</span>], <span class="comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span></span><br><span class="line">      viewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定需要转换成的视窗单位，默认vw</span></span><br><span class="line">      fontViewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名，</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 默认值1，小于或等于1px则不进行转换</span></span><br><span class="line">      mediaQuery: <span class="literal">true</span>, <span class="comment">// 是否在媒体查询的css代码中也进行转换，默认false</span></span><br><span class="line">      replace: <span class="literal">true</span>, <span class="comment">// 是否转换后直接更换属性值</span></span><br><span class="line">      exclude: [<span class="regexp">/node_modules/</span>], <span class="comment">// 设置忽略文件，用正则做目录名匹配</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="web3连接到以太坊网络（测试网、主网）"><a href="#web3连接到以太坊网络（测试网、主网）" class="headerlink" title="web3连接到以太坊网络（测试网、主网）"></a>web3连接到以太坊网络（测试网、主网）</h1><ol><li>什么是web3<br>web3是以太坊官方开提供的一个连接以太坊区块链的模块，允许您使用HTTP或IPC与本地或远程以太坊节点进行交互，它包含以太坊生态系统的几乎所有功能。web3模块主要连接以太坊暴露出来的RPC层。开发者利用web3连接RPC层，可以连接任何暴露了RPC接口的节点，从而与区块链交互。web3是一个集合库，支持多种开发语言使用wbe3，其中的JavaScript API叫做web3.js、另外还有web3.py、web3j，web3.js将是我们钱包开发项目的重点。</li></ol><p>web3.eth：用于与以太坊区块链和智能合约之间的交互。</p><p>web3.utils：包含一些辅助方法。</p><p>web3.shh：用于协议进行通信的P2P和广播。</p><p>web3.bzz：用于与群网络交互的Bzz模块。</p><p>github地址：<a href="https://github.com/web3/web3.js/tree/v1.0.0-beta.34" target="_blank" rel="noopener">https://github.com/web3/web3.js/tree/v1.0.0-beta.34</a></p><p>web3.js开发文档：<a href="https://web3js.readthedocs.io/en/v1.8.1/" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/v1.8.1/</a></p><p>web3.js 中文文档 : <a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p><ol start="2"><li>实例化web3对象<br>web3要与以坊节点进行交互，需要创建一个web3对象，下面看看如何创建。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="comment">// "Web3.providers.givenProvider" will be set if in an Ethereum supported browser.</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">'ws://some.local-or-remote.node:8546'</span>);</span><br></pre></td></tr></table></figure><p>根据API可知需要指定节点地址，我们将ws://some.local-or-remote.node:8546换成其它连接到以太坊网络的节点的地址，以此来确定连接的以太坊的网络。那么连接到以太坊网络的节点的地址是多少呢？这里我们需要使用到infura。</p><ol start="3"><li>获取连接到以太坊网络的节点地址<br>infura提供公开的 Ethereum主网和测试网络节点，到infura.io网站注册后即可获取各个网络的地址。请按照如下步骤获取地址。</li></ol><p>第一步：打开 infura网站地址：<a href="https://infura.io/dashboard，使用邮箱注册后登陆" target="_blank" rel="noopener">https://infura.io/dashboard，使用邮箱注册后登陆</a></p><p>第二步：点击上图标记的“create new project”按钮创建一个新项目。然后弹出如下弹框，在输入框输入项目名，如”MyEtherWallet“，然后点击“create project”按钮创建。</p><p><img src="/2025/03/10/以太坊钱包开发/3.png" alt></p><p>第三步：然后会显示如下界面，点击下图中的选择框，可以看到提供主网、Kovan测试网络、Ropsten测试网络、GoerLi测试网络的节点地址。</p><p><img src="/2025/03/10/以太坊钱包开发/4.png" alt="image.png"></p><p>第四步：选择GoerLi测试网络，然后复制地址，将获取到类似这样的地址：<a href="https://kovan.infura.io/v3/d93f......cd67，如下。" target="_blank" rel="noopener">https://kovan.infura.io/v3/d93f......cd67，如下。</a></p><p><img src="/2025/03/10/以太坊钱包开发/5.png" alt="image.png"></p><ol start="4"><li>连接到以太坊GoerLi测试网络<br>现在将复制的地址替换掉实例化web对象的地址，如下</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>)</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">'wss://goerli.infura.io/ws/v3/cb7e63cf28244e4499b4b6fb6162e746'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Web3:"</span>, web3)</span><br></pre></td></tr></table></figure><p>连接到以太坊主网与GoerLi测试网络一样的，只需复制主网节点的地址去实例化web3即可。由于在主网上交易需要花费gas，因此我们基于GoerLi测试网络进行开发，后续开发完成后可再切换到主网。</p><p><img src="/2025/03/10/以太坊钱包开发/6.png" alt="image-20230102215334761"></p><h1 id="Web3js-高频-Api"><a href="#Web3js-高频-Api" class="headerlink" title="Web3js 高频 Api"></a>Web3js 高频 Api</h1><h2 id="账号创建"><a href="#账号创建" class="headerlink" title="账号创建"></a>账号创建</h2><ol><li>创建账号需要使用web3.js的如下API</li></ol><p>API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create([entropy]);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/7.png" alt="image.png"><br>参数：</p><p>entropy - String (可选): 它是一个可选项，是一个随机字符串，将作为解锁账号的密码。如果没有传递字符串，则使用random生成随机字符串。</p><p>返回值：</p><p>Object：包含以下字段的一个帐户对象：</p><p>address- string：帐户地址。</p><p>privateKey- string：帐户私钥。前端永远不应该在localstorage中以未加密的方式共享或存储！</p><p>signTransaction(tx [, callback])- Function：签名交易的方法。</p><p>sign(data)- Function：签名二进制交易的方法。</p><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br><span class="line">&#123;</span><br><span class="line">address: <span class="string">"0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4"</span>,</span><br><span class="line">privateKey: <span class="string">"0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098"</span>,</span><br><span class="line">signTransaction: <span class="function"><span class="keyword">function</span>(<span class="params">tx</span>)</span>&#123;...&#125;,</span><br><span class="line">sign: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;,</span><br><span class="line">encrypt: <span class="function"><span class="keyword">function</span>(<span class="params">password</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>获取地址<br>使用API<code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>addreds</code>属性，即账户的私钥。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account = web3.eth.accounts.create(<span class="string">"123456"</span>)</span><br><span class="line"><span class="keyword">let</span> address = account.address</span><br><span class="line"><span class="comment">//address：0xfF0B5A0AA68249cD161b606679DB49CBD9a12cd0</span></span><br></pre></td></tr></table></figure><p>3.获取私钥</p><p>使用API<code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>privateKey</code>属性，即账户的私钥。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account = web3.eth.accounts.create()</span><br><span class="line"><span class="keyword">let</span> privateKey = account.privateKey</span><br><span class="line"><span class="comment">//privateKey:0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709</span></span><br></pre></td></tr></table></figure><h2 id="余额获取"><a href="#余额获取" class="headerlink" title="余额获取"></a>余额获取</h2><p>根据地址获取以wei为单位余额</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getBalance(address).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a>单位转换</h2><ol><li>Eth 转为 wei</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Web3 或者实例后的web3对象都可以</span><br><span class="line"><span class="keyword">const</span> num = Web3.utils.toWei(<span class="string">"0.3"</span>);</span><br><span class="line"><span class="keyword">const</span> num = web3.utils.toWei(<span class="string">"0.3"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"><span class="comment">// 300000000000000000</span></span><br></pre></td></tr></table></figure><ol start="2"><li>wei 转为Eth</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Web3 或者实例后的web3对象都可以</span><br><span class="line"> <span class="keyword">this</span>.balance = Web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br><span class="line"> <span class="keyword">this</span>.balance = web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br></pre></td></tr></table></figure><h2 id="Eth转账"><a href="#Eth转账" class="headerlink" title="Eth转账"></a>Eth转账</h2><p><strong>API</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendSignedTransaction(signedTransactionData [, callback])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p><code>signedTransactionData</code>-<code>String</code>：以HEX格式签名的交易数据。</p><p>交易数据对象可以包含如下字段：</p><ul><li><code>from</code>- <code>String|Number</code>：发送帐户的地址。如果未指定，则使用web3.eth.defaultAccount属性。或web3.eth.accounts.wallet中本地钱包的地址。</li><li><code>to</code>- <code>String</code>:(可选）消息的目标地址，若未定义则为合同发送消息。</li><li><code>value</code>- <code>Number|String|BN|BigNumber</code>:(可选）为wei中的交易转移的数量，如果是合约发送消息，则是捐赠给合约地址。</li><li><code>gas</code> - <code>Number</code>:(可选，默认：待定）用于交易的gas（未使用的gas会退还）。</li><li><code>gasPrice</code>- <code>Number|String|BN|BigNumber</code>:(可选）此交易的gas价格，以wei为单位，默认为<a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#eth-gasprice" target="_blank" rel="noopener">web3.eth.gasPrice</a>。</li><li><code>data</code>- <code>String</code>:(可选）包含合同上函数调用数据的<a href="http://solidity.readthedocs.io/en/latest/abi-spec.html" target="_blank" rel="noopener">ABI字节字符串</a>。</li><li><code>nonce</code>- <code>Number</code>:(可选）随机数的整数。</li></ul></li><li><p><code>callback</code>-<code>Function</code>：（可选）可选回调，将错误对象作为第一个参数返回，结果作为第二个参数返回。</p></li></ul><p><strong>返回</strong></p><p><code>PromiEvent</code>：promise组合的事件，将在交易完成时调用。包含以下事件</p><ul><li><code>&quot;transactionHash&quot;</code>返回<code>String</code>：在发送事务并且事务哈希可用之后立即触发。</li><li><code>&quot;receipt&quot;</code>返回<code>Object</code>：在交易确认时触发。</li><li><code>&quot;confirmation&quot;</code>返回<code>Number</code>，<code>Object</code>：每次确认都会被调用，直到第12次确认。接收确认编号作为第一个参数，将数据作为第二个参数。</li><li><code>&quot;error&quot;</code>返回<code>Error</code>：如果在发送过程中发生错误，则会触发。</li></ul><ol><li><p>构建转账参数</p><p>区块链转账和支付宝转账类似，需要 <code>发送方</code> 、<code>接收方</code>、<code>金额</code>、<code>密码</code></p><p>另外需要添加部分区块链参数：<code>矿工费gas</code>、<code>地址转账交易次数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取账户交易次数</span></span><br><span class="line"> <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromaddress);</span><br><span class="line"> <span class="comment">// 获取预计转账gas费</span></span><br><span class="line"> <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line"> <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line"> <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.utils.toWei(number);</span><br><span class="line"> <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">   <span class="keyword">from</span>: fromaddress,</span><br><span class="line">   nonce: nonce,</span><br><span class="line">   gasPrice: gasPrice,</span><br><span class="line">   to: toaddress,</span><br><span class="line">   value: balance,</span><br><span class="line">   data: <span class="string">"0x00"</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过转账参数计算最终gas费用，并将通过私钥将转账参数进行编码加密</p><blockquote><p>ethereumjs-tx 第三方库请选择1.3.7版本</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tx <span class="keyword">from</span> <span class="string">"ethereumjs-tx"</span>;  </span><br><span class="line"><span class="comment">// 将私钥去除“ox”后进行hex转化</span></span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(privatekey.slice(<span class="number">2</span>), <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">      <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">      rawTx.gas = gas;</span><br><span class="line">     <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>sendSignedTransaction</code> api发送转账交易，并且获取交易id</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web3.eth</span><br><span class="line">  .sendSignedTransaction(<span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>))</span><br><span class="line">  .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;)</span></span><br><span class="line">  <span class="comment">// .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;)</span></span><br><span class="line">  .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>区块链浏览器或者目标钱包产看转账结果</p><p>goerli区块链浏览器 <a href="https://goerli.etherscan.io/tx/交易id" target="_blank" rel="noopener">https://goerli.etherscan.io/tx/交易id</a></p></li></ol><h1 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在前面的教程中我们对以太坊钱包已经有了一定的认识，上一章也重点介绍了账号地址的生成过程，在以太坊钱包中一个重点就是账户系统，在这个模块中很多初学同学不是很清楚密码、keystore、助记词与私钥它们之间的关系。下面我们来看看它们之间到底有着怎样的爱恨情仇，让大家琢磨不透。</p></blockquote><p><code>密码</code></p><p>密码不是私钥，它是在创建账户时候的密码（可以修改）</p><p>密码在以下情况下会使用到：</p><ol><li>作为转账的支付密码</li><li>用keystore导入钱包的时候需要输入的密码，用来解锁keystore的</li></ol><p><code>私钥 Private Key</code></p><p>私钥由64位长度的十六进制的字符组成，比如：<code>0xA4356E49C88C8B7AB370AF7D5C0C54F0261AAA006F6BDE09CD4745CF54E0115A</code>，一个账户只有一个私钥且不能修改。<br>通常一个钱包中私钥和公钥是成对出现的，有了私钥，我们就可以通过一定的算法生成公钥，再通过公钥经过一定的算法生成地址，这一过程都是不可逆的。私钥一定要妥善保管，若被泄漏别人可以通过私钥解锁账号转出你的该账号的数字货币。</p><p><code>公钥 Public Key</code></p><p>公钥(Public Key)是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</p><p><code>Keystore</code></p><p>Keystore常见于以太坊钱包，它是将私钥以加密的方式保存为一份 JSON 文件，这份 JSON 文件就是 keystore，所以它就是加密后的私钥。Keystore必须配合钱包密码才能导入并使用该账号。当黑客盗取 Keystore 后，在没有密码情况下, 有可能通过暴力破解 Keystore 密码解开 Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。</p><p><code>助记词 Mnemonic</code></p><p>私钥是64位长度的十六进制的字符，不利于记录且容易记错，所以用算法将一串随机数转化为了一串12 ~ 24个容易记住的单词，方便保存记录。注意：</p><ol><li>助记词是私钥的另一种表现形式</li><li>助记词=私钥，这是不正确的说法，通过助记词可以获取相关联的多个私钥，但是通过其中一个私钥是不能获取助记词的，因此<strong>助记词≠私钥</strong>。</li></ol><p>BIP</p><p>要弄清楚助记词与私钥的关系，得清楚BIP协议，是<code>Bitcoin Improvement Proposals</code>的缩写，意思是Bitcoin 的改进建议，用于提出 Bitcoin 的新功能或改进措施。BIP协议衍生了很多的版本，主要有BIP32、BIP39、BIP44。</p><p><strong>BIP32</strong></p><p>BIP32是 HD钱包的核心提案，通过种子来生成主私钥，然后派生海量的子私钥和地址，种子是一串很长的随机数。</p><p><strong>BIP39</strong></p><p>由于种子是一串很长的随机数，不利于记录，所以我们用算法将种子转化为一串12 ~ 24个的单词，方便保存记录，这就是BIP39，它扩展了 HD钱包种子的生成算法。</p><p><strong>BIP44</strong></p><p>BIP44 是在 BIP32 和 BIP43 的基础上增加多币种，提出的层次结构非常全面，它允许处理多个币种，多个帐户，每个帐户有数百万个地址。</p><p>在BIP32路径中定义以下5个级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m/purpse&apos;/coin_type&apos;/account&apos;/change/address_index</span><br></pre></td></tr></table></figure><ul><li>purpose：在BIP43之后建议将常数设置为44’。表示根据BIP44规范使用该节点的子树。</li><li>Coin_type：币种，代表一个主节点（种子）可用于无限数量的独立加密币，如比特币，Litecoin或Namecoin。此级别为每个加密币创建一个单独的子树，避免重用已经在其它链上存在的地址。开发人员可以为他们的项目注册未使用的号码。</li><li>Account：账户，此级别为了设置独立的用户身份可以将所有币种放在一个的帐户中，从0开始按顺序递增。</li><li>Change：常量0用于外部链，常量1用于内部链，外部链用于钱包在外部用于接收和付款。内部链用于在钱包外部不可见的地址，如返回交易变更。</li><li>Address_index：地址索引，按顺序递增的方式从索引0开始编号。</li></ul><p>BIP44的规则使得 HD钱包非常强大，用户只需要保存一个种子，就能控制所有币种，所有账户的钱包，因此由BIP39 生成的助记词非常重要，所以一定安全妥善保管，那么会不会被破解呢？如果一个 HD 钱包助记词是 12 个单词，一共有 2048 个单词可能性，那么随机的生成的助记词所有可能性大概是<code>5e+39</code>，因此几乎不可能被破解。</p><p><code>HD钱包</code></p><p>通过BIP协议生成账号的钱包叫做HD钱包。这个HD钱包，并不是Hardware Wallet硬件钱包，这里的 HD 是<code>Hierarchical Deterministic</code>的缩写，意思是分层确定性，所以HD钱包的全称为比特币分成确定性钱包 。</p><h2 id="密码、私钥、keystore与助记词的关系"><a href="#密码、私钥、keystore与助记词的关系" class="headerlink" title="密码、私钥、keystore与助记词的关系"></a>密码、私钥、keystore与助记词的关系</h2><p><img src="/2025/03/10/以太坊钱包开发/8.png" alt="img"></p><h2 id="钱包的核心：私钥"><a href="#钱包的核心：私钥" class="headerlink" title="钱包的核心：私钥"></a>钱包的核心：私钥</h2><p>基于以上的分析，我们对以太坊钱包的账号系统有了一个很好的认识，那么我们在使用钱包的过程中，该如何保管自己的钱包呢？主要包含以下几种方式：</p><ul><li>私钥（Private Key）</li><li>Keystore+密码（Keystore+Password）</li><li>助记词（Mnemonic code）</li></ul><p>通过以上三种中的一种方式都可以解锁账号，然后掌控它，所以对于每种方式中的数据都必须妥善包括，如有泄漏，请尽快转移数字资产。</p><p>我们可以得到以下总结：</p><ul><li>通过私钥+密码可以生成keystore，即加密私钥；</li><li>通过keystore+密码可以获取私钥，即解密keystore。</li><li>通过助记词根据不同的路径获取不同的私钥，即使用HD钱包将助记词转化成种子来生成主私钥，然后派生海量的子私钥和地址。</li></ul><p>可以看出这几种方式的核心其实都是为了获得私钥，然后去解锁账号，因此钱包的核心功能是私钥的创建、存储和使用。</p><p><strong>参考资料</strong></p><p><a href="https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a><br><a href="https://github.com/ethereum/EIPs/issues/84" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/84</a><br><a href="https://github.com/ethereum/EIPs/issues/85" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/85</a></p><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><blockquote><p>从无到有创建一个新的账户</p></blockquote><h3 id="web3-直接创建账户"><a href="#web3-直接创建账户" class="headerlink" title="web3 直接创建账户"></a>web3 直接创建账户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br></pre></td></tr></table></figure><h3 id="助记词-创建账户"><a href="#助记词-创建账户" class="headerlink" title="助记词 创建账户"></a>助记词 创建账户</h3><p>需要使用<code>bip39</code>协议将助记词转换成种子，再通过<code>ethereumjs-wallet</code>库生成hd钱包，根据路径的不同从hd钱包中获取不同的keypair，keypair中就包含有公钥、私钥，再通过<code>ethereumjs-util</code>库将公钥生成地址，从而根据助记词获取所有关联的账号，能获取到公钥、私钥、地址等数据信息。</p><h4 id="1-依赖库"><a href="#1-依赖库" class="headerlink" title="1. 依赖库"></a>1. 依赖库</h4><p>需要用到三个库：bip39、ethereumjs-wallet/hdkey、ethereumjs-util。先安装依赖库，<code>cd</code>到项目跟路径运行命令<code>npm i bip39 ethereumjs-wallet ethereumjs-util</code>。</p><ul><li><a href="https://github.com/bitcoinjs/bip39" target="_blank" rel="noopener">bip39</a>：随机产生新的 mnemonic code，并可以将其转成 binary 的 seed。</li><li><a href="https://github.com/ethereumjs/ethereumjs-wallet" target="_blank" rel="noopener">ethereumjs-wallet</a>：生成和管理公私钥，下面使用其中 hdkey 子套件来创建 HD 钱包。</li><li><a href="https://github.com/ethereumjs/ethereumjs-util" target="_blank" rel="noopener">ethereumjs-util</a>：Ethereum 的一个工具库。</li><li><a href="https://iancoleman.io/bip39/" target="_blank" rel="noopener">https://iancoleman.io/bip39/</a></li></ul><h4 id="2-通过助记词创建账号"><a href="#2-通过助记词创建账号" class="headerlink" title="2. 通过助记词创建账号"></a>2. 通过助记词创建账号</h4><ul><li><p>创建助记词</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入bip39模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bip39 <span class="keyword">from</span> <span class="string">"bip39"</span>;</span><br><span class="line"><span class="comment">// 创建助记词 </span></span><br><span class="line"><span class="keyword">let</span> mnemonic = bip39.generateMnemonic();</span><br><span class="line"><span class="built_in">console</span>.log(mnemonic);</span><br><span class="line"><span class="comment">// 结果 12位助记词</span></span><br><span class="line"><span class="comment">// vote select solar shy embrace immense lizard stamp scrub vague negative forward</span></span><br></pre></td></tr></table></figure></li><li><p>根据助记词生成密钥对 keypair</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 导入分层钱包模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; hdkey &#125; <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;</span><br><span class="line">      <span class="comment">//1.将助记词转成seed</span></span><br><span class="line">      <span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.mnemonicToSeed(<span class="string">"12位助记词"</span>);</span><br><span class="line">      <span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line">      <span class="keyword">let</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">      <span class="comment">//4.生成钱包中在m/44'/60'/0'/0/i路径的keypair</span></span><br><span class="line">      <span class="keyword">let</span> keypair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(keypair);</span><br></pre></td></tr></table></figure><p>keypair 密钥对</p><p><img src="/2025/03/10/以太坊钱包开发/9.png" alt="image-20221208222354836"></p><h4 id="3-由keypair-获取钱包地址和私钥"><a href="#3-由keypair-获取钱包地址和私钥" class="headerlink" title="3. 由keypair 获取钱包地址和私钥"></a>3. 由keypair 获取钱包地址和私钥</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.getWallet();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"lowerCaseAddress"</span>, lowerCaseAddress);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"CheckSumAddress"</span>, CheckSumAddress);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"prikey"</span>, prikey);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lowerCaseAddress 0xd9fc0fd4412616c7075e68b151ab3a7bcb9a3f54</span></span><br><span class="line"><span class="comment">CheckSumAddress 0xd9fC0FD4412616c7075E68b151ab3A7bcB9A3f54</span></span><br><span class="line"><span class="comment">prikey 3fc11495517f1f015bbcb6c311da66e3b26b23e4c91c1285ccc4b69d9d274002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="导出账户"><a href="#导出账户" class="headerlink" title="导出账户"></a>导出账户</h2><blockquote><p>一个已经存在的账户导出 私钥 和 keystore</p></blockquote><ol><li>通过分层钱包对象 + 密码 创建keystore</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(data.pass1); <span class="comment">// 参数必须为 字符串</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过私钥和密码创建 keystore </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keystore = <span class="keyword">await</span> web3.eth.accounts.encrypt(<span class="string">"账户私钥"</span>,<span class="string">"密码"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟keystore数据</span></span><br><span class="line"><span class="keyword">const</span> keystoreJsonV3 = &#123;</span><br><span class="line">        version: <span class="number">3</span>,</span><br><span class="line">        id: <span class="string">"dbb70fb2-52ad-4e1f-9c19-0b50329f89c3"</span>,</span><br><span class="line">        address: <span class="string">"445b469888528dacd9b87246c5ce70407adaa411"</span>,</span><br><span class="line">        crypto: &#123;</span><br><span class="line">          ciphertext:</span><br><span class="line">            <span class="string">"1e53e7e775644422600188b8134907992db40d278064ea3a966da4dcdf80db64"</span>,</span><br><span class="line">          cipherparams: &#123; <span class="attr">iv</span>: <span class="string">"f9d2b047019674eee449b316f4a21491"</span> &#125;,</span><br><span class="line">          cipher: <span class="string">"aes-128-ctr"</span>,</span><br><span class="line">          kdf: <span class="string">"scrypt"</span>,</span><br><span class="line">          kdfparams: &#123;</span><br><span class="line">            dklen: <span class="number">32</span>,</span><br><span class="line">            salt: <span class="string">"153e074d78d0ba36fae3e46e582c42e53f61653cb5d4f1a3a3f68094e6ca0160"</span>,</span><br><span class="line">            n: <span class="number">8192</span>,</span><br><span class="line">            r: <span class="number">8</span>,</span><br><span class="line">            p: <span class="number">1</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          mac: <span class="string">"e91456c59b2505c16b80c2495ab7b4633273c2ae366cb6953f27de8cfebad629"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"> <span class="keyword">const</span> res = web3.eth.accounts.decrypt(keystoreJsonV3, <span class="string">"1235"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过keystore解密私钥</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br></pre></td></tr></table></figure><h2 id="导入账户"><a href="#导入账户" class="headerlink" title="导入账户"></a>导入账户</h2><blockquote><p>通过 私钥、助记词、keystore 导入一个已经存在的钱包账户 地址 和 私钥</p></blockquote><ol><li>通过keystore获取 私钥和地址 </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line"><span class="keyword">let</span> address = wallet.getAddressString()</span><br></pre></td></tr></table></figure><ol start="2"><li>通过助记词 获取地址和私钥</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mnemonic=prompt(<span class="string">"请输入助记词"</span>)</span><br><span class="line"><span class="keyword">let</span> seed = bip39.mnemonicToSeed(mnemonic)</span><br><span class="line"><span class="keyword">let</span> hdwallet = hdkey.fromMasterSeed(seed)</span><br><span class="line"><span class="keyword">let</span> keypair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.getWallet();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>通过私钥获取 地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;     </span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> Buffer( prompt(<span class="string">"请输入私钥"</span>), <span class="string">'hex'</span> )</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.fromPrivateKey(privatekey)</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br></pre></td></tr></table></figure></li></ol><h1 id="区块链钱包项目流程"><a href="#区块链钱包项目流程" class="headerlink" title="区块链钱包项目流程"></a>区块链钱包项目流程</h1><p><img src="/2025/03/10/以太坊钱包开发/10.png" alt="image-20221209110335777"></p><h3 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1.项目准备"></a>1.项目准备</h3><p>​         直接采用随堂demo创建的项目 不需要重新创建</p><h4 id="web3相关第三方包-1"><a href="#web3相关第三方包-1" class="headerlink" title="web3相关第三方包"></a>web3相关第三方包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet</span><br></pre></td></tr></table></figure><blockquote><p>注： ethereumjs-tx 使用1.3.7 版本</p></blockquote><h4 id="node-polyfill-兼容文件配置-1"><a href="#node-polyfill-兼容文件配置-1" class="headerlink" title="node-polyfill 兼容文件配置"></a>node-polyfill 兼容文件配置</h4><ol><li><p>下载polyfill 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-polyfill-webpack-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js 文件中配置插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line">++ <span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">++  configureWebpack: &#123;</span><br><span class="line">++    plugins: [</span><br><span class="line">++      <span class="keyword">new</span> NodePolyfillWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置vant-ui-ui组件库-1"><a href="#配置vant-ui-ui组件库-1" class="headerlink" title="配置vant-ui ui组件库"></a>配置vant-ui ui组件库</h4><p><a href="https://vant-contrib.gitee.io/vant/#/zh-CN" target="_blank" rel="noopener">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vant</span><br><span class="line">$ npm i unplugin-vue-components -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在vue.config.js 文件中配置插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">"@vue/cli-service"</span>);</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// vant</span></span><br><span class="line">++ <span class="keyword">const</span> &#123; VantResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>);</span><br><span class="line">++ <span class="keyword">const</span> ComponentsPlugin = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> NodePolyfillWebpackPlugin(),</span><br><span class="line">++    ComponentsPlugin(&#123; <span class="attr">resolvers</span>: [VantResolver()]&#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试 在app.vue文件添加代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line"> &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/11.png" alt="image-20230102202255947"></p><h4 id="通过vw配置响应式-1"><a href="#通过vw配置响应式-1" class="headerlink" title="通过vw配置响应式"></a>通过vw配置响应式</h4><p><a href="https://www.cnblogs.com/hongrun/p/16130707.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongrun/p/16130707.html</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在根目录下创建 名为 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">"px"</span>, <span class="comment">// 要转化的单位</span></span><br><span class="line">      viewportWidth: <span class="number">375</span>, <span class="comment">// UI设计稿的宽度</span></span><br><span class="line">      unitPrecision: <span class="number">6</span>, <span class="comment">// 转换后的精度，即小数点位数</span></span><br><span class="line">      propList: [<span class="string">"*"</span>], <span class="comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span></span><br><span class="line">      viewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定需要转换成的视窗单位，默认vw</span></span><br><span class="line">      fontViewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名，</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 默认值1，小于或等于1px则不进行转换</span></span><br><span class="line">      mediaQuery: <span class="literal">true</span>, <span class="comment">// 是否在媒体查询的css代码中也进行转换，默认false</span></span><br><span class="line">      replace: <span class="literal">true</span>, <span class="comment">// 是否转换后直接更换属性值</span></span><br><span class="line">      exclude: [<span class="regexp">/node_modules/</span>], <span class="comment">// 设置忽略文件，用正则做目录名匹配</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="封装缓存函数"><a href="#封装缓存函数" class="headerlink" title="封装缓存函数"></a>封装缓存函数</h4><p>整个项目为了保证钱包的安全性，所有账户相关的操作，不经过中心化服务器，只在缓存使用</p><p>在这里可以参考<code>webstorage</code>增加过期时间，cookie 等的封装</p><p>创建 src/utils/storage.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  setItem(key, val) &#123;</span><br><span class="line">    localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(val || <span class="string">""</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  getItem(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> val;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      val = <span class="built_in">JSON</span>.parse(localStorage.getItem(key));</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      val = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Storage();</span><br></pre></td></tr></table></figure><h4 id="app-vue-文件引入"><a href="#app-vue-文件引入" class="headerlink" title="app.vue 文件引入"></a>app.vue 文件引入</h4><p>在app.vue 引入文件并且初始化web3.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">   &lt;h3&gt; qf - eth -wallet&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// import * as util from &quot;ethereumjs-util&quot;;</span><br><span class="line">import ethwallet from &quot;ethereumjs-wallet&quot;;  </span><br><span class="line">import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import * as bip39 from &quot;bip39&quot;;</span><br><span class="line">import Tx from &quot;ethereumjs-tx&quot;;</span><br><span class="line">import Web3 from &quot;web3&quot;;</span><br><span class="line">import storage from &quot;@/utils/storage&quot;;</span><br><span class="line">var web3 = new Web3(</span><br><span class="line">  Web3.givenProvider ||</span><br><span class="line">    &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-通过Mnemonic助记词创建钱包"><a href="#2-通过Mnemonic助记词创建钱包" class="headerlink" title="2.通过Mnemonic助记词创建钱包"></a>2.通过Mnemonic助记词创建钱包</h3><blockquote><p> 判断缓存是否有 钱包对象</p><ol><li>有钱包对象显示钱包信息  地址 私钥  余额</li><li>没有钱包对象显示创建钱包按钮</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;qf - eth -wallet&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;创建钱包&lt;/h4&gt;</span><br><span class="line">    &lt;van-button type=&quot;primary&quot; @click=&quot;createWallet&quot;&gt; 创建钱包 &lt;/van-button&gt;</span><br><span class="line">    &lt;van-button type=&quot;primary&quot; @click=&quot;importWallet&quot;&gt;</span><br><span class="line">      导入钱包-助记词</span><br><span class="line">    &lt;/van-button&gt;</span><br><span class="line">    &lt;h4&gt;钱包信息&lt;/h4&gt;</span><br><span class="line">    &#123;&#123; wallet &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">// import * as util from &quot;ethereumjs-util&quot;;</span><br><span class="line">import ethwallet from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import * as bip39 from &quot;bip39&quot;;</span><br><span class="line">import Tx from &quot;ethereumjs-tx&quot;;</span><br><span class="line">import storage from &quot;@/utils/storage&quot;;</span><br><span class="line">import Web3 from &quot;web3&quot;;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;;</span><br><span class="line">var web3 = new Web3(</span><br><span class="line">  Web3.givenProvider ||</span><br><span class="line">    &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;</span><br><span class="line">);</span><br><span class="line">const wallet = reactive(storage.getItem(&quot;wallet&quot;) || &#123;&#125;);</span><br><span class="line">console.log(wallet);</span><br><span class="line">async function createWallet() &#123;</span><br><span class="line">  const pass = prompt(&quot;请输入您的钱包密码&quot;);</span><br><span class="line">  if (!pass) return false;</span><br><span class="line">  let mnemonic = bip39.generateMnemonic();</span><br><span class="line">  alert(&quot;您的助记词为:&quot; + mnemonic);</span><br><span class="line">  const checkMnemonic = prompt(&quot;请输入您的助记词&quot;);</span><br><span class="line">  if (mnemonic === checkMnemonic) &#123;</span><br><span class="line">    //1.将助记词转成seed</span><br><span class="line">    let seed = await bip39.mnemonicToSeed(mnemonic);</span><br><span class="line">    //3.通过hdkey将seed生成HD Wallet</span><br><span class="line">    let hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">    //4.生成钱包中在m/44&apos;/60&apos;/0&apos;/0/i路径的keypair</span><br><span class="line">    let keyPair = hdWallet.derivePath(&quot;m/44&apos;/60&apos;/0&apos;/0/0&quot;);</span><br><span class="line">    // 获取钱包对象</span><br><span class="line">    let wallet = keyPair.getWallet();</span><br><span class="line">    // 获取钱包地址</span><br><span class="line">    let lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">    // 获取钱包校验地址</span><br><span class="line">    let CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line">    // 获取私钥</span><br><span class="line">    let prikey = wallet.getPrivateKey().toString(&quot;hex&quot;);</span><br><span class="line">    let keystore = await wallet.toV3(pass);</span><br><span class="line">    console.log(keystore);</span><br><span class="line">    // 保存钱包信息</span><br><span class="line">    const walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: 0,</span><br><span class="line">      mnemonic, // 助记词不应该记录下来仅仅是为了便于演示</span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(&quot;wallet&quot;, walletInfo);</span><br><span class="line">    wallet = walletInfo;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(&quot;助记词错误请重新输入&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-显示余额"><a href="#3-显示余额" class="headerlink" title="3.显示余额"></a>3.显示余额</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balance = ref(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取余额</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!wallet.address) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 根据地址查询余额</span></span><br><span class="line">  web3.eth.getBalance(wallet.address).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    balance.value = web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">getBalance()</span><br></pre></td></tr></table></figure><h3 id="4-转账交易"><a href="#4-转账交易" class="headerlink" title="4.转账交易"></a>4.转账交易</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 获取用户输入金额 与 地址 </span><br><span class="line"><span class="number">2.</span> 调用send 方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keystore = storage.getItem(<span class="string">"wallet"</span>).keystore;</span><br><span class="line">  <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">  <span class="keyword">let</span> walletobj;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    walletobj = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    alert(<span class="string">"密码错误"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> key = walletobj.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">  <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">  <span class="comment">// console.log(privateKey);</span></span><br><span class="line">  <span class="keyword">const</span> fromaddress = wallet.address;</span><br><span class="line">  <span class="comment">// 获取账户交易次数</span></span><br><span class="line">  <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromaddress);</span><br><span class="line">  <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">  <span class="built_in">console</span>.log(number.value, <span class="keyword">typeof</span> number.value);</span><br><span class="line">  <span class="keyword">let</span> balance = Web3.utils.toWei(number.value);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">  <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">    <span class="keyword">from</span>: fromaddress,</span><br><span class="line">    nonce: nonce,</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">    to: toaddress.value,</span><br><span class="line">    value: balance,</span><br><span class="line">    data: <span class="string">"0x00"</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">  <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">  rawTx.gas = gas;</span><br><span class="line">  <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">  <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">  tx.sign(privateKey);</span><br><span class="line">  <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line"></span><br><span class="line">  web3.eth</span><br><span class="line">    .sendSignedTransaction(<span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>))</span><br><span class="line">    .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;)</span></span><br><span class="line">    <span class="comment">// .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;)</span></span><br><span class="line">    .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-导出账户信息"><a href="#5-导出账户信息" class="headerlink" title="5.导出账户信息"></a>5.导出账户信息</h3><ul><li>导出私钥</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">exportKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> walletObj;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        walletObj = <span class="keyword">await</span> ethwallet.fromV3(wallet.keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = walletObj.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">   alert(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导出keystore </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缓存对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exportKeyStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">JSON</span>.stringify(wallet.keystore))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-解锁账户信息"><a href="#6-解锁账户信息" class="headerlink" title="6.解锁账户信息"></a>6.解锁账户信息</h3><ul><li><p>助记词解锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">添加助记词导入钱包方法</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">importWallet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mnemonic = prompt(<span class="string">"请输入助记词"</span>);</span><br><span class="line">  <span class="keyword">const</span> pass = prompt(<span class="string">"请输入您的钱包密码"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!pass) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//1.将助记词转成seed</span></span><br><span class="line">    <span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.mnemonicToSeed(mnemonic);</span><br><span class="line">    <span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line">    <span class="keyword">let</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">    <span class="comment">//4.生成钱包中在m/44'/60'/0'/0/i路径的keypair</span></span><br><span class="line">    <span class="keyword">let</span> keyPair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line">    <span class="comment">// 获取钱包对象</span></span><br><span class="line">    <span class="keyword">let</span> wallet = keyPair.getWallet();</span><br><span class="line">    <span class="comment">// 获取钱包地址</span></span><br><span class="line">    <span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">    <span class="comment">// 获取钱包校验地址</span></span><br><span class="line">    <span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line">    <span class="comment">// 获取私钥</span></span><br><span class="line">    <span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">    <span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(pass);</span><br><span class="line">    <span class="built_in">console</span>.log(keystore);</span><br><span class="line">    <span class="comment">// 保存钱包信息</span></span><br><span class="line">    <span class="keyword">const</span> walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: <span class="number">0</span>,</span><br><span class="line">      mnemonic, <span class="comment">// 助记词不应该记录下来仅仅是为了便于演示</span></span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(<span class="string">"wallet"</span>, walletInfo);</span><br><span class="line">    wallet = walletInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>私钥解锁</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">importByPrivateKey</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> key = prompt(<span class="string">"请输入私钥"</span>)</span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> Buffer(key , <span class="string">'hex'</span> )</span><br><span class="line">  <span class="keyword">let</span> pass =  prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.fromPrivateKey(privatekey)</span><br><span class="line">  <span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(pass);</span><br><span class="line">  <span class="comment">// 获取钱包地址</span></span><br><span class="line">  <span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">  <span class="keyword">const</span> walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey: key,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(walletInfo)</span><br><span class="line">    storage.setItem(<span class="string">"wallet"</span>, walletInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>未来展望<ul><li>通过uniapp 、rn、electron 将项目变为app和桌面端应用</li><li>app添加扫码转账功能</li><li>增加erc20代币转账功能</li><li>增加nft数字藏品商城功能</li><li>增加Dao 应用</li></ul></li></ol><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol><li><p>通过智能合约文件 获取abi</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; abi &#125; <span class="keyword">from</span> <span class="string">"@/contract/HHC.json"</span>;</span><br></pre></td></tr></table></figure></li><li><p>在web3实例的基础上创建智能合约实例</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hhc = <span class="keyword">new</span> <span class="keyword">this</span>.web3.eth.Contract(</span><br><span class="line">  abi,</span><br><span class="line">  <span class="string">"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过智能合约实例获取代币余额</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> num = <span class="keyword">await</span> hhc.methods.balanceOf(address).call();</span><br><span class="line">Web3.utils.fromWei(num, <span class="string">"ether"</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>智能合约交易hash 创建</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> createCoinTransationHx(contractInstance, method, to, value) &#123;</span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">   <span class="keyword">let</span> wallet;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     alert(<span class="string">"密码错误"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">from</span> = <span class="keyword">this</span>.ownerAddress;</span><br><span class="line">   <span class="comment">// 当前地址交易次数</span></span><br><span class="line">   <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">   <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">   <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">   <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.getGasPrice();</span><br><span class="line">   <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">   <span class="keyword">let</span> weiValue = <span class="keyword">await</span> Web3.utils.toWei(value);</span><br><span class="line">   <span class="comment">// 转账的记录对象</span></span><br><span class="line">   <span class="comment">// 代币转账</span></span><br><span class="line">   <span class="comment">// this.HccCont = new this.web3.eth.Contract(</span></span><br><span class="line">   <span class="comment">//   abi,</span></span><br><span class="line">   <span class="comment">//   "0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">   <span class="comment">// );</span></span><br><span class="line">   <span class="keyword">const</span> contractAbi = <span class="keyword">await</span> contractInstance.methods[method](</span><br><span class="line">     to,</span><br><span class="line">     weiValue</span><br><span class="line">   ).encodeABI();</span><br><span class="line">   <span class="comment">// console.log(contractAbi);</span></span><br><span class="line">   <span class="comment">// console.log(contractInstance._address);</span></span><br><span class="line">   <span class="comment">// return false;</span></span><br><span class="line">   <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">     <span class="keyword">from</span>: <span class="keyword">this</span>.ownerAddress,</span><br><span class="line">     nonce: nonce,</span><br><span class="line">     gasPrice: gasPrice,</span><br><span class="line">     to: contractInstance._address, <span class="comment">//eth 转账 to 目标地址 ，智能合约 to 智能合约地址</span></span><br><span class="line">     value: <span class="number">0</span>, <span class="comment">//eth 转账 数量</span></span><br><span class="line">     data: contractAbi, <span class="comment">//智能合约方法的abi编码</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">   <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.estimateGas(rawTx);</span><br><span class="line">   rawTx.gas = gas;</span><br><span class="line">   <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">   <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">   tx.sign(privateKey);</span><br><span class="line">   <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">   <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">   <span class="keyword">return</span> transationHx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>智能合约代币转账</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.web3.eth</span><br><span class="line">      .sendSignedTransaction(hx)</span><br><span class="line">      .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">        cb &amp;&amp; cb(ret);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">        <span class="keyword">const</span> &#123; transactionHash &#125; = ret;</span><br><span class="line">        <span class="keyword">this</span>.createOrderData(transactionHash);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"latestBlockHash"</span>, (...arg) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"latestBlockHash"</span>, arg);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error:"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用vue开发以太坊钱包&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>RAG系统搭建(基础版)</title>
    <link href="/2025/02/20/RAG%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA-%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    <id>/2025/02/20/RAG系统搭建-基础版/</id>
    <published>2025-02-20T07:32:05.000Z</published>
    <updated>2025-08-19T02:30:56.056Z</updated>
    
    <content type="html"><![CDATA[<p>简单的搭建一个大语言模型的RAG系统<br><a id="more"></a><br>RAG（Retrieval-Augmented Generation）系统是一种结合了信息检索（Retrieval）和文本生成（Generation）能力的框架，通过将传统的基于检索的方法与现代的生成模型相结合，来提升对任务的回答质量和准确性。<br><img src="/2025/02/20/RAG系统搭建-基础版/1.png" alt="img"></p><h2 id="python环境搭建"><a href="#python环境搭建" class="headerlink" title="python环境搭建"></a>python环境搭建</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用Anaconda来安装python环境，可以直接在系统的应用商店中安装。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>打开Anaconda PowerShell Prompt<br>1.创建环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name envName python=3.10 // 目前最好使用3.10版本，对各种库的兼容性比较好</span><br></pre></td></tr></table></figure></p><p>2.激活环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate envName</span><br></pre></td></tr></table></figure></p><p>3.查看当前环境列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure></p><p>4.卸载环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 确保当前激活环境非要删除的envName</span><br><span class="line">conda env remove --name envName</span><br></pre></td></tr></table></figure></p><p>5.安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装单个包</span><br><span class="line">pip install package_name</span><br><span class="line"></span><br><span class="line">// 根据requirements.txt文件安装所有依赖</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p>6.更换镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">华为云：https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure></p><p>7.查看当前环境都安装了哪些依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></p><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p><a href="https://huggingface.co/models" target="_blank" rel="noopener">HuggingFace模型</a>，这个网站需要科学上网，所以国内使用<a href="https://modelscope.cn/models" target="_blank" rel="noopener">modelscope</a></p><h3 id="安装modelscope依赖库"><a href="#安装modelscope依赖库" class="headerlink" title="安装modelscope依赖库"></a>安装modelscope依赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install modelscope -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="Sentence-Transformer模型下载"><a href="#Sentence-Transformer模型下载" class="headerlink" title="Sentence Transformer模型下载"></a>Sentence Transformer模型下载</h3><p>在进行RAG之前，需要使用词向量模型进行Embedding，将文本进行向量化处理，执行下述命令下载模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 模型下载</span><br><span class="line">from modelscope import snapshot_download</span><br><span class="line"></span><br><span class="line"># model_id 模型的id</span><br><span class="line"># cache_dir 模型下载路径</span><br><span class="line">model_dir = snapshot_download(model_id=&apos;Ceceliachenen/paraphrase-multilingual-MiniLM-L12-v2&apos;, cache_dir=&apos;D:/jinux/models&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="LLM模型下载"><a href="#LLM模型下载" class="headerlink" title="LLM模型下载"></a>LLM模型下载</h3><p>这里选择千问0.5B大模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from modelscope import snapshot_download</span><br><span class="line"></span><br><span class="line">model_dir = snapshot_download(model_id=&apos;Qwen/Qwen2.5-0.5B-Instruct&apos;, cache_dir=&apos;D:/jinux/models&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><p>下边案例所需要的依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install llama_index -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install llama_index.llms.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install transformers -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install llama_index.embeddings.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure></p><h2 id="调用本地模型进行推理测试"><a href="#调用本地模型进行推理测试" class="headerlink" title="调用本地模型进行推理测试"></a>调用本地模型进行推理测试</h2><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from llama_index.llms.huggingface import HuggingFaceLLM</span><br><span class="line">from llama_index.core.llms import ChatMessage</span><br><span class="line"></span><br><span class="line"># 使用HuggingFace 加载本地大模型</span><br><span class="line">llm = HuggingFaceLLM(</span><br><span class="line">  # 给定的是本地模型的全路径</span><br><span class="line">  model_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字</span><br><span class="line">  tokenizer_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 模型名字</span><br><span class="line">  model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;,</span><br><span class="line">  tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;</span><br><span class="line">)</span><br><span class="line">rsp = llm.chat(messages=[ChatMessage(content=&quot;请简单的介绍一下jinux&quot;)])</span><br><span class="line">print(rsp)</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">Jenkins 是一个开源的自动化构建工具，它允许开发者......</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line"> JLinux 是一种基于 Linux 的开源操作系统，由阿里云......</span><br></pre></td></tr></table></figure><p>推理结果每次都是错的。</p><h2 id="创建知识库-RAG"><a href="#创建知识库-RAG" class="headerlink" title="创建知识库(RAG)"></a>创建知识库(RAG)</h2><h3 id="执行代码-1"><a href="#执行代码-1" class="headerlink" title="执行代码"></a>执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings</span><br><span class="line">from llama_index.embeddings.huggingface import HuggingFaceEmbedding</span><br><span class="line">from llama_index.llms.huggingface import HuggingFaceLLM</span><br><span class="line"></span><br><span class="line"># 初始化一个HuggingFaceEmbedding对象，用于将文本转换为向量表示</span><br><span class="line"># 指定了一个预训练的sentence-transformer模型的路径</span><br><span class="line">embed_model = HuggingFaceEmbedding(</span><br><span class="line">    model_name=r&quot;D:\jinux\models\Ceceliachenen\paraphrase-multilingual-MiniLM-L12-v2&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 将创建的嵌入模型赋值给全局设置的embed_model属性，</span><br><span class="line"># 这样在后续的索引构建过程中就会使用这个模型。</span><br><span class="line">Settings.embed_model = embed_model</span><br><span class="line"></span><br><span class="line"># 推理模型（生成模型）</span><br><span class="line">llm = HuggingFaceLLM(</span><br><span class="line">  # 给定的是本地模型的全路径</span><br><span class="line">  model_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字</span><br><span class="line">  tokenizer_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 模型名字</span><br><span class="line">  model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;,</span><br><span class="line">  tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置全局的llm属性，这样在索引查询时会使用这个模型</span><br><span class="line">Settings.llm = llm</span><br><span class="line"></span><br><span class="line"># RAG 系统构建过程</span><br><span class="line"># 从指定目录读取所有文档，并加载数据到内存中，required_exts 只加载指定扩展名的文档</span><br><span class="line">documents = SimpleDirectoryReader(&quot;./documents&quot;, required_exts=[&quot;.txt&quot;]).load_data()</span><br><span class="line"></span><br><span class="line"># 创建一个VectorStoreIndex，并使用之前加载的文档来构建索引</span><br><span class="line"># 此索引将文档转换为向量，并存储这些向量以便于快速检索</span><br><span class="line"># 默认是存储在内存中的</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line"></span><br><span class="line"># 创建一个查询引擎，这个引擎可以接收查询并返回相关文档的响应</span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(&quot;请简单的介绍一下jinux&quot;)</span><br><span class="line"></span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他是一个大龄前端程序员。</span><br><span class="line">他的工作经历和职业背景主要集中在工作中遇到的年龄危机以及他正在学习AI方面知识上。由于他是一位大龄程序员，他在工作中可能会面临一些挑战，比如可能被裁员的风险。因此，他需要不断学习新的技能和知识来应对这些风险。</span><br></pre></td></tr></table></figure><p>测试结果是正确的，因为提供的文档中有这些信息。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>上述代码原理见下图<br><img src="/2025/02/20/RAG系统搭建-基础版/2.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个RAG系统非常简单，但是基本原理是这样的，通过向量化的方式，将文本转换为向量，然后通过向量检索的方式，找到最相似的文本，最后再交给LLM模型进行推理，得到最终的答案。<br><a href="https://github.com/jinux7/study-collections/tree/master/python/AI" target="_blank" rel="noopener">源码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的搭建一个大语言模型的RAG系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python&amp;rust" scheme="/categories/python-rust/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>docker基础教程</title>
    <link href="/2025/02/06/docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>/2025/02/06/docker基础教程/</id>
    <published>2025-02-06T06:58:27.000Z</published>
    <updated>2025-03-05T06:07:35.720Z</updated>
    
    <content type="html"><![CDATA[<p>docker基础入门教程<br><a id="more"></a></p><blockquote><p>本文章运行环境是window11专业版 版本号24H2</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><ul><li>任务栏搜索”功能”，点击”启用或关闭windows功能”</li><li>勾选”适用于Linux的Windows子系统”和”虚拟机平台”,点击确定后重启电脑</li></ul><h3 id="安装wsl2"><a href="#安装wsl2" class="headerlink" title="安装wsl2"></a>安装wsl2</h3><ul><li>使用管理员身份打开CMD</li><li>输入命令<code>wsl --set-default-version 2</code></li><li>输入命令<code>wsl --update</code>也可以<code>wsl --update --web-download</code></li></ul><h3 id="下载docker"><a href="#下载docker" class="headerlink" title="下载docker"></a>下载docker</h3><ul><li><a href="https://www.docker.com/" target="_blank" rel="noopener">docker官网</a></li><li>下载后安装(intel core处理器下载AMD的安装文件)</li></ul><p>安装后可在CMD中执行<code>docker --version</code>查看docker版本</p><h2 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h2><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># 删除 image 文件</span><br><span class="line">docker image rm [imageName]</span><br></pre></td></tr></table></figure></p><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 是最重要、最常用的 image 仓库。</p><h2 id="实例（hello-world）"><a href="#实例（hello-world）" class="headerlink" title="实例（hello world）"></a>实例（hello world）</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello world</a>“，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站。</p><blockquote><p>1.右键点击系统托盘（右下角）的 Docker 图标，选择 Settings（或直接打开 Docker Desktop）。<br>  2.进入 Docker Engine 配置页面。<br>  3.在编辑框中修改 registry-mirrors 字段，添加国内镜像源地址<br>    {<br>      “builder”: {<br>        “gc”: {<br>          “defaultKeepStorage”: “20GB”,<br>          “enabled”: true<br>        }<br>      },<br>      “experimental”: false,<br>      “registry-mirrors”: [<br>        “<a href="https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;" target="_blank" rel="noopener">https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;</a>,<br>        “<a href="https://docker.m.daocloud.io&quot;" target="_blank" rel="noopener">https://docker.m.daocloud.io&quot;</a>,<br>        “<a href="https://hub-mirror.c.163.com&quot;" target="_blank" rel="noopener">https://hub-mirror.c.163.com&quot;</a>,<br>        “<a href="https://mirror.baidubce.com&quot;" target="_blank" rel="noopener">https://mirror.baidubce.com&quot;</a>,<br>        “<a href="https://your_preferred_mirror&quot;" target="_blank" rel="noopener">https://your_preferred_mirror&quot;</a>,<br>        “<a href="https://dockerhub.icu&quot;" target="_blank" rel="noopener">https://dockerhub.icu&quot;</a>,<br>        “<a href="https://docker.registry.cyou&quot;" target="_blank" rel="noopener">https://docker.registry.cyou&quot;</a>,<br>        “<a href="https://docker-cf.registry.cyou&quot;" target="_blank" rel="noopener">https://docker-cf.registry.cyou&quot;</a>,<br>        “<a href="https://dockercf.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://dockercf.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://docker.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://docker.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://dockertest.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://dockertest.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://mirror.aliyuncs.com&quot;" target="_blank" rel="noopener">https://mirror.aliyuncs.com&quot;</a>,<br>        “<a href="https://dockerproxy.com&quot;" target="_blank" rel="noopener">https://dockerproxy.com&quot;</a>,<br>        “<a href="https://mirror.baidubce.com&quot;" target="_blank" rel="noopener">https://mirror.baidubce.com&quot;</a>,<br>        “<a href="https://docker.m.daocloud.io&quot;" target="_blank" rel="noopener">https://docker.m.daocloud.io&quot;</a>,<br>        “<a href="https://docker.nju.edu.cn&quot;" target="_blank" rel="noopener">https://docker.nju.edu.cn&quot;</a>,<br>        “<a href="https://docker.mirrors.sjtug.sjtu.edu.cn&quot;" target="_blank" rel="noopener">https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</a>,<br>        “<a href="https://docker.mirrors.ustc.edu.cn&quot;" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn&quot;</a>,<br>        “<a href="https://mirror.iscas.ac.cn&quot;" target="_blank" rel="noopener">https://mirror.iscas.ac.cn&quot;</a>,<br>        “<a href="https://docker.rainbond.cc&quot;" target="_blank" rel="noopener">https://docker.rainbond.cc&quot;</a><br>      ]<br>    }<br>  4.点击 Apply &amp; Restart，等待 Docker 重启生效。</p></blockquote><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<code>library</code>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure></p><p>抓取成功以后，就可以在本机看到这个 image 文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><p>现在，运行这个 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure></p><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br></pre></td></tr></table></figure></p><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></p><p>对于那些不会自动终止的容器，必须使用<code>docker container kill</code> 命令手动终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container kill [containID]</span><br></pre></td></tr></table></figure></p><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure></p><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure></p><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="实例（制作自己的-Docker-容器）"><a href="#实例（制作自己的-Docker-容器）" class="headerlink" title="实例（制作自己的 Docker 容器）"></a>实例（制作自己的 Docker 容器）</h2><p>下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先下载源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jinux7/koa-demos.git</span><br><span class="line">cd koa-demos</span><br></pre></td></tr></table></figure></p><h3 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></p><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></p><p>上面代码一共五行，含义如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</span><br><span class="line">COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app：指定接下来的工作路径为/app。</span><br><span class="line">RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span><br><span class="line">EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br></pre></td></tr></table></figure></p><h3 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t koa-demo .</span><br><span class="line"># 或者</span><br><span class="line">docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"># 或者</span><br><span class="line">docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面命令的各个参数含义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p参数：容器的 3000 端口映射到本机的 8000 端口。</span><br><span class="line">-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span><br><span class="line">koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</span><br><span class="line">/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span><br></pre></td></tr></table></figure></p><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app#</span><br></pre></td></tr></table></figure></p><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app# node demos/01.js</span><br></pre></td></tr></table></figure></p><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not" target="_blank" rel="noopener">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 demo 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在本机的另一个终端窗口，查出容器的 ID</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 停止指定的容器运行</span><br><span class="line">docker container kill [containerID]</span><br></pre></td></tr></table></figure></p><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查出容器的 ID</span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"># 删除指定的容器文件</span><br><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure></p><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></p><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></p><h3 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>注册一个账户。然后，用下面的命令登录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></p><p>接着，为本地的 image 标注用户名和版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"># 实例</span><br><span class="line">docker image tag koa-demos:0.0.1 jinux/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></p><p>也可以不标注用户名，重新构建一下 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></p><p>最后，发布 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></p><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><blockquote><p>这里的<code>imageName</code>是镜像名，<code>username/repository</code>是用户名下的仓库名，<code>tag</code>版本对用着<code>imageName</code>镜像，一般来说一个仓库下包含着一个镜像的不同版本。</p></blockquote><h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><h3 id="docker-container-start"><a href="#docker-container-start" class="headerlink" title="docker container start"></a>docker container start</h3><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start [containerID]</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-stop"><a href="#docker-container-stop" class="headerlink" title="docker container stop"></a>docker container stop</h3><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop [containerID]</span><br></pre></td></tr></table></figure></p><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><h3 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a>docker container logs</h3><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [containerID]</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-exec"><a href="#docker-container-exec" class="headerlink" title="docker container exec"></a>docker container exec</h3><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-cp"><a href="#docker-container-cp" class="headerlink" title="docker container cp"></a>docker container cp</h3><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker基础入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="docker" scheme="/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>element-plus全局设置组件默认属性</title>
    <link href="/2025/01/09/element-plus%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7/"/>
    <id>/2025/01/09/element-plus全局设置组件默认属性/</id>
    <published>2025-01-09T08:17:43.000Z</published>
    <updated>2025-01-09T08:30:49.193Z</updated>
    
    <content type="html"><![CDATA[<p>element-plus全局设置组件默认属性<br><a id="more"></a><br>以Dialog组件的close-on-click-modal属性为例，默认是true，通过点击modal可以关闭Dialog。<br>现在全局把它设置成false</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementPlus, &#123; ElDialog &#125; from &quot;element-plus&quot;;</span><br><span class="line">ElDialog.props.closeOnclickModal.default = false;</span><br><span class="line">const app = Vue.createApp(App);</span><br><span class="line">app.use(ElementPlus);</span><br></pre></td></tr></table></figure><p><code>ElDialog.props.closeOnclickModal.default = false;</code>这句来修改默认属性</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementPlus from &quot;element-plus&quot;;</span><br><span class="line">const app = Vue.createApp(App);</span><br><span class="line">app.use(ElementPlus);</span><br><span class="line">app._context.components.ElDialog[&apos;props&apos;].closeOnClickModal.default = false;</span><br></pre></td></tr></table></figure><p><code>app._context.components.ElDialog[&#39;props&#39;].closeOnClickModal.default = false;</code>这句来修改默认属性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上举例了ElDialog组件，其他组件也可以这样设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;element-plus全局设置组件默认属性&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nodejs通过usb库调用tspl协议控制标签打印机GODEX(G500-U)</title>
    <link href="/2024/11/12/nodejs%E9%80%9A%E8%BF%87usb%E5%BA%93%E8%B0%83%E7%94%A8tspl%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%E6%A0%87%E7%AD%BE%E6%89%93%E5%8D%B0%E6%9C%BAGODEX-G500-U/"/>
    <id>/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/</id>
    <published>2024-11-12T07:30:31.000Z</published>
    <updated>2024-11-13T08:20:37.181Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs通过usb库调用tspl协议控制标签打印机GODEX<br><a id="more"></a></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>首先要下载Zadig，下载地址<a href="https://zadig.akeo.ie/" target="_blank" rel="noopener">传送门</a>，他是一个usb通用驱动程序，因为GODEX官方驱动执行device.open会报错。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>接上打印机并开机，然后按照下图做，以达到驱动能被open的目的。<br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/1.png" alt="img"><br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/2.png" alt="img"><br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/3.png" alt="img"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>安装nodejs依赖，方法为<code>npm install usb</code></p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usb = <span class="built_in">require</span>(<span class="string">'usb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 你的设备的vendorId和productId</span></span><br><span class="line"><span class="comment"> * 这两个id可以通过Zadig工具获取，也可以通过usb.getDeviceList()方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> vendorId = <span class="number">0x195F</span>;</span><br><span class="line"><span class="keyword">const</span> productId = <span class="number">0x1</span>;</span><br><span class="line"><span class="comment">// 打印方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintLabel</span>(<span class="params">cmds</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> device = usb.findByIds(vendorId, productId)</span><br><span class="line">device.open()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = device.interfaces.length ; i &lt; len ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, len2 = device.interfaces[i].endpoints.length ; j &lt; len2 ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (device.interfaces[i].endpoints[j].direction == <span class="string">'out'</span>) &#123;</span><br><span class="line">device.interfaces[i].claim() <span class="comment">// 找到了要用的对象后，首先要声明所有权</span></span><br><span class="line"><span class="keyword">let</span> outEndpoint = device.interfaces[i].endpoints[j]</span><br><span class="line">outEndpoint.transferType = <span class="number">2</span> <span class="comment">// bulk 批量传输</span></span><br><span class="line">outEndpoint.transfer(cmds, (err) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line">device.close()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">device.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commands = <span class="string">`</span></span><br><span class="line"><span class="string">  ^Q30,3</span></span><br><span class="line"><span class="string">  ^W50</span></span><br><span class="line"><span class="string">  ^H5</span></span><br><span class="line"><span class="string">  ^P1</span></span><br><span class="line"><span class="string">  ^S2</span></span><br><span class="line"><span class="string">  ^AT</span></span><br><span class="line"><span class="string">  ^C1</span></span><br><span class="line"><span class="string">  ^R0</span></span><br><span class="line"><span class="string">  ~Q+0</span></span><br><span class="line"><span class="string">  ^O0</span></span><br><span class="line"><span class="string">  ^D0</span></span><br><span class="line"><span class="string">  ^E12</span></span><br><span class="line"><span class="string">  ~R200</span></span><br><span class="line"><span class="string">  ^XSET,ROTATION,0</span></span><br><span class="line"><span class="string">  ^L</span></span><br><span class="line"><span class="string">  Dy2-me-dd</span></span><br><span class="line"><span class="string">  Th:m:s</span></span><br><span class="line"><span class="string">  BQ,26,15,2,46,40,0,0,WS003</span></span><br><span class="line"><span class="string">  AE,25,130,1,1,0,0,WS00301002</span></span><br><span class="line"><span class="string">  AD,90,178,1,1,0,0,WS003</span></span><br><span class="line"><span class="string">  AB,310,114,1,1,0,0,1241</span></span><br><span class="line"><span class="string">  XRB26,65,4,0,10</span></span><br><span class="line"><span class="string">  WS00301002</span></span><br><span class="line"><span class="string">  XRB325,71,4,0,4</span></span><br><span class="line"><span class="string">  1241</span></span><br><span class="line"><span class="string">  E</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// 调用打印方法</span></span><br><span class="line">PrintLabel(commands)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs通过usb库调用tspl协议控制标签打印机GODEX&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="打印" scheme="/tags/%E6%89%93%E5%8D%B0/"/>
    
  </entry>
  
</feed>
