<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-07-20T06:38:31.779Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>the-super-tiny-compiler</title>
    <link href="/2020/07/20/the-super-tiny-compiler/"/>
    <id>/2020/07/20/the-super-tiny-compiler/</id>
    <published>2020-07-20T05:54:45.000Z</published>
    <updated>2020-07-20T06:38:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>一个极简编译器<br><a id="more"></a></p><h1 id="the-super-tiny-compiler"><a href="#the-super-tiny-compiler" class="headerlink" title="the-super-tiny-compiler"></a>the-super-tiny-compiler</h1><p>现在我们在开发中一定会使用到babel这个编译器，它可以把JavaScript代码解析成ast语法树，进而处理代码。<br>the-super-tiny-compiler 是一个非常简单的代码解析器，通过它可以了解babel的工作原理。<br><a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">the-super-tiny-compiler</a><br><a href="https://github.com/YongzeYao/the-super-tiny-compiler-CN" target="_blank" rel="noopener">the-super-tiny-compiler-CN</a><br>中文注释代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 今天我们会一起编写一个编译器。一个非常非常简化的微型编译器！这个编译器非常小，如果你移除这个</span></span><br><span class="line"><span class="comment"> * 文件里的注释，那么这个文件只剩下大概200行代码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们会将类似于LISP的函数调用编译成类似于C的函数调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果你对这两个语言中的一个或者两个不熟悉。下面是一个快速的介绍。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果我有两个函数`add`和`subtract`，它们会像下面这样被写出来：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  LISP                      C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2 + 2          (add 2 2)                 add(2, 2)</span></span><br><span class="line"><span class="comment"> *   4 - 2          (subtract 4 2)            subtract(4, 2)</span></span><br><span class="line"><span class="comment"> *   2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 非常简单直观不是吗？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 非常好，因为这就是我们要编译的代码。尽管这并不是一个完整的LISP或者C的编译器，但是它足够展示</span></span><br><span class="line"><span class="comment"> * 现代编译器的很多大部分组成部件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大部分编译器的工作可以被分解为三个主要阶段：解析（Parsing），转化（Transformation）以及</span></span><br><span class="line"><span class="comment"> * 代码生成（Code Generation）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. *解析* 将源代码转换为一个更抽象的形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. *转换* 接受解析产生的抽象形式并且操纵这些抽象形式做任何编译器想让它们做的事。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. *代码生成* 基于转换后的代码表现形式（code representation）生成目标代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析</span></span><br><span class="line"><span class="comment"> * -------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解析一般被分为两个部分：词法分析和语法分析。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. *词法分析* 通过一个叫做tokenizer（词素生成器，也叫lexer）的工具将源代码分解成一个个词素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    词素是描述编程语言语法的对象。它可以描述数字，标识符，标点符号，运算符等等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. *语法分析* 接收词素并将它们组合成一个描述了源代码各部分之间关系的中间表达形式：抽象语法树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    抽象语法树是一个深度嵌套的对象，这个对象以一种既能够简单地操作又提供很多关于源代码信息的形式</span></span><br><span class="line"><span class="comment"> *    来展现代码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 看下面的代码:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (add 2 (subtract 4 2))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 上面代码产生的词素会像下面这样：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   [</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'paren',  value: '('        &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'name',   value: 'add'      &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'number', value: '2'        &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'paren',  value: '('        &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'name',   value: 'subtract' &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'number', value: '4'        &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'number', value: '2'        &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'paren',  value: ')'        &#125;,</span></span><br><span class="line"><span class="comment"> *     &#123; type: 'paren',  value: ')'        &#125;,</span></span><br><span class="line"><span class="comment"> *   ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 而产生的抽象语法树会像下面这样：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &#123;</span></span><br><span class="line"><span class="comment"> *     type: 'Program',</span></span><br><span class="line"><span class="comment"> *     body: [&#123;</span></span><br><span class="line"><span class="comment"> *       type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *       name: 'add',</span></span><br><span class="line"><span class="comment"> *       params: [&#123;</span></span><br><span class="line"><span class="comment"> *         type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *         value: '2',</span></span><br><span class="line"><span class="comment"> *       &#125;, &#123;</span></span><br><span class="line"><span class="comment"> *         type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *         name: 'subtract',</span></span><br><span class="line"><span class="comment"> *         params: [&#123;</span></span><br><span class="line"><span class="comment"> *           type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *           value: '4',</span></span><br><span class="line"><span class="comment"> *         &#125;, &#123;</span></span><br><span class="line"><span class="comment"> *           type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *           value: '2',</span></span><br><span class="line"><span class="comment"> *         &#125;]</span></span><br><span class="line"><span class="comment"> *       &#125;]</span></span><br><span class="line"><span class="comment"> *     &#125;]</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换</span></span><br><span class="line"><span class="comment"> * --------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 编译器的下一个阶段是转换阶段。再回顾一遍，这个过程接收解析生成的抽象语法树并对它做出改动。</span></span><br><span class="line"><span class="comment"> * 转换阶段可以改变抽象语法树使代码保持在同一个语言（例如Babel，Babel接收的是JS代码生成的也是</span></span><br><span class="line"><span class="comment"> * JS代码），或者编译成另外一门语言。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 让我们一起来看如何转换一个抽象语法树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可能会注意到我们的抽象语法树包含了长得非常相似的元素。观察那些含有type属性的元素。这些元素</span></span><br><span class="line"><span class="comment"> * 被称为抽象语法树的节点。每一个节点都描述了源代码中的一部分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 针对NumberLiteral我们有一个节点：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &#123;</span></span><br><span class="line"><span class="comment"> *     type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *     value: '2',</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 针对CallExpression我们也有一个节点：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &#123;</span></span><br><span class="line"><span class="comment"> *     type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *     name: 'subtract',</span></span><br><span class="line"><span class="comment"> *     params: [...nested nodes go here...],</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在转换抽象语法树的时候，我们可以通过添加/删除/替换节点属性来操纵节点。我们也可以添加节点，</span></span><br><span class="line"><span class="comment"> * 删除节点，或者基于现有的抽象语法树创建一个全新的抽象语法树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于我们的编译目标是另外一门语言，所以我们集中注意力新建一个针对目标语言的全新抽象语法树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment"> * ---------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了处理节点，我们需要遍历它们。这个遍历的过程按照深度优先规则遍历每一个节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &#123;</span></span><br><span class="line"><span class="comment"> *     type: 'Program',</span></span><br><span class="line"><span class="comment"> *     body: [&#123;</span></span><br><span class="line"><span class="comment"> *       type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *       name: 'add',</span></span><br><span class="line"><span class="comment"> *       params: [&#123;</span></span><br><span class="line"><span class="comment"> *         type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *         value: '2'</span></span><br><span class="line"><span class="comment"> *       &#125;, &#123;</span></span><br><span class="line"><span class="comment"> *         type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *         name: 'subtract',</span></span><br><span class="line"><span class="comment"> *         params: [&#123;</span></span><br><span class="line"><span class="comment"> *           type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *           value: '4'</span></span><br><span class="line"><span class="comment"> *         &#125;, &#123;</span></span><br><span class="line"><span class="comment"> *           type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *           value: '2'</span></span><br><span class="line"><span class="comment"> *         &#125;]</span></span><br><span class="line"><span class="comment"> *       &#125;]</span></span><br><span class="line"><span class="comment"> *     &#125;]</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以针对上面这个抽象语法树我们会按照下面步骤遍历节点：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. Program - 从抽象语法树的最顶端开始</span></span><br><span class="line"><span class="comment"> *   2. CallExpression (add) - 移动到Program的body属性中的第一个元素</span></span><br><span class="line"><span class="comment"> *   3. NumberLiteral (2) - 移动到CallExpression的params中的第一个元素</span></span><br><span class="line"><span class="comment"> *   4. CallExpression (subtract) - 移动到CallExpression的params中的第二个元素</span></span><br><span class="line"><span class="comment"> *   5. NumberLiteral (4) - 移动到CallExpression的params中的第一个元素</span></span><br><span class="line"><span class="comment"> *   6. NumberLiteral (2) - 移动到CallExpression的params中的第二个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果我们直接操纵这个抽象语法树，而不是创建一个新的抽象语法树，那么我们就需要在这个步骤使用到</span></span><br><span class="line"><span class="comment"> * 很多不同的抽象概念。然而为了满足我们的需求，在这一步我们仅仅需要访问抽象语法树中的每一个节点</span></span><br><span class="line"><span class="comment"> * 即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The reason I use the word "visiting" is because there is this pattern of how</span></span><br><span class="line"><span class="comment"> * to represent operations on elements of an object structure.</span></span><br><span class="line"><span class="comment"> * 在这里我使用“访问”这个词的与原因是因为存在着下面这个用来表示一个对象结构中元素行为的模式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 访问者</span></span><br><span class="line"><span class="comment"> * --------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基本的思想是我们会创建一个“访问者”对象，这个访问者对象有不同的方法来接受不同的节点类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   var visitor = &#123;</span></span><br><span class="line"><span class="comment"> *     NumberLiteral() &#123;&#125;,</span></span><br><span class="line"><span class="comment"> *     CallExpression() &#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当我们遍历抽象语法树的时候，我们会根据现在“进入”的节点的类型调用访问者对象相对应的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了使这个对象能够正常工作，我们需要传入当前节点以及当前节点的父节点的引用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   var visitor = &#123;</span></span><br><span class="line"><span class="comment"> *     NumberLiteral(node, parent) &#123;&#125;,</span></span><br><span class="line"><span class="comment"> *     CallExpression(node, parent) &#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 然而，也存在着在“离开”节点的时候调用方法的可能性。假设我们有以下的抽象语法树结构：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Program</span></span><br><span class="line"><span class="comment"> *     - CallExpression</span></span><br><span class="line"><span class="comment"> *       - NumberLiteral</span></span><br><span class="line"><span class="comment"> *       - CallExpression</span></span><br><span class="line"><span class="comment"> *         - NumberLiteral</span></span><br><span class="line"><span class="comment"> *         - NumberLiteral</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当我们向下遍历语法树的时候，我们会碰到所谓的叶子节点。我们在处理完一个节点后会“离开”这个节点。</span></span><br><span class="line"><span class="comment"> * 所以向下遍历树的时候我们“进入”节点，而向上返回的时候我们“离开”节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   -&gt; Program (enter)</span></span><br><span class="line"><span class="comment"> *     -&gt; CallExpression (enter)</span></span><br><span class="line"><span class="comment"> *       -&gt; Number Literal (enter)</span></span><br><span class="line"><span class="comment"> *       &lt;- Number Literal (exit)</span></span><br><span class="line"><span class="comment"> *       -&gt; Call Expression (enter)</span></span><br><span class="line"><span class="comment"> *          -&gt; Number Literal (enter)</span></span><br><span class="line"><span class="comment"> *          &lt;- Number Literal (exit)</span></span><br><span class="line"><span class="comment"> *          -&gt; Number Literal (enter)</span></span><br><span class="line"><span class="comment"> *          &lt;- Number Literal (exit)</span></span><br><span class="line"><span class="comment"> *       &lt;- CallExpression (exit)</span></span><br><span class="line"><span class="comment"> *     &lt;- CallExpression (exit)</span></span><br><span class="line"><span class="comment"> *   &lt;- Program (exit)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了支持上面所讲的功能，我们的访问者对象的最终形态如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   var visitor = &#123;</span></span><br><span class="line"><span class="comment"> *     NumberLiteral: &#123;</span></span><br><span class="line"><span class="comment"> *       enter(node, parent) &#123;&#125;,</span></span><br><span class="line"><span class="comment"> *       exit(node, parent) &#123;&#125;,</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码生成</span></span><br><span class="line"><span class="comment"> * ---------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 编译器的最后步骤是代码生成。有时候编译器在这个步骤也会执行转换阶段的一些行为，但是大体而言代</span></span><br><span class="line"><span class="comment"> * 码生成阶段的工作就是基于转换步骤产生的抽象语法树生成目标代码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 代码生成器的工作方式多种多样，一些编译器会重新利用更早阶段产生的词素，还有一些编译器会创建一</span></span><br><span class="line"><span class="comment"> * 个独立的代码表达形式从而能够线性地打印节点，但是基于我的经验大部分编译器会使用我们刚刚创造的</span></span><br><span class="line"><span class="comment"> * 那个抽象语法树，这也是我们接下来讲的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个有效的代码生成器知道如何“打印”抽象语法树不同类型的节点，并且会递归地调用自己来打印嵌套的</span></span><br><span class="line"><span class="comment"> * 节点直到整个语法树被打印成一长串完整的代码字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面所讲到的就是编译器的所有不同部分了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这并不表明所有编译器都像我上面描述的那样工作。不同的编译器有各种各样不同的目的，它们可能需要</span></span><br><span class="line"><span class="comment"> * 一些我没有讲到的步骤。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但是现在你应该已经有了一个编译器如何工作的大体概念了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 既然现在我已经解释了所有东西，你就可以立马动手写一个你自己的编译器了不是吗？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开个玩笑，我会帮助你理解如何写一个编译器 :P。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 那么我们开始吧……</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                                   (/^▽^)/</span></span><br><span class="line"><span class="comment"> *                                THE TOKENIZER!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们从解析步骤的第一个部分开始，词法分析。也就是tokenizer词素生成器的工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们将源代码分解成一个词素数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (add 2 (subtract 4 2))   =&gt;   [&#123; type: 'paren', value: '(' &#125;, ...]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们首先需要接收一个代码字符串，并且我们需要设置两个变量……</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenizer</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `current`变量跟踪我们现在在源代码中的什么地方，就像一个光标一样。</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `tokens`变量，顾名思义，用来储存词素的数组。</span></span><br><span class="line">  <span class="keyword">let</span> tokens = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们从创建一个`while`循环开始，在这个循环里我们会根据需求增加`current`变量的值。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 注意由于词素的长度不同的，我们可能需要在一次循环中多次增加`current`的值。</span></span><br><span class="line">  <span class="keyword">while</span> (current &lt; input.length) &#123;</span><br><span class="line">    <span class="comment">// 我们将input中的当前字符存到char变量中。</span></span><br><span class="line">    <span class="keyword">let</span> char = input[current];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们需要检测的第一个情况就是开括号，这在之后会被函数调用`CallExpression`所用到。但是</span></span><br><span class="line">    <span class="comment">// 现在我们只需要关心字符即可。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 我们检测我们是否有一个开括号：</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果我们有一个开括号，我们创建一个类型为`paren`的词素并将value设置为开括号。</span></span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        type: <span class="string">'paren'</span>,</span><br><span class="line">        value: <span class="string">'('</span>,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 之后我们增加`current`</span></span><br><span class="line">      current++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 然后我们继续进行下一个循环</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来我们需要检测的是闭括号。这里的行为和开括号的一模一样：检查是否是一个闭括号，如果是</span></span><br><span class="line">    <span class="comment">// 的话，创建一个新词素，增加`current`然后执行下一个循环。</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">')'</span>) &#123;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        type: <span class="string">'paren'</span>,</span><br><span class="line">        value: <span class="string">')'</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      current++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来我们需要检测得是空格。这非常有趣，因为空格只是为了易读性而被添加的，所以我们并不需</span></span><br><span class="line">    <span class="comment">// 要将其储存为一个词素。我们简单地不管它就好。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 所以这里我们仅仅检测当前字符是否是一个空格，如果是的话我们直接继续下一个循环。</span></span><br><span class="line">    <span class="keyword">let</span> WHITESPACE = <span class="regexp">/\s/</span>;</span><br><span class="line">    <span class="keyword">if</span> (WHITESPACE.test(char)) &#123;</span><br><span class="line">      current++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个词素类型是数字。这和我们之前碰到的情况都不一样，因为一个数字可能包含任意数量的字符。</span></span><br><span class="line">    <span class="comment">// 我们需要捕获数字的所有字符来创建一个词素。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   (add 123 456)</span></span><br><span class="line">    <span class="comment">//        ^^^ ^^^</span></span><br><span class="line">    <span class="comment">//        上面代码中数字只构成了两个词素</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 所以我们在碰到一个序列中的第一个数字的时候开始下面的步骤。</span></span><br><span class="line">    <span class="keyword">let</span> NUMBERS = <span class="regexp">/[0-9]/</span>;</span><br><span class="line">    <span class="keyword">if</span> (NUMBERS.test(char)) &#123;</span><br><span class="line">      <span class="comment">// 我们会创造一个`value`字符串，这个字符串用来存储字符。</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 之后我们遍历序列中的每一个字符直到遇到一个不是数字的字符，把每一个字符添加到`value`</span></span><br><span class="line">      <span class="comment">// 字符串中并且增加`current`的值。</span></span><br><span class="line">      <span class="keyword">while</span> (NUMBERS.test(char)) &#123;</span><br><span class="line">        value += char;</span><br><span class="line">        char = input[++current];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 之后我们将我们的数字词素添加到`tokens`数组。</span></span><br><span class="line">      tokens.push(&#123; <span class="attr">type</span>: <span class="string">'number'</span>, value &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 然后我们继续下一个循环。</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们同样支持字符串，字符串是由双引号"包裹的文字内容。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   (concat "foo" "bar")</span></span><br><span class="line">    <span class="comment">//            ^^^   ^^^ string tokens</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 我们引号开始检测。</span></span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">'"'</span>) &#123;</span><br><span class="line">      <span class="comment">// 创造一个`value`变量保存我们的字符串。</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 跳过意味着字符串开始的那个引号。</span></span><br><span class="line">      char = input[++current];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 之后我们遍历每一个字符直到我们到达了另一个引号。</span></span><br><span class="line">      <span class="keyword">while</span> (char !== <span class="string">'"'</span>) &#123;</span><br><span class="line">        value += char;</span><br><span class="line">        char = input[++current];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 跳过意味着字符串结尾的引号。</span></span><br><span class="line">      char = input[++current];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 然后创造字符串词素并添加到`tokens`数组。</span></span><br><span class="line">      tokens.push(&#123; <span class="attr">type</span>: <span class="string">'string'</span>, value &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一种词素是`name`词素。这是一个字母序列，在我们lisp语法中是函数的名称。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   (add 2 4)</span></span><br><span class="line">    <span class="comment">//    ^^^</span></span><br><span class="line">    <span class="comment">//    Name token</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> LETTERS = <span class="regexp">/[a-z]/i</span>;</span><br><span class="line">    <span class="keyword">if</span> (LETTERS.test(char)) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 和其他情况一样，我们遍历字母并将它们添加到`value`变量。</span></span><br><span class="line">      <span class="keyword">while</span> (LETTERS.test(char)) &#123;</span><br><span class="line">        value += char;</span><br><span class="line">        char = input[++current];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 之后创建词素并添加到`tokens`变量。</span></span><br><span class="line">      tokens.push(&#123; <span class="attr">type</span>: <span class="string">'name'</span>, value &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后如果我们并不能匹配到任何情况的话，我们就抛出一个错误并退出。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'I dont know what this character is: '</span> + char);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后我们返回词素数组tokens。</span></span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                                 ヽ/❀o ل͜ o\ﾉ</span></span><br><span class="line"><span class="comment"> *                                THE PARSER!!!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们的语法分析器接受我们的词素数组并创造出一个抽象语法树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   [&#123; type: 'paren', value: '(' &#125;, ...]   =&gt;   &#123; type: 'Program', body: [...] &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的，那么我们定义一个`parser`函数，这个函数接收词素数组tokens。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parser</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们还是创建一个`current`变量跟踪我们所处的位置。</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是这一次我们使用的是递归而不是一个`while`循环。所以我们定义一个`walk`函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在walk函数中我们首先获取当前词素。</span></span><br><span class="line">    <span class="keyword">let</span> token = tokens[current];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对不同类型的词素，我们的处理方式也不同，从数字词素开始。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 我们检测当前词素是否为一个数字词素。</span></span><br><span class="line">    <span class="keyword">if</span> (token.type === <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是一个数字词素，我们增加`current`变量的值。</span></span><br><span class="line">      current++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 之后我们返回一个类型为`NumberLiteral`类型的抽象语法树节点，并且设置这个节点的value。</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">'NumberLiteral'</span>,</span><br><span class="line">        value: token.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们有一个字符串词素，那么和数字词素的情况类似，只不过这里我们返回一个`StringLiteral`</span></span><br><span class="line">    <span class="comment">// 类型的词素。</span></span><br><span class="line">    <span class="keyword">if</span> (token.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">      current++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">'StringLiteral'</span>,</span><br><span class="line">        value: token.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来我们检测是否是一个函数调用。我们在碰到一个开括号的时候处理这种情况。</span></span><br><span class="line">    <span class="keyword">if</span> (token.type === <span class="string">'paren'</span> &amp;&amp; token.value === <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="comment">// 我们会增加`current`变量的值来跳过开括号以选取下一个词素，这是因为在我们的抽象语法树</span></span><br><span class="line">      <span class="comment">// 中开括号本身并没有意义。</span></span><br><span class="line">      token = tokens[++current];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 我们创建一个类型为`CallExpression`的基础词素，之后我们将它的名字设置为当前词素的value。</span></span><br><span class="line">      <span class="comment">// 这是因为开括号之后的词素的value就是函数的名字。</span></span><br><span class="line">      <span class="keyword">let</span> node = &#123;</span><br><span class="line">        type: <span class="string">'CallExpression'</span>,</span><br><span class="line">        name: token.value,</span><br><span class="line">        params: [],</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 我们再一次增加`current`变量来跳过包含了函数名的词素。</span></span><br><span class="line">      token = tokens[++current];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 现在我们遍历每一个会成为我们`CallExpression`词素的`params`的词素直到我们遇到一个</span></span><br><span class="line">      <span class="comment">// 闭括号为止。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 这就是需要递归的时候。我们使用递归而不是试图直接分析可能有无限多层嵌套节点的参数。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 为了解释这个概念，以我们的lisp代码为例。你可以观察到`add`的参数是一个数字和一个嵌套</span></span><br><span class="line">      <span class="comment">// 的`CallExpression`，而这个`CallExpression`又拥有自己的参数。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   (add 2 (subtract 4 2))</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 你也可以观察到在我们的词素数组中我们有多个闭括号。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   [</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'paren',  value: '('        &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'name',   value: 'add'      &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'number', value: '2'        &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'paren',  value: '('        &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'name',   value: 'subtract' &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'number', value: '4'        &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'number', value: '2'        &#125;,</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'paren',  value: ')'        &#125;, &lt;&lt;&lt; 闭括号</span></span><br><span class="line">      <span class="comment">//     &#123; type: 'paren',  value: ')'        &#125;, &lt;&lt;&lt; 闭括号</span></span><br><span class="line">      <span class="comment">//   ]</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 我们依赖嵌套的`walk`函数在处理每一个嵌套的CallExpression`的时候增加我们的`current`变量。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 所以我们创建一个`while`循环直到我们碰到一个类型为`paren`并且`value`是闭括号的词素。</span></span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        token.type !== <span class="string">'paren'</span> ||</span><br><span class="line">        (token.type === <span class="string">'paren'</span> &amp;&amp; token.value !== <span class="string">')'</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 我们调用`walk`函数，`walk`函数会返回一个节点然后我们将这个节点添加到我们的`node.params`。</span></span><br><span class="line">        node.params.push(walk());</span><br><span class="line">        token = tokens[current];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后我们还需要增加`current`变量来跳过闭括号。</span></span><br><span class="line">      current++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回这个节点。</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样，如果我们没有匹配到以上任何类型，我们抛出一个错误。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(token.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在，我们来创建我们的抽象语法树。抽象语法树的根节点是一个`Program`节点。</span></span><br><span class="line">  <span class="keyword">let</span> ast = &#123;</span><br><span class="line">    type: <span class="string">'Program'</span>,</span><br><span class="line">    body: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后我们调用我们的`walk`函数，将返回的节点都添加到`ast.body`数组中。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 我们在一个循环中这样做的原因是因为我们可能有多个单独的函数调用，而不是相互嵌套。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   (add 2 2)</span></span><br><span class="line">  <span class="comment">//   (subtract 4 2)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span> (current &lt; tokens.length) &#123;</span><br><span class="line">    ast.body.push(walk());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，语法分析器会返回抽象语法树。</span></span><br><span class="line">  <span class="keyword">return</span> ast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                                 ⌒(❀&gt;◞౪◟&lt;❀)⌒</span></span><br><span class="line"><span class="comment"> *                               THE TRAVERSER!!!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在我们有了抽象语法树，而我们希望可以使用一个访问者对象来访问各个节点。我们需要能够在碰到一</span></span><br><span class="line"><span class="comment"> * 个节点的时候调用访问者对象相应的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   traverse(ast, &#123;</span></span><br><span class="line"><span class="comment"> *     Program: &#123;</span></span><br><span class="line"><span class="comment"> *       enter(node, parent) &#123;</span></span><br><span class="line"><span class="comment"> *         // ...</span></span><br><span class="line"><span class="comment"> *       &#125;,</span></span><br><span class="line"><span class="comment"> *       exit(node, parent) &#123;</span></span><br><span class="line"><span class="comment"> *         // ...</span></span><br><span class="line"><span class="comment"> *       &#125;,</span></span><br><span class="line"><span class="comment"> *     &#125;,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     CallExpression: &#123;</span></span><br><span class="line"><span class="comment"> *       enter(node, parent) &#123;</span></span><br><span class="line"><span class="comment"> *         // ...</span></span><br><span class="line"><span class="comment"> *       &#125;,</span></span><br><span class="line"><span class="comment"> *       exit(node, parent) &#123;</span></span><br><span class="line"><span class="comment"> *         // ...</span></span><br><span class="line"><span class="comment"> *       &#125;,</span></span><br><span class="line"><span class="comment"> *     &#125;,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     NumberLiteral: &#123;</span></span><br><span class="line"><span class="comment"> *       enter(node, parent) &#123;</span></span><br><span class="line"><span class="comment"> *         // ...</span></span><br><span class="line"><span class="comment"> *       &#125;,</span></span><br><span class="line"><span class="comment"> *       exit(node, parent) &#123;</span></span><br><span class="line"><span class="comment"> *         // ...</span></span><br><span class="line"><span class="comment"> *       &#125;,</span></span><br><span class="line"><span class="comment"> *     &#125;,</span></span><br><span class="line"><span class="comment"> *   &#125;);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们定义一个traverser函数，这个函数接收抽象语法树以及一个访问者对象。在这个函数内部我们</span></span><br><span class="line"><span class="comment">// 还会定义两个函数……</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverser</span>(<span class="params">ast, visitor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `traverseArray`函数，这个函数允许我们遍历一个数组并且调用我们接下来定义的函数："traverseNode`。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverseArray</span>(<span class="params">array, parent</span>) </span>&#123;</span><br><span class="line">    array.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      traverseNode(child, parent);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `traverseNode`函数会接收一个节点以及这个节点的父节点。这样它就可以将这两个参数传递给我们</span></span><br><span class="line">  <span class="comment">// 的访问者对象的方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverseNode</span>(<span class="params">node, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//我们首先检测访问者对象是否含有一个匹配当前类型节点的方法。</span></span><br><span class="line">    <span class="keyword">let</span> methods = visitor[node.type];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前类型节点有相匹配的`enter`方法，我们调用这个方法`enter`方法并传入节点以及父节点。</span></span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; methods.enter) &#123;</span><br><span class="line">      methods.enter(node, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来我们根据当前节点类型分情况处理。</span></span><br><span class="line">    <span class="keyword">switch</span> (node.type) &#123;</span><br><span class="line">      <span class="comment">// 我们从最顶层的`Program`开始。由于Program节点的body属性是一个节点数组，我们调用</span></span><br><span class="line">      <span class="comment">// `traverseArray`函数来向下遍历它们。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// （请注意'traverseArray`会调用`traverseNode`所以我们会递归地遍历抽象语法树。）</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'Program'</span>:</span><br><span class="line">        traverseArray(node.body, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对于`CallExpression`节点，我们遍历它的`params`属性。</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CallExpression'</span>:</span><br><span class="line">        traverseArray(node.params, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对于`NumberLiteral`和`StringLiteral`的情况，我们并没有任何子节点去访问，所以我们</span></span><br><span class="line">      <span class="comment">// 直接break。</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'NumberLiteral'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'StringLiteral'</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 同样的，如果出现没有匹配的情况，我们抛出一个错误。</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(node.type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果访问者对象针对当前类型节点存在着一个`exit`方法的话，我们在这里调用它并传入节点和父节点。</span></span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; methods.exit) &#123;</span><br><span class="line">      methods.exit(node, parent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，我们通过调用`traverseNode`并传入ast和null来开始遍历。这里传入null作为父节点的原</span></span><br><span class="line">  <span class="comment">// 因是因为抽象语法树的根节点并没有父节点。</span></span><br><span class="line">  traverseNode(ast, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                                   ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽</span></span><br><span class="line"><span class="comment"> *                              THE TRANSFORMER!!!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接下来就是转换器。我们的转换器会接收我们创造的抽象语法树并将它和一个访问者对象传给traverser</span></span><br><span class="line"><span class="comment"> * 函数。然后创造一个新的抽象语法树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *   Original AST                     |   Transformed AST</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *   &#123;                                |   &#123;</span></span><br><span class="line"><span class="comment"> *     type: 'Program',               |     type: 'Program',</span></span><br><span class="line"><span class="comment"> *     body: [&#123;                       |     body: [&#123;</span></span><br><span class="line"><span class="comment"> *       type: 'CallExpression',      |       type: 'ExpressionStatement',</span></span><br><span class="line"><span class="comment"> *       name: 'add',                 |       expression: &#123;</span></span><br><span class="line"><span class="comment"> *       params: [&#123;                   |         type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *         type: 'NumberLiteral',     |         callee: &#123;</span></span><br><span class="line"><span class="comment"> *         value: '2'                 |           type: 'Identifier',</span></span><br><span class="line"><span class="comment"> *       &#125;, &#123;                         |           name: 'add'</span></span><br><span class="line"><span class="comment"> *         type: 'CallExpression',    |         &#125;,</span></span><br><span class="line"><span class="comment"> *         name: 'subtract',          |         arguments: [&#123;</span></span><br><span class="line"><span class="comment"> *         params: [&#123;                 |           type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *           type: 'NumberLiteral',   |           value: '2'</span></span><br><span class="line"><span class="comment"> *           value: '4'               |         &#125;, &#123;</span></span><br><span class="line"><span class="comment"> *         &#125;, &#123;                       |           type: 'CallExpression',</span></span><br><span class="line"><span class="comment"> *           type: 'NumberLiteral',   |           callee: &#123;</span></span><br><span class="line"><span class="comment"> *           value: '2'               |             type: 'Identifier',</span></span><br><span class="line"><span class="comment"> *         &#125;]                         |             name: 'subtract'</span></span><br><span class="line"><span class="comment"> *       &#125;]                           |           &#125;,</span></span><br><span class="line"><span class="comment"> *     &#125;]                             |           arguments: [&#123;</span></span><br><span class="line"><span class="comment"> *   &#125;                                |             type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *                                    |             value: '4'</span></span><br><span class="line"><span class="comment"> * ---------------------------------- |           &#125;, &#123;</span></span><br><span class="line"><span class="comment"> *                                    |             type: 'NumberLiteral',</span></span><br><span class="line"><span class="comment"> *                                    |             value: '2'</span></span><br><span class="line"><span class="comment"> *                                    |           &#125;]</span></span><br><span class="line"><span class="comment"> *  (sorry the other one is longer.)  |         &#125;</span></span><br><span class="line"><span class="comment"> *                                    |       &#125;</span></span><br><span class="line"><span class="comment"> *                                    |     &#125;]</span></span><br><span class="line"><span class="comment"> *                                    |   &#125;</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们定义一个transformer函数，这个函数接收一个lisp抽象语法树对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformer</span>(<span class="params">ast</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们会创建一个`newAst`，这个新抽象语法树和之前的抽象语法树一样有一个Program节点。</span></span><br><span class="line">  <span class="keyword">let</span> newAst = &#123;</span><br><span class="line">    type: <span class="string">'Program'</span>,</span><br><span class="line">    body: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来我会小小地作弊一下并使用一个小小的hack。我们会给父节点添加一个`context`属性，我们</span></span><br><span class="line">  <span class="comment">// 会将子节点添加到它们的父节点的`context`属性中。通常情况下你会有一个比这个更好的抽象，</span></span><br><span class="line">  <span class="comment">// 但是针对我们的目的这样做更简洁。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 只要记住`context`是一个从旧的抽象语法树到新的抽象语法树的引用即可。</span></span><br><span class="line">  ast._context = newAst.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们从调用traverser函数并传入抽象语法树和访问者对象开始。</span></span><br><span class="line">  traverser(ast, &#123;</span><br><span class="line">    <span class="comment">// 访问者对象处理的第一种情况是`NumberLiteral`节点。</span></span><br><span class="line">    NumberLiteral: &#123;</span><br><span class="line">      <span class="comment">// 我们会在进入节点的时候访问节点。</span></span><br><span class="line">      enter(node, parent) &#123;</span><br><span class="line">        <span class="comment">//我们创建一个`NumberLiteral`类型的新节点并添加到父节点的`context`。</span></span><br><span class="line">        parent._context.push(&#123;</span><br><span class="line">          type: <span class="string">'NumberLiteral'</span>,</span><br><span class="line">          value: node.value,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来是`StringLiteral`类型节点。</span></span><br><span class="line">    StringLiteral: &#123;</span><br><span class="line">      enter(node, parent) &#123;</span><br><span class="line">        parent._context.push(&#123;</span><br><span class="line">          type: <span class="string">'StringLiteral'</span>,</span><br><span class="line">          value: node.value,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着是`CallExpression`类型节点。</span></span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">      enter(node, parent) &#123;</span><br><span class="line">        <span class="comment">// 我们创建一个新的`CallExpression`类型节点，这个新节点还有一个嵌套的`Identifier`对象。</span></span><br><span class="line">        <span class="keyword">let</span> expression = &#123;</span><br><span class="line">          type: <span class="string">'CallExpression'</span>,</span><br><span class="line">          callee: &#123;</span><br><span class="line">            type: <span class="string">'Identifier'</span>,</span><br><span class="line">            name: node.name,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="built_in">arguments</span>: [],</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来我们给原始的`CallExpression`节点定义一个`context`属性。这个属性指向</span></span><br><span class="line">        <span class="comment">// `expression`的arguments属性，这样我们就可以添加参数了。</span></span><br><span class="line">        node._context = expression.arguments;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来我们检测父节点是否是一个`CallExpression`，如果不是的话……</span></span><br><span class="line">        <span class="keyword">if</span> (parent.type !== <span class="string">'CallExpression'</span>) &#123;</span><br><span class="line">          <span class="comment">// 我们将我们的`CallExpression`节点包裹在`ExpressionStatement`节点中。</span></span><br><span class="line">          <span class="comment">// 我们这样做的原因是因为JS中顶层的`CallExpression`实际上是语句。</span></span><br><span class="line">          expression = &#123;</span><br><span class="line">            type: <span class="string">'ExpressionStatement'</span>,</span><br><span class="line">            expression: expression,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后，我们将我们的`CallExpression`（可能被包裹）添加到父节点的`context`属性。</span></span><br><span class="line">        parent._context.push(expression);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，转换器会返回我们刚刚创造的全新抽象语法树。</span></span><br><span class="line">  <span class="keyword">return</span> newAst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                               ヾ（〃＾∇＾）ﾉ♪</span></span><br><span class="line"><span class="comment"> *                            THE CODE GENERATOR!!!!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在我们进入最后的阶段：代码生成器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们的代码生成器会递归地调用自身将树中的每一个节点打印出来，最终形成一个巨大的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codeGenerator</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们根据节点类型分情况处理。</span></span><br><span class="line">  <span class="keyword">switch</span> (node.type) &#123;</span><br><span class="line">    <span class="comment">// 如果我们有一个`Program`节点。我们会使用代码生成器遍历`body`属性中的所有节点然后使用</span></span><br><span class="line">    <span class="comment">// 换行符\n连接起来。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Program'</span>:</span><br><span class="line">      <span class="keyword">return</span> node.body.map(codeGenerator).join(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对`ExpressionStatement`我们会对节点的expression属性调用代码生成器，并加上一个分号……</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ExpressionStatement'</span>:</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        codeGenerator(node.expression) + <span class="string">';'</span> <span class="comment">// &lt;&lt; (...because we like to code the *correct* way)</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对`CallExpression`我们会打印出`callee`，也就是函数名，加上一个开括号，我们会对</span></span><br><span class="line">    <span class="comment">// `arguments`数组中的每一个节点调用代码生成器，使用逗号连接它们，然后我们添加一个闭括号。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'CallExpression'</span>:</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        codeGenerator(node.callee) +</span><br><span class="line">        <span class="string">'('</span> +</span><br><span class="line">        node.arguments.map(codeGenerator).join(<span class="string">', '</span>) +</span><br><span class="line">        <span class="string">')'</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对`Identifier`，我们简单地返回节点的name属性。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Identifier'</span>:</span><br><span class="line">      <span class="keyword">return</span> node.name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对`NumberLiteral`，我们简单地返回节点的值。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'NumberLiteral'</span>:</span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对StringLiteral`，我们在节点value周围加上引号。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'StringLiteral'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'"'</span> + node.value + <span class="string">'"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有匹配，我们抛出一个错误。</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(node.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                                  (۶* ‘ヮ’)۶”</span></span><br><span class="line"><span class="comment"> *                         !!!!!!!!THE COMPILER!!!!!!!!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终于到了！我们定义我们的`compiler`函数。这个函数会将所有部分连接起来。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. input  =&gt; tokenizer   =&gt; tokens</span></span><br><span class="line"><span class="comment"> *   2. tokens =&gt; parser      =&gt; ast</span></span><br><span class="line"><span class="comment"> *   3. ast    =&gt; transformer =&gt; newAst</span></span><br><span class="line"><span class="comment"> *   4. newAst =&gt; generator   =&gt; output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compiler</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tokens = tokenizer(input);</span><br><span class="line">  <span class="keyword">let</span> ast = parser(tokens);</span><br><span class="line">  <span class="keyword">let</span> newAst = transformer(ast);</span><br><span class="line">  <span class="keyword">let</span> output = codeGenerator(newAst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回输出！</span></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> *                                   (๑˃̵ᴗ˂̵)و</span></span><br><span class="line"><span class="comment"> * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!YOU MADE IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment"> * ============================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我只是在导出函数……</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  tokenizer,</span><br><span class="line">  parser,</span><br><span class="line">  traverser,</span><br><span class="line">  transformer,</span><br><span class="line">  codeGenerator,</span><br><span class="line">  compiler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个极简编译器&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="nodejs" scheme="/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nodejs多进程cluster</title>
    <link href="/2020/07/20/nodejs%E5%A4%9A%E8%BF%9B%E7%A8%8Bcluster/"/>
    <id>/2020/07/20/nodejs多进程cluster/</id>
    <published>2020-07-20T03:12:24.000Z</published>
    <updated>2020-07-20T05:42:42.555Z</updated>
    
    <content type="html"><![CDATA[<p>使用cluster开启nodejs多进程<br><a id="more"></a></p><h1 id="nodejs多进程cluster"><a href="#nodejs多进程cluster" class="headerlink" title="nodejs多进程cluster"></a>nodejs多进程cluster</h1><p>nodejs是单线程语言，如果一台电脑cpu是8核的，nodejs只能使用其中的一个，另外7个都没有使用到，cpu的资源都浪费了。<br>cluster这个包可以开启多个进程，可以完全利用电脑的cpu资源。<br>pm2这个工具内部也是用cluster开启的nodejs多进程<br>笔者写了一个小例子：</p><h2 id="cluster-js"><a href="#cluster-js" class="headerlink" title="cluster.js"></a>cluster.js</h2><p>这个文件开启多进程，并且可以守护进程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>); <span class="comment">// 获取CPU 的数量</span></span><br><span class="line"><span class="keyword">var</span> numCPUs = os.cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// numCPUs = 2</span></span><br><span class="line"><span class="keyword">var</span> process = <span class="built_in">require</span>(<span class="string">'process'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="comment">// 主进程分支</span></span><br><span class="line">    cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'工作进程 %d 关闭 (%s). 重启中...'</span>,</span><br><span class="line">            worker.process.pid, signal || code);</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.process.pid]</span><br><span class="line">        worker = cluster.fork()</span><br><span class="line">        workers[worker.process.pid] = worker</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'新的工作进程'</span>, worker.process.pid)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(workers))</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'numCPUs:'</span>, numCPUs)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> worker = cluster.fork();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'init ... pid'</span>, worker.process.pid)</span><br><span class="line">        workers[worker.process.pid] = worker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'./app'</span>);</span><br><span class="line">    app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当主进程被终止时，关闭所有工作进程</span></span><br><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> pid <span class="keyword">in</span> workers) &#123;</span><br><span class="line">        process.kill(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><p>这里就是一个普通http服务程序，有10%的几率抛出错误，检测cluster的守护进程功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Math</span>.random() &gt; <span class="number">0.9</span> ? fn() : <span class="string">''</span> </span><br><span class="line">    response.end(<span class="string">'Hello jinux'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    server.listen(<span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'app started at port 3000...'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="test-js"><a href="#test-js" class="headerlink" title="test.js"></a>test.js</h2><p>这里用来测试端口<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    request(<span class="string">'http://localhost:3000'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'body:'</span>, body); <span class="comment">// Print the HTML for the Google homepage.</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p><p>最后附上demo的代码<a href="https://github.com/jinux7/study-collections/tree/master/nodejs%E5%A4%9A%E8%BF%9B%E7%A8%8Bcluster" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用cluster开启nodejs多进程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="nodejs" scheme="/tags/nodejs/"/>
    
      <category term="服务器" scheme="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>h5横屏适配</title>
    <link href="/2020/07/16/h5%E6%A8%AA%E5%B1%8F%E9%80%82%E9%85%8D/"/>
    <id>/2020/07/16/h5横屏适配/</id>
    <published>2020-07-16T06:38:59.000Z</published>
    <updated>2020-07-16T06:49:51.225Z</updated>
    
    <content type="html"><![CDATA[<p>h5移动端横屏适配<br><a id="more"></a></p><h1 id="h5横屏适配"><a href="#h5横屏适配" class="headerlink" title="h5横屏适配"></a>h5横屏适配</h1><p>我们平时在移动端开发时，特别是一些互动小游戏，需要只能在竖屏或者横屏的状态下展示。<br>比如，我们现在有一个需求，要求只能横屏展示，无论用户的手机处于竖屏还是横屏状态，都展示横屏效果。<br>最常用的方式是利用css3的transform rotate,将页面旋转90度。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 CSS3 旋转 对根容器逆时针旋转 90 度</span></span><br><span class="line"><span class="keyword">var</span> detectOrient = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width = <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">      height =  <span class="built_in">document</span>.documentElement.clientHeight,</span><br><span class="line">      $wrapper =  <span class="built_in">document</span>.getElementById(<span class="string">"J_wrapper"</span>),</span><br><span class="line">      style = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( width &gt;= height )&#123; <span class="comment">// 横屏</span></span><br><span class="line">      style += <span class="string">"width:"</span> + width + <span class="string">"px;"</span>;  <span class="comment">// 注意旋转后的宽高切换</span></span><br><span class="line">      style += <span class="string">"height:"</span> + height + <span class="string">"px;"</span>;</span><br><span class="line">      style += <span class="string">"-webkit-transform: rotate(0); transform: rotate(0);"</span>;</span><br><span class="line">      style += <span class="string">"-webkit-transform-origin: 0 0;"</span>;</span><br><span class="line">      style += <span class="string">"transform-origin: 0 0;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123; <span class="comment">// 竖屏</span></span><br><span class="line">      style += <span class="string">"width:"</span> + height + <span class="string">"px;"</span>;</span><br><span class="line">      style += <span class="string">"height:"</span> + width + <span class="string">"px;"</span>;</span><br><span class="line">      style += <span class="string">"-webkit-transform: rotate(90deg); transform: rotate(90deg);"</span>;</span><br><span class="line">      <span class="comment">// 注意旋转中点的处理</span></span><br><span class="line">      style += <span class="string">"-webkit-transform-origin: "</span> + width / <span class="number">2</span> + <span class="string">"px "</span> + width / <span class="number">2</span> + <span class="string">"px;"</span>;</span><br><span class="line">      style += <span class="string">"transform-origin: "</span> + width / <span class="number">2</span> + <span class="string">"px "</span> + width / <span class="number">2</span> + <span class="string">"px;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  $wrapper.style.cssText = style;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize = detectOrient;</span><br><span class="line">detectOrient();</span><br></pre></td></tr></table></figure></p><p>以上这段代码可以解决一些常见场景，如果场景更复杂，<a href="https://aotu.io/notes/2017/10/18/landscape_mode_in_html5_game/" target="_blank" rel="noopener">详见此文</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;h5移动端横屏适配&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>常见的web攻击方式</title>
    <link href="/2020/06/24/%E5%B8%B8%E8%A7%81%E7%9A%84web%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>/2020/06/24/常见的web攻击方式/</id>
    <published>2020-06-24T01:38:08.000Z</published>
    <updated>2020-06-24T02:22:16.588Z</updated>
    
    <content type="html"><![CDATA[<p>常见的web攻击方式<br><a id="more"></a></p><h1 id="常见的web攻击方式"><a href="#常见的web攻击方式" class="headerlink" title="常见的web攻击方式"></a>常见的web攻击方式</h1><p>简要的介绍下web常见的几种攻击方式</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>详请见本站文章<a href="https://jinux7.github.io/2018/11/28/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS/" target="_blank" rel="noopener">web安全之XSS</a></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>详请见本站文章<a href="https://jinux7.github.io/2018/11/28/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/" target="_blank" rel="noopener">web安全之CSRF</a></p><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>比如你访问黑客网站A，A网站iframe引入了一个博客网站B，A网站将iframe透明化，并且在iframe下面放一张美女图片，图片上有一个更新美女信息的按钮，这个按钮正好跟B网站发布信息按钮重合，当你不在意的点击了图片上的按钮，实际你点击的是透明化的B网站的发布信息按钮。</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入是对后端数据库的攻击<br>前端页面输入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：admin</span><br><span class="line">密码：<span class="number">1</span><span class="string">'or'</span><span class="number">1</span><span class="string">'='</span><span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这里的密码是一段SQL语句，后台在利用前端传来的红户名和密码拼装好一段SQL语句，并查询就会返回true。<br>拼接后的SQL语句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE username = <span class="string">'admin'</span> AND password = <span class="string">'1'</span>or<span class="string">'1'</span>=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="OS注入"><a href="#OS注入" class="headerlink" title="OS注入"></a>OS注入</h2><p>OS注入式针对操作系统的<br>以nodejs为例，假如在接口中需要从github下载用户指定的repo，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'mz/child_process'</span>).exec;</span><br><span class="line"><span class="keyword">let</span> params = <span class="comment">// 用户输入的参数</span></span><br><span class="line">exec(<span class="string">`git clone <span class="subst">$&#123;params.repo&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></p><p>如果传入的参数是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/xx/xx.git &amp;&amp; rm -rf /*</span></span><br></pre></td></tr></table></figure></p><p>执行完拉取库的命令后继续执行一个删除当前路径下所有文件的操作。</p><h2 id="请求劫持"><a href="#请求劫持" class="headerlink" title="请求劫持"></a>请求劫持</h2><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS服务器（DNS解析的各个步骤）被纂改，修改了域名解析的结果，使得访问到的不是预期的ip。</p><h3 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h3><p>运营商劫持，此时大概只能升级HTTPS了。</p><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">可以看一下阮老师的这篇文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的web攻击方式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>chrome调试之overrides</title>
    <link href="/2020/06/22/chrome%E8%B0%83%E8%AF%95%E4%B9%8Boverrides/"/>
    <id>/2020/06/22/chrome调试之overrides/</id>
    <published>2020-06-22T03:19:42.000Z</published>
    <updated>2020-06-22T05:23:18.857Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器调试之overrides<br><a id="more"></a></p><h1 id="chrome调试之overrides"><a href="#chrome调试之overrides" class="headerlink" title="chrome调试之overrides"></a>chrome调试之overrides</h1><p>平时我们用浏览器调试代码很普遍，今天我介绍一个浏览器的小技能，可以覆盖网站的代码，在本地生成一个一样的文件，刷新网站的时候浏览器会加载本地生成的文件，这样，可以实时的修改代码并且观察修改后的效果。<br>启用步骤：<br>1.在浏览器的调试面板进入sources.<br>2.点击overrides,会看到一个<code>+ Select folder for overrides</code>,点击加号选择一个存放文件的文件夹。（注意浏览器上方会有一个权限提示，点击允许）<br>3.这时还是在sources面板下，点击Page，切换到此网站的源代码展示目录，选择一个要调试的文件（html,js,css均可），单击右键，选择<code>Save for overrides</code>, 之后可以在刚才选择的文件夹下看到这个保存到本地的文件，修改这个文件后再刷新页面，就可以看到修改后的变化了。<br>4.在overrides面板下可以看到<code>Enable Local Overrides</code>,切换这个选项可以控制本地代码是否参与执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器调试之overrides&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="调试" scheme="/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="浏览器" scheme="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>jwt、session、oauth简单介绍</title>
    <link href="/2020/06/19/jwt%E3%80%81session%E3%80%81oauth%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>/2020/06/19/jwt、session、oauth简单介绍/</id>
    <published>2020-06-19T03:04:57.000Z</published>
    <updated>2020-06-19T03:33:41.954Z</updated>
    
    <content type="html"><![CDATA[<p>jwt、session、oauth的鉴权简单说明<br><a id="more"></a></p><h1 id="jwt、session、oauth简单介绍"><a href="#jwt、session、oauth简单介绍" class="headerlink" title="jwt、session、oauth简单介绍"></a>jwt、session、oauth简单介绍</h1><h2 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h2><p>jwt是json web token的缩写，jwt的鉴权流程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用户向服务器发送用户名和密码。</span><br><span class="line"><span class="number">2</span>、服务器验证通过后，生成jwt，可以有选择的在其中    保存用户信息及数据。也可以加密。    </span><br><span class="line"><span class="number">3</span>、服务器向用户返回jwt。</span><br><span class="line"><span class="number">4</span>、用户随后的每一次请求，都会在 cookie 或者 header或参数里，将 jwt 传回服务器鉴权。</span><br><span class="line"><span class="number">5</span>、服务器收到jwt，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure></p><p>jwt内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分为 头部（header),载荷（payload)，签证（signature). 用 “.” 分隔。</span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1</span><br><span class="line">NDM0ODg3NjgsImp0aSI6ImFjYzhmZjIzLWM1MjgtNDk3OS04N</span><br><span class="line">TYwLWY0NGFmYWNhNDY4MiIsImlzcyI6ImJpenN2YyIsIm5iZ</span><br><span class="line">iI6NTQzNDgxNTY4LCJzdWIiOiJ0b2tlbi14ajZqOTo3emg1Y</span><br><span class="line">md2OGI1cWZrN2JoNnJxZ3o3djV0OGJ2amhiNHNoazQ5aGh6O</span><br><span class="line">GtjcWN6NmpnNWI3ejIifQ.dRKURNOUFOlgO7zBxMajF7<span class="number">-8</span>Wn</span><br><span class="line"><span class="number">0</span>zYs8x2t0UU6SYtP4</span><br></pre></td></tr></table></figure></p><p>优缺点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有跨域问题、集群下登录信息同步的问题。</span><br><span class="line">一旦签发，到期前无法简单废止，最好用https。</span><br><span class="line">server无状态，性能高。</span><br></pre></td></tr></table></figure></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session是利用cookie做健全的，流程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用户向服务器发送用户名和密码。</span><br><span class="line"><span class="number">2</span>、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</span><br><span class="line"><span class="number">3</span>、服务器向用户返回一个 session_id，写入用户的 Cookie。</span><br><span class="line"><span class="number">4</span>、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</span><br><span class="line"><span class="number">5</span>、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure></p><p>优缺点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扩展性不好，存在跨域 和 集群session同步的问题。</span><br><span class="line">面对csrf 攻击，不如jwt。</span><br></pre></td></tr></table></figure></p><h2 id="oauth-用于第三方认证"><a href="#oauth-用于第三方认证" class="headerlink" title="oauth 用于第三方认证"></a>oauth 用于第三方认证</h2><p>目的在于让客户端安全可控地获取”用户”的授权。<br>比如说，登录微博（客户端）的时候，懒得新建账号了就用qq账号登录，选择qq登录。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oauth场景，客户端不必保存登录用户（qq）的登录密码。  </span><br><span class="line">更精细的控制权限，即权限的到期时间，提升安全性。</span><br><span class="line">有四种模式：</span><br><span class="line">    授权码模式（authorization code）</span><br><span class="line">    简化模式（implicit）</span><br><span class="line">    密码模式（resource owner password credentials）</span><br><span class="line">    客户端模式（client credentials）</span><br></pre></td></tr></table></figure></p><p>这里我做了一个github的第三方登录鉴权，详情<a href="https://github.com/jinux7/study-collections/tree/master/oauth-github%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">点这里</a>查看。<br>在做鉴权之前，需要登录github，之后在setting-&gt;Developer settings开启github鉴权功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jwt、session、oauth的鉴权简单说明&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="github" scheme="/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1和HTTP2的区别</title>
    <link href="/2020/06/18/HTTP1%E5%92%8CHTTP2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>/2020/06/18/HTTP1和HTTP2的区别/</id>
    <published>2020-06-18T06:51:59.000Z</published>
    <updated>2020-06-18T08:36:58.916Z</updated>
    
    <content type="html"><![CDATA[<p>简单的说一下http1和http2的区别<br><a id="more"></a></p><h1 id="HTTP1和HTTP2的区别"><a href="#HTTP1和HTTP2的区别" class="headerlink" title="HTTP1和HTTP2的区别"></a>HTTP1和HTTP2的区别</h1><h2 id="Http1-x"><a href="#Http1-x" class="headerlink" title="Http1.x"></a>Http1.x</h2><p>缺陷：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞。</p><h2 id="Http1-0-短连接"><a href="#Http1-0-短连接" class="headerlink" title="Http1.0(短连接)"></a>Http1.0(短连接)</h2><p>缺陷：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；<br>解决方案：添加头信息——非标准的Connection字段Connection: keep-alive</p><h2 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h2><p>改进点：<br>1.持久连接（与Http1其它版本的最大区别）<br>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive(对于同一个域名，大多数浏览器允许同时建立6个持久连接)<br>2.管道机制<br>即在同一个TCP连接里面，客户端可以同时发送多个请求。<br>3.分块传输编码<br>即服务端每产生一块数据，就发送一块，采用”流模式”而取代”缓存模式”。<br>4.新增请求方式<br>PUT:请求服务器存储一个资源;<br>DELETE：请求服务器删除标识的资源；<br>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；<br>TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；<br>CONNECT：保留将来使用<br>5.缺点：<br>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”</p><ul><li>避免方式：一是减少请求数，二是同时多开持久连接</li></ul><h2 id="Http-2-0"><a href="#Http-2-0" class="headerlink" title="Http/2.0"></a>Http/2.0</h2><p>特点：<br>1.采用二进制格式而非文本格式；<br>2.完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；（解决了线头阻塞的问题，与Http1最重要的区别）<br>3.使用报头压缩，降低开销<br>4.服务器推送</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。<br>二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。</p><h3 id="完全多路复用"><a href="#完全多路复用" class="headerlink" title="完全多路复用"></a>完全多路复用</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><h3 id="报头压缩"><a href="#报头压缩" class="headerlink" title="报头压缩"></a>报头压缩</h3><p>1.HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>2.对于相同的头部，不必再通过请求发送，只需发送一次；<br>3.HTTP/2 对这一点做了优化，引入了头信息压缩机制；<br>4.一方面，头信息使用gzip或compress压缩后再发送；<br>5.另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的说一下http1和http2的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs常驻后台运行</title>
    <link href="/2020/06/05/Nodejs%E5%B8%B8%E9%A9%BB%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>/2020/06/05/Nodejs常驻后台运行/</id>
    <published>2020-06-05T09:05:27.000Z</published>
    <updated>2020-06-08T01:28:29.261Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs程序在后台运行<br><a id="more"></a></p><h1 id="Nodejs常驻后台运行"><a href="#Nodejs常驻后台运行" class="headerlink" title="Nodejs常驻后台运行"></a>Nodejs常驻后台运行</h1><p>nodejs是通过命令行方式执行，当用户的xshell断开时Nodejs也就停止运行了。下面介绍几种办法让Nodejs常驻在后台运行</p><h2 id="pm2-推荐"><a href="#pm2-推荐" class="headerlink" title="pm2(推荐)"></a>pm2(推荐)</h2><p><a href="http://pm2.io/" target="_blank" rel="noopener">官网地址</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br><span class="line">pm2 start app.js        <span class="comment">// 启动</span></span><br><span class="line">pm2 start app.js -i max <span class="comment">//启动 使用所有CPU核心的集群</span></span><br><span class="line">pm2 stop app.js         <span class="comment">// 停止</span></span><br><span class="line">pm2 stop all            <span class="comment">// 停止所有</span></span><br><span class="line">pm2 restart app.js      <span class="comment">// 重启</span></span><br><span class="line">pm2 restart all         <span class="comment">// 重启所有</span></span><br><span class="line">pm2 <span class="keyword">delete</span>  app.js      <span class="comment">// 关闭</span></span><br></pre></td></tr></table></figure></p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup node app.js &amp;</span><br></pre></td></tr></table></figure><h2 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h2><p><a href="https://github.com/nodejitsu/forever" target="_blank" rel="noopener">github地址</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install forever -g</span><br><span class="line">forever start app.js    <span class="comment">//启动</span></span><br><span class="line">forever stop app.js     <span class="comment">//关闭</span></span><br><span class="line">forever stopall         <span class="comment">//关闭全部</span></span><br><span class="line">forever restart app.js  <span class="comment">//重启</span></span><br><span class="line">forever restartall      <span class="comment">//重启全部</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs程序在后台运行&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="linux" scheme="/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>前端埋点</title>
    <link href="/2020/05/29/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/"/>
    <id>/2020/05/29/前端埋点/</id>
    <published>2020-05-29T03:13:42.000Z</published>
    <updated>2020-05-29T06:16:56.139Z</updated>
    
    <content type="html"><![CDATA[<p>全面的介绍前端埋点知识<br><a id="more"></a></p><h1 id="前端埋点"><a href="#前端埋点" class="headerlink" title="前端埋点"></a>前端埋点</h1><p>所谓「埋点」，就是在正常的功能逻辑中添加统计逻辑。拿统计微信右上角「+」的点击次数为例，上报的数据可以采用KEY-VALUE形式，我们定义KEY为「CLICK_ADD_BTN」，VALUE的值为点击的次数。当用户点击「+」时，展示菜单的代码会通过按钮的「回调」来触发执行，程序猿在业务代码执行完后，又加上了统计代码，把「CLICK_ADD_BTN」对应的VALUE加1，「+」被统计到了一次使用。<br>目前常见的前端埋点技术有3类：代码埋点、可视化埋点、无埋点（无埋点属于埋点的一个子集）。</p><h2 id="代码埋点："><a href="#代码埋点：" class="headerlink" title="代码埋点："></a>代码埋点：</h2><p>控件操作发生时通过预先写好的代码来发送数据。<br>优点：</p><ul><li>控制发送数据时间，事件自定义属性详细记录</li></ul><p>缺点：</p><ul><li>时间、人力成本大，数据传输的时效性。</li></ul><h2 id="可视化埋点："><a href="#可视化埋点：" class="headerlink" title="可视化埋点："></a>可视化埋点：</h2><p>利用可视化交互手段，通过可视化界面配置控件操作与事件操作发生关系。通过后台截屏的方式采集数据。<br>优点：</p><ul><li>成本低，速度快</li></ul><p>缺点：</p><ul><li>行为记录信息少，支持的分析方式少</li></ul><h2 id="无埋点："><a href="#无埋点：" class="headerlink" title="无埋点："></a>无埋点：</h2><p>Growing IO和Heap analytics，这2家是国内与国外的无埋点技术公司代表。用户展现界面元素时，通过控件绑定触发事件，事件被触发的时候系统会有相应的接口让开发者处理这些行为。现在市面上主流无埋点做法有两种，一种是预先跟踪所有的渲染信息，一种是滞后跟踪的渲染信息。<br>优点：</p><ul><li>无需埋点，方便快捷</li></ul><p>缺点：</p><ul><li>行为记录信息少，传输压力大</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，关于埋点有无问题，可视化埋点和代码优劣问题，不管选择哪个都要从自身情况去考虑，自身分析场景来体验和对比，选择最适合自己的。适合自己的才是最好的。<br>这里推荐两篇介绍比较详细的前端埋点博文:<br><a href="http://www.imooc.com/article/27151" target="_blank" rel="noopener">第一篇</a><br><a href="https://blog.csdn.net/ywl570717586/article/details/89852222" target="_blank" rel="noopener">第二篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全面的介绍前端埋点知识&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>微前端</title>
    <link href="/2020/05/25/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <id>/2020/05/25/微前端/</id>
    <published>2020-05-25T07:11:09.000Z</published>
    <updated>2020-05-25T07:53:46.365Z</updated>
    
    <content type="html"><![CDATA[<p>初探微前端<br><a id="more"></a></p><h1 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h1><p>微前端最近火了起来，作为紧跟技术潮流的笔者来说，当然要了解一下。<br>贴出一篇笔者觉得不错的文章，<a href="https://www.lizenghai.com/archives/40308.html#i-17" target="_blank" rel="noopener">Single-Spa + Vue Cli 微前端落地指南</a>。这篇文章写得很不错，笔者就是按照他的思路一步一步的完成了一个微前端的demo。但是，笔者的demo只包含vue，父项目和子项目都是用的vue搭建的，相对来说比较简单些，而且，在实际开发的项目中都是一样的框架也是最好的选择。<br>最后，自己用vue写的一个demo，完成了主框架引入了两个子框架。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E5%BE%AE%E5%89%8D%E7%AB%AF" target="_blank" rel="noopener">demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初探微前端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>hash&amp;history单页面路由框架</title>
    <link href="/2020/05/18/hash-history%E5%8D%95%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6/"/>
    <id>/2020/05/18/hash-history单页面路由框架/</id>
    <published>2020-05-18T03:30:17.000Z</published>
    <updated>2020-05-18T05:20:29.624Z</updated>
    
    <content type="html"><![CDATA[<p>hash和history路由形式的单页面框架<br><a id="more"></a></p><h1 id="hash-amp-history单页面路由框架"><a href="#hash-amp-history单页面路由框架" class="headerlink" title="hash&amp;history单页面路由框架"></a>hash&amp;history单页面路由框架</h1><p>现在vue,react,angular三大框架已经垄断了前端的单页面应用，用起来很方便，今天笔者写两个hash和history路由的小框架，有时候小项目可能也能用到，相比其它框架可能会配置灵活些。在使用vue等框架之前的单页面应用都是这样做的。<br>细节不写了，附上demo代码：<br><a href="https://github.com/jinux7/study-collections/tree/master/hash%26history%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hash和history路由形式的单页面框架&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写vue</title>
    <link href="/2020/04/27/%E6%89%8B%E5%86%99vue/"/>
    <id>/2020/04/27/手写vue/</id>
    <published>2020-04-27T05:54:30.000Z</published>
    <updated>2020-04-27T08:04:30.936Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个基础功能的vue<br><a id="more"></a></p><h1 id="手写vue"><a href="#手写vue" class="headerlink" title="手写vue"></a>手写vue</h1><p>实现一个非常简化版vue，暂时实现了<code>v-text,v-html,v-model,@eventName</code>指令，还有插值表达式<code>｛｛｝｝</code>,<br>一共写了4个类去实现，Vue是主类，Dep依赖收集类，Watcher是观察者类，Dep依赖收集去触发Watcher观察者定义的的方法，Compile类是用来解析html的dom元素的，解析的时候向对应的数据添加依赖，这样数据改变视图跟着改变。<br>下面是代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(option) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = option.el &amp;&amp; <span class="built_in">document</span>.querySelector(option.el);</span><br><span class="line">    <span class="keyword">this</span>.$data = option.data;</span><br><span class="line">    <span class="keyword">this</span>.$methods = option.methods;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observer(<span class="keyword">this</span>.$data);</span><br><span class="line">    <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给data值设置get，set的数据劫持</span></span><br><span class="line">  observer(daObj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> daObj === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> daObj) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = daObj[key];</span><br><span class="line">        <span class="keyword">if</span>(value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.observer(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); </span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(daObj, key, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              Dep.target &amp;&amp; dep.push(Dep.target);</span><br><span class="line">              <span class="keyword">return</span> value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(val) &#123;</span><br><span class="line">              value = val;</span><br><span class="line">              <span class="comment">// 这里注意。依赖触发要在value=val的下边</span></span><br><span class="line">              dep.dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  push(watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers.push(watcher);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers.forEach(<span class="function"><span class="params">watcher</span>=&gt;</span> &#123;</span><br><span class="line">      watcher &amp;&amp; watcher.callback &amp;&amp; watcher.callback(); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(callback) &#123;</span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译模板字符串类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseHtml(el, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  parseHtml(el, vm) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(el.childNodes).forEach(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理带有指令的节点元素</span></span><br><span class="line">      <span class="keyword">this</span>.updateDirect(item, vm);</span><br><span class="line">      <span class="keyword">if</span>(item.nodeType === <span class="number">1</span> &amp;&amp; item.childNodes.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归解析</span></span><br><span class="line">        <span class="keyword">this</span>.parseHtml(item, vm);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.nodeType === <span class="number">3</span> &amp;&amp; <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>.test(item.textContent)) &#123;</span><br><span class="line">        <span class="keyword">let</span> epx = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.updateText(item, vm, epx);</span><br><span class="line">        <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.updateText(item, vm, epx);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是指令节点</span></span><br><span class="line">  updateDirect(node, vm) &#123;</span><br><span class="line">    <span class="comment">// 如果元素节点的属性是一个json对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> node.attributes === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="comment">// 转换成数组</span></span><br><span class="line">      <span class="keyword">let</span> attrs = <span class="built_in">Array</span>.from(node.attributes);</span><br><span class="line">      <span class="keyword">if</span>(attrs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;attrs.length; i++) &#123;</span><br><span class="line">          <span class="comment">// v-xxx指令</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="regexp">/^v\-.+/</span>.test(attrs[i].name)) &#123;</span><br><span class="line">            <span class="keyword">let</span> handleStr = attrs[i].name.substring(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> epx = attrs[i].value;</span><br><span class="line">            <span class="keyword">this</span>[<span class="string">'dir'</span>+handleStr](node, vm, epx);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// @事件</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="regexp">/^\@.+/</span>.test(attrs[i].name))&#123;</span><br><span class="line">            <span class="keyword">let</span> eventName = attrs[i].name.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> callbackName = attrs[i].value;</span><br><span class="line">            <span class="keyword">this</span>[<span class="string">'eventHandler'</span>](node, vm, eventName, callbackName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理指令节点数据响应</span></span><br><span class="line">  dirtext(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateText(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateText(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirhtml(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateHtml(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateHtml(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirmodel(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateValue(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateValue(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 添加input事件</span></span><br><span class="line">    node.addEventListener(<span class="string">'input'</span>, (ev)=&gt; &#123;</span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx + <span class="string">'="'</span> + ev.target.value + <span class="string">'"'</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理指令事件</span></span><br><span class="line">  eventHandler(node, vm, eventName, callbackName) &#123;</span><br><span class="line">    node.addEventListener(eventName, vm.$methods[callbackName]||loop, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改元素节点的textContent</span></span><br><span class="line">  updateText(node, vm, epx) &#123;</span><br><span class="line">    node.textContent = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改元素节点的innerHTML</span></span><br><span class="line">  updateHtml(node, vm, epx) &#123;</span><br><span class="line">    node.innerHTML = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改input元素的value</span></span><br><span class="line">  updateValue(node, vm, epx) &#123;</span><br><span class="line">    node.value = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>代码不多，但是基本功能已经实现。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99vue" target="_blank" rel="noopener">代码点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个基础功能的vue&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>手写vuex</title>
    <link href="/2020/04/21/%E6%89%8B%E5%86%99vuex/"/>
    <id>/2020/04/21/手写vuex/</id>
    <published>2020-04-21T06:52:06.000Z</published>
    <updated>2020-04-21T07:16:43.862Z</updated>
    
    <content type="html"><![CDATA[<p>简单的实现vuex的功能<br><a id="more"></a></p><h1 id="手写vuex"><a href="#手写vuex" class="headerlink" title="手写vuex"></a>手写vuex</h1><p>vuex是vue的一个状态管理插件，现在使用的场景非常多，今天，自己简单的实现一下vuex的几个小功能，如<code>state,getter,commit,mutations,dispatch,actions</code>,暂时先实现这么多，有精力的话再补充<code>module,map等</code>。</p><h2 id="vuex在vue中的使用"><a href="#vuex在vue中的使用" class="headerlink" title="vuex在vue中的使用"></a>vuex在vue中的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// store.js文件，也就是配置store的文件</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  getter: &#123;</span><br><span class="line">    getterCount(state) &#123;</span><br><span class="line">      return state.count + 5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num) &#123;</span><br><span class="line">      state.count += num; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addAction(state, num) &#123;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        state.commit(&apos;add&apos;, num);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// vue的main.js文件中引入store</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br><span class="line"></span><br><span class="line">// vue具体页面使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h2&gt;state-&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;getter-&gt;&#123;&#123;$store.getter.getterCount&#125;&#125;&lt;/h2&gt;  </span><br><span class="line">    &lt;h2&gt;computed-&gt;&#123;&#123;mill&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;onAdd&quot;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;onAddDispatch&quot;&gt;addDispatch&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    mill() &#123;</span><br><span class="line">      return this.$store.state.count + 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onAdd() &#123;</span><br><span class="line">      this.$store.commit(&apos;add&apos;, 15);</span><br><span class="line">    &#125;,</span><br><span class="line">    onAddDispatch() &#123;</span><br><span class="line">      this.$store.dispatch(&apos;addAction&apos;, 10);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vuex的实现代码"><a href="#vuex的实现代码" class="headerlink" title="vuex的实现代码"></a>vuex的实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">let Vue;</span><br><span class="line">class Store &#123;</span><br><span class="line">  constructor(options = &#123;&#125;) &#123;</span><br><span class="line">    this.options = options;</span><br><span class="line">    this.vueState = new Vue(&#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          state: options.state</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 处理getter操作</span><br><span class="line">    this.getter = &#123;&#125;;</span><br><span class="line">    Object.keys(this.options.getter).forEach(item=&gt; &#123;</span><br><span class="line">      Object.defineProperty(this.getter, item, &#123;</span><br><span class="line">        get: ()=&gt; &#123;</span><br><span class="line">          return this.options.getter[item](this.options.state);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // commit方法和mutations</span><br><span class="line">  commit(type, val) &#123;</span><br><span class="line">    Object.keys(this.options.mutations).forEach(item=&gt; &#123;</span><br><span class="line">      if(item === type) &#123;</span><br><span class="line">        this.options.mutations[item](this.options.state, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // dispatch方法和actions</span><br><span class="line">  dispatch(type, val) &#123;</span><br><span class="line">    Object.keys(this.options.actions).forEach(item=&gt; &#123;</span><br><span class="line">      if(item === type) &#123;</span><br><span class="line">        this.options.actions[item](this, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取Store的state，来源于this.vueState，是Vue的一个实例，可以实现了store.state的数据绑定更新页面</span><br><span class="line">  get state () &#123;</span><br><span class="line">      return this.vueState.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 供Vue.use()调用 </span><br><span class="line">function install(_Vue) &#123;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">      beforeCreate: function () &#123;</span><br><span class="line">          const options = this.$options;</span><br><span class="line">          if (options.store) &#123;</span><br><span class="line">              this.$store = options.store;</span><br><span class="line">          &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">              this.$store = options.parent.$store;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的实现vuex的功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly入门</title>
    <link href="/2020/04/15/WebAssembly%E5%85%A5%E9%97%A8/"/>
    <id>/2020/04/15/WebAssembly入门/</id>
    <published>2020-04-15T03:15:30.000Z</published>
    <updated>2020-04-27T07:53:06.088Z</updated>
    
    <content type="html"><![CDATA[<p>WebAssembly简单实例<br><a id="more"></a></p><h1 id="WebAssembly入门"><a href="#WebAssembly入门" class="headerlink" title="WebAssembly入门"></a>WebAssembly入门</h1><p>WebAssembly是一门新技术，可以将c,c++,java等文件编译成.wasm文件，再被js引入到html中使用。<br>今天我介绍一种简单的方式生成.wasm文件，不需要使用繁琐的系统工具来完成。<br><a href="https://webassembly.studio/" target="_blank" rel="noopener">在线webassembly</a>,这个网站可以在线写c语言代码，在线打包成.wasm文件，还可以看例子，学习具体的使用。<br>贴一个小例子，也是按照这个在线编辑器copy下来的，<a href="https://github.com/jinux7/study-collections/tree/master/webAssembly" target="_blank" rel="noopener">demo点这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebAssembly简单实例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>点击或触摸事件中的相关X,Y介绍</title>
    <link href="/2020/04/13/%E7%82%B9%E5%87%BB%E6%88%96%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3X-Y%E4%BB%8B%E7%BB%8D/"/>
    <id>/2020/04/13/点击或触摸事件中的相关X-Y介绍/</id>
    <published>2020-04-13T01:30:07.000Z</published>
    <updated>2020-04-13T01:54:39.236Z</updated>
    
    <content type="html"><![CDATA[<p>点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍<br><a id="more"></a></p><h1 id="点击或触摸事件中的相关X-Y介绍"><a href="#点击或触摸事件中的相关X-Y介绍" class="headerlink" title="点击或触摸事件中的相关X,Y介绍"></a>点击或触摸事件中的相关X,Y介绍</h1><h2 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h2><p>我们在使用点击事件时，想获取当前鼠标在页面中的位置，可以把事件对象打印出来，看到了下图中的一些相关于x，y的属性。<br><img src="/2020/04/13/点击或触摸事件中的相关X-Y介绍/1.png" alt="img"></p><h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><h3 id="clientX、clientY"><a href="#clientX、clientY" class="headerlink" title="clientX、clientY"></a>clientX、clientY</h3><p>点击位置距离当前body可视区域的x，y坐标</p><h3 id="pageX、pageY"><a href="#pageX、pageY" class="headerlink" title="pageX、pageY"></a>pageX、pageY</h3><p>对于整个页面来说，包括了被卷去的body部分的长度</p><h3 id="screenX、screenY"><a href="#screenX、screenY" class="headerlink" title="screenX、screenY"></a>screenX、screenY</h3><p>点击位置距离当前电脑屏幕的x，y坐标</p><h3 id="offsetX、offsetY"><a href="#offsetX、offsetY" class="headerlink" title="offsetX、offsetY"></a>offsetX、offsetY</h3><p>相对于带有定位的父盒子的x，y坐标</p><h3 id="x、y"><a href="#x、y" class="headerlink" title="x、y"></a>x、y</h3><p>和screenX、screenY一样</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2020/04/13/点击或触摸事件中的相关X-Y介绍/2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>web全景图之pannellum</title>
    <link href="/2020/04/09/web%E5%85%A8%E6%99%AF%E5%9B%BE%E4%B9%8Bpannellum/"/>
    <id>/2020/04/09/web全景图之pannellum/</id>
    <published>2020-04-09T06:32:37.000Z</published>
    <updated>2020-04-09T07:12:53.174Z</updated>
    
    <content type="html"><![CDATA[<p>开发web全景图的工具库pannellum<br><a id="more"></a></p><h1 id="web全景图之pannellum"><a href="#web全景图之pannellum" class="headerlink" title="web全景图之pannellum"></a>web全景图之pannellum</h1><p>最近需要开发一个室内全景图的项目，类似于贝壳的VR看房，直接用three.js开发成本太高，于是在网上找到了pannellum这个工具库，不依赖其它的库，而且还小，使用简单。</p><h2 id="pannellum官网地址"><a href="#pannellum官网地址" class="headerlink" title="pannellum官网地址"></a>pannellum官网地址</h2><p><a href="https://pannellum.org/" target="_blank" rel="noopener">pannellum官网地址</a></p><h2 id="自己做了一个小demo"><a href="#自己做了一个小demo" class="headerlink" title="自己做了一个小demo"></a>自己做了一个小demo</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/pannellum-web%E5%85%A8%E6%99%AF" target="_blank" rel="noopener">demo地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发web全景图的工具库pannellum&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="3D" scheme="/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>AlloyFinger手势库分析</title>
    <link href="/2020/03/26/AlloyFinger%E6%89%8B%E5%8A%BF%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>/2020/03/26/AlloyFinger手势库分析/</id>
    <published>2020-03-26T09:13:31.000Z</published>
    <updated>2020-03-27T01:24:40.048Z</updated>
    
    <content type="html"><![CDATA[<p>移动端手势库AlloyFinger分析<br><a id="more"></a></p><h1 id="AlloyFinger手势库分析"><a href="#AlloyFinger手势库分析" class="headerlink" title="AlloyFinger手势库分析"></a>AlloyFinger手势库分析</h1><p>AlloyFinger这个移动端手势库是腾讯的AlloyTeam团队开发的，体积小，功能强大，简单易用，具体的使用方法见<a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="noopener">AlloyFinger github</a><br>这两天闲暇的时候好好的读了几遍这个库的代码，写好了注释，理解了作者的思路，受益匪浅。<br>注释代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 移动端手势库</span><br><span class="line"> * @desc 分析</span><br><span class="line"> */</span><br><span class="line">;</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  // 获取两点间距离工具函数</span><br><span class="line">  function getLen(v) &#123;</span><br><span class="line">      return Math.sqrt(v.x * v.x + v.y * v.y);</span><br><span class="line">  &#125;</span><br><span class="line">  // dot和getAngle函数用来算两次手势状态之间的夹角, cross函数用来算方向的, getRotateAngle函数算手势真正的角度的</span><br><span class="line">  function dot(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.x + v1.y * v2.y;</span><br><span class="line">  &#125;</span><br><span class="line"> // 求两次手势状态之间的夹角</span><br><span class="line">  function getAngle(v1, v2) &#123;</span><br><span class="line">      var mr = getLen(v1) * getLen(v2);</span><br><span class="line">      if (mr === 0) return 0;</span><br><span class="line">      var r = dot(v1, v2) / mr;</span><br><span class="line">      if (r &gt; 1) r = 1;</span><br><span class="line">      return Math.acos(r);</span><br><span class="line">  &#125;</span><br><span class="line">  // 利用cross结果的正负来判断旋转的方向(大于0为逆时针, 小于0为顺时针)</span><br><span class="line">  function cross(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.y - v2.x * v1.y;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果cross大于0那就是逆时针对于屏幕是正角,对于第一象限是负角,所以 角度 * -1, 然后角度单位换算</span><br><span class="line">  function getRotateAngle(v1, v2) &#123;</span><br><span class="line">      var angle = getAngle(v1, v2);</span><br><span class="line">      if (cross(v1, v2) &gt; 0) &#123;</span><br><span class="line">          angle *= -1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return angle * 180 / Math.PI;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var HandlerAdmin = function(el) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">      this.el = el;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 函数管理构造函数</span><br><span class="line">  function HandlerAdmin(el) &#123;</span><br><span class="line">    this.handlers = [];</span><br><span class="line">    this.el = el;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.add = function(handler) &#123;</span><br><span class="line">    this.handlers.push(handler);</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.del = function(handler) &#123;</span><br><span class="line">    // 如果什么也不传，清空函数数组</span><br><span class="line">    if(!handler) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 比对数组中的函数，并且删除它</span><br><span class="line">    for(var i=this.handlers.length; i&gt;=0; i--) &#123;</span><br><span class="line">      if(this.handlers[i] === handler) &#123;</span><br><span class="line">          this.handlers.splice(i, 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 运行需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.dispatch = function() &#123;</span><br><span class="line">    for(var i=0,len=this.handlers.length; i&lt;len; i++) &#123;</span><br><span class="line">        var handler = this.handlers[i];</span><br><span class="line">        // 运行这些函数的时候，是作为元素的事件触发的，所以，这些函数的this要指向这个元素</span><br><span class="line">        if(typeof handler === &apos;function&apos;) handler.apply(this.el, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化函数管理对象</span><br><span class="line">  function wrapFunc(el, handler) &#123;</span><br><span class="line">    var handlerAdmin = new HandlerAdmin(el);</span><br><span class="line">    handlerAdmin.add(handler);</span><br><span class="line">    return handlerAdmin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 手势库构造函数</span><br><span class="line">  function AlloyFinger(el, option) &#123;</span><br><span class="line">    // 获取添加事件的元素</span><br><span class="line">    this.element = typeof el === &apos;string&apos; ? document.querySelector(el) : el;</span><br><span class="line">    // 因为添加事件后这些方法的执行上下文是this.element，所以给方法bind JinuxFinger这个执行上下文</span><br><span class="line">    this.start = this.start.bind(this);</span><br><span class="line">    this.move = this.move.bind(this);</span><br><span class="line">    this.end = this.end.bind(this);</span><br><span class="line">    this.cancel = this.cancel.bind(this);</span><br><span class="line">    // 给这个元素添加事件</span><br><span class="line">    this.element.addEventListener(&quot;touchstart&quot;, this.start, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchmove&quot;, this.move, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchend&quot;, this.end, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchcancel&quot;, this.cancel, false);</span><br><span class="line">    // 定义一些实例属性</span><br><span class="line">    this.preV = &#123; x: null, y: null &#125;; // 两个手指间的x距离和y距离</span><br><span class="line">    this.pinchStartLen = null; // 捏拽的长度</span><br><span class="line">    this.zoom = 1; // 缩放比例</span><br><span class="line">    this.isDoubleTap = false; // 是否是双击</span><br><span class="line">    var noop = function() &#123;&#125; // 空函数</span><br><span class="line">    // 实例化JinuxFinger时，设置的手势回调函数</span><br><span class="line">    this.rotate = wrapFunc(this.element, option.rotate || noop); // 旋转</span><br><span class="line">    this.touchStart = wrapFunc(this.element, option.touchStart || noop); // 触摸开始  </span><br><span class="line">    this.multipointStart = wrapFunc(this.element, option.multipointStart || noop); // 多个手指触摸开始 </span><br><span class="line">    this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop); // 多个手指触摸结束，如4个手指触摸，屏幕上剩下1个或不剩都会触发</span><br><span class="line">    this.pinch = wrapFunc(this.element, option.pinch || noop); // 两个手指捏拽</span><br><span class="line">    this.swipe = wrapFunc(this.element, option.swipe || noop); // 上下左右滑动，手指离开时触发</span><br><span class="line">    this.tap = wrapFunc(this.element, option.tap || noop); // 无论是单击还是双击都会触发</span><br><span class="line">    this.doubleTap = wrapFunc(this.element, option.doubleTap || noop); // 双击触发</span><br><span class="line">    this.longTap = wrapFunc(this.element, option.longTap || noop); // 单手指长按触发，750ms</span><br><span class="line">    this.singleTap = wrapFunc(this.element, option.singleTap || noop); // 单击触发，250ms</span><br><span class="line">    this.pressMove = wrapFunc(this.element, option.pressMove || noop); // 1个手指屏幕上移动触发</span><br><span class="line">    this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop); // 2个以上手指屏幕上移动触发</span><br><span class="line">    this.touchMove = wrapFunc(this.element, option.touchMove || noop); // 无论几个手指在屏幕上移动都会触发</span><br><span class="line">    this.touchEnd = wrapFunc(this.element, option.touchEnd || noop); // 触摸结束都会触发</span><br><span class="line">    this.touchCancel = wrapFunc(this.element, option.touchCancel || noop); // 事件简单的说是在移动端发生了触摸中断，一般情况下就是优先级比当前活动更高的事件时，才会触发的。比如正在看新闻，手指滑动屏幕的时候，突然来电话，直接中断了触摸事件，跳转到了通话，页面此时就触发了touchcancel事件。这个事件不容易在浏览器的模拟器中模拟，之前我在用电脑的任务栏切换的时候，受到启发，可以试试在浏览器模拟器触摸的同时，按下键盘上的Alt+Tab键，果然触发了touchcancel事件，有兴趣的小伙伴可以试一下。</span><br><span class="line">    </span><br><span class="line">    this._cancelAllHandler = this.cancelAll.bind(this);</span><br><span class="line">    // 触发window的scroll事件时，清除现有touch事件的回调函数执行</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line"></span><br><span class="line">    this.delta = null; // 双击的间隔时间</span><br><span class="line">    this.last = null; // 相对于下一次点击，前一次点击的时间</span><br><span class="line">    this.now = null; // 当前点击保存用的时间，也可以理解为相对于上一次点击，这个是当前点击的时间</span><br><span class="line">    this.tapTimeout = null;</span><br><span class="line">    this.singleTapTimeout = null;</span><br><span class="line">    this.longTapTimeout = null;</span><br><span class="line">    this.swipeTimeout = null;</span><br><span class="line">    this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">    this.preTapPosition = &#123; x: null, y: null &#125;; // 相对于下次点击，前一次点击手指x,y坐标的保存对象</span><br><span class="line">  &#125;</span><br><span class="line">  AlloyFinger.prototype = &#123;</span><br><span class="line">    start: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 屏幕上没有手指则返回</span><br><span class="line">      this.now = Date.now(); // 设置touch开始时的时间</span><br><span class="line">      this.x1 = evt.touches[0].pageX; // 第一个手指触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动</span><br><span class="line">      this.y1 = evt.touches[0].pageY; // 第一个手指触点相对于HTML文档左边沿的的Y坐标</span><br><span class="line">      this.delta = this.now - (this.last || this.now); // 双击的间隔时间</span><br><span class="line">      this.touchStart.dispatch(evt, this.element); // 触发了touchStart回调函数</span><br><span class="line">      if (this.preTapPosition.x !== null) &#123; // 如果不为null，说明之前已经有点击了</span><br><span class="line">          // 判断是否满足手指双击条件</span><br><span class="line">          this.isDoubleTap = (this.delta &gt; 0 &amp;&amp; this.delta &lt;= 250 &amp;&amp; Math.abs(this.preTapPosition.x - this.x1) &lt; 30 &amp;&amp; Math.abs(this.preTapPosition.y - this.y1) &lt; 30);</span><br><span class="line">          if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">      this.preTapPosition.x = this.x1; // 保存当前手指x坐标</span><br><span class="line">      this.preTapPosition.y = this.y1;// 保存当前手指y坐标</span><br><span class="line">      this.last = this.now; // 保存当前时间</span><br><span class="line">      var preV = this.preV, </span><br><span class="line">          len = evt.touches.length; // 现在屏幕上有多少个手指</span><br><span class="line">      if (len &gt; 1) &#123; // 两个手指以上触摸情况</span><br><span class="line">          this._cancelLongTap(); // 清除长按回调函数的执行</span><br><span class="line">          this._cancelSingleTap(); // 清除点击函数的执行</span><br><span class="line">          // 计算两个手指x,y的距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 &#125;;</span><br><span class="line">          // 赋值给preV</span><br><span class="line">          preV.x = v.x; </span><br><span class="line">          preV.y = v.y;</span><br><span class="line">          this.pinchStartLen = getLen(preV); // 计算出两个手指间的距离</span><br><span class="line">          this.multipointStart.dispatch(evt, this.element); // 触发多点触碰函数回调</span><br><span class="line">      &#125;</span><br><span class="line">      this._preventTap = false; // 长按是否回调执行，否 </span><br><span class="line">      this.longTapTimeout = setTimeout(function () &#123; // 长按触发回调函数的定时器</span><br><span class="line">          this.longTap.dispatch(evt, this.element); // 触发长按回调函数</span><br><span class="line">          this._preventTap = true; // 长按是否回调执行，是</span><br><span class="line">      &#125;.bind(this), 750); // 长按是手指按下750ms后触发</span><br><span class="line">  &#125;,</span><br><span class="line">  move: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 没有touches属性则返回</span><br><span class="line">      var preV = this.preV, // 两个手指间距离暂存preV里</span><br><span class="line">          len = evt.touches.length, // 屏幕上的手指数</span><br><span class="line">          currentX = evt.touches[0].pageX, // 屏幕上第一个手指的pageX暂存</span><br><span class="line">          currentY = evt.touches[0].pageY; // 屏幕上第一个手指的pageY暂存</span><br><span class="line">      this.isDoubleTap = false; // 手指移动了，就不是双击了</span><br><span class="line">      if (len &gt; 1) &#123; // 手指大于2个情况</span><br><span class="line">          var sCurrentX = evt.touches[1].pageX, // 屏幕上第2个手指的pageX暂存</span><br><span class="line">              sCurrentY = evt.touches[1].pageY; // 屏幕上第2个手指的pageY暂存</span><br><span class="line">          // 两个手指间距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY &#125;;</span><br><span class="line"></span><br><span class="line">          if (preV.x !== null) &#123;</span><br><span class="line">              if (this.pinchStartLen &gt; 0) &#123; // move之前两指间的距离如果大于0情况</span><br><span class="line">                  evt.zoom = getLen(v) / this.pinchStartLen; // move后的距离/move前的，就是捏拽的比例</span><br><span class="line">                  this.pinch.dispatch(evt, this.element); // 触发捏拽回调，并将zoom属性传递到事件对象里</span><br><span class="line">              &#125;</span><br><span class="line">              // 获取手指移动的角度</span><br><span class="line">              evt.angle = getRotateAngle(v, preV);</span><br><span class="line">              this.rotate.dispatch(evt, this.element); // 触发旋转回调函数</span><br><span class="line">          &#125;</span><br><span class="line">          preV.x = v.x; // move时将现在两指间的距离x赋值给preV</span><br><span class="line">          preV.y = v.y; // move时将现在两指间的距离y赋值给preV</span><br><span class="line"></span><br><span class="line">          if (this.x2 !== null &amp;&amp; this.sx2 !== null) &#123; // 因为是两个手指，所以取的是两个手指中间的值，两次move之间的偏移量,参考下变一个手指情况</span><br><span class="line">              evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;</span><br><span class="line">              evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;</span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          this.twoFingerPressMove.dispatch(evt, this.element); // 两个以上手指移动的事件回调</span><br><span class="line"></span><br><span class="line">          this.sx2 = sCurrentX; // 第二个手指坐标x暂存</span><br><span class="line">          this.sy2 = sCurrentY; // 第二个手指坐标y暂存</span><br><span class="line">      &#125; else &#123; // 单指move情况下</span><br><span class="line">          if (this.x2 !== null) &#123; // 第一次移动this.x2=null的,第二次之后才为true</span><br><span class="line">              evt.deltaX = currentX - this.x2; // x方向两次move事件的差值</span><br><span class="line">              evt.deltaY = currentY - this.y2; // y方向两次move事件的差值</span><br><span class="line"></span><br><span class="line">              //move事件中添加对当前触摸点到初始触摸点的判断，</span><br><span class="line">              //如果曾经大于过某个距离(比如10),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。</span><br><span class="line">              var movedX = Math.abs(this.x1 - this.x2),</span><br><span class="line">                  movedY = Math.abs(this.y1 - this.y2);</span><br><span class="line"></span><br><span class="line">              if(movedX &gt; 10 || movedY &gt; 10)&#123;</span><br><span class="line">                  this._preventTap = true;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          this.pressMove.dispatch(evt, this.element); // 一个手指移动的触发回调</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchMove.dispatch(evt, this.element); // 有移动就触发touchMove事件回调</span><br><span class="line"></span><br><span class="line">      this._cancelLongTap(); // 有移动事件了，清除长按的事件回调</span><br><span class="line">      this.x2 = currentX; // 将当前第一个手指的坐标x复制给this.x2</span><br><span class="line">      this.y2 = currentY; // 将当前第一个手指的坐标y复制给this.y2</span><br><span class="line">      </span><br><span class="line">      if (len &gt; 1) &#123; // 两个以上手指，阻止浏览器默认事件</span><br><span class="line">          evt.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  end: function (evt) &#123;</span><br><span class="line">      if (!evt.changedTouches) return; // end事件触发时，changedTouches为空，则返回</span><br><span class="line">      this._cancelLongTap(); // 取消长按的回调函数</span><br><span class="line">      var self = this; // this暂存在bianliangself</span><br><span class="line">      if (evt.touches.length &lt; 2) &#123; // 目前屏幕上留下的手指0或者1个</span><br><span class="line">          this.multipointEnd.dispatch(evt, this.element); // 调用多指触摸的结束回调</span><br><span class="line">          this.sx2 = this.sy2 = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //swipe</span><br><span class="line">      // this.x2或this.y2有值说明有在屏幕上移动，并且计算移动后离开屏幕时的坐标与this.x1手指刚触摸屏幕时的坐标差值大于30，可以出发swipe事件回调</span><br><span class="line">      if ((this.x2 &amp;&amp; Math.abs(this.x1 - this.x2) &gt; 30) ||</span><br><span class="line">          (this.y2 &amp;&amp; Math.abs(this.y1 - this.y2) &gt; 30)) &#123;</span><br><span class="line">          // 获取滑动的方向  </span><br><span class="line">          evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);</span><br><span class="line">          this.swipeTimeout = setTimeout(function () &#123; // 触发swipe回调函数，加入宏任务队列</span><br><span class="line">              self.swipe.dispatch(evt, self.element);</span><br><span class="line"></span><br><span class="line">          &#125;, 0)</span><br><span class="line">      &#125; else &#123; // 这里说明不是swipe事件，只是点击事件</span><br><span class="line">          this.tapTimeout = setTimeout(function () &#123; // 点击定时器</span><br><span class="line">              if(!self._preventTap)&#123; // 长按事件函数没有执行</span><br><span class="line">                  self.tap.dispatch(evt, self.element); // 执行tap回调</span><br><span class="line">              &#125;</span><br><span class="line">              // trigger double tap immediately</span><br><span class="line">              if (self.isDoubleTap) &#123; // 如果是双击的话</span><br><span class="line">                  self.doubleTap.dispatch(evt, self.element); // 执行双击事件回调</span><br><span class="line">                  self.isDoubleTap = false; // 执行之后设置双击标识为假</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line"></span><br><span class="line">          if (!self.isDoubleTap) &#123; // 如果不是双击操作</span><br><span class="line">              self.singleTapTimeout = setTimeout(function () &#123; // 250ms后执行singleTap事件回调</span><br><span class="line">                  self.singleTap.dispatch(evt, self.element);</span><br><span class="line">              &#125;, 250);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchEnd.dispatch(evt, this.element); // 手指离开都会触发touchEnd事件回调</span><br><span class="line">      // 手指离开后将一些属性重置</span><br><span class="line">      this.preV.x = 0;</span><br><span class="line">      this.preV.y = 0;</span><br><span class="line">      this.zoom = 1;</span><br><span class="line">      this.pinchStartLen = null;</span><br><span class="line">      this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelAll: function () &#123;</span><br><span class="line">      this._preventTap = true; // 阻止tap事件</span><br><span class="line">      clearTimeout(this.singleTapTimeout); // 清除singleTapTimeout定时器</span><br><span class="line">      clearTimeout(this.tapTimeout); // 清除tapTimeout定时器</span><br><span class="line">      clearTimeout(this.longTapTimeout); // 清除longTapTimeout定时器</span><br><span class="line">      clearTimeout(this.swipeTimeout); // 清除swipeTimeout定时器</span><br><span class="line">  &#125;,</span><br><span class="line">  cancel: function (evt) &#123; // cancel事件</span><br><span class="line">      this.cancelAll()</span><br><span class="line">      this.touchCancel.dispatch(evt, this.element); // 触发touchCancel回调</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelLongTap: function () &#123; // 清除longTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.longTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelSingleTap: function () &#123; // 清除singleTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.singleTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 计算swipe的方向函数</span><br><span class="line">  _swipeDirection: function (x1, x2, y1, y2) &#123;</span><br><span class="line">      return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? &apos;Left&apos; : &apos;Right&apos;) : (y1 - y2 &gt; 0 ? &apos;Up&apos; : &apos;Down&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件添加回调函数</span><br><span class="line">  on: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].add(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件删除回调函数</span><br><span class="line">  off: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].del(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 实例销毁函数</span><br><span class="line">  destroy: function() &#123;</span><br><span class="line">      if(this.singleTapTimeout) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      if(this.tapTimeout) clearTimeout(this.tapTimeout);</span><br><span class="line">      if(this.longTapTimeout) clearTimeout(this.longTapTimeout);</span><br><span class="line">      if(this.swipeTimeout) clearTimeout(this.swipeTimeout);</span><br><span class="line"></span><br><span class="line">      this.element.removeEventListener(&quot;touchstart&quot;, this.start);</span><br><span class="line">      this.element.removeEventListener(&quot;touchmove&quot;, this.move);</span><br><span class="line">      this.element.removeEventListener(&quot;touchend&quot;, this.end);</span><br><span class="line">      this.element.removeEventListener(&quot;touchcancel&quot;, this.cancel);</span><br><span class="line"></span><br><span class="line">      this.rotate.del();</span><br><span class="line">      this.touchStart.del();</span><br><span class="line">      this.multipointStart.del();</span><br><span class="line">      this.multipointEnd.del();</span><br><span class="line">      this.pinch.del();</span><br><span class="line">      this.swipe.del();</span><br><span class="line">      this.tap.del();</span><br><span class="line">      this.doubleTap.del();</span><br><span class="line">      this.longTap.del();</span><br><span class="line">      this.singleTap.del();</span><br><span class="line">      this.pressMove.del();</span><br><span class="line">      this.twoFingerPressMove.del()</span><br><span class="line">      this.touchMove.del();</span><br><span class="line">      this.touchEnd.del();</span><br><span class="line">      this.touchCancel.del();</span><br><span class="line"></span><br><span class="line">      this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;</span><br><span class="line"></span><br><span class="line">      window.removeEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 暴露给外部使用</span><br><span class="line">  if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">    module.exports = AlloyFinger;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      window.AlloyFinger = AlloyFinger;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端手势库AlloyFinger分析&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写call,apply,bind函数</title>
    <link href="/2020/03/25/%E6%89%8B%E5%86%99call-apply-bind%E5%87%BD%E6%95%B0/"/>
    <id>/2020/03/25/手写call-apply-bind函数/</id>
    <published>2020-03-25T06:17:43.000Z</published>
    <updated>2020-03-25T07:01:19.519Z</updated>
    
    <content type="html"><![CDATA[<p>手写call,apply,bind函数<br><a id="more"></a></p><h1 id="手写call-apply-bind函数"><a href="#手写call-apply-bind函数" class="headerlink" title="手写call,apply,bind函数"></a>手写call,apply,bind函数</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = arguments[1];</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myApply(testObj, [1, 2, 3]);</span><br></pre></td></tr></table></figure></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  let _this = this</span><br><span class="line">  let args = [...arguments].slice(1)</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 判断是否被当做构造函数使用</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return _this.apply(this, args.concat([...arguments]))</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat([...arguments]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myBind(testObj, 1)(2, 3);</span><br></pre></td></tr></table></figure></p><p>以上就是我们常用的call，apply，bind函数的手写实现，但是，用到了es6的[…arg]结构语法，下面只写一个call实现的es5版本。</p><h2 id="call-es5版"><a href="#call-es5版" class="headerlink" title="call es5版"></a>call es5版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var fnStr = `context.fn(`;</span><br><span class="line">    for(var i=0, len=arg.length; i&lt;len; i++) &#123;</span><br><span class="line">        if(i === (len-1)) &#123;</span><br><span class="line">            fnStr += arg[i];    </span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fnStr += arg[i] + &apos;,&apos;;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += &apos;)&apos;;</span><br><span class="line">    console.log(fnStr);</span><br><span class="line">    var result = eval(fnStr);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写call,apply,bind函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="/2020/03/20/%E6%89%8B%E5%86%99Promise/"/>
    <id>/2020/03/20/手写Promise/</id>
    <published>2020-03-20T05:30:12.000Z</published>
    <updated>2020-03-20T07:20:42.907Z</updated>
    
    <content type="html"><![CDATA[<p>模拟一个Promise功能<br><a id="more"></a></p><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>现在的异步基本上都是用Promise来实现的，用起来很方便，但是，Promise是怎么实现的呢，它的then回调是怎么工作的，带着这些疑问，决定自己实现一个Promise。<br>早在2年前，其实我就实现过一个Promise，不过那个原理比较笨，还用到了定时器循环，后来陆续看了些其他人的写法，还是有点没绕明白，这两天又看了向军老师的实现方式，觉得很好，自己也实现一下。<br>主要的难以理解的地方是then函数的写法，这个地方明白了整个Promise也就理解了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  // 等待状态</span><br><span class="line">  static PENDING = &quot;pending&quot;;</span><br><span class="line">  // 成功状态</span><br><span class="line">  static FULFILLED = &quot;fulfilled&quot;;</span><br><span class="line">  // 拒绝状态</span><br><span class="line">  static REJECTED = &quot;rejected&quot;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态是等待</span><br><span class="line">    this.status = MyPromise.PENDING;</span><br><span class="line">    // 成功值</span><br><span class="line">    this.value = null;</span><br><span class="line">    // 拒绝值</span><br><span class="line">    this.reason = null;</span><br><span class="line">    // then的回调数组</span><br><span class="line">    this.callbacks = [];</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 成功调用函数</span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.status = MyPromise.FULFILLED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onFulfilled(this.value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 拒绝调用函数</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      this.status = MyPromise.REJECTED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onRejected(this.reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then函数</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    if (typeof onFulfilled != &quot;function&quot;) &#123;</span><br><span class="line">      onFulfilled = () =&gt; this.value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof onRejected != &quot;function&quot;) &#123;</span><br><span class="line">      onRejected = () =&gt; this.reason;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链式调用，返回一个MyPromise</span><br><span class="line">    const p = new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">        this.callbacks.push(&#123;</span><br><span class="line">          onFulfilled: (value)=&gt; &#123;</span><br><span class="line">            let result = onFulfilled(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected: (value)=&gt; &#123;</span><br><span class="line">            let result = onRejected(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.FULFILLED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onFulfilled(this.value);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.REJECTED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onRejected(this.reason);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(value instanceof MyPromise) &#123;</span><br><span class="line">        value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.all方法</span><br><span class="line">  static all(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      let values = [];</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            values.push(value);</span><br><span class="line">            if(values.length === promises.length) &#123;</span><br><span class="line">              resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.race方法</span><br><span class="line">  static race(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>demo代码<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99promise" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟一个Promise功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>nodejs环境变量NODE_ENV</title>
    <link href="/2020/03/17/nodejs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE-ENV/"/>
    <id>/2020/03/17/nodejs环境变量NODE-ENV/</id>
    <published>2020-03-17T07:20:52.000Z</published>
    <updated>2020-03-17T08:14:52.457Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs环境变量NODE_ENV的设置和获取<br><a id="more"></a></p><h1 id="nodejs环境变量NODE-ENV"><a href="#nodejs环境变量NODE-ENV" class="headerlink" title="nodejs环境变量NODE_ENV"></a>nodejs环境变量NODE_ENV</h1><p>我们在使用webpack打包的时候，会根据环境变量的不同做各种操作，那么，环境变量是如何设置和获取的呢？<br>首先说一下，在命令行中设置的环境变量是临时的，当命令行关闭后就没有了，要想持久化的设置环境变量，只能到我的电脑，属性，高级，环境变量里设置。</p><p>首先，创建一个app.js的文件，内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.NODE_ENV);</span><br></pre></td></tr></table></figure></p><p>我们把环境变量打印出来看看。<br>在命令行下(window系统的cmd可以，powershell和git bash不行)，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set NODE_ENV=pro &amp;&amp; node app.js</span><br></pre></td></tr></table></figure></p><p>打印出<code>pro</code><br>如果想在powershell和git bash都可以使用，那就得利用npm，在package.json中的scripts里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;pro&quot;: &quot;set NODE_ENV=pro &amp;&amp; node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>利用npm可以获取NODE_ENV的值。<br>这种方法的不足是，<code>set NODE_ENV=pro</code>是window的方式，而linux和ios是<code>export NODE_ENV=&#39;pro&#39;</code>,为了一套命令的兼容性，<br>我们可以使用<code>cross-env</code>这个nodejs模块，使用方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>好了，我们已经可以获取NODE_ENV环境变量了。<br>再介绍一个可以获取命令行参数的方便方法，<code>process.env.npm_config_argv</code><br>看名字就知道，只能在npm命令下使用，我们来看看具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.npm_config_argv);</span><br></pre></td></tr></table></figure></p><p>当我们执行<code>npm run dev</code><br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;remain&quot;:[],&quot;cooked&quot;:[&quot;run&quot;,&quot;dev&quot;],&quot;original&quot;:[&quot;run&quot;,&quot;dev&quot;]&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以分析是dev还是pro来处理不同操作。<br>其实，我们想做的莫非就是利用命令行中不同的参数做不同的操作而已，nodejs有一个<code>process.argv</code>属性，可以获取命令行下的参数，来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.argv);</span><br></pre></td></tr></table></figure></p><p>我们在命令行下执行：<code>node app.js dev pro</code>。<br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;C:\\Program Files\\nodejs\\node.exe&apos;,</span><br><span class="line">  &apos;C:\\Jinux\\test\\nodejs-env\\app.js&apos;,</span><br><span class="line">  &apos;dev&apos;,</span><br><span class="line">  &apos;pro&apos; ]</span><br></pre></td></tr></table></figure></p><p>我们还是可以根据命令行下的参数做不同的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs环境变量NODE_ENV的设置和获取&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
