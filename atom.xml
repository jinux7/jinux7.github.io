<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2023-01-06T02:32:30.454Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端编译原理-VUE模板编译概览</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-VUE%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%A6%82%E8%A7%88/"/>
    <id>/2023/01/04/前端编译原理-VUE模板编译概览/</id>
    <published>2023-01-04T09:01:05.000Z</published>
    <updated>2023-01-06T02:32:30.454Z</updated>
    
    <content type="html"><![CDATA[<p>VUE模板编译工作流程简介<br><a id="more"></a></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>VUE的模板是要被转换成js渲染函数，在运行时执行的。</p><h2 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h2><p><code>模板</code>-&gt;<code>parse(str)</code>-&gt;<code>模板AST</code>-&gt;<code>transform(ast)</code>-&gt;<code>javascript AST</code>-&gt;<code>generate(JSAST)</code>-&gt;<code>渲染函数</code></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><blockquote><p>词法分析是把字符串解析成tokens</p></blockquote><p>模板字符串转化后的tokens：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;div&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;text&apos;, content: &apos;Vue&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;text&apos;, content: &apos;Template&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;div&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>实现code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">const State = &#123;</span><br><span class="line">  initial: 1,</span><br><span class="line">  tagOpen: 2,</span><br><span class="line">  tagName: 3,</span><br><span class="line">  text: 4,</span><br><span class="line">  tagEnd: 5,</span><br><span class="line">  tagEndName: 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isAlpha(char) &#123;</span><br><span class="line">  return char &gt;= &apos;a&apos; &amp;&amp; char &lt;= &apos;z&apos; || char &gt;= &apos;A&apos; &amp;&amp; char &lt;= &apos;Z&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tokenize(str) &#123;</span><br><span class="line">  let currentState = State.initial</span><br><span class="line">  const chars = []</span><br><span class="line">  const tokens = []</span><br><span class="line">  while(str) &#123;</span><br><span class="line">    const char = str[0]</span><br><span class="line">    switch (currentState) &#123;</span><br><span class="line">      case State.initial:</span><br><span class="line">        if (char === &apos;&lt;&apos;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.text</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagOpen:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;/&apos;) &#123;</span><br><span class="line">          currentState = State.tagEnd</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&gt;&apos;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;tag&apos;,</span><br><span class="line">            name: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.text:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&lt;&apos;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;text&apos;,</span><br><span class="line">            content: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagEnd:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagEndName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagEndName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&gt;&apos;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;tagEnd&apos;,</span><br><span class="line">            name: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><blockquote><p>语法分析是把词法分析出来的tokens解析成AST</p></blockquote><p>模板AST：<br><a href="#模板AST">⬇⬇⬇</a><br>实现code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function parse(str) &#123;</span><br><span class="line">  const tokens = tokenize(str)</span><br><span class="line"></span><br><span class="line">  const root = &#123;</span><br><span class="line">    type: &apos;Root&apos;,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;</span><br><span class="line">  const elementStack = [root]</span><br><span class="line"></span><br><span class="line">  while (tokens.length) &#123;</span><br><span class="line">    const parent = elementStack[elementStack.length - 1]</span><br><span class="line">    const t = tokens[0]</span><br><span class="line">    switch (t.type) &#123;</span><br><span class="line">      case &apos;tag&apos;:</span><br><span class="line">        const elementNode = &#123;</span><br><span class="line">          type: &apos;Element&apos;,</span><br><span class="line">          tag: t.name,</span><br><span class="line">          children: []</span><br><span class="line">        &#125;</span><br><span class="line">        parent.children.push(elementNode)</span><br><span class="line">        elementStack.push(elementNode)</span><br><span class="line">        break</span><br><span class="line">      case &apos;text&apos;:</span><br><span class="line">        const textNode = &#123;</span><br><span class="line">          type: &apos;Text&apos;,</span><br><span class="line">          content: t.content</span><br><span class="line">        &#125;</span><br><span class="line">        parent.children.push(textNode)</span><br><span class="line">        break</span><br><span class="line">      case &apos;tagEnd&apos;:</span><br><span class="line">        elementStack.pop()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    tokens.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模板AST"><a href="#模板AST" class="headerlink" title="模板AST"></a>模板AST</h3><blockquote><p>通过parse步骤后得到的模板AST：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Root&quot;,</span><br><span class="line">  &quot;children&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">      &quot;tag&quot;: &quot;div&quot;,</span><br><span class="line">      &quot;children&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">          &quot;tag&quot;: &quot;p&quot;,</span><br><span class="line">          &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Text&quot;,</span><br><span class="line">              &quot;content&quot;: &quot;Vue&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">          &quot;tag&quot;: &quot;p&quot;,</span><br><span class="line">          &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Text&quot;,</span><br><span class="line">              &quot;content&quot;: &quot;Template&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><blockquote><p>将模板AST转换成javascript AST，此处使用了插件结构，处理转换节点的函数是单独出来的</p></blockquote><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function transform(ast) &#123;</span><br><span class="line">  const context = &#123;</span><br><span class="line">    currentNode: null,</span><br><span class="line">    parent: null,</span><br><span class="line">    replaceNode(node) &#123;</span><br><span class="line">      context.currentNode = node</span><br><span class="line">      context.parent.children[context.childIndex] = node</span><br><span class="line">    &#125;,</span><br><span class="line">    removeNode() &#123;</span><br><span class="line">      if (context.parent) &#123;</span><br><span class="line">        context.parent.children.splice(context.childIndex, 1)</span><br><span class="line">        context.currentNode = null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nodeTransforms: [</span><br><span class="line">      transformRoot,</span><br><span class="line">      transformElement,</span><br><span class="line">      transformText</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用 traverseNode 完成转换</span><br><span class="line">  traverseNode(ast, context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseNode(ast, context) &#123;</span><br><span class="line">  context.currentNode = ast</span><br><span class="line"></span><br><span class="line">  const exitFns = []</span><br><span class="line">  const transforms = context.nodeTransforms</span><br><span class="line">  for (let i = 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">    const onExit = transforms[i](context.currentNode, context)</span><br><span class="line">    if (onExit) &#123;</span><br><span class="line">      exitFns.push(onExit)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!context.currentNode) return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const children = context.currentNode.children</span><br><span class="line">  if (children) &#123;</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      context.parent = context.currentNode</span><br><span class="line">      context.childIndex = i</span><br><span class="line">      traverseNode(children[i], context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let i = exitFns.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    exitFns[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插件工具函数"><a href="#插件工具函数" class="headerlink" title="插件工具函数"></a>插件工具函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">function transformText(node) &#123;</span><br><span class="line">  if (node.type !== &apos;Text&apos;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node.jsNode = createStringLiteral(node.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function transformElement(node) &#123;</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    if (node.type !== &apos;Element&apos;) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const callExp = createCallExpression(&apos;h&apos;, [</span><br><span class="line">      createStringLiteral(node.tag)</span><br><span class="line">    ])</span><br><span class="line">    node.children.length === 1</span><br><span class="line">      ? callExp.arguments.push(node.children[0].jsNode)</span><br><span class="line">      : callExp.arguments.push(</span><br><span class="line">        createArrayExpression(node.children.map(c =&gt; c.jsNode))</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    node.jsNode = callExp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformRoot(node) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    if (node.type !== &apos;Root&apos;) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const vnodeJSAST = node.children[0].jsNode</span><br><span class="line"></span><br><span class="line">    node.jsNode = &#123;</span><br><span class="line">      type: &apos;FunctionDecl&apos;,</span><br><span class="line">      id: &#123; type: &apos;Identifier&apos;, name: &apos;render&apos; &#125;,</span><br><span class="line">      params: [],</span><br><span class="line">      body: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &apos;ReturnStatement&apos;,</span><br><span class="line">          return: vnodeJSAST</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createStringLiteral(value) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;StringLiteral&apos;,</span><br><span class="line">    value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createIdentifier(name) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;Identifier&apos;,</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createArrayExpression(elements) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;ArrayExpression&apos;,</span><br><span class="line">    elements</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCallExpression(callee, arguments) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;CallExpression&apos;,</span><br><span class="line">    callee: createIdentifier(callee),</span><br><span class="line">    arguments</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="javascript-AST"><a href="#javascript-AST" class="headerlink" title="javascript AST"></a>javascript AST</h3><blockquote><p>模板字符串经过转换后生成的javascript AST:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;FunctionDecl&quot;,</span><br><span class="line">  &quot;id&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;render&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;params&quot;: [],</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line">      &quot;return&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">        &quot;callee&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;arguments&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;div&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ArrayExpression&quot;,</span><br><span class="line">            &quot;elements&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">                &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;h&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;p&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;Vue&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">                &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;h&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;p&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;Template&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><blockquote><p>得到转换后的javascript AST后，生成渲染函数字符串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">function generate(node) &#123;</span><br><span class="line">  const context = &#123;</span><br><span class="line">    code: &apos;&apos;,</span><br><span class="line">    push(code) &#123;</span><br><span class="line">      context.code += code</span><br><span class="line">    &#125;,</span><br><span class="line">    currentIndent: 0,</span><br><span class="line">    newline() &#123;</span><br><span class="line">      context.code += &apos;\n&apos; + `  `.repeat(context.currentIndent)</span><br><span class="line">    &#125;,</span><br><span class="line">    indent() &#123;</span><br><span class="line">      context.currentIndent++</span><br><span class="line">      context.newline()</span><br><span class="line">    &#125;,</span><br><span class="line">    deIndent() &#123;</span><br><span class="line">      context.currentIndent--</span><br><span class="line">      context.newline()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  genNode(node, context)</span><br><span class="line"></span><br><span class="line">  return context.code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNode(node, context) &#123;</span><br><span class="line">  switch (node.type) &#123;</span><br><span class="line">    case &apos;FunctionDecl&apos;:</span><br><span class="line">      genFunctionDecl(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;ReturnStatement&apos;:</span><br><span class="line">      genReturnStatement(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;CallExpression&apos;:</span><br><span class="line">      genCallExpression(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;StringLiteral&apos;:</span><br><span class="line">      genStringLiteral(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;ArrayExpression&apos;:</span><br><span class="line">      genArrayExpression(node, context)</span><br><span class="line">      break</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genFunctionDecl(node, context) &#123;</span><br><span class="line">  const &#123; push, indent, deIndent &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`function $&#123;node.id.name&#125; `)</span><br><span class="line">  push(`(`)</span><br><span class="line">  genNodeList(node.params, context)</span><br><span class="line">  push(`) `)</span><br><span class="line">  push(`&#123;`)</span><br><span class="line">  indent()</span><br><span class="line"></span><br><span class="line">  node.body.forEach(n =&gt; genNode(n, context))</span><br><span class="line"></span><br><span class="line">  deIndent()</span><br><span class="line">  push(`&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNodeList(nodes, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    const node = nodes[i]</span><br><span class="line">    genNode(node, context)</span><br><span class="line">    if (i &lt; nodes.length - 1) &#123;</span><br><span class="line">      push(&apos;, &apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genReturnStatement(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`return `)</span><br><span class="line">  genNode(node.return, context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genCallExpression(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  const &#123; callee, arguments: args &#125; = node</span><br><span class="line">  push(`$&#123;callee.name&#125;(`)</span><br><span class="line">  genNodeList(args, context)</span><br><span class="line">  push(`)`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genStringLiteral(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`&apos;$&#123;node.value&#125;&apos;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genArrayExpression(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  push(&apos;[&apos;)</span><br><span class="line">  genNodeList(node.elements, context)</span><br><span class="line">  push(&apos;]&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><blockquote><p>经过transform转换后生成的渲染函数字符串：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function render () &#123;</span><br><span class="line">  return h(&apos;div&apos;, [h(&apos;p&apos;, &apos;Vue&apos;), h(&apos;p&apos;, &apos;Template&apos;)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function compile(template) &#123;</span><br><span class="line">  // 模板AST</span><br><span class="line">  const ast = parse(template);</span><br><span class="line">  // 将模板AST转换为javascript AST</span><br><span class="line">  transform(ast);</span><br><span class="line">  // 代码生成</span><br><span class="line">  const code = generate(ast.jsNode);</span><br><span class="line"></span><br><span class="line">  return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本篇内容摘取《VUE设计与实现》的第15章，简单的介绍了前端模板的编译解析步骤。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/VUE%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">本篇code</a><br><a href="https://github.com/HcySunYang/code-for-vue-3-book" target="_blank" rel="noopener">VUE设计与实现code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VUE模板编译工作流程简介&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-有限状态机</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>/2023/01/04/前端编译原理-有限状态机/</id>
    <published>2023-01-04T03:34:48.000Z</published>
    <updated>2023-01-04T07:01:49.030Z</updated>
    
    <content type="html"><![CDATA[<p>有限状态机在词法分析中的应用<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。</p></blockquote><p>有限状态机在计算机领域的应用非常多，本篇文章主要介绍下在词法解析方面的应用。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>将字符串<br><code>100+200-300</code><br>转化成如下tokens<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;100&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Punctuator&apos;, value: &apos;+&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;200&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Punctuator&apos;, value: &apos;-&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;300&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 四则运算字符串</span><br><span class="line">const inputStr = &apos;100+200-300&apos;;</span><br><span class="line"></span><br><span class="line">// 匹配数字的正则</span><br><span class="line">const NumReg = /[0-9]/</span><br><span class="line">// 匹配标点符号的正则规则</span><br><span class="line">const PunctuatorReg = /[\+\-\*\/]/</span><br><span class="line"></span><br><span class="line">// 最终输出的所有tokens合集</span><br><span class="line">const tokens = []</span><br><span class="line"></span><br><span class="line">// 当前状态机中正在处理的token</span><br><span class="line">let currentToken = &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 词法分析函数</span><br><span class="line"> * @param &#123;*&#125; inputStr </span><br><span class="line"> * @returns tokens</span><br><span class="line"> */</span><br><span class="line">function stateMachine(inputStr) &#123;</span><br><span class="line">  // 定义状态机的初始状态判断函数</span><br><span class="line">  let state = start</span><br><span class="line">  // 依次迭代输入的字符串</span><br><span class="line">  // while(inputStr) &#123;</span><br><span class="line">  //   state = state(inputStr[0]);</span><br><span class="line">  //   inputStr = inputStr.slice(1);</span><br><span class="line">  // &#125;</span><br><span class="line">  inputStr.split(&quot;&quot;).forEach(char =&gt; &#123;</span><br><span class="line">      // 此处的char是每一个字符</span><br><span class="line">      // 调用state函数 并且传入char</span><br><span class="line">      state = state(char)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 遍历结束后仍然需要发送一次最后</span><br><span class="line">  tokens.push(currentToken)</span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 状态机初始函数</span><br><span class="line"> * @param &#123;*&#125; char 输入的字符</span><br><span class="line"> * @return &#123;*&#125; </span><br><span class="line"> */</span><br><span class="line">function start (char) &#123;</span><br><span class="line">  if(NumReg.test(char)) &#123;</span><br><span class="line">      // 首个输入的char是数字 初始化token为numeric</span><br><span class="line">      currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125;</span><br><span class="line">      // 返回的是一个nunmer的处理函数</span><br><span class="line">      return numeric</span><br><span class="line">  &#125;else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">      // 首个输入的char是标点符号 初始化current为punctuator</span><br><span class="line">      currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">      // 返回的是一个punctuator的处理函数</span><br><span class="line">      return punctuator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数字处理函数</span><br><span class="line">function numeric(char) &#123;</span><br><span class="line">  if(NumReg.test(char)) &#123;</span><br><span class="line">      // 如果当前输入是数字 不分词 连续累加value值</span><br><span class="line">      currentToken.value += char</span><br><span class="line">      // 返回numeric函数赋给state</span><br><span class="line">      return numeric</span><br><span class="line">  &#125;else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">      // 如果是标点符号 分词</span><br><span class="line">      // 如果当前输入的标点符号 进行分词</span><br><span class="line">      // 首先将旧的token输入到tokens中</span><br><span class="line">      emitToken(currentToken)</span><br><span class="line">      // 修改当前token</span><br><span class="line">      currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">      // 返回punctuator处理函数</span><br><span class="line">      return punctuator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标点符号状态处理函数</span><br><span class="line">function punctuator(char) &#123;</span><br><span class="line">  // 无论如何都要发射 因为标点符号在分词阶段不会被拼接起来</span><br><span class="line">  emitToken(currentToken)</span><br><span class="line">  if (NumReg.test(char)) &#123;</span><br><span class="line">    currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125;</span><br><span class="line">    return numeric</span><br><span class="line">  &#125; else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">    currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">    return punctuator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return punctuator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将token放入tokens中</span><br><span class="line">function emitToken(token) &#123;</span><br><span class="line">  // 重制 currentToken</span><br><span class="line">  currentToken = &#123; type: &apos;&apos;, value: &apos;&apos; &#125;</span><br><span class="line">  // 将上一次传入的token参数保存到最终输入的tokens中</span><br><span class="line">  tokens.push(token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(stateMachine(inputStr));</span><br></pre></td></tr></table></figure><h3 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 四则运算字符串</span><br><span class="line">const inputStr = &apos;100+200-300&apos;;</span><br><span class="line">// 匹配数字的正则</span><br><span class="line">const NumReg = /[0-9]/</span><br><span class="line">// 匹配标点符号的正则规则</span><br><span class="line">const PunctuatorReg = /[\+\-\*\/]/</span><br><span class="line">// 最终输出的所有tokens合集</span><br><span class="line">const tokens = []</span><br><span class="line">// 当前状态机中正在处理的token</span><br><span class="line">let currentToken = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">let type = &apos;start&apos;;</span><br><span class="line">function start(char, i, str) &#123;</span><br><span class="line">  if( type===&apos;start&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    type = &apos;Numberic&apos;;</span><br><span class="line">    currentToken += char;</span><br><span class="line">  &#125;else if(type===&apos;Numberic&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    currentToken += char;</span><br><span class="line">  &#125;else if(type===&apos;Numberic&apos;&amp;&amp;PunctuatorReg.test(char)) &#123;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Numberic&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    type = &apos;Punctuator&apos;;</span><br><span class="line">    currentToken = char;</span><br><span class="line">  &#125;else if(type===&apos;Punctuator&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    type = &apos;Numberic&apos;;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Punctuator&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    currentToken = char;</span><br><span class="line">  &#125;</span><br><span class="line">  if(type===&apos;Numberic&apos;&amp;&amp;i===(str.length-1)) &#123;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Numberic&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    currentToken = &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stateMachine(str) &#123;</span><br><span class="line">  for(let i=0; i&lt;str.length; i++) &#123;</span><br><span class="line">    start(str[i], i, str);</span><br><span class="line">  &#125;</span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line">console.log(stateMachine(inputStr));</span><br></pre></td></tr></table></figure><p>上面两个案例结果一样，但是过程不同。案例一的状态变化是以返回函数的形式，对代码进行了抽象解耦。案例二有点面向过程的写法，代码冗余，逻辑复杂的话，肯定是第一种方法好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章只是简单的介绍下，有限状态机在编译的词法分析阶段的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有限状态机在词法分析中的应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-编译器流程</title>
    <link href="/2022/12/30/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
    <id>/2022/12/30/前端编译原理-编译器流程/</id>
    <published>2022-12-30T02:44:56.000Z</published>
    <updated>2022-12-30T08:53:48.922Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍前端编译器的工作流程<br><a id="more"></a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本篇文章主要针对前端的JSX语法标签进行编译解析。<br>接下来将使用 Esprima 结合一个简单的 Demo 来实现串通整个编译器的工作流程。</p><h2 id="解析阶段-Parsing"><a href="#解析阶段-Parsing" class="headerlink" title="解析阶段 (Parsing)"></a>解析阶段 (Parsing)</h2><p>首先，在编译器的初始阶段会接受一段代码，通常会是一串字符串。<br>如下JSX代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>编译器拿到这段字符串代码之后会进入解析阶段，在解析阶段主要会做以下两件事：词法分析和语法分析</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>当编译器接受到上边的字符串时，首先会将传入的字符串按照词法效果分割成为一系列被称为 Token 的东西，这一步通常被称为分词。<br>先来看看利用 Esprima Api 查看将上述代码进行词法分析后的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parse1.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 配置支持jsx和tokens 利用parseScript Api 打印对应的tokens</span><br><span class="line">const &#123; tokens &#125; = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true, tokens: true &#125;);</span><br><span class="line">console.log(tokens,&apos;tokens&apos;)</span><br></pre></td></tr></table></figure></p><p>此时上方的语句经过词法分析会被一步一步拆分成为这样的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;id&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;=&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;String&quot;,&quot;value&quot;: &quot;\&quot;app\&quot;&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Hello&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Jue Jin&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到针对上方传入的 JSX 语法被解析成为了一个 Token 组成的数组，数组中每一个对象即代表一个 Token 。<br>每个 Token 都是拥有对应的 type 属性表示它的类型以及 value 属性表示它的值。<br>这一步通过解析阶段的词法分析将传入的代码分割成为了一个个 Token ，通常使用有限状态机是词法分析的最佳途径。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上一步通过词法分析将输入的代码分割成为了一个 tokens 的数组，在这之后需要将 tokens 进行语法分析从而转化成为真正的抽象语法树（AST）形式。<br>所谓抽象语法树，你可以将它理解成为一颗圣诞树。上述 tokens 中每一个 token 都可以看作成为该圣诞树中的一个节点。<br>语法分析正式将上述分成的每个 Token 抽象成为一棵树，从而描述每个 Token 节点之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parse2.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 调用parseScript获得输入代码生成的抽象语法树</span><br><span class="line">const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);</span><br><span class="line">console.log(ast, &apos;ast&apos;)</span><br></pre></td></tr></table></figure></p><p>上述的 Token 在经过语法分析后会变成这样的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;body&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;: &quot;ExpressionStatement&quot;,</span><br><span class="line">    &quot;expression&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">      &quot;openingElement&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;div&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;selfClosing&quot;: false,</span><br><span class="line">        &quot;attributes&quot;: [&#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXAttribute&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;id&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;value&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;app&quot;,</span><br><span class="line">            &quot;raw&quot;: &quot;\&quot;app\&quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;children&quot;: [&#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">        &quot;openingElement&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;p&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;selfClosing&quot;: false,</span><br><span class="line">          &quot;attributes&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;children&quot;: [&#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXText&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;Hello&quot;,</span><br><span class="line">          &quot;raw&quot;: &quot;Hello&quot;</span><br><span class="line">        &#125;],</span><br><span class="line">        &quot;closingElement&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXClosingElement&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;p&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXText&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;Jue Jin&quot;,</span><br><span class="line">        &quot;raw&quot;: &quot;Jue Jin&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      &quot;closingElement&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXClosingElement&quot;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;div&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所谓的语法分析阶段其实就是将 Tokens 经过一系列语法分析成为这颗树，树中的每个节点都会保存各自节点对应的信息。<br>同时因为树形的数据结构也很好的反应出了各个节点之间的关系。</p><h2 id="转化阶段-Transformaiton"><a href="#转化阶段-Transformaiton" class="headerlink" title="转化阶段 (Transformaiton)"></a>转化阶段 (Transformaiton)</h2><p>编译器首先经过转移阶段后将输入的代码转变成为 AST 。之后会进入转化阶段，所谓转化阶段本质上就是对于抽象语法树的一个深度遍历过程。<br>在转化阶段，会遍历这颗抽象语法树从而对于匹配节点进行增删改查从而修改树形结构。<br>比如想为 p 节点上添加一个 id 为 text 的属性，那么此时在遍历 AST 的过程中遍历到对应节点时修改对应的节点属性即可，当然也可以直接粗暴的替换整个节点。</p><blockquote><p>关于 Estraverse ，它是针对 Esprima 生成的抽象语法树进行深度遍历的一个工具库。因为 Estraverse 这个库不支持 JSX 语法，所以这里使用它的一个拓展工具库 estraverse-fb 来实现 JSX 转化的抽象语法树的遍历。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// transform.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 深度遍历AST的工具库</span><br><span class="line">const esTraverseFb = require(&apos;estraverse-fb&apos;)</span><br><span class="line">// 生成AST节点的工具</span><br><span class="line">const &#123; builders &#125; = require(&apos;ast-types&apos;)</span><br><span class="line"></span><br><span class="line">const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);</span><br><span class="line"></span><br><span class="line">// 深度优先的方式</span><br><span class="line">esTraverseFb.traverse(ast, &#123;</span><br><span class="line">  // 进入每个节点时都会出发enter函数</span><br><span class="line">  enter: function (node) &#123;</span><br><span class="line">    const &#123; type, openingElement &#125; = node</span><br><span class="line">    // 判断当前进入的节点是否是匹配的p节点</span><br><span class="line">    if (type === &apos;JSXElement&apos; &amp;&amp; openingElement.name.name === &apos;p&apos;) &#123;</span><br><span class="line">      // 生成当前需要添加的属性节点</span><br><span class="line">      const attribute = builders.jsxAttribute(</span><br><span class="line">        // 第一个参数是name</span><br><span class="line">        builders.jsxIdentifier(&apos;id&apos;),</span><br><span class="line">        // 第二个参数是value</span><br><span class="line">        builders.literal(&apos;text&apos;)</span><br><span class="line">      )</span><br><span class="line">      // 为该节点的开始标签中添加生成的属性 id=&apos;text&apos;</span><br><span class="line">      openingElement.attributes.push(attribute)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 离开每个节点时会触发leave函数</span><br><span class="line">  leave: function () &#123;</span><br><span class="line">    // nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ast);</span><br></pre></td></tr></table></figure><p>此时经过上述的转化，我们更改了原本的 AST 结构。我们将原始的 p 标签对应的节点修改成为了这样的结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">  &quot;openingElement&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;p&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;selfClosing&quot;: false,</span><br><span class="line">    // 这里我们为attributes中添加了一个属性节点</span><br><span class="line">    &quot;attributes&quot;: [&#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">        &quot;loc&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">        &quot;comments&quot;: null,</span><br><span class="line">        &quot;optional&quot;: false,</span><br><span class="line">        &quot;typeAnnotation&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;value&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;loc&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">        &quot;comments&quot;: null,</span><br><span class="line">        &quot;regex&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;loc&quot;: null,</span><br><span class="line">      &quot;type&quot;: &quot;JSXAttribute&quot;,</span><br><span class="line">      &quot;comments&quot;: null</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生成阶段-Code-Generation"><a href="#生成阶段-Code-Generation" class="headerlink" title="生成阶段 (Code Generation)"></a>生成阶段 (Code Generation)</h2><p>上述经过解析阶段 (Parsing) 将输入的字符串转化成了抽象语法树 AST 结构。<br>之后经过转化阶段 (Transformaiton) 对于生成的抽象语法树进行深度遍历节点，从而对于某些节点进行了修改。‘<br>此时编译器拥有了经过处理后的抽象语法树，此时需要做的当然是将所谓的树形结构的抽象语法树转化成为新的代码。<br>这一步通常称为生成阶段(Code Generation)：通过抽象语法树反向转化成为生成的代码，此时最新的代码是根据修改后的 AST 生成的代码。<br>在生成阶段本质上就是遍历抽象语法树，根据抽象语法树上每个节点的类型和属性递归调用从而生成对应的字符串代码。<br>在代码生成阶段，可以借助 EscodeGen 将 AST 转化成为新的字符串代码。</p><blockquote><p>因为 EscodeGen 对于 JSX 语法并不支持，所以这里具体就不详细演示用法了，有兴趣的朋友可以自行尝试。</p></blockquote><p>上方将代码修改的抽象语法树会生成新的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;p id=&quot;text&quot;&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，一次编译器工作流程中包括解析、转化、生成这三个步骤。<br>如果自己想实现，请参考本站的<a href="/2020/07/20/the-super-tiny-compiler/">【tiny编译工具】</a><br><a href="https://github.com/jinux7/study-collections/tree/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">上面例子代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍前端编译器的工作流程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>\r与\n区别</title>
    <link href="/2022/12/26/r%E4%B8%8E-n%E5%8C%BA%E5%88%AB/"/>
    <id>/2022/12/26/r与-n区别/</id>
    <published>2022-12-26T06:30:06.000Z</published>
    <updated>2022-12-26T06:46:54.103Z</updated>
    
    <content type="html"><![CDATA[<p>\r回车与\n换行的区别<br><a id="more"></a></p><h2 id="回车和换行来源"><a href="#回车和换行来源" class="headerlink" title="回车和换行来源"></a>回车和换行来源</h2><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意儿，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。<br>这就是”回车”和”换行”的来历，从它们的英语名字上也可以看出一二。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>\r是回车，英文是Carriage return，缩写是CR，作用：使光标到行首。<br>\n是换行，英文是New line/line feed，缩写是LF，作用：使光标下移一行。</p><blockquote><p>如果用过机械打字机，就知道回车和换行的区别了。<br>回车就是把水平位置复位，不卷动滚筒。<br>换行就是把滚筒卷一格，不改变水平位置。<br>我们平时所说的键盘Enter键换行实则应该叫做叫做回车换行(\r\n)</p></blockquote><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>✪ Windows系统里面，每行结尾是 回车+换行(CR+LF)，即“\r\n”；<br>✪ Unix系统里，每行结尾只有 换行CR，即“\n”；<br>✪ Mac系统里，每行结尾是 回车CR 即’\r’；<br>直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p><h2 id="兼容处理"><a href="#兼容处理" class="headerlink" title="兼容处理"></a>兼容处理</h2><p>在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。<br>在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化。<br>如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;\r回车与\n换行的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>javascript常用中英文惯译法</title>
    <link href="/2022/12/06/javascript%E5%B8%B8%E7%94%A8%E4%B8%AD%E8%8B%B1%E6%96%87%E6%83%AF%E8%AF%91%E6%B3%95/"/>
    <id>/2022/12/06/javascript常用中英文惯译法/</id>
    <published>2022-12-06T03:07:18.000Z</published>
    <updated>2022-12-07T01:57:58.553Z</updated>
    
    <content type="html"><![CDATA[<p>javascript常用中英文惯译法<br><a id="more"></a></p><h2 id="语法或词法分析"><a href="#语法或词法分析" class="headerlink" title="语法或词法分析"></a>语法或词法分析</h2><blockquote><p>标识符（identifier）<br>标签（label）<br>关键字，保留字（keyword,reserved words）<br>符号（symbol）<br>标记，记号（token）<br>数据类型（types,data types）<br>无类型的（untype-）<br>变量（variable）<br>声明（declare）<br>赋值（assignment）<br>解构赋值（destructuring assignment）<br>未赋值变量（unassigned variable）<br>未声明变量（undeclared variable）<br>值（values）<br>常量，常数，常值（constant,const）<br>直接量，字面量（literal,literal constant,manifest constant）<br>指数计数法，科学计数法（exponential notation）<br>定点计数法（fixed-point notation）<br>代码逻辑行，物理行（logical line,physical line）<br>语句（statements）<br>语句块（statement block）<br>简单语句（simple statements）<br>单行语句（single line statements）<br>复合语句（compound statements）<br>条件（condition）<br>表达式（expression）<br>一元运算符，单目运算符（unary operator）<br>二元运算符（binary operator）<br>运算符优先级（precedence）<br>运算符，操作符，操作数（operator）</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数组（array）<br>关联数组（associative array）<br>索引数组（index array）<br>多维数组（multidimensional array）<br>动态数组（dynamic arry）<br>变长数组（variable length array）<br>元素（element）<br>索引，下标（index）<br>字符串（string）<br>Unicode 字符串（Unicode string）<br>转义序列（escape sequence）</p></blockquote><h2 id="编程范型（面向对象，函数式等）"><a href="#编程范型（面向对象，函数式等）" class="headerlink" title="编程范型（面向对象，函数式等）"></a>编程范型（面向对象，函数式等）</h2><blockquote><p>编程范型（programming paradigm）<br>多范型语言（multi-paradigm language）<br>动态绑定（dynamic bind）<br>作用域（scope）<br>引用（reference）<br>域，成员，字段（member,field）<br>类（class）<br>继承（inheritance）<br>多态（polymorphism）<br>封装（encapsulation）<br>类方法（class method）<br>虚方法（virtual method）<br>纯虚方法，抽象方法（abstract method）<br>覆盖（override）<br>对象（object）<br>实例（instance）<br>原型（prototype）<br>构造器，构造函数（constructor,constructor function）<br>属性（property）<br>方法（method）<br>用户定义属性（user-defined properties）<br>预定义属性（pre-defined properties）<br>内部（内建）属性/方法/成员（build-in properties/method/member）<br>事件（event）<br>事件句柄，事件处理器，事件处理代码（event handle）<br>特性，性质，属性（attribute）<br>特性（feature）<br>函数（function）<br>参数（arguments）<br>外部局部变量（external local variable,upvalue）<br>lambda运算（lambda calculus）<br>闭包（closure）</p></blockquote><h2 id="编译、执行及其他"><a href="#编译、执行及其他" class="headerlink" title="编译、执行及其他"></a>编译、执行及其他</h2><blockquote><p>解释器（interpreter）<br>运行期（runtime）<br>宿主（host）<br>上下文（context）<br>环境（environment）<br>执行环境，执行上下文（execution context）<br>异常（exception）<br>错误（error）<br>正则表达式（regular expression）<br>全局（global）<br>局部（local）<br>全局对象（global object）<br>全局变量（global variable）<br>局部变量（local variable）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript常用中英文惯译法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GPU和CSS硬件加速</title>
    <link href="/2022/10/21/GPU%E5%92%8CCSS%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    <id>/2022/10/21/GPU和CSS硬件加速/</id>
    <published>2022-10-21T06:38:55.000Z</published>
    <updated>2022-10-21T06:48:54.352Z</updated>
    
    <content type="html"><![CDATA[<p>彻底搞懂GPU和CSS硬件加速<br><a id="more"></a></p><h2 id="从-cpu-聊起"><a href="#从-cpu-聊起" class="headerlink" title="从 cpu 聊起"></a>从 cpu 聊起</h2><p>cpu (central process) 是计算机的大脑，它提供了一套指令集，我们写的程序最终会通过 cpu 指令来控制的计算机的运行。</p><p>cpu 会对指令进行译码，然后通过逻辑电路执行该指令。整个执行的流程分为了多个阶段，叫做流水线。指令流水线包括取指令、译码、执行、取数、写回五步，这是一个指令周期。cpu 会不断的执行指令周期来完成各种任务。</p><p>指令和数据都会首先加载到内存中，在程序运行时依次取到 cpu 里。cpu 访问内存虽然比较快，但比起 cpu 执行速度来说还是比较慢的，为了缓解这种速度矛盾，cpu 设计了 3 级缓存，也就是 L1、L2、L3 的缓存。<br><img src="/2022/10/21/GPU和CSS硬件加速/1.webp" alt="img"><br>如图，多核 cpu 各核心都有自有独立的 L1、L2 缓存，然后共享 L3 缓存，这 3 级缓存容量是逐渐递增的，但是速度是逐渐下降的，但是也会比访问内存快一些。</p><p>有了这 3 级缓存以后，cpu 执行速度和访问内存速度的矛盾就可以得到缓解，不需要一直访问内存，cpu 每次会加载一个缓存行，也就是 64 字节大小的数据到缓存中。这样访问临近的数据的时候就可以直接访问缓存。</p><p>从内存中把数据和指令加载到 cpu 的缓存中，然后通过控制器控制指令的译码、执行，通过运算器进行运算，之后把结果写回内存。这就是 cpu 的工作流程。</p><p>cpu 每个核只有一个线程，也就是单控制流、单数据流。这样的架构导致 cpu 在一些场景下效率是不高的，比如 3d 渲染的场景。</p><h2 id="3d-渲染流程"><a href="#3d-渲染流程" class="headerlink" title="3d 渲染流程"></a>3d 渲染流程</h2><p>3d 的渲染首先是建立 3d 的模型，它由一系列三维空间中的顶点构成，3 个顶点构成一个三角形，然后所有的顶点构成的三角形拼接起来就是 3d 模型。<br><img src="/2022/10/21/GPU和CSS硬件加速/2.webp" alt="img"><br>顶点、三角形，这是 3d 的基础。3d 引擎首先要计算顶点数据，确定 3d 图形的形状。之后还要对每个面进行贴图，可以在每个三角形画上不同的纹理。</p><p>3d 图形要显示在二维的屏幕上就要做投影，这个投影的过程叫做光栅化。（光栅是一种光学仪器，在这里就代表 3d 投影到 2d 屏幕的过程）<br><img src="/2022/10/21/GPU和CSS硬件加速/3.webp" alt="img"><br>光栅化要计算 3d 图形投影到屏幕的每一个像素的颜色，计算完所有的像素之后会写到显存的帧缓冲区，完成了一帧的渲染，之后会继续这样计算下一帧。</p><p>也就是说，3d 渲染的流程是：</p><blockquote><p>计算顶点数据，构成 3d 的图形<br>给每个三角形贴图，画上纹理<br>投影到二维的屏幕，计算每个像素的颜色（光栅化）<br>把一帧的数据写入显存的帧缓冲区</p></blockquote><p>顶点的数量是非常庞大的，而 cpu 只能顺序的一个个计算，所以处理这种 3d 渲染会特别费劲，于是就出现了专门用于这种 3d 数据的并行计算的硬件，也就是 GPU。</p><h2 id="GPU-的构成"><a href="#GPU-的构成" class="headerlink" title="GPU 的构成"></a>GPU 的构成</h2><p>和 cpu 的一个一个数据计算不同，gpu 是并行的，有成百上千个核心用于并行计算。<br><img src="/2022/10/21/GPU和CSS硬件加速/4.webp" alt="img"><br>gpu 也是有着指令、译码、执行的流程，只不过，每个指令会并行执行 n 个计算，是单控制流多数据流的，而 cpu 是单控制流单数据流。</p><p>所以，对于 3d 渲染这种要计算成万个顶点数据和像素点的场景，GPU 会比 CPU 高效很多。</p><p>但是，gpu 全是优点么？也不是。</p><h2 id="cpu-和-gpu-的区别"><a href="#cpu-和-gpu-的区别" class="headerlink" title="cpu 和 gpu 的区别"></a>cpu 和 gpu 的区别</h2><p>cpu 是通用的，能够执行各种逻辑和运算，而 gpu 则是主要是用于并行计算大批量的重复任务，不能处理复杂逻辑。</p><p>如上图，cpu 中控制器和缓存占据了很大一部分，而 gpu 中这两部分则很少，但是有更多的核心用于计算。</p><p>两者对比的话，cpu 相当于一个大学生，能够解决各种难题，但是计算 1 万个加法就没那么快，而 gpu 就像一帮小学生，解决不了难题，但是计算加法这种就很快，因为人多。</p><p>也就是说如果逻辑复杂，那么只能用 cpu，如果只是计算量大，并且每个计算都比较重复，那就比较适合 gpu。</p><p>3d 的渲染中有大量这种重复却简单的计算，比如顶点数据和光栅化的像素数据，通过 gpu 就可以并发的一次计算成百上千个。</p><h2 id="opengl、webgl、css-硬件加速"><a href="#opengl、webgl、css-硬件加速" class="headerlink" title="opengl、webgl、css 硬件加速"></a>opengl、webgl、css 硬件加速</h2><p>显卡中集成了 gpu，提供了驱动，使用 gpu 能力需要使用驱动的 api。 gpu 的 api 有一套开源标准叫做 opengl，有三百多个函数，用于各种图形的绘制。（在 windows 下有一套自己的标准叫做 DirectX）</p><p>我们在网页中绘制 3d 图形是使用 webgl 的 api，而浏览器在实现 webgl 的时候也是基于 opengl 的 api，最终会驱动 gpu 进行渲染。</p><p>css 大部分样式还是通过 cpu 来计算的，但 css 中也有一些 3d 的样式和动画的样式，计算这些样式同样有很多重复且大量的计算任务，可以交给 gpu 来跑。</p><p>浏览器在处理下面的 css 的时候，会使用 gpu 渲染：</p><blockquote><p>transform<br>opacity<br>filter<br>will-change</p></blockquote><p>浏览器是把内容分到不同的图层分别渲染的，最后合并到一起，而触发 gpu 渲染会新建一个图层，把该元素样式的计算交给 gpu。</p><p>opacity 需要改变每个像素的值，符合重复且大量的特点，会新建图层，交给 gpu 渲染。transform 是动画，每个样式值的计算也符合重复且大量的特点，也默认会使用 gpu 加速。同理 fiter 也是一样。</p><p>这里要注意的是 gpu 硬件加速是需要新建图层的，而把该元素移动到新图层是个耗时操作，界面可能会闪一下，所以最好提前做。will-change 就是提前告诉浏览器在一开始就把元素放到新的图层，方便后面用 gpu 渲染的时候，不需要做图层的新建。</p><p>当然，有的时候我们想强制触发硬件渲染，就可以通过上面的属性，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">will-change: transform;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform:translate3d(0, 0, 0);</span><br></pre></td></tr></table></figure></p><p>chrome devtools 可以看到是 cpu 渲染还是 gpu 渲染，打开 rendering 面板，勾选 layer borders，会发现蓝色和黄色的框。蓝色的是 cpu 渲染的，而黄色的是 gpu 渲染的。</p><p>比如这段文字，现在没有单独一个图层：<br><img src="/2022/10/21/GPU和CSS硬件加速/5.webp" alt="img"><br>添加一个 will-change: transform 的属性，浏览器会新建图层来渲染该元素，然后使用 gpu 渲染：<br><img src="/2022/10/21/GPU和CSS硬件加速/6.webp" alt="img"><br>gpu 硬件加速能减轻 cpu 压力，使得渲染更流畅，但是也会增加内存的占用，对于 transform、opacity、filter 默认会开启硬件加速。其余情况，建议只在必要的时候用。</p><h2 id="opencl-和神经网络"><a href="#opencl-和神经网络" class="headerlink" title="opencl 和神经网络"></a>opencl 和神经网络</h2><p>重复且大量的计算任务只有 3d 渲染一种场景么？</p><p>不是的，AI 领域的机器学习也很典型，它的特点是大量的神经元需要计算，但是每个计算都比较简单，也很适合用 gpu 来跑。</p><p>现在的 gpu 不只是能跑图形渲染，也提供了一些编程能力，这部分 api 有 opencl 标准。可以通过 gpu 的并行计算能力来跑一些有大量计算但是没有很多逻辑的的任务，会比 cpu 效率更高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cpu 提供了指令集，会不断的执行取指令、译码、执行、取数、写回的指令周期，控制着计算机的运转。</p><p>cpu 计算的速度比较快，而访问内存比较慢，为了缓和两者的矛盾，引入了 L1、L2、L3 的多级缓存体系，L1、L2、L3 是容器逐渐变大，访问速度逐渐变慢的关系，但还是比访问内存快。内存会通过一个缓存行（64 字节）的大小为单位来读入缓存，供 cpu 访问。</p><p>3d 渲染的流程是计算每一个顶点的数据，连成一个个三角形，然后进行纹理贴图，之后计算投影到二维屏幕的每一个像素的颜色，也就是光栅化，最后写入显存帧缓冲区，这样进行一帧帧的渲染。</p><p>cpu 的计算是一个个串行执行的，对于 3d 渲染这种涉及大量顶点、像素要计算的场景就不太合适，于是出现了 gpu。</p><p>gpu 可以并行执行大量重复的计算，有成百上千个计算单元，相比 cpu 虽然执行不了复杂逻辑，但是却能执行大量重复的运算。提供了 opengl 的标准 api。</p><p>css 中可以使用 gpu 加速渲染来减轻 cpu 压力，使得页面体验更流畅，默认 transform、opacity、filter 都会新建新的图层，交给 gpu 渲染。对于这样的元素可以使用 will-change: 属性名; 来告诉浏览器在最开始就把该元素放到新图层渲染。</p><p>gpu 的并行计算能力不只是 3d 渲染可以用，机器学习也有类似的场景，可以通过 opencl 的 api 来控制 gpu 进行计算。</p><p>gpu 和前端的关系还是挺密切的，不管是 webgl，还是 css 硬件加速，或者网页的性能都与之相关。希望这篇文章能够帮大家了解 gpu 的原理和应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;彻底搞懂GPU和CSS硬件加速&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
      <category term="3D" scheme="/tags/3D/"/>
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>css中的单位</title>
    <link href="/2022/10/21/css%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BD%8D/"/>
    <id>/2022/10/21/css中的单位/</id>
    <published>2022-10-21T05:39:28.000Z</published>
    <updated>2022-10-21T06:30:28.148Z</updated>
    
    <content type="html"><![CDATA[<p>css中的一些单位<br><a id="more"></a><br>说起CSS单位，我们最熟悉的可能就是像素单位（px），它是一个绝对单位，也就是说一个10px的文字，放在哪里都是一样大的。单位可以影响颜色、距离、尺寸等一系列的属性。CSS中单位的形式有很多种，下面就分别来看看这些单位。<br><img src="/2022/10/21/css中的单位/1.webp" alt="img"></p><h2 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h2><p>相对单位就是相对于另一个长度的长度。CSS中的相对单位主要分为两大类：</p><blockquote><p>字体相对单位，他们都是根据font-size来进行计算的。常见的字体相对单位有：em、rem、ex、ch；<br>视窗相对单位，他们都是根据视窗大小来决定的。常见的视窗相对单位有vw、vh、vmax、vmin。</p></blockquote><h3 id="em-和-rem"><a href="#em-和-rem" class="headerlink" title="em 和 rem"></a>em 和 rem</h3><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>em是最常见的相对长度单位，适合基于特定的字号进行排版。根据CSS的规定，1em 等于元素的font-size属性的值。<br>em 是相对于父元素的字体大小进行计算的。如果当前对行内文本的字体尺寸未进行显示设置，则相对于浏览器的默认字体尺寸。当DOM元素嵌套加深时，并且同时给很多层级显式的设置了font-size的值的单位是em，那么就需要层层计算，复杂度会很高。<br><strong>如果自身元素是没有设置字体大小的，那么就会根据其父元素的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算。</strong><br>em单位除了可以作用于 font-size之外，还可以运用于其他使用长度的属性，比如border-width、width、height、margin、padding、text-shadow等。<br>所以，em的使用还是比较复杂的，它可能会继承任意一级父元素的字体大小。需要谨慎使用。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem相对于em就简单了很多，它是根据页面的根元素（根元素）的字体大小来计算的。<br>如果没有对根元素设定字号的话，font-size: 1rem的作用与font-size: initial相同。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>使用 em 和 rem 可以让我们灵活的够控制元素整体的放大和缩小，而不是固定大小。那何时应使用 em，何时应使用 rem 呢？可以根据两者的差异来进行选择：</p><blockquote><p>两者在客户端中计算出来的样式都会以px的形式显示；<br>rem是相对于根元素html的font-size计算，em 相对于元素的font-size计算；<br>当需要根据浏览器的font-size设置缩放时，应该使用 rem；<br>使用 em 应该根据组件的font-size来定，而不是根元素的font-size来定；<br>rem 可以从浏览器字体设置中继承 font-size 值， em 可能受任何继承过来的父元素 font-size 的影响。</p></blockquote><h3 id="ex-和-ch"><a href="#ex-和-ch" class="headerlink" title="ex 和 ch"></a>ex 和 ch</h3><p>ex 和 ch 都是排版用的单位，它们的大小取决于元素的font-size 和 font-family属性。</p><blockquote><p>ex 指的是所用字体中小写字母 x 的高度。因此，如果两个字体不一样，那么 ex 的值是不一样的。因为每种字体的小写 x 的高度是不一样的。<br>ch 和 ex 类似，不过它是基于数字 0 的宽度计算的。会随着字体的变化而变化。而0 的宽度通常是对字体的平均字符宽度，它是一个估计值。由于 ch 是一个近似等宽的单元，所以在设置容器的宽度时很有用，比如一个容器想要显示指定个数的字符串时，就可以使用这个单位。</p></blockquote><h3 id="vw、vh、vmax-和-vmin"><a href="#vw、vh、vmax-和-vmin" class="headerlink" title="vw、vh、vmax 和 vmin"></a>vw、vh、vmax 和 vmin</h3><p>这四个单位都是视窗单位，所谓的视窗，在web端指的就是可视区域，移动端的视窗指的就是布局视窗。如果视窗大小发生了变化，那么这些值都会随之变化。这四个单位指的是：</p><blockquote><p>vw：视窗宽度的百分比；<br>vh：视窗高度的百分比；<br>vmax：较大的 vh 和 vw；<br>vmin：较小的 vh 和 vw。</p></blockquote><p>假如一个浏览器的高度是800px，那么1vh的值就是8px。vh和vw的大小总是和视窗的高度和宽度有关。 ​<br>vmin 和 vmax 与视窗宽度和高度的最大值和最小值有关。假如一个浏览器高度为500px，宽度为1200px，那么1vmin就是5px，1vmax就是12px。</p><h2 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h2><p>在 CSS 中，绝对单位包括： px 、pt 、pc、 cm 、 mm 、in 等。绝对单位是一个固定的值，它反应了一个真实的物理尺寸。它不会受屏幕大小或者字体的影响。它们的大小取决于值以及屏幕的分辨率（DPI，每英寸的点数）。px就是我们最常用的绝对单位之一。这些绝对单位的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1in = 25.4mm = 2.54cm = 6pc = 72pt =96px</span><br></pre></td></tr></table></figure></p><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>px 全称为 Pixels，表示像素，它并不严格等于显示器的像素，尤其在高清屏下。尽管CSS单位会根据浏览器、操作系统或者硬件适当缩放，在某些设备或者用户的分辨率设置下也会发生变化，但是96px通常等于一个物理英寸的大小。<br>CSS 将光栅图像(如照片等)的显示方式定义为默认每一个图像大小为1px。 一个“600x400”解析度的照片的长宽分别为“600px”和“400px”，所以照片本身的像素并不会与显示装置像素一致，而是与 px 单位一致。如此就可以将图像完整的与网页的其它元素排列起来。 ​<br>很多时候， px 也常被称为 CSS 像素。它是一个绝对单位，但也可以被视为相对单位，因为像素单位相对的是设备像素。在同一个设备上，每 1 个 CSS 像素所代表的物理像素是可以变化的；在不同的设备之间，每 1 个 CSS 像素所代表的物理像素是可以变化的。</p><h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>pt 全称为 Point，表示点。常用于软件设计和排版印刷行业（笔者做的前端系统，最终的产物就是一个需要拿去印刷的PDF，所以会经常用到这个单位）。当使用这个单位时，无论显示器的分辨率是多少，打印在纸上的结果都是一样的。 ​<br>如果单纯为了网页的显示，建议就使用px像素单位，如果需要输出印刷产品，就可以考虑使用pt。</p><h3 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h3><p>pc 全程为 Picas，表示派卡。相当于我国新四号铅字的尺寸。派卡也是印刷的术语，1派卡等于12点。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1pc = 16px</span><br></pre></td></tr></table></figure></p><h3 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h3><p>cm 全称为 Centimeters，表示厘米。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1cm = 37.8px</span><br></pre></td></tr></table></figure></p><h3 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h3><p>mm 全称为 Millimeters，表示毫米。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1mm = 3.78px</span><br></pre></td></tr></table></figure></p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>in 全称为 Inches，表示英寸。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1in = 96px</span><br></pre></td></tr></table></figure></p><h2 id="频率单位"><a href="#频率单位" class="headerlink" title="频率单位"></a>频率单位</h2><p>CSS中的频率单位有两个：赫兹（Hz）和千赫兹（kHz）。它们的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1kHz = 1000Hz</span><br></pre></td></tr></table></figure></p><p>通常情况下，频率单位使用在听或说级联样式表中。频率可以被用来改变一个语音阅读文本的音调。低频率就是低音，高频率就是高音。<br>需要注意，当数值为0时，单位对值没有影响，但是单位是不能省略的。也就是说0、0Hz、0kHz是不一样的。所以，在使用频率单位时，不要直接写0。另外，这两个单位是不区分大小写的。</p><h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>CSS中的时间单位有两个：秒（s）和毫秒（ms）。这两个时间单位都是CSS新增的单位。这两个单位的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1s = 1000ms</span><br></pre></td></tr></table></figure></p><p>时间单位主要用于过度和动画中，用于定义持续时间或延迟时间。</p><h2 id="分辨率单位"><a href="#分辨率单位" class="headerlink" title="分辨率单位"></a>分辨率单位</h2><p>CSS中的分辨率单位有三个：dpi、dpcm、dppx。这三个单位都是CSS3中华新增的单位。他们都是正值，不允许为负值。这三个单位的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1dppx = 96dpi</span><br><span class="line">1dpi ≈ 0.39dpcm</span><br><span class="line">1dpcm ≈ 2.54dpi</span><br></pre></td></tr></table></figure></p><p>分辨率单位主要用于媒体查询等操作。</p><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>dpi 全称为 dots per inch，表示每英寸包含的点的数量。普通屏幕通常包含 72或96个点，大于 192dpi 的屏幕被称为高分屏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-resolution: 96dpi) &#123; ... &#125;</span><br><span class="line">@media print and (min-resolution: 300dpi) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h3 id="dpcm"><a href="#dpcm" class="headerlink" title="dpcm"></a>dpcm</h3><p>dpcm 全称为 dots per centimeter，表示每厘米包含的点的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-resolution: 28dpcm) &#123; ... &#125;</span><br><span class="line">@media print and (min-resolution: 118dpcm) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h3 id="dppx"><a href="#dppx" class="headerlink" title="dppx"></a>dppx</h3><p>dppx 全称为 dots per pixel，表示每像素（px）包含点的数量。由于CSS px的固定比率为1:96，因此1dppx相当于96dpi。它对应于由图像分辨率定义的CSS中显示的图像的默认分辨率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-resolution: 2dppx) &#123; ... &#125;</span><br><span class="line">@media screen and (min-resolution: 1dppx) and (max-resolution: 1.9dppx) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h2 id="角度单位"><a href="#角度单位" class="headerlink" title="角度单位"></a>角度单位</h2><p>CSS中的角度单位有四个：deg、grad、rad、turn。这些角度单位都是CSS3中新增的单位。它们的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90deg = 100grad = 0.25turn ≈ 1.570796326794897rad</span><br></pre></td></tr></table></figure></p><p>一般这些角度单位用于元素的旋转操作，包括2D旋转、3D旋转等。</p><blockquote><p>当旋转值为正值时，元素会顺时针旋转；<br>当旋转值为负值时，元素会逆时针旋转。</p></blockquote><p>通常情况下，一个完整的旋转就是360度。所以，所有的角度都在0-360度之间。但是，超出这个范围的值也是允许的，只不过都会归到0-360度之间。比如，顺时针旋转450度（450deg）、逆时针旋转270度（-270deg）、顺时针旋转90度（90deg）都是一样的效果，都会归为90deg。但是当使用动画时，这些角度值就非常重要了。<br>CSS的旋转主要依赖于 transform 属性中的 rotate() 、rotate3d、 skew() 等方法。只需给它们传递旋转的角度即可。 ​<br>除了旋转会使用角度之外，线性渐变也会经常使用角度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(45deg, #000, #fff);</span><br></pre></td></tr></table></figure></p><h3 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h3><p>deg 全称为 Degress，表示度，一个圆总共360度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(2deg);</span><br></pre></td></tr></table></figure></p><h3 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h3><p>grad 全称为 Gradians，表示梯度，一个圆总共400梯度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(2grad);</span><br></pre></td></tr></table></figure></p><h3 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h3><p>rad 全称为 Radians，表示弧度，一个圆总共2π弧度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(2rad);</span><br></pre></td></tr></table></figure></p><h3 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h3><p>turn 全称为 Turns，表示圈（转），一个圆总共一圈（转）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform:rotate(.5turn);</span><br></pre></td></tr></table></figure></p><h2 id="百分比单位"><a href="#百分比单位" class="headerlink" title="百分比单位"></a>百分比单位</h2><p>百分比（%）也是我们比较常用的单位之一，所有接受长度值的属性都可以使用百分比单位。但是不同属性使用该单位的效果可能并不一样。但是都需要有一个参照值，也就是说百分比值是一个相对的值。 ​</p><h3 id="盒模型中的百分比"><a href="#盒模型中的百分比" class="headerlink" title="盒模型中的百分比"></a>盒模型中的百分比</h3><p>在CSS中的盒模型包含的属性有：width、max-width、min-width、height、max-height、min-height、padding、margin等。这些属性在使用百分比时，参照物不尽相同：</p><blockquote><p>width、max-width、min-width：值为百分比时，其相对于包含块的 width 进行计算；<br>height、max-height、min-height：值为百分比时，其相对于包含块的 height 进行计算；<br>padding、margin：值为百分比时，如果是水平的值，就是相对于包含块的 width 进行计算；如果是垂直的值，也是相对于包含块的 width 进行计算。</p></blockquote><h3 id="文本中的百分比"><a href="#文本中的百分比" class="headerlink" title="文本中的百分比"></a>文本中的百分比</h3><p>在CSS中文本控制的属性有font-size、line-height 、vertical-align、 text-indent等。这些属性在使用百分比时，参照物不尽相同：</p><blockquote><p>font-size：根据父元素的font-size 进行计算；<br>line-height：根据font-size进行计算；<br>vertical-align：根据line-height进行计算；<br>text-indent：如果是水平的，则根据width进行计算，如果是垂直的，则根据 height 进行计算。</p></blockquote><h3 id="定位中的百分比"><a href="#定位中的百分比" class="headerlink" title="定位中的百分比"></a>定位中的百分比</h3><p>在CSS中用控制 position 位置的top、right、bottom、left都可以使用百分比作为单位。其参照物就是包含块的同方向的width和height。不同定位的包含块不尽相同：</p><blockquote><p>如果元素为静态（ static ）或相对定位（ relative ），包含块一般是其父容器；<br>如果元素为绝对定位（ absolute ），包含块应该是离它最近的 position 为 absolute 、 relative 或 fixed 的祖先元素；<br>如果元素为固定定位（ fixed ），包含块就是视窗（ viewport ）。</p></blockquote><h3 id="变换中的百分比"><a href="#变换中的百分比" class="headerlink" title="变换中的百分比"></a>变换中的百分比</h3><p>CSS 中的 transform 属性中的 translate 和 transform-origin 值也可以设置百分比。</p><blockquote><p>translateX() 根据容器的 width 计算<br>translateY() 根据容器的 height 计算<br>transform-origin 中横坐标（ x ）相对于容器的 width 计算；纵坐标（ y ）相对于容器的 height 计算</p></blockquote><p>注意，在 translate 还有一个 z 轴的函数 translateZ() 。它是不接受百分比为单位的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css中的一些单位&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>github工作流</title>
    <link href="/2022/10/14/github%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>/2022/10/14/github工作流/</id>
    <published>2022-10-14T03:21:29.000Z</published>
    <updated>2022-10-14T03:26:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>常用的一种github工作流<br><a id="more"></a></p><blockquote><p>1.git clone // 到本地<br>2.git checkout -b xxx 切换至新分支xxx<br>（相当于复制了remote的仓库到本地的xxx分支上<br>3.修改或者添加本地代码（部署在硬盘的源文件上）<br>4.git diff 查看自己对代码做出的改变<br>5.git add 上传更新后的代码至暂存区<br>6.git commit 可以将暂存区里更新后的代码更新到本地git<br>7.git push origin xxx 将本地的xxxgit分支上传至github上的git</p></blockquote><blockquote><p>（如果在写自己的代码过程中发现远端GitHub上代码出现改变）<br>1.git checkout main 切换回main分支<br>2.git pull origin master(main) 将远端修改过的代码再更新到本地<br>3.git checkout xxx 回到xxx分支<br>4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容<br>（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）<br>5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上<br>（-f —》强行）<br>6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit</p></blockquote><blockquote><p>远端完成更新后<br>1.git branch -d xxx 删除本地的git分支<br>2.git pull origin master 再把远端的最新代码拉至本地</p></blockquote><p><a href="https://www.bilibili.com/video/BV19e4y1q7JJ/?spm_id_from=333.1007.tianma.2-2-4.click&amp;vd_source=52fb49cd12021ddab3266f637619f33b" target="_blank" rel="noopener">视频教程地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的一种github工作流&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="github" scheme="/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>企业信息化常用系统</title>
    <link href="/2022/10/12/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>/2022/10/12/企业信息化常用系统/</id>
    <published>2022-10-12T03:15:40.000Z</published>
    <updated>2022-10-12T03:31:34.247Z</updated>
    
    <content type="html"><![CDATA[<p>企业信息化常用系统的英文缩写<br><a id="more"></a></p><h2 id="企业资源计划（ERP）"><a href="#企业资源计划（ERP）" class="headerlink" title="企业资源计划（ERP）"></a>企业资源计划（ERP）</h2><p><img src="/2022/10/12/企业信息化常用系统/1.png" alt="img"></p><h2 id="客户关系管理（CRM）"><a href="#客户关系管理（CRM）" class="headerlink" title="客户关系管理（CRM）"></a>客户关系管理（CRM）</h2><p><img src="/2022/10/12/企业信息化常用系统/2.png" alt="img"></p><h2 id="供应链管理（SCM）"><a href="#供应链管理（SCM）" class="headerlink" title="供应链管理（SCM）"></a>供应链管理（SCM）</h2><p><img src="/2022/10/12/企业信息化常用系统/3.png" alt="img"></p><h2 id="商业智能（BI）"><a href="#商业智能（BI）" class="headerlink" title="商业智能（BI）"></a>商业智能（BI）</h2><p><img src="/2022/10/12/企业信息化常用系统/4.png" alt="img"></p><h2 id="决策支持系统（DSS）"><a href="#决策支持系统（DSS）" class="headerlink" title="决策支持系统（DSS）"></a>决策支持系统（DSS）</h2><p><img src="/2022/10/12/企业信息化常用系统/5.png" alt="img"></p><h2 id="业务流程重组（BPR）"><a href="#业务流程重组（BPR）" class="headerlink" title="业务流程重组（BPR）"></a>业务流程重组（BPR）</h2><p><img src="/2022/10/12/企业信息化常用系统/6.png" alt="img"></p><h2 id="业务流程管理（BPM）"><a href="#业务流程管理（BPM）" class="headerlink" title="业务流程管理（BPM）"></a>业务流程管理（BPM）</h2><p><img src="/2022/10/12/企业信息化常用系统/7.png" alt="img"></p><h2 id="企业应用集成（EAI）"><a href="#企业应用集成（EAI）" class="headerlink" title="企业应用集成（EAI）"></a>企业应用集成（EAI）</h2><p><img src="/2022/10/12/企业信息化常用系统/8.png" alt="img"></p><h2 id="企业门户"><a href="#企业门户" class="headerlink" title="企业门户"></a>企业门户</h2><p><img src="/2022/10/12/企业信息化常用系统/9.png" alt="img"></p><h2 id="电子政务与电子商务简称"><a href="#电子政务与电子商务简称" class="headerlink" title="电子政务与电子商务简称"></a>电子政务与电子商务简称</h2><blockquote><p>政府 Government<br>  企业 Business<br>  公民 Citizen<br>  线上 Online<br>  线下 Offline<br>  G2G G2B B2C C2C等<br>  O2O</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;企业信息化常用系统的英文缩写&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="软考" scheme="/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>h5禁止微信字体设置</title>
    <link href="/2022/10/10/h5%E7%A6%81%E6%AD%A2%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/"/>
    <id>/2022/10/10/h5禁止微信字体设置/</id>
    <published>2022-10-10T02:28:42.000Z</published>
    <updated>2022-10-10T02:40:12.030Z</updated>
    
    <content type="html"><![CDATA[<p>解除微信字体大小设置，对h5页面的影响<br><a id="more"></a><br>在开发微信公众号，或者用微信打开一个h5页面，如果调整了微信的字体大小，页面的布局会发生改变，这样就做不到统一。<br>IOS和安卓用不同的方法禁止了微信字体的调整，见下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;微信字体大小设置&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  /* iOS禁止微信调整字体大小 */</span><br><span class="line">  body &#123;</span><br><span class="line">    -webkit-text-size-adjust: 100% !important;</span><br><span class="line">    text-size-adjust: 100% !important;</span><br><span class="line">    -moz-text-size-adjust: 100% !important;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;h1字体大小测试微信&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;h2字体大小测试微信&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;h3字体大小测试微信&lt;/h3&gt;</span><br><span class="line">  &lt;h4&gt;h4字体大小测试微信&lt;/h4&gt;</span><br><span class="line">  &lt;h5&gt;h5字体大小测试微信&lt;/h5&gt;</span><br><span class="line">  &lt;h6&gt;h6字体大小测试微信&lt;/h6&gt;</span><br><span class="line">  &lt;div style=&quot;font-size:14px;&quot;&gt;div字体大小测试微信px&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;font-size:2rem;&quot;&gt;div字体大小测试微信rem&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 对安卓手机有效</span><br><span class="line">  // 强制禁止用户修改微信客户端的字体大小</span><br><span class="line">  (function() &#123;</span><br><span class="line">    if (typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot;) &#123;</span><br><span class="line">    handleFontSize();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (document.addEventListener) &#123;</span><br><span class="line">    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, handleFontSize, false);</span><br><span class="line">  &#125; else if (document.attachEvent) &#123;</span><br><span class="line">    document.attachEvent(&quot;WeixinJSBridgeReady&quot;, handleFontSize);</span><br><span class="line">    document.attachEvent(&quot;onWeixinJSBridgeReady&quot;, handleFontSize);  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function handleFontSize() &#123;</span><br><span class="line">    // 设置网页字体为默认大小</span><br><span class="line">    WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;);</span><br><span class="line">    // 重写设置网页字体大小的事件</span><br><span class="line">    WeixinJSBridge.on(&apos;menu:setfont&apos;, function() &#123;</span><br><span class="line">      WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解除微信字体大小设置，对h5页面的影响&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="微信" scheme="/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>canvas-html属性width与css的width区别</title>
    <link href="/2022/09/15/canvas-html%E5%B1%9E%E6%80%A7width%E4%B8%8Ecss%E7%9A%84width%E5%8C%BA%E5%88%AB/"/>
    <id>/2022/09/15/canvas-html属性width与css的width区别/</id>
    <published>2022-09-15T06:45:32.000Z</published>
    <updated>2022-09-15T07:08:41.895Z</updated>
    
    <content type="html"><![CDATA[<p>canvas中标签属性的width，height与css的width，height的区别<br><a id="more"></a><br>canvas中，如果不写width和height，会默认width=300，height=150。</p><blockquote><p>标签属性中的width和height可以理解为虚拟画布的宽高，比如设置width=3000，height=1000，在js中对其进行绘图时，都是在这个宽3000，高1000的画布上进行绘制。<br>而css的width和height是绘制好的这块画布在实际的页面中显示的具体宽高，可以把画布理解为一张宽3000，高1000的图片，当设置其css宽高时，这张图片会根据实际的宽高进行变化。</p></blockquote><p>附上一段代码，可以更改width和height观察其变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;canvas&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  canvas &#123;</span><br><span class="line">    border: 1px solid blue;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id=&quot;mycanvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;浏览器不支持Canvas,请升级或改用其它浏览器！&lt;/canvas&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var canvas = document.getElementById(&quot;mycanvas&quot;),</span><br><span class="line">        ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    ctx.moveTo(0,0);</span><br><span class="line">    ctx.lineTo(300,150);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas中标签属性的width，height与css的width，height的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="canvas" scheme="/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发</title>
    <link href="/2022/09/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    <id>/2022/09/05/微信公众号开发/</id>
    <published>2022-09-05T06:31:44.000Z</published>
    <updated>2022-09-06T07:11:06.471Z</updated>
    
    <content type="html"><![CDATA[<p>微信公众号开发简介<br><a id="more"></a><br>微信公众号开发比较繁琐，先来看一下大致架构：<br><img src="/2022/09/05/微信公众号开发/1.png" alt="img"><br>服务器鉴权这块，应该是比较难的。<br>这里有两个需要鉴权的地方，一个是基本配置里的URL接入鉴权，另一个是JS-SDK的鉴权。</p><h2 id="URL接入鉴权"><a href="#URL接入鉴权" class="headerlink" title="URL接入鉴权"></a>URL接入鉴权</h2><p><img src="/2022/09/05/微信公众号开发/2.png" alt="img"><br>上图中的这个URL是微信公众平台接入到自己的后台服务器的接口鉴权，URL可以写成这样<code>http://jinux.top/weixinapi</code>。<br>看一看微信公众平台的定义：</p><blockquote><p>开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：<br>1）将token、timestamp、nonce三个参数进行字典序排序<br>2）将三个参数字符串拼接成一个字符串进行sha1加密<br>3）开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信</p></blockquote><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html" target="_blank" rel="noopener">官网文档地址</a><br>验证signature的示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function checkSignature() &#123;</span><br><span class="line">  let &#123; signature, timestamp, nonce, echostr &#125; = req.query;</span><br><span class="line">  let token = &apos;testweixin&apos;; // 这个token是上图中的填写的Token</span><br><span class="line">  let array = [timestamp, nonce, token];</span><br><span class="line">  array.sort(); // 字典排序</span><br><span class="line">  let str = array.join(&apos;&apos;);</span><br><span class="line">  let resultStr = sha1(str); // 对字符串进行sha1加密，需要const sha1 = require(&apos;sha1&apos;)</span><br><span class="line">  if(resultStr === signature) &#123;</span><br><span class="line">    res.send(echostr);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    res.send(&apos;Error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JS-SDK使用"><a href="#JS-SDK使用" class="headerlink" title="JS-SDK使用"></a>JS-SDK使用</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62" target="_blank" rel="noopener">官方文档地址</a><br>js-sdk使用流程图：<br><img src="/2022/09/05/微信公众号开发/3.png" alt="img"><br>在网页中调用微信赋予的功能时，需要config 接口注入权限验证配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。</span><br><span class="line">  appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class="line">  timestamp: , // 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class="line">  signature: &apos;&apos;,// 必填，签名</span><br><span class="line">  jsApiList: [] // 必填，需要使用的 JS 接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>timestamp, nonceStr, signature</code>需要后台生成。<br>接下来，看一下生成流程</p><h3 id="获取ticket"><a href="#获取ticket" class="headerlink" title="获取ticket"></a>获取ticket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function getTicket() &#123;</span><br><span class="line">  let tokenUrl = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`;</span><br><span class="line">  let token_data = await axios.get(tokenUrl);</span><br><span class="line">  let access_token = token_data.data.access_token; // 得到access_token</span><br><span class="line">  let ticketUrl = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=$&#123;access_token&#125;&amp;type=jsapi`;</span><br><span class="line">  let ticket_data = await axios.get(ticketUrl);</span><br><span class="line">  let ticket = ticket_data.data.ticket; // 获取jsp_ticket</span><br><span class="line">  return ticket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成nonceStr"><a href="#生成nonceStr" class="headerlink" title="生成nonceStr"></a>生成nonceStr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function createNonceStr() &#123;</span><br><span class="line">  return Math.random().toString(36).subStr(2, 15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成timestamp"><a href="#生成timestamp" class="headerlink" title="生成timestamp"></a>生成timestamp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function createTimestamp() &#123;</span><br><span class="line">  return parseInt(new Date().getTime() / 1000) + &apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成signature"><a href="#生成signature" class="headerlink" title="生成signature"></a>生成signature</h3><blockquote><p>签名生成规则如下：<br>1）参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。<br>2）对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用 URL 键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1。<br>3）这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 处理数据格式</span><br><span class="line">function row(obj) &#123;</span><br><span class="line">  let keys = Object.keys(obj);</span><br><span class="line">  keys = keys.sort(); // 字典排序</span><br><span class="line">  let newObj = &#123;&#125;;</span><br><span class="line">  keys.forEach(key=&gt; &#123;</span><br><span class="line">    newObj[key] = obj[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  let string = &apos;&apos;;</span><br><span class="line">  for(let k in newObj) &#123;</span><br><span class="line">    string += &apos;&amp;&apos; + k + &apos;=&apos; + newObj[k];</span><br><span class="line">  &#125;</span><br><span class="line">  string = string.subStr(1);</span><br><span class="line">  return string;</span><br><span class="line">&#125;</span><br><span class="line">// 生成signature签名方法</span><br><span class="line">async function getSignature(url) &#123;</span><br><span class="line">  let jsapi_ticket = await getTicket();</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    jsapi_ticket,</span><br><span class="line">    nonceStr: createNonceStr(),</span><br><span class="line">    timestamp: createTimestamp(),</span><br><span class="line">    url</span><br><span class="line">  &#125;</span><br><span class="line">  let str = row(obj);</span><br><span class="line">  let signature = sha1(str);</span><br><span class="line">  obj.signature = signature;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="人脸识别认证"><a href="#人脸识别认证" class="headerlink" title="人脸识别认证"></a>人脸识别认证</h2><p>微信是提供了人脸识别验证接口的，该接口目前是免费的，并且是适用公众号的。由于该接口属于未开放接口，所以在微信JS-SDK说明文档是无法查看到该接口文档的，需要写邮件给腾讯进行申请审核，如果申请通过，腾讯会回复邮件，开通对应公众号的调用权限，并会发送接口文档。<br><a href="https://blog.csdn.net/weixin_36463040/article/details/112664578" target="_blank" rel="noopener">开通人脸识别方法</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是简单的列举了URL接入鉴权和JS-SDK的鉴权，这两个也是公众号中最繁琐的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公众号开发简介&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="微信" scheme="/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>nodejs path模块详解</title>
    <link href="/2022/08/23/nodejs-path%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/"/>
    <id>/2022/08/23/nodejs-path模块详解/</id>
    <published>2022-08-23T02:50:19.000Z</published>
    <updated>2022-08-23T05:51:10.889Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs的path模块用法<br><a id="more"></a><br>nodejs的path模块包含一系列处理和转换文件路径的工具集</p><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h2><p>规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.normalize(&apos;a/b/c/../user/bin&apos;));// a\b\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c///../user/bin/&apos;));// a\b\user\bin\</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin&apos;));// a\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/.././///../user/bin/..&apos;));// a\user</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin/../../&apos;));// a\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../&apos;));// ..\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../../../&apos;));// ..\..\..\</span><br><span class="line">console.log(path.normalize(&apos;./a/.././user/bin/./&apos;));// user\bin\</span><br></pre></td></tr></table></figure></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>path.join([path1], [path2], […])<br>将多个路径结合在一起，并转换为规范化路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.join(&apos;////./a&apos;, &apos;b////c&apos;, &apos;user/&apos;));// \a\b\c\user</span><br><span class="line">console.log(path.join(&apos;./a&apos;, &apos;b//c&apos;, &apos;user&apos;));// a\b\c\user</span><br><span class="line">console.log(path.join(&apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// ..\user\</span><br><span class="line">console.log(path.join(__dirname, &apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// E:\jinux\node\study\user\</span><br></pre></td></tr></table></figure></p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>从源地址 from 到目的地址 to 的绝对路径</p><blockquote><p>类似在shell里执行一系列的cd命令<br>path.resolve(‘foo/bar’, ‘/tmp/file/‘, ‘..’, ‘a/../subfile’)<br>类似于:<br>cd foo/bar<br>cd /tmp/file/<br>cd ..<br>cd a/../subfile<br>pwd<br>[注意]如果某个from或to参数是绝对路径（比如 ‘E:/abc’，或是以“/”开头的路径），则将忽略之前的from参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.resolve(&apos;.&apos;, &apos;testFiles/..&apos;, &apos;trdLayer&apos;));// E:\jinux\node\study\path模块\trdLayer</span><br><span class="line">console.log(path.resolve(&apos;..&apos;, &apos;testFiles&apos;, &apos;a.txt&apos;));// E:\jinux\node\study\testFiles\a.txt</span><br><span class="line">console.log(path.resolve(&apos;D:&apos;, &apos;abc&apos;, &apos;D:/a&apos;));// D:\a</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;ok.gif&apos;));// E:\jinux\node\study\path模块\abc\ok.gif</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)); // E:\jinux\node\study\path模块\subfile</span><br><span class="line">console.log(path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)); // E:\b\c</span><br></pre></td></tr></table></figure><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><p>path.relative(from, to)<br>获取从 from 到 to 的相对路径，可以看作 path.resolve 的相反实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.relative(&apos;C:\\\test&apos;, &apos;C:\\\impl\\bbb&apos;));//..\impl\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;C:/bbb&apos;));//..\..\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;D:/bbb&apos;));//D:\bbb</span><br></pre></td></tr></table></figure></p><h2 id="isAbsolute"><a href="#isAbsolute" class="headerlink" title="isAbsolute"></a>isAbsolute</h2><p>path.isAbsolute(path)<br>path是一个绝对路径(比如 ‘E:/abc’)，或者是以“/”开头的路径，二者都会返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.isAbsolute(&apos;../testFiles/secLayer&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;./join.js&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;temp&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;/temp/../..&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;E:/github/nodeAPI/abc/efg&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;///temp123&apos;));// true</span><br></pre></td></tr></table></figure></p><h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h2><p>path.dirname(p)<br>返回路径p所在的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // /foo/bar/baz/asdf</span><br><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/&apos;)); // /foo/bar/baz</span><br><span class="line">console.log(path.dirname(&apos;C:/test/aaa&apos;)); // C:/test</span><br><span class="line">console.log(path.dirname(__dirname)); // E:\jinux\node\study</span><br></pre></td></tr></table></figure></p><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p>path.basename(p[, ext])<br>返回路径的最后一个部分，即文件名。参数ext为需要截掉的后缀内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // a.txt</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;,&apos;.txt&apos;)); // a</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/&apos;)); // asdf</span><br><span class="line">console.log(path.basename(&apos;C:/test/aaa&apos;)); // aaa</span><br></pre></td></tr></table></figure></p><h2 id="extname"><a href="#extname" class="headerlink" title="extname"></a>extname</h2><p>path.extname(p)<br>返回路径p的扩展名，从最后一个’.’到字符串的末尾。如果最后一个部分没有’.’，或者路径是以’.’开头，则返回空字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // .txt</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt.b&apos;)); // .b</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.&apos;)); // .</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa/.&apos;)); // &apos;&apos;</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa&apos;)); // &apos;&apos;</span><br></pre></td></tr></table></figure></p><h2 id="sep"><a href="#sep" class="headerlink" title="sep"></a>sep</h2><p>返回对应平台下的文件分隔符，win下为’\’，linux下为’/‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.sep); // win下为\，linux下为/</span><br><span class="line">console.log(&apos;foo\\bar\\baz&apos;.split(path.sep)); // [ &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos; ]</span><br><span class="line">console.log(&apos;foo/bar/baz&apos;.split(path.sep)); // win下返回[&apos;foo/bar/baz&apos;]，但在linux系统下会返回[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]</span><br></pre></td></tr></table></figure></p><h2 id="delimiter"><a href="#delimiter" class="headerlink" title="delimiter"></a>delimiter</h2><p>返回对应平台下的路径分隔符，win下为’;’ linux下为’:’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.delimiter); //win下为“;” linux下为“:”</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所有代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">// 当前文件路径</span><br><span class="line">console.log(&apos;当前文件夹路径&apos;, process.cwd());</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.normalize</span><br><span class="line"> * 规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠　</span><br><span class="line"> */</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../user/bin&apos;));// a\b\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c///../user/bin/&apos;));// a\b\user\bin\</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin&apos;));// a\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/.././///../user/bin/..&apos;));// a\user</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin/../../&apos;));// a\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../&apos;));// ..\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../../../&apos;));// ..\..\..\</span><br><span class="line">console.log(path.normalize(&apos;./a/.././user/bin/./&apos;));// user\bin\</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.join</span><br><span class="line"> * path.join([path1], [path2], [...])</span><br><span class="line"> * 将多个路径结合在一起，并转换为规范化路径</span><br><span class="line"> */</span><br><span class="line">console.log(path.join(&apos;////./a&apos;, &apos;b////c&apos;, &apos;user/&apos;));// \a\b\c\user</span><br><span class="line">console.log(path.join(&apos;./a&apos;, &apos;b//c&apos;, &apos;user&apos;));// a\b\c\user</span><br><span class="line">console.log(path.join(&apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// ..\user\</span><br><span class="line">console.log(path.join(__dirname, &apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// E:\jinux\node\study\user\</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.resolve</span><br><span class="line"> * path.resolve([from ...], to)</span><br><span class="line"> * 从源地址 from 到目的地址 to 的绝对路径，类似在shell里执行一系列的cd命令</span><br><span class="line"> * path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</span><br><span class="line"> * 类似于:</span><br><span class="line"> * cd foo/bar</span><br><span class="line"> * cd /tmp/file/</span><br><span class="line"> * cd ..</span><br><span class="line"> * cd a/../subfile</span><br><span class="line"> * pwd</span><br><span class="line"> * [注意]如果某个from或to参数是绝对路径（比如 &apos;E:/abc&apos;，或是以“/”开头的路径），则将忽略之前的from参数</span><br><span class="line"> */</span><br><span class="line">console.log(path.resolve(&apos;.&apos;, &apos;testFiles/..&apos;, &apos;trdLayer&apos;));// E:\jinux\node\study\path模块\trdLayer</span><br><span class="line">console.log(path.resolve(&apos;..&apos;, &apos;testFiles&apos;, &apos;a.txt&apos;));// E:\jinux\node\study\testFiles\a.txt</span><br><span class="line">console.log(path.resolve(&apos;D:&apos;, &apos;abc&apos;, &apos;D:/a&apos;));// D:\a</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;ok.gif&apos;));// E:\jinux\node\study\path模块\abc\ok.gif</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)); // E:\jinux\node\study\path模块\subfile</span><br><span class="line">console.log(path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)); // E:\b\c</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.relative</span><br><span class="line"> * path.relative(from, to)</span><br><span class="line"> * 获取从 from 到 to 的相对路径，可以看作 path.resolve 的相反实现</span><br><span class="line"> */</span><br><span class="line">console.log(path.relative(&apos;C:\\\test&apos;, &apos;C:\\\impl\\bbb&apos;));//..\impl\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;C:/bbb&apos;));//..\..\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;D:/bbb&apos;));//D:\bbb</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.dirname</span><br><span class="line"> * path.dirname(p)</span><br><span class="line"> * 返回路径p所在的目录</span><br><span class="line"> */</span><br><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // /foo/bar/baz/asdf</span><br><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/&apos;)); // /foo/bar/baz</span><br><span class="line">console.log(path.dirname(&apos;C:/test/aaa&apos;)); // C:/test</span><br><span class="line">console.log(path.dirname(__dirname)); // E:\jinux\node\study</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.basename</span><br><span class="line"> * path.basename(p[, ext])</span><br><span class="line"> * 返回路径的最后一个部分，即文件名。参数ext为需要截掉的后缀内容</span><br><span class="line"> */</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // a.txt</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;,&apos;.txt&apos;)); // a</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/&apos;)); // asdf</span><br><span class="line">console.log(path.basename(&apos;C:/test/aaa&apos;)); // aaa</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.extname</span><br><span class="line"> * path.extname(p)</span><br><span class="line"> * 返回路径p的扩展名，从最后一个&apos;.&apos;到字符串的末尾。如果最后一个部分没有&apos;.&apos;，或者路径是以&apos;.&apos;开头，则返回空字符串</span><br><span class="line"> */</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // .txt</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt.b&apos;)); // .b</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.&apos;)); // .</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa/.&apos;)); // &apos;&apos;</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa&apos;)); // &apos;&apos;</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.sep</span><br><span class="line"> * 返回对应平台下的文件分隔符，win下为&apos;\&apos;，linux下为&apos;/&apos;</span><br><span class="line"> */</span><br><span class="line">console.log(path.sep); // win下为\，linux下为/</span><br><span class="line">console.log(&apos;foo\\bar\\baz&apos;.split(path.sep)); // [ &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos; ]</span><br><span class="line">console.log(&apos;foo/bar/baz&apos;.split(path.sep)); // win下返回[&apos;foo/bar/baz&apos;]，但在linux系统下会返回[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.delimiter</span><br><span class="line"> * 返回对应平台下的路径分隔符，win下为&apos;;&apos; linux下为&apos;:&apos;</span><br><span class="line"> */</span><br><span class="line">console.log(path.delimiter); //win下为“;” linux下为“:”</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.isAbsolute</span><br><span class="line"> * path.isAbsolute(path)</span><br><span class="line"> * path是一个绝对路径(比如 &apos;E:/abc&apos;)，或者是以“/”开头的路径，二者都会返回true</span><br><span class="line"> */</span><br><span class="line">console.log(path.isAbsolute(&apos;../testFiles/secLayer&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;./join.js&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;temp&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;/temp/../..&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;E:/github/nodeAPI/abc/efg&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;///temp123&apos;));// true</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs的path模块用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CSS设计模式</title>
    <link href="/2022/08/15/CSS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>/2022/08/15/CSS设计模式/</id>
    <published>2022-08-15T06:00:04.000Z</published>
    <updated>2022-08-15T07:27:03.736Z</updated>
    
    <content type="html"><![CDATA[<p>CSS设计模式<br><a id="more"></a><br>css的设计模式有OOCSS，BEM，SMACSS，ACSS这几种，接下来逐一介绍。</p><h2 id="设计模式-OOCSS"><a href="#设计模式-OOCSS" class="headerlink" title="设计模式:OOCSS"></a>设计模式:OOCSS</h2><p>OOCSS是比较基础的设计模式，其他设计模式或多或少都有OOCSS的影子,OO就是面向对象，也就是用面向对象的思维来写CSS。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>大家都很熟悉面向对象，我们简单看下下面这一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    void study () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher extends Person &#123;</span><br><span class="line">    void study () &#123;&#125;</span><br><span class="line">    void teach () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    void study () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个Person类，它有一些方法，Teacher和Student都继承Person，并且进行了一些修订和扩展。那么我们可以把Person类看成是别人写代码，在不改变别人源码的情况下,新增Teacher和Student对源码进行修订和扩展。这种写法是完全可以应用到CSS上面的。我们看下面一段代码场景:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;menu fix&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;</span><br><span class="line">.menu &#123;</span><br><span class="line">   color: green;</span><br><span class="line">   font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">.fix &#123;</span><br><span class="line">   color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>设计师只想让我们改变其中一个盒子的样式，其他的不变。<br>这时不能轻易改变menu，因为一旦改变就会影响不需要改变的地方。那么我们可以直接利用面向对象的思想，在后面单独添加一个类进行修订和扩展。这样一看我们平时在写的CSS，不就是面向对象吗？<br>当然，OOCSS是有具体的原则的。那么它有哪些原则且个原则的具体是什么呢？我们来看一下：</p><h3 id="原则一-容器与内容分离"><a href="#原则一-容器与内容分离" class="headerlink" title="原则一:容器与内容分离"></a>原则一:容器与内容分离</h3><p>容器与内容分离顾名思义，直接看一个代码案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;post&quot;&gt; </span><br><span class="line">  &lt;p class=&quot;metadata&quot;&gt;</span><br><span class="line">    &lt;a&gt;Hello&lt;/a&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;comment&quot;&gt; </span><br><span class="line">  &lt;p class=&quot;metadata&quot;&gt;</span><br><span class="line">    &lt;a&gt;Hello&lt;/a&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// ---------code 1-----------</span><br><span class="line">.post .metadata &#123;</span><br><span class="line">  // css code</span><br><span class="line">&#125;</span><br><span class="line">// ---------code 2-----------</span><br><span class="line">.post &#123;&#125;</span><br><span class="line">.metadata &#123;</span><br><span class="line">  // css code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>两个不同容器中的内容相同<br>先看样式的code 1，这样显然不好，容器和内容是嵌套依赖关系，并没有做到容器与内容分离。内容的样式无法复用。样式的code 2做到了容器与内容分离，内容在不同的容器中可以复用。</p><h3 id="原则二-结构与皮肤分离"><a href="#原则二-结构与皮肤分离" class="headerlink" title="原则二:结构与皮肤分离"></a>原则二:结构与皮肤分离</h3><p>结构可以看做是一个基础对象,而皮肤可以看做是另外一个对象,也就是对象与对象要分离。基础对象不能改,不断的分离出皮肤对象达到对基础对象的修正和扩展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;menu fix&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 基础对象</span><br><span class="line">.menu &#123;</span><br><span class="line">  color: green;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">// 皮肤</span><br><span class="line">.fix &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="OOCSS与Vue的关系"><a href="#OOCSS与Vue的关系" class="headerlink" title="OOCSS与Vue的关系"></a>OOCSS与Vue的关系</h3><p>我们每天都在写OOCSS，Vue的组件就是OOCSS。我们下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// -------------定义组件-----------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;MateData&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">// 基础对象</span><br><span class="line">.menu &#123;</span><br><span class="line">   color: green;</span><br><span class="line">   font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">// -----------使用组件-------------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;mate-data class=&quot;fix1&quot;&gt;&lt;/mate-data&gt;</span><br><span class="line">  &lt;mate-data class=&quot;fix2&quot;&gt;&lt;/mate-data&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">// 皮肤</span><br><span class="line">.fix1 &#123;</span><br><span class="line">   color: red;</span><br><span class="line">&#125;</span><br><span class="line">.fix2 &#123;</span><br><span class="line">   font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h2 id="设计模式-BEM"><a href="#设计模式-BEM" class="headerlink" title="设计模式:BEM"></a>设计模式:BEM</h2><h3 id="BEM是什么"><a href="#BEM是什么" class="headerlink" title="BEM是什么"></a>BEM是什么</h3><p>BEM即块(Block)、元素(Element)、修饰符(Modifier) 是由Yandex（俄罗斯最著名的互联网企业）的开发团队提出的前端开发理论。BEM通过Block、Element、Modifier来描述页面(关键就是为了解决多人协作的命名问题)。<br>Block是页面中独立存在的区块，可以在不同场合下使用。每个页面都可以看做是多个Block组成。<br>Element是构成Block的元素，只有在对应Block内部才具有意义，是依赖于Block的存在。<br>Modifier是描述Block或Element的属性或状态。同一Block或Element可以有多个Modifier，Modifier不可以单独存在。<br>在命名时，Block作为起始开头，不同 Block 和 Element 用 _ 两个底线区隔开来，不同的 Modifier 则用 – 区隔。<br><img src="/2022/08/15/CSS设计模式/1.jpg" alt="img"></p><h3 id="进阶版的OOCSS"><a href="#进阶版的OOCSS" class="headerlink" title="进阶版的OOCSS"></a>进阶版的OOCSS</h3><p>BEM就是进阶版的OOCSS，我们看下图所示:<br><img src="/2022/08/15/CSS设计模式/2.jpg" alt="img"></p><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>页面两个tab栏，整体布局相似,只有细节部分不同<br>那么使用BEM写样式时，就会定义一个块menu，下面包含元素menu_tab，完成整体布局，细微部分使用修饰符menu_tab-style1进行微调。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BEM --&gt;</span><br><span class="line">&lt;div class=&quot;menu menu-style1&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>通过上面代码可以看出BEM就是OOCSS。<br>对BEM感兴趣的话，可以访问<a href="https://en.bem.info/methodology/css/" target="_blank" rel="noopener">BEM的官网</a></p><h2 id="设计模式-SMACSS"><a href="#设计模式-SMACSS" class="headerlink" title="设计模式:SMACSS"></a>设计模式:SMACSS</h2><p>SMACSS is a way to examine your design process and as a way to fit those rigid frameworks into a flexible thought process. (SMACSS通过一个灵活的思维过程来检查你的设计过程和方式是否符合你的架构，更像一种规范~)</p><h3 id="核心思想-分类"><a href="#核心思想-分类" class="headerlink" title="核心思想:分类"></a>核心思想:分类</h3><ul><li>SMACSS的核心就是分类，它主要要求分为五大类分别是：Base、Layout、Modules、State、Theme</li><li>Base是对浏览器默认样式的重置，常见的<a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">normalize.css</a>就属于此。这里样式只会对标签元素本身做设定，不会出现任何 class 或id，但是可以有属性选择器或是伪类.</li><li>Layout对页面布局的一些功能，属于较高的一层，它可以作为层级较低的Module Rules元素的容器。左右分栏、栅格系统等都属于布局规范。SMACSS还约定命名使用l-/layout-前缀来标识布局的class。</li><li>Modules公共复用的小模块，模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。SMACSS中的模块具有自己的一个命名，隶属于模块下的类皆以该模块为前缀，例如：.menu .menu-title等。</li><li>State对不同的展示效果，例如显示、隐藏，与BEM抽取修饰类的方式的不同，SMACSS是抽取更高级别的样式类，得到更强的复用性，命名全都以is-前缀,如:is-hidden。</li><li>Theme对不同主题皮肤的维护，可以修改前面4个类别的样式，且应和前面4个类别分离开来（便于切换，也就是“换肤”）。命名规范需要添加theme-前缀。</li></ul><h3 id="最小适配深度原则"><a href="#最小适配深度原则" class="headerlink" title="最小适配深度原则"></a>最小适配深度原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* depth 1 */</span><br><span class="line">.sidebar ul h3 &#123;&#125;</span><br><span class="line">/* depth 2 */</span><br><span class="line">.sub-title &#123;&#125;</span><br></pre></td></tr></table></figure><p>两段css的区别在于html和css的耦合度(这一点上和OOCSS的分离容器和内容的原则不谋而合)。可以想到，由于上面的样式规则使用了继承选择符，因此对于html的结构实际是有一定依赖的。如果html发生重构，就有可能不再具有这些样式。对应的，下面的样式规则只有一个选择符，因此不依赖于特定html结构，只要为元素添加class，就可以获得对应样式。<br>当然，继承选择符是有用的，它可以减少因相同命名引发的样式冲突（常发生于多人协作开发）。但是，我们不应过度使用，在不造成样式冲突的允许范围之内，尽可能使用短的、不限定html结构的选择符。这就是SMACSS的最小化适配深度的意义。<br>在项目中使用SMACSS时，每一个分类都是一个目录，但是在Vue中，Layout和Modules不需要单独维护目录，因为我们写的布局组件和模块组件就相当于这两个分类了。<br>如果想要对SMACSS更详细的了解可以访问<a href="https://smacss-zh.vercel.app/preface.html" target="_blank" rel="noopener">SMACSS</a></p><h2 id="设计模式-ITCSS"><a href="#设计模式-ITCSS" class="headerlink" title="设计模式:ITCSS"></a>设计模式:ITCSS</h2><p>这是由<a href="https://csswizardry.com/" target="_blank" rel="noopener">csswizardry</a>提倡的一个 CSS 设计方法论，它可以让CSS更好的管理和维护。<br>使用ITCSS主要可以帮助我们以下几点:</p><ul><li>Manages source order.(管理 CSS 代码的书写顺序)</li><li>Filters explicitness.(过滤器的明确性，是说分层来明确每层 CSS 的作用)</li><li>Tames the cascade.(控制好 CSS 的权重)</li><li>Sanitises inheritance.(安全地使用继承)</li></ul><h3 id="核心思想-分层"><a href="#核心思想-分层" class="headerlink" title="核心思想:分层"></a>核心思想:分层</h3><p>TCSS的核心是分层,主要分为七层, 与SMACSS的分类相比更加精细，层次分的更细主要有:</p><table><thead><tr><th>Layer</th><th>作用</th></tr></thead><tbody><tr><td>Settings</td><td>项目使用的全局变量</td></tr><tr><td>Tools</td><td>mixin，function</td></tr><tr><td>Generic</td><td>最基本的设定 normalize.css，reset</td></tr><tr><td>Base</td><td>type selector</td></tr><tr><td>Objects</td><td>不经过装饰 (Cosmetic-free) 的设计模式，相当于SMACSS的Layout</td></tr><tr><td>Components</td><td>UI 组件</td></tr><tr><td>Trumps</td><td>helper 唯一可以使用 !important 的地方</td></tr></tbody></table><p>下面就是ITCSS的架构模型:<br><img src="/2022/08/15/CSS设计模式/3.jpg" alt="img"><br>从这个模型可以看出来，越往下就越具体，越局限于使用在某个具体的东西。另外它的下一层永远继承上一层的所有样式。</p><h3 id="各个分层例子"><a href="#各个分层例子" class="headerlink" title="各个分层例子"></a>各个分层例子</h3><h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4><p>全局变量，比如颜色，字体大小等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$yellow: #FAAF00;</span><br><span class="line">$yellow-bright: #FAF7F0;</span><br></pre></td></tr></table></figure></p><h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><p>mixin，function 等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@mixin sample-mixin () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到 Tools 为止，不会生成具体的 css</p><h4 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h4><p>reset，normalize 等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*,</span><br><span class="line">*::before,</span><br><span class="line">*::after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors" target="_blank" rel="noopener">type selector</a> 比如 link, p 等等，只有这一层才使用 type selector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  margin: 0</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h4><p>Cosmetic-free，不使用比如 color、border-color、background-color 之类的<br>使用这个 CSS 你在浏览器上面只可以看一片空白<br>主要用来做画面的 layout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.o-container &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p>UI 组件<br>到这个部分，根据UI分析具体有哪些组件需要实现，可以分给多个人来同时实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># button组件</span><br><span class="line">.c-btn &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  ...</span><br><span class="line">  &amp;--primary &#123;</span><br><span class="line">    background-color: #ff5959;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;--large &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    padding: 16px 14px;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HTML 类似这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=&quot;c-btn c-btn--primary&quot; href=&quot;#&quot;&gt;sample&lt;/a&gt;</span><br><span class="line">&lt;a class=&quot;c-btn c-btn--primary c-btn--large&quot; href=&quot;#&quot;&gt;sample&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Trumps"><a href="#Trumps" class="headerlink" title="Trumps"></a>Trumps</h4><p>放各种 helper<br>最主要的作用是用在不适合或者不容易放在 Component 的时候<br>比如 margin，很可能不应该放 Component，这时候可以用 Trumps 来微调<br>这样可以防止你的 Component 变得非常大<br>只有这一层才可以使用! important，以此来避免多个! important 的混乱局面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.u-color &#123;</span><br><span class="line">  &amp;--white &#123;</span><br><span class="line">    color: $white !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.u-hidden &#123;</span><br><span class="line">  display: hidden !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在使用时，每个分层都维护为一个文件夹。在Vue中使用时，Objects和Components相当于我们的组件，不需要单独维护。<br>另外值得注意的是，无论是SMACSS的分类还是ITCSS的分层，都是一种思想，我们可以根据实际项目来动态的添加或者删除某一个分类或者分层，不能生搬硬套。</p></blockquote><h2 id="设计模式-ACSS"><a href="#设计模式-ACSS" class="headerlink" title="设计模式:ACSS"></a>设计模式:ACSS</h2><p>ACSS使用了紧密的类名库。 这些类名通常被缩写，并与它们影响的内容分开。 在ACSS系统中，我们可以知道类名的作用； 但是类名称与内容类型之间没有关系,即每一个样式对应一个类，也称原子类CSS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.float-left &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">.float-right &#123;</span><br><span class="line">  float: right;</span><br><span class="line">&#125;</span><br><span class="line">.z-0 &#123;</span><br><span class="line">  z-index: 0;</span><br><span class="line">&#125;</span><br><span class="line">.z-auto &#123;</span><br><span class="line">  z-index: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中，可以看到ACSS有极强的复用性,维护成本低，但是破坏了css命名的语义化。最终很可能代码会成为下面这样。但是存在即合理，ACSS也有其作用，继续往下看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;grid grid-cols-3 gap-2 place-content-center h-48 ...&quot;&gt;</span><br><span class="line">  &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><a href="https://tailwindcss.com/" target="_blank" rel="noopener">tailwindcss</a>是一个典型的ACSS框架。</p><h2 id="混合使用CSS设计模式"><a href="#混合使用CSS设计模式" class="headerlink" title="混合使用CSS设计模式"></a>混合使用CSS设计模式</h2><p>在进行一个项目的设计时,我们可以针对多种CSS设计模式进行选型，结合不同设计模式的优点和缺点，设计一个完整银杏的CSS架构。<br>假如我们选择ITCSS、BEM、ACSS进行组合，设计一个CSS架构。<br>在我们设计CSS架构时,我们首先想到的一定是SMACSS和ITCSS,因为它们两个对CSS进行了分类分层的划分。</p><table><thead><tr><th>SMACSS</th><th>ITCSS</th></tr></thead><tbody><tr><td>Base</td><td>Setting</td></tr><tr><td>Layout</td><td>Tools</td></tr><tr><td>Modules</td><td>Generic</td></tr><tr><td>State</td><td>Base</td></tr><tr><td>Theme</td><td>Objects</td></tr><tr><td></td><td>Components</td></tr><tr><td></td><td>Trumps</td></tr></tbody></table><p>根据上表我们可以看出ITCSS分层更加精细，所以我们选择ITCSS，接着我们继续看ITCSS的Objects和Components层，它就相当于OOCSS且相当于开发Vue组件，所以我们在开发组件时使用选择OOCSS的进阶版BEM。我们知道如果一个项目全部使用ACSS的缺点跟明显，那么我们选择ACSS的原因是因为项目中可能会存在向字体大小的这种的样式,所以我们可以把这一类样式维护在ACSS目录中。Generic和Base类似所以只保留Base即可，我假设Trumps用不到,所以也去掉这一层。所以我们的架构现在就是下面这样。</p><table><thead><tr><th>ITCSS+BEM+ACSS</th></tr></thead><tbody><tr><td>Setting</td></tr><tr><td>Tools</td></tr><tr><td>Base</td></tr><tr><td>Objects</td></tr><tr><td>Components</td></tr><tr><td>ACSS</td></tr></tbody></table><p>目录结构就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-|comments</span><br><span class="line">-|styles</span><br><span class="line">--|acss</span><br><span class="line">--|base</span><br><span class="line">--|settings</span><br><span class="line">--|tools</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSS设计模式听起来很深奥，但是大家在日常开发时，已经不知不觉的在使用，只不过是没有概念而已。在开发中熟练的使用CSS设计模式，可以使代码结构思路清晰，易于阅读，维护，如果想真正的在项目中写好CSS,CSS设计模式是必不可少的，也是我们开发者应该掌握的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS设计模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="样式" scheme="/tags/%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法基础-时间复杂度</title>
    <link href="/2022/08/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>/2022/08/05/算法基础-时间复杂度/</id>
    <published>2022-08-05T07:20:47.000Z</published>
    <updated>2022-08-05T08:19:41.307Z</updated>
    
    <content type="html"><![CDATA[<p>算法基础之时间复杂度<br><a id="more"></a><br>对于算法的衡量一般是从两个维度进行的，一是空间维度，即算法执行所需要占据的内存空间；一是时间维度，即算法执行所需要的时间，今天主讲时间维度。</p><h2 id="大O符号表示法"><a href="#大O符号表示法" class="headerlink" title="大O符号表示法"></a>大O符号表示法</h2><p>对于时间复杂度的衡量，我们最常见的就是使用大O符号表示法，例如O(1),O(n)等。之所以采用这样的方式衡量，是因为在不同配置的计算机上，相同的算法代码所呈现出来的性能也不尽相同。所以引入大O符号表示法可以使算法执行所消耗的时间标准化，更加易于对比。<br>大O符号表示法的完整格式是T(n)=O(f(n))，这个函数表示的是代码执行次数与所使用时间之间的正比例关系。其中f(n)表示算法中每行代码执行次数的和，O()表示一个正比例关系。所以大O符号表示法所表示的是算法执行时间的增长变化趋势的，而不是算法实际的执行时间。在使用大O符号表示法的时候，我们一般会假设算法中每一行代码的执行时间都是一样，也就是一个单位时间会运行一行代码，这样我们就能够方便的计算f(n)了。</p><h2 id="常见时间复杂度量级"><a href="#常见时间复杂度量级" class="headerlink" title="常见时间复杂度量级"></a>常见时间复杂度量级</h2><p>一般在代码设计中长长的出现的时间复杂度量级主要有以下这些：</p><ul><li>常数阶O(1)。</li><li>对数阶O(logN)。</li><li>线性阶O(n) 。</li><li>线性对数阶O(nlogN)。</li><li>平方阶O(n^2)。</li><li>立方阶O(n^3)。</li><li>K方阶O(n^k)。</li><li>指数阶O(2^n)。</li><li>组合阶O(n!)。</li></ul><p>以上这些复杂度量级从上到下所表示的复杂度越来越大，执行效率也越来越低。下面就一些示例来说明不同形式的代码其时间复杂度的量级。</p><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><p>代码中没有循环结构，无论执行多少行，代码所消耗的时间始终固定，不随着某个变量的操作发生变化，其复杂度就是O(1) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1</span><br><span class="line">j = 2</span><br><span class="line">i += 1</span><br><span class="line">j += 2</span><br></pre></td></tr></table></figure></p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><p>代码中只有一层循环结构，没有任何嵌套的循环结构，代码执行所消耗的时间只与循环控制变量线性相关，那么这段代码的复杂度就是O(n) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n =100;</span><br><span class="line">for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="O-logN"><a href="#O-logN" class="headerlink" title="O(logN)"></a>O(logN)</h3><p>代码中同样只有一层循环结构，没有任何嵌套的循环结构，但是代码执行所消耗的时间与循环控制变量指数相关，那么这段代码的复杂度就是O(logN)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int n = 1024;</span><br><span class="line">while(i &lt; n)&#123;</span><br><span class="line">    i = i*2;</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">for(int i=0; i&lt;n; i*=2)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从例子可以看出，时间复杂度是O(log2(n)),但是2可以忽略掉，直接写成O(log(n))。</p><h3 id="O-nlogN"><a href="#O-nlogN" class="headerlink" title="O(nlogN)"></a>O(nlogN)</h3><p>线性对数阶量级中就已经开始出现多层的循环结构了，在复杂度为O(nlogN)量级的代码中，有两层循环结构，其中一层为O(n)量级的循环，一层为O(logN)量级的循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n =100;</span><br><span class="line">int m = 1024;</span><br><span class="line">for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">  while(i &lt; m)&#123;</span><br><span class="line">    i = i*2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><p>平方阶O(n²) 就是把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n = 100;</span><br><span class="line">int m = 100;</span><br><span class="line">for (i=0; i &lt; n ; i++)&#123;</span><br><span class="line">  for(i=0; i &lt; m ;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="O-n-3-O-n-k"><a href="#O-n-3-O-n-k" class="headerlink" title="O(n^3) O(n^k)"></a>O(n^3) O(n^k)</h3><p>立方阶则是3层循环嵌套。<br>K方阶则是k层循环嵌套。</p><h3 id="O-2-n"><a href="#O-2-n" class="headerlink" title="O(2^n)"></a>O(2^n)</h3><p>下例从出现递归的时候，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long function1(int n) &#123;    </span><br><span class="line">  if (n &lt;= 1) &#123;        </span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;        </span><br><span class="line">    return function1(n - 1) + function1(n - 2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度分析的4个高阶概念"><a href="#复杂度分析的4个高阶概念" class="headerlink" title="复杂度分析的4个高阶概念"></a>复杂度分析的4个高阶概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。</li><li>最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。</li><li>平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。</li><li>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li></ul><h3 id="为什么要引入这4个概念？"><a href="#为什么要引入这4个概念？" class="headerlink" title="为什么要引入这4个概念？"></a>为什么要引入这4个概念？</h3><p>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p><h3 id="如何分析平均、均摊时间复杂度？"><a href="#如何分析平均、均摊时间复杂度？" class="headerlink" title="如何分析平均、均摊时间复杂度？"></a>如何分析平均、均摊时间复杂度？</h3><p>平均时间复杂度：代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。<br>均摊时间复杂度：两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是浅浅的介绍下算法的时间复杂度内容。<br>最后介绍一个图形工具<a href="https://zh.numberempire.com/" target="_blank" rel="noopener">数学工具</a><br>进入网站后，点击函数图像绘制工具，可以把复杂度量级以图形的方式直观的展示出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法基础之时间复杂度&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="算法" scheme="/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>node.js中的setTimeout,setImmediate,Promise,process.nextTick</title>
    <link href="/2022/08/02/node-js%E4%B8%AD%E7%9A%84setTimeout-setImmediate-Promise-process-nextTick/"/>
    <id>/2022/08/02/node-js中的setTimeout-setImmediate-Promise-process-nextTick/</id>
    <published>2022-08-02T08:37:15.000Z</published>
    <updated>2022-08-03T02:10:22.881Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs中的事件循环宏任务和微任务<br><a id="more"></a></p><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>首先，看一下nodejs的任务队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line"></span><br><span class="line">┌&gt; │timers          │执行setTimeout() 和 setInterval()中到期的callback</span><br><span class="line"></span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line"></span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line"></span><br><span class="line">│  │pending callbacks│执行系统操作的回调, 如:tcp, udp通信的错误callback</span><br><span class="line"></span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line"></span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line"></span><br><span class="line">│  │idle, prepare   │只在内部使用</span><br><span class="line"></span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line"></span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line"></span><br><span class="line">│  │poll            │执行与I/O相关的回调</span><br><span class="line"></span><br><span class="line">    │                  (除了close回调、定时器回调和setImmediate()之外，几乎所有回调都执行);</span><br><span class="line"></span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line"></span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line"></span><br><span class="line">│  │check           │执行setImmediate的callback</span><br><span class="line"></span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line"></span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line"></span><br><span class="line">└─┤close callbacks │执行close事件的callback，例如socket.on(&quot;close&quot;,func)</span><br><span class="line"></span><br><span class="line">    └───────────────────────┘</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure></p><p>nodejs任务队列有timers，pending callbacks，idle, prepare，poll ，check，close callbacks这6个阶段，其中第2，3个属于nodejs内部的不去探讨，还剩下1，4，5，6.<br>先看两个宏任务的执行顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;setImmediate&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>输出的结果不是固定的，可能是nodejs启动时进入的任务队列时机不一样造成的，再看下边的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./file.txt&apos;, &apos;utf-8&apos;, (err, data)=&gt; &#123;</span><br><span class="line">    setTimeout(()=&gt; &#123;</span><br><span class="line">        console.log(&apos;setTimeout&apos;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    </span><br><span class="line">    setImmediate(()=&gt; &#123;</span><br><span class="line">        console.log(&apos;setImmediate&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个例子的输出就是固定的，永远都是”setImmediate”,”setTimeout”,因为按照按照上边任务队列的表来看，poll之后就是check。</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>Promise和process.nextTick是两个微任务，他们不在任务队列的表格中。他们的执行跟在浏览器端一样，在宏任务之前执行，就是每个宏任务执行之后都会把微任务都执行完了再去执行宏任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;Promise&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;nextTick&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>nextTick优先顺序高于Promise</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后写一个宏任务和微任务都有的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">    process.nextTick(()=&gt; &#123;</span><br><span class="line">        console.log(&apos;setTimeout-nextTick&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;setImmediate&apos;);</span><br><span class="line">    process.nextTick(()=&gt; &#123;</span><br><span class="line">        console.log(&apos;setImmediate-nextTick&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;Promise&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(()=&gt; &#123;</span><br><span class="line">    console.log(&apos;nextTick&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行后发现，当有下边两个微任务在的时候，setTimeout永远在setImmediate前执行，当没有这两个微任务的时候，先后顺序又不一定了，侧面说明微任务可以校准任务队列的执行时机。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs中的事件循环宏任务和微任务&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web Component</title>
    <link href="/2022/06/22/Web-Component/"/>
    <id>/2022/06/22/Web-Component/</id>
    <published>2022-06-22T07:45:43.000Z</published>
    <updated>2022-06-22T08:06:25.943Z</updated>
    
    <content type="html"><![CDATA[<p>Web Component初探<br><a id="more"></a></p><h3 id="什么是-Web-Component"><a href="#什么是-Web-Component" class="headerlink" title="什么是 Web Component"></a>什么是 Web Component</h3><p>Web Component 是一种 W3C标准 支持的 组件化方案，通过它，我们可以编写可复用的 组件，同时，我们也可以对自己的组件做更精细化的控制。正如 PWA 一样，他并非一项单一的技术，而是由三项技术组成：</p><blockquote><p>1.Shadow DOM<br>2.Custom elements<br>3.HTML templates</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们准备编写一个 TextReverse 组件，TextReverse 只有一个很简单的功能，就是把传入的 字符串颠倒显示。<br>例如： <text-reverse text="123"></text-reverse> 将会显示 321。<br>第一步，我们需要 定义 这个自定义组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TextReverse extends HTMLElement &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        const shadowRoot = this.attachShadow(&#123; mode: &apos;open&apos; &#125;);</span><br><span class="line">        const text = this.getAttribute(&apos;text&apos;) || &apos;&apos;;</span><br><span class="line">        const wrapper = document.createElement(&apos;span&apos;);</span><br><span class="line">        wrapper.textContent = text.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        shadowRoot.appendChild(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义组件的方式也十分简单，我们只需要 继承一下 HTMLElement，然后在 构造函数 中编写自己的 初始化逻辑 就可以了。<br>初始化过程中，我们首先 创建了一个 shadowRoot，这个相当于是我们整个组件的一个 根结点。<br>紧接着，我们获取到自身的 text 属性，并且将其 倒置 放入新创建的 span 元素中。<br>最后，我们把带有 text 的 span 塞入 shadowRoot。<br>定义完成之后，我们要告知一下系统，也就是 组件注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(</span><br><span class="line">    &apos;text-reverse&apos;,</span><br><span class="line">    TextReverse</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>这里有一个小细节，就是我们注册的名字必须是带短横线的。<br>注册完成之后就可以正式使用啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-reverse text=&apos;12345&apos;&gt;&lt;/text-reverse&gt;</span><br></pre></td></tr></table></figure></p><p>上面的例子中，我们用到了 shadow root，他承载着我们组件所有的内容。而他也是 Web Component 核心技术。<br>我们都知道 Dom 其实就是一棵树，而我们的组件则是树上的一个节点。我们可以称组件节点为 shadow host。<br>shadow host 中含有一颗与外界隔离的 dom 树，我们称之为 shadow tree。shadow tree 中的内容不会影响到外界。Shadow Root 则是这一课shadow tree 的根节点。</p><h3 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h3><p>shadow dom 一大亮点就是样式隔离。我们可以给之前的例子加上样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class TextReverse extends HTMLElement &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // ...</span><br><span class="line">        const style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.textContent = `* &#123;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;`</span><br><span class="line">        shadowRoot.appendChild(style);</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们给所有元素添加一个红的背景色。但是，结果只有组件内的元素背景色受到了影响。这种样式隔离的特性很好地避免了不同组件之间的样式干扰。</p><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><p>在上面的例子中，我们采用代码的方式来创建修改节点。相较于 React 的 Jsx 和 Vue 的模版，这种方法比较低效。所以，我们可以使用 Template 来解决这问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&apos;text-reverse&apos;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        *&#123;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;span id=&apos;text&apos;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">class TextReverse extends HTMLElement &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        const shadowRoot = this.attachShadow(&#123; mode: &apos;open&apos; &#125;);</span><br><span class="line">        const text = this.getAttribute(&apos;text&apos;) || &apos;&apos;;</span><br><span class="line">        const template = document.getElementById(&apos;text-reverse&apos;).content.cloneNode(true);</span><br><span class="line">        template.getElementById(&apos;text&apos;).textContent = text.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        shadowRoot.appendChild(template);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在 html 中定义了一个 template，然后，就和操作普通元素一样获取到 template 节点，然后深拷贝一份节点内容。最后直接操作这个节点。</p><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>和 Vue 的 Slot 相似，Slot 赋予了组件更高的可扩展性。通过 Slot，我们可以给组件传入更多的自定义内容。<br>在上面的例子中，我们给组件添加一个自定义的标题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-reverse text=&apos;12345&apos;&gt;</span><br><span class="line">    &lt;span slot=&apos;title&apos;&gt;text reverse&lt;/span&gt;</span><br><span class="line">&lt;/text-reverse&gt;</span><br><span class="line">&lt;template id=&apos;text-reverse&apos;&gt;</span><br><span class="line">        &lt;h1&gt;&lt;slot name=&apos;title&apos;&gt;default title&lt;/slot&gt;&lt;/h1&gt;</span><br><span class="line">        &lt;span id=&apos;text&apos;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>模版中，我们定义一个 slot 元素，命名为 title，并且设置一个无内容时的默认值 default title。 使用的时候，我们在元素中添加一个 slot 属性来与模版中的 slot 相匹配。</p><h3 id="继承现有元素"><a href="#继承现有元素" class="headerlink" title="继承现有元素"></a>继承现有元素</h3><p>至今，我们都是完全自定义组件内容，假如我们想扩展现有系统元素，那就需要定义一个 内置自定义元素。 我们来用一个屏蔽数字的 p 元素来说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class PFilter extends HTMLParagraphElement &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        const textContent = this.textContent;</span><br><span class="line">        this.textContent = textContent.replace(/\d/g, &apos;*&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(</span><br><span class="line">    &apos;p-filter&apos;,</span><br><span class="line">    PFilter,</span><br><span class="line">    &#123;</span><br><span class="line">        extends: &apos;p&apos;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>我们这边不再是继承 HTMLElement，而是继承需要扩展的 p节点 HTMLParagraphElement。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p is=&apos;p-filter&apos;&gt;我的手机号是：10086&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>不同于独立自定义组件，我们还是需要用原有元素名去声明，并且在 is 属性中填写我们的组件名。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>和大多数框架一样，Web Component 也含有许多控制组件生命周期的方法。</p><blockquote><p>1.connectedCallback：当 custom elemen t首次被插入 DOM 时，被调用。<br>2.disconnectedCallback：当 custom element 从 DOM 中删除时，被调用。<br>3.adoptedCallback：当 custom element 被移动到新的文档时，被调用。<br>4.attributeChangedCallback: 当 custom element 增加、删除、修改自身属性时，被调用。</p></blockquote><p>我们只需在定义组件的类中声明对应的方法即可。attributeChangedCallback 相对与别的属性比较特别，他需要 搭配 observedAttributes 使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TextReverse extends HTMLElement &#123;</span><br><span class="line">    //...</span><br><span class="line">    static get observedAttributes () &#123;</span><br><span class="line">        return [&apos;text&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    attributeChangedCallback () &#123;</span><br><span class="line">        const text = this.getAttribute(&apos;text&apos;) || &apos;&apos;;</span><br><span class="line">        this.shadowRoot.getElementById(&apos;text&apos;).textContent = text.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在 observedAttributes静态方法中添加需要监听的属性值。然后，在 text 改变的时候，触发 attributeChangedCallback方法来更新 text的值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Web Component 的功能十分强大，相较于 React，Vue等框架，他天生自带样式隔离，并且最主要的是拥有浏览器的原生支持。不过，想要达到工程开发标准 的话，他还有一段很长很长的路要走。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web Component初探&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Service Worker</title>
    <link href="/2022/06/06/Service-Worker/"/>
    <id>/2022/06/06/Service-Worker/</id>
    <published>2022-06-06T07:51:56.000Z</published>
    <updated>2022-06-06T08:48:05.785Z</updated>
    
    <content type="html"><![CDATA[<p>Service Worker初探<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>service worker定义先不谈，主要简单的介绍下笔者对service worker流程理解,也就是生命周期,直奔主题。</p><blockquote><p>1.第一次进入html文件时，注册service worker文件(sw.js)，接下来sw.js文件中的install事件响应，紧接着activate事件响应，最后是register注册的Promise的then执行，记住，这时registration的状态是installed。在第一次打开网页时，install和activate事件都会执行，可以在install事件里做缓存配置处理，可以在activate事件里做删除无用的缓存处理。<br>2.再次进入这个页面时，因为第一次已经注册了sw.js文件，所以install和activate事件是不会执行的，但是fetch事件可以执行，也可以理解为，再次进入这个页面时，service worker已经接管了这个页面，可以在fetch事件里对请求做处理，也就是service worker的核心功能所在。这时registration的状态是active。<br>3.service worker和html页面是分离的，页面关闭，service worker并不会关闭，每次打开html页面时，这个页面注册过的service worker都会对其进行监管操作，一个页面可以对应多个service worker，只有active状态下的service worker才是正在工作的。因为每次在修改了sw.js文件后，浏览器会自动检查这个文件是否有改变，如果有改变了，会执行步骤1的注册流程，这个时候可以在install事件中，加上self.skipWaiting()，它的作用是将当前的service worker状态提升到active，接管网页操作。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>sw.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/6.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;service worker&lt;/h1&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">      /* 当页面加载完成就创建一个serviceWorker */</span><br><span class="line">      window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">        /* 创建并指定对应的执行内容 */</span><br><span class="line">        /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 &apos;/&apos;，表示 根网域下的所有内容。这也是默认值。 */</span><br><span class="line">        navigator.serviceWorker.register(&apos;./sw.js&apos;, &#123;scope: &apos;./&apos;&#125;)</span><br><span class="line">          .then(function (registration) &#123;</span><br><span class="line">            if (registration.installing) &#123;</span><br><span class="line">              console.log(&apos;Service worker installing&apos;);</span><br><span class="line">            &#125; else if (registration.waiting) &#123;</span><br><span class="line">              console.log(&apos;Service worker installed&apos;);</span><br><span class="line">            &#125; else if (registration.active) &#123;</span><br><span class="line">              console.log(&apos;Service worker active&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (err) &#123;</span><br><span class="line">            console.log(&apos;ServiceWorker registration failed: &apos;, err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>sw.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">var CACHE_NAME = &apos;v1&apos;;</span><br><span class="line">/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */</span><br><span class="line">this.addEventListener(&apos;install&apos;, function (event) &#123;</span><br><span class="line">  console.log(&apos;install-&apos;+CACHE_NAME);</span><br><span class="line">  self.skipWaiting();</span><br><span class="line">  event.waitUntil(</span><br><span class="line">      /* 创建一个名叫V1的缓存版本 */</span><br><span class="line">      caches.open(CACHE_NAME).then(function (cache) &#123;</span><br><span class="line">          /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */</span><br><span class="line">          return cache.addAll([</span><br><span class="line">              &apos;/sw.html&apos;,</span><br><span class="line">              &apos;./lib/1.js&apos;,</span><br><span class="line">              &apos;./lib/2.js&apos;,</span><br><span class="line">              &apos;./lib/3.js&apos;,</span><br><span class="line">          ]);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">// 激活事件</span><br><span class="line">this.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;activate&apos;);</span><br><span class="line">  let cacheWhitelist = [CACHE_NAME];</span><br><span class="line">    // 将其他的chace缓存清除</span><br><span class="line">    event.waitUntil(</span><br><span class="line">      caches.keys().then (cacheNames =&gt; &#123;</span><br><span class="line">        return Promise.all(</span><br><span class="line">          cacheNames.map( cacheName =&gt; &#123;</span><br><span class="line">            if (cacheWhitelist.indexOf(cacheName) === -1) &#123;</span><br><span class="line">              return caches.delete(cacheName)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line">// fetch事件-是否是install时缓存的文件</span><br><span class="line">// this.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">//   event.respondWith(caches.match(event.request).then(function (response) &#123;</span><br><span class="line">//     if (response) &#123;</span><br><span class="line">//       console.log(response, &apos;------&apos;);</span><br><span class="line">//       return response</span><br><span class="line">//     &#125; else &#123;</span><br><span class="line">//       console.log(event.request, &apos;========&apos;);</span><br><span class="line">//       return fetch(event.request)</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;));</span><br><span class="line">// &#125;);</span><br><span class="line">// fetch事件-</span><br><span class="line">this.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">  if (navigator.onLine) &#123;</span><br><span class="line">    return fetch(event.request.clone()).then(function (response) &#123;</span><br><span class="line">      if (!response || response.status !== 200) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      caches.open(CACHE_NAME).then(function (cache) &#123;</span><br><span class="line">        cache.put(event.request, response.clone())</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return response</span><br><span class="line">    &#125;).catch(function (err) &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    event.respondWith(caches.match(event.request).then(function (response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        // A cached response has been found!</span><br><span class="line">        return response</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // We don&apos;t have a cached response, initiate a fetch...</span><br><span class="line">        return fetch(event.request)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>service worker功能非常强大，PWA就是基于service worker，以上只是简单的介绍，不过生命周期也就这么多内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Service Worker初探&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="worker" scheme="/tags/worker/"/>
    
  </entry>
  
  <entry>
    <title>Web Worker</title>
    <link href="/2022/06/01/Web-Worker/"/>
    <id>/2022/06/01/Web-Worker/</id>
    <published>2022-06-01T08:26:47.000Z</published>
    <updated>2022-06-01T08:49:42.226Z</updated>
    
    <content type="html"><![CDATA[<p>Web Server的简单介绍<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Web Worker使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行任务，从而允许主（通常是UI）线程运行而不被阻塞。<br>它的作用就是给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。这样做的好处是主线程可以把计算密集型或高延迟的任务交给worker线程执行，这样主线程就会变得轻松，不会被阻塞或拖慢。这并不意味着JS语言本身支持了多线程能力，而是浏览器作为宿主环境提供了JS一个多线程运行的环境。<br>不过因为worker一旦新建，就会一直运行，不会被主线程的活动打断，这样有利于随时响应主线程的通性，但是也会造成资源的浪费，所以不应过度使用，用完注意关闭。或者说：如果worker无实例引用，该worker空闲后立即会被关闭；如果worker实列引用不为0，该worker空闲也不会被关闭。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>同源限制<br>worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧</li><li>文件限制<br>为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源</li><li>DOM操作限制<br>worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、window等对象，但是可以获取navigator、location(只读)、XMLHttpRequest、setTimeout族等浏览器API。</li><li>通信限制<br>worker线程与主线程不在同一个上下文，不能直接通信，需要通过postMessage方法来通信。</li><li>脚本限制<br>worker线程不能执行alert、confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>worker线程的js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// workerThread1.js</span><br><span class="line">let i = 1</span><br><span class="line">function simpleCount() &#123;</span><br><span class="line">  i++</span><br><span class="line">  self.postMessage(i)</span><br><span class="line">  setTimeout(simpleCount, 1000)</span><br><span class="line">&#125;</span><br><span class="line">simpleCount()</span><br><span class="line">self.onmessage = ev =&gt; &#123;</span><br><span class="line">  postMessage(ev.data + &apos; 呵呵~&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>html文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  Worker 输出内容：&lt;span id=&apos;app&apos;&gt;&lt;/span&gt;</span><br><span class="line">  &lt;input type=&apos;text&apos; title=&apos;&apos; id=&apos;msg&apos;&gt;</span><br><span class="line">  &lt;button onclick=&apos;sendMessage()&apos;&gt;发送&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&apos;stopWorker()&apos;&gt;stop!&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&apos;text/javascript&apos;&gt;</span><br><span class="line">  if (typeof(Worker) === &apos;undefined&apos;)// 使用Worker前检查一下浏览器是否支持</span><br><span class="line">    document.writeln(&apos; Sorry! No Web Worker support.. &apos;)</span><br><span class="line">  else &#123;</span><br><span class="line">    window.w = new Worker(&apos;workerThread1.js&apos;)</span><br><span class="line">    window.w.onmessage = ev =&gt; &#123;</span><br><span class="line">      document.getElementById(&apos;app&apos;).innerHTML = ev.data</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    window.w.onerror = err =&gt; &#123;</span><br><span class="line">      w.terminate()</span><br><span class="line">      console.log(error.filename, error.lineno, error.message) // 发生错误的文件名、行号、错误内容</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sendMessage() &#123;</span><br><span class="line">      const msg = document.getElementById(&apos;msg&apos;)</span><br><span class="line">      window.w.postMessage(msg.value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function stopWorker() &#123;</span><br><span class="line">      window.w.terminate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>主线程中的api，worker表示是 Worker 的实例</p><blockquote><p>worker.postMessage: 主线程往worker线程发消息，消息可以是任意类型数据，包括二进制数据<br>worker.terminate: 主线程关闭worker线程<br>worker.onmessage: 指定worker线程发消息时的回调，也可以通过worker.addEventListener(‘message’,cb)的方式<br>worker.onerror: 指定worker线程发生错误时的回调，也可以 worker.addEventListener(‘error’,cb)</p></blockquote><p>Worker线程中全局对象为 self，代表子线程自身，这时 this指向self</p><blockquote><p>self.postMessage: worker线程往主线程发消息，消息可以是任意类型数据，包括二进制数据<br>self.close: worker线程关闭自己<br>self.onmessage: 指定主线程发worker线程消息时的回调，也可以self.addEventListener(‘message’,cb)<br>self.onerror: 指定worker线程发生错误时的回调，也可以 self.addEventListener(‘error’,cb)</p></blockquote><p>注意，w.postMessage(aMessage, transferList) 方法接受两个参数，aMessage 是可以传递任何类型数据的，包括对象，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。一个可选的 Transferable对象的数组，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用（中止），并且只有在它被发送到的worker中可用。可转移对象是如ArrayBuffer，MessagePort或ImageBitmap的实例对象，transferList数组中不可传入null。</p><p>worker线程中加载脚本的api</p><blockquote><p>importScripts(‘script1.js’)    // 加载单个脚本<br>importScripts(‘script1.js’, ‘script2.js’)    // 加载多个脚本</p></blockquote><h2 id="实战场景"><a href="#实战场景" class="headerlink" title="实战场景"></a>实战场景</h2><ul><li>加密数据<br>有些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致UI线程无响应，因此这是使用Web Worker的好时机，使用Worker线程可以让用户更加无缝的操作UI。</li><li>预取数据<br>有时候为了提升数据加载速度，可以提前使用Worker线程获取数据，因为Worker线程是可以是用 XMLHttpRequest 的。</li><li>预渲染<br>在某些渲染场景下，比如渲染复杂的canvas的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用Worker线程来执行，也可以使用多个Worker线程，这里有个<a href="https://nerget.com/rayjs-mt/rayjs.html" target="_blank" rel="noopener">射线追踪的示例</a>。</li><li>复杂数据处理场景<br>某些检索、排序、过滤、分析会非常耗费时间，这时可以使用Web Worker来进行，不占用主线程。</li><li>预加载图片<br>有时候一个页面有很多图片，或者有几个很大的图片的时候，如果业务限制不考虑懒加载，也可以使用Web Worker来加载图片，可以参考一下<a href="https://juejin.cn/post/6844903510673211400" target="_blank" rel="noopener">这篇文章的探索</a>，这里简单提要一下。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web Server的简单介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="worker" scheme="/tags/worker/"/>
    
  </entry>
  
  <entry>
    <title>Map与WeakMap(垃圾回收角度)</title>
    <link href="/2022/05/30/Map%E4%B8%8EWeakMap-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A7%92%E5%BA%A6/"/>
    <id>/2022/05/30/Map与WeakMap-垃圾回收角度/</id>
    <published>2022-05-30T05:25:18.000Z</published>
    <updated>2022-05-30T05:58:14.889Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs环境，垃圾回收角度看Map与WeakMap区别<br><a id="more"></a></p><h3 id="Map与WeakMap简单区别"><a href="#Map与WeakMap简单区别" class="headerlink" title="Map与WeakMap简单区别"></a>Map与WeakMap简单区别</h3><blockquote><p>Map的键值可以是原始数据类型和引用类型，WeakMap的键值只能说引用类型（object）。<br>Map可以迭代遍历键，WeakMap不可迭代遍历键。<br>WeakMap中的”weak“表示弱映射的键是”弱弱地拿着“的，意思就是，这些键不属于正式的引用。<br>换言之，WeakMap所构建的实例中，其key键所对应引用地址的引用断开或不属于指向同一个内存地址的时候，其对应value值就会被加入垃圾回收队伍。（粗暴理解为：因为key必须是个引用类型，当key引用断了或变了，这个键值对就可以进垃圾桶了）<br>观察内存空间理解WeakMap，因为通常条件下很难察觉WeakMap里面keyValue什么时候消失，但是通过某一个引用类型的值大到足够占据一定内存时候，我们可以通过观察内存的变化来观察WeakMap的特性。</p></blockquote><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>Node.js的进程Api process.memoryUsage()配合手动垃圾回收global.gc()在终端观察。（也可以使用Chrome浏览器Performance功能录制内存变化）</p><blockquote><p>glabal.gc()<br>手动调用一次垃圾回收。需要在运行js文件时候增加命令 –expose-gc，一般环境下不推荐使用，这里做学习用。</p></blockquote><blockquote><p>process.memoryUsage()<br>查看Node进程的内存占用情况,返回值为对象其中包含五个属性 rss，heapTotal，heapUsed，external，arrayBuffers；其中主要属性是 heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用的内存量,单位都为字节。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>1.WeakMap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 第一次手动清理垃圾以确保为最新状态，观察内存情况</span><br><span class="line">global.gc();</span><br><span class="line">console.log(`第一次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);</span><br><span class="line">const wm = new WeakMap();</span><br><span class="line"></span><br><span class="line">let key = &#123;&#125;;</span><br><span class="line">// 给 WeakMap实例 赋值一个 占领内存足够大的 键值对</span><br><span class="line">wm.set(key, new Array(114514 * 19));</span><br><span class="line">// 手动清理一下垃圾 观察内存占用情况</span><br><span class="line">global.gc();</span><br><span class="line">console.log(`第二次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);</span><br><span class="line"></span><br><span class="line">// 此时把 key键 的引用进行断开，并观察内存占用情况</span><br><span class="line">key = null;</span><br><span class="line">// key = new Array();  </span><br><span class="line">// 这种改变引用地址写法也可以引起 弱映射，因为引用地址不再是同块内存地址 WeakMap内对应的value也会被垃圾回收</span><br><span class="line"></span><br><span class="line">global.gc();</span><br><span class="line">console.log(`第三次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`);</span><br><span class="line"></span><br><span class="line">$ node --expose-gc index.js</span><br><span class="line"></span><br><span class="line">第一次垃圾回收，当前内存使用情况：1.66MB</span><br><span class="line">第二次垃圾回收，当前内存使用情况：18.45MB</span><br><span class="line">第三次垃圾回收，当前内存使用情况：1.84MB</span><br></pre></td></tr></table></figure></p><p>2.Map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 第一次手动清理垃圾以确保为最新状态，观察内存情况</span><br><span class="line">global.gc();</span><br><span class="line">console.log(</span><br><span class="line">  `第一次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB`</span><br><span class="line">);</span><br><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">let key = &#123;&#125;;</span><br><span class="line">m.set(key, new Array(114514 * 19));</span><br><span class="line">// 手动清理一下垃圾 观察内存占用情况</span><br><span class="line">global.gc();</span><br><span class="line">console.log(</span><br><span class="line">  `第二次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB，</span><br><span class="line">  当前Map的长度: $&#123;m.size&#125;`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 此时把 key键 的引用进行断开，并观察内存占用情况</span><br><span class="line">key = null;</span><br><span class="line">global.gc();</span><br><span class="line">console.log(</span><br><span class="line">  `第三次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB，</span><br><span class="line">  当前Map的长度: $&#123;m.size&#125;`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 清除Map所有键值对</span><br><span class="line">m.clear();</span><br><span class="line"></span><br><span class="line">global.gc();</span><br><span class="line">console.log(</span><br><span class="line">  `第四次垃圾回收，当前内存使用情况：$&#123;(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)&#125;MB，</span><br><span class="line">  当前Map的长度: $&#123;m.size&#125;`</span><br><span class="line">);</span><br><span class="line">$ node --expose-gc index.js</span><br><span class="line">第一次垃圾回收，当前内存使用情况：1.66MB</span><br><span class="line">第二次垃圾回收，当前内存使用情况：18.45MB，当前Map的长度: 1</span><br><span class="line">第三次垃圾回收，当前内存使用情况：18.45MB，当前Map的长度: 1</span><br><span class="line">第四次垃圾回收，当前内存使用情况：1.85MB，当前Map的长度: 0</span><br></pre></td></tr></table></figure></p><p>由此可见Map所构建的实例是需要手动清理，才能被垃圾回收清除，而WeakMap只要外部的引用消失，所对应的键值对就会自动被垃圾回收清除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs环境，垃圾回收角度看Map与WeakMap区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
