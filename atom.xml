<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2024-06-21T02:49:54.777Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Vue.js 设计与实现》速读</title>
    <link href="/2024/06/21/%E3%80%8AVue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%80%9F%E8%AF%BB/"/>
    <id>/2024/06/21/《Vue-js-设计与实现》速读/</id>
    <published>2024-06-21T02:21:16.000Z</published>
    <updated>2024-06-21T02:49:54.777Z</updated>
    
    <content type="html"><![CDATA[<p>《Vue.js 设计与实现》概要总结<br><a id="more"></a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这是一本没有带你阅读一行源码，却可以让你在阅读完成之后，对 <code>vue 3</code> 所有的核心逻辑 <strong>了如指掌</strong> 的书籍。</p><p>无论是 <strong>响应性、调度系统、惰性执行</strong> ，还是 <strong>渲染器、diff 算法、编辑器三大步 </strong>  ，甚至是 <strong>有限自动状态机</strong> 等所有你能想到知识，本书都可以给你答案。</p><p>它就是  <strong>尤雨溪亲自做序</strong> ，<strong>Vue 官方团队成员：霍春阳</strong> 编写的  <strong>Vue.js 设计与实现</strong>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当前这个时间段下，关于 <code>vue 3</code> 源码的书籍，主要有两本。</p><p>第一本就是，咱们本次要讲的  <strong>《Vue.js 设计与实现》</strong>。</p><p>第二本是，<strong>《vue.js 技术内幕》</strong>，作者是黄轶。</p><p>正巧，两本书我都买来了。</p><p>这两本书，虽然都是讲解 <code>vue 3</code> 源码的，但是在讲解的方式上，有非常大的区别。</p><p>首先是 《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 <strong>从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序）</strong>，以 <strong>提出问题 - 分析思路 - 解决问题</strong> 的方式，来讲解 <code>vue 3</code> 的核心设计。其内部，没有读一行 <code>vue3</code> 的源码，但却可以让我们对整个 <code>vue 3</code> 的核心，拥有一个非常清楚的认知。</p><p>其次是 《vue.js 技术内幕》：它是一个标准的 “源码分析” 书籍，内部对 <code>vue 3</code> 的很多源码，进行了逐一的解读。</p><p>如果大家想要学习 <code>vue 3</code> 的设计思路，掌握框架设计的思维方式。那么我强烈推荐你看一看《Vue.js 设计与实现》。</p><p>如果你想要对 <code>vue</code> 源码进行逐一解读，那么可以看一下《vue.js 技术内幕》。</p><p>那么明确好了现在市面上学习 <code>vue 3</code> 源码的方式之后，下面就让我们进入到 《Vue.js 设计与实现》的学习中去吧！</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>《Vue.js 设计与实现》的内容一共分为 6 篇， <code>18</code> 个章节：</p><ul><li>首先第一篇：对 <code>vue</code> 的整个框架设计，进行了概述</li><li>第二篇：主要讲解了 <code>vue</code> 中的响应式系统，除了大家所熟悉的 <code>proxy</code> 之外，额外还包含了：调度系统 <code>scheduler</code>、惰性执行 <code>lazy</code>、<code>ref</code> 的实现原理</li><li>第三篇：主要针对 <code>vue</code> 的渲染器（<code>renderer</code>）进行了讲解，额外还包含了 <code>diff</code> 算法的详细讲解</li><li>第四篇：是组件化。包含了 组件的渲染机制，以及对 <code>vue</code> 官方组件 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 的实现原理，进行了剖析</li><li>第五篇：是编译器（<code>compiler</code>）。在这一篇中，把编译器的三大步：<code>parse</code>、<code>transform</code>、<code>generate</code> 进行了分步的讲解。</li><li>最后：是服务端渲染。主要是 <code>CSR</code>、<code>SSR</code> 以及 同构渲染。</li></ul><h2 id="第一篇：框架设计概览"><a href="#第一篇：框架设计概览" class="headerlink" title="第一篇：框架设计概览"></a>第一篇：框架设计概览</h2><p>整个第一篇分为三个章节：</p><ol><li>权衡的艺术：这里主要涉及到了 <code>vue</code> 框架设计的一些基本概念，也是咱们讲解的重点</li><li>框架设计的核心要素：相对比较杂，都是一些零碎的知识点</li><li>Vue.js 3 的设计思路：这一章包含了 <code>vue</code> 框架设计的逻辑主线，也非常重要，但是内容并不多</li></ol><p>那么首先咱们先来看第一章。</p><h3 id="第一章：权衡的艺术"><a href="#第一章：权衡的艺术" class="headerlink" title="第一章：权衡的艺术"></a>第一章：权衡的艺术</h3><p>在这一章中，开头的一句话，描述了框架设计的精髓，这句话也是尤雨溪在多个开发者大会中经常提到的，那就是：<strong>框架的设计，本身就是一种权衡的艺术</strong>。</p><p>在这一章中，书中分别从三个方面来去分析了所谓权衡的艺术，到底是什么意思。</p><h4 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h4><p>首先第一个方面就是：<strong>命令式和声明式</strong> 的概念。</p><p>所谓 <strong>命令式</strong> 指的就是：<strong>关注过程</strong> 的范式。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231540415.png" alt="image-20230207231540415"></p><p>而 <strong>声明式</strong> 指的就是： <strong>关注结果</strong> 的范式。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207231536123.png" alt="image-20230207231536123"></p><p>什么意思呢？我们来举一个小例子：</p><blockquote><p>张三的妈妈，让张三去买酱油。</p><p>那么对于张三而言，他就需要：拿钱、出门、下楼、进超市、拿酱油、付钱、回家。</p><p>而对于张三的妈妈来说，她完全不需要关心张三做了什么，只需要对张三说一声就可以了。</p></blockquote><p>那么在这个例子中，张三就是一个典型的命令式，他需要完成整件事情的所有过程。</p><p>而张三的妈妈，就是典型的声明式，她不关心过程只关心结果。</p><p>那么这里大家来想一下，<code>vue</code> 是声明式的？还是命令式的？</p><p>对于 <code>vue</code> 而言，它的内部实现一定是 <strong>命令式</strong> 的，而我们在使用 <code>vue</code> 的时候，则是通过 <strong>声明式</strong> 来使用的。</p><p>也就是说： <strong>vue 封装了命令式的过程，对外暴露出了声明式的结果</strong></p><h4 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h4><p>在明确好了命令式和声明式的概念之后。接下来咱们来看下从 <strong>性能</strong> 层面，<code>vue</code> 所体现出来的一种权衡的方式。</p><p>针对于性能的分析，主要从两个方面去说。</p><p>首先第一个方面：大家觉得 <strong>是命令式的性能更强，还是声明式的性能更强呢？</strong></p><p>答案是：<strong>命令式的性能 &gt; 声明式的性能</strong>。</p><p>其实原因非常简单，对于 <strong>命令式</strong> 的代码而言，它直接通过 <strong>原生的 <code>JavaScript</code> 进行实现</strong>，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 <code>1</code>。</p><p>而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 <code>1 + N</code> 的。</p><p>那么既然如此，<code>vue</code> 为什么还要对外暴露出声明式的接口呢？</p><p>这其实是因为：<strong>声明式的可维护性，要远远大于命令式的可维护性</strong>。</p><blockquote><p>大家从这两段代码（命令式和声明式代码）中就可以发现，声明式代码比命令式代码要简单的多。</p><p>越简单的代码，可维护性就越强</p></blockquote><p>当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 <code>vue</code> 的性能优化之下，它并不会比纯命令式的性能差太多）</p><p>而这样的一种权衡，在 <code>template</code> 模板中，更是体现的淋漓尽致。</p><p>在前端领域，想要使用 <code>JavaScript</code> 修改 <code>html</code> 的方式，主要有三种：<strong><code>原生 JavaScript、innerHTML、虚拟 DOM</code></strong></p><p>很多小伙伴都会认为 <code>虚拟 DOM</code> 的性能是最高的，其实不是。</p><p>我们来看这个对比。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230207233547097.png" alt="image-20230207233547097" style="zoom:50%;"></p><p>从这个对比我们可以发现，<code>虚拟 DOM</code> 的性能，并不是最高的。</p><p>但是它的 <strong>心智负担（书写难度）最小</strong>， 从而带来了 <strong>可维护性最高</strong>。所以哪怕它的性能并不是最高的。<code>vue</code> 依然选择了 <code>虚拟 DOM</code> 来进行了渲染层的构建。</p><p>这个也是一种性能与可维护性的权衡。</p><h4 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h4><p>第一章的最后一部分，主要讲解的就是 <strong>运行时和编译时</strong>。</p><p>这两个名词，各位小伙伴在日常开发中，应该是经常听到的。</p><p>它们两个都是框架设计的一种方式，可单独出现，也可组合使用。</p><p>那么下面咱们就分别来介绍一下它们。</p><p>首先是 <strong>运行时：<code>runtime</code></strong>。</p><blockquote><p>它指的是：<strong>利用 render 函数，直接把 虚拟 <code>DOM</code>  转化为 真实 <code>DOM</code> 元素</strong> 的一种方式。</p><p>在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。</p></blockquote><p>其次是 <strong>编译时：compiler</strong>：</p><blockquote><p>它指的是：<strong>直接把 <code>template</code> 模板中的内容，转化为 真实 <code>DOM</code> 元素</strong>。</p><p>因为存在编译的过程，所以可以分析用户提供的内容。</p><p>同时，没有运行时理论上性能会更好。</p><p>目前该方式，有具体的实现库，那就是现在也非常火的 <code>Svelte</code></p><p>但是这里要注意： <strong>它的真实性能，没有办法达到理论数据。</strong></p></blockquote><p>最后是 <strong>运行时 + 编译时</strong>：</p><blockquote><p>它的过程被分为两步：</p><ol><li>先把 <code>template</code> 模板转化为 <code>render</code> 函数。也就是 <strong>编译时</strong></li><li>再利用 <code>render</code> 函数，把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code>。也就是 <strong>运行时</strong></li></ol><p>两者的结合，可以：</p><p>在 编译时，分析用户提供的内容<br>在 运行时，提供足够的灵活性</p><p>这也是 <code>vue</code> 的主要实现方式。</p></blockquote><h3 id="第二章：框架设计的核心要素"><a href="#第二章：框架设计的核心要素" class="headerlink" title="第二章：框架设计的核心要素"></a>第二章：框架设计的核心要素</h3><p>这一章主要讲解了，框架设计时一些凌乱的注意点。</p><p>比如：</p><ol><li>通过 环境变量 和 <code>TreeShanking</code> 控制打包之后的体积</li><li>构建不同的打包产物，以应用不同的场景</li><li>提供了 <code>callWithErrorHandling</code> 接口函数，来对错误进行统一处理</li><li>源码通过 <code>TypeScript</code> 开发，以保证可维护性。</li><li>内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。</li></ol><p>这些东西都是基于一个个的小点单独去说的，整体之间并没有一个完成的线性逻辑。</p><p>所以大家可以根据具体感兴趣或者不了解的点，单独去看就可以。</p><h3 id="第三章：Vue-js-3-的设计思路"><a href="#第三章：Vue-js-3-的设计思路" class="headerlink" title="第三章：Vue.js 3 的设计思路"></a>第三章：Vue.js 3 的设计思路</h3><p>在这一章中，作者站在一个高层的角度，以 <strong><code>UI</code> 形式、渲染器、组件、编辑器</strong> 为逻辑主线进行的讲解。</p><p>下面咱们就来捋一捋这条线。</p><p>在 <code>Vue</code> 中 <code>UI</code> 形式主要分为两种：</p><ul><li>声明式的模板描述<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170232727.png" alt="image-20230208170232727"></li><li>命令式的 render 函数<br><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208170236795.png" alt="image-20230208170236795"></li></ul><p>而针对于 <strong>声明式的模板描述</strong> 而言，本质上就是咱们常用的 <code>tempalte</code> 模板。它会被 <strong>编辑器</strong> 编译，得到 <strong>渲染函数 <code>render</code></strong> 。</p><p>渲染器与渲染函数，并 <strong>不是</strong> 一个东西。</p><p>渲染器是 <strong>函数 <code>createRenderer</code> 的返回值，是一个对象。被叫做 <code>renderer</code></strong>。 <strong><code>renderer</code> 对象中有一个方法 <code>render</code></strong>，这个 <code>render</code> ，就是我们常说的<strong>渲染函数</strong>。</p><p>渲染函数接收两个参数 <code>VNode</code> 和 <code>container</code>。</p><p>其中 <code>VNode</code> 表示 <strong>虚拟 DOM</strong>，本质上是一个 <code>JS</code> 对象。<code>container</code> 是一个容器，表示被挂载的位置。而 <code>render</code> 函数的作用，就是： <strong>把 <code>vnode</code> 挂载到 <code>container</code> 上</strong>。</p><p>同时，因为 <code>Vue</code> 以组件代表最小颗粒度，所以 <code>vue</code> 内部的渲染，本质上是：<strong>大量的组件渲染</strong>。</p><p>而组件本质上是一组 <code>DOM</code> 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 <code>DOM</code>。也就是说，<code>Vue</code> 本质上是： <strong>以组件作为介质，来完成针对于一组、一组的 <code>DOM</code> 渲染。</strong></p><h3 id="第一篇总结"><a href="#第一篇总结" class="headerlink" title="第一篇总结"></a>第一篇总结</h3><p>在整个第一篇中，作者主要就是通过这三章的内容， <strong>自顶向下</strong> 的为我们介绍了 <code>vue</code> 的框架设计逻辑。其目的主要就是为了让我们了解， <code>Vue</code> 框架的运行逻辑和一些关键概念。</p><h2 id="第二篇：响应式系统"><a href="#第二篇：响应式系统" class="headerlink" title="第二篇：响应式系统"></a>第二篇：响应式系统</h2><p>第二篇主要是针对 <strong>响应式系统</strong> 的讲解。</p><p>同样也是被分为三章：</p><ul><li>首先第一章，也是最重要的一章，就是 <strong>响应系统的作用与实现</strong></li><li>第二章，主要针对 <strong>对象的响应性实现原理</strong> 进行了讲解</li><li>第三章，主要针对 <strong>非对象的响应性实现原理</strong> 进行了讲解</li></ul><h3 id="第四章：响应系统的作用与实现"><a href="#第四章：响应系统的作用与实现" class="headerlink" title="第四章：响应系统的作用与实现"></a>第四章：响应系统的作用与实现</h3><p>在这一章中，作者从 <strong>响应式数据的概念开始，讲解了响应式系统的实现。</strong> 然后针对于 <strong>计算属性与 <code>watch</code>  的实现原理，进行了分析。</strong> 在分析的过程中，也对其所设计到的 <strong><code>调度系统（scheduler）</code> 和  <code>惰性执行（lazy）</code> 的原理进行了明确。</strong> 最后讲解了在 <strong>竞态问题下，关于过期的副作用的处理逻辑。</strong> </p><h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><p>那么首先咱们先来看基本概念 <strong>副作用函数 与 响应式数据</strong>。</p><p>所谓 <strong>副作用函数</strong> 指的是 <strong>会产生副作用的函数</strong>，这样的函数非常的多。比如</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208190429676.png" alt="image-20230208190429676"></p><p>在这段代码中， <code>effect</code> 的触发会导致全局变化 <code>val</code> 发生变化，那么 <code>effect</code> 就可以被叫做<strong>副作用函数</strong>。而如果 <code>val</code> 这个数据的变化，导致了视图的变化，那么 <code>val</code> 就被叫做 <strong>响应式数据</strong>。</p><p>那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为：</p><ul><li>第一个是 <code>getter</code> 行为，也就是 <strong>数据读取</strong></li><li>第二个是 <code>setter</code> 行为，也就是 <strong>数据修改</strong></li></ul><p>在 <code>vue 2</code> 中，这样的两个行为通过 <code>Object.defineProperty</code> 进行的实现。</p><p>在 <code>vue 3</code> 中，这样的两个行为通过 <code>Proxy</code> 进行的实现。</p><p>那么具体的实现逻辑是什么呢？咱们来看下面的图示：</p><blockquote><p>首先是 <code>getter</code> 形式：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191120105.png" alt="image-20230208191120105" style="zoom:20%;"></p><p>在该函数中，存在一个 <code>effect</code> 方法，方法内部触发了 <code>getter</code> 行为。一旦 <code>getter</code> 行为被触发，则把对应的 <code>effect</code> 方法保存到一个 “桶（数据对象）” 中</p><p>当触发 <code>setter</code> 行为时：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208191257788.png" alt="image-20230208191257788" style="zoom:23%;"></p><p>则会从 “桶” 中取出 <code>effect</code> 方法，并执行。</p><p>那么此时因为 <code>obj.text</code> 的值发生了变化，所以 <code>effect</code> 被执行时 <code>document.body.innerText</code> 会被赋上新的值。从而导致视图发生变化。</p></blockquote><p>这是一套构建响应式系统的基础逻辑。这一套逻辑足够应对大家在日常的 <strong>面试</strong> 或者 <strong>工作</strong> 中的基本需求。</p><p>而这套逻辑说起来简单，做起来还是有一些难度的。如果想要构建出一套完善的响应式系统，那么需要做非常多的工作，篇幅也会非常长。这就不是咱们这一个分享会的长度可以解决的了。</p><p>所以后面有时间可以在github源码里面也详细的讲解并且实现了响应性模块。</p><h4 id="调度系统（scheduler）"><a href="#调度系统（scheduler）" class="headerlink" title="调度系统（scheduler）"></a>调度系统（scheduler）</h4><p>那么说完了基本的响应性之后，接下来咱们来看 <strong>调度系统（<code>scheduler</code>）</strong></p><p>所谓调度系统，指的就是 <strong>响应性的可调度性</strong>。</p><p>而所谓的可调度，指的就是 <strong>当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式</strong></p><p>比如，在这段打印中，决定打印的顺序</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208192343242.png" alt="image-20230208192343242" style="zoom:50%;"></p><p>而想要实现一个调度系统，则需要依赖 <strong><code>异步：Promise</code> 和 <code>队列：jobQueue</code></strong> 来进行实现。咱们需要 <strong>基于 <code>Set</code> 构建出一个基本的队列数组 <code>jobQueue</code>，利用 <code>Promise</code> 的异步特性，来控制执行的顺序</strong></p><h4 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h4><p>当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 <strong>计算属性（computed）</strong> 的实现了。</p><p>计算属性本质上是： <strong>一个属性值，当依赖的响应式数据发生变化时，重新计算</strong></p><p>那么它的实现就需要彻底依赖于 <strong>调度系统（scheduler）</strong> 来进行实现。</p><h4 id="惰性执行（lazy）"><a href="#惰性执行（lazy）" class="headerlink" title="惰性执行（lazy）"></a>惰性执行（lazy）</h4><p>说完计算属性，那么下面我们来看下 <code>watch</code> 监听器。</p><p><code>watch</code> 监听器本质上是 <strong>观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数</strong></p><p>这也就意味着，<code>watch</code> 很多时候并不需要立刻执行。</p><p>那么此时，就需要使用到 <strong>惰性执行（<code>lazy</code>）</strong> 来进行控制。</p><p>惰性执行的实现要比调度系统简单。它本质上 <strong>是一个 <code>boolean</code> 型的值，可以被添加到 <code>effect</code> 函数中，用来控制副作用的执行</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!lazy) &#123;</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watch-的实现原理"><a href="#watch-的实现原理" class="headerlink" title="watch 的实现原理"></a>watch 的实现原理</h4><p>基于 调度系统 与 惰性执行，那么就可以实现 <code>watch</code> 监听器了。</p><h4 id="过期的副作用"><a href="#过期的副作用" class="headerlink" title="过期的副作用"></a>过期的副作用</h4><p><code>watch</code> 监听器的实现非常广泛，有时候我们甚至可以在 <strong><code>watch</code> 中完成一些异步操作。</strong></p><p>但是大量的异步操作，极有可能会导致 <strong>竞态问题</strong>。</p><p>所谓的竞态问题，指的是 <strong>在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机</strong>。比如咱们来看这段代码</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230208194352049.png" alt="image-20230208194352049" style="zoom:33%;"></p><blockquote><p>这段代码完成的是一个异步操作。</p><p>如果 <code>obj</code> 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 <code>data</code> 被赋值为 请求B 的结果。</p><p>但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 <code>data</code> 的值就会变为 请求 A 的返回值。</p><p>这个咱们的期望是不一样的。</p><p>那么这样的问题，就是 <strong>竞态问题</strong></p></blockquote><p>而如果想要解决这问题，那么就需要使用到 <code>watch</code> 回调函数的第三个参数 <code>onInvalidate</code>，它本身也是一个回调函数。并且 <strong>该回调函数（<code>onInvalidate</code>）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</strong></p><p>而 <code>onInvalidate</code> 的实现原理也非常简单，只需要 <strong>在副作用函数（effct）重新执行前，先触发 <code>onInvalidate</code></strong> 即可。</p><h4 id="第四章总结"><a href="#第四章总结" class="headerlink" title="第四章总结"></a>第四章总结</h4><p>那么到这里，咱们就把 <strong>响应性系统的大致核心逻辑</strong> 明确完成了。从这个逻辑中，我们知道想要实现响应性数据，那么核心就是通过 <code>Proxy</code> 实现。</p><p>那么这个 <code>proxy</code> 具体怎么做呢？</p><p>接下来，咱们来看第五章。</p><h3 id="第五章：非原始值（对象）的响应性方案"><a href="#第五章：非原始值（对象）的响应性方案" class="headerlink" title="第五章：非原始值（对象）的响应性方案"></a>第五章：非原始值（对象）的响应性方案</h3><p>书中的第五章整体而言非常简单，主要就介绍了两个接口，<code>Proxy</code> 和 <code>Reflect</code>。</p><p>这两个接口通常会一起进行使用，其中：</p><ul><li><code>Proxy</code> 可以 <strong>代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象）</strong></li><li><code>Reflect</code> 可以 <strong>在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用</strong></li></ul><h3 id="第六章：原始值（非对象）的响应性方案"><a href="#第六章：原始值（非对象）的响应性方案" class="headerlink" title="第六章：原始值（非对象）的响应性方案"></a>第六章：原始值（非对象）的响应性方案</h3><p>如果大家熟悉 <code>proxy</code> 的话，那么可以知道，针对于 <code>proxy</code> 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。</p><p>但是，在 <code>vue</code> 中，我们可以通过 <code>ref</code> 构建简单数据类型的响应。</p><p>那么 <code>ref</code> 是如何进行实现的呢？</p><p>这里大家要注意：<strong>针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献</strong></p><p>在最新的 <code>vue 3.2</code> 代码中，<code>vue</code> 通过 <strong><code>get</code> 、<code>set</code>  函数标记符，让函数以属性调用的形式被触发。</strong>这两个修饰符，可以让我们 <strong>像调用属性一样，调用方法</strong>。 所以当我们平时 <strong>访问 ref.value 属性时，本质上是  value() 函数的执行</strong>。</p><h3 id="第二篇总结"><a href="#第二篇总结" class="headerlink" title="第二篇总结"></a>第二篇总结</h3><p>那么到这里咱们整个响应式系统的大概流程，就已经描述完成了。其核心逻辑主要就是在第四章中。</p><p>至于第五章和第六章，更多的偏向于具体的细节和代码逻辑。</p><h2 id="第三篇：渲染器"><a href="#第三篇：渲染器" class="headerlink" title="第三篇：渲染器"></a>第三篇：渲染器</h2><p>那么下面咱们来看 <strong>第三篇：渲染器</strong> 。</p><p>第三篇一共被分为 5 个章节。但是只讲解了三部分内容。</p><ul><li>首先第七章，主要讲解了<strong>渲染器的设计</strong>。</li><li>第八章，主要讲解了 <strong><code>DOM</code> 的挂载和更新的逻辑</strong>。</li><li>而 第九、十、十一 这三章，主要讲解了 <strong>Diff 算法</strong></li></ul><h3 id="第七章：渲染器的设计"><a href="#第七章：渲染器的设计" class="headerlink" title="第七章：渲染器的设计"></a>第七章：渲染器的设计</h3><p>在之前咱们说过 <strong>渲染器与渲染函数不是一个东西</strong></p><ul><li><strong>渲染器</strong> 是 <code>createRenderer</code> 的返回值，是一个对象。</li><li><strong>渲染函数</strong> 是渲染器对象中的 <code>render</code> 方法</li></ul><p>在 <code>vue 3.2.37</code> 的源码内部，<code>createRenderer</code> 函数的具体实现是通过 <code>baseCreateRenderer</code> 进行的。它的代码量非常庞大，涉及到了 <code>2000</code> 多行的代码。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209085155034.png" alt="image-20230209085155034" style="zoom:33%;"></p><p>代码量虽多，但是核心思路并不是特别复杂。总体可以被分为两部分：</p><ol><li><strong>在浏览器端渲染时，利用 <code>DOM API</code> 完成 <code>DOM</code> 操作</strong>：比如，如果渲染 <code>DOM</code> 那么就使用 <code>createElement</code>，如果要删除 <code>DOM</code> 那么就使用 <code>removeChild</code>。</li><li><strong>渲染器不能与宿主环境（浏览器）产生强耦合</strong>：因为 <code>vue</code> 不光有浏览器渲染，还包括了 <code>服务端</code> 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。</li></ol><p>在渲染的过程中，还有一个非常重要的概念 <code>vnode</code>。书中并没有专门的章节来介绍 <code>vnode</code>。所以为了避免各位小伙伴对 <code>vnode</code> 不了解，咱们单独把 <code>vnode</code> 说一下。</p><p>所谓 <code>vnode</code> 本身是 <strong>一个普通的 JavaScript 对象，代表了渲染的内容</strong>。对象中通过 <code>type</code> 表示渲染的 <code>DOM</code>。比如 <code>type === div</code>：则表示 <code>div</code> 标签、<code>type === Framgnet</code> 则表示渲染片段（vue 3 新增）、<code>type === Text</code> 则表示渲染文本节点。</p><h3 id="第八章：挂载与更新"><a href="#第八章：挂载与更新" class="headerlink" title="第八章：挂载与更新"></a>第八章：挂载与更新</h3><p>对于渲染器而言，它做的最核心的事情就是 <strong>对节点进行挂载、更新的操作</strong>。作者在第八章中，详细的介绍了对应的逻辑。</p><p>整个第八章分为两部分来讲解了这个事情：</p><ol><li><code>DOM</code> 节点操作</li><li>属性节点操作</li></ol><h4 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a><code>DOM</code> 节点操作</h4><p>首先先来看 <code>DOM</code> 节点操作。<code>DOM</code> 节点的操作可以分为三部分：</p><ul><li><strong>挂载</strong>：所谓挂载表示节点的初次渲染。比如，可以直接通过 <code>createElement</code> 方法新建一个 <code>DOM</code> 节点，再利用 <code>parentEl.insertBefore</code> 方法插入节点。</li><li><strong>更新</strong>：当响应性数据发生变化时，可能会涉及到 <code>DOM</code> 的更新。此时的更新本质上是属于 <strong>属性的更新</strong>。咱们等到属性节点操作那里再去说。</li><li><strong>卸载</strong>：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 <code>parentEl.removeChild</code> 进行。</li></ul><p>以上三种类型，是 <code>vue</code> 在进行 <code>DOM</code> 操作时的常见逻辑。基本上覆盖了 <code>DOM</code> 操作 <code>90% 以上</code> 的常见场景</p><h4 id="属性节点操作"><a href="#属性节点操作" class="headerlink" title="属性节点操作"></a>属性节点操作</h4><p>看完了 <code>DOM</code> 操作之后，接下来咱们来看属性节点操作。</p><p>针对于属性而言，大体可以分为两类：</p><ol><li><strong>属性</strong>：比如 <code>class</code>、<code>id</code>、<code>value</code>、<code>src</code>…</li><li><strong>事件</strong>：比如 <code>click</code>、<code>input</code>….</li></ol><p>那么咱们就先来看 <strong>非事件的属性部分</strong>。</p><p>想要了解 <code>vue</code> 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 <strong>浏览器中的属性分类</strong>。</p><p>在浏览器中 <code>DOM</code> 属性其实被分为了两类：</p><ul><li>第一类叫做 <code>HTML Attributes</code>：直接定义在 <code>HTML 标签</code> 上的属性，都属于这一类。</li><li><p>第二类叫做 <code>DOM Properties</code>：它是拿到 <code>DOM</code> 对象后定义的属性。咱们接下来主要要说的就是它。</p><p><code>HTML Attributes</code> 的定义相对而言比较简单和直观，但是问题在于 <strong>它只能在 <code>html</code> 中进行操作</strong>。</p></li></ul><p>而如果想要在 <code>JS</code> 中操作 <code>DOM</code> 属性，就必须要通过  <code>DOM Properties</code> 来进行实现。但是因为 <code>JS</code> 本身特性的问题，会导致某些 <code>DOM Properties</code> 的设置存在特殊性。比如 <code>class、type、value</code> 这三个。</p><p>所以为了保证 <code>DOM Properties</code> 的成功设置，那么我们就必须要知道 <strong>不同属性的 <code>DOM Properties</code> 定义方式 </strong>。</p><p>下面咱们来看一下。</p><p><code>DOM Properties</code> 的设置一共被分为两种：</p><ol><li><code>el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;)</code></li><li><code>. 属性赋值</code> ： <code>el.属性名 = 属性值</code> 或者 <code>el[属性名] = 属性值</code> 都属于 <code>.属性赋值</code>  </li></ol><p>我们来看这段代码：</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209093545078.png" alt="image-20230209093545078" style="zoom:50%;"></p><blockquote><p>在这段代码中，我们为 <code>textarea</code> 利用 <code>DOM Properties</code> 的方式设置了三个不同的属性：</p><ul><li>首先是 <code>class</code>： <code>class</code> 在属性操作中是一个非常特殊的存在。它有两个名字 <code>class</code> 和 <code>className</code>。如果我们直接通过 <code>el.setAttribute</code> 的话，那么必须要用 <code>class</code> 才可以成功，而如果是通过 <code>. 属性</code> 的形式，那么必须要使用 <code>className</code> 才可以成功。</li><li>第二个是 <code>type</code>： <code>type</code> 仅支持 <code>el.setAttribute</code>  的方式，不支持 <code>.属性的方式</code></li><li>第三个是 <code>value</code>：<code>value</code> 不支持直接使用 <code>el.setAttribute</code>  设置，但是支持 <code>.属性</code> 的设置方式</li></ul></blockquote><p>除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>接下来，咱们来看 <code>vue</code> 对事件的处理操作。</p><p>事件的处理和属性、<code>DOM</code> 一样，也是分为 <strong>添加、删除、更新</strong> 三类。</p><ul><li>添加：添加比较简单，主要利用 <code>el.addEventListener</code> 进行实现即可。</li><li>删除：主要利用 <code>el.removeEventListener</code> 进行处理。</li><li>更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。</li></ul><p>通常情况下，我们所认知的事件更新应该是 <strong>删除旧事件、添加新事件</strong> 的过程。但是如果利用 <code>el.addEventListener</code> 和 <code>el.removeEventListener</code> 来完成这件事情，是一件非常消耗性能的事。</p><p>那么怎么能够节省性能，同时完成事件的更新呢？</p><p>这时，<code>vue</code> 对事件的更新提出了一个叫做 <code>vei</code> 的概念，这个概念的意思是： <strong>为 <code>addEventListener</code> 回调函数，设置了一个 <code>value</code> 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。</strong></p><p>这个代码比较多，大家如果想要查看具体代码的话，可以 <a href="https://github.com/lgd8981289/vue-next-mini" target="_blank" rel="noopener">在 github 搜索 vue-next-mini</a>，进入到 <code>packages/runtime-dom/src/modules/events.ts</code> 路径下查看。</p><h3 id="第九、十、十一章：Diff-算法"><a href="#第九、十、十一章：Diff-算法" class="headerlink" title="第九、十、十一章：Diff 算法"></a>第九、十、十一章：Diff 算法</h3><p>整个渲染器最后的三个章节全部都用来讲解了 <code>diff</code> 算法。</p><p>针对于 <code>diff</code> 而言，它的本质其实就是一个对比的方法，其描述的核心就是： <strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p><p>目前针对于 <code>vue 3.2.37</code> 的版本来说，整个的 <code>diff</code> 算法被分为 5 步（<strong>这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助</strong>）：</p><ol><li><code>sync from start</code>：自前向后的对比</li><li><code>sync from end</code>：自后向前的对比</li><li><code>common sequence + mount</code>：新节点多于旧节点，需要挂载</li><li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li><li><code>unknown sequence</code>：乱序</li></ol><p>而，针对于书中的这三章来说，本质上是按照 <strong>简单 diff 算法、双端 diff 算法、快速 diff 算法</strong> 的顺序把整个 <code>diff</code> 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。</p><p>所以说咱们在当前的这个分享中，肯定是没有办法为大家讲解具体算法逻辑的。</p><p>针对于这一块，我同样也是准备了另外的博客。</p><h3 id="第三篇总结"><a href="#第三篇总结" class="headerlink" title="第三篇总结"></a>第三篇总结</h3><p>针对于第三篇渲染器来说，咱们所描述的重点主要是围绕  <strong>渲染器的设计</strong> 和  <strong><code>DOM</code> 的挂载和更新的逻辑</strong> 来去说的。</p><p>针对于这两部分而言，大家要明确 <strong>渲染器与渲染函数的区别</strong>，同时要知道 <code>HTML Attributes</code> 和 <code>DOM Properties</code> 在行为上的差异性。另外关于事件更新的 <code>vei</code> 概念，应该也可以给大家带来一些新的思路。</p><p>而针对于 <code>diff</code>，咱们没有放在当前分享中去说，主要还是因为时长不够的原因。但是我为大家准备了额外的博客和视频，大家可以根据自己需要去进行查看。</p><h2 id="第四篇：组件化"><a href="#第四篇：组件化" class="headerlink" title="第四篇：组件化"></a>第四篇：组件化</h2><p>第四篇组件化，它应该算是比较简单的一个篇章，也是分为三部分来去讲解：</p><ol><li>组件的实现原理：这是咱们讲解的重心，但是不用担心，它并不复杂。</li><li>异步组件与函数式组件：这个比较冷僻，在实际开发中的使用场景有限</li><li>内建组件和模块：里面主要讲解了 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 这三个内置组件的实现逻辑</li></ol><h3 id="第十二章：组件的实现原理"><a href="#第十二章：组件的实现原理" class="headerlink" title="第十二章：组件的实现原理"></a>第十二章：组件的实现原理</h3><p>想要了解 <code>vue</code> 中组件的实现，那么首先我们需要知道什么是组件。</p><p>组件本质上就是一个 <code>JavaScript</code> 对象，比如，以下对象就是一个基本的组件</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209105953064.png" alt="image-20230209105953064" style="zoom:33%;"></p><p>而对于组件而言，同样需要使用 <code>vnode</code> 来进行表示，当 <code>vnode</code> 的 <code>type</code> 属性是一个 <strong>自定义对象</strong> 时，那么这个 <code>vnode</code> 就表示组件的 <code>vnode</code></p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110548502.png" alt="image-20230209110548502" style="zoom:33%;"></p><p>而组件的渲染，本质上是 <strong>组件包含的 <code>DOM</code> 的渲染。</strong> 对于组件而言，必然会包含一个 <code>render</code> 渲染函数。如果没有 <code>render</code> 函数，那么 <code>vue</code> 会把 <code>template</code> 模板编译为 <code>render</code> 函数。而组件渲染的内容，其实就是 <code>render</code> 函数返回的 <code>vnode</code>。具体的渲染逻辑，全部都通过渲染器执行。</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209110919710.png" alt="image-20230209110919710" style="zoom:33%;"></p><p><code>vue 3</code> 之后提出了 <code>composition API</code>，<code>composition API</code> 包含一个入口函数，也就是 <code>setup</code> 函数。 <code>setup</code> 函数包含两种类型的返回值：</p><ol><li><strong>返回一个函数</strong>：当 <code>setup</code> 返回一个函数时，那么该函数会被作为 <code>render</code> 函数直接渲染。</li><li><strong>返回一个对象</strong>：当 <code>setup</code> 返回一个对象时，那么 <code>vue</code> 会直接把该对象的属性，作为 <code>render</code> 渲染时的依赖数据</li></ol><p>同时，对于组件来说还有一个 <strong>插槽</strong> 的概念。插槽的实现并不神奇。插槽本质上 <strong>是一段 <code>innerHTML</code> 的内容，在 <code>vnode</code> 中以 <code>children</code> 属性进行呈现</strong>。当插槽被渲染时，只需要渲染 <code>children</code> 即可。</p><p>对于组件来说，除了咱们常用的 <strong>对象组件</strong> 之外，<code>vue</code> 还提供了额外的两种组件，也就是 <strong>异步组件与函数式组件</strong>。</p><h3 id="第十三章：异步组件与函数式组件"><a href="#第十三章：异步组件与函数式组件" class="headerlink" title="第十三章：异步组件与函数式组件"></a>第十三章：异步组件与函数式组件</h3><p>所谓异步组件，指的是： <strong>异步加载的组件</strong> 。</p><p>比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。</p><p>异步组件在 <strong>优化页面性能、拆包、服务端下发组件</strong> 时，会比较有用。</p><p>而对于 <strong>函数式组件</strong> 来说，相对就比较冷僻了。函数式组件指的是 <strong>没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 <code>props</code> 属性</strong> 。在实际开发中，并不常见。</p><h3 id="第十四章：内建组件和模块"><a href="#第十四章：内建组件和模块" class="headerlink" title="第十四章：内建组件和模块"></a>第十四章：内建组件和模块</h3><p>这一章中，主要描述了 <code>vue</code> 的三个内置组件。</p><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>首先第一个是 <code>KeepAlive</code>。</p><p>这是我们在日常开发中，非常常用的内置组件。它可以 <strong>缓存一个组件，避免该组件不断地销毁和创建</strong>。</p><p>看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 <strong>组件卸载</strong> 和 <strong>组件挂载</strong> 两个方面：</p><ul><li><strong>组件卸载</strong>：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中</li><li><strong>组件挂载</strong>：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。</li></ul><h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code> 是 <code>vue 3</code> 新增的组件，作用是 <strong>将 <code>Teleport</code> 插槽的内容渲染到其他的位置</strong>。比如我们可以把 <code>dialog</code> 渲染到 <code>body</code> 根标签之下。</p><p>它的实现原理，主要也是分为两部分：</p><ol><li>把 Teleport 组件的渲染逻辑，从渲染器中抽离</li><li>在指定的位置进行独立渲染</li></ol><h4 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h4><p><code>Transition</code> 是咱们常用的动画组件，作用是 <strong>实现动画逻辑</strong>。</p><p>其核心原理同样被总结为两点：</p><ol><li><code>DOM</code> 元素被挂载时，将动效附加到该 <code>DOM</code> 元素上</li><li><code>DOM</code> 元素被卸载时，等在 <code>DOM</code> 元素动效执行完成后，执行卸载 <code>DOM</code> 操作</li></ol><h3 id="第四篇总结"><a href="#第四篇总结" class="headerlink" title="第四篇总结"></a>第四篇总结</h3><p>整个第四篇，主要围绕着组件来去讲。所以内容并不复杂。</p><p>对于咱们的日常的开发与面试而言，其实只需要搞清楚 <strong>组件的原理</strong> 与 <strong>内建组件原理</strong> 即可。</p><h2 id="第五篇：编译器"><a href="#第五篇：编译器" class="headerlink" title="第五篇：编译器"></a>第五篇：编译器</h2><p>编译器是一个非常复杂的环节。作者主要通过 <strong>编辑器核心逻辑、解析器、编译优化</strong> 这三个方向进行了说明。</p><p>其中对于我们日常开发与面试来说，最核心的就是 <strong>第十五章：编译器核心技术概述</strong> 。这也是咱们在这一篇中的主要章节。</p><h3 id="第十五章：编译器核心技术概述"><a href="#第十五章：编译器核心技术概述" class="headerlink" title="第十五章：编译器核心技术概述"></a>第十五章：编译器核心技术概述</h3><p>在编译器核心技术概述，主要包含两个核心内容：</p><ol><li>模板 <code>DSL</code> 的编译器</li><li><code>Vue</code> 编译流程三大步</li></ol><h4 id="模板-DSL-的编译器"><a href="#模板-DSL-的编译器" class="headerlink" title="模板 DSL 的编译器"></a>模板 <code>DSL</code> 的编译器</h4><p>在任何一个编程语言中，都存在编译器的概念。 <code>vue</code> 的编译器是在 <strong>一种领域下，特定语言的编译器</strong> ，那么这种编译器被叫做 <code>DSL</code> 编译器。</p><p>而编译器的本质是 <strong>通过一段程序，可以把 A 语言翻译成 B 语言</strong>。在 <code>vue</code> 中的体现就是 <strong>把 <code>tempalte</code> 模板，编译成 <code>render</code> 渲染函数</strong></p><p>一个完整的编译器，一个分为 <strong>两个阶段、六个流程</strong>：</p><ul><li>编译前端：<ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>编译后端：<ul><li>中间代码生成</li><li>优化</li><li>目标代码生成</li></ul></li></ul><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113241592.png" alt="image-20230209113241592"></p><p>而对于 <code>vue</code> 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209113421705.png" alt="image-20230209113421705"></p><ol><li><code>parse</code>：通过 <code>parse</code> 函数，把模板编译成 <code>AST</code> 对象</li><li><code>transform</code>：通过 <code>transform</code> 函数，把 <code>AST</code> 转化为 <code>JavaScript AST</code></li><li><code>generate</code>：通过 <code>generate</code> 函数，把 <code>JavaScript AST</code> 转化为 渲染函数（<code>render</code>）</li></ol><p>这三大步中，每一步都包含非常复杂的逻辑实现。</p><p>和之前一样，因为篇幅的问题，我们没有办法这里去详细讲解三大步的流程。</p><p>我依然为大家提供了 <a href="https://juejin.cn/post/7197977396603256890/42118200" target="_blank" rel="noopener">博客版</a></p><h4 id="第十六章：解析器（parse）"><a href="#第十六章：解析器（parse）" class="headerlink" title="第十六章：解析器（parse）"></a>第十六章：解析器（parse）</h4><p>这一章，主要详细讲解了 <strong>parse 解析逻辑</strong>。是在三大步中的 <code>parse</code> 逻辑的基础上，进行了一个加强。</p><p>所以这里咱们也按下不表</p><h4 id="第十七章：编译优化"><a href="#第十七章：编译优化" class="headerlink" title="第十七章：编译优化"></a>第十七章：编译优化</h4><p>最后就是编译优化。</p><p>编译优化也是一个非常大的概念，其核心就是 <strong>通过编译的手段提取关键信息，并以此知道生成最优代码的过程</strong>。</p><p>它的核心优化逻辑，主要是 <strong>把节点分为两类</strong>：</p><ul><li>第一类是 <strong>动态节点</strong>：也就是会 <strong>受数据变化影响</strong> 的节点</li><li>第二类是 <strong>静态节点</strong>：也就是 <strong>不受数据变化影响</strong> 的节点</li></ul><p>优化主要的点，就是 <strong>动态节点</strong>。</p><p>优化的方式主要是通过 <code>Block 树</code> 进行优化。</p><p><code>Block 树</code> 本质上就是一个 <strong>虚拟节点数对象</strong>，内部包含一个 <code>dynamicChildren</code> 属性，用来 <strong>收集所有的动态子节点</strong>，以达到提取关键点进行优化的目的。</p><p>除此之外，还有一些小的优化手段，比如：</p><ul><li>静态提升</li><li>预字符串化</li><li>缓存内联事件处理函数</li><li><code>v-once</code> 指令</li><li>…</li></ul><h3 id="第五篇总结"><a href="#第五篇总结" class="headerlink" title="第五篇总结"></a>第五篇总结</h3><p>其实第五篇编译器应该是整本书中，逻辑最复杂的一篇了。内部包含了特别多的代码实现。</p><p>但是因为篇幅问题，所以我们没有办法给大家进行详细介绍。只能是把大致的核心流程为大家进行明确。希望大家见谅。</p><h2 id="第六篇：服务端渲染"><a href="#第六篇：服务端渲染" class="headerlink" title="第六篇：服务端渲染"></a>第六篇：服务端渲染</h2><p>最后一篇只有一个章节，就是 <strong>同构渲染</strong>。</p><p>想要了解同构渲染，那么需要先搞明白 <code>CSR、SSR</code> 的概念。</p><ul><li><code>CSR</code>：所谓 <code>CSR</code> 指的是 <strong>客户端渲染</strong>。<ul><li>浏览器向服务器发起请求</li><li>服务器查询数据库，返回数据</li><li>浏览器得到数据，进行页面构建</li></ul></li><li><code>SSR</code>：表示 <strong>服务端渲染</strong><ul><li>览器向服务器发起请求</li><li>服务器查询数据库，根据数据，生成 <code>HTML</code> ，并进行返回</li><li>浏览器直接渲染 <code>HTML</code></li></ul></li></ul><p>两种方式各有利弊，所以同构渲染，指的就是 <strong>把 <code>CSR</code> 和 <code>SSR</code> 进行合并</strong>。既可以单独 <code>CSR</code> ，也可以单独 <code>SSR</code>，同时还可以 <strong>结合两者，在首次渲染时，通过 <code>SSR</code>，在非首次渲染时，通过 <code>CSR</code></strong>。</p><p>以下是三者的对比图</p><p><img src="/2024/06/21/《Vue-js-设计与实现》速读/image-20230209121227934.png" alt="image-20230209121227934" style="zoom:50%;"></p><p>而针对 <code>vue</code> 的服务端渲染来说，它是 <strong>将虚拟 <code>DOM</code>  渲染为 <code>HTML</code> 字符串</strong>，本质上是 <strong>解析的 <code>vnode</code> 对象，然后进行的 <code>html</code> 的字符串拼接</strong></p><p>最后又讲解了客户端激活的原理，大致分为两步：</p><ol><li>为页面中的 <code>DOM</code> 元素与虚拟节点对象之间建立联系</li><li>为页面中的 <code>DOM</code> 元素添加事件绑定</li></ol><p>这两步主要是通过 <code>renderer.hydrate()</code> 方法进行实现了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 那么到这里，整个 《Vue.js 设计与实现》就已经全部说完了。</p><p>整本书中，涉及到的内容是非常全面的，就像咱们开头所说的一样，它是一个 <strong>从高层的设计角度，来探讨框架需要关注的问题。</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Vue.js 设计与实现》概要总结&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>日语-N2文法</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-N2%E6%96%87%E6%B3%95/"/>
    <id>/2024/06/11/日语-N2文法/</id>
    <published>2024-06-11T03:11:15.000Z</published>
    <updated>2024-06-11T05:22:08.066Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之N2文法<br><a id="more"></a></p><h1 id="単元"><a href="#単元" class="headerlink" title="単元"></a>単元</h1><h2 id="第１７課"><a href="#第１７課" class="headerlink" title="第１７課"></a>第１７課</h2><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><h4 id="～ぬきで／～ぬきにして-本意是去除的意思，引申义是不是，不必，不需要，不的意思"><a href="#～ぬきで／～ぬきにして-本意是去除的意思，引申义是不是，不必，不需要，不的意思" class="headerlink" title="～ぬきで／～ぬきにして　本意是去除的意思，引申义是不是，不必，不需要，不的意思"></a>～ぬきで／～ぬきにして　本意是去除的意思，引申义是不是，不必，不需要，不的意思</h4><ul><li>堅苦しいあいさつはぬきにして思い切り飲みましょう。</li><li>これはお世辞抜きで面白いですよ。</li></ul><h4 id="～（よう）とする／としている-打算做-正要做，马上快要"><a href="#～（よう）とする／としている-打算做-正要做，马上快要" class="headerlink" title="～（よう）とする／としている　打算做/正要做，马上快要"></a>～（よう）とする／としている　打算做/正要做，马上快要</h4><ul><li>犯人は警察に捕まりそうになって，銃で自殺しょうとした。</li><li>复习：すると　一……就……，紧接着前项事情发生后项事情</li></ul><h4 id="据说的几种表达方式"><a href="#据说的几种表达方式" class="headerlink" title="据说的几种表达方式"></a>据说的几种表达方式</h4><ul><li>～といわれています（第3课）通常认为</li><li>～そうです （第4课）</li><li>～とのことです （第5课）</li><li>～ということです （第5课）</li><li>～とまで（さえ）いわれている （第17课）夸张的据说，极端情况下使用</li><li>蘇州は美しい街だ，東洋のベニスとさえいわれている。</li></ul><h2 id="第１8課"><a href="#第１8課" class="headerlink" title="第１8課"></a>第１8課</h2><h3 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h3><h4 id="在……的时候，期间"><a href="#在……的时候，期间" class="headerlink" title="在……的时候，期间"></a>在……的时候，期间</h4><ul><li>時　表示时间<ul><li>小さい時</li></ul></li><li>間　表示时间和空间<ul><li>皆が寝ている間に，～</li><li>東京と大阪の間に，～</li></ul></li><li>ところ　表示状态<ul><li>忙しいところですが，～</li></ul></li><li>うち　在……当中，在……期间，趁着（年轻等）<ul><li>～うちに　等同于～間に，表示在这个期间一定发生了动作<ul><li>母が外出しているうちに（間に），掃除をして部屋をピカピカにしよう。</li></ul></li><li>～うちは　表示在这个期间没有变化<ul><li>体が健康なうちは，妻と二人でのんびり暮らしたい。</li></ul></li></ul></li><li>折，節，際　和時一样，属于美化语</li></ul><h4 id="假定形＋幸いです／恐縮です-对方这么做我会很高兴-我这么做的化给对方添麻烦"><a href="#假定形＋幸いです／恐縮です-对方这么做我会很高兴-我这么做的化给对方添麻烦" class="headerlink" title="假定形＋幸いです／恐縮です　对方这么做我会很高兴/我这么做的化给对方添麻烦"></a>假定形＋幸いです／恐縮です　对方这么做我会很高兴/我这么做的化给对方添麻烦</h4><ul><li>後日こちらからお電話いたしますので，その折にご都合をお聞かせいただければ幸いです。</li><li>お忙しい中恐縮ですが，ご連絡いただければ幸いです。</li></ul><h4 id="AをBにした／とした-以A作为B的一部分-全部"><a href="#AをBにした／とした-以A作为B的一部分-全部" class="headerlink" title="AをBにした／とした　以A作为B的一部分/全部"></a>AをBにした／とした　以A作为B的一部分/全部</h4><ul><li>弊社では，「金星」をベースにした新感覚のカクテルもごよういしています。</li><li>この服は「エコロジー」をコンセプトとした素材でできています。</li></ul><h4 id="なお／また／さらに-另外，还有"><a href="#なお／また／さらに-另外，还有" class="headerlink" title="なお／また／さらに　另外，还有"></a>なお／また／さらに　另外，还有</h4><h2 id="第１９課"><a href="#第１９課" class="headerlink" title="第１９課"></a>第１９課</h2><h3 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋次第＋～-一……就……"><a href="#ます形＋次第＋～-一……就……" class="headerlink" title="ます形＋次第＋～　一……就……"></a>ます形＋次第＋～　一……就……</h4><ul><li>わかり次第ご連絡を差し上げます。</li><li>準備ができ次第，ご案内いたします。</li><li>复习：～たら，すぐに，～と</li></ul><h4 id="ます形＋つつある-表示动作正在逐渐变化或朝着一个方向发展"><a href="#ます形＋つつある-表示动作正在逐渐变化或朝着一个方向发展" class="headerlink" title="ます形＋つつある　表示动作正在逐渐变化或朝着一个方向发展"></a>ます形＋つつある　表示动作正在逐渐变化或朝着一个方向发展</h4><ul><li>中国国内の物価が上がりつつある。</li><li>复习：一方，ばかりだ，の一途をたどる，いく</li></ul><h4 id="～と評判だ-得到很高的评价"><a href="#～と評判だ-得到很高的评价" class="headerlink" title="～と評判だ　得到很高的评价"></a>～と評判だ　得到很高的评价</h4><ul><li>都内の浄水場で処理した水をボトルに詰めて販売していて，味も美味しいと評判だ。</li></ul><h4 id="～に伴って～-随着-，表示伴随着某个重大事件连带发生了另外的事件"><a href="#～に伴って～-随着-，表示伴随着某个重大事件连带发生了另外的事件" class="headerlink" title="～に伴って～　随着~，表示伴随着某个重大事件连带发生了另外的事件"></a>～に伴って～　随着~，表示伴随着某个重大事件连带发生了另外的事件</h4><ul><li>冷戦の終結に伴って，経済関係の重要性が強調されるようになってきた。</li><li>都市の緑化に伴って，駅周辺に花や木が増えってきた。</li><li>复习：～とともに</li></ul><h4 id="～のもと（で）-表示在……之下，之中。本意是表示位置靠下的部位"><a href="#～のもと（で）-表示在……之下，之中。本意是表示位置靠下的部位" class="headerlink" title="～のもと（で）　表示在……之下，之中。本意是表示位置靠下的部位"></a>～のもと（で）　表示在……之下，之中。本意是表示位置靠下的部位</h4><ul><li>国連の旗のもと，各国が協力して紛争の平和的な解決を目指している。</li><li>マイナス３０度吹雪という悪天候のものでも，観測作業は継続された。</li></ul><h4 id="一方-一边，一边，表示并列同时经行"><a href="#一方-一边，一边，表示并列同时经行" class="headerlink" title="一方　一边，一边，表示并列同时经行"></a>一方　一边，一边，表示并列同时经行</h4><ul><li>彼は大学で哲学を教える一方，大工として働いている。</li><li>复习：一方也有朝着趋势一直发展的意思</li></ul><h2 id="第２０課"><a href="#第２０課" class="headerlink" title="第２０課"></a>第２０課</h2><h3 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h3><h4 id="～だらけ-满是，沾满了，很多"><a href="#～だらけ-满是，沾满了，很多" class="headerlink" title="～だらけ　满是，沾满了，很多"></a>～だらけ　满是，沾满了，很多</h4><ul><li>ここのところ，失敗だらけなんです。</li><li>間違いだらけの答案を採点する。</li></ul><h4 id="と思ったら，～-刚一……就……，动作刚一发生，就发生了意外的事情"><a href="#と思ったら，～-刚一……就……，动作刚一发生，就发生了意外的事情" class="headerlink" title="~と思ったら，～　刚一……就……，动作刚一发生，就发生了意外的事情"></a>~と思ったら，～　刚一……就……，动作刚一发生，就发生了意外的事情</h4><ul><li>電車は発車したと思ったら大きな音を出して急停車した。</li><li>その学生は，就職したと思ったらさっさと辞めてしまった。</li></ul><h4 id="～というより-～というよりむしろ-比起这样说……还不如……-与其说是……不如说……"><a href="#～というより-～というよりむしろ-比起这样说……还不如……-与其说是……不如说……" class="headerlink" title="～というより/～というよりむしろ　比起这样说……还不如……/与其说是……不如说……"></a>～というより/～というよりむしろ　比起这样说……还不如……/与其说是……不如说……</h4><ul><li>正直に言えば，喜んで引き受けたというより思わず頷いたという形だった。</li><li>この料理は，中華料理というよりむしろ日本料理というほうが適切だ。</li></ul><h4 id="ばかり"><a href="#ばかり" class="headerlink" title="ばかり"></a>ばかり</h4><ul><li>～たばかりです　主观上觉得事情刚刚完成<ul><li>彼は3月に大学を卒業したばかりです。</li></ul></li><li>～ばかり～　全是，尽是，光是<ul><li>最近，変な夢ばかり見る。</li></ul></li><li>～てはばかりいる　消极的事情反复发生<ul><li>彼はよく遅れてばかりいる。</li></ul></li><li>～ばかりではなく　不仅……而且……<ul><li>その地方は寒いばかりではなく，乾燥しているため，農業には向いていない。</li></ul></li><li>～ばかりだ　朝着一个不好的方向不断发展<ul><li>病気はどんどん悪くなるばかりだ。</li></ul></li></ul><h4 id="～ほど-表示程度很高"><a href="#～ほど-表示程度很高" class="headerlink" title="～ほど　表示程度很高"></a>～ほど　表示程度很高</h4><ul><li>李さんは日本人と間違わるほど，日本語が上手だ。</li><li>その日は，部屋のコップの水さえ凍るほどの寒さだった。</li></ul><h4 id="Aを境にB-以A作为分水岭有了B这样的变化"><a href="#Aを境にB-以A作为分水岭有了B这样的变化" class="headerlink" title="Aを境にB　以A作为分水岭有了B这样的变化"></a>Aを境にB　以A作为分水岭有了B这样的变化</h4><ul><li>1970年代を境に，日本は高齢化社会になったといわれる。</li></ul><h1 id="単元-1"><a href="#単元-1" class="headerlink" title="単元"></a>単元</h1><h2 id="第２１課"><a href="#第２１課" class="headerlink" title="第２１課"></a>第２１課</h2><h3 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h3><h4 id="～分-与之相对应的，与另一部分做对比"><a href="#～分-与之相对应的，与另一部分做对比" class="headerlink" title="～分　与之相对应的，与另一部分做对比"></a>～分　与之相对应的，与另一部分做对比</h4><ul><li>急いだ分，仕上がりはよくない。</li><li>食べたら食べた分，運動をしないと，太ってしまいます。</li></ul><h4 id="～ずつ-在进行反复进行的动作时，每次动作实现需要的数量或分量"><a href="#～ずつ-在进行反复进行的动作时，每次动作实现需要的数量或分量" class="headerlink" title="～ずつ　在进行反复进行的动作时，每次动作实现需要的数量或分量"></a>～ずつ　在进行反复进行的动作时，每次动作实现需要的数量或分量</h4><ul><li>3人ずつ部屋に入ってください。</li><li>機械が壊れないように，電流を少しずつ流します。</li></ul><h4 id="わけ"><a href="#わけ" class="headerlink" title="わけ"></a>わけ</h4><ul><li>～わけだ　自然而然的<ul><li>田中さんは大学を卒業して3年だから，今年25歳になるというわけだ。</li></ul></li><li>～わけがない　没有道理<ul><li>食べる後にお金を上げないわけがない。</li></ul></li><li>～わけではない　并不是，不应该，不能<ul><li>皆がルールを守らないから，自分も守らなくていいというわけではない。</li></ul></li><li>～わけにはいかない　不能（没有道理的）<ul><li>ここであきらめいるわけにはいきません。</li></ul></li></ul><h4 id="必ずしも～ない-未必，表示部分否定，不强烈的否定"><a href="#必ずしも～ない-未必，表示部分否定，不强烈的否定" class="headerlink" title="必ずしも～ない　未必，表示部分否定，不强烈的否定"></a>必ずしも～ない　未必，表示部分否定，不强烈的否定</h4><ul><li>学校で学んだことが必ずしも生活に役に立つわけではない。</li><li>王さんの言うことが必ずしも正しいとは限らない。</li></ul><h4 id="～を始め-以……代表（为首）"><a href="#～を始め-以……代表（为首）" class="headerlink" title="～を始め　以……代表（为首）"></a>～を始め　以……代表（为首）</h4><ul><li>中国，日本，韓国を始めとするアジアの国々にとって経済的な協力関係は重要だ。</li></ul><h4 id="～に至るまで-意思和まで一样，多用于列举极端的事物"><a href="#～に至るまで-意思和まで一样，多用于列举极端的事物" class="headerlink" title="～に至るまで　意思和まで一样，多用于列举极端的事物"></a>～に至るまで　意思和まで一样，多用于列举极端的事物</h4><ul><li>この店には，日常使うもの，歯ブラシやせっけんはもちろん，整髪料に至るまでそろっている。</li></ul><h4 id="～といっても過言ではない-即使这么说也不过分"><a href="#～といっても過言ではない-即使这么说也不过分" class="headerlink" title="～といっても過言ではない　即使这么说也不过分"></a>～といっても過言ではない　即使这么说也不过分</h4><ul><li>私は本が好きだ。本を読まない日はないといっても過言ではない。</li><li>現在，中国の経済が世界経済の動向を決めるといっても言い過ぎではない。</li></ul><h2 id="第２２課"><a href="#第２２課" class="headerlink" title="第２２課"></a>第２２課</h2><h3 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋ながら／つつ"><a href="#ます形＋ながら／つつ" class="headerlink" title="ます形＋ながら／つつ"></a>ます形＋ながら／つつ</h4><ul><li>同时进行的动作，强调后面的动作<ul><li>彼は食べながらテレビを見る。</li><li>私は，今，お茶を飲みつつ手紙を書いています。</li></ul></li><li>虽然……但是……，表示转折<ul><li>彼は大学生でありながら，喫茶店を経営している。</li><li>何かしなければならないと思いつつ，時間が過ぎてしまった。</li></ul></li></ul><h4 id="まま-照旧，一如原样"><a href="#まま-照旧，一如原样" class="headerlink" title="まま　照旧，一如原样"></a>まま　照旧，一如原样</h4><ul><li>～たまま／～のまま　理应改变却没有改变</li><li>～ままに　表示顺从该动作或意志和～どおり有一样的意思<ul><li>お客様のご希望のままに，シェフが調理します。</li><li>あなたが望むままに生きていきなさい。</li></ul></li></ul><h4 id="～なしで／～抜きで-在不具备本来该有的某种东西的状态下做某事"><a href="#～なしで／～抜きで-在不具备本来该有的某种东西的状态下做某事" class="headerlink" title="～なしで／～抜きで　在不具备本来该有的某种东西的状态下做某事"></a>～なしで／～抜きで　在不具备本来该有的某种东西的状态下做某事</h4><ul><li>準備なしで発表をしたら，失敗した。</li><li>相談抜きで面白い。</li></ul><h4 id="～に加え（て）-不仅……而且……"><a href="#～に加え（て）-不仅……而且……" class="headerlink" title="～に加え（て）　不仅……而且……"></a>～に加え（て）　不仅……而且……</h4><ul><li>前回の勝利に加えて，今回も大差で勝った。</li></ul><h4 id="～たびに-每当……就会……"><a href="#～たびに-每当……就会……" class="headerlink" title="～たびに　每当……就会……"></a>～たびに　每当……就会……</h4><ul><li>海絵来るたびに，子供のころ溺れたことを思い出す。</li><li>卒業式のたびに校長先生は泣きながらあいさつをします。</li><li>拓展：～といつも／～時はいつも／～ごとに　意思和～たびに一样</li></ul><h4 id="次第"><a href="#次第" class="headerlink" title="次第"></a>次第</h4><ul><li>一……就……</li><li>～次第で　随着……，取决于……</li><li>この裁判では，あなたの証言次第で，被告は有罪になります。</li><li>今回の旅行でどこへ行くかは，予算次第です。</li></ul><h2 id="第２３課"><a href="#第２３課" class="headerlink" title="第２３課"></a>第２３課</h2><h3 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h3><h4 id="～だからこそ-正因为，こそ在这里起到了强调的作用"><a href="#～だからこそ-正因为，こそ在这里起到了强调的作用" class="headerlink" title="～だからこそ　正因为，こそ在这里起到了强调的作用"></a>～だからこそ　正因为，こそ在这里起到了强调的作用</h4><ul><li>偶然ではなく，~努力したからこそ教員試験に合格したんだ。</li></ul><h4 id="从……到……"><a href="#从……到……" class="headerlink" title="从……到……"></a>从……到……</h4><ul><li>～から～まで　具有连续性的准确范围<ul><li>3時から3時15分まで休憩します。</li></ul></li><li>～から～にかけて　断断续续，大致范围<ul><li>城を持たない水上都市として，明から清にかけて大きく発展した。</li></ul></li><li>～にわたって　时间长，跨度大，范围大<ul><li>10年にわたって研究開発によって，ようやく新しい農薬が完成した。</li></ul></li></ul><h4 id="时间＋を通して-表示整个时间范围"><a href="#时间＋を通して-表示整个时间范围" class="headerlink" title="时间＋を通して　表示整个时间范围"></a>时间＋を通して　表示整个时间范围</h4><ul><li>今週一週間を通して湿度が高く，蒸し暑い日が続くでしょう。</li></ul><h4 id="～ことがない-不会出现这样的情况"><a href="#～ことがない-不会出现这样的情况" class="headerlink" title="～ことがない　不会出现这样的情况"></a>～ことがない　不会出现这样的情况</h4><ul><li>その美しさはみ飽きることがない。</li></ul><h4 id="～ことはない-没必要，用不着"><a href="#～ことはない-没必要，用不着" class="headerlink" title="～ことはない　没必要，用不着"></a>～ことはない　没必要，用不着</h4><ul><li>ここまで来て，今さえ，やめることはない。</li></ul><h2 id="第２４課"><a href="#第２４課" class="headerlink" title="第２４課"></a>第２４課</h2><h3 id="文法-7"><a href="#文法-7" class="headerlink" title="文法"></a>文法</h3><h4 id="ます形＋がち-往往会，容易会，表示消极的事项"><a href="#ます形＋がち-往往会，容易会，表示消极的事项" class="headerlink" title="ます形＋がち　往往会，容易会，表示消极的事项"></a>ます形＋がち　往往会，容易会，表示消极的事项</h4><ul><li>一般の視聴者にとって，CMは迷惑なものと考えられがちだ。</li><li>それは，小さい子にありがちな自己中心的な考え方です。</li></ul><h4 id="～以上（は）～／～からには～-既然……就……（建议，义务，表决心）"><a href="#～以上（は）～／～からには～-既然……就……（建议，义务，表决心）" class="headerlink" title="～以上（は）～／～からには～　既然……就……（建议，义务，表决心）"></a>～以上（は）～／～からには～　既然……就……（建议，义务，表决心）</h4><ul><li>応援する以上は最後まで応援したほうがいい。</li><li>視聴者が，企業の広告ではなく番組のためにテレビを見る以上，広告主の企業や放送局と視聴者の利害は常に対立することになる。</li></ul><h4 id="ます形／一类形容词去い＋がる-想做，觉得，用于第三人称"><a href="#ます形／一类形容词去い＋がる-想做，觉得，用于第三人称" class="headerlink" title="ます形／一类形容词去い＋がる　想做，觉得，用于第三人称"></a>ます形／一类形容词去い＋がる　想做，觉得，用于第三人称</h4><ul><li>恥ずかしがってばかりいないで，自分から発言してはどうですか。</li><li>その子供はジュースを食べたがっている。</li></ul><h1 id="単元-2"><a href="#単元-2" class="headerlink" title="単元"></a>単元</h1><h2 id="第２５課"><a href="#第２５課" class="headerlink" title="第２５課"></a>第２５課</h2><h3 id="文法-8"><a href="#文法-8" class="headerlink" title="文法"></a>文法</h3><h4 id="～ついに-终于，表示花费时间或经过艰苦努力终于完成某事"><a href="#～ついに-终于，表示花费时间或经过艰苦努力终于完成某事" class="headerlink" title="～ついに　终于，表示花费时间或经过艰苦努力终于完成某事"></a>～ついに　终于，表示花费时间或经过艰苦努力终于完成某事</h4><ul><li>あの二人は7年交際して，ついに婚約した。</li><li>やっと　侧重于期待的事情终于实现了</li><li>あの二人は7年交際して，やっよ婚約した。</li></ul><h4 id="よく"><a href="#よく" class="headerlink" title="よく"></a>よく</h4><ul><li>经常<ul><li>陳さんは東京によく遊びに行きます。</li></ul></li><li>程度<ul><li>李さん，その洋服よく似合いますね。</li></ul></li><li>意外或感叹<ul><li>それにしても，よく会場を押さえられましたよね</li></ul></li><li>以よくも的形式表示惊讶或憎恶<ul><li>裏切っておきながら，彼はよくも私たちの前に姿を見せられたものだ。</li></ul></li></ul><h4 id="ます形＋きる-表示动作或事情彻底完成，用于动作或事情实现起来有困难时"><a href="#ます形＋きる-表示动作或事情彻底完成，用于动作或事情实现起来有困难时" class="headerlink" title="ます形＋きる　表示动作或事情彻底完成，用于动作或事情实现起来有困难时"></a>ます形＋きる　表示动作或事情彻底完成，用于动作或事情实现起来有困难时</h4><ul><li>3人分の料理を1人で食べきった。</li><li>中国をはじめとしたアジアの国々，ヨーロッパやアメリカ，中東，ロシアなどにも，数えきれないほどの日本食レストランがある。</li><li>类似的表达还有ます形＋通す　不放弃，不会改变想法，把某一动作坚持做到最后<ul><li>演奏家は途中で間違えたが，最後までその曲を弾き通した。</li></ul></li></ul><h4 id="～に応じた（接名词）／～に応じて（接动词）-根据-适应-，书面语"><a href="#～に応じた（接名词）／～に応じて（接动词）-根据-适应-，书面语" class="headerlink" title="～に応じた（接名词）／～に応じて（接动词）　根据/适应~，书面语"></a>～に応じた（接名词）／～に応じて（接动词）　根据/适应~，书面语</h4><ul><li>賃金は働きに応じて支払われる。</li><li>外国で売られている寿司は，文化の違いに応じた「創作料理」になっていることが多い。</li></ul><h4 id="～から見ると／～から見ても／～から見れば-从……来看，从某种立场上审视，考虑问题。"><a href="#～から見ると／～から見ても／～から見れば-从……来看，从某种立场上审视，考虑问题。" class="headerlink" title="～から見ると／～から見ても／～から見れば　从……来看，从某种立场上审视，考虑问题。"></a>～から見ると／～から見ても／～から見れば　从……来看，从某种立场上审视，考虑问题。</h4><ul><li>日本人から見ると，寿司だとは思えないものもたくさんある。</li><li>私から見て，佐藤さんは素晴らしい上司だ。</li></ul><h4 id="～に即した／～に即して-按照……-根据……"><a href="#～に即した／～に即して-按照……-根据……" class="headerlink" title="～に即した／～に即して　按照……/根据……"></a>～に即した／～に即して　按照……/根据……</h4><ul><li>食べ物はその国の状況に即して変化するものなのだ。</li><li>現状に即して考えると，政府の予測は楽観的過ぎる。</li></ul><h4 id="ぬ，ず-都是古日语用于表示未然形"><a href="#ぬ，ず-都是古日语用于表示未然形" class="headerlink" title="ぬ，ず　都是古日语用于表示未然形"></a>ぬ，ず　都是古日语用于表示未然形</h4><ul><li>江戸前ならぬ，アメリカ前，ニュージーランド前の寿司をその土地のスタイルで楽しむのもよいのではないだろうか。</li></ul><h2 id="第２６課"><a href="#第２６課" class="headerlink" title="第２６課"></a>第２６課</h2><h3 id="文法-9"><a href="#文法-9" class="headerlink" title="文法"></a>文法</h3><h4 id="～だけあって-真不愧是……，一般和さすが连用"><a href="#～だけあって-真不愧是……，一般和さすが连用" class="headerlink" title="～だけあって　真不愧是……，一般和さすが连用"></a>～だけあって　真不愧是……，一般和さすが连用</h4><ul><li>さすが上海一の高級ホテルだけあって，素晴らしい会場ですね。</li></ul><h4 id="～だけに-正是由于……"><a href="#～だけに-正是由于……" class="headerlink" title="～だけに　正是由于……"></a>～だけに　正是由于……</h4><ul><li>今回のテストは簡単だっただけに，クラスの平均点は高かった。</li></ul><h4 id="古日语表示未然形"><a href="#古日语表示未然形" class="headerlink" title="古日语表示未然形"></a>古日语表示未然形</h4><ul><li>复习：ず（三类动词せず），ぬ</li><li>ざる<ul><li>ない形＋ざるをえない／～しかない　不得不……，只好……<ul><li>約束だから，明日までにやらざるをえません。</li><li>期限が迫っているので，決めざるを得ません。</li><li>パソコンがフリーズしたので，プログラムを終了するしかありません。</li></ul></li></ul></li></ul><h4 id="～にもかかわらず-尽管……-虽然……"><a href="#～にもかかわらず-尽管……-虽然……" class="headerlink" title="～にもかかわらず　尽管……/虽然……"></a>～にもかかわらず　尽管……/虽然……</h4><ul><li>何度も注意したにもかかわらず，娘はまた友達の悪口を言っている。</li><li>李さんは頭が痛いにもかかわらず，寝ないで仕事を続けた。</li></ul><h4 id="～どころか-从根本上否定，用于消极事项，类似はもちろん"><a href="#～どころか-从根本上否定，用于消极事项，类似はもちろん" class="headerlink" title="～どころか　从根本上否定，用于消极事项，类似はもちろん"></a>～どころか　从根本上否定，用于消极事项，类似はもちろん</h4><ul><li>忙しくて，昼ご飯どころか，朝ご飯も食べていない。</li><li>このところ支出が多くて，貯金するどころか，借金が増えてしまった。</li></ul><h4 id="ます形＋かねる／かねない-难以实现-不好的事情很容易很可能实现"><a href="#ます形＋かねる／かねない-难以实现-不好的事情很容易很可能实现" class="headerlink" title="ます形＋かねる／かねない　难以实现/不好的事情很容易很可能实现"></a>ます形＋かねる／かねない　难以实现/不好的事情很容易很可能实现</h4><ul><li>このままだと，プロジェクトは中止になりかねない。</li></ul><h2 id="第２７課"><a href="#第２７課" class="headerlink" title="第２７課"></a>第２７課</h2><h3 id="文法-10"><a href="#文法-10" class="headerlink" title="文法"></a>文法</h3><h4 id="Aなしには／では／て＋B-没有A是不可能完成B的"><a href="#Aなしには／では／て＋B-没有A是不可能完成B的" class="headerlink" title="Aなしには／では／て＋B　没有A是不可能完成B的"></a>Aなしには／では／て＋B　没有A是不可能完成B的</h4><ul><li>今回の成功は，彼らの協力なしにはありえなかったと思います。</li><li>お金もなしに，会社を成立することは不可能だ。</li></ul><h4 id="ます形＋える／うる-也表示为动词的可能态"><a href="#ます形＋える／うる-也表示为动词的可能态" class="headerlink" title="ます形＋える／うる　也表示为动词的可能态"></a>ます形＋える／うる　也表示为动词的可能态</h4><ul><li>この状態は，予想しえない事態だ。</li></ul><h4 id="字典形＋まい"><a href="#字典形＋まい" class="headerlink" title="字典形＋まい"></a>字典形＋まい</h4><ul><li>～ないだろう　表示否定推测，难道不是……<ul><li>この勝負の勝敗はすでに決まっていたのではあるまいか。</li></ul></li><li>～しないつもりだ　表示否定的意志<ul><li>こんな所にはもう二度と来るまい。</li></ul></li></ul><h4 id="～ずにはいられない-忍不住要……做"><a href="#～ずにはいられない-忍不住要……做" class="headerlink" title="～ずにはいられない　忍不住要……做"></a>～ずにはいられない　忍不住要……做</h4><ul><li>部屋が汚れていると，片づけずにはいられない。</li><li>その映画を見たら，泣かずにはいられない。</li></ul><h4 id="～のみならず-不仅……"><a href="#～のみならず-不仅……" class="headerlink" title="～のみならず　不仅……"></a>～のみならず　不仅……</h4><ul><li>中国のみならず，日本でも張一心は人気がある。</li><li>复习：和～ばかりでなく，～だけではなく意思一样</li></ul><h4 id="ちなみに～-顺便一提，附带，补充说明"><a href="#ちなみに～-顺便一提，附带，补充说明" class="headerlink" title="ちなみに～　顺便一提，附带，补充说明"></a>ちなみに～　顺便一提，附带，补充说明</h4><ul><li>玉袁譚公園では，日本から寄贈された桜を見ることができる。ちなみに，北京の桜は東京よりも3週間ほど開花が遅いそうだ。</li></ul><h2 id="第２８課"><a href="#第２８課" class="headerlink" title="第２８課"></a>第２８課</h2><h3 id="文法-11"><a href="#文法-11" class="headerlink" title="文法"></a>文法</h3><h4 id="～もんです-表示理由的ものです"><a href="#～もんです-表示理由的ものです" class="headerlink" title="～もんです　表示理由的ものです"></a>～もんです　表示理由的ものです</h4><ul><li>ここ数日忙しかったもんで，なかなかお電話できず申し訳ありませんでした。</li></ul><h4 id="ついでに-做某事同时又在做着其他事情"><a href="#ついでに-做某事同时又在做着其他事情" class="headerlink" title="ついでに　做某事同时又在做着其他事情"></a>ついでに　做某事同时又在做着其他事情</h4><ul><li>散歩に出たついでに，コンビニで買い物をして帰った。</li></ul><h4 id="だったらいいんです／ならいいんです-那就好"><a href="#だったらいいんです／ならいいんです-那就好" class="headerlink" title="だったらいいんです／ならいいんです　那就好"></a>だったらいいんです／ならいいんです　那就好</h4><ul><li>コンテストは大成功のうちに終わりました。<ul><li>だったらいいんです。</li></ul></li></ul><h4 id="～だけには～-唯独对……"><a href="#～だけには～-唯独对……" class="headerlink" title="～だけには～　唯独对……"></a>～だけには～　唯独对……</h4><ul><li>健康だけには自信があったのに。</li></ul><h4 id="Aに反してB-与A相反的B"><a href="#Aに反してB-与A相反的B" class="headerlink" title="Aに反してB　与A相反的B"></a>Aに反してB　与A相反的B</h4><ul><li>予想に反して，来場者は1万人を超えた。</li></ul><h4 id="そてらとは別に-另一方面，与～一方有相同的意思"><a href="#そてらとは別に-另一方面，与～一方有相同的意思" class="headerlink" title="そてらとは別に　另一方面，与～一方有相同的意思"></a>そてらとは別に　另一方面，与～一方有相同的意思</h4><ul><li>彼は英会話学校で動いています。しかし，それらとは別に芸術家として活動しています。</li></ul><h1 id="単元-3"><a href="#単元-3" class="headerlink" title="単元"></a>単元</h1><h2 id="第２９課"><a href="#第２９課" class="headerlink" title="第２９課"></a>第２９課</h2><h3 id="文法-12"><a href="#文法-12" class="headerlink" title="文法"></a>文法</h3><h4 id="～までもない-没必要"><a href="#～までもない-没必要" class="headerlink" title="～までもない　没必要"></a>～までもない　没必要</h4><ul><li>今さら言うまでもありません，すべて皆さんのおかげです。</li></ul><h4 id="～ぶり／～っぷり-……的样子"><a href="#～ぶり／～っぷり-……的样子" class="headerlink" title="～ぶり／～っぷり　……的样子"></a>～ぶり／～っぷり　……的样子</h4><ul><li>彼の歩きぶりから見せと，どうも足にけがをしているようだ。</li><li>佐藤さんはいつも食べっぷりがいい。</li><li>复习：时间＋ぶり表示时间间隔</li></ul><h4 id="たった-仅仅经常和だけ连用"><a href="#たった-仅仅经常和だけ连用" class="headerlink" title="たった　仅仅经常和だけ连用"></a>たった　仅仅经常和だけ连用</h4><ul><li>たった1年で，これだけ業績を上げたんですから。</li></ul><h4 id="～に決まっている-一定是……，绝对是……，肯定是……"><a href="#～に決まっている-一定是……，绝对是……，肯定是……" class="headerlink" title="～に決まっている　一定是……，绝对是……，肯定是……"></a>～に決まっている　一定是……，绝对是……，肯定是……</h4><ul><li>今から会社に帰っても，もう誰もいないにきまっている。</li></ul><h4 id="AうえでB／AたうえでB-为了A，在此之前先做B-先做A，然后做B"><a href="#AうえでB／AたうえでB-为了A，在此之前先做B-先做A，然后做B" class="headerlink" title="AうえでB／AたうえでB　为了A，在此之前先做B/先做A，然后做B"></a>AうえでB／AたうえでB　为了A，在此之前先做B/先做A，然后做B</h4><ul><li>外国に住むうえで，一番気を付けなければならないことは何ですか。</li><li>多額の資金を集めたうえで，会長に立候補した。</li></ul><h4 id="そう～ではない-并不是……"><a href="#そう～ではない-并不是……" class="headerlink" title="そう～ではない　并不是……"></a>そう～ではない　并不是……</h4><ul><li>日本語はそう難しくないと思います。</li></ul><h4 id="～とはいうものの-虽然这么说，尽管"><a href="#～とはいうものの-虽然这么说，尽管" class="headerlink" title="～とはいうものの　虽然这么说，尽管"></a>～とはいうものの　虽然这么说，尽管</h4><ul><li>とはいうものの，宇宙に持っていける食べ物には，いくつかの条件がある。</li><li>このはかりはデザインが斬新なものの，実用的ではない。</li></ul><h4 id="～にすら-尽然，连"><a href="#～にすら-尽然，连" class="headerlink" title="～にすら　尽然，连"></a>～にすら　尽然，连</h4><ul><li>そのことは，田中さんすら知らなかった。</li><li>疲れ切って，食事すらできない。</li></ul><h4 id="～にあたって-在……之际"><a href="#～にあたって-在……之际" class="headerlink" title="～にあたって　在……之际"></a>～にあたって　在……之际</h4><ul><li>海外に赴任するにあたって，いろいろな準備をしなければなりませんでした。</li></ul><h2 id="第３０課"><a href="#第３０課" class="headerlink" title="第３０課"></a>第３０課</h2><h3 id="文法-13"><a href="#文法-13" class="headerlink" title="文法"></a>文法</h3><h4 id="Aに先立ってB-在A之前先做B动作"><a href="#Aに先立ってB-在A之前先做B动作" class="headerlink" title="Aに先立ってB　在A之前先做B动作"></a>Aに先立ってB　在A之前先做B动作</h4><ul><li>トレーニングの開始に先立ち，細かいスケジュールを立てた。</li></ul><h4 id="Aを通してB-表示方法手段，通过A做B动作"><a href="#Aを通してB-表示方法手段，通过A做B动作" class="headerlink" title="Aを通してB　表示方法手段，通过A做B动作"></a>Aを通してB　表示方法手段，通过A做B动作</h4><ul><li>妻とは，私と妻の共通の友人を通して知り合いました。</li><li>复习：时间段+を通して　表示整个时间段</li></ul><h4 id="～できなくはない-不是不能"><a href="#～できなくはない-不是不能" class="headerlink" title="～できなくはない　不是不能"></a>～できなくはない　不是不能</h4><ul><li>その映画は原作を読まなくても理解できなくはないですが，よく分からないと思うころがたくさんあると思います。</li></ul><h4 id="～にしたがって／～につれて-随着……，按照……"><a href="#～にしたがって／～につれて-随着……，按照……" class="headerlink" title="～にしたがって／～につれて　随着……，按照……"></a>～にしたがって／～につれて　随着……，按照……</h4><ul><li>年を取るにしたがって，一日が短く感じられるのはなぜだろう。</li><li>太陽が沈むにしたがって，辺りは暗くなった。</li></ul><h4 id="～にすぎない-不过如此，没什么大不了的"><a href="#～にすぎない-不过如此，没什么大不了的" class="headerlink" title="～にすぎない　不过如此，没什么大不了的"></a>～にすぎない　不过如此，没什么大不了的</h4><ul><li>私はあくまで彼の代理で会議に出席したにすぎない。</li></ul><h4 id="～に位置している-位于，处于……位置"><a href="#～に位置している-位于，处于……位置" class="headerlink" title="～に位置している　位于，处于……位置"></a>～に位置している　位于，处于……位置</h4><ul><li>フランスはドイツの西に位置しています。</li></ul><h4 id="～にほかならない-正因为是……"><a href="#～にほかならない-正因为是……" class="headerlink" title="～にほかならない　正因为是……"></a>～にほかならない　正因为是……</h4><ul><li>落第の原因は，勉強不足にほかならない。</li></ul><h4 id="～としても，～-即使……也……"><a href="#～としても，～-即使……也……" class="headerlink" title="～としても，～　即使……也……"></a>～としても，～　即使……也……</h4><ul><li>両親が反対したとしても，私は留学します。</li><li>明日は忙しいので，そちらに伺えるとしても遅くなってしまうと思います。</li></ul><h2 id="第３１課"><a href="#第３１課" class="headerlink" title="第３１課"></a>第３１課</h2><h3 id="文法-14"><a href="#文法-14" class="headerlink" title="文法"></a>文法</h3><h4 id="～くせに-明明……却……"><a href="#～くせに-明明……却……" class="headerlink" title="～くせに　明明……却……"></a>～くせに　明明……却……</h4><ul><li>俺より2年後輩のくせに，すごいじゃないか。</li><li>私の息子は，学校で答えが分からないくせに，いつも手を挙げているそうだ。</li></ul><h4 id="（动词原形-形容词去い＋くある-名词和形动＋である）＋べき-表示第三人称的应该……"><a href="#（动词原形-形容词去い＋くある-名词和形动＋である）＋べき-表示第三人称的应该……" class="headerlink" title="（动词原形/形容词去い＋くある/名词和形动＋である）＋べき　表示第三人称的应该……"></a>（动词原形/形容词去い＋くある/名词和形动＋である）＋べき　表示第三人称的应该……</h4><ul><li>とにかく，先に栄転を受けるべきだよ。</li><li>すべての人は平等であるべきだ。</li><li>地球の自然はいつまでも美しくあるべきだ。</li></ul><h4 id="～もんか／～ものか-不……"><a href="#～もんか／～ものか-不……" class="headerlink" title="～もんか／～ものか　不……"></a>～もんか／～ものか　不……</h4><ul><li>こうなったら，もう心配なんてするもんか。</li><li>助けてやると言ったのに断るなんて，もう絶対に助けてやるものか。</li></ul><h4 id="～てやる-说话人给予对方利益，恩惠。"><a href="#～てやる-说话人给予对方利益，恩惠。" class="headerlink" title="～てやる　说话人给予对方利益，恩惠。"></a>～てやる　说话人给予对方利益，恩惠。</h4><ul><li>今日は俺がおごってやるよ。</li><li>娘に四捨五入の方法を教えてやる。</li></ul><h4 id="～とすると／～とすれば／～となると／～としたら-如果……"><a href="#～とすると／～とすれば／～となると／～としたら-如果……" class="headerlink" title="～とすると／～とすれば／～となると／～としたら　如果……"></a>～とすると／～とすれば／～となると／～としたら　如果……</h4><ul><li>公衆の面前でスピーチするとなると，緊張してしまいます。</li></ul><h4 id="～がなされる／～をする-古日语的用法，书面语"><a href="#～がなされる／～をする-古日语的用法，书面语" class="headerlink" title="～がなされる／～をする　古日语的用法，书面语"></a>～がなされる／～をする　古日语的用法，书面语</h4><ul><li>今回の研究会では活溌な議論がなされる。</li></ul><h2 id="第３２課"><a href="#第３２課" class="headerlink" title="第３２課"></a>第３２課</h2><h3 id="文法-15"><a href="#文法-15" class="headerlink" title="文法"></a>文法</h3><h4 id="～どころではない-顾不上……，不是做……的时候"><a href="#～どころではない-顾不上……，不是做……的时候" class="headerlink" title="～どころではない　顾不上……，不是做……的时候"></a>～どころではない　顾不上……，不是做……的时候</h4><ul><li>父は正月だというのに出かけるどころではなく，家で遅くまで仕事をしている。</li></ul><h4 id="～なりに-站在……立场上"><a href="#～なりに-站在……立场上" class="headerlink" title="～なりに　站在……立场上"></a>～なりに　站在……立场上</h4><ul><li>大阪で，僕なりに考えました。</li><li>あの子もあの子なりに意見があるのでしょうから，怒らないでまず話を聞いてあげてください。</li></ul><h4 id="～でしかない-不过是……"><a href="#～でしかない-不过是……" class="headerlink" title="～でしかない　不过是……"></a>～でしかない　不过是……</h4><ul><li>貯金しているといっても，まだ１０万円でしかない。</li><li>言葉というのはコミュニケーションをするための道具でしかない。</li></ul><h4 id="～恐れがある／～かねない（有依据时可以使用）-恐怕会……，很有可能……发生不好的事情"><a href="#～恐れがある／～かねない（有依据时可以使用）-恐怕会……，很有可能……发生不好的事情" class="headerlink" title="～恐れがある／～かねない（有依据时可以使用）　恐怕会……，很有可能……发生不好的事情"></a>～恐れがある／～かねない（有依据时可以使用）　恐怕会……，很有可能……发生不好的事情</h4><ul><li>台風が本州に上達する恐れがある。</li><li>あんな運転の仕方では，衝突事故でも起こしかねない。</li></ul><h4 id="～のみ-和だけ一样的意思，书面语"><a href="#～のみ-和だけ一样的意思，书面语" class="headerlink" title="～のみ　和だけ一样的意思，书面语"></a>～のみ　和だけ一样的意思，书面语</h4><ul><li>この商品は，予約している方のみ購入することができます。</li></ul><h4 id="～に至る-到……为止，书面语"><a href="#～に至る-到……为止，书面语" class="headerlink" title="～に至る　到……为止，书面语"></a>～に至る　到……为止，书面语</h4><ul><li>現在では1000羽以上が確認されるに至っている。</li><li>結婚に至るまで，二人の間にはいろんなことがありました。</li></ul><h4 id="AかたわらB-表示A和B同时进行，A是主要动作，B是次要动作"><a href="#AかたわらB-表示A和B同时进行，A是主要动作，B是次要动作" class="headerlink" title="AかたわらB　表示A和B同时进行，A是主要动作，B是次要动作"></a>AかたわらB　表示A和B同时进行，A是主要动作，B是次要动作</h4><ul><li>山本さんはコーチのかたわら，審判としても活躍している。</li></ul><h4 id="～に終わる（失敗，不調）-以不顺利的情况结束"><a href="#～に終わる（失敗，不調）-以不顺利的情况结束" class="headerlink" title="～に終わる（失敗，不調）　以不顺利的情况结束"></a>～に終わる（失敗，不調）　以不顺利的情况结束</h4><ul><li>今回の世界大会で，日本チームは実力が出せずに不調に終わった。</li></ul><h4 id="～をもって-以……分水岭，从……起，到……为止"><a href="#～をもって-以……分水岭，从……起，到……为止" class="headerlink" title="～をもって　以……分水岭，从……起，到……为止"></a>～をもって　以……分水岭，从……起，到……为止</h4><ul><li>私は，3月31日をもって，会社を退職することにいたしました。</li></ul><h4 id="～に際して-在……之际，……的时候，书面语"><a href="#～に際して-在……之际，……的时候，书面语" class="headerlink" title="～に際して　在……之际，……的时候，书面语"></a>～に際して　在……之际，……的时候，书面语</h4><ul><li>本ホームページのご利用に際しては，以かの点にご注意ください。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之N2文法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-N3文法</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-N3%E6%96%87%E6%B3%95/"/>
    <id>/2024/06/11/日语-N3文法/</id>
    <published>2024-06-11T03:10:55.000Z</published>
    <updated>2024-06-11T05:20:24.688Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之N3文法<br><a id="more"></a></p><h1 id="単元"><a href="#単元" class="headerlink" title="単元"></a>単元</h1><h2 id="第１課"><a href="#第１課" class="headerlink" title="第１課"></a>第１課</h2><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><h4 id="～くらい-ぐらい-ほど-接续：动词简体，形容词，形容动词＋な，名词"><a href="#～くらい-ぐらい-ほど-接续：动词简体，形容词，形容动词＋な，名词" class="headerlink" title="～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词"></a>～くらい/ぐらい/ほど 接续：动词简体，形容词，形容动词＋な，名词</h4><ol><li><p>接续：动词简体，形容词，形容动词+ な</p></li><li><p>……左右，大约……，可以和ほど替换</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：家から学校まで一時間ぐらいかかる。</span><br><span class="line">译：从家到学校大概要花1个小时左右。</span><br><span class="line"></span><br><span class="line">例：どのぐらい日本語を勉強していますか。</span><br><span class="line">译：大概学了多久日语呢？</span><br></pre></td></tr></table></figure><ol start="3"><li>表示动作或状态的程度，可以和ほど替换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：飛ぶほど嬉しい。</span><br><span class="line">译：高兴地飞起。</span><br><span class="line"></span><br><span class="line">例：今日は忙しくて、食事する時間もないくらいだ。</span><br><span class="line">译：今天太忙了以至于我连吃饭的时间都没有。</span><br></pre></td></tr></table></figure><ol start="4"><li>表示最低程度，至少</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：いくら忙しくても、電話ぐらいはできるでしょう。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：自分の事ぐらいは自分でやります。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ol start="5"><li>没有比……更……，可以和ほど替换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：朱さんぐらい可愛い人はいない。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：戦争ぐらい残酷なものはない。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="とは-というのは"><a href="#とは-というのは" class="headerlink" title="とは/というのは"></a>とは/というのは</h4><ol><li>所谓的~ 用于下定义和解释说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：JRとは、Japan Railwaysの略です。</span><br><span class="line">译：JR是Japan Railways的简写。</span><br></pre></td></tr></table></figure><ol start="2"><li>……是因为…… 前者是因为后者导致的，这时只能用～というのは～のだ</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は怒ったというのは、きっと酷い事を言われたのでしょう。</span><br><span class="line">译：他生气的原因一定是被说了很过分的话吧？</span><br></pre></td></tr></table></figure><h4 id="～というものは-ということは-用于说明该事物的本质特征"><a href="#～というものは-ということは-用于说明该事物的本质特征" class="headerlink" title="～というものは/ということは 用于说明该事物的本质特征"></a>～というものは/ということは 用于说明该事物的本质特征</h4><ol><li>～というものは 用于名词</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：人間というものは一人で生きていくことはできません。</span><br><span class="line">译：人类是一个人无法生存下去的吧。</span><br></pre></td></tr></table></figure><ol start="2"><li>～ということは 用于动词，也可以用于对事情原因的推测</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：一人で生活するということは、大変なことですね。</span><br><span class="line">译：一个人生活真是不容易呀。</span><br><span class="line"></span><br><span class="line">例：彼は怒ったということは、きっと酷い事を言われたのでしょう。</span><br><span class="line">译：他生气的原因一定是被说了很过分的话吧？</span><br></pre></td></tr></table></figure><ol start="3"><li>～ということは/つまり、～ということだ　也就是说……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日から会社へ来なくてもいい、つまり君はクビだということだ。</span><br><span class="line">译：明天就不用来公司上班了，也就是说你被解雇了。</span><br></pre></td></tr></table></figure><h4 id="～はもちろん-はもとより-自不必说"><a href="#～はもちろん-はもとより-自不必说" class="headerlink" title="～はもちろん/はもとより　自不必说"></a>～はもちろん/はもとより　自不必说</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：最近は仕事が忙しくて、土曜日はもちろん、日曜日も休めない。</span><br><span class="line">译：最近工作太忙了，星期六就不用说了，星期天也没法休息了。</span><br><span class="line"></span><br><span class="line">例：主要都市を結ぶ路線はもちろん、世界で初めて実用化されたリニアモーターカーも国営です。</span><br><span class="line">译：连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。</span><br></pre></td></tr></table></figure><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>日本には，JR，鉄道，公営の３種類の鉄道会社があります。JRとは，Japan Railwaysの略です。以前は国営の鉄道でしたが，１９８７年に民営化されました。世界的に有名な新幹線もJRの路線の１つで，日本の主要な都市と都市を結んでいます。最高時速は３００キロを超えます。最初に完成したのは東海道新幹線ですが，山陽新幹線，東北新幹線，九州新幹線など，路線がどんどん延びています。</p><p>中国の鉄道は，ほとんど国営です。主要都市を結ぶ路線はもちろん，世界で初めて実用化されたリニアモーターも国営です。</p><blockquote><p>在日本有JR、铁路、公营三种类型的铁路公司。JR是Japan Railways的简称。以前是属于国有铁路，1987年民营化了。世界有名的新干线就是JR的其中一条线路，把日本主要城市与城市之间连接起来。最高时速超过300公里。最初完成的是东海道新干线、山阳新干线以及九州新干线等等，渐渐的线路不断延伸。</p></blockquote><blockquote><p>中国的铁路基本都是国营的。连接主要城市的路线自不必说，世界首次实用化的磁悬浮列车也是国营的。</p></blockquote><h2 id="第２課"><a href="#第２課" class="headerlink" title="第２課"></a>第２課</h2><h3 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h3><h4 id="～ものです。"><a href="#～ものです。" class="headerlink" title="～ものです。"></a>～ものです。</h4><ol><li>表示对事物的性质或变化的感慨或吃惊，经常与よく一起使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一人でよく返って来られたものですね。</span><br><span class="line">译：竟然能一个人回来呀。</span><br></pre></td></tr></table></figure><ol start="2"><li>AはBものです，A本质上具有B的性质、B是理所应当的事情</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：人の心は分からないものです。（本质）</span><br><span class="line">译：人心是最难懂的。</span><br><span class="line"></span><br><span class="line">例：約束の時間に遅れる時は，相手に連絡するものです。（理所应当）</span><br><span class="line">译：在约定的时间迟到了的话，应该和对方联系。</span><br></pre></td></tr></table></figure><h4 id="口语中经常使用～て来接续，书面语中使用ます形来接续"><a href="#口语中经常使用～て来接续，书面语中使用ます形来接续" class="headerlink" title="口语中经常使用～て来接续，书面语中使用ます形来接续"></a>口语中经常使用～て来接续，书面语中使用ます形来接续</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：深いお辞儀をし，相手の名刺をお辞儀をしながら受け取ります。</span><br><span class="line">译：深深地鞠躬，一边鞠躬一边接受对方的名片。</span><br></pre></td></tr></table></figure><h4 id="简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！"><a href="#简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！" class="headerlink" title="简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！"></a>简体＋ほうが～です。做什么更怎么怎么样。如果做什么使用的是た形则语气较强！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：名刺を出す時も受け取る時も，両手を使うほうが丁寧です。</span><br><span class="line">译：名片递出和接收的时候，用双手是更加礼貌的。</span><br></pre></td></tr></table></figure><h4 id="いくら～ても～-无论……也……"><a href="#いくら～ても～-无论……也……" class="headerlink" title="いくら～ても～　无论……也……"></a>いくら～ても～　无论……也……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この店ではいくら食べても，１０００円です。</span><br><span class="line">译：这家店不管吃多少，只要1000日元。</span><br></pre></td></tr></table></figure><h3 id="课文-1"><a href="#课文-1" class="headerlink" title="课文"></a>课文</h3><p>仕事で初対面の人にあった時は，名刺を出します。名刺の出し方と受け取り方にも決まりがあります。相手が目上の時は，まず自分から名刺をだして深いお辞儀をし，次に相手の名刺をお辞儀をしながら受け取ります。出す時も受け取る時も，両手を使うほうが丁寧です。</p><p>また，話内容にも気をつけなけれならなりません。初対面の時は，個人的なことを聞かないのが普通です。特に仕事の場で出合った相手には，個人的な質問を避けたほうがいいでしょう。結婚しているかどうか，給料はいくらか，年齢はいくつかなどもは，普通は聞きません。</p><blockquote><p>工作场合下和对方第一次见面时，要递出名片。名片的递出和接收方法都是有规定的。对方是上级的时候，首先自己首先递出名片并深鞠躬，接着边鞠躬边接收对方的名片。名片递出和接收的时候，用双手是更加礼貌的。</p></blockquote><blockquote><p>另外聊天的内容也要注意。第一次见面时，个人相关的事情一般不要询问。特别是工作场合遇到对方，最好避免个人问题。结婚了没，工资多少，年龄多大了等问题一般不要询问。</p></blockquote><h2 id="第３課"><a href="#第３課" class="headerlink" title="第３課"></a>第３課</h2><h3 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h3><h4 id="～を含めて＋数量词-包括-在内的-「数量词」"><a href="#～を含めて＋数量词-包括-在内的-「数量词」" class="headerlink" title="～を含めて＋数量词 包括~在内的+「数量词」"></a>～を含めて＋数量词 包括~在内的+「数量词」</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今回の『金星』プロジェクトは，私を含めて４名のスタッフが担当いたします。</span><br><span class="line">译：这次金星项目包括我一共四人负责。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：～ほか＋数量词 除开……还有+「数量词」……</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今回のプロジェクトの担当者は，主任の李秀麗ほか３名のスタッフです。</span><br><span class="line">译：这次的项目负责人除了李秀丽以外还有3人。</span><br></pre></td></tr></table></figure><h4 id="～にとって-对……来说，表示从某人立场上来说，用于表明立场"><a href="#～にとって-对……来说，表示从某人立场上来说，用于表明立场" class="headerlink" title="～にとって 对……来说，表示从某人立场上来说，用于表明立场"></a>～にとって 对……来说，表示从某人立场上来说，用于表明立场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。</span><br><span class="line">译：对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><blockquote><p>～として，有和当事人有同一向想法的时候使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：困っている人を助けるのは，人間として当然のことです。</span><br><span class="line">译：帮助有困难的人，作为人来说是应当的。</span><br></pre></td></tr></table></figure><blockquote><p>～としては，站在客观立场上，强调自己的立场</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私としては，その案に反対です。</span><br><span class="line">译：我个人是反对这个方案的。</span><br></pre></td></tr></table></figure><blockquote><p>～にしたら・～してみれば・～にすれば 有希望对方理解的感觉</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大人には簡単でも，子供にしたら難しいでしょう。</span><br><span class="line">译：对大人来说简单，可对小孩子就困难的很。</span><br></pre></td></tr></table></figure><h4 id="～が，～けど-表示转折或者铺垫下文的说法"><a href="#～が，～けど-表示转折或者铺垫下文的说法" class="headerlink" title="～が，～けど 表示转折或者铺垫下文的说法"></a>～が，～けど 表示转折或者铺垫下文的说法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：すみませんが，今話してもいいでしょう。</span><br><span class="line">译：打扰一下，现在方便说话吗？</span><br><span class="line"></span><br><span class="line">例：李さんも日本語も上手ですけど，王さんも上手ですね。</span><br><span class="line">译：李桑日语说的很好，王桑也说的很好呀。</span><br></pre></td></tr></table></figure><h4 id="～わけには-もいきません-依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱"><a href="#～わけには-もいきません-依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱" class="headerlink" title="～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱"></a>～わけには/もいきません 依据常识是不可能的，但是も有表达也可以考虑选择的感觉，相对于は语气较弱</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：名字をつけないわけにはにいきません。</span><br><span class="line">译：不取名字是不行的。</span><br><span class="line"></span><br><span class="line">例：質問がたくさんあっても，無視するわけにもいかないので，きちんと答えています。</span><br><span class="line">译：即使问题有很多，也不能无视它，要好好地回答。</span><br></pre></td></tr></table></figure><h4 id="～といわれています-据说，通常认为，表示非说话人主观判断，而是一种普遍的常识"><a href="#～といわれています-据说，通常认为，表示非说话人主观判断，而是一种普遍的常识" class="headerlink" title="～といわれています　据说，通常认为，表示非说话人主观判断，而是一种普遍的常识"></a>～といわれています　据说，通常认为，表示非说话人主观判断，而是一种普遍的常识</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。</span><br><span class="line">译：日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。</span><br></pre></td></tr></table></figure><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li>佐藤：よろしくお願いします。李さんも日本語が上手ですけど，王さんも上手です。</li><li>王：ありがとうございます。出身は浙江省の紹興ですが，大学時代，日本に留学していたんです。ですから，今回のプロジェクトに大変興味があります。</li><li>佐藤：紹興ですか，１０年前に，一度だけ行ったことがあります。</li><li>王：そうでうか。</li><li>佐藤：ええ。私にとって，初めての海外旅行でしたが，紹興で飲んだ紹興酒の味は今でも覚えていますよ。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">佐藤：请多关照。李桑日语说的很好，王桑也说的很好呀。</span><br><span class="line">王：谢谢夸奖。出生于浙江绍兴，大学地时候，去日本留学过。所以对这次地项目非常地有兴趣。</span><br><span class="line">佐藤：绍兴吗，10年前，去过一次呀。</span><br><span class="line">王：是吗？</span><br><span class="line">佐藤：是的呢。对我来说，第一次海外旅行，在绍兴喝的绍兴酒至今我还记得。</span><br></pre></td></tr></table></figure><h3 id="课文-2"><a href="#课文-2" class="headerlink" title="课文"></a>课文</h3><p>しかし，名字をつけないわけにはいきません。そこで，多くの人が，地名や地形から名字をつけましら。日本の名字に，『木』，『林』，『山』，『川』など自然に関係する名字が多いのは，そのためです。家が谷の中にあるから『中谷』，近くに大きな杉の木があるから『大杉』とつけられた名字もたくさんあります。日本で最も多い『佐藤』や『鈴木』は，昔の武士の名字や，地名からつけられた名字だといわれています。</p><blockquote><p>但是不取名字是不行的。所以大多数人的名字是来源于地名或地形。因此日本的名字中，『木』，『林』，『山』，『川』等等和自然有关的名字很多。家住在山谷中就叫『中谷』，附近有巨大的杉树就叫『大杉』这样的名字也有很多。日本最多地名字是『佐藤』和『铃木』，是来源于以前武士地名字或者地名。</p></blockquote><h2 id="第４課"><a href="#第４課" class="headerlink" title="第４課"></a>第４課</h2><h3 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h3><h4 id="信息的转述"><a href="#信息的转述" class="headerlink" title="信息的转述"></a>信息的转述</h4><ol><li>简体＋そうです</li></ol><ul><li>转述他人信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：李さんは明日会社を休むそうです。</span><br><span class="line">译：李桑明天休假。</span><br></pre></td></tr></table></figure><ul><li>听说传闻</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼女はもうすぐ結婚するそうです。</span><br><span class="line">译：她好像马上要结婚了。</span><br></pre></td></tr></table></figure><ul><li>样态，似乎、好像、看起来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この葡萄が美味しそうです。</span><br><span class="line">译：这个葡萄看起来很好吃的样子。</span><br></pre></td></tr></table></figure><ol start="2"><li>～とのことです、～ということです 听说，据说</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：このダムには３メートルくらいの魚がいるということです。</span><br><span class="line">译：听说这个水坝有3米长的鱼。</span><br><span class="line"></span><br><span class="line">例：山田さんがよろしくとのことです。</span><br><span class="line">译：听说山田人很好。</span><br></pre></td></tr></table></figure><ol start="3"><li>～といってもいました 记得说过，或者用于确认对方说的话</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：青木主任がちょっとお話しをしたいと言っていました。</span><br><span class="line">译：青木主任想和你说几句话。</span><br></pre></td></tr></table></figure><ol start="4"><li>简体＋って 与家人、朋友等亲密的人表示传闻，可以替换～と，～とは，～という人は</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日は雨だって。</span><br><span class="line">译：明天有雨。</span><br></pre></td></tr></table></figure><h4 id="思ったより-超出预想水平或范围"><a href="#思ったより-超出预想水平或范围" class="headerlink" title="思ったより 超出预想水平或范围"></a>思ったより 超出预想水平或范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：思ったより大変な仕事になりそうなんです。</span><br><span class="line">译：工作变得超乎想象的辛苦呢。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：予想以上に/想像以上に 比より更加正式程度也更强一些</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：今月の給料は予想以上に少なくて，がっかりしました。</span><br><span class="line">译：这个月的工资比预想的少多了，很失望。</span><br><span class="line"></span><br><span class="line">例：上海の変化は想像以上に速いですね。</span><br><span class="line">译：上海的变化比预想的还要快呀。</span><br></pre></td></tr></table></figure><h4 id="～といえば-说道-用于把名词作为话题提出，对话题进行说明"><a href="#～といえば-说道-用于把名词作为话题提出，对话题进行说明" class="headerlink" title="～といえば　说道~ 用于把名词作为话题提出，对话题进行说明"></a>～といえば　说道~ 用于把名词作为话题提出，对话题进行说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：かつて，日本のサラリーマンといえば，朝早く家を出て家に帰るのは深夜になり，残業や休日出勤をするのは当たり前でした。</span><br><span class="line">译：以前说到日本的上班族，很早出门深夜回家，加班和周末上班是理所应当的。</span><br></pre></td></tr></table></figure><h4 id="このように-综上所述"><a href="#このように-综上所述" class="headerlink" title="このように 综上所述"></a>このように 综上所述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このように，日本のサラリーマンの働き方は，かつてに比べると大きく変化しています。</span><br><span class="line">译：综上所述，日本的上班族的工作方式对比之前有了很大变化。</span><br></pre></td></tr></table></figure><h3 id="会话-1"><a href="#会话-1" class="headerlink" title="会话"></a>会话</h3><ul><li>青木：お忙しいところすみません。実は，上海支社で進めている『金星』プロジェクトが，思ったより大変な仕事になりそうなんです。</li><li>山田：そうですか。</li><li>青木：それで，東京本社でも『金星』プロジェクトの担当者を決めることになりました。突然ですが，山田さん，この仕事をしてもらえませんか。</li><li>山田：私が『金星』プロジェクトの担当者に？</li><li>青木：はい。上海支社の李さんからの要望なんです。</li><li>山田：李さんが，私を推薦してくれたんですか。</li><li>青木：ええ。山田さんは上海支社に行ったこともあるし，中国の事情に詳しいからということでした。</li><li>山田：分かりました。中国と関係のある仕事なら，ぜひやってみたいと思います。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">青木：这忙还打扰你。实际上上海分公司正在推进的金星项目，变得比预想还要麻烦呢。</span><br><span class="line">山田：是这样吗？</span><br><span class="line">青木：所以，东京总公司决定了金星项目的负责人。虽然有些突然，山田桑，这份工作你愿意接受吗？</span><br><span class="line">山田：我担任金星项目的负责人吗？</span><br><span class="line">青木：是的。上海分公司的李桑推荐的。</span><br><span class="line">山田：李桑推荐的我吗？</span><br><span class="line">青木：是的呢。山田桑去过上海分公司，对中国的事情也很了解。</span><br><span class="line">山田：我知道了。和中国有关系的工作，请一定要让我试试。</span><br></pre></td></tr></table></figure><h3 id="课文-3"><a href="#课文-3" class="headerlink" title="课文"></a>课文</h3><p>さらに，フレックスタイム制度を導入する会社も増えています。これは，自分の出勤と退勤の時間を自由に決められる制度です。労働者が自分の生活と仕事のバランスを取りながら，働くことができるように設けられました。</p><blockquote><p>另外，引入弹性时间制度的公司也增加了不少。这是项可以自己自由决定上班和下班时间的制度。这个是为劳动者既能平衡自己的生活和工作，也能工作所设计的。</p></blockquote><h1 id="単元-1"><a href="#単元-1" class="headerlink" title="単元"></a>単元</h1><h2 id="第５課"><a href="#第５課" class="headerlink" title="第５課"></a>第５課</h2><h3 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h3><h4 id="转换话题"><a href="#转换话题" class="headerlink" title="转换话题"></a>转换话题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ところで　         话说回来</span><br><span class="line">話しが変わりますが　说点别的</span><br><span class="line">さて　             那么</span><br><span class="line">それで　           然后</span><br><span class="line">けれども/でも　     不过/但是</span><br><span class="line">それでは/では　     那么（转换下一个话题）</span><br><span class="line">それはそうと　      先不说这个</span><br></pre></td></tr></table></figure><h4 id="～を～にして-以……为……"><a href="#～を～にして-以……为……" class="headerlink" title="～を～にして　以……为……"></a>～を～にして　以……为……</h4><ol><li>～をきっかけにして 以……为契机</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：コンテストで最高賞を受賞したのをきっかけにして，売れるようになりました。</span><br><span class="line">译：再一次竞赛后得到最高奖为契机，变得开始畅销。</span><br></pre></td></tr></table></figure><ol start="2"><li>～を手がかりにして 以……为线索</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：犯人が残したナイフを手がかりにして，事件を解決した。</span><br><span class="line">译：以犯人留下的小刀为线索，将事件解决了。</span><br></pre></td></tr></table></figure><ol start="3"><li>～を頼りにして　根据……</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：李さんが書いてくれた地図を頼りにして，美術館を探した。</span><br><span class="line">译：我根据李桑画的地图找到了美术馆。</span><br></pre></td></tr></table></figure><h4 id="～ということからきた～-～に由来した～-由此而来的，源于"><a href="#～ということからきた～-～に由来した～-由此而来的，源于" class="headerlink" title="～ということからきた～/～に由来した～　由此而来的，源于"></a>～ということからきた～/～に由来した～　由此而来的，源于</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：相撲でぐらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。</span><br><span class="line">译：相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。</span><br><span class="line"></span><br><span class="line">例：『天ぷら』はボルトガル語の”tempera”に由来した言葉です。</span><br><span class="line">译：『天妇罗』的由来时葡萄牙语的“tempera”一词。</span><br></pre></td></tr></table></figure><h4 id="～のは間違いない-一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用"><a href="#～のは間違いない-一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用" class="headerlink" title="～のは間違いない　一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用"></a>～のは間違いない　一定，确信不疑的推断，不能和きっと，多分这样的词语一起使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：中国の体操選手がオリンピックで優勝するのは間違いない。</span><br><span class="line">译：中国的体操选手一定会在奥林匹克上获胜。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：～に違いない/～に相違ない（书面） 能和 <strong>きっと 多分</strong> 这样的词语一起使用 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：このガイドブックは内容が豊富で面白い。きっと売れるに違いない。</span><br><span class="line">译：这本指南的内容丰富有趣。一定买的很好。</span><br><span class="line"></span><br><span class="line">例：彼は十分な休みを取っていなかったに相違ない。</span><br><span class="line">译：他一定没有得到充分的休息。</span><br></pre></td></tr></table></figure><h4 id="～という点から-で-从……方面来"><a href="#～という点から-で-从……方面来" class="headerlink" title="～という点から/で　从……方面来"></a>～という点から/で　从……方面来</h4><ol><li>という点から分類する　从……方面来分类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語の単語を，元の言葉は何かという点から分類すると，……</span><br><span class="line">译：日语的单词是以它原来的语言是什么这一点来分类的。</span><br></pre></td></tr></table></figure><ol start="2"><li>という点から判断する 从……方面来判断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いろいろな証拠という点から判断するんですが，彼は犯人です。</span><br><span class="line">译：各种各样的证据判断出，他是犯人。</span><br></pre></td></tr></table></figure><ol start="3"><li>という点で　依据……性质来判断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：遅くまで開いているという点で，あの店は便利です。</span><br><span class="line">译：营业到很晚这一点来看，那家店很便利。</span><br></pre></td></tr></table></figure><h4 id="～を中心とした～-以……为中心"><a href="#～を中心とした～-以……为中心" class="headerlink" title="～を中心とした～　以……为中心"></a>～を中心とした～　以……为中心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉だ。</span><br><span class="line">译：外来语主要是19世纪以后，以西洋为中心的外国引进的语言。</span><br></pre></td></tr></table></figure><h4 id="AをBという-呼ぶ（书面）-把A叫做B"><a href="#AをBという-呼ぶ（书面）-把A叫做B" class="headerlink" title="AをBという/呼ぶ（书面）　把A叫做B"></a>AをBという/呼ぶ（书面）　把A叫做B</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。</span><br><span class="line">译：另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。</span><br></pre></td></tr></table></figure><h4 id="名词＋の-形容动词-な-简体＋ような（名词）-ように（动词）-像是……，类似……"><a href="#名词＋の-形容动词-な-简体＋ような（名词）-ように（动词）-像是……，类似……" class="headerlink" title="名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……"></a>名词＋の/形容动词+な/简体＋ような（名词）/ように（动词） 像是……，类似……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：東京のような大都市では，家賃が高くて大変だ。</span><br><span class="line">译：像东京这样的大城市，房租太高了太不容易了。</span><br><span class="line"></span><br><span class="line">例：鳥が飛ぶように空を飛んでみたい。</span><br><span class="line">译：想像鸟一样在空中飞行。</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><blockquote><p>～という/いったよう＋な/に　列举多个例子时使用，いった有<strong>没有列举完</strong>的语气，といったような可以省略为といった</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：エビ，イカ，卵といったようなコレステロの高い食品は避けた穂がいい。</span><br><span class="line">译：避免高胆固醇食物，如虾、鱿鱼和鸡蛋。</span><br><span class="line"></span><br><span class="line">例：テレビ，冷蔵庫，布団というように，一人暮らしで必要な物を買った。</span><br><span class="line">译：我买了一个人生活必需的东西，比如电视、冰箱和被褥。</span><br></pre></td></tr></table></figure><blockquote><p>～というふうな/に　用于列举多个具体事例，陈述处理办法或顺序，略显口语</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：北京，上海，広州というふうに，中国の大きな都市を順番に訪問した。</span><br><span class="line">译：我们依次参观了中国的大城市，如北京、上海和广州。</span><br></pre></td></tr></table></figure><h4 id="～に受ける-受欢迎"><a href="#～に受ける-受欢迎" class="headerlink" title="～に受ける　受欢迎"></a>～に受ける　受欢迎</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『金星』という名前は，中国人にうけるでしょう。</span><br><span class="line">译：金星这个名字，中国人会喜欢吧？</span><br></pre></td></tr></table></figure><h4 id="～に基づいた～-以……为根据"><a href="#～に基づいた～-以……为根据" class="headerlink" title="～に基づいた～　以……为根据"></a>～に基づいた～　以……为根据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：音読みとは，昔の中国語の発音に基づいた読み方だ。</span><br><span class="line">译：音读是指以以前中文的发音为根据的读法。</span><br></pre></td></tr></table></figure><h4 id="うち-在……当中"><a href="#うち-在……当中" class="headerlink" title="~うち　在……当中"></a>~うち　在……当中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：若いうち</span><br><span class="line">译：趁着年轻</span><br><span class="line"></span><br><span class="line">例：参加者のうち，賞品がもらえるのは３位までだ。</span><br><span class="line">译：参加人中，能得到奖品的只有三位。</span><br></pre></td></tr></table></figure><h3 id="会话-2"><a href="#会话-2" class="headerlink" title="会话"></a>会话</h3><ul><li>佐藤：ええ，『金星』は星の名前ですが，『金星』というのは，『すばらしい働きをすること』を表します。相撲でくらいの低い力士が横綱に勝った時に『金星をあげる』ということきた言葉です。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">佐藤：『金星』是指星星的名字，这里的金星是指，有着出色工作表现的意思。相扑中水平低的力士战胜最高水平力士时会说取得了金星这样的话。</span><br></pre></td></tr></table></figure><h3 id="课文-4"><a href="#课文-4" class="headerlink" title="课文"></a>课文</h3><p>日本の単語を，元の言葉は何かという点から分類すると，和語，漢語，外来語，混種語の４つに分かることができる。和語はもともと日本語にあった言葉で，漢語は中国から取り入れられた言葉だ。<br>漢語は『音読み』する。音読みとは，昔の中国の発音に基いた読み方だ。外来語は主に１９世紀以降，西洋を中心とした外国から取り入れられた言葉で，普通片仮名でかく。<br>さらに，和語，漢語，外来語のうち，二つ以上を組み合わせてできた言葉を混種語と呼ぶ。『消しゴム』や『マラソン大会』『正月休み』などの言葉だ。</p><blockquote><p>日语的单词是以它原来的语言是什么这一点来分类的。可以分为和语、汉语、外来语、混合语四种。和语是最早日语就有的语言，汉语是从中国引入的语言。<br>汉语是音读。所谓的音读是指以以前中文的发音为根据的读法。外来语主要是19世纪以后，以西洋为中心的外国引进的语言，用普通片假名书写。<br>另外，日语、汉语、外来语中，两种以上能组合起来的语言叫做混合语。诸如“橡皮擦”、“马拉松比赛”和“新年假期”之类的词。</p></blockquote><h2 id="第６課"><a href="#第６課" class="headerlink" title="第６課"></a>第６課</h2><h3 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h3><h4 id="～ちゃって-～じゃって-是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。"><a href="#～ちゃって-～じゃって-是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。" class="headerlink" title="～ちゃって/～じゃって　是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。"></a>～ちゃって/～じゃって　是～てしまって的缩略形式，如果是波音的话使用后者作为缩略形式。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">食べてしまう　ー＞　食べちゃう　ー＞　食べちゃって</span><br><span class="line">飲んでしまう　ー＞　飲んでじゃう　ー＞　飲んでじゃって</span><br><span class="line"></span><br><span class="line">例：打ち合わせが長引いちゃって。</span><br><span class="line">译：会议拖了很长时间。</span><br></pre></td></tr></table></figure><h4 id="気になる-一直想着……-对某人有意思"><a href="#気になる-一直想着……-对某人有意思" class="headerlink" title="気になる 一直想着…… 对某人有意思"></a>気になる 一直想着…… 对某人有意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そんなことを聞くということは，佐藤さん，李さんのことが気になるのかしら。</span><br><span class="line">译：听到这样的话，佐藤桑，你是不是对李桑有意思呀。</span><br></pre></td></tr></table></figure><h4 id="～による-よって-根据……"><a href="#～による-よって-根据……" class="headerlink" title="～による/よって　根据……"></a>～による/よって　根据……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『はし』といっても，その形や材料は国や地域によって違う。</span><br><span class="line">译：虽说都是筷子，它的形态和材料会因为国家和地区而不同。</span><br></pre></td></tr></table></figure><h4 id="簡体＋といっても-虽说……"><a href="#簡体＋といっても-虽说……" class="headerlink" title="簡体＋といっても 虽说……"></a>簡体＋といっても 虽说……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：英語できないといっても，日常会話は十分にできる。</span><br><span class="line">译：虽说英语不行，但是日常对话应该够了。</span><br></pre></td></tr></table></figure><h4 id="簡体／名詞の＋ほか，～も-除了……之外，也……"><a href="#簡体／名詞の＋ほか，～も-除了……之外，也……" class="headerlink" title="簡体／名詞の＋ほか，～も 除了……之外，也……"></a>簡体／名詞の＋ほか，～も 除了……之外，也……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：材料は木や竹，プラスチックのほか，玉や金属の物もある。</span><br><span class="line">译：材料是木头或竹子，除了塑料以外，也有玉和金属的。</span><br></pre></td></tr></table></figure><h4 id="～をしている-状态的表示方法"><a href="#～をしている-状态的表示方法" class="headerlink" title="～をしている 状态的表示方法"></a>～をしている 状态的表示方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：韓国の箸は中国より少し短く，やや平らな形をしている。</span><br><span class="line">译：韩国的筷子比中国的短了一些，也要扁平一些。</span><br></pre></td></tr></table></figure><h4 id="～とされる-和-と考えられている-意思一样：被认为是……"><a href="#～とされる-和-と考えられている-意思一样：被认为是……" class="headerlink" title="～とされる 和 と考えられている 意思一样：被认为是……"></a>～とされる 和 と考えられている 意思一样：被认为是……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本では２月１４日のバレンタインデーは，女性が男性にチョコレートを贈る日だとされる。</span><br><span class="line">译：在日本2月14日情人节被认为是女性向男性赠送巧克力的日子。</span><br></pre></td></tr></table></figure><h4 id="面倒を見る-照顾"><a href="#面倒を見る-照顾" class="headerlink" title="面倒を見る　照顾"></a>面倒を見る　照顾</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：部下の面倒をよくみるし。</span><br><span class="line">译：很照顾自己的下属。</span><br></pre></td></tr></table></figure><h3 id="会话-3"><a href="#会话-3" class="headerlink" title="会话"></a>会话</h3><ul><li>中井さん：うん。明るくて，仕事熱心な人だっていったよ。部下の面倒をよく見るし，優しいし，まさに理想的な上司です。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中井桑：是的。人很开朗，对工作也很热心的人呢。对下属也很照顾，人也温柔，简直是理想的上司呢。</span><br></pre></td></tr></table></figure><h3 id="课文-5"><a href="#课文-5" class="headerlink" title="课文"></a>课文</h3><p>『はし』といっても，その形や材料は国や地域によって違う。中国の箸は長くて，先端が丸太さがあまり変わらない。材料は木や竹，プラスチックのほか，玉や金属の物もある。<br>韓国の箸は中国より少し短く，やや平らな形をしている。ステンレスなど，金属の物が一般的だ。<br>日本の箸は韓国の物に比べてさらに短く，先のほうは細くなっていて，尖っている。材質は木や竹が多く，漆が塗られていることがある。</p><blockquote><p>虽说都是筷子，它的形态和材料会因为国家和地区而不同。中国的筷子比较长，筷子前端的圆度没怎么变化。材料是木头或竹子，除了塑料以外，也有玉和金属的。<br>韩国的筷子比中国的短了一些，也要扁平一些。一般是不锈钢之类的金属。<br>日本的筷子相比韩国要短一些，前者很细很尖。材质大多数是木头或竹子，也有在表面涂漆的。</p></blockquote><h2 id="第７課"><a href="#第７課" class="headerlink" title="第７課"></a>第７課</h2><h3 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h3><h4 id="簡体＋参考にする-参考になる-把……作为参考-有参考价值"><a href="#簡体＋参考にする-参考になる-把……作为参考-有参考价值" class="headerlink" title="簡体＋参考にする/参考になる 把……作为参考/有参考价值"></a>簡体＋参考にする/参考になる 把……作为参考/有参考价值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：『燕醸造のCMを参考にする』と書いてあるけど，これはどいう意味？</span><br><span class="line">译：上面写着『燕牌啤酒的广告有参考价值』，这是什么意思呢？</span><br><span class="line"></span><br><span class="line">例：このCMは，きっと参考になるだろうと思います。</span><br><span class="line">译：这个广告一定有参考价值。</span><br></pre></td></tr></table></figure><h4 id="名詞の＋うえで-这……方面"><a href="#名詞の＋うえで-这……方面" class="headerlink" title="名詞の＋うえで 这……方面"></a>名詞の＋うえで 这……方面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ただし，仕事のうえでのメールや目上の人に送る場合は，いくつか気をつけなければならないことがある。</span><br><span class="line">译：然而工作上的邮件和发送给上级的场合下，有一些必须注意事项。</span><br></pre></td></tr></table></figure><h4 id="名词-さえ～ば，～-只要……就……"><a href="#名词-さえ～ば，～-只要……就……" class="headerlink" title="名词+さえ～ば，～ 只要……就……"></a>名词+さえ～ば，～ 只要……就……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お金と時間さえあれば，毎日演劇を見に行きたい。</span><br><span class="line">译：只要有钱和时间，每天都想去剧院。</span><br></pre></td></tr></table></figure><h4 id="～などという-这……之类的"><a href="#～などという-这……之类的" class="headerlink" title="～などという 这……之类的"></a>～などという 这……之类的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：『こんにちは』『はじめまして』などという，メールの内容の分からない表現は避ける。</span><br><span class="line">译：邮件内容要避免『你好』『初次见面』之类的无法理解内容的表达方式。</span><br></pre></td></tr></table></figure><h4 id="～ごとに-表示每隔……（间隔）"><a href="#～ごとに-表示每隔……（间隔）" class="headerlink" title="～ごとに　表示每隔……（间隔）"></a>～ごとに　表示每隔……（间隔）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：１年ごとに，売り上げの目標作って，営業活動を頑張った。</span><br><span class="line">译：每年都会指定销售目标，努力开展营业活动。</span><br></pre></td></tr></table></figure><h3 id="课文-6"><a href="#课文-6" class="headerlink" title="课文"></a>课文</h3><p>件名を描く時は，用件を明確にする</p><p>宛て先と自分の名前を忘れずに入れる</p><p>用件は簡潔にする</p><p>最後に署名を入れる</p><blockquote><p>描述主题时，用词要明确<br>不要忘记写收件人和自己的名字<br>用词要简洁<br>最后要署上你的名字</p></blockquote><h2 id="第８課"><a href="#第８課" class="headerlink" title="第８課"></a>第８課</h2><h3 id="文法-7"><a href="#文法-7" class="headerlink" title="文法"></a>文法</h3><h4 id="だけ-仅仅"><a href="#だけ-仅仅" class="headerlink" title="だけ　仅仅"></a>だけ　仅仅</h4><ol><li>だけで　少量的事情或者事物就能引发后项结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと見ただけで，本物だとわかります。</span><br><span class="line">译：仅仅只是看了一眼，就知道是真的。</span><br></pre></td></tr></table></figure><ol start="2"><li>だけだ／だけではない　仅此/不仅</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そのだけです。</span><br><span class="line">译：仅此而已。</span><br><span class="line"></span><br><span class="line">例：中井さんは事件あった場所を知っているだけだ。</span><br><span class="line">译：田中桑仅仅只是知道发生时间的场所。</span><br></pre></td></tr></table></figure><ol start="3"><li>だけではすまない／だけですむ　仅仅这样是不行的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：課長に報告したら，注意されるだけではさまない。</span><br><span class="line">译：向课长报告的话，仅仅是注意是不行的。</span><br></pre></td></tr></table></figure><h4 id="～代わりに／～かわって／～に代わる-……被代替……"><a href="#～代わりに／～かわって／～に代わる-……被代替……" class="headerlink" title="～代わりに／～かわって／～に代わる　……被代替……"></a>～代わりに／～かわって／～に代わる　……被代替……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：相手は丼を使う代わりに紙コップを使い，その中に砕いたインスタントラーメンを入れる，お湯を注いで，食べ始めた。</span><br><span class="line">译：对方使用纸杯代替碗，在纸杯中放入碎的方便面，再放入开水，就可以开始吃了。</span><br><span class="line"></span><br><span class="line">例：手紙の代わりに電子メールをうちます。</span><br><span class="line">译：发送电子邮件代替信件。</span><br><span class="line"></span><br><span class="line">例：父に代わって長男がご挨拶に伺います。</span><br><span class="line">译：长子代替父亲前来问候。</span><br><span class="line"></span><br><span class="line">例：丼に代わる新しい容器が必要だ。</span><br><span class="line">译：使用新容器代替是有必要的。</span><br></pre></td></tr></table></figure><h4 id="～（ら）れるようにしなければいけない-努力做到"><a href="#～（ら）れるようにしなければいけない-努力做到" class="headerlink" title="～（ら）れるようにしなければいけない　努力做到"></a>～（ら）れるようにしなければいけない　努力做到</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：免許証はいつでも見せられるようにしなければいけない。</span><br><span class="line">译：驾照无论何时都需要能看到。</span><br></pre></td></tr></table></figure><h4 id="～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果"><a href="#～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果" class="headerlink" title="～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果"></a>～た＋すえ（好的结果）／あげく（不好的结果）＋【に】历经怎样的艰辛，后句描述结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：何度も失敗した末に，ようやく開発に成功した。</span><br><span class="line">译：经历无数次失败，最终成功开发出来。</span><br><span class="line"></span><br><span class="line">例：苦労したあげく，結局失敗した。</span><br><span class="line">译：辛苦的工作到最后还是失败了。</span><br></pre></td></tr></table></figure><h3 id="会話"><a href="#会話" class="headerlink" title="会話"></a>会話</h3><ul><li>王：はい。商品のPRだけじゃなくて，日本の文化を紹介するコーナーを作ってはどうかと考えています。日本の食べ物とか若者の意識とかを紹介するのも面白いとおもいます。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">王：是的。这不仅是商品的提案，我想做一个介绍日本文化的栏目。介绍日本的饮食什么的，年轻人的想法什么的都很有趣。</span><br></pre></td></tr></table></figure><h3 id="课文-7"><a href="#课文-7" class="headerlink" title="课文"></a>课文</h3><p>しかし，開発は簡単ではなかった。容器の材料は，ガラス，紙，プラスチック，金属，当時考えられるだけの物が集められた。様々な工夫のすえ，『発泡スチロール』が採用された。容器の形についても試作が繰り返された。片手を持てて，手から滑り落ちない形を理想として，現在の形が生まれた。</p><blockquote><p>然而，开发不是这么简单的。容器的材料有不锈钢、纸、塑料、金属，这些都是当时能想到的汇聚起来的东西。通过各种各样的方式方法，最终采用了泡沫塑料。关于容器的形状也多次尝试制作。以单手就能拿起，不容易从手中滑落为理想，诞生了现在的形状。</p></blockquote><h1 id="単元-2"><a href="#単元-2" class="headerlink" title="単元"></a>単元</h1><h2 id="第９課"><a href="#第９課" class="headerlink" title="第９課"></a>第９課</h2><h3 id="文法-8"><a href="#文法-8" class="headerlink" title="文法"></a>文法</h3><h4 id="自动词-てある-人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态"><a href="#自动词-てある-人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态" class="headerlink" title="自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态"></a>自动词 + てある 人为状态持续着，强调说话人或某人的行为后的结果，对象变成了某种状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：「王風」という名札が付けてあります。</span><br><span class="line">译：上面挂有【王风】名字的牌子。</span><br><span class="line"></span><br><span class="line">例：玄関の電気がつけてあります。</span><br><span class="line">译：玄关的灯开着。</span><br></pre></td></tr></table></figure><h4 id="他动词-ている-自然状态持续着"><a href="#他动词-ている-自然状态持续着" class="headerlink" title="他动词 + ている 自然状态持续着"></a>他动词 + ている 自然状态持续着</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：窓が開けています。</span><br><span class="line">译：窗户开着。</span><br><span class="line"></span><br><span class="line">例：窓が開けてあります。</span><br><span class="line">译：窗户打开着。</span><br></pre></td></tr></table></figure><h4 id="自动词-ておく-有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。"><a href="#自动词-ておく-有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。" class="headerlink" title="自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。"></a>自动词 + ておく 有意做某事，强调行为本身，而没有状态结果。不能用が提示动作对象，不能用于请求。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：ファイルは机の上に置いておきます。</span><br><span class="line">译：我把文件反正桌子上。</span><br><span class="line"></span><br><span class="line">例：朝起きられるように、時計を6時にセットしておく。</span><br><span class="line">译：为了能早起，我定了6点的闹钟。</span><br></pre></td></tr></table></figure><h4 id="名词-どおり-与～一样；按照～那样；预想；预计"><a href="#名词-どおり-与～一样；按照～那样；预想；预计" class="headerlink" title="名词 + どおり 与～一样；按照～那样；预想；预计"></a>名词 + どおり 与～一样；按照～那样；预想；预计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：予定通り17時30分に到着いたしましたが…</span><br><span class="line">译：和预计的一样17点30分到达了……</span><br><span class="line"></span><br><span class="line">例：田中さんは、希望通り大学院に進学しました。</span><br><span class="line">译：田中如愿升入研究生院。</span><br></pre></td></tr></table></figure><h4 id="後ほど；後（のち）で；あとで-前者更有礼貌"><a href="#後ほど；後（のち）で；あとで-前者更有礼貌" class="headerlink" title="後ほど；後（のち）で；あとで 前者更有礼貌"></a>後ほど；後（のち）で；あとで 前者更有礼貌</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：後ほど，お泊まりのホテルに届けいたします。</span><br><span class="line">译：稍后送到您住宿的酒店。</span><br><span class="line"></span><br><span class="line">例：詳細については後ほどご報告いたします。</span><br><span class="line">译：详细情况稍后汇报给您。</span><br></pre></td></tr></table></figure><blockquote><p>另外还有 先ほど</p></blockquote><h3 id="会话-4"><a href="#会话-4" class="headerlink" title="会话"></a>会话</h3><ul><li><p>王さん：ちょっと，いたい，いつまでも待ってばいいんですか。もう６時半ですよ。</p></li><li><p>手荷物係：申し訳ございません。ただ今お調べしております。もう少しお待ちいただけませんか。</p></li><li><p>王さん：そんな，困りますよ。ロビーで同僚が待っているんです。早くしてもらえませんか。</p></li><li><p>手荷物係：本当に申し訳ございません。後ほど，お泊まりのホテルに届けいたします。よろしいでしょうか。</p></li><li><p>王さん：仕方ないですね。できるだけ早く届けてくださいよ。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">王桑：喂，究竟要让我等到多久才好呀？已经6点半了呀！</span><br><span class="line">行李员：真的十分抱歉！但是现在还在调查中，请在稍等一下可以吗？</span><br><span class="line"></span><br><span class="line">王桑：怎么会这样，太麻烦了。前厅还有同事在等着我。能尽快找到还给我吗？</span><br><span class="line">行李员：真的非常抱歉，稍后送到您住宿的酒店，这样您觉得可以吗？</span><br><span class="line"></span><br><span class="line">王桑：只好这样了。快点送过来呀！</span><br></pre></td></tr></table></figure><h3 id="课文-8"><a href="#课文-8" class="headerlink" title="课文"></a>课文</h3><p>4月1日17時20分，憧れのローマに到着。荷物を受け取って，入国。旅行社の人が迎えに来ているはずだが，見つからない。もし来なかったらと思い，不安になった時，背の高い男性が，にこにこしながら近付いてきて何か言う。誰かと思ったら，我々を迎えに来たガイドさんだった。</p><blockquote><p>4月1日17点20分，憧憬的罗马到了。取到了托运的行李，入国。因该有旅行社的人来接我们，但是没有看见。正在想着如果没有来的话怎么办，感到不安的时候，有个背高高的男性笑眯眯的走过来说着什么。我正在想着这是谁，原来是来迎接我们的导游。</p></blockquote><h2 id="第１０課"><a href="#第１０課" class="headerlink" title="第１０課"></a>第１０課</h2><h3 id="文法-9"><a href="#文法-9" class="headerlink" title="文法"></a>文法</h3><h4 id="よう（更为正式）／ように-目的，为了……"><a href="#よう（更为正式）／ように-目的，为了……" class="headerlink" title="よう（更为正式）／ように　目的，为了……"></a>よう（更为正式）／ように　目的，为了……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：できるだけたくさんの取材ができるよう予定を立てました。</span><br><span class="line">译：为了尽可能多的采访，我们定了这样的行程。</span><br><span class="line"></span><br><span class="line">例：早く病気がなおるよう、安静にしていた。</span><br><span class="line">译：为了病能早点好，静养了一段时间。</span><br></pre></td></tr></table></figure><h4 id="～による／よって"><a href="#～による／よって" class="headerlink" title="～による／よって"></a>～による／よって</h4><h5 id="被动中提示动作的主体"><a href="#被动中提示动作的主体" class="headerlink" title="被动中提示动作的主体."></a>被动中提示动作的主体.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このレストランは，有名なデザイナーによって設計された。</span><br><span class="line">译：这个饭店是有名的设计师设计的。</span><br></pre></td></tr></table></figure><h5 id="根据，依据"><a href="#根据，依据" class="headerlink" title="根据，依据"></a>根据，依据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：林さんが行くかどうかによって，私もどうするかきめます。</span><br><span class="line">译：小林去不去决定了我怎么完成。</span><br></pre></td></tr></table></figure><h5 id="方式，方法"><a href="#方式，方法" class="headerlink" title="方式，方法"></a>方式，方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この薬の効果は，多くの実験によって確認されている。</span><br><span class="line">译：这个药的效果是经过了多次实验才确认的。</span><br></pre></td></tr></table></figure><h4 id="～になります-代替です／だ，语气更加的含蓄，委婉。"><a href="#～になります-代替です／だ，语气更加的含蓄，委婉。" class="headerlink" title="～になります　代替です／だ，语气更加的含蓄，委婉。"></a>～になります　代替です／だ，语气更加的含蓄，委婉。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お１人様１６０００円になりますが，よろしいですか。</span><br><span class="line">译：一个人16000日元，您觉得可以吗？</span><br></pre></td></tr></table></figure><h3 id="课文-9"><a href="#课文-9" class="headerlink" title="课文"></a>课文</h3><p>温泉地では，お客を集めるための工夫をしている。例えば，宿泊する人以外がホテルや旅館の入浴施設を有料で使用できる「日帰り温泉」がある。<br>「入浴＋昼ご飯」や，「入浴＋部屋で休憩」など，宿泊する時間のない人のためにさまざまなプランもある。最近では「日帰り入浴」専用の施設も増えてきている。</p><p>また銭湯といって，安い値段で入浴できる施設もある。銭湯とは，多くの家にお風呂がなかったころに作られた入浴施設のことだ。現在ではその数も少なくなってきているが，最近では，「スーパー銭湯」が出てきて人気を集めている。普通の銭湯より値段は高いが，いろいろな種類のお風呂やマッサージ，エステなどがあり，1日中たのしめる。「スーパー銭湯」は忙しい人たちのちょっとした癒しの場になっているのだ。</p><blockquote><p>泡温泉的地方为了能揽客下了很大的功夫。比如，有住宿以外的人可以通过付费使用旅馆的入浴设施【日归温泉】。还有【温泉+晚饭】和【温泉+房间休息】等等，没有住宿时间的人也有各种各样的方案。最近【日归温泉】专用设置也增加了许多。</p></blockquote><blockquote><p>另外还有钱汤，价格实惠的洗浴设施也有。所谓钱汤是指，以前许多家里没有可以泡温泉的地方，而建立的公用洗浴设施。现在这样的设施在慢慢减少，最近出现了很有人气的超级钱汤。比普通的钱汤价格稍微贵一点，但是有各种各样的种类，洗浴，按摩以及美容，可以享受一整天。超级钱汤正在成为给那些忙碌人难得消除身心疲惫的场所。</p></blockquote><h2 id="第１１課"><a href="#第１１課" class="headerlink" title="第１１課"></a>第１１課</h2><h3 id="文法-10"><a href="#文法-10" class="headerlink" title="文法"></a>文法</h3><h4 id="避免断定的说法"><a href="#避免断定的说法" class="headerlink" title="避免断定的说法"></a>避免断定的说法</h4><ul><li>难道不是吗？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">书面语：</span><br><span class="line"></span><br><span class="line">ではないか</span><br><span class="line">ではないだろうか</span><br><span class="line">ではないでしょうか。</span><br><span class="line"></span><br><span class="line">口语：</span><br><span class="line"></span><br><span class="line">ではありませんか</span><br><span class="line">ではないですか</span><br><span class="line">じゃありませんか</span><br><span class="line">じゃないですか</span><br><span class="line">じゃないか</span><br></pre></td></tr></table></figure><ul><li>～きがする　好像，对过去的某事尽管记忆模糊，但是认为是那样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：その時は，賛成した気がします。</span><br><span class="line">译：那个时候我好像是赞成的。</span><br></pre></td></tr></table></figure><ul><li>～と思う／～と思える／～と思われる　认为，～と思える／～と思われる 有自然而然地这样认为，而非专断的意见</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：彼女の言っていることは事実だと思う。</span><br><span class="line">译：我觉得她说的话是事实。</span><br><span class="line"></span><br><span class="line">例：私はこの方針が正しいと思えません。</span><br><span class="line">译：我不觉得这个方针是正确的。</span><br></pre></td></tr></table></figure><h4 id="～はずです-应该是……，基于推论或记忆认为理所应当成立的事情"><a href="#～はずです-应该是……，基于推论或记忆认为理所应当成立的事情" class="headerlink" title="～はずです　应该是……，基于推论或记忆认为理所应当成立的事情"></a>～はずです　应该是……，基于推论或记忆认为理所应当成立的事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は今年定年のはずです。</span><br><span class="line">译：他今年应该退休了。</span><br></pre></td></tr></table></figure><h4 id="～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。"><a href="#～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。" class="headerlink" title="～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。"></a>～ようだ（主观）／～らしい（客观）可能，大概的意思，根据某种依据做出的判断。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あの雲の様子から見て，明日は雨のようだ。</span><br><span class="line">译：从那个云的样子来看，明天可能要下雨。</span><br><span class="line"></span><br><span class="line">例：天気予報によると，今年の冬は暖かいらしい。</span><br><span class="line">译：天气预报说今年冬天可能会比较暖和。</span><br></pre></td></tr></table></figure><h4 id="～のところ-……的时刻，有包含这个的后续可能会发生某种变化的语气"><a href="#～のところ-……的时刻，有包含这个的后续可能会发生某种变化的语气" class="headerlink" title="～のところ　……的时刻，有包含这个的后续可能会发生某种变化的语气"></a>～のところ　……的时刻，有包含这个的后续可能会发生某种变化的语气</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：興行成績は現在のところ第２位ですが，来週はトップになる見込みです。</span><br><span class="line">译：票房成绩目前还是第二名，但下周有可能登顶。</span><br></pre></td></tr></table></figure><h4 id="～見込みです-很可能，有希望的意思"><a href="#～見込みです-很可能，有希望的意思" class="headerlink" title="～見込みです　很可能，有希望的意思"></a>～見込みです　很可能，有希望的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：来年の業績はかなり良い見込みです。</span><br><span class="line">译：明年的业已有希望相当好。</span><br></pre></td></tr></table></figure><h4 id="形容词去掉い＋まる（自动词：变得）／める（他动词：使……）-古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语"><a href="#形容词去掉い＋まる（自动词：变得）／める（他动词：使……）-古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语" class="headerlink" title="形容词去掉い＋まる（自动词：变得）／める（他动词：使……）　古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语"></a>形容词去掉い＋まる（自动词：变得）／める（他动词：使……）　古日语的形式，将形容词动词化，适用于高い，広い，強い，弱い等词语</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そうそう，日本映画の人気も高まっていますよ。</span><br><span class="line">译：是的呢，日本电影的人气也变得很高。</span><br><span class="line"></span><br><span class="line">例：社員一人一人の節約の意識を，もう少し高めないといけない。</span><br><span class="line">译：必须提高每个社员的节约意识。</span><br></pre></td></tr></table></figure><h4 id="～に夢中になる-被什么东西吸引而聚精会神投入其中的状态"><a href="#～に夢中になる-被什么东西吸引而聚精会神投入其中的状态" class="headerlink" title="～に夢中になる　被什么东西吸引而聚精会神投入其中的状态"></a>～に夢中になる　被什么东西吸引而聚精会神投入其中的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：昔の子供は学校が終われると，外で遊ぶに夢中になったものです。</span><br><span class="line">译：以前的小孩放学后，会沉迷在外面玩。</span><br></pre></td></tr></table></figure><blockquote><p>知识拓展</p></blockquote><ul><li>夢中になって 专心致志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。</span><br><span class="line">译：来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。</span><br></pre></td></tr></table></figure><ul><li>夢中で/夢中だ　拼命的做</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：田中さんは今日仕事に夢中だから，しばらく結婚はしないでしょう。</span><br><span class="line">译：看田中桑今天拼命的工作，最近一段时间应该不会结婚吧？</span><br><span class="line"></span><br><span class="line">例：大きな犬に追いかけられて，夢中で逃げだ。</span><br><span class="line">译：被大型犬着，拼命地逃跑。</span><br></pre></td></tr></table></figure><h4 id="～うえに，～-不仅……而且……"><a href="#～うえに，～-不仅……而且……" class="headerlink" title="～うえに，～　不仅……而且……"></a>～うえに，～　不仅……而且……</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日は気温が低いうえに，風が強いので，とても寒く感じる。</span><br><span class="line">译：今天不仅气温低风也很大，感觉非常冷啊。</span><br></pre></td></tr></table></figure><h4 id="～とともに，～-随着前向的变化，后向也因此伴随着变化，也有同时进行的意思"><a href="#～とともに，～-随着前向的变化，后向也因此伴随着变化，也有同时进行的意思" class="headerlink" title="～とともに，～　随着前向的变化，后向也因此伴随着变化，也有同时进行的意思"></a>～とともに，～　随着前向的变化，后向也因此伴随着变化，也有同时进行的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：その後，デジタル技術の開発が進むとともに，高画質のいきいきとした映像が生み出されるようになった。</span><br><span class="line">译：之后，随着数字技术的开发，产生了高画质的生动影像。</span><br><span class="line"></span><br><span class="line">例：原因を調査するとともに，再発を防ぐための努力もしていかなければならない。</span><br><span class="line">译：随着原因的调查，为了防止再次发生而不得不努力。</span><br></pre></td></tr></table></figure><h3 id="会話-1"><a href="#会話-1" class="headerlink" title="会話"></a>会話</h3><ul><li><p>担当者：ええ，若者は日本のものと外国のものを区別していないような気がします。彼らは，映画にしても音楽にしても，いいものならすぐに受け入れます。</p></li><li><p>王：そうですね。中国の若者も同じだという気がします。じゃあ，彼らの心をつかむには，どうすればいいんでしょうか。</p></li><li><p>担当者：うーん…，難しい質問ですね。やはり本当にいいものを作ることではないでしょうか。</p></li><li><p>王：本当にいいもの，ですか？</p></li><li><p>担当者：ええ。今の若者は，テレビCMより，同時代の人の口コミを信じます。映像でも音楽でも，本当にいいものを提供すれば，口コミで広がっていくはずです。</p></li><li><p>王：なるほど。ありがとうございます。とても参考になりました。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">担当者：是的，我觉得年轻人好像没有区分日本的东西和外国的东西。他们不管是电影还是音乐，只要是觉得好的马上就会接受。</span><br><span class="line">王：是这样呢，中国的年轻人好像也是这样。那么怎么做才能抓住他们的心呢？</span><br><span class="line"></span><br><span class="line">担当者：嗯，很难得问题呀。果然还是要真正做出好的东西对吧？</span><br><span class="line">王：真的好的东西，是吗？</span><br><span class="line"></span><br><span class="line">担当者：是的。现今的年轻人比起电视频道更相信同龄人的口碑。不管是电影还是音乐，提供真正好的东西的话，口碑应该也会越来越好。</span><br><span class="line">王：原来如此，谢谢。非常有参考价值。</span><br></pre></td></tr></table></figure><h3 id="课文-10"><a href="#课文-10" class="headerlink" title="课文"></a>课文</h3><p>日本に来た外国人は，電車などでサラリーマンが夢中になって漫画を読んでいる光景を見て，驚くという。日本の漫画は，子供向けから成人向けまで，対象の年代ごとにさまざまな種類がある。</p><p>会社員の生活や，経済に関するものなど，大人にしか楽しめない内容の漫画が多くある。一方，子供向けの漫画でも，大人が楽しめるものも多い。近年，中国では「クレヨンしんちゃん」「ドラえもん」「ちびまる子ちゃん」などの漫画が子供だけでなく大人からも人気を集めている。</p><blockquote><p>来日的外国人会在电车等地方看到上班族再专心致志地看漫画的情景而感到惊讶。日本的漫画从孩子到成人，会因为看漫画对象的年代不同有着各种各样的分类。</p></blockquote><blockquote><p>公司职员的生活或者经济相关的漫画等等，有很多精彩的内容只有大人才能看的漫画有很多。另一方面，也有很多小孩子和大人都能看得的漫画。近几年，在中国像【蜡笔小新】、【哆啦A梦】【樱桃小丸子】等等这样的漫画不仅小孩子喜欢，也很受大人们的欢迎。</p></blockquote><h2 id="第１２課"><a href="#第１２課" class="headerlink" title="第１２課"></a>第１２課</h2><h3 id="文法-11"><a href="#文法-11" class="headerlink" title="文法"></a>文法</h3><h4 id="耳にする／目にする-表示没主动去看听，而是被动传入"><a href="#耳にする／目にする-表示没主动去看听，而是被动传入" class="headerlink" title="耳にする／目にする　表示没主动去看听，而是被动传入"></a>耳にする／目にする　表示没主动去看听，而是被动传入</h4><ul><li>最も大阪の方言が聞けると思っていたんですが，あまり耳にしませんでした。</li><li>携帯電話の普及で，最近公衆電話を目にしなくなりました。</li></ul><h4 id="～せい／せいで／せいか-事情的原因，原因不明确时用せいか"><a href="#～せい／せいで／せいか-事情的原因，原因不明确时用せいか" class="headerlink" title="～せい／せいで／せいか　事情的原因，原因不明确时用せいか"></a>～せい／せいで／せいか　事情的原因，原因不明确时用せいか</h4><ul><li>風邪を引いているせいか，今日は仕事に集中できない。</li><li>計画が失敗したのは，私のせいだ。</li></ul><h4 id="～おかけで／～おかけか-多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか"><a href="#～おかけで／～おかけか-多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか" class="headerlink" title="～おかけで／～おかけか　多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか"></a>～おかけで／～おかけか　多亏了，用于陈述中性的原因或者理由，原因不明确时用おかけか</h4><ul><li>林さんのおかけで，助かりました。</li><li>薬を飲んだおかけか，1日で熱が下がりました。</li></ul><h4 id="～です／だけれど，～-虽然……，但是……，意思和が，だけ一样的但是更有礼貌"><a href="#～です／だけれど，～-虽然……，但是……，意思和が，だけ一样的但是更有礼貌" class="headerlink" title="～です／だけれど，～　虽然……，但是……，意思和が，だけ一样的但是更有礼貌"></a>～です／だけれど，～　虽然……，但是……，意思和が，だけ一样的但是更有礼貌</h4><ul><li>せっかくですけれど，今日は遠慮しておきます。</li></ul><h4 id="～においても-对于，在……方面，就……而言"><a href="#～においても-对于，在……方面，就……而言" class="headerlink" title="～においても　对于，在……方面，就……而言"></a>～においても　对于，在……方面，就……而言</h4><ul><li>日本語においても，発音，文法，語彙など，地域による言葉の違いがある。</li></ul><h4 id="～ことになる-也就是说，变得……会这样"><a href="#～ことになる-也就是说，变得……会这样" class="headerlink" title="～ことになる　也就是说，变得……会这样"></a>～ことになる　也就是说，变得……会这样</h4><ul><li>参加者は男性３名，女性２名，５名ということになる。</li></ul><h3 id="课文-11"><a href="#课文-11" class="headerlink" title="课文"></a>课文</h3><p>中国は多民族国家で，民族によって使用する言語が異なっている。また中国語も一つではなく，かなりの数の方言が存在する。それぞれの方言は発音も文法も語彙も大きく違っている。</p><p>日本語においても，発音，文法，語彙など，地域による言葉の違いがある。</p><p>まず，発音やアクセントの違いがある。例えば，「はし」という言葉だ。「箸」の「はし」，「橋」の「はし」。ほかにも異なった意味があるが，この二つの意味で考えてみよう。</p><p>方言の違いによってこんな誤解が起きることもある。例えば，東北地方に「なげる」という方言がある。これは「捨てる」という意味だが，方言を知らない人が「これをなげす」と言われて，「投げる」だと解釈して，ごみを投げ返して怒られたという話がある。また，関西地方には「ほかす」という方言がある。やはり「捨てる」という意味が，これを「保管して」と聞き間違えて，要らないものを大切に保管してしまったという話もある。</p><h1 id="単元-3"><a href="#単元-3" class="headerlink" title="単元"></a>単元</h1><h2 id="第１３課"><a href="#第１３課" class="headerlink" title="第１３課"></a>第１３課</h2><h3 id="文法-12"><a href="#文法-12" class="headerlink" title="文法"></a>文法</h3><h4 id="折り入って～-诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫"><a href="#折り入って～-诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫" class="headerlink" title="折り入って～　诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫"></a>折り入って～　诚心诚意地将自己关系重大的恳求或秘密说出来之前的铺垫</h4><ul><li>折り入ってお話したいのですが，今よろしいでしょうか。</li></ul><h4 id="もしかして／もしかすると・もしかしたら-该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句"><a href="#もしかして／もしかすると・もしかしたら-该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句" class="headerlink" title="もしかして／もしかすると・もしかしたら　该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句"></a>もしかして／もしかすると・もしかしたら　该不会，难道，尽管不能确定但是认为应该是那样，后两者很少用于疑问句</h4><ul><li>もしかして，上海の李さんも来るの？</li></ul><h4 id="～ことになりました-决定要……-有受到多种因素的影响后才做出的决定，自然的变成这样的"><a href="#～ことになりました-决定要……-有受到多种因素的影响后才做出的决定，自然的变成这样的" class="headerlink" title="～ことになりました　决定要…… 　有受到多种因素的影响后才做出的决定，自然的变成这样的"></a>～ことになりました　决定要…… 　有受到多种因素的影响后才做出的决定，自然的变成这样的</h4><ul><li>王さんが結婚式に出席してくれことになりました。</li><li>来年の春に結婚することになりました。</li></ul><h4 id="朝着一个方向不断发展，有～ていく的感觉"><a href="#朝着一个方向不断发展，有～ていく的感觉" class="headerlink" title="朝着一个方向不断发展，有～ていく的感觉"></a>朝着一个方向不断发展，有～ていく的感觉</h4><ul><li><p>～一方だ</p><ul><li>世界の人口は増加する一方が，日本の人口は減り始めている。</li><li>前后主语一样时表示同时做某事，可用于接续<ul><li>彼は事故の原因を調べる一方，被害の拡大を防いだ。</li></ul></li><li>前后主语不一样时表示对比，也可以用于接续<ul><li>出生率が下がる一方，平均寿命どんどん長くなっています。</li></ul></li></ul></li><li><p>～ばかりだ</p><ul><li>全是，尽是，光是<ul><li>最近，変な夢ばかり見る。</li><li>彼は週末になると博物館ばかり行っている</li></ul></li><li>朝着一个不好的方向不断发展<ul><li>病気はどんどん悪くなるばかりだ。</li></ul></li></ul></li><li><p>の一途をたどる　书面语</p><ul><li>出生率は減少の一途をたどっている。</li></ul></li></ul><h4 id="AのBにはCがある-AのB的原因之一有C"><a href="#AのBにはCがある-AのB的原因之一有C" class="headerlink" title="AのBにはCがある　AのB的原因之一有C"></a>AのBにはCがある　AのB的原因之一有C</h4><ul><li>事故の原因には整備不良がある。</li><li>「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。</li></ul><h4 id="Aに対する-对于A的……（态度，感情，动作），也有对比的意思"><a href="#Aに対する-对于A的……（态度，感情，动作），也有对比的意思" class="headerlink" title="Aに対する　对于A的……（态度，感情，动作），也有对比的意思"></a>Aに対する　对于A的……（态度，感情，动作），也有对比的意思</h4><ul><li>政府に対する国民の批判が高まっている。</li><li>地球温暖化に対して取り組みは国によってさまざまだ。</li><li>兄はおとなしく内向的なのに対して，弟はとても活発で外向的だ。</li></ul><h3 id="课文-12"><a href="#课文-12" class="headerlink" title="课文"></a>课文</h3><p>「少子化」の背景には，結婚，出産，育児に対する人々の意識の変化がある。例えば，結婚年齢が遅くなる「晩婚化」の傾向は，年々強まっている。結婚時の女性の平均年齢は，1977年には25.0歳であったが，1992年には26.0歳，2004年には27.8歳になった。</p><p>高年齢になると出産を控える傾向が強まり，一人の女性が出産する子供の数を示す「出生率」が下がる。それが少子化の原因に繋がっている。</p><h2 id="第１４課"><a href="#第１４課" class="headerlink" title="第１４課"></a>第１４課</h2><h3 id="文法-13"><a href="#文法-13" class="headerlink" title="文法"></a>文法</h3><h4 id="～を問わず-不论……，书面语"><a href="#～を問わず-不论……，书面语" class="headerlink" title="～を問わず　不论……，书面语"></a>～を問わず　不论……，书面语</h4><ul><li>男女を問わず，黒か濃い紺色，灰色の地味なスーツを指す。</li></ul><h4 id="～て初めて～-只有……才能……"><a href="#～て初めて～-只有……才能……" class="headerlink" title="～て初めて～　只有……才能……"></a>～て初めて～　只有……才能……</h4><ul><li>これらの試験をとっばして初めて内定をもらうことになる 。</li></ul><p>####　少しでも～　尽可能早的……</p><ul><li>少しでもいい席を取れるように，会場の前に朝早くから多くの人が並んでいる。</li></ul><h3 id="课文-13"><a href="#课文-13" class="headerlink" title="课文"></a>课文</h3><p>面接は話す場であり，文を読む場ではない。志望動機や自己PRなど，履歴書に書いたものをそのまま話すのはよくない。</p><p>会社の建物に入り，出るまでが採用試験である。受付での話し方や待合室での態度なども評価の対象になる。</p><p>面接でははじめの印象が大切である。清潔のあるきちんとした服装をすること。</p><h2 id="第１５課"><a href="#第１５課" class="headerlink" title="第１５課"></a>第１５課</h2><h3 id="文法-14"><a href="#文法-14" class="headerlink" title="文法"></a>文法</h3><h4 id="ちっとも／少しも／全然／真く＋～ない-一点也不"><a href="#ちっとも／少しも／全然／真く＋～ない-一点也不" class="headerlink" title="ちっとも／少しも／全然／真く＋～ない　一点也不"></a>ちっとも／少しも／全然／真く＋～ない　一点也不</h4><ul><li>学生の頃と，ちっとも変わってないわね。</li><li>課長は少しも部下の意見を聞いてくれない。</li><li>昨日の夜のことは全然覚えてない。</li><li>山田さんと町子さんが結婚することを真く知らなかった。</li></ul><h4 id="それはそうと-先不说那个，转换话题"><a href="#それはそうと-先不说那个，转换话题" class="headerlink" title="それはそうと　先不说那个，转换话题"></a>それはそうと　先不说那个，转换话题</h4><ul><li>今回は仕事で日本に来たんでしょう。</li></ul><h4 id="決して～ない-绝对不是这样，绝对不这样做"><a href="#決して～ない-绝对不是这样，绝对不这样做" class="headerlink" title="決して～ない　绝对不是这样，绝对不这样做"></a>決して～ない　绝对不是这样，绝对不这样做</h4><ul><li>彼は決して嘘はつきません</li><li>誰にも決してを分からない場所にお金を隠した。</li></ul><h3 id="课文-14"><a href="#课文-14" class="headerlink" title="课文"></a>课文</h3><p>日本の料理には，面白い名前のものがある。例えば，「親子丼」というのは，鶏肉と卵を調理してご飯にのせた料理である。鶏肉と卵は親と子であることからついた名前だ。<br>ほなに，「他人丼」という料理もある。豚肉や牛肉と卵を調理してご飯に載せた料理である。豚肉と卵は「親子」ではなく「他人」だからである。</p><p>では，「キツネうどん」というのはどんな料理だろうか。決して狐の肉が入ったうどんではない。うどんの上に，「油揚げ」という，豆腐を油揚げた物を載せた料理だ。<br>油揚げの色がキツネのような色だからとか，油揚げがキツネの好物だから，という理由でこんな名前が付けられたという。</p><h2 id="第１６課"><a href="#第１６課" class="headerlink" title="第１６課"></a>第１６課</h2><h3 id="文法-15"><a href="#文法-15" class="headerlink" title="文法"></a>文法</h3><h4 id="～ともに-一起做……和一緒に一样的意思"><a href="#～ともに-一起做……和一緒に一样的意思" class="headerlink" title="～ともに　一起做……和一緒に一样的意思"></a>～ともに　一起做……和一緒に一样的意思</h4><ul><li>今までともに助け合って，頑張ってきた。</li></ul><h4 id="～とも-全部，都"><a href="#～とも-全部，都" class="headerlink" title="～とも　全部，都"></a>～とも　全部，都</h4><ul><li>私たち姉妹は５人とも元気です。</li></ul><h4 id="～からといって～とは限らない／ない-虽然说……但也不一定-不"><a href="#～からといって～とは限らない／ない-虽然说……但也不一定-不" class="headerlink" title="～からといって～とは限らない／ない　虽然说……但也不一定/不"></a>～からといって～とは限らない／ない　虽然说……但也不一定/不</h4><ul><li>日本人だからといって，日本の文化に詳しいとは限らない。</li><li>森さんは，お酒を飲まないからといってお酒が嫌いではない。</li></ul><h3 id="会話-2"><a href="#会話-2" class="headerlink" title="会話"></a>会話</h3><p>中国には「白头偕老」という言葉があります。これは「ともに白髪になるまで一緒にいる」いう意味の言葉です。お二人とも，きっとこの言葉通りの幸せな夫婦になられるでしょう。</p><h3 id="课文-15"><a href="#课文-15" class="headerlink" title="课文"></a>课文</h3><p>キリスト教式で結婚式を上げるからといって，キリスト教の信者であるとは限らない。ウエディングドレスが着たいからとか，教会で挙式したいからなど，自分の好みで挙式のスタイルを決める人が多く，宗教で決める人は少数である。ほてるや結婚式場には，挙式の場所が設けられているので，実際に神社や教会へ行く人の数は少ない。さらに，海外で挙式をする人も多くなっている。</p><p>下のグラフは，ある出版社が首都圏の夫婦４００組に対して行ったアンケートの結果を求めたものである。これを見ると，挙式の形式が時代とともに変わってきていることが分かる。１９９４年には「キリスト教式結婚式」が56.6%，「人前結婚式」が5.4%であったのに対して，２００５年では，それぞれ74.4%，12.6%に増えた。一方，伝統的な挙式形式である「神前結婚式」は，２００５年には１９９４年の３分の１まで減少した。このように，結婚式に対する人々の意識は，時代にとともに変化してきている。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之N3文法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-(简敬)语</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E7%AE%80%E6%95%AC-%E8%AF%AD/"/>
    <id>/2024/06/11/日语-简敬-语/</id>
    <published>2024-06-11T03:10:38.000Z</published>
    <updated>2024-06-11T05:18:08.534Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之(简敬)语<br><a id="more"></a></p><h1 id="简体"><a href="#简体" class="headerlink" title="简体"></a>简体</h1><h2 id="变形规则"><a href="#变形规则" class="headerlink" title="变形规则"></a>变形规则</h2><h3 id="名词和形容动词"><a href="#名词和形容动词" class="headerlink" title="名词和形容动词"></a>名词和形容动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：だ，である</span><br><span class="line"></span><br><span class="line">一般否定：ではない、じゃない</span><br><span class="line"></span><br><span class="line">过去时：だった</span><br><span class="line"></span><br><span class="line">过去否定：ではなかった、じゃなかった</span><br></pre></td></tr></table></figure><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：寒い</span><br><span class="line"></span><br><span class="line">一般否定：寒くない</span><br><span class="line"></span><br><span class="line">过去时：寒かった</span><br><span class="line"></span><br><span class="line">过去否定：寒くなかった</span><br></pre></td></tr></table></figure><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般陈述句：字典形</span><br><span class="line"></span><br><span class="line">一般否定：ない形</span><br><span class="line"></span><br><span class="line">过去时：た形</span><br><span class="line"></span><br><span class="line">过去否定：なかった</span><br></pre></td></tr></table></figure><h2 id="活用形"><a href="#活用形" class="headerlink" title="活用形"></a>活用形</h2><h3 id="终止形"><a href="#终止形" class="headerlink" title="终止形"></a>终止形</h3><blockquote><p>终止形即终止句子的形式<br>当名词和形容动词后面有か时可以省略だ</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动词简体</span><br><span class="line"></span><br><span class="line">形容词简体</span><br><span class="line"></span><br><span class="line">形容动词＋だ</span><br><span class="line"></span><br><span class="line">名词＋だ</span><br></pre></td></tr></table></figure><h3 id="连体形"><a href="#连体形" class="headerlink" title="连体形"></a>连体形</h3><blockquote><p>用于修饰名词, 所以连体形没有名词的变形</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动词简体</span><br><span class="line"></span><br><span class="line">形容词简体</span><br><span class="line"></span><br><span class="line">形容动词＋な</span><br></pre></td></tr></table></figure><h3 id="连用形"><a href="#连用形" class="headerlink" title="连用形"></a>连用形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I形: ます形</span><br><span class="line"></span><br><span class="line">II形: て形, た形</span><br></pre></td></tr></table></figure><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h3 id="简体可以修饰名词"><a href="#简体可以修饰名词" class="headerlink" title="简体可以修饰名词"></a>简体可以修饰名词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は四川語を話すことができます。</span><br><span class="line">译：我会说四川话。</span><br></pre></td></tr></table></figure><h3 id="简体＋といいます-引用别人说的话"><a href="#简体＋といいます-引用别人说的话" class="headerlink" title="简体＋といいます　引用别人说的话"></a>简体＋といいます　引用别人说的话</h3><ol><li>直接引用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：寝る前に、『おやしみ』といいます。</span><br><span class="line">译：睡觉之前一般会说“晚安”。</span><br></pre></td></tr></table></figure><ol start="2"><li>间接引用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ミーラさんは『来週東京へ出張する』といいます。</span><br><span class="line">译：米勒说下周要去东京出差。</span><br></pre></td></tr></table></figure><h3 id="动词和形容词简体-形容动词な-名词の＋とき-在……时候，动词简体过去式表示动作之后的情况"><a href="#动词和形容词简体-形容动词な-名词の＋とき-在……时候，动词简体过去式表示动作之后的情况" class="headerlink" title="动词和形容词简体/形容动词な/名词の＋とき　在……时候，动词简体过去式表示动作之后的情况"></a>动词和形容词简体/形容动词な/名词の＋とき　在……时候，动词简体过去式表示动作之后的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：暇なとき、遊びに来ましょうか。</span><br><span class="line">译：闲暇的时候，来玩吧！</span><br><span class="line"></span><br><span class="line">例：国へ帰るとき</span><br><span class="line">译：回国途中时……</span><br><span class="line"></span><br><span class="line">例：国へ帰ったとき</span><br><span class="line">译：回国后……</span><br></pre></td></tr></table></figure><h3 id="字典形＋と……-一怎么样"><a href="#字典形＋と……-一怎么样" class="headerlink" title="字典形＋と…… 一怎么样"></a>字典形＋と…… 一怎么样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：右へ曲がると郵便局があります。</span><br><span class="line">译：一右转就到邮局了。</span><br></pre></td></tr></table></figure><h3 id="简体-名词な＋んですか"><a href="#简体-名词な＋んですか" class="headerlink" title="简体/名词な＋んですか"></a>简体/名词な＋んですか</h3><ol><li>寻求更详细的说明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうして遅れたんですか。</span><br><span class="line">译：为什么迟到了呢？</span><br></pre></td></tr></table></figure><ol start="2"><li>提起话题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：NHKを見学したいんですが、どうしたらいいですか。</span><br><span class="line">译：我想去NHK参观学习，怎做么才好呢？</span><br></pre></td></tr></table></figure><h3 id="终止形＋し＋终止形＋し＋终止形＋「から」"><a href="#终止形＋し＋终止形＋し＋终止形＋「から」" class="headerlink" title="终止形＋し＋终止形＋し＋终止形＋「から」"></a>终止形＋し＋终止形＋し＋终止形＋「から」</h3><ol><li>并列</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ワット先生は熱心だし真面目だし、経験もあります。</span><br><span class="line">译：瓦特老师既热心又认真，而且非常有经验。</span><br></pre></td></tr></table></figure><ol start="2"><li>列举理由，表示轻微的因果关系，暗示还有其他理由</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：駅から近いし、車でも来られるし、この店はとても便利です。</span><br><span class="line">译：离车站又近，坐车也能来，这家店真是便利呀。</span><br></pre></td></tr></table></figure><h3 id="动词字典形-动词ない形＋つもりです-下决心打算做某事"><a href="#动词字典形-动词ない形＋つもりです-下决心打算做某事" class="headerlink" title="动词字典形/动词ない形＋つもりです　下决心打算做某事"></a>动词字典形/动词ない形＋つもりです　下决心打算做某事</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：国へ帰っても柔道を続けるつもりです。</span><br><span class="line">译：即使回国也打算继续柔道。</span><br><span class="line"></span><br><span class="line">例：明日からは煙草を吸わないつもりです。</span><br><span class="line">译：打算从明天开始不再吸烟了。</span><br></pre></td></tr></table></figure><h3 id="动词字典形-名词の＋予定です-预计，预定的计划"><a href="#动词字典形-名词の＋予定です-预计，预定的计划" class="headerlink" title="动词字典形/名词の＋予定です　预计，预定的计划"></a>动词字典形/名词の＋予定です　预计，预定的计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：７月の終わりにドイツへ出張する予定です。</span><br><span class="line">译：预计7月完去德国出差。</span><br><span class="line"></span><br><span class="line">例：旅行は１週間ぐらいの予定です。</span><br><span class="line">译：预计旅行一周左右。</span><br></pre></td></tr></table></figure><h3 id="动词た形-ない形ない＋ほうがいいです。-最好做…-用于给别人提供建议和忠告"><a href="#动词た形-ない形ない＋ほうがいいです。-最好做…-用于给别人提供建议和忠告" class="headerlink" title="动词た形/ない形ない＋ほうがいいです。　最好做… 用于给别人提供建议和忠告"></a>动词た形/ない形ない＋ほうがいいです。　最好做… 用于给别人提供建议和忠告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：毎日運動したほうがいいです。</span><br><span class="line">译：最好每天运动。</span><br></pre></td></tr></table></figure><h3 id="终止形＋でしょう-表示说话人的推测"><a href="#终止形＋でしょう-表示说话人的推测" class="headerlink" title="终止形＋でしょう　表示说话人的推测"></a>终止形＋でしょう　表示说话人的推测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：明日は雨が降るでしょう。</span><br><span class="line">译：明天要下雨吧？</span><br><span class="line"></span><br><span class="line">例：楊さんは合格するでしょうか。</span><br><span class="line">译：杨同学及格了吧？</span><br></pre></td></tr></table></figure><h3 id="终止形＋かもしれません-可能，或许，可以简写为かも"><a href="#终止形＋かもしれません-可能，或许，可以简写为かも" class="headerlink" title="终止形＋かもしれません　可能，或许，可以简写为かも"></a>终止形＋かもしれません　可能，或许，可以简写为かも</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：約束の時間に合わないかもしれません。</span><br><span class="line">译：可能会错过了约定的时间。</span><br></pre></td></tr></table></figure><h3 id="字典形-た形＋とおりに、～-按照……做……"><a href="#字典形-た形＋とおりに、～-按照……做……" class="headerlink" title="字典形/た形＋とおりに、～　按照……做……"></a>字典形/た形＋とおりに、～　按照……做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：私はやるとおりに、やってください。</span><br><span class="line">译：请跟着我做。</span><br><span class="line"></span><br><span class="line">例：みたとおりに、話してください。</span><br><span class="line">译：请按照所看到的那样说。</span><br></pre></td></tr></table></figure><ul><li>拓展：～らしい　推测，传闻，……的样子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あそこにいる人は男らしい。</span><br><span class="line">译：那人像是个男的。</span><br><span class="line"></span><br><span class="line">例：彼はとても男らしい。</span><br><span class="line">译：她非常像一名男性。</span><br></pre></td></tr></table></figure><h3 id="ます形-名词の＋とおりに、～-正如，按照"><a href="#ます形-名词の＋とおりに、～-正如，按照" class="headerlink" title="ます形/名词の＋とおりに、～　正如，按照"></a>ます形/名词の＋とおりに、～　正如，按照</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：説明書のとおりに、組み立てました。</span><br><span class="line">译：我按照说明书组装好了。</span><br></pre></td></tr></table></figure><h3 id="た形-名词の＋あとで-……之后……-（する前に、した後で）"><a href="#た形-名词の＋あとで-……之后……-（する前に、した後で）" class="headerlink" title="た形/名词の＋あとで　……之后…… （する前に、した後で）"></a>た形/名词の＋あとで　……之后…… （する前に、した後で）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：仕事のあとで、飲みに行きませんか。</span><br><span class="line">译：下班后要去喝一杯吗？</span><br></pre></td></tr></table></figure><h3 id="可能态字典形-ない形ない＋ように、～-为了……而……-前方必须是非意志类词语，前后主语可以不一致"><a href="#可能态字典形-ない形ない＋ように、～-为了……而……-前方必须是非意志类词语，前后主语可以不一致" class="headerlink" title="可能态字典形/ない形ない＋ように、～　为了……而…… 前方必须是非意志类词语，前后主语可以不一致"></a>可能态字典形/ない形ない＋ように、～　为了……而…… 前方必须是非意志类词语，前后主语可以不一致</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：早く泳げるように、毎日練習しています。</span><br><span class="line">译：为了早点学会游泳，每天都在练习。</span><br><span class="line"></span><br><span class="line">例：忘れないように、メモしてください。</span><br><span class="line">译：为了不忘记，记了笔记。</span><br><span class="line"></span><br><span class="line">例：老人にも読めるように、新聞の字を大きくする。</span><br><span class="line">译：为了让老人也能阅读，放大了报纸上的字。</span><br></pre></td></tr></table></figure><h3 id="字典形-名词の＋ために、～-为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿"><a href="#字典形-名词の＋ために、～-为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿" class="headerlink" title="字典形/名词の＋ために、～　为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿"></a>字典形/名词の＋ために、～　为了，因为。前后主语一致，意志类词语，比ように有更强烈的意愿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：自分の店を持つために、貯金しています。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="可能态字典形-ない形なく＋ように、なります-变得……"><a href="#可能态字典形-ない形なく＋ように、なります-变得……" class="headerlink" title="可能态字典形/ない形なく＋ように、なります　变得……"></a>可能态字典形/ない形なく＋ように、なります　变得……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：毎日練習すれば、泳げように、なります。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：太りましたから、好きな服が着られなくように、なりました。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="字典形-ない形ない＋ように、します-努力（尽可能）做或不做……"><a href="#字典形-ない形ない＋ように、します-努力（尽可能）做或不做……" class="headerlink" title="字典形/ない形ない＋ように、します　努力（尽可能）做或不做……"></a>字典形/ない形ない＋ように、します　努力（尽可能）做或不做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：毎日運動して、何でも食べるように、しています。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：もっと野菜を食べるように、してください。（更有礼貌）</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="疑问词＋终止形＋か、～"><a href="#疑问词＋终止形＋か、～" class="headerlink" title="疑问词＋终止形＋か、～"></a>疑问词＋终止形＋か、～</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：結婚のお祝いは何がいいか、話しています。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：私たちが初めて会ったのはいつか、覚えていますか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="终止形（名词不加だ）＋かどうか、～"><a href="#终止形（名词不加だ）＋かどうか、～" class="headerlink" title="终止形（名词不加だ）＋かどうか、～"></a>终止形（名词不加だ）＋かどうか、～</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：その話は本堂かどうか、わかりません。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：まちがいがないかどうか、調べてください。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="名词-形容词去い-形容动词＋がる-有……的感觉-感觉……"><a href="#名词-形容词去い-形容动词＋がる-有……的感觉-感觉……" class="headerlink" title="名词/形容词去い/形容动词＋がる　有……的感觉, 感觉……"></a>名词/形容词去い/形容动词＋がる　有……的感觉, 感觉……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：嬉しがる</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：好きがる</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="名词に-形容词去い加く-形容动词に＋します-使……变成……-名词に还有选择和决定的意思"><a href="#名词に-形容词去い加く-形容动词に＋します-使……变成……-名词に还有选择和决定的意思" class="headerlink" title="名词に/形容词去い加く/形容动词に＋します　使……变成……　名词に还有选择和决定的意思"></a>名词に/形容词去い加く/形容动词に＋します　使……变成……　名词に还有选择和决定的意思</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：音を大きくします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：部屋を綺麗にします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：会議は明日にします。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：部屋はシングルにしますか、ツインにしますか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="连体形-名词の＋場合は、～-如果……就……-后面一般接对策或导致的结果"><a href="#连体形-名词の＋場合は、～-如果……就……-后面一般接对策或导致的结果" class="headerlink" title="连体形/名词の＋場合は、～　如果……就……(后面一般接对策或导致的结果)"></a>连体形/名词の＋場合は、～　如果……就……(后面一般接对策或导致的结果)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：会議に間に合わない場合は、連絡してください。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：時間に遅れた場合は、会場に入れません。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="连体形-名词な＋のに、～-明明……却……-表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。"><a href="#连体形-名词な＋のに、～-明明……却……-表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。" class="headerlink" title="连体形/名词な＋のに、～　明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。"></a>连体形/名词な＋のに、～　明明……却…… 表示意料之外的事情，有一种不满的感觉，有轻微的责备，还有一些遗憾的感情。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：約束をしたのに、彼女はきませんでした。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：約束をしたのに、どうして来なかったですか。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-～ている-た＋ところです-即将-正在-刚刚做了（5-10分钟的事情）"><a href="#动词字典形-～ている-た＋ところです-即将-正在-刚刚做了（5-10分钟的事情）" class="headerlink" title="动词字典形/～ている/~た＋ところです　即将/正在/刚刚做了（5-10分钟的事情）"></a>动词字典形/～ている/~た＋ところです　即将/正在/刚刚做了（5-10分钟的事情）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：会議は今から始まるところです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：今私は勉強しているところです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：たった今バスがでたところです</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-ない形ない-形容词-形容动词な-名词の＋はずです-应该会，确信的推断。"><a href="#动词字典形-ない形ない-形容词-形容动词な-名词の＋はずです-应该会，确信的推断。" class="headerlink" title="动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです　应该会，确信的推断。"></a>动词字典形/ない形ない/形容词/形容动词な/名词の＋はずです　应该会，确信的推断。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：くるはずですよ</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="简体＋そうです-据说，传闻。"><a href="#简体＋そうです-据说，传闻。" class="headerlink" title="简体＋そうです　据说，传闻。"></a>简体＋そうです　据说，传闻。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：天気予報によると、明日はさむくなるそうです。</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：クララさんは子どもの時、フランスに住んでいたそうです</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="动词字典形-形容词-形容动词な-名词の＋ようです-好像，感官感受到的好像"><a href="#动词字典形-形容词-形容动词な-名词の＋ようです-好像，感官感受到的好像" class="headerlink" title="动词字典形/形容词/形容动词な/名词の＋ようです　好像，感官感受到的好像"></a>动词字典形/形容词/形容动词な/名词の＋ようです　好像，感官感受到的好像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：渡辺さんはこのごろはやくかえりますから、どうも恋人ができたようですね。</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="～がします。-有……的感受"><a href="#～がします。-有……的感受" class="headerlink" title="～がします。　有……的感受"></a>～がします。　有……的感受</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：おと（こえ）がします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：あじがします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：においがします</span><br><span class="line">译：</span><br><span class="line"></span><br><span class="line">例：～顔がします　有~样的表情</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h1 id="敬语"><a href="#敬语" class="headerlink" title="敬语"></a>敬语</h1><h2 id="礼貌体"><a href="#礼貌体" class="headerlink" title="礼貌体"></a>礼貌体</h2><h3 id="です"><a href="#です" class="headerlink" title="です"></a>です</h3><p>普通形态：～です。<br>过去形态：～でした。<br>否定形态：～では（じゃ）ありません。<br>过去否定形态：～では（じゃ）ありませんでした。</p><h3 id="ます"><a href="#ます" class="headerlink" title="ます"></a>ます</h3><p>普通形态：～ます。<br>过去形态：～ました。<br>否定形态：～ません。<br>过去否定形态：～ませんでした。</p><h2 id="尊他语"><a href="#尊他语" class="headerlink" title="尊他语"></a>尊他语</h2><h3 id="被动形表达尊敬"><a href="#被动形表达尊敬" class="headerlink" title="被动形表达尊敬"></a>被动形表达尊敬</h3><ul><li>課長はもう帰られました。</li></ul><h3 id="お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～"><a href="#お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～" class="headerlink" title="お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～"></a>お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～</h3><ul><li><p>～ください　请……</p><ul><li>お待ちください。</li></ul></li><li><p>～になる</p><ul><li>社長はもうお帰りになりました。</li></ul></li></ul><h3 id="特殊动词的敬语变形"><a href="#特殊动词的敬语变形" class="headerlink" title="特殊动词的敬语变形"></a>特殊动词的敬语变形</h3><ul><li>いらっしゃる ー＞ いらっしゃいます　ー＞　いる、来る、行く</li><li>召し上がります　ー＞　食べる、飲む</li><li>おっしゃる　ー＞ おっしゃいます　ー＞　言う<ul><li>というと　ー＞　とおっしゃいますと</li></ul></li><li>なさる　ー＞ なさいます　ー＞　する</li><li>ご覧になります　ー＞　見る<ul><li>ご覧ください　―＞　見てください</li></ul></li><li>ご存じです　ー＞　知っています</li><li>くださる　ー＞　くださいます　ー＞　くれる</li></ul><h3 id="ます形＋まして-用于敬语中使前后敬语一致，使礼貌程度一致"><a href="#ます形＋まして-用于敬语中使前后敬语一致，使礼貌程度一致" class="headerlink" title="ます形＋まして　用于敬语中使前后敬语一致，使礼貌程度一致"></a>ます形＋まして　用于敬语中使前后敬语一致，使礼貌程度一致</h3><ul><li>ハンスが昨夜ねつをだしまして、今朝もまだ下がらないんです。</li></ul><h3 id="お＋形容词"><a href="#お＋形容词" class="headerlink" title="お＋形容词"></a>お＋形容词</h3><ul><li><p>お忙しい</p><ul><li>今日はお忙しいようですから，また明後日伺います。</li></ul></li><li><p>お詳しい</p><ul><li>御社が中国国内の酒類販売ルートにお詳しいことを，MTS社の聞くより伺いました。</li></ul></li></ul><h2 id="自谦语"><a href="#自谦语" class="headerlink" title="自谦语"></a>自谦语</h2><h3 id="お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～-1"><a href="#お＋1类动词和2类动词的ます形～-ご＋3类动词的词干～-1" class="headerlink" title="お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～"></a>お＋1类动词和2类动词的ます形～/ご＋3类动词的词干～</h3><ul><li><p>～＋する／いたします／できる</p><ul><li>今月のスケジュールはお送りします。</li><li>はい，ご用意できます。</li></ul></li><li><p>～＋申し上げる・申し上げます　同する一样的意思，但是敬意程度更高</p><ul><li>よろしくご検討くださいますようお願い申し上げます。</li></ul></li><li><p>お＋动词て型＋しております　～ています 的自谦语</p><ul><li>只今お調べしております。</li><li>お呼び出ししております。</li></ul></li></ul><h3 id="特殊动词的敬语变形-1"><a href="#特殊动词的敬语变形-1" class="headerlink" title="特殊动词的敬语变形"></a>特殊动词的敬语变形</h3><ul><li>差し上げります　ー＞　上げる</li><li>いただきます　ー＞　もらう，食べる，飲む</li><li>参ります　ー＞　行く、来る</li><li>おります　ー＞　いる</li><li>申します　ー＞　言う</li><li>いたします　ー＞　する</li><li>拝見します　ー＞　見る</li><li>伺います　ー＞　聞く、いる</li><li>存じます　ー＞　思う，知る<ul><li>ことと存じます　ー＞　と思います</li></ul></li><li>お目にかかります　ー＞　会う</li><li>お目にかけります　ー＞　見せる</li><li>私　ー＞　わたくし<ul><li>私たち　ー＞　わたくしども</li></ul></li><li>お～しております　ー＞　～ています、お～します</li><li>使役态表达自谦</li><li>常用组合形式为～＋させていただきます<ul><li>検討させていただきます</li></ul></li></ul><h2 id="礼貌语"><a href="#礼貌语" class="headerlink" title="礼貌语"></a>礼貌语</h2><ul><li>お手洗い　ー＞　洗手间</li><li>ございます　ー＞　ある</li><li>でございます　ー＞　です</li><li>よろしい　ー＞　いい</li><li>より　―＞　から</li><li>にて　―＞　で</li><li>～におかれましては／～には　―＞　～は　书函中表达敬意的写法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之(简敬)语&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-(形助副)词</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E5%BD%A2%E5%8A%A9%E5%89%AF-%E8%AF%8D/"/>
    <id>/2024/06/11/日语-形助副-词/</id>
    <published>2024-06-11T03:10:19.000Z</published>
    <updated>2024-06-11T03:28:17.307Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之(形助副)词<br><a id="more"></a></p><h1 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h1><h3 id="1-修饰名词"><a href="#1-修饰名词" class="headerlink" title="1. 修饰名词"></a>1. 修饰名词</h3><p>~い + 名词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：優しい人</span><br><span class="line">译：温柔的人</span><br></pre></td></tr></table></figure><h3 id="2-名词化"><a href="#2-名词化" class="headerlink" title="2. 名词化"></a>2. 名词化</h3><p>形容词（去い） + さ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：部長は頭の痛さを我慢して出張した。</span><br><span class="line">译：部长忍着头痛出差去了。</span><br></pre></td></tr></table></figure><h3 id="3-修饰动词"><a href="#3-修饰动词" class="headerlink" title="3. 修饰动词"></a>3. 修饰动词</h3><p>形容词（去い） + く</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：浅く笑う</span><br><span class="line">译：浅笑</span><br></pre></td></tr></table></figure><h3 id="4-句中接续"><a href="#4-句中接续" class="headerlink" title="4. 句中接续"></a>4. 句中接续</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼女は美しくて優しいです。</span><br><span class="line">译：她美丽温柔。</span><br></pre></td></tr></table></figure><h1 id="形容动词"><a href="#形容动词" class="headerlink" title="形容动词"></a>形容动词</h1><h3 id="1-修饰名词-1"><a href="#1-修饰名词-1" class="headerlink" title="1. 修饰名词"></a>1. 修饰名词</h3><p>形容动词 + な + 名词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：綺麗な景色</span><br><span class="line">译：美丽的风景</span><br></pre></td></tr></table></figure><h3 id="2-名词化-1"><a href="#2-名词化-1" class="headerlink" title="2. 名词化"></a>2. 名词化</h3><p>形容动词 + さ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あの店は家に近いので、便利さは一番です。</span><br><span class="line">译：那个商店离家很近，非常方便呀。</span><br></pre></td></tr></table></figure><h3 id="3-修饰动词-1"><a href="#3-修饰动词-1" class="headerlink" title="3. 修饰动词"></a>3. 修饰动词</h3><p>形容动词 + に</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：簡単にしました</span><br><span class="line">译：轻易地完成了</span><br></pre></td></tr></table></figure><h3 id="4-句中接续-1"><a href="#4-句中接续-1" class="headerlink" title="4. 句中接续"></a>4. 句中接续</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この町は綺麗で静かです。</span><br><span class="line">译：这坐小镇真是美丽安静呀。</span><br></pre></td></tr></table></figure><h1 id="助词"><a href="#助词" class="headerlink" title="助词"></a>助词</h1><p>助词是日语中的一大特色，它是日语语言中的黏着剂，串连起一个个完整的句子和含义。</p><h2 id="常用助词"><a href="#常用助词" class="headerlink" title="常用助词"></a>常用助词</h2><h3 id="1-を"><a href="#1-を" class="headerlink" title="1. を"></a>1. <code>を</code></h3><ul><li>提示宾语</li></ul><p>全員が無事であることをお祈りします。</p><blockquote><p>祈祷大家都没事。</p></blockquote><ul><li>表示经过的场所</li></ul><p>猫は塀の上を走っていった。  </p><blockquote><p>小猫从在墙上跑走了。</p></blockquote><ul><li>动作的出发点，起点</li></ul><p>彼は文房具を売る6階でエレベーターを降りた。</p><blockquote><p>他在买文具的6楼下了电梯。</p></blockquote><h3 id="2-に"><a href="#2-に" class="headerlink" title="2. に"></a>2. <code>に</code></h3><ul><li>动作作用的对象</li></ul><p>親に黙って、会社を辞めてしまった。</p><blockquote><p>瞒着父母辞掉了工作。</p></blockquote><ul><li>动作变化的结果</li></ul><p>温度がマイナスになると、水が氷になります。</p><blockquote><p>温度到达零度以下水就会结冰。</p></blockquote><ul><li>事物存在的场所</li></ul><p>その言葉にうそは少しもなかった。</p><blockquote><p>那些话里一点谎言也没有。</p></blockquote><ul><li>动作的着落点</li></ul><p>道に倒れている人を助けました。</p><blockquote><p>救助了倒在道路上的人。</p></blockquote><ul><li>表示目的</li></ul><p>スーパーへ買い物に行きます。</p><blockquote><p>去超市买东西。</p></blockquote><h3 id="3-が"><a href="#3-が" class="headerlink" title="3. が"></a>3. <code>が</code></h3><ul><li>固定搭配，前接表示感觉的词表示感觉</li></ul><p>さっき隣の部屋で人の話し声がしました。 </p><blockquote><p>我刚才听到隔壁有人说话的声音。</p></blockquote><ul><li>接在自动词前面</li></ul><p>新しくて白い建物が見えるでしょう。あれが王さんの家です。</p><blockquote><p>能看到那座又新又白的建筑吧，那就是小王的家。</p></blockquote><ul><li>表示转折或铺垫</li></ul><p>ちょっとお願いがあるんですが…</p><p>予定どおり１７時３０分に到着いたしましたが…</p><h3 id="4-で"><a href="#4-で" class="headerlink" title="4. で"></a>4. <code>で</code></h3><ul><li>表示交通工具手段</li></ul><p>バスで学校へ行きます。</p><blockquote><p>坐公交去学校。</p></blockquote><ul><li>表示动作发生的场所</li></ul><p>運動場で走ります。</p><blockquote><p>在运动场上跑步。</p></blockquote><ul><li>表示原因</li></ul><p>地震でビルが倒れた。</p><blockquote><p>地震把大楼震倒了。</p></blockquote><ul><li>表示范围</li></ul><p>クラスの中で李さんが一番かっこいいです。</p><blockquote><p>班里小李最帅。</p></blockquote><ul><li>表示限定</li></ul><p>明日いっぱいで仕事を終わらせてください。</p><blockquote><p>请在明天内完成工作。</p></blockquote><h3 id="5-と"><a href="#5-と" class="headerlink" title="5. と"></a>5. <code>と</code></h3><ul><li>表示共同动作的对象</li></ul><p>李さんと一緒に映画を見に行きます。</p><blockquote><p>和小李一起去看电影。</p></blockquote><ul><li>表示引用的内容</li></ul><p>ほら、見てごらん。あそこに｢危険｣と書いてありますよ。</p><blockquote><p>你瞧，那里写着“危险”两个字哦。</p></blockquote><h3 id="6-へ"><a href="#6-へ" class="headerlink" title="6. へ"></a>6. <code>へ</code></h3><ul><li>表示动作移动的方向</li></ul><p>買い物へいく途中王先生に会いました。</p><blockquote><p>去买东西的路上遇到了王老师。  </p></blockquote><h3 id="7-から"><a href="#7-から" class="headerlink" title="7. から"></a>7. <code>から</code></h3><ul><li>表示起点</li></ul><p>学校から家まで1時間かかります。</p><blockquote><p>从家到学校要花1个小时。</p></blockquote><ul><li>表示原因</li></ul><p>昨日試験がありましたから行かなかった。</p><blockquote><p>因为昨天有考试所以没去。</p></blockquote><ul><li>表示成分/材料</li></ul><p>この箱は紙からできた。</p><blockquote><p>这个箱子是纸做的。</p></blockquote><h3 id="8-まで"><a href="#8-まで" class="headerlink" title="8. まで"></a>8. <code>まで</code></h3><ul><li>表示终点</li></ul><p>試験は明日までです。</p><blockquote><p>考试到明天结束。</p></blockquote><h3 id="9-の"><a href="#9-の" class="headerlink" title="9. の"></a>9. <code>の</code></h3><ul><li>表示所属,属性</li></ul><p>高校時代最後の運動会は一生忘れられない。</p><blockquote><p>高中时代最后一次运动会终生难忘。</p></blockquote><ul><li>名词化</li></ul><p>あのう、赤いのがありますか。</p><blockquote><p>请问有红色的吗？</p></blockquote><ul><li>表解释说明</li></ul><p>昨日試験がありましたから、来なかったのです。</p><blockquote><p>因为昨天有考试所以没来。</p></blockquote><h3 id="9-～けど"><a href="#9-～けど" class="headerlink" title="9. ～けど"></a>9. <code>～けど</code></h3><ul><li>表示转折或铺垫</li></ul><p>あうの，荷物がでてこないんですけど…</p><blockquote><p>那个，我的行李还有没有出来，能不能……</p></blockquote><p>知っていたけど，言わなかっただけだ。</p><blockquote><p>我是知道的，只不过没有说罢了。</p></blockquote><h1 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h1><p>副词用作连用修饰语，表示用言的状态、程度，或者表明句子的陈述语气等的词叫作副词。</p><h2 id="常用副词"><a href="#常用副词" class="headerlink" title="常用副词"></a>常用副词</h2><h3 id="あ"><a href="#あ" class="headerlink" title="あ"></a>あ</h3><h4 id="あまり"><a href="#あまり" class="headerlink" title="あまり"></a>あまり</h4><p>后接动词，肯定：太，过于；否定：不那么，不怎么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：あまり食べると毒だよ。</span><br><span class="line">译：吃太多会伤身。</span><br><span class="line"></span><br><span class="line">例：あまり良くない。</span><br><span class="line">译：不怎么好。</span><br></pre></td></tr></table></figure><h4 id="あるいは"><a href="#あるいは" class="headerlink" title="あるいは"></a>あるいは</h4><p>或者；或许</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すぐ行けば或いは間に合うかもしれない。</span><br><span class="line">译：马上出发的话或许能赶上也说不定。</span><br></pre></td></tr></table></figure><h4 id="あいにく"><a href="#あいにく" class="headerlink" title="あいにく"></a>あいにく</h4><p>不凑巧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あいにく彼は留守でした。</span><br><span class="line">译：不凑巧他不在家。</span><br></pre></td></tr></table></figure><h3 id="い"><a href="#い" class="headerlink" title="い"></a>い</h3><h4 id="いかが"><a href="#いかが" class="headerlink" title="いかが"></a>いかが</h4><p>如何；怎样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ご病人の具合はいかがでしょうか。</span><br><span class="line">译：病人的情况如何？</span><br></pre></td></tr></table></figure><h4 id="一番（いちばん）"><a href="#一番（いちばん）" class="headerlink" title="一番（いちばん）"></a>一番（いちばん）</h4><p>最</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼が一番よく知っている。</span><br><span class="line">译：他知道的最清楚。</span><br></pre></td></tr></table></figure><h4 id="一生懸命（いっしょうけんめい）"><a href="#一生懸命（いっしょうけんめい）" class="headerlink" title="一生懸命（いっしょうけんめい）"></a>一生懸命（いっしょうけんめい）</h4><p>拼命</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一生懸命努力する。</span><br><span class="line">译：拼命努力着。</span><br></pre></td></tr></table></figure><h4 id="一緒に（いっしょに）"><a href="#一緒に（いっしょに）" class="headerlink" title="一緒に（いっしょに）"></a>一緒に（いっしょに）</h4><p>一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一緒にビルを飲みましょう。</span><br><span class="line">译：一起去喝啤酒吧。</span><br></pre></td></tr></table></figure><h4 id="一層（いっそう）"><a href="#一層（いっそう）" class="headerlink" title="一層（いっそう）"></a>一層（いっそう）</h4><p>更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病気は一層悪くなった。</span><br><span class="line">译：病情更加恶化了。</span><br></pre></td></tr></table></figure><h4 id="一般に（いっぱんに）"><a href="#一般に（いっぱんに）" class="headerlink" title="一般に（いっぱんに）"></a>一般に（いっぱんに）</h4><p>一般地、普遍地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：一般にイギリス発祥とされるゴルフ。</span><br><span class="line">译：一般认为高尔夫的发祥地是英国。</span><br></pre></td></tr></table></figure><h4 id="いつまでも"><a href="#いつまでも" class="headerlink" title="いつまでも"></a>いつまでも</h4><p>永远；无论到何时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いつまでも友達でいましょう。</span><br><span class="line">译：永远是朋友。</span><br></pre></td></tr></table></figure><h4 id="いつも"><a href="#いつも" class="headerlink" title="いつも"></a>いつも</h4><p>总是；经常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いつもニコニコしていたら，嫌なことが寄り付きません。</span><br><span class="line">译：经常面带微笑的话，不好的事情就不会靠近哦。</span><br></pre></td></tr></table></figure><h3 id="お"><a href="#お" class="headerlink" title="お"></a>お</h3><h4 id="凡そ（およそ）"><a href="#凡そ（およそ）" class="headerlink" title="凡そ（およそ）"></a>凡そ（およそ）</h4><ol><li>大约</li><li>凡是</li><li>完全（用于否定）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：君の話は凡そ分かった。</span><br><span class="line">译：你的话我大概明白了。</span><br><span class="line"></span><br><span class="line">例：凡そ人間として生まれた以上…</span><br><span class="line">译：本来既然生而为人……</span><br><span class="line"></span><br><span class="line">例：政治とは凡そ縁がない。</span><br><span class="line">译：与政治全然无缘。</span><br></pre></td></tr></table></figure><h3 id="か"><a href="#か" class="headerlink" title="か"></a>か</h3><h4 id="がっかり"><a href="#がっかり" class="headerlink" title="がっかり"></a>がっかり</h4><ol><li>失望</li><li>筋疲力竭</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：そんなにがっかりするな。</span><br><span class="line">译：别那么丧气呀。</span><br><span class="line"></span><br><span class="line">例：疲れてがっかりした。</span><br><span class="line">译：累得精疲力竭了。</span><br></pre></td></tr></table></figure><h4 id="必ず（かならず）"><a href="#必ず（かならず）" class="headerlink" title="必ず（かならず）"></a>必ず（かならず）</h4><p>一定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：必ず失敗する。</span><br><span class="line">译：必定要失败。</span><br></pre></td></tr></table></figure><h4 id="かなり"><a href="#かなり" class="headerlink" title="かなり"></a>かなり</h4><p>相当（出乎意料的那种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：かなりの距離。</span><br><span class="line">译：相当远的距离。</span><br><span class="line"></span><br><span class="line">例：あの人は日本語がかなりできる。</span><br><span class="line">译：那个人日语相当不错。</span><br></pre></td></tr></table></figure><h3 id="き"><a href="#き" class="headerlink" title="き"></a>き</h3><h4 id="きちんと"><a href="#きちんと" class="headerlink" title="きちんと"></a>きちんと</h4><ol><li>整整齐齐地，干干净净地</li><li>规规矩矩地，准确地</li><li>正好，正巧，正合适</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：料金はきちんと払ってある。</span><br><span class="line">译：钱已经如数付清。</span><br><span class="line"></span><br><span class="line">例：3時にきちんと集まる。</span><br><span class="line">译：3点准时集合。</span><br><span class="line"></span><br><span class="line">例：きちんとした字。</span><br><span class="line">译：工整的字。</span><br></pre></td></tr></table></figure><h4 id="きっと"><a href="#きっと" class="headerlink" title="きっと"></a>きっと</h4><p>一定（经常和だろう/でしょう一起使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：きっと合格できる。</span><br><span class="line">译：一定能合格。</span><br></pre></td></tr></table></figure><h4 id="極めて（きわめて）"><a href="#極めて（きわめて）" class="headerlink" title="極めて（きわめて）"></a>極めて（きわめて）</h4><p>极其</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：極めて簡単な問題である。</span><br><span class="line">译：是个极其简单的问题。</span><br></pre></td></tr></table></figure><h3 id="け"><a href="#け" class="headerlink" title="け"></a>け</h3><h4 id="結局（けっきょく）"><a href="#結局（けっきょく）" class="headerlink" title="結局（けっきょく）"></a>結局（けっきょく）</h4><p>到底，终究</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：結局だれがやるのか。</span><br><span class="line">译：到底谁来做呢？</span><br></pre></td></tr></table></figure><h4 id="結構（けっこう-）"><a href="#結構（けっこう-）" class="headerlink" title="結構（けっこう ）"></a>結構（けっこう ）</h4><p>相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私の日本語も結構通（つう）じたようだ。</span><br><span class="line">译：我的日语还算讲的通了。</span><br></pre></td></tr></table></figure><h4 id="決して（けっして）"><a href="#決して（けっして）" class="headerlink" title="決して（けっして）"></a>決して（けっして）</h4><p>决不~ 后要接否定使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：決して屈（く）しない。</span><br><span class="line">译：绝不屈服。</span><br></pre></td></tr></table></figure><h3 id="さ"><a href="#さ" class="headerlink" title="さ"></a>さ</h3><h4 id="さっき"><a href="#さっき" class="headerlink" title="さっき"></a>さっき</h4><p>刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：さっき帰ったばかりだ。</span><br><span class="line">译：刚刚才回来。</span><br></pre></td></tr></table></figure><h4 id="早速（さっそく-）"><a href="#早速（さっそく-）" class="headerlink" title="早速（さっそく ）"></a>早速（さっそく ）</h4><p>立刻，马上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：早速返事をくれた。</span><br><span class="line">译：很快给我了反馈。</span><br></pre></td></tr></table></figure><h4 id="さっぱり"><a href="#さっぱり" class="headerlink" title="さっぱり"></a>さっぱり</h4><p>清爽；干净；直爽；清单；不油腻；完全；精光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例：さっぱりした身なりをしている。</span><br><span class="line">译：打扮得干净利落。</span><br><span class="line"></span><br><span class="line">例：この料理はさっぱりしている。</span><br><span class="line">译：这个菜很清淡。</span><br><span class="line"></span><br><span class="line">例：約束のことはきれいさっぱりと忘れてしまった。</span><br><span class="line">译：早把约定忘得干干净净</span><br><span class="line"></span><br><span class="line">例：この映画はさっぱりおもしろくない。</span><br><span class="line">译：这个电影一点也不好看。</span><br><span class="line"></span><br><span class="line">例：どうもさっぱりだ。</span><br><span class="line">译：真糟糕。</span><br></pre></td></tr></table></figure><h3 id="し"><a href="#し" class="headerlink" title="し"></a>し</h3><h4 id="しっかり"><a href="#しっかり" class="headerlink" title="しっかり"></a>しっかり</h4><p>牢牢地；紧紧地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しっかりつかまる。</span><br><span class="line">译：牢牢抓住。</span><br></pre></td></tr></table></figure><h4 id="じっと"><a href="#じっと" class="headerlink" title="じっと"></a>じっと</h4><p>一动不动地；一声不响地，忍耐着，不出声；目不转睛地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：じっと見つめる。</span><br><span class="line">译：盯着看。</span><br><span class="line"></span><br><span class="line">例：じっとしていられない。</span><br><span class="line">译：坐立不安。</span><br></pre></td></tr></table></figure><h4 id="実は（じつは）"><a href="#実は（じつは）" class="headerlink" title="実は（じつは）"></a>実は（じつは）</h4><p>说真的，老实说，事实是，说实在的，其实，原来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：実は私にもよく分からない。</span><br><span class="line">译：说真的，我也不太明白。</span><br></pre></td></tr></table></figure><h4 id="しばらく"><a href="#しばらく" class="headerlink" title="しばらく"></a>しばらく</h4><p>暂时，不久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらく待ってくれ。 </span><br><span class="line">译：（你）给我等一会儿。</span><br></pre></td></tr></table></figure><p>一时的，暂且</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらく辛抱する。</span><br><span class="line">译：姑且忍耐一时。</span><br></pre></td></tr></table></figure><p>许久，好久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：しばらくでしたね。</span><br><span class="line">译：好久不见呀。</span><br></pre></td></tr></table></figure><h4 id="充分（じゅうぶん）"><a href="#充分（じゅうぶん）" class="headerlink" title="充分（じゅうぶん）"></a>充分（じゅうぶん）</h4><p>充分的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：自分の力を充分発揮する。</span><br><span class="line">译：充分发挥自己的才能。</span><br></pre></td></tr></table></figure><h3 id="す"><a href="#す" class="headerlink" title="す"></a>す</h3><h4 id="ずいぶん"><a href="#ずいぶん" class="headerlink" title="ずいぶん"></a>ずいぶん</h4><p>相当厉害；非常，很；颇，相当；特别；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病人は熱のためにずいぶん苦しんでいる。</span><br><span class="line">译：病人因发烧很难受。</span><br></pre></td></tr></table></figure><p>好久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ずいぶん捜した。</span><br><span class="line">译：找了好久。</span><br></pre></td></tr></table></figure><h4 id="すぐ"><a href="#すぐ" class="headerlink" title="すぐ"></a>すぐ</h4><p>立刻；马上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すぐ出かけましょう。</span><br><span class="line">译：马上出门吧。</span><br></pre></td></tr></table></figure><h4 id="すこし"><a href="#すこし" class="headerlink" title="すこし"></a>すこし</h4><p>一点点；稍微</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：少し疲れました。</span><br><span class="line">译：有点累了。</span><br></pre></td></tr></table></figure><h4 id="すっかり"><a href="#すっかり" class="headerlink" title="すっかり"></a>すっかり</h4><p>完全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：すっかり忘れていた。</span><br><span class="line">译：全忘了。</span><br></pre></td></tr></table></figure><h4 id="ずっと"><a href="#ずっと" class="headerlink" title="ずっと"></a>ずっと</h4><p>一直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今朝からずっと待っていた。</span><br><span class="line">译：从今天早晨一直等到现在。</span><br></pre></td></tr></table></figure><p>远比…..更</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼の方がずっといい。</span><br><span class="line">译：他的方法好得多。</span><br></pre></td></tr></table></figure><p>径直（走）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ずっと前へ進み出た。</span><br><span class="line">译：径直走到前面。</span><br></pre></td></tr></table></figure><h4 id="すべて"><a href="#すべて" class="headerlink" title="すべて"></a>すべて</h4><p>全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題はすべて解決した。</span><br><span class="line">译：问题全部解决了。</span><br></pre></td></tr></table></figure><h3 id="せ"><a href="#せ" class="headerlink" title="せ"></a>せ</h3><h4 id="せっかく"><a href="#せっかく" class="headerlink" title="せっかく"></a>せっかく</h4><p>难得，好不容易</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：せっかく晩ご飯を作ったのに、みんなは外食にするなんて。</span><br><span class="line">译：我特意做了晚饭，大家却在外面吃饭。</span><br></pre></td></tr></table></figure><h4 id="ぜったい"><a href="#ぜったい" class="headerlink" title="ぜったい"></a>ぜったい</h4><p>绝对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ぜったい間違いない。</span><br><span class="line">译：绝对没有错。</span><br></pre></td></tr></table></figure><h4 id="ぜひ"><a href="#ぜひ" class="headerlink" title="ぜひ"></a>ぜひ</h4><p>一定；务必</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ぜひ遊びに来てね。</span><br><span class="line">译：一定要来玩哦。</span><br></pre></td></tr></table></figure><h4 id="全然（ぜんぜん）"><a href="#全然（ぜんぜん）" class="headerlink" title="全然（ぜんぜん）"></a>全然（ぜんぜん）</h4><p>一点也不…..（后接否定，表全否）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：全然興味がない。</span><br><span class="line">译：完全没了兴趣。</span><br></pre></td></tr></table></figure><h4 id="全部（ぜんぶ）"><a href="#全部（ぜんぶ）" class="headerlink" title="全部（ぜんぶ）"></a>全部（ぜんぶ）</h4><p>全部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題は全部解決ずみだ。</span><br><span class="line">译：问题已经全部解决。</span><br></pre></td></tr></table></figure><h3 id="そ"><a href="#そ" class="headerlink" title="そ"></a>そ</h3><h4 id="相当（そうとう）"><a href="#相当（そうとう）" class="headerlink" title="相当（そうとう）"></a>相当（そうとう）</h4><p>相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日は相当（に）寒いです。</span><br><span class="line">译：今天相当的冷呀。</span><br></pre></td></tr></table></figure><h4 id="そろそろ"><a href="#そろそろ" class="headerlink" title="そろそろ"></a>そろそろ</h4><p>就要，快要；不久；时间差不多了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：もうそろそろ晚飯だ。</span><br><span class="line">译：就要吃晚饭了。</span><br></pre></td></tr></table></figure><p>渐渐；逐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そろそろ（と）寒くなってきた。</span><br><span class="line">译：渐渐地冷起来了。</span><br></pre></td></tr></table></figure><p>慢慢地；徐徐地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そろそろと歩く。</span><br><span class="line">译：慢慢地走。</span><br></pre></td></tr></table></figure><h4 id="それぞれ"><a href="#それぞれ" class="headerlink" title="それぞれ"></a>それぞれ</h4><p>各自；分别；各个；每个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：それぞれ別の道を行く。</span><br><span class="line">译：各走各的路。</span><br></pre></td></tr></table></figure><h4 id="それほど"><a href="#それほど" class="headerlink" title="それほど"></a>それほど</h4><p>那么，那样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語はそれほど難しくありません。</span><br><span class="line">译：语并不是那么难。</span><br></pre></td></tr></table></figure><h3 id="た"><a href="#た" class="headerlink" title="た"></a>た</h3><h4 id="だんだん"><a href="#だんだん" class="headerlink" title="だんだん"></a>だんだん</h4><p>渐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：だんだん秋めいてきた。</span><br><span class="line">译：渐有秋意了。</span><br></pre></td></tr></table></figure><h4 id="たまに"><a href="#たまに" class="headerlink" title="たまに"></a>たまに</h4><p>偶尔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たまにはご両親に電話を掛けなさい。</span><br><span class="line">译：偶尔请给你父母打个电话。</span><br></pre></td></tr></table></figure><h4 id="多分（たぶん）"><a href="#多分（たぶん）" class="headerlink" title="多分（たぶん）"></a>多分（たぶん）</h4><p>大概（经常和でしょう/だろう一起使用，表示推测，大概….）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼が言うことは多分本当だろう。</span><br><span class="line">译：他说的大概是真的吧！</span><br></pre></td></tr></table></figure><h4 id="大体（だいたい）"><a href="#大体（だいたい）" class="headerlink" title="大体（だいたい）"></a>大体（だいたい）</h4><p>大体上；大概</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大体以下のように規定する。</span><br><span class="line">译：大致规定如下。</span><br></pre></td></tr></table></figure><p>基本上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大体できた。 </span><br><span class="line">译：基本上完成了。</span><br></pre></td></tr></table></figure><h4 id="たいてい"><a href="#たいてい" class="headerlink" title="たいてい"></a>たいてい</h4><p>大致上，大都，差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：問題はたいてい出来た。</span><br><span class="line">译：问题大都产生了。</span><br></pre></td></tr></table></figure><p>大概，恐怕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たいてい大丈夫だろう。</span><br><span class="line">译：大概没问题吧。</span><br></pre></td></tr></table></figure><h4 id="たくさん"><a href="#たくさん" class="headerlink" title="たくさん"></a>たくさん</h4><p>许多（后接名词时要加の例：たくさんの人 动词可直接接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たくさんの人。</span><br><span class="line">译：很多人。</span><br></pre></td></tr></table></figure><h4 id="確か（たしか）"><a href="#確か（たしか）" class="headerlink" title="確か（たしか）"></a>確か（たしか）</h4><p>似乎，大概，表示根据记忆有相当把握的推断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：確か2000円でした。</span><br><span class="line">译：要是没错，那是二千日元。</span><br></pre></td></tr></table></figure><h4 id="たとえ"><a href="#たとえ" class="headerlink" title="たとえ"></a>たとえ</h4><p>即使</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：たとえ負けても後悔しない。</span><br><span class="line">译：即使输了也不后悔。</span><br></pre></td></tr></table></figure><h4 id="例えば（たとえば）"><a href="#例えば（たとえば）" class="headerlink" title="例えば（たとえば）"></a>例えば（たとえば）</h4><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：スポーツ，例えばバレーボールや卓球などをなさいますか。</span><br><span class="line">译：体育活动，例如排球、乒乓球，你参加吗？</span><br></pre></td></tr></table></figure><h3 id="ち"><a href="#ち" class="headerlink" title="ち"></a>ち</h3><h4 id="ちゃんと"><a href="#ちゃんと" class="headerlink" title="ちゃんと"></a>ちゃんと</h4><p>好好地；踏踏实实地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちゃんと仕事をする。</span><br><span class="line">译：踏踏实实地工作。</span><br></pre></td></tr></table></figure><p>整整齐齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：物をちゃんとかたづける。</span><br><span class="line">译：把东西收拾好。</span><br></pre></td></tr></table></figure><p>确实；的确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わたしがちゃんと見た。</span><br><span class="line">译：我确实看见了。</span><br></pre></td></tr></table></figure><h4 id="ちょうど"><a href="#ちょうど" class="headerlink" title="ちょうど"></a>ちょうど</h4><p>刚好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど居合わせる。</span><br><span class="line">译：正好在场。</span><br></pre></td></tr></table></figure><p>宛如，好像，恰似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど絵のようだ。</span><br><span class="line">译：好像一幅画。</span><br></pre></td></tr></table></figure><p>正，整。完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょうど８時。</span><br><span class="line">译：八点整。</span><br></pre></td></tr></table></figure><h4 id="ちょっと"><a href="#ちょっと" class="headerlink" title="ちょっと"></a>ちょっと</h4><p>一会儿，一下；表示数量不多，程度不深，时间很短等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと待ってください。</span><br><span class="line">译：请稍等一下。</span><br></pre></td></tr></table></figure><p>相当，颇。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと名の通った人</span><br><span class="line">译：颇有名望的人</span><br></pre></td></tr></table></figure><p>不太容易，表示没那么简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっとわからない。</span><br><span class="line">译：不太明白。</span><br></pre></td></tr></table></figure><p>试试，看看，以轻松的心情事做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと行ってくる。</span><br><span class="line">译：去去就来。</span><br></pre></td></tr></table></figure><h3 id="つ"><a href="#つ" class="headerlink" title="つ"></a>つ</h3><h4 id="ついでに"><a href="#ついでに" class="headerlink" title="ついでに"></a>ついでに</h4><p>顺便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：散歩のついでに、お菓子を買ってきた。</span><br><span class="line">译：去散步，顺便买来了点心。</span><br></pre></td></tr></table></figure><h4 id="ついに"><a href="#ついに" class="headerlink" title="ついに"></a>ついに</h4><p>终于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ついに出来上がった。</span><br><span class="line">译：终于完成了。</span><br></pre></td></tr></table></figure><p>直到最后（也不）；始终（不）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ついに会わずじまいだ。</span><br><span class="line">译：直到最后也未能见面。</span><br></pre></td></tr></table></figure><h4 id="次々（つぎつぎ）"><a href="#次々（つぎつぎ）" class="headerlink" title="次々（つぎつぎ）"></a>次々（つぎつぎ）</h4><p>连续不断、络绎不绝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：次々に仕掛け花火が打ち上げられる。</span><br><span class="line">译：一个接一个地放起烟火。</span><br></pre></td></tr></table></figure><h4 id="常に（つねに）"><a href="#常に（つねに）" class="headerlink" title="常に（つねに）"></a>常に（つねに）</h4><p>经常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：常にあることだ。</span><br><span class="line">译：常有的事。</span><br></pre></td></tr></table></figure><h4 id="つまり"><a href="#つまり" class="headerlink" title="つまり"></a>つまり</h4><p>总之，归根究底</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：つまり君は何を言いたいのか。</span><br><span class="line">译：究竟你想说什么呢？</span><br></pre></td></tr></table></figure><h3 id="て"><a href="#て" class="headerlink" title="て"></a>て</h3><h4 id="できるだけ"><a href="#できるだけ" class="headerlink" title="できるだけ"></a>できるだけ</h4><p>尽量地；尽可能地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：できるだけのことをする。</span><br><span class="line">译：尽力而为。</span><br></pre></td></tr></table></figure><h3 id="と"><a href="#と" class="headerlink" title="と"></a>と</h3><h4 id="どう"><a href="#どう" class="headerlink" title="どう"></a>どう</h4><p>如何；怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：それはどういうわけだ。</span><br><span class="line">译：那是为什么呢？</span><br><span class="line"></span><br><span class="line">例：もう一杯どう。 </span><br><span class="line">译：再来一杯怎么样？</span><br></pre></td></tr></table></figure><h4 id="どうか"><a href="#どうか" class="headerlink" title="どうか"></a>どうか</h4><p>请；务必</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あのことはどうかなるだろう。</span><br><span class="line">译：那件事总会有办法的吧。</span><br></pre></td></tr></table></figure><p>礼貌用语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうかよろしくお願いします。</span><br><span class="line">译：请多关照。</span><br></pre></td></tr></table></figure><p>不正常；异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は今日にどうかしている。</span><br><span class="line">译：他今天与往常不一样。</span><br></pre></td></tr></table></figure><p>怎么回事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：それはどうか分からない。</span><br><span class="line">译：不明白那是怎么回事。</span><br></pre></td></tr></table></figure><h4 id="どうして"><a href="#どうして" class="headerlink" title="どうして"></a>どうして</h4><p>为什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日はどうして学校を休みましたか。</span><br><span class="line">译：今天怎么没来上学呀。</span><br></pre></td></tr></table></figure><p>怎么样，怎么办，如何。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この機械をどうして動かすか教えてほしい。</span><br><span class="line">译：希望教给我怎样开动这个机器。</span><br></pre></td></tr></table></figure><p>岂止，岂料，意外，相反</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やさしそうに見えるが，どうして，なかなか気が強い。 </span><br><span class="line">译：看上去像很温柔，其实刚强得很。</span><br></pre></td></tr></table></figure><p>唉呀唉呀。出乎意料时表示吃惊或感叹的词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうして，たいした人気だ。</span><br><span class="line">译：唉呀唉呀，真红得不得了。</span><br></pre></td></tr></table></figure><h4 id="当然（とうぜん）"><a href="#当然（とうぜん）" class="headerlink" title="当然（とうぜん）"></a>当然（とうぜん）</h4><p>当然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：謝るのが当然だ。</span><br><span class="line">译：道歉是应当的。</span><br></pre></td></tr></table></figure><h4 id="ときどき"><a href="#ときどき" class="headerlink" title="ときどき"></a>ときどき</h4><p>偶尔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ときどき外食する。</span><br><span class="line">译：偶尔再外面吃饭。</span><br></pre></td></tr></table></figure><h4 id="とても"><a href="#とても" class="headerlink" title="とても"></a>とても</h4><p>非常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今日はとても寒いです。</span><br><span class="line">译：今天非常的冷呀。</span><br></pre></td></tr></table></figure><h4 id="とにかく"><a href="#とにかく" class="headerlink" title="とにかく"></a>とにかく</h4><p>总之</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：とにかく仕事を続けたくない。</span><br><span class="line">译：总之我不想继续工作了。</span><br></pre></td></tr></table></figure><h4 id="ともに"><a href="#ともに" class="headerlink" title="ともに"></a>ともに</h4><p>一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：学友とともに恩師を訪ねる。 </span><br><span class="line">译：和学友一同访问恩师。</span><br></pre></td></tr></table></figure><p>同时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：残念であるとともに、くやしくも思う。</span><br><span class="line">译：感到遗憾的同时，也很悔恨。</span><br></pre></td></tr></table></figure><h4 id="どうぞ"><a href="#どうぞ" class="headerlink" title="どうぞ"></a>どうぞ</h4><p>请</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はい，どうぞ。</span><br><span class="line">译：请。</span><br></pre></td></tr></table></figure><p>礼貌用语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうぞよろしく。</span><br><span class="line">译：请多关照。</span><br></pre></td></tr></table></figure><h4 id="特に（とくに）"><a href="#特に（とくに）" class="headerlink" title="特に（とくに）"></a>特に（とくに）</h4><p>特别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：特に注意すべき点。</span><br><span class="line">译：应特别注意的地方。</span><br></pre></td></tr></table></figure><h3 id="な"><a href="#な" class="headerlink" title="な"></a>な</h3><h4 id="なお"><a href="#なお" class="headerlink" title="なお"></a>なお</h4><p>更加，愈发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：薬を飲んで、なお悪くなった。</span><br><span class="line">译：吃了药更加不好了。</span><br></pre></td></tr></table></figure><p>犹，尚，还，仍然，依然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今もなお夢中している。</span><br><span class="line">译：现在也仍然非常热衷。</span><br></pre></td></tr></table></figure><p>此外（接续）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なお、詳しいことは後で話します。</span><br><span class="line">译：此外，具体事宜稍后再谈。</span><br></pre></td></tr></table></figure><h4 id="なかなか"><a href="#なかなか" class="headerlink" title="なかなか"></a>なかなか</h4><p>后接形容词时表肯定：相当<br>后接动词ない型时：轻易(不)，怎么也….，表示动作很难完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：去年の冬はなかなか寒かったですね。</span><br><span class="line">译：去年冬天相当的冷呀。</span><br><span class="line"></span><br><span class="line">例：なかなか怒らない。</span><br><span class="line">译：轻易不生气。</span><br></pre></td></tr></table></figure><h4 id="なるべく"><a href="#なるべく" class="headerlink" title="なるべく"></a>なるべく</h4><p>尽量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なるべくなら明日来ていただけませんか。</span><br><span class="line">译：可能的话，请明天来怎么样？</span><br></pre></td></tr></table></figure><h4 id="なるほど"><a href="#なるほど" class="headerlink" title="なるほど"></a>なるほど</h4><p>诚然，的确；果然；怪不得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なるほど美しい人だ。</span><br><span class="line">译：的确是个美人。</span><br></pre></td></tr></table></figure><h4 id="なんとなく"><a href="#なんとなく" class="headerlink" title="なんとなく"></a>なんとなく</h4><p>不知为何，总觉得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：先輩の前では、なんとなく気兼ねする。</span><br><span class="line">译：在老前辈面前总觉得拘束。</span><br></pre></td></tr></table></figure><p>无意中，不自主地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：なんとなく、口を滑らせてしまった。</span><br><span class="line">译：无意中说漏了嘴。</span><br></pre></td></tr></table></figure><h3 id="は"><a href="#は" class="headerlink" title="は"></a>は</h3><h4 id="はっきり"><a href="#はっきり" class="headerlink" title="はっきり"></a>はっきり</h4><p>清楚；明白</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はっきりと見える。</span><br><span class="line">译：清晰可见。</span><br></pre></td></tr></table></figure><h4 id="ばらばら"><a href="#ばらばら" class="headerlink" title="ばらばら"></a>ばらばら</h4><p>零散；散乱（形容动词）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ばらばらの髪の毛。</span><br><span class="line">译：披散的头发。</span><br></pre></td></tr></table></figure><p>忽地跳出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：悪漢共がばらばらと現れた。</span><br><span class="line">译：坏蛋们忽地跳了出来。</span><br></pre></td></tr></table></figure><p>哗啦啦的雨声</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：大粒の雨がばらばらと降り出した。</span><br><span class="line">译：大雨点哗啦哗啦地下了起来。</span><br></pre></td></tr></table></figure><h3 id="ひ"><a href="#ひ" class="headerlink" title="ひ"></a>ひ</h3><h4 id="非常に（ひじょうに）"><a href="#非常に（ひじょうに）" class="headerlink" title="非常に（ひじょうに）"></a>非常に（ひじょうに）</h4><p>非常地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：血糖値が非常に高い。</span><br><span class="line">译：血糖值非常高。</span><br></pre></td></tr></table></figure><h4 id="びっくり"><a href="#びっくり" class="headerlink" title="びっくり"></a>びっくり</h4><p>吓一跳；吃惊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：びっくり仰天する。</span><br><span class="line">译：大吃一惊。</span><br></pre></td></tr></table></figure><h3 id="ほ"><a href="#ほ" class="headerlink" title="ほ"></a>ほ</h3><h4 id="ほとんど"><a href="#ほとんど" class="headerlink" title="ほとんど"></a>ほとんど</h4><p>几乎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ほとんど眠れなかった。</span><br><span class="line">译：几乎没有睡。</span><br></pre></td></tr></table></figure><p>大部分；大概；大致；大体上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：古い建物はほとんど取り払われた。</span><br><span class="line">译：旧房子差不多都拆掉了。</span><br></pre></td></tr></table></figure><h3 id="ま"><a href="#ま" class="headerlink" title="ま"></a>ま</h3><h4 id="まあまあ"><a href="#まあまあ" class="headerlink" title="まあまあ"></a>まあまあ</h4><p>一般般，尚可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まあまあいいだろう。</span><br><span class="line">译：还算可以吧。</span><br></pre></td></tr></table></figure><h4 id="また"><a href="#また" class="headerlink" title="また"></a>また</h4><p>又；再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：またにしましょう。</span><br><span class="line">译：改天再说〔去,来,做〕吧；下次再说吧！</span><br></pre></td></tr></table></figure><h4 id="まだ"><a href="#まだ" class="headerlink" title="まだ"></a>まだ</h4><p>还</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ完成していない。</span><br><span class="line">译：尚未完成。</span><br></pre></td></tr></table></figure><p>还，仍旧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ会議中だ。</span><br><span class="line">译：会议还在进行中。</span><br></pre></td></tr></table></figure><p>才，仅，刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まだ作ったばかりだ。</span><br><span class="line">译：刚刚做完。</span><br></pre></td></tr></table></figure><p>还，更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：理由はまだある。</span><br><span class="line">译：理由还有。</span><br></pre></td></tr></table></figure><p>还，还好，还算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このほうがまだましだ。</span><br><span class="line">译：这样还算好。</span><br></pre></td></tr></table></figure><h4 id="まっすぐ"><a href="#まっすぐ" class="headerlink" title="まっすぐ"></a>まっすぐ</h4><p>笔直；径直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに見る。</span><br><span class="line">译：直向前看。</span><br></pre></td></tr></table></figure><p>一直；照直；不绕弯；直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに家に帰る。</span><br><span class="line">译：直接回家。</span><br></pre></td></tr></table></figure><p>正直；坦率；耿直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まっすぐに白状する。</span><br><span class="line">译：老实供认；坦白交代。</span><br></pre></td></tr></table></figure><h4 id="まったく"><a href="#まったく" class="headerlink" title="まったく"></a>まったく</h4><p>完全地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まったく健康になった。</span><br><span class="line">译：完全康复。</span><br></pre></td></tr></table></figure><p>全然；完全（否定）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：お酒はまったく飲まない。</span><br><span class="line">译：全然不喝酒。</span><br></pre></td></tr></table></figure><p>真，实在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まったく困ったものだ。</span><br><span class="line">译：真难办。</span><br></pre></td></tr></table></figure><h4 id="ますます"><a href="#ますます" class="headerlink" title="ますます"></a>ますます</h4><p>越来越……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ますます元気になった。</span><br><span class="line">译：越来越有精神了。</span><br></pre></td></tr></table></figure><h4 id="間も無く（まもなく）"><a href="#間も無く（まもなく）" class="headerlink" title="間も無く（まもなく）"></a>間も無く（まもなく）</h4><p>马上就要……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：間も無く春休みがやって来る。</span><br><span class="line">译：春假不久就会来到。</span><br></pre></td></tr></table></figure><h4 id="まるで"><a href="#まるで" class="headerlink" title="まるで"></a>まるで</h4><p>简直</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まるで違う。</span><br><span class="line">译：完全不一样。</span><br></pre></td></tr></table></figure><p>好像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：まるで夢のようだ。</span><br><span class="line">译：好像做梦一样。</span><br></pre></td></tr></table></figure><h3 id="め"><a href="#め" class="headerlink" title="め"></a>め</h3><h4 id="めったに"><a href="#めったに" class="headerlink" title="めったに"></a>めったに</h4><p>（后接否定）几乎（不）……很（少），（不）常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：めったに怒らない。</span><br><span class="line">译：很少发火。</span><br></pre></td></tr></table></figure><h4 id="めっきり"><a href="#めっきり" class="headerlink" title="めっきり"></a>めっきり</h4><p>显著，急剧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：病人はめっきりよくなってきた。</span><br><span class="line">译：病人明显好转了。</span><br></pre></td></tr></table></figure><h3 id="も"><a href="#も" class="headerlink" title="も"></a>も</h3><h4 id="もう"><a href="#もう" class="headerlink" title="もう"></a>もう</h4><p>已经</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：当地に来てもう半月になった。</span><br><span class="line">译：来到此地已经半个月了。</span><br></pre></td></tr></table></figure><h4 id="もし"><a href="#もし" class="headerlink" title="もし"></a>もし</h4><p>如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：もし彼が来たら，またせておいてください。</span><br><span class="line">译：要是他来了，请让他等一下。</span><br></pre></td></tr></table></figure><h4 id="もっと"><a href="#もっと" class="headerlink" title="もっと"></a>もっと</h4><p>更加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：リンゴをもっとください。</span><br><span class="line">译：再给些苹果吧。</span><br></pre></td></tr></table></figure><h4 id="最も（もっとも）"><a href="#最も（もっとも）" class="headerlink" title="最も（もっとも）"></a>最も（もっとも）</h4><p>最</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：最もよい。</span><br><span class="line">译：最好。</span><br></pre></td></tr></table></figure><h3 id="や"><a href="#や" class="headerlink" title="や"></a>や</h3><h4 id="やがて"><a href="#やがて" class="headerlink" title="やがて"></a>やがて</h4><p>不久</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やがて夜になった。</span><br><span class="line">译：天不久就黑了。</span><br></pre></td></tr></table></figure><p>大约，大致，差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やがて小１時間になる。</span><br><span class="line">译：差不多过了一个小时。</span><br></pre></td></tr></table></figure><h4 id="約（やく）"><a href="#約（やく）" class="headerlink" title="約（やく）"></a>約（やく）</h4><p>大约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：約4時間。</span><br><span class="line">译：约四小时。</span><br></pre></td></tr></table></figure><h4 id="やっと"><a href="#やっと" class="headerlink" title="やっと"></a>やっと</h4><p>好不容易；终于；总算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：終電にやっと間に合った。</span><br><span class="line">译：好不容易赶上了末班电车。</span><br></pre></td></tr></table></figure><p>勉勉强强；刚刚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やっとでき上がった。</span><br><span class="line">译：好不容易才完成了。</span><br></pre></td></tr></table></figure><h4 id="やはり"><a href="#やはり" class="headerlink" title="やはり"></a>やはり</h4><p>果然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：注意したが、やはりミスがある。</span><br><span class="line">译：虽然注意了，但还是有错。</span><br></pre></td></tr></table></figure><p>虽然…仍旧…。归根到底仍然是最初预测的结论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やはり女がいた。 </span><br><span class="line">译：果然在外边有了女人。</span><br></pre></td></tr></table></figure><p>依然，仍旧。情况和以前一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今でも、やはり昔のままになっている。 </span><br><span class="line">译：即使到了现在，（它）仍旧保留着原来的风貌。</span><br></pre></td></tr></table></figure><h3 id="ゆ"><a href="#ゆ" class="headerlink" title="ゆ"></a>ゆ</h3><h4 id="ゆっくり"><a href="#ゆっくり" class="headerlink" title="ゆっくり"></a>ゆっくり</h4><p>慢慢地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ご飯をゆっくり食べる。</span><br><span class="line">译：慢慢地吃饭。</span><br></pre></td></tr></table></figure><p>有余地，宽敞舒适，充裕，舒畅，安静，舒适</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いまからでもゆっくり間に合う。</span><br><span class="line">译：即使从现在起也还来得及。</span><br></pre></td></tr></table></figure><h3 id="よ"><a href="#よ" class="headerlink" title="よ"></a>よ</h3><h4 id="ようやく"><a href="#ようやく" class="headerlink" title="ようやく"></a>ようやく</h4><p>终于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく試験が終わった。</span><br><span class="line">译：考试终于结束了。</span><br></pre></td></tr></table></figure><p>勉强，好不容易，总算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく間に合った。</span><br><span class="line">译：总算赶上了。</span><br></pre></td></tr></table></figure><p>渐渐，逐渐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ようやく春らしくなってきた。</span><br><span class="line">译：渐渐有点春意了。</span><br></pre></td></tr></table></figure><h4 id="よほど"><a href="#よほど" class="headerlink" title="よほど"></a>よほど</h4><p>很，颇，相当</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：よほど自信があるのだろう。</span><br><span class="line">译：很有自信吧！</span><br></pre></td></tr></table></figure><p>差一点就…..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：よほど帰ろうかと思った。</span><br><span class="line">译：差点想回去。</span><br></pre></td></tr></table></figure><h3 id="わ"><a href="#わ" class="headerlink" title="わ"></a>わ</h3><h4 id="割合（わりあい）"><a href="#割合（わりあい）" class="headerlink" title="割合（わりあい）"></a>割合（わりあい）</h4><p>比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この子は割合と勉強する。</span><br><span class="line">译：这个孩子比较用功。</span><br></pre></td></tr></table></figure><h4 id="わざと"><a href="#わざと" class="headerlink" title="わざと"></a>わざと</h4><p>故意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わざと聞こえないふりにする。</span><br><span class="line">译：故意装作听不见。</span><br></pre></td></tr></table></figure><h4 id="わざわざ"><a href="#わざわざ" class="headerlink" title="わざわざ"></a>わざわざ</h4><p>特意地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そのために、わざわざ来たのだ。 </span><br><span class="line">译：为此特意过来的。</span><br></pre></td></tr></table></figure><p>故意地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：わざわざいたずら書きをする。</span><br><span class="line">译：故意乱涂乱画。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之(形助副)词&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-动词变形</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/"/>
    <id>/2024/06/11/日语-动词变形/</id>
    <published>2024-06-11T03:09:46.000Z</published>
    <updated>2024-06-11T03:25:52.011Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之动词变形<br><a id="more"></a></p><h1 id="ます形"><a href="#ます形" class="headerlink" title="ます形"></a>ます形</h1><h2 id="变形规则："><a href="#变形规则：" class="headerlink" title="变形规则："></a>变形规则：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　い段＋ます</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ます</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　きます</span><br><span class="line">  サ变动词：する　ー＞　します</span><br></pre></td></tr></table></figure><h2 id="文法："><a href="#文法：" class="headerlink" title="文法："></a>文法：</h2><h3 id="1-ます形本身就是动词的敬语形态"><a href="#1-ます形本身就是动词的敬语形态" class="headerlink" title="1. ます形本身就是动词的敬语形态"></a>1. ます形本身就是动词的敬语形态</h3><h3 id="2-ますー＞ましょう-ましょうか-劝诱-积极主动为对方做某事"><a href="#2-ますー＞ましょう-ましょうか-劝诱-积极主动为对方做某事" class="headerlink" title="2. ますー＞ましょう/ましょうか　劝诱/积极主动为对方做某事"></a>2. ますー＞ましょう/ましょうか　劝诱/积极主动为对方做某事</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：一緒にビールを飲みましょ！</span><br><span class="line">译：一起去喝啤酒吧！</span><br><span class="line"></span><br><span class="line">例：傘を貸しましょうか？</span><br><span class="line">译：可以把伞借给我吗？</span><br></pre></td></tr></table></figure><h3 id="3-ますー＞ませんか-更有礼貌的询问对方"><a href="#3-ますー＞ませんか-更有礼貌的询问对方" class="headerlink" title="3. ますー＞ませんか　更有礼貌的询问对方"></a>3. ますー＞ませんか　更有礼貌的询问对方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：あのシャツはありませんか？</span><br><span class="line">译：那件衬衫还有吗？</span><br></pre></td></tr></table></figure><h3 id="4-ます形可直接修饰名词"><a href="#4-ます形可直接修饰名词" class="headerlink" title="4. ます形可直接修饰名词"></a>4. ます形可直接修饰名词</h3><ul><li>做……的方法 ます形+方（かた）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：漢字の読み方</span><br><span class="line">译：汉字的读法</span><br></pre></td></tr></table></figure><h3 id="5-ます形＋ながら＋句子2-一边做……一般做……强调后面的动作"><a href="#5-ます形＋ながら＋句子2-一边做……一般做……强调后面的动作" class="headerlink" title="5. ます形＋ながら＋句子2  一边做……一般做……强调后面的动作"></a>5. ます形＋ながら＋句子2  一边做……一般做……强调后面的动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：音楽を聴きながら食事します。</span><br><span class="line">译：一边听音乐一边吃饭。</span><br></pre></td></tr></table></figure><h3 id="6-ます形-形容词去い-形容动词＋すぎる-过度做……-超过许可范围-不好的事情"><a href="#6-ます形-形容词去い-形容动词＋すぎる-过度做……-超过许可范围-不好的事情" class="headerlink" title="6. ます形/形容词去い/形容动词＋すぎる　过度做……, 超过许可范围, 不好的事情"></a>6. ます形/形容词去い/形容动词＋すぎる　过度做……, 超过许可范围, 不好的事情</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：働きすぎる。</span><br><span class="line">译：过度工作</span><br><span class="line"></span><br><span class="line">例：最近の車は操作が簡単すぎて、運転がおもしくないです。</span><br><span class="line">译：最近的车操作起来太简单了，都没有驾驶乐趣了。</span><br></pre></td></tr></table></figure><h3 id="7-ます形-形容词去い-形容动词＋そうです-样态助动词-看起来好像……"><a href="#7-ます形-形容词去い-形容动词＋そうです-样态助动词-看起来好像……" class="headerlink" title="7. ます形/形容词去い/形容动词＋そうです(样态助动词)　看起来好像……"></a>7. ます形/形容词去い/形容动词＋そうです(样态助动词)　看起来好像……</h3><p><em>特殊变形词语: いいー＞よさ　ないー＞なさ</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：今にも雨が降りそうです。</span><br><span class="line">译：今天看起好像要下雨了。</span><br><span class="line"></span><br><span class="line">例：その料理は辛そうです。</span><br><span class="line">译：这个料理看起来很辣的样子。</span><br><span class="line"></span><br><span class="line">例：この机は丈夫そうです。</span><br><span class="line">译：这张桌子看起来很结实。</span><br></pre></td></tr></table></figure><h3 id="8-ます形＋やすいです-客观觉得容易……"><a href="#8-ます形＋やすいです-客观觉得容易……" class="headerlink" title="8. ます形＋やすいです　客观觉得容易……"></a>8. ます形＋やすいです　客观觉得容易……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このパソコンは使いやすいです。</span><br><span class="line">译：这台电脑很容易使用。</span><br></pre></td></tr></table></figure><h3 id="9-ます形＋にくいです-客观觉得难……"><a href="#9-ます形＋にくいです-客观觉得难……" class="headerlink" title="9. ます形＋にくいです　客观觉得难……"></a>9. ます形＋にくいです　客观觉得难……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：このカープは割れにくくて、安全ですよ。</span><br><span class="line">译：这个杯子很难裂开，很安全哟。</span><br></pre></td></tr></table></figure><h3 id="10-ます形＋がたいです-主观觉得难……-认知类-说话类的词语-书面语"><a href="#10-ます形＋がたいです-主观觉得难……-认知类-说话类的词语-书面语" class="headerlink" title="10. ます形＋がたいです　主观觉得难……　(认知类, 说话类的词语, 书面语)"></a>10. ます形＋がたいです　主观觉得难……　(认知类, 说话类的词语, 书面语)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この宿題はやりがたいです。</span><br><span class="line">译：这道题做起来很难。</span><br></pre></td></tr></table></figure><h3 id="11-ます形＋かねる-难以……-郑重书面语-与敬语连用"><a href="#11-ます形＋かねる-难以……-郑重书面语-与敬语连用" class="headerlink" title="11. ます形＋かねる　难以……　(郑重书面语, 与敬语连用)"></a>11. ます形＋かねる　难以……　(郑重书面语, 与敬语连用)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと断りかねる</span><br><span class="line">译：难以拒绝</span><br></pre></td></tr></table></figure><h1 id="た形"><a href="#た形" class="headerlink" title="た形"></a>た形</h1><h2 id="变形规则"><a href="#变形规则" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">    く、ぐ　ー＞　いた、いだ</span><br><span class="line">        特例：いく　ー＞　行った</span><br><span class="line">    う、つ、る　ー＞　った</span><br><span class="line">    ぬ、ぶ、む　ー＞　んだ</span><br><span class="line">    す　ー＞　した</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋た</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　きた</span><br><span class="line">    サ变动次：する　ー＞　した</span><br><span class="line"></span><br><span class="line">形容词：去掉 い+かった</span><br><span class="line">    ~かったり、～かったりです　既……又……</span><br><span class="line"></span><br><span class="line">形容动词：词语+だった</span><br><span class="line">    ~だったり、～だったりです　既……又……</span><br></pre></td></tr></table></figure><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h3 id="1-动词-形容词-形容动词的た形表示动词的简体过去式"><a href="#1-动词-形容词-形容动词的た形表示动词的简体过去式" class="headerlink" title="1. 动词/形容词/形容动词的た形表示动词的简体过去式"></a>1. 动词/形容词/形容动词的た形表示动词的简体过去式</h3><h3 id="2-～たことがあります-有过……的经历"><a href="#2-～たことがあります-有过……的经历" class="headerlink" title="2. ～たことがあります　有过……的经历"></a>2. ～たことがあります　有过……的经历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は日本へ行ったことがあります。</span><br><span class="line">译：我去过日本。</span><br></pre></td></tr></table></figure><h3 id="3-～たり、～たり-交替，反复的动作"><a href="#3-～たり、～たり-交替，反复的动作" class="headerlink" title="3. ～たり、～たり　交替，反复的动作"></a>3. ～たり、～たり　交替，反复的动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は歌ったり、ダンスしたりこができます。</span><br><span class="line">译：我可以边唱歌边跳舞。</span><br></pre></td></tr></table></figure><h3 id="4-疑问词＋～たらいいですか-做……才好呢？"><a href="#4-疑问词＋～たらいいですか-做……才好呢？" class="headerlink" title="4. 疑问词＋～たらいいですか　做……才好呢？"></a>4. 疑问词＋～たらいいですか　做……才好呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：どうしたらいいですか？</span><br><span class="line">译：怎么做才好呢？</span><br></pre></td></tr></table></figure><h3 id="5-～たら、～-如果……就……"><a href="#5-～たら、～-如果……就……" class="headerlink" title="5. ～たら、～　如果……就……"></a>5. ～たら、～　如果……就……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：雨が降ったら、行きません。</span><br><span class="line">译：如果下雨了，就不去了。</span><br></pre></td></tr></table></figure><h3 id="6-～た＋ばかりです-刚刚做了，比ところです更长的时间但是是主观觉得时间短"><a href="#6-～た＋ばかりです-刚刚做了，比ところです更长的时间但是是主观觉得时间短" class="headerlink" title="6. ～た＋ばかりです　刚刚做了，比ところです更长的时间但是是主观觉得时间短"></a>6. ～た＋ばかりです　刚刚做了，比ところです更长的时间但是是主观觉得时间短</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：彼は3月に大学を卒業したばかりです。</span><br><span class="line">译：他3月份才刚刚从大学毕业。</span><br></pre></td></tr></table></figure><h1 id="て形"><a href="#て形" class="headerlink" title="て形"></a>て形</h1><h2 id="变形规则-1"><a href="#变形规则-1" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">    く、ぐ　ー＞　いて、いで</span><br><span class="line">        特例：いく　ー＞　行って</span><br><span class="line">    う、つ、る　ー＞　って</span><br><span class="line">    ぬ、ぶ、む　ー＞　んで</span><br><span class="line">    す　ー＞　して</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋て</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　きて</span><br><span class="line">    サ变动次：する　ー＞　して</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋くて</span><br><span class="line"></span><br><span class="line">形容动词和名词：～＋で</span><br></pre></td></tr></table></figure><h2 id="文法-1"><a href="#文法-1" class="headerlink" title="文法"></a>文法</h2><h3 id="1-～てください-请……（轻微的命令）"><a href="#1-～てください-请……（轻微的命令）" class="headerlink" title="1. ～てください　请……（轻微的命令）"></a>1. ～てください　请……（轻微的命令）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やめてください。</span><br><span class="line">译：请不要这么做！</span><br></pre></td></tr></table></figure><h3 id="2-～てもいいです-可以做……"><a href="#2-～てもいいです-可以做……" class="headerlink" title="2. ～てもいいです　可以做……"></a>2. ～てもいいです　可以做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：食べていいです。</span><br><span class="line">译：可以吃掉。</span><br></pre></td></tr></table></figure><h3 id="3-～てはいけません-不可以做……"><a href="#3-～てはいけません-不可以做……" class="headerlink" title="3. ～てはいけません　不可以做……"></a>3. ～てはいけません　不可以做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いま伝染病時から、旅行してはいけません。</span><br><span class="line">译：因为现在是疫情时期，不可以去旅行。</span><br></pre></td></tr></table></figure><h3 id="4-～ています"><a href="#4-～ています" class="headerlink" title="4. ～ています"></a>4. ～ています</h3><h4 id="4-1-正在做某事"><a href="#4-1-正在做某事" class="headerlink" title="4.1 正在做某事"></a>4.1 正在做某事</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ゲームしています。</span><br><span class="line">译：正在打游戏。</span><br></pre></td></tr></table></figure><h4 id="4-2-表示状态（结婚，认识某人，住在，有等）"><a href="#4-2-表示状态（结婚，认识某人，住在，有等）" class="headerlink" title="4.2 表示状态（结婚，认识某人，住在，有等）"></a>4.2 表示状态（结婚，认识某人，住在，有等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今大阪に住んでいます。</span><br><span class="line">译：目前我住在大版。</span><br></pre></td></tr></table></figure><h4 id="4-3-反复进行的动作或习惯（学习，工作等）"><a href="#4-3-反复进行的动作或习惯（学习，工作等）" class="headerlink" title="4.3 反复进行的动作或习惯（学习，工作等）"></a>4.3 反复进行的动作或习惯（学习，工作等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：勉強しています</span><br><span class="line">译：学习中……</span><br></pre></td></tr></table></figure><h3 id="5-～てあげます-为别人做……（我或我方为第三方做事情）"><a href="#5-～てあげます-为别人做……（我或我方为第三方做事情）" class="headerlink" title="5. ～てあげます　为别人做……（我或我方为第三方做事情）"></a>5. ～てあげます　为别人做……（我或我方为第三方做事情）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="5-1-比自己地位低的人，动物，植物可以用-やります"><a href="#5-1-比自己地位低的人，动物，植物可以用-やります" class="headerlink" title="5.1 比自己地位低的人，动物，植物可以用　やります"></a>5.1 比自己地位低的人，动物，植物可以用　やります</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="5-2-比自己地位高的人，可以用-あしあげます"><a href="#5-2-比自己地位高的人，可以用-あしあげます" class="headerlink" title="5.2 比自己地位高的人，可以用　あしあげます"></a>5.2 比自己地位高的人，可以用　あしあげます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="6-～てもらいます-主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）"><a href="#6-～てもらいます-主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）" class="headerlink" title="6. ～てもらいます　主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）"></a>6. ～てもらいます　主动请别人为我做……（别人为我或我方做事情，包含我或我方主动请求和别人主动为我做）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="6-1-比自己地位高的人，可以用-～ていただきます"><a href="#6-1-比自己地位高的人，可以用-～ていただきます" class="headerlink" title="6.1 比自己地位高的人，可以用　～ていただきます"></a>6.1 比自己地位高的人，可以用　～ていただきます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="7-～てくれます-别人主动为我做……（别人为我或我方做事情，别人主动为我做）"><a href="#7-～てくれます-别人主动为我做……（别人为我或我方做事情，别人主动为我做）" class="headerlink" title="7. ～てくれます　别人主动为我做……（别人为我或我方做事情，别人主动为我做）"></a>7. ～てくれます　别人主动为我做……（别人为我或我方做事情，别人主动为我做）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="7-1-比自己地位高的人，可以用-～てくださいます"><a href="#7-1-比自己地位高的人，可以用-～てくださいます" class="headerlink" title="7.1 比自己地位高的人，可以用　～てくださいます"></a>7.1 比自己地位高的人，可以用　～てくださいます</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h4 id="7-2-～てくださいませんか-超级有礼貌的表达方式"><a href="#7-2-～てくださいませんか-超级有礼貌的表达方式" class="headerlink" title="7.2 ～てくださいませんか　超级有礼貌的表达方式"></a>7.2 ～てくださいませんか　超级有礼貌的表达方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="7-3-～ていただけませんか-能帮我做……吗？"><a href="#7-3-～ていただけませんか-能帮我做……吗？" class="headerlink" title="7.3 ～ていただけませんか　能帮我做……吗？"></a>7.3 ～ていただけませんか　能帮我做……吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="8-～ても～-即使……也……"><a href="#8-～ても～-即使……也……" class="headerlink" title="8. ～ても～　即使……也……"></a>8. ～ても～　即使……也……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：やっても、無理です。</span><br><span class="line">译：即使做了，也不行了。</span><br></pre></td></tr></table></figure><h3 id="9-～てしまいます-表示下决心、将来完成"><a href="#9-～てしまいます-表示下决心、将来完成" class="headerlink" title="9. ～てしまいます　表示下决心、将来完成"></a>9. ～てしまいます　表示下决心、将来完成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：昼ご飯までにレポートを書いてしまいます。</span><br><span class="line">译：我要在午饭前把报告写完。</span><br></pre></td></tr></table></figure><h3 id="10-～てしまいました"><a href="#10-～てしまいました" class="headerlink" title="10. ～てしまいました"></a>10. ～てしまいました</h3><h4 id="10-1-强调某个行为已经全部完成了"><a href="#10-1-强调某个行为已经全部完成了" class="headerlink" title="10.1. 强调某个行为已经全部完成了"></a>10.1. 强调某个行为已经全部完成了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：漢字の宿題はもうやってしまいました。</span><br><span class="line">译：汉字的作业已经全部做完了。</span><br></pre></td></tr></table></figure><h4 id="10-2-为难状态下的困惑，后悔（发生了不好的事情）"><a href="#10-2-为难状态下的困惑，后悔（发生了不好的事情）" class="headerlink" title="10.2. 为难状态下的困惑，后悔（发生了不好的事情）"></a>10.2. 为难状态下的困惑，后悔（发生了不好的事情）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：パスポートをなくしてしまいました。</span><br><span class="line">译：护照弄丢了。</span><br></pre></td></tr></table></figure><h3 id="11-～てあります"><a href="#11-～てあります" class="headerlink" title="11. ～てあります"></a>11. ～てあります</h3><h4 id="11-1-表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）"><a href="#11-1-表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）" class="headerlink" title="11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）"></a>11.1. 表示有生命的物体参与过的动作后的状态：……着（有着、挂着、放着等，只能使用他动词）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：机の上にメモが置いてあります。</span><br><span class="line">译：桌子上放着笔记本。</span><br></pre></td></tr></table></figure><h4 id="11-2-表示状态时和ています的区别"><a href="#11-2-表示状态时和ています的区别" class="headerlink" title="11.2. 表示状态时和ています的区别"></a>11.2. 表示状态时和ています的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动词，强调窗户的状态</span><br><span class="line">例：窓が閉まっています。</span><br><span class="line">译：窗户关闭着。</span><br><span class="line"></span><br><span class="line">他动词，强调不知道被谁关了窗户这件事的结果</span><br><span class="line">例：窓が閉めてあります</span><br><span class="line">译：窗户关闭着</span><br></pre></td></tr></table></figure><h4 id="11-3-表示为将来提前做准备"><a href="#11-3-表示为将来提前做准备" class="headerlink" title="11.3. 表示为将来提前做准备"></a>11.3. 表示为将来提前做准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：誕生日のプレゼントはもう買ってあります。</span><br><span class="line">译：生日礼物已经买好了。</span><br></pre></td></tr></table></figure><h3 id="12-～ておきます"><a href="#12-～ておきます" class="headerlink" title="12. ～ておきます"></a>12. ～ておきます</h3><h4 id="12-1-做某件事之前必要做的事情"><a href="#12-1-做某件事之前必要做的事情" class="headerlink" title="12.1. 做某件事之前必要做的事情"></a>12.1. 做某件事之前必要做的事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：旅行の前に切符を買っておきます。</span><br><span class="line">译：旅行之前要把票买好。</span><br></pre></td></tr></table></figure><h4 id="12-2-为下次使用而完成必要的动作"><a href="#12-2-为下次使用而完成必要的动作" class="headerlink" title="12.2. 为下次使用而完成必要的动作"></a>12.2. 为下次使用而完成必要的动作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：はさみを使ったら、元の所に戻して置いてください。</span><br><span class="line">译：用完剪刀后，请放回原来的地方。</span><br></pre></td></tr></table></figure><h4 id="12-3-让状态持续下去"><a href="#12-3-让状态持续下去" class="headerlink" title="12.3. 让状态持续下去"></a>12.3. 让状态持续下去</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日会議がありますから、いすはこのままにして置いてください。</span><br><span class="line">译：明天还有会议，椅子就这样保持下去吧。</span><br></pre></td></tr></table></figure><h4 id="12-4-临时的措施"><a href="#12-4-临时的措施" class="headerlink" title="12.4. 临时的措施"></a>12.4. 临时的措施</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：資料は後で見ておきます、そこに置いといてください。</span><br><span class="line">译：资料之后要看，请放在哪里。</span><br></pre></td></tr></table></figure><h4 id="12-5-～ておきます-ー＞-～ときます（口语）"><a href="#12-5-～ておきます-ー＞-～ときます（口语）" class="headerlink" title="12.5. ～ておきます　ー＞　～ときます（口语）"></a>12.5. ～ておきます　ー＞　～ときます（口语）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：そこにおいといてください。</span><br><span class="line">译：请放到那里。</span><br></pre></td></tr></table></figure><h3 id="13-まだ～ていません-事情或者动作还没有发生"><a href="#13-まだ～ていません-事情或者动作还没有发生" class="headerlink" title="13. まだ～ていません　事情或者动作还没有发生"></a>13. まだ～ていません　事情或者动作还没有发生</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：銀行はまだ開いていません。</span><br><span class="line">译：银行还没有开门。</span><br></pre></td></tr></table></figure><h3 id="14-～てみる-试着做……"><a href="#14-～てみる-试着做……" class="headerlink" title="14. ～てみる　试着做……"></a>14. ～てみる　试着做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：も一度考えてみます。</span><br><span class="line">译：在试着思考一次。</span><br><span class="line"></span><br><span class="line">例：このズボンをはいてみてもいいですか。</span><br><span class="line">译：可以试穿一下这条裤子吗？</span><br></pre></td></tr></table></figure><h3 id="15-（て形-ない形-ないで）＋动词2-在动词1的情况下做动词2-有「没有做……而是做……」的意思"><a href="#15-（て形-ない形-ないで）＋动词2-在动词1的情况下做动词2-有「没有做……而是做……」的意思" class="headerlink" title="15. （て形/ない形+ないで）＋动词2  在动词1的情况下做动词2 　有「没有做……而是做……」的意思"></a>15. （て形/ない形+ないで）＋动词2  在动词1的情况下做动词2 　有「没有做……而是做……」的意思</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：醤油を付けて食べます。</span><br><span class="line">译：沾着酱油吃。</span><br><span class="line"></span><br><span class="line">例：醤油を付けないで食べます。</span><br><span class="line">译：不要沾着酱油吃。</span><br><span class="line"></span><br><span class="line">例：日曜日はどこも行かないで、うちでゆっくり休みます。</span><br><span class="line">译：周日哪里也不去，在家里好好休息。</span><br></pre></td></tr></table></figure><h3 id="16-～て来ます"><a href="#16-～て来ます" class="headerlink" title="16. ～て来ます"></a>16. ～て来ます</h3><h4 id="16-1-做某个动作之后再回来-有去去就回的感觉"><a href="#16-1-做某个动作之后再回来-有去去就回的感觉" class="headerlink" title="16.1. 做某个动作之后再回来, 有去去就回的感觉"></a>16.1. 做某个动作之后再回来, 有去去就回的感觉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと煙草を買ってきます。</span><br><span class="line">译：我去买包香烟。</span><br></pre></td></tr></table></figure><h4 id="16-2-有逐渐变化的意思"><a href="#16-2-有逐渐变化的意思" class="headerlink" title="16.2. 有逐渐变化的意思"></a>16.2. 有逐渐变化的意思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：消えて来ます。</span><br><span class="line">译：慢慢消失了。</span><br></pre></td></tr></table></figure><h1 id="ない形"><a href="#ない形" class="headerlink" title="ない形"></a>ない形</h1><h2 id="变形规则-2"><a href="#变形规则-2" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一类动词：</span><br><span class="line">う段　ー＞　あ段＋ない</span><br><span class="line">    以う结尾的动词，要去掉う变成わない。買うー＞買わない</span><br><span class="line">    ある的ない形就是ない</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ない</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　来（こ）ない</span><br><span class="line">    サ变动次：する　ー＞　しない</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋くない</span><br><span class="line"></span><br><span class="line">形容动词和名词：～＋では（じゃ）ない</span><br></pre></td></tr></table></figure><h2 id="文法-2"><a href="#文法-2" class="headerlink" title="文法"></a>文法</h2><h3 id="1-一般用于否定"><a href="#1-一般用于否定" class="headerlink" title="1. 一般用于否定"></a>1. 一般用于否定</h3><h3 id="2-～ないでください-请不要做……"><a href="#2-～ないでください-请不要做……" class="headerlink" title="2. ～ないでください　请不要做……"></a>2. ～ないでください　请不要做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="3-必须做……"><a href="#3-必须做……" class="headerlink" title="3. 必须做……"></a>3. 必须做……</h3><ul><li>～なければ、なりません</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ul><li>～ないと、いけません</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><ul><li>～ないと</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h3 id="4-～なくてもいいです-不做……也可以"><a href="#4-～なくてもいいです-不做……也可以" class="headerlink" title="4. ～なくてもいいです　不做……也可以"></a>4. ～なくてもいいです　不做……也可以</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">译：</span><br></pre></td></tr></table></figure><h1 id="可能态"><a href="#可能态" class="headerlink" title="可能态"></a>可能态</h1><h2 id="变形规则-3"><a href="#变形规则-3" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　え段＋る</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋られる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：くる　ー＞　こられる</span><br><span class="line">    サ变动词：する　ー＞　できる</span><br></pre></td></tr></table></figure><h2 id="变化后的词性"><a href="#变化后的词性" class="headerlink" title="变化后的词性"></a>变化后的词性</h2><ul><li>变化之后都是二类动词</li><li>变化之后都是自动词</li></ul><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><h3 id="1-事物的性质"><a href="#1-事物的性质" class="headerlink" title="1.事物的性质"></a>1.事物的性质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：この野菜は生で食べらない。</span><br><span class="line">译：这个蔬菜不能生吃。</span><br></pre></td></tr></table></figure><h3 id="2-表示可能性"><a href="#2-表示可能性" class="headerlink" title="2.表示可能性"></a>2.表示可能性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：この事は両親に言えません。</span><br><span class="line">译：这件事不能对父母说。</span><br><span class="line"></span><br><span class="line">例：今は社長に会えません。</span><br><span class="line">译：现在无法会见社长。</span><br><span class="line"></span><br><span class="line">例：事務所の人は誰もそのコンーピュータを使えます。</span><br><span class="line">译：事务所的人谁都不会使用那台电脑。</span><br></pre></td></tr></table></figure><h3 id="3-能力"><a href="#3-能力" class="headerlink" title="3.能力"></a>3.能力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：日本語を話せます。</span><br><span class="line">译：会说日语。</span><br></pre></td></tr></table></figure><h1 id="假定形"><a href="#假定形" class="headerlink" title="假定形"></a>假定形</h1><h2 id="变形规则-4"><a href="#变形规则-4" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段　ー＞　え段＋ば</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋れば</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　くれば</span><br><span class="line">    サ变动次：する　ー＞　すれば</span><br><span class="line"></span><br><span class="line">形容词：去掉 い＋ければ</span><br><span class="line"></span><br><span class="line">形容动词和名词：〜＋なら「ば」</span><br></pre></td></tr></table></figure><h2 id="文法-3"><a href="#文法-3" class="headerlink" title="文法"></a>文法</h2><h3 id="1-一般条件：一……就……"><a href="#1-一般条件：一……就……" class="headerlink" title="1. 一般条件：一……就……"></a>1. 一般条件：一……就……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：いい天気なら、向こうに島が見えます。</span><br><span class="line">译：天气好的话，你可以看到对面的小岛。</span><br></pre></td></tr></table></figure><h3 id="2-假定条件：如果……就……"><a href="#2-假定条件：如果……就……" class="headerlink" title="2. 假定条件：如果……就……"></a>2. 假定条件：如果……就……</h3><blockquote><p>PS: 前句是意志类词语，后句是对听话人提要求的话，只能用たら，たら范围最大。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：時間がなかったら、テレビを見ません。</span><br><span class="line">译：没时间我就不看电视了。</span><br><span class="line"></span><br><span class="line">例：時間がなければ、テレビを見ません。</span><br><span class="line">译：没时间我就不看电视了。</span><br><span class="line"></span><br><span class="line">例：よがったら、助けてもらいますか。</span><br><span class="line">译：可以的话，能帮下忙吗？</span><br></pre></td></tr></table></figure><h3 id="3-名词-なら-可用于对方提出的话题，再提供一些信息"><a href="#3-名词-なら-可用于对方提出的话题，再提供一些信息" class="headerlink" title="3. 名词+なら　可用于对方提出的话题，再提供一些信息"></a>3. 名词+なら　可用于对方提出的话题，再提供一些信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：温泉に行きたいんですが、どこか良い所がありませんか。</span><br><span class="line">译：非常想去泡温泉呀，有什么好地方吗？</span><br><span class="line"></span><br><span class="line">例：温泉なら、白馬がいいですよ。</span><br><span class="line">译：如果是温泉的话，白马县挺不错的哦。</span><br></pre></td></tr></table></figure><h3 id="4-疑问词＋假定形＋いいですか-等同于-〜たらいいですか-怎么做才好呢？"><a href="#4-疑问词＋假定形＋いいですか-等同于-〜たらいいですか-怎么做才好呢？" class="headerlink" title="4. 疑问词＋假定形＋いいですか　等同于　〜たらいいですか　怎么做才好呢？"></a>4. 疑问词＋假定形＋いいですか　等同于　〜たらいいですか　怎么做才好呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：本を借りたいですが、どうすればいいですか。</span><br><span class="line">译：想借本书，怎么做才好呢？</span><br></pre></td></tr></table></figure><h3 id="5-假定形＋连体形＋ほど〜-越……越……"><a href="#5-假定形＋连体形＋ほど〜-越……越……" class="headerlink" title="5. 假定形＋连体形＋ほど〜　越……越……"></a>5. 假定形＋连体形＋ほど〜　越……越……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：パソコンは操作が簡単なら簡単なほどいいです。</span><br><span class="line">译：电脑的操作越简单越好呀。</span><br></pre></td></tr></table></figure><h1 id="被动形"><a href="#被动形" class="headerlink" title="被动形"></a>被动形</h1><h2 id="变形规则-5"><a href="#变形规则-5" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段　ー＞　あ段＋れる</span><br><span class="line"></span><br><span class="line">二类动词：去る＋られる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：来る　ー＞　来られる</span><br><span class="line">    サ变动次：する　ー＞　される</span><br></pre></td></tr></table></figure><h2 id="文法-4"><a href="#文法-4" class="headerlink" title="文法"></a>文法</h2><h3 id="AはBに＋被动形-A被B……"><a href="#AはBに＋被动形-A被B……" class="headerlink" title="AはBに＋被动形　A被B……"></a>AはBに＋被动形　A被B……</h3><blockquote><p>中性，好坏都可表达<br>当A是作品或者发明时，被动形前面要加上よって</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：私は先生に褒められました。</span><br><span class="line">译：我被老师表扬了。</span><br><span class="line"></span><br><span class="line">例：私は犬に噛まれました。</span><br><span class="line">译：我被狗咬了。</span><br><span class="line"></span><br><span class="line">例：電話はベルによって発明されました。</span><br><span class="line">译：电话是被贝尔发明的。</span><br></pre></td></tr></table></figure><h3 id="AはBに＋なにを被动形-A的なに被B……"><a href="#AはBに＋なにを被动形-A的なに被B……" class="headerlink" title="AはBに＋なにを被动形 A的なに被B……"></a>AはBに＋なにを被动形 A的なに被B……</h3><blockquote><p>中性，不好的事情<br>A和~是从属关系（A的~），但是不能直接使用『Aの~』作为主语</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：私は犬に手を噛まれました。</span><br><span class="line">译：我的手被狗咬了。</span><br></pre></td></tr></table></figure><h1 id="使役态"><a href="#使役态" class="headerlink" title="使役态"></a>使役态</h1><h2 id="变形规则-6"><a href="#变形规则-6" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　あ段＋せる</span><br><span class="line">う结尾　ー＞　わせる</span><br><span class="line"></span><br><span class="line">二类动词：去る＋させる</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　こさせる</span><br><span class="line">  サ变动词：する　ー＞　させる</span><br></pre></td></tr></table></figure><h2 id="文法-5"><a href="#文法-5" class="headerlink" title="文法"></a>文法</h2><h3 id="～を自动词使役态-让名词（某人）做"><a href="#～を自动词使役态-让名词（某人）做" class="headerlink" title="～を自动词使役态　让名词（某人）做~"></a>～を自动词使役态　让名词（某人）做~</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：息子をイギリスヘ留学させます。 </span><br><span class="line">译：让我的儿子去英国留学。</span><br></pre></td></tr></table></figure><h3 id="～に～を他动词使役态-让名词（某人）做"><a href="#～に～を他动词使役态-让名词（某人）做" class="headerlink" title="～に～を他动词使役态　让名词（某人）做~"></a>～に～を他动词使役态　让名词（某人）做~</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：娘にピアノを習わせます。</span><br><span class="line">译：让女儿学习钢琴</span><br></pre></td></tr></table></figure><h1 id="意志形"><a href="#意志形" class="headerlink" title="意志形"></a>意志形</h1><h2 id="变形规则-7"><a href="#变形规则-7" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　お段＋う</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋よう</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">  か变动词：くる　ー＞　こよう</span><br><span class="line">  サ变动词：する　ー＞　しよう</span><br></pre></td></tr></table></figure><h2 id="文法-6"><a href="#文法-6" class="headerlink" title="文法"></a>文法</h2><h3 id="自己的意志"><a href="#自己的意志" class="headerlink" title="自己的意志"></a>自己的意志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：ちょっと休まない。</span><br><span class="line">译：要不休息一下？</span><br><span class="line"></span><br><span class="line">例：うん、休もう。</span><br><span class="line">译：嗯，去休息吧！</span><br></pre></td></tr></table></figure><h3 id="劝诱"><a href="#劝诱" class="headerlink" title="劝诱"></a>劝诱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：て伝おうか。</span><br><span class="line">译：能帮我一下吗？</span><br></pre></td></tr></table></figure><h3 id="提议-大家一起做"><a href="#提议-大家一起做" class="headerlink" title="提议(大家一起做)"></a>提议(大家一起做)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：みんなですごし休もうか。</span><br><span class="line">译：大家一起休息一下吧？</span><br></pre></td></tr></table></figure><h3 id="意志形＋とおもっています-很久以前就打算做……"><a href="#意志形＋とおもっています-很久以前就打算做……" class="headerlink" title="意志形＋とおもっています　很久以前就打算做……"></a>意志形＋とおもっています　很久以前就打算做……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：週末は海に行こうとおもっています。</span><br><span class="line">译：很久以前就打算周末去海边呢。</span><br></pre></td></tr></table></figure><h3 id="意志形＋とおもいます-刚刚有这样的打算……"><a href="#意志形＋とおもいます-刚刚有这样的打算……" class="headerlink" title="意志形＋とおもいます　刚刚有这样的打算……"></a>意志形＋とおもいます　刚刚有这样的打算……</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：今から銀行へ行こうとおもいます。</span><br><span class="line">译：我今天才打算去银行。</span><br></pre></td></tr></table></figure><h2 id="敬体"><a href="#敬体" class="headerlink" title="敬体"></a>敬体</h2><h3 id="～ましょう"><a href="#～ましょう" class="headerlink" title="～ましょう"></a>～ましょう</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：休みましょう。</span><br><span class="line">译：休息一下吧！</span><br></pre></td></tr></table></figure><h1 id="命令形"><a href="#命令形" class="headerlink" title="命令形"></a>命令形</h1><h2 id="变形规则-8"><a href="#变形规则-8" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一类动词：う段假名　ー＞　え段</span><br><span class="line"></span><br><span class="line">二类动词：去掉 る＋ろ</span><br><span class="line"></span><br><span class="line">三类动词：</span><br><span class="line">    か变动词：くる　ー＞　こい</span><br><span class="line">    サ变动词：する　ー＞　しろ</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h1 id="命令形和禁止形"><a href="#命令形和禁止形" class="headerlink" title="命令形和禁止形"></a>命令形和禁止形</h1><h2 id="变形规则-9"><a href="#变形规则-9" class="headerlink" title="变形规则"></a>变形规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典形＋な</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之动词变形&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>日语-五十音图</title>
    <link href="/2024/06/11/%E6%97%A5%E8%AF%AD-%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/"/>
    <id>/2024/06/11/日语-五十音图/</id>
    <published>2024-06-11T03:09:09.000Z</published>
    <updated>2024-06-11T03:25:57.204Z</updated>
    
    <content type="html"><![CDATA[<p>日语学习之五十音图发音<br><a id="more"></a></p><h1 id="五十音图"><a href="#五十音图" class="headerlink" title="五十音图"></a>五十音图</h1><h2 id="平假名"><a href="#平假名" class="headerlink" title="平假名"></a>平假名</h2><table><thead><tr><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr><td>あ（a）</td><td>い（i）</td><td>う（u）</td><td>え（e）</td><td>お（o）</td></tr><tr><td>か（ka）</td><td>き（ki）</td><td>く（ku）</td><td>け（ke）</td><td>こ（ko）</td></tr><tr><td>さ（sa）</td><td>し（si）</td><td>す（su）</td><td>せ（se）</td><td>そ（so）</td></tr><tr><td>た（ta）</td><td>ち（chi）</td><td>つ（tsu）</td><td>て（te）</td><td>と（to）</td></tr><tr><td>な（na）</td><td>に（ni）</td><td>ぬ（nu）</td><td>ね（ne）</td><td>の（no）</td></tr><tr><td>は（ha）</td><td>ひ（hi）</td><td>ふ（fu）</td><td>へ（he）</td><td>ほ（ho）</td></tr><tr><td>ま（ma）</td><td>み（mi）</td><td>む（mu）</td><td>め（me）</td><td>も（mo）</td></tr><tr><td>や（ya）</td><td>い（i）</td><td>ゆ（yu）</td><td>え（e）</td><td>よ（yo）</td></tr><tr><td>ら（ra）</td><td>り（ri）</td><td>る（ru）</td><td>れ（re）</td><td>ろ（ro）</td></tr><tr><td>わ（wa）</td><td>い（i）</td><td>う（u）</td><td>え（e）</td><td>を（wo）</td></tr><tr><td>ん（n）</td><td></td><td></td><td></td></tr></tbody></table><h2 id="片假名"><a href="#片假名" class="headerlink" title="片假名"></a>片假名</h2><table><thead><tr><th>ア段</th><th>イ段</th><th>ウ段</th><th>エ段</th><th>オ段</th></tr></thead><tbody><tr><td>ア（a）</td><td>イ（i）</td><td>ウ（u）</td><td>エ（e）</td><td>オ（o）</td></tr><tr><td>カ（ka）</td><td>キ（ki）</td><td>ク（ku）</td><td>ケ（ke）</td><td>コ（ko）</td></tr><tr><td>サ（sa）</td><td>シ（si）</td><td>ス（su）</td><td>セ（se）</td><td>ソ（so）</td></tr><tr><td>タ（ta）</td><td>チ（chi）</td><td>ツ（tsu）</td><td>テ（te）</td><td>ト（to）</td></tr><tr><td>ナ（na）</td><td>ニ（ni）</td><td>ヌ（nu）</td><td>ネ（ne）</td><td>ノ（no）</td></tr><tr><td>ハ（ha）</td><td>ヒ（hi）</td><td>フ（fu）</td><td>ヘ（he）</td><td>ホ（ho）</td></tr><tr><td>マ（ma）</td><td>ミ（mi）</td><td>ム（mu）</td><td>メ（me）</td><td>モ（mo）</td></tr><tr><td>ヤ（ya）</td><td>イ（i）</td><td>ユ（yu）</td><td>エ（e）</td><td>ヨ（yo）</td></tr><tr><td>ラ（ra）</td><td>リ（ri）</td><td>ル（ru）</td><td>レ（re）</td><td>ロ（ro）</td></tr><tr><td>ワ（wa）</td><td>イ（i）</td><td>ウ（u）</td><td>エ（e）</td><td>ヲ（wo）</td></tr><tr><td>ン（n）</td><td></td><td></td><td></td></tr></tbody></table><h2 id="浊音-半浊音"><a href="#浊音-半浊音" class="headerlink" title="浊音/半浊音"></a>浊音/半浊音</h2><table><thead><tr><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr><td>が（ga）</td><td>ぎ（gi）</td><td>ぐ（gu）</td><td>げ（ge）</td><td>ご（go）</td></tr><tr><td>ざ（za）</td><td>じ（ji）</td><td>ず（zu）</td><td>ぜ（ze）</td><td>ぞ（zo）</td></tr><tr><td>だ（da）</td><td>ぢ（ji）</td><td>づ（zu）</td><td>で（ze）</td><td>ど（do）</td></tr><tr><td>ば（ba）</td><td>び（bi）</td><td>ぶ（bu）</td><td>べ（be）</td><td>ぼ（bo）</td></tr><tr><td>ぱ（pa）</td><td>ぴ（pi）</td><td>ぷ（pu）</td><td>ぺ（pe）</td><td>ぽ（po）</td></tr></tbody></table><h2 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h2><table><thead><tr><th>や段</th><th>ゆ段</th><th>よ段</th></tr></thead><tbody><tr><td>きゃ（kya）</td><td>きゅ（kyu）</td><td>きょ（kyo）</td></tr><tr><td>ぎゃ（gya）</td><td>ぎゅ（gyu）</td><td>ぎょ（gyo）</td></tr><tr><td>しゃ（sha）</td><td>しゅ（shu）</td><td>しょ（sho）</td></tr><tr><td>じゃ（ja）</td><td>じゅ（ju）</td><td>じょ（jo）</td></tr><tr><td>ちゃ（cha）</td><td>ちゅ（chu）</td><td>ちょ（cho）</td></tr><tr><td>にゃ（nya）</td><td>にゅ（nyu）</td><td>にょ（nyo）</td></tr><tr><td>ひゃ（hya）</td><td>ひゅ（hyu）</td><td>ひょ（hyo）</td></tr><tr><td>びゃ（bya）</td><td>びゅ（byu）</td><td>びょ（byo）</td></tr><tr><td>ぴゃ（pya）</td><td>ぴゅ（pyu）</td><td>ぴょ（pyu）</td></tr><tr><td>みゃ（mya）</td><td>みゅ（myu）</td><td>みょ（myo）</td></tr><tr><td>りゃ（rya）</td><td>りゅ（ryu）</td><td>りょ（ryo）</td></tr></tbody></table><h2 id="拨音"><a href="#拨音" class="headerlink" title="拨音"></a>拨音</h2><p>ん不出现在词头，ん在其后面发音为n的音</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：反対（はんたい）、新聞（しんぶん）、天気（てんき）</span><br></pre></td></tr></table></figure><h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><p>つ音的主要在两个发音之前停顿一拍，促音与否会影响单词的含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">物価（ぶっか）部下（ぶか）</span><br><span class="line">喝采（かっさい）火災（かさい）</span><br><span class="line">夫（おっと）音（おと）</span><br></pre></td></tr></table></figure><h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><p>长音是两倍母音的发音，长音与否同样也会影响单词的含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">おばあさん（奶奶）、おばさん（阿姨）</span><br><span class="line">お爺（じい）さん（爷爷）、おじさん（叔叔）</span><br><span class="line">雪（ゆき）、勇気（ゆうき）</span><br></pre></td></tr></table></figure><h2 id="音调"><a href="#音调" class="headerlink" title="音调"></a>音调</h2><h3 id="升调"><a href="#升调" class="headerlink" title="升调"></a>升调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庭（に👆わ）</span><br><span class="line">鼻（は👆な）</span><br></pre></td></tr></table></figure><h3 id="降调"><a href="#降调" class="headerlink" title="降调"></a>降调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本（ほ👇ん）</span><br><span class="line">天気（て👇んき）</span><br></pre></td></tr></table></figure><h3 id="词中降调"><a href="#词中降调" class="headerlink" title="词中降调"></a>词中降调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卵（た👆ま👇ご）</span><br><span class="line">飛行機（ひ👆こ👇うき）</span><br></pre></td></tr></table></figure><h3 id="接续降调"><a href="#接续降调" class="headerlink" title="接续降调"></a>接续降调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">靴（くつ👇）</span><br><span class="line">花（はな👇）</span><br></pre></td></tr></table></figure><h3 id="升调和接续降调的区别"><a href="#升调和接续降调的区别" class="headerlink" title="升调和接续降调的区别"></a>升调和接续降调的区别</h3><p>花和鼻发音都一样，但是后面接助词时助词的发音却不一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：花👇が咲く</span><br><span class="line">例：鼻👉が高い</span><br></pre></td></tr></table></figure><p>音调不同词语的意思也有可能不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：橋（はし👇）</span><br><span class="line">例：箸（は👇し）</span><br></pre></td></tr></table></figure><h2 id="语调"><a href="#语调" class="headerlink" title="语调"></a>语调</h2><h3 id="平调"><a href="#平调" class="headerlink" title="平调"></a>平调</h3><p>陈述句一般都是平调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：明日友達とお花見をします。👉</span><br><span class="line">译：明天和朋友一起去赏花。</span><br></pre></td></tr></table></figure><h3 id="升调-1"><a href="#升调-1" class="headerlink" title="升调"></a>升调</h3><p>疑问句是升调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ミラさんも一緒に行きませんか。👆</span><br><span class="line">译：米勒先生你也一块去吗？</span><br></pre></td></tr></table></figure><h3 id="降调-1"><a href="#降调-1" class="headerlink" title="降调"></a>降调</h3><p>表示同意和失望的语气时也有用降调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：ああ、いいですね。👇</span><br><span class="line">译：啊，好的呢！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语学习之五十音图发音&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="日语" scheme="/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Three.js基础入门</title>
    <link href="/2024/06/06/Three-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>/2024/06/06/Three-js基础入门/</id>
    <published>2024-06-06T05:59:37.000Z</published>
    <updated>2024-06-06T06:12:46.721Z</updated>
    
    <content type="html"><![CDATA[<p>Three.js基础入门学习<br><a id="more"></a></p><blockquote><p>Three.js是一款开源的主流3D绘图JS引擎（名字Three就是3D的含义），原作者为Mr.Doob。<a href="https://github.com/mrdoob/three.js/" target="_blank" rel="noopener">项目地址为</a><br>Three.js经常会和WebGL混淆， 但也并不总是，three.js其实是使用WebGL来绘制三维效果的。 WebGL是一个只能画点、线和三角形的非常底层的系统. 想要用WebGL来做一些实用的东西通常需要大量的代码， 这就是Three.js的用武之地。它封装了诸如场景、灯光、阴影、材质、贴图、空间运算等一系列功能，让你不必要再从底层WebGL开始写起。</p></blockquote><h2 id="场景Scene"><a href="#场景Scene" class="headerlink" title="场景Scene"></a>场景Scene</h2><p>三维场景Scene (opens new window)对象理解为虚拟的3D场景，用来表示模拟生活中的真实三维场景,或者说三维世界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建3D场景对象Scene</span><br><span class="line">const scene = new THREE.Scene();</span><br></pre></td></tr></table></figure></p><h2 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h2><p>物体 = 几何体 + 材质</p><h3 id="几何体Geometry"><a href="#几何体Geometry" class="headerlink" title="几何体Geometry"></a>几何体Geometry</h3><p><img src="/2024/06/06/Three-js基础入门/1.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个长方体几何对象Geometry</span><br><span class="line">const geometry = new THREE.BoxGeometry(100, 100, 100);</span><br></pre></td></tr></table></figure></p><h3 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h3><p><img src="/2024/06/06/Three-js基础入门/2.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个材质对象Material</span><br><span class="line">const material = new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: 0xff0000, // 0xff0000设置材质颜色为红色</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="网格模型Mesh-物体"><a href="#网格模型Mesh-物体" class="headerlink" title="网格模型Mesh(物体)"></a>网格模型Mesh(物体)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 两个参数分别为几何体geometry、材质material</span><br><span class="line">const mesh = new THREE.Mesh(geometry, material); // 网格模型对象Mesh</span><br><span class="line">// 设置网格模型在三维空间中的位置坐标，默认是坐标原点</span><br><span class="line">mesh.position.set(0,10,0);</span><br><span class="line">// 在threejs中你创建了一个表示物体的虚拟对象Mesh，需要通过.add()方法，把网格模型mesh添加到三维场景scene中。</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure><h2 id="摄像机Camera"><a href="#摄像机Camera" class="headerlink" title="摄像机Camera"></a>摄像机Camera</h2><p>Threejs如果想把三维场景Scene渲染到web网页上，还需要定义一个虚拟相机Camera，就像你生活中想获得一张照片，需要一台用来拍照的相机。<br><img src="/2024/06/06/Three-js基础入门/3.png" alt="img"><br>Threejs提供了正投影相机OrthographicCamera和透视投影相机PerspectiveCamera，本次使用比较常用的透视投影相机PerspectiveCamera。</p><h3 id="透视投影相机PerspectiveCamera"><a href="#透视投影相机PerspectiveCamera" class="headerlink" title="透视投影相机PerspectiveCamera"></a>透视投影相机PerspectiveCamera</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)</span><br><span class="line">const width = 800; //宽度</span><br><span class="line">const height = 500; //高度</span><br><span class="line">// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面</span><br><span class="line">const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);</span><br></pre></td></tr></table></figure><p><code>PerspectiveCamera( fov, aspect, near, far )</code></p><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>fov</td><td>相机视锥体竖直方向视野角度</td><td>50</td></tr><tr><td>aspect</td><td>相机视锥体水平方向和竖直方向长度比，一般设置为Canvas画布宽高比width / height</td><td>1</td></tr><tr><td>near</td><td>相机视锥体近裁截面相对相机距离</td><td>0.1</td></tr><tr><td>far</td><td>相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向</td><td>2000</td></tr></tbody></table><h3 id="相机位置-position"><a href="#相机位置-position" class="headerlink" title="相机位置.position"></a>相机位置.position</h3><p>生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs中虚拟相机同样如此。<br>比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。<br>相机对象Camera具有位置属性.position，通过位置属性.position可以设置相机的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相机在Three.js三维坐标系中的位置</span><br><span class="line">// 根据需要设置相机位置具体值</span><br><span class="line">camera.position.set(200, 200, 200);</span><br></pre></td></tr></table></figure></p><h3 id="相机观察目标-lookAt"><a href="#相机观察目标-lookAt" class="headerlink" title="相机观察目标.lookAt()"></a>相机观察目标.lookAt()</h3><p>你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于threejs相机而言，就是设置.lookAt()方法的参数，指定一个3D坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 相机观察目标指向Threejs 3D空间中某个位置</span><br><span class="line">camera.lookAt(0, 0, 0); // 坐标原点</span><br><span class="line">camera.lookAt(0, 10, 0);  // y轴上位置10</span><br><span class="line">camera.lookAt(mesh.position); // 指向mesh对应的位置</span><br></pre></td></tr></table></figure></p><h2 id="渲染器WebGLRenderer"><a href="#渲染器WebGLRenderer" class="headerlink" title="渲染器WebGLRenderer"></a>渲染器WebGLRenderer</h2><h3 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h3><p>通过WebGL渲染器WebGLRenderer可以实例化一个WebGL渲染器对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建渲染器对象</span><br><span class="line">const renderer = new THREE.WebGLRenderer();</span><br></pre></td></tr></table></figure></p><h3 id="设置Canvas画布尺寸-setSize"><a href="#设置Canvas画布尺寸-setSize" class="headerlink" title="设置Canvas画布尺寸.setSize()"></a>设置Canvas画布尺寸.setSize()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义threejs输出画布的尺寸(单位:像素px)</span><br><span class="line">const width = 800; //宽度</span><br><span class="line">const height = 500; //高度</span><br><span class="line">renderer.setSize(width, height); // 设置three.js渲染区域的尺寸(像素px)</span><br></pre></td></tr></table></figure><h3 id="渲染器渲染方法-render"><a href="#渲染器渲染方法-render" class="headerlink" title="渲染器渲染方法.render()"></a>渲染器渲染方法.render()</h3><p>渲染器WebGLRenderer执行渲染方法.render()就可以生成一个Canvas画布(照片)，并把三维场景Scene呈现在canvas画布上面,你可以把.render()理解为相机的拍照动作“咔”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.render(scene, camera); // 执行渲染操作</span><br></pre></td></tr></table></figure></p><h3 id="渲染器Canvas画布属性-domElement"><a href="#渲染器Canvas画布属性-domElement" class="headerlink" title="渲染器Canvas画布属性.domElement"></a>渲染器Canvas画布属性.domElement</h3><p>渲染器WebGLRenderer通过属性.domElement可以获得渲染方法.render()生成的Canvas画布，.domElement本质上就是一个HTML元素：Canvas画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure></p><h2 id="光Light"><a href="#光Light" class="headerlink" title="光Light"></a>光Light</h2><p>实际生活中物体表面的明暗效果是会受到光照的影响，比如晚上不开灯，你就看不到物体，灯光比较暗，物体也比较暗。在threejs中，咱们用网格模型Mesh模拟生活中物体，所以threejs中模拟光照Light对物体表面的影响，就是模拟光照Light对网格模型Mesh表面的影响。</p><h3 id="受光照影响材质"><a href="#受光照影响材质" class="headerlink" title="受光照影响材质"></a>受光照影响材质</h3><p>threejs提供的网格材质，有的受光照影响，有的不受光照影响。<br><img src="/2024/06/06/Three-js基础入门/4.png" alt="img"></p><h3 id="光源简介"><a href="#光源简介" class="headerlink" title="光源简介"></a>光源简介</h3><p>Three.js提供了多种模拟生活中光源。<br><img src="/2024/06/06/Three-js基础入门/5.png" alt="img"><br>下面用点光源举例子</p><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>点光源PointLight可以类比为一个发光点，就像生活中一个灯泡以灯泡为中心向四周发射光线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 点光源：两个参数分别表示光源颜色和光照强度</span><br><span class="line">// 参数1：0xffffff是纯白光,表示光源颜色</span><br><span class="line">// 参数2：1.0,表示光照强度，可以根据需要调整</span><br><span class="line">const pointLight = new THREE.PointLight(0xffffff, 1.0);</span><br></pre></td></tr></table></figure></p><p>除了通过THREE.PointLight的参数2设置光照强度，你可以可以直接访问光照强度属性.intensity设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointLight.intensity = 1.0;//光照强度</span><br></pre></td></tr></table></figure></p><h3 id="光源衰减"><a href="#光源衰减" class="headerlink" title="光源衰减"></a>光源衰减</h3><p>实际生活中点光源，比如一个灯泡，随着距离的改变，光线会衰减，越来越弱，光源衰减属性.decay默认值是2.0，如果你不希望衰减可以设置为0.0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointLight.decay = 0.0; // 设置光源不随距离衰减</span><br></pre></td></tr></table></figure></p><h3 id="光源位置"><a href="#光源位置" class="headerlink" title="光源位置"></a>光源位置</h3><p>你把点光源想象为一个电灯泡，你在3D空间中，放的位置不同，模型的渲染效果就不一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//点光源位置</span><br><span class="line">pointLight.position.set(400, 0, 0); // 点光源放在x轴上</span><br></pre></td></tr></table></figure></p><h3 id="光源添加到场景"><a href="#光源添加到场景" class="headerlink" title="光源添加到场景"></a>光源添加到场景</h3><p>光源和网格模型Mesh对应一样是三维场景的一部分，自然需要添加到三维场景中才能起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.add(pointLight); // 点光源添加到场景中</span><br></pre></td></tr></table></figure></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>threejs可以借助HTML5的API请求动画帧window.requestAnimationFrame实现动画渲染。</p><h3 id="threejs旋转动画"><a href="#threejs旋转动画" class="headerlink" title="threejs旋转动画"></a>threejs旋转动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 渲染函数</span><br><span class="line">function render() &#123;</span><br><span class="line">    renderer.render(scene, camera); // 执行渲染操作</span><br><span class="line">    mesh.rotateY(0.01); // 每次绕y轴旋转0.01弧度</span><br><span class="line">    requestAnimationFrame(render); // 请求再次执行渲染函数render，渲染下一帧</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="计算两帧渲染时间间隔和帧率"><a href="#计算两帧渲染时间间隔和帧率" class="headerlink" title="计算两帧渲染时间间隔和帧率"></a>计算两帧渲染时间间隔和帧率</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 渲染循环</span><br><span class="line">const clock = new THREE.Clock();</span><br><span class="line">function render() &#123;</span><br><span class="line">    const spt = clock.getDelta()*1000;//毫秒</span><br><span class="line">    console.log(&apos;两帧渲染时间间隔(毫秒)&apos;,spt);</span><br><span class="line">    console.log(&apos;帧率FPS&apos;,1000/spt);</span><br><span class="line">    renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度</span><br><span class="line">    requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="渲染循环和相机控件OrbitControls"><a href="#渲染循环和相机控件OrbitControls" class="headerlink" title="渲染循环和相机控件OrbitControls"></a>渲染循环和相机控件OrbitControls</h3><p>设置了渲染循环,相机控件OrbitControls就不用再通过事件change执行renderer.render(scene, camera);，毕竟渲染循环一直在执行renderer.render(scene, camera)。</p><blockquote><p>以上内容就是Three.js的基础内容，下面介绍一些辅助开发的插件。</p></blockquote><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><h3 id="辅助观察坐标系"><a href="#辅助观察坐标系" class="headerlink" title="辅助观察坐标系"></a>辅助观察坐标系</h3><p>THREE.AxesHelper()的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// AxesHelper：辅助观察的坐标系</span><br><span class="line">const axesHelper = new THREE.AxesHelper(150);</span><br><span class="line">scene.add(axesHelper);</span><br></pre></td></tr></table></figure></p><h3 id="AxesHelper的xyz轴"><a href="#AxesHelper的xyz轴" class="headerlink" title="AxesHelper的xyz轴"></a>AxesHelper的xyz轴</h3><p>three.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。</p><h2 id="相机控件OrbitControls"><a href="#相机控件OrbitControls" class="headerlink" title="相机控件OrbitControls"></a>相机控件OrbitControls</h2><p>平时开发调试代码，或者展示模型的时候，可以通过相机控件OrbitControls实现旋转缩放预览效果。</p><h3 id="OrbitControls使用"><a href="#OrbitControls使用" class="headerlink" title="OrbitControls使用"></a>OrbitControls使用</h3><ul><li>旋转：拖动鼠标左键</li><li>缩放：滚动鼠标中键</li><li>平移：拖动鼠标右键</li></ul><h3 id="引入扩展库OrbitControls-js"><a href="#引入扩展库OrbitControls-js" class="headerlink" title="引入扩展库OrbitControls.js"></a>引入扩展库OrbitControls.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 引入轨道控制器扩展库OrbitControls.js</span><br><span class="line">import &#123; OrbitControls &#125; from &apos;three/addons/controls/OrbitControls.js&apos;;</span><br></pre></td></tr></table></figure><h3 id="使用OrbitControls"><a href="#使用OrbitControls" class="headerlink" title="使用OrbitControls"></a>使用OrbitControls</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置相机控件轨道控制器OrbitControls</span><br><span class="line">const controls = new OrbitControls(camera, renderer.domElement);</span><br><span class="line">// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景</span><br><span class="line">controls.addEventListener(&apos;change&apos;, function () &#123;</span><br><span class="line">    renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">&#125;);//监听鼠标、键盘事件</span><br></pre></td></tr></table></figure><h2 id="stats查看threejs渲染帧率"><a href="#stats查看threejs渲染帧率" class="headerlink" title="stats查看threejs渲染帧率"></a>stats查看threejs渲染帧率</h2><p>three.js每执行WebGL渲染器.render()方法一次，就在canvas画布上得到一帧图像，不停地周期性执行.render()方法就可以更新canvas画布内容，一般场景越复杂往往渲染性能越低，也就是每秒钟执行.render()的次数越低。<br>通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(FPS),所谓渲染帧率(FPS)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。</p><h3 id="引入Stats"><a href="#引入Stats" class="headerlink" title="引入Stats"></a>引入Stats</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//引入性能监视器stats.js</span><br><span class="line">import Stats from &apos;three/addons/libs/stats.module.js&apos;;</span><br></pre></td></tr></table></figure><h3 id="Stats使用"><a href="#Stats使用" class="headerlink" title="Stats使用"></a>Stats使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建stats对象</span><br><span class="line">const stats = new Stats();</span><br><span class="line">// stats.domElement:web页面上输出计算结果,一个div元素，</span><br><span class="line">document.body.appendChild(stats.domElement);</span><br><span class="line">// 渲染函数</span><br><span class="line">function render() &#123;</span><br><span class="line">// requestAnimationFrame循环调用的函数中调用方法update(),来刷新时间</span><br><span class="line">stats.update();</span><br><span class="line">renderer.render(scene, camera); // 执行渲染操作</span><br><span class="line">requestAnimationFrame(render); // 请求再次执行渲染函数render，渲染下一帧</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h2 id="demo-source"><a href="#demo-source" class="headerlink" title="demo source"></a>demo source</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">import * as THREE from &apos;three&apos;;</span><br><span class="line">// 引入轨道控制器扩展库OrbitControls.js</span><br><span class="line">import &#123; OrbitControls &#125; from &apos;three/addons/controls/OrbitControls.js&apos;;</span><br><span class="line">//引入性能监视器stats.js</span><br><span class="line">import Stats from &apos;three/addons/libs/stats.module.js&apos;;</span><br><span class="line"></span><br><span class="line">// 获取屏幕宽高</span><br><span class="line">const width = screen.width;</span><br><span class="line">const height = screen.height;</span><br><span class="line">// 变量声明</span><br><span class="line">let scene, camera, mesh, renderer, directionalLight, stats;</span><br><span class="line">// 初始化场景函数</span><br><span class="line">function initScene() &#123;</span><br><span class="line">  // 创建3D场景对象Scene</span><br><span class="line">  scene = new THREE.Scene();</span><br><span class="line">&#125;</span><br><span class="line">// 创建物体</span><br><span class="line">function initObject() &#123;</span><br><span class="line">  //创建一个长方体几何对象Geometry</span><br><span class="line">  const geometry = new THREE.BoxGeometry(20, 20, 20); </span><br><span class="line">  //创建一个材质对象Material</span><br><span class="line">  const material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000,//0xff0000设置材质颜色为红色</span><br><span class="line">    transparent:true,//开启透明</span><br><span class="line">    opacity:0.8,//设置透明度</span><br><span class="line">  &#125;); </span><br><span class="line">  // 两个参数分别为几何体geometry、材质material</span><br><span class="line">  mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh</span><br><span class="line">  //设置网格模型在三维空间中的位置坐标，默认是坐标原点</span><br><span class="line">  mesh.position.set(0,0,0);</span><br><span class="line">  scene.add(mesh); </span><br><span class="line">&#125;</span><br><span class="line">// 初始化相机</span><br><span class="line">function initCamera() &#123;</span><br><span class="line">  // 实例化一个透视投影相机对象</span><br><span class="line">  camera = new THREE.PerspectiveCamera(30, width/height, 1, 1000);</span><br><span class="line">  // 相机在Three.js三维坐标系中的位置</span><br><span class="line">  // 根据需要设置相机位置具体值</span><br><span class="line">  camera.position.set(200, 200, 200); </span><br><span class="line">  //相机观察目标指向Threejs 3D空间中某个位置</span><br><span class="line">  camera.lookAt(0, 0, 0); // 坐标原点</span><br><span class="line">&#125;</span><br><span class="line">// 初始化灯光</span><br><span class="line">function initLight() &#123;</span><br><span class="line">  // 环境光:没有特定方向，整体改变场景的光照明暗</span><br><span class="line">  const ambient = new THREE.AmbientLight(0xffffff, 0.4);</span><br><span class="line">  scene.add(ambient);</span><br><span class="line">  // 平行光</span><br><span class="line">  directionalLight = new THREE.DirectionalLight(0xffffff, 1);</span><br><span class="line">  // 设置光源的方向：通过光源position属性和目标指向对象的position属性计算</span><br><span class="line">  directionalLight.position.set(80, 50, 50);</span><br><span class="line">  // 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0</span><br><span class="line">  directionalLight.target = mesh;</span><br><span class="line">  scene.add(directionalLight);</span><br><span class="line">&#125;</span><br><span class="line">// 初始化渲染器</span><br><span class="line">function initRender() &#123;</span><br><span class="line">  // 创建渲染器对象</span><br><span class="line">  renderer = new THREE.WebGLRenderer();</span><br><span class="line">  renderer.setSize(width, height);</span><br><span class="line">  renderer.render(scene, camera); // 执行渲染操作</span><br><span class="line">  document.querySelector(&apos;#app&apos;).appendChild(renderer.domElement);</span><br><span class="line">&#125;</span><br><span class="line">// 初始化辅助开发工具</span><br><span class="line">function initHelper() &#123;</span><br><span class="line">  //创建stats对象</span><br><span class="line">  stats = new Stats();</span><br><span class="line">  //stats.domElement:web页面上输出计算结果,一个div元素，</span><br><span class="line">  document.body.appendChild(stats.domElement);</span><br><span class="line"></span><br><span class="line">  // DirectionalLightHelper：可视化平行光</span><br><span class="line">  const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5,0xff0000);</span><br><span class="line">  scene.add(dirLightHelper);</span><br><span class="line"></span><br><span class="line">  // AxesHelper：辅助观察的坐标系</span><br><span class="line">  const axesHelper = new THREE.AxesHelper(150);</span><br><span class="line">  scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line">  // 设置相机控件轨道控制器OrbitControls</span><br><span class="line">  const controls = new OrbitControls(camera, renderer.domElement);</span><br><span class="line">  // 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景</span><br><span class="line">  // controls.addEventListener(&apos;change&apos;, function () &#123;</span><br><span class="line">  //     renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">  // &#125;);//监听鼠标、键盘事件</span><br><span class="line">&#125;</span><br><span class="line">// 动画</span><br><span class="line">function animate() &#123;</span><br><span class="line">  mesh.rotateX(0.01);</span><br><span class="line">  mesh.rotateY(0.01);</span><br><span class="line">  stats.update();</span><br><span class="line">  renderer.render(scene, camera); //执行渲染操作</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">// 开始Threejs</span><br><span class="line">function start() &#123;</span><br><span class="line">  initScene();</span><br><span class="line">  initObject();</span><br><span class="line">  initCamera();</span><br><span class="line">  initLight();</span><br><span class="line">  initRender();</span><br><span class="line">  initHelper();</span><br><span class="line">  animate();</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Three.js基础入门学习&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="Threejs" scheme="/tags/Threejs/"/>
    
  </entry>
  
  <entry>
    <title>Three.js学习资源导航</title>
    <link href="/2024/06/03/Three-js%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    <id>/2024/06/03/Three-js学习资源导航/</id>
    <published>2024-06-03T01:56:22.000Z</published>
    <updated>2024-06-06T06:02:31.462Z</updated>
    
    <content type="html"><![CDATA[<p>Three.js相关学习资源导航链接<br><a id="more"></a></p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ul><li><a href="https://threejs.org/" target="_blank" rel="noopener">官网文档</a></li><li><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene" target="_blank" rel="noopener">官方API文档</a></li><li><a href="https://techbrood.com/threejs/docs" target="_blank" rel="noopener">中文文档</a></li><li><a href="https://threejs.org/manual/#zh/fundamentals" target="_blank" rel="noopener">官方入门教程</a></li><li><a href="http://www.hewebgl.com/article/articledir/1/" target="_blank" rel="noopener">初中高级教程</a></li><li><a href="http://www.webgl3d.cn/pages/4a14ce/" target="_blank" rel="noopener">基础教程</a></li><li><a href="https://blog.csdn.net/homula123/article/details/101197463" target="_blank" rel="noopener">从零构建3D智能仓库</a></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li><a href="https://threejs.org/examples/" target="_blank" rel="noopener">官网案例</a></li><li><a href="https://www.wjceo.com/blog/threejs/" target="_blank" rel="noopener">暮志未晚博客案例100篇</a></li><li><a href="http://www.yanhuangxueyuan.com/3D.html" target="_blank" rel="noopener">3D案例</a></li><li><a href="http://www.yanhuangxueyuan.com/3D/liangcang/" target="_blank" rel="noopener">物联网粮仓3D可视化</a></li><li><a href="https://ezshine.jnsii.com/cases/slowroads/" target="_blank" rel="noopener">3D版赛车游戏</a></li><li><a href="https://ezshine.jnsii.com/cases/avatarbuilder/" target="_blank" rel="noopener">Three.js开发的3D头像生成器 </a></li></ul><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/mrdoob/three.js/" target="_blank" rel="noopener">官方源码仓库</a></li><li><a href="https://github.com/mrdoob/three.js/tree/dev/examples" target="_blank" rel="noopener">官方示例仓库</a></li><li><a href="https://github.com/chandlerprall/Physijs" target="_blank" rel="noopener">Physijs-一款物理引擎，可以协助基于原生WebGL或使用three.js创建模拟物理现象，比如重力下落、物体碰撞等物理现象</a></li><li><a href="https://github.com/mrdoob/stats.js" target="_blank" rel="noopener">stats.js-提供了一个简单的信息框，可帮助您监视代码性能</a></li><li><a href="https://github.com/dataarts/dat.gui" target="_blank" rel="noopener">dat.gui-轻量级的icon形用户界面框架，可以用来控制Javascript的变量，比如WebGL中一个物体的尺寸、颜色</a></li><li><a href="https://github.com/tweenjs/tween.js/" target="_blank" rel="noopener">tween.js-一款可生成平滑动画效果的js动画库。可以非常方便的控制机械、游戏角色运动</a></li><li><a href="https://github.com/sshirokov/ThreeBSP" target="_blank" rel="noopener">ThreeBSP-可以将现有的模型组合出更多个性的模型来使用。如两个几何体的差集、并集、交集的展示</a></li><li><a href="https://free3d.com/3d-models/" target="_blank" rel="noopener">免费3D模型</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Three.js相关学习资源导航链接&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="Threejs" scheme="/tags/Threejs/"/>
    
      <category term="资源导航" scheme="/tags/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>windows系统安装Redis</title>
    <link href="/2024/05/30/windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85redis/"/>
    <id>/2024/05/30/windows系统安装redis/</id>
    <published>2024-05-30T08:06:09.000Z</published>
    <updated>2024-05-30T08:27:27.803Z</updated>
    
    <content type="html"><![CDATA[<p>windows系统下如何安装Redis<br><a id="more"></a></p><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，它提供了一个高效的键值存储解决方案，并支持多种数据结构，如字符串（Strings）、哈希（Hashes）、列表（Lists）、集合（Sets）和有序集合（Sorted Sets）等。它被广泛应用于缓存、消息队列、实时统计等场景。</p><h2 id="安装（windows）"><a href="#安装（windows）" class="headerlink" title="安装（windows）"></a>安装（windows）</h2><p><a href="https://github.com/zkteco-home/redis-windows" target="_blank" rel="noopener">Redis安装文件下载</a><br>将这个库clone到本地，之后以管理员身份执行<code>install_redis.cmd</code>这个文件后，就安装好了。<br><img src="/2024/05/30/windows系统安装redis/1.png" alt="img"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><code>redis-cli.exe</code>是客户端，可以连接redis服务进行操作<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET mykey &quot;Hello, World!&quot;</span><br><span class="line">GET mykey</span><br></pre></td></tr></table></figure></p><h3 id="卸载服务"><a href="#卸载服务" class="headerlink" title="卸载服务"></a>卸载服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-uninstall</span><br></pre></td></tr></table></figure><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-stop</span><br></pre></td></tr></table></figure><h3 id="开始服务"><a href="#开始服务" class="headerlink" title="开始服务"></a>开始服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-start</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个安装地址，<a href="https://github.com/microsoftarchive/redis" target="_blank" rel="noopener">Redis安装文件下载</a><br>但是这个库维护的Redis版本较低。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windows系统下如何安装Redis&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="后端" scheme="/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>web视频播放浅析</title>
    <link href="/2024/04/19/web%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%85%E6%9E%90/"/>
    <id>/2024/04/19/web视频播放浅析/</id>
    <published>2024-04-19T02:32:53.000Z</published>
    <updated>2024-04-22T01:16:01.429Z</updated>
    
    <content type="html"><![CDATA[<p>简单的介绍html中video标签的几种使用场景,注意，视频播放是点播形式。<br><a id="more"></a></p><h2 id="视频知识"><a href="#视频知识" class="headerlink" title="视频知识"></a>视频知识</h2><p>web端以前用flash播放视频，但是由于安全原因，现在已经抛弃，使用html5的video标签。</p><blockquote><p>视频容器（也称为视频封装格式）是用来存储音频、视频和其他元数据（如字幕、章节信息等）的一种文件格式结构。它将音视频编码数据组织在一起，以便于播放器解析和呈现。容器的作用就像一个“包装盒”，将不同的轨道（视频流、音频流、字幕流等）按照一定的标准组织起来，使得各部分数据可以同步播放。</p></blockquote><h3 id="常见的视频文件格式"><a href="#常见的视频文件格式" class="headerlink" title="常见的视频文件格式"></a>常见的视频文件格式</h3><p><img src="/2024/04/19/web视频播放浅析/1.png" alt="img"></p><h3 id="常见的视频编码格式"><a href="#常见的视频编码格式" class="headerlink" title="常见的视频编码格式"></a>常见的视频编码格式</h3><p><img src="/2024/04/19/web视频播放浅析/2.png" alt="img"></p><h3 id="浏览器中的视频格式"><a href="#浏览器中的视频格式" class="headerlink" title="浏览器中的视频格式"></a>浏览器中的视频格式</h3><h4 id="WebM"><a href="#WebM" class="headerlink" title="WebM"></a>WebM</h4><p><img src="/2024/04/19/web视频播放浅析/3.png" alt="img"></p><h4 id="Ogg-Theora"><a href="#Ogg-Theora" class="headerlink" title="Ogg/Theora"></a>Ogg/Theora</h4><p><img src="/2024/04/19/web视频播放浅析/4.png" alt="img"></p><h4 id="MPEG-4-H-264"><a href="#MPEG-4-H-264" class="headerlink" title="MPEG-4/H.264"></a>MPEG-4/H.264</h4><p><img src="/2024/04/19/web视频播放浅析/5.png" alt="img"></p><h2 id="常见视频播放方法"><a href="#常见视频播放方法" class="headerlink" title="常见视频播放方法"></a>常见视频播放方法</h2><h3 id="基础方式"><a href="#基础方式" class="headerlink" title="基础方式"></a>基础方式</h3><p>使用<code>video</code>标签，<code>src</code>直接链接到一个完整的视频地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;video-basic&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      #video &#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        margin: 20px auto;</span><br><span class="line">        display: block;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;video id=&quot;video&quot; controls autoplay&gt;</span><br><span class="line">        &lt;source src=&quot;http://127.0.0.1:3000/video1.mp4&quot; type=&quot;&quot;&gt;</span><br><span class="line">      &lt;/video&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>这个例子是最基础最简单的。<br><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/basic-usage" target="_blank" rel="noopener">源码</a></p><h3 id="video-stream方式"><a href="#video-stream方式" class="headerlink" title="video-stream方式"></a>video-stream方式</h3><p>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;data:,&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Streaming&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        background-color: #000000;</span><br><span class="line">      &#125;</span><br><span class="line">      video &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        max-height: 100%;</span><br><span class="line">        max-width: 100%;</span><br><span class="line">        margin: auto;</span><br><span class="line">        object-fit: contain;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;video </span><br><span class="line">      src=&quot;http://localhost:3000/api/video/video.mp4&quot;</span><br><span class="line">      playsInline</span><br><span class="line">      muted</span><br><span class="line">      autoplay</span><br><span class="line">      controls </span><br><span class="line">      controlsList=&quot;nodownload&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>后端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">import Koa from &apos;koa&apos;</span><br><span class="line">import KoaRouter from &apos;koa-router&apos;</span><br><span class="line">import sendFile from &apos;koa-sendfile&apos;</span><br><span class="line">import url from &apos;url&apos;</span><br><span class="line">import path from &apos;path&apos;</span><br><span class="line">import fs from &apos;fs&apos;</span><br><span class="line">import util from &apos;util&apos;</span><br><span class="line"></span><br><span class="line">const __filename = url.fileURLToPath(import.meta.url)</span><br><span class="line">const __dirname = path.dirname(__filename)</span><br><span class="line"></span><br><span class="line">const PORT = parseInt(process.env.PORT, 10) || 3000</span><br><span class="line">const app = new Koa()</span><br><span class="line">const router = new KoaRouter()</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Serve HTML page containing the video player</span><br><span class="line">//</span><br><span class="line">router.get(&apos;/&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">    await sendFile(ctx, path.resolve(__dirname, &apos;public&apos;, &apos;index.html&apos;))</span><br><span class="line"></span><br><span class="line">    if (!ctx.status) &#123;</span><br><span class="line">        ctx.throw(404)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Serve video streaming</span><br><span class="line">//</span><br><span class="line">router.get(&apos;/api/video/:name&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; name &#125; = ctx.params</span><br><span class="line"></span><br><span class="line">    if (</span><br><span class="line">        !/^[a-z0-9-_ ]+\.mp4$/i.test(name)</span><br><span class="line">    ) &#123;</span><br><span class="line">        return next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; request, response &#125; = ctx</span><br><span class="line">    const &#123; range &#125; = request.headers</span><br><span class="line"></span><br><span class="line">    if (!range) &#123;</span><br><span class="line">        ctx.throw(400, &apos;Range not provided&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const videoPath = path.resolve(__dirname, &apos;videos&apos;, name)</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        await util.promisify(fs.access)(videoPath)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        if (err.code === &apos;ENOENT&apos;) &#123;</span><br><span class="line">            ctx.throw(404)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ctx.throw(err.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Calculate start Content-Range</span><br><span class="line">    //</span><br><span class="line">    const parts = range.replace(&apos;bytes=&apos;, &apos;&apos;).split(&apos;-&apos;)</span><br><span class="line">    const rangeStart = parts[0] &amp;&amp; parts[0].trim()</span><br><span class="line">    const start = rangeStart ? parseInt(rangeStart, 10) : 0</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Calculate video size and chunk size</span><br><span class="line">    //</span><br><span class="line">    const videoStat = await util.promisify(fs.stat)(videoPath)</span><br><span class="line">    const videoSize = videoStat.size</span><br><span class="line">    const chunkSize = 10 ** 6 // 1mb</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Calculate end Content-Range</span><br><span class="line">    //</span><br><span class="line">    // Safari/iOS first sends a request with bytes=0-1 range HTTP header</span><br><span class="line">    // probably to find out if the server supports byte ranges</span><br><span class="line">    //</span><br><span class="line">    const rangeEnd = parts[1] &amp;&amp; parts[1].trim()</span><br><span class="line">    const __rangeEnd = rangeEnd ? parseInt(rangeEnd, 10) : undefined</span><br><span class="line">    const end = __rangeEnd === 1 ? __rangeEnd : (Math.min(start + chunkSize, videoSize) - 1) // We remove 1 byte because start and end start from 0</span><br><span class="line">    const contentLength = end - start + 1 // We add 1 byte because start and end start from 0</span><br><span class="line"></span><br><span class="line">    response.set(&apos;Content-Range&apos;, `bytes $&#123;start&#125;-$&#123;end&#125;/$&#123;videoSize&#125;`)</span><br><span class="line">    response.set(&apos;Accept-Ranges&apos;, &apos;bytes&apos;)</span><br><span class="line">    response.set(&apos;Content-Length&apos;, contentLength)</span><br><span class="line"></span><br><span class="line">    const stream = fs.createReadStream(videoPath, &#123; start, end &#125;)</span><br><span class="line">    stream.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">        console.log(err.toString())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    response.status = 206</span><br><span class="line">    response.type = path.extname(name)</span><br><span class="line">    response.body = stream</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// We ignore ECONNRESET, ECANCELED and ECONNABORTED errors</span><br><span class="line">// because when the browser closes the connection, the server</span><br><span class="line">// tries to read the stream. So, the server says that it cannot</span><br><span class="line">// read a closed stream.</span><br><span class="line">//</span><br><span class="line">app.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">    if (![&apos;ECONNRESET&apos;, &apos;ECANCELED&apos;, &apos;ECONNABORTED&apos;].includes(err.code)) &#123;</span><br><span class="line">        console.log(err.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Add Koa Router middleware</span><br><span class="line">//</span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Start the server on the specified PORT</span><br><span class="line">//</span><br><span class="line">app.listen(PORT)</span><br><span class="line">console.log(&apos;Video Streaming Server is running on Port&apos;, PORT)</span><br></pre></td></tr></table></figure></p><p>可以看出，前端部分的代码跟第一个例子一样，直接给<code>video</code>标签的<code>src</code>一个视频链接地址，但是这个地址指向后台一个api接口。<br><code>video</code>标签默认会在请求头加上<code>Content-Range</code>属性，后端接口会根据这个属性去返回对应的数据。对于前端开发来说是无感的，因为浏览器已经自动完成了，只需要对后端接口做处理即可。<br><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/video-streaming" target="_blank" rel="noopener">源码</a></p><h3 id="mediaSource方式"><a href="#mediaSource方式" class="headerlink" title="mediaSource方式"></a>mediaSource方式</h3><p>这个方式用到了MediaSource这个API，允许JavaScript创建和处理媒体数据源，使得浏览器能够播放来自各种来源的自定义媒体数据，而不是只限于原始的文件或 URL。<br>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;video id=&quot;video&quot; width=&quot;800&quot; height=&quot;400&quot; webkit-playsinline=&quot;true&quot; controls playsinline=&quot;true&quot; type=&quot;video/mp4&quot; muted x5-video-player-type=&quot;h5&quot; &gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var PostbirdMp4ToBlob = &#123;</span><br><span class="line">        mediaSource:new MediaSource(),</span><br><span class="line">        // 检查是否支持 MediaSource 或者 mimeCodec</span><br><span class="line">        checkSupported: function (cb) &#123;</span><br><span class="line">            if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(this.mimeCodec)) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.video.src  = assetUrl; // 如果不支持，则直接将 src 修改成原始的url，保证兼容性</span><br><span class="line">                console.error(&apos;Unsupported MediaSource or unsupported MIME type or codec: &apos;, this.mimeCodec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 初始化 selector / assetUrl / mimeCodec / autoPlay</span><br><span class="line">        // selector：video的选择器 exp: &apos;#video&apos;</span><br><span class="line">        // assetUrl: video的请求地址 exp : &apos;./v.mp4&apos;</span><br><span class="line">        // mimeCodec: 编码模式  exp:  &apos;video/mp4; codecs=&quot;avc1.640028, mp4a.40.2&quot;&apos;</span><br><span class="line">        init: function (selector, assetUrl, mimeCodec) &#123;</span><br><span class="line">            this.video = document.querySelector(selector); // 获取vide dom</span><br><span class="line">            this.assetUrl = assetUrl;</span><br><span class="line">            this.mimeCodec = mimeCodec;</span><br><span class="line">            this.checkSupported();</span><br><span class="line">            this.start();// 开启</span><br><span class="line">        &#125;,</span><br><span class="line">        start: function () &#123;</span><br><span class="line">            console.log(this.mediaSource.readyState); // closed </span><br><span class="line">            this.video.src = URL.createObjectURL(this.mediaSource);</span><br><span class="line">            this.mediaSource.addEventListener(&apos;sourceopen&apos;, this.sourceOpen.bind(this));// bind(this) 保证回调</span><br><span class="line">        &#125;,</span><br><span class="line">        // MediaSource sourceopen 事件处理</span><br><span class="line">        sourceOpen: function (_) &#123;</span><br><span class="line">            var _this = this;</span><br><span class="line">            console.log(this.mediaSource.readyState); // open</span><br><span class="line">            var sourceBuffer = this.mediaSource.addSourceBuffer(this.mimeCodec);</span><br><span class="line">            this.fetchAB(this.assetUrl, function (buf) &#123;</span><br><span class="line">                sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123;</span><br><span class="line">                    _this.mediaSource.endOfStream();// 结束</span><br><span class="line">                    _this.video.play(); // 播放视频</span><br><span class="line">                    console.log(_this.mediaSource.readyState); // ended</span><br><span class="line">                &#125;);</span><br><span class="line">                sourceBuffer.appendBuffer(buf);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        // 基于 XHR 的简单封装</span><br><span class="line">        // arguments - url </span><br><span class="line">        // arguments - cb (回调函数)</span><br><span class="line">        fetchAB: function (url, cb) &#123;</span><br><span class="line">            var xhr = new XMLHttpRequest;</span><br><span class="line">            xhr.open(&apos;get&apos;, url);</span><br><span class="line">            xhr.responseType = &apos;arraybuffer&apos;;</span><br><span class="line">            xhr.onload = function () &#123;</span><br><span class="line">                cb(xhr.response);</span><br><span class="line">            &#125;;</span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var codec = &apos;video/mp4; codecs=&quot;avc1.42e01e, mp4a.40.2&quot;&apos;;</span><br><span class="line">        PostbirdMp4ToBlob.init(&apos;#video&apos;, &apos;/video/video1.mp4&apos;, codec);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>后端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const Router = require(&apos;koa-router&apos;);</span><br><span class="line">const static = require(&apos;koa-static&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;).promises;</span><br><span class="line"></span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const router = new Router();</span><br><span class="line"></span><br><span class="line">app.use(static(&apos;./static&apos;));</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(8080, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;server is run at 8080......&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后端是一个静态资源服务器</p><blockquote><p>这里需要注意下，用MediaSource接口来播放视频，对视频文件是有要求的，目前例子中的mp4文件可以播放，但是笔者试了很多方式来转换其它的视频文件都没有成功，目前也在尝试中。</p></blockquote><p><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/media-source" target="_blank" rel="noopener">源码</a></p><h3 id="m3u8-Hls方式"><a href="#m3u8-Hls方式" class="headerlink" title="m3u8 Hls方式"></a>m3u8 Hls方式</h3><p>.m3u8文件本质上是一个索引文件，其中包含了指向一系列多媒体片段（通常是经过加密或未加密的TS格式文件）的URL列表。<br>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;video-m3u8&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;video-list&quot;&gt;</span><br><span class="line">        &lt;div&gt;播放列表&lt;/div&gt;</span><br><span class="line">        &lt;ul&gt;&lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;video id=&quot;video&quot; controls autoplay&gt;&lt;/video&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &apos;./style.css&apos;;</span><br><span class="line">import Hls from &apos;hls.js&apos;;</span><br><span class="line">var video = document.getElementById(&apos;video&apos;);</span><br><span class="line">var videoList = [&apos;video1&apos;, &apos;video2&apos;, &apos;video3&apos;, &apos;video4&apos;, &apos;video5&apos;];</span><br><span class="line">// 创建buttons并插入dom</span><br><span class="line">var nUl = document.querySelector(&apos;.video-list ul&apos;);</span><br><span class="line">videoList.forEach(item=&gt; &#123;</span><br><span class="line">  var nLi= document.createElement(&apos;li&apos;);</span><br><span class="line">  var nBtn= document.createElement(&apos;button&apos;);</span><br><span class="line">  nBtn.textContent = item;</span><br><span class="line">  nLi.appendChild(nBtn);</span><br><span class="line">  nUl.appendChild(nLi);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">playVideo(videoList[0]);</span><br><span class="line"></span><br><span class="line">// 按钮添加事件</span><br><span class="line">var buttons = document.querySelectorAll(&apos;.video-list button&apos;);</span><br><span class="line">for(let btn of buttons) &#123;</span><br><span class="line">  btn.onclick = (evt)=&gt; &#123;</span><br><span class="line">    let videoName = evt.target.textContent;</span><br><span class="line">    playVideo(videoName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 播放video</span><br><span class="line">function playVideo(videoName) &#123;</span><br><span class="line">  if (Hls.isSupported()) &#123;</span><br><span class="line">    var hls = new Hls();</span><br><span class="line">    hls.loadSource(&apos;http://127.0.0.1:3000/&apos;+videoName+&apos;.m3u8&apos;);</span><br><span class="line">    hls.attachMedia(video);</span><br><span class="line">    hls.on(Hls.Events.MANIFEST_PARSED, function () &#123;</span><br><span class="line">      // video.play();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else if (video.canPlayType(&apos;application/vnd.apple.mpegurl&apos;)) &#123;</span><br><span class="line">    video.src = &apos;http://127.0.0.1:3000/&apos;+videoName+&apos;.m3u8&apos;;</span><br><span class="line">    video.addEventListener(&apos;loadedmetadata&apos;, function () &#123;</span><br><span class="line">      // video.play();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>js文件中需要<code>hls.js</code>库。</p><blockquote><p>hls.js 是一个开源的JavaScript库，专为解决在现代Web浏览器上播放基于HTTP Live Streaming (HLS)协议的视频内容而设计。HLS协议由苹果公司开发，被广泛用于在网络上分发实时和点播视频内容，尤其适用于移动端和桌面设备。<br>HLS协议的工作原理是将长视频文件切割成一系列小的媒体片段（通常为MPEG-2 Transport Stream格式，扩展名为.ts），并通过一个M3U8索引文件来组织这些片段。M3U8文件包含了指向各个视频片段的URL以及元数据，如分辨率、编码类型等信息。</p></blockquote><p><code>video.src = &#39;http://127.0.0.1:3000/&#39;+videoName+&#39;.m3u8&#39;</code>这段代码是指向一个<code>.m3u8</code>的文件，这个文件怎么生成的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// creatM3u8.js</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const fluentFFmpeg = require(&apos;fluent-ffmpeg&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">// 输入文件夹</span><br><span class="line">const inputFolder = path.resolve(__dirname, &apos;./sourceVideos&apos;);</span><br><span class="line">// 输入文件夹下的所有视频文件list</span><br><span class="line">const files = fs.readdirSync(inputFolder);</span><br><span class="line"></span><br><span class="line">// 输出目录，用于保存生成的 TS 文件和 M3U8 索引文件</span><br><span class="line">const outputDir = path.resolve(__dirname, &apos;./public&apos;);</span><br><span class="line">// FfmpegCommand实例变量</span><br><span class="line">let command;</span><br><span class="line">// 删除文件夹内容</span><br><span class="line">deleteFolderRecursiveSync(outputDir);</span><br><span class="line">// 循环files文件列表，逐个转换</span><br><span class="line">(async ()=&gt; &#123;</span><br><span class="line">  for(let file of files) &#123;</span><br><span class="line">    // 创建一个 FfmpegCommand 实例</span><br><span class="line">    command = fluentFFmpeg();</span><br><span class="line">    await creatVideos(file);</span><br><span class="line">    console.log(&apos;-----完成转换&apos;+file+&apos;-----&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">function creatVideos(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject )=&gt; &#123;</span><br><span class="line">    console.log(&apos;-----开始转换&apos;+file+&apos;-----&apos;);</span><br><span class="line">    const basenameWithExt = path.basename(file);</span><br><span class="line">    const extname = path.extname(basenameWithExt);</span><br><span class="line">    const fileNameWithoutExt = basenameWithExt.slice(0, -extname.length);</span><br><span class="line">    // 设置输出目录和 HLS 参数</span><br><span class="line">    command.input(`$&#123;inputFolder&#125;/$&#123;file&#125;`)</span><br><span class="line">    .output(`$&#123;outputDir&#125;/$&#123;fileNameWithoutExt&#125;.m3u8`)</span><br><span class="line">    .outputOptions([</span><br><span class="line">      &apos;-hls_time 10&apos;, // 每个切片时长为 10 秒</span><br><span class="line">      &apos;-hls_list_size 0&apos;, // 不限制播放列表的大小（无限循环）</span><br><span class="line">      `-hls_segment_filename $&#123;outputDir&#125;/$&#123;file&#125;_%03d.ts`, // 指定切片文件命名规则</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    // 执行转换过程</span><br><span class="line">    command</span><br><span class="line">    .on(&apos;progress&apos;, function(progress) &#123;</span><br><span class="line">      let per = parseInt(progress.percent || 0);</span><br><span class="line">      console.log(&apos;转换进度: &apos; + per + &apos;%&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      // console.log(&apos;HLS 转换完成！&apos;);</span><br><span class="line">      resolve(file);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">      console.error(&apos;An error occurred: &apos; + err.message);</span><br><span class="line">    &#125;)</span><br><span class="line">    .run();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 删除文件夹内容</span><br><span class="line">function deleteFolderRecursiveSync(folderPath) &#123;</span><br><span class="line">  if (!fs.existsSync(folderPath)) return;</span><br><span class="line"></span><br><span class="line">  const files = fs.readdirSync(folderPath);</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    const filePath = path.join(folderPath, files[i]);</span><br><span class="line"></span><br><span class="line">    if (fs.lstatSync(filePath).isDirectory()) &#123;</span><br><span class="line">      // 如果是子目录，则递归删除</span><br><span class="line">      deleteFolderRecursiveSync(filePath);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果是文件，则直接删除</span><br><span class="line">      fs.unlinkSync(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个文件读取目录<code>sourceVideos</code>文件夹下的mp4文件，并且分成n个视频片段和.m3u8文件，保存到了public目录下。<br>public目录是一个静态资源服务器文件夹，前端<code>hls.js</code>库会拿到<code>m3u8</code>文件，解析文件内容，加载视频片段并播放。<br><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/m3u8" target="_blank" rel="noopener">源码</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上简单介绍并列举了几种<code>video</code>标签在web视频播放中的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的介绍html中video标签的几种使用场景,注意，视频播放是点播形式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>npm安装不同版本的一个包</title>
    <link href="/2024/03/18/npm%E5%AE%89%E8%A3%85%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8C%85/"/>
    <id>/2024/03/18/npm安装不同版本的一个包/</id>
    <published>2024-03-18T02:30:03.000Z</published>
    <updated>2024-03-18T02:44:39.992Z</updated>
    
    <content type="html"><![CDATA[<p>在同一个项目中，安装不同版本的一个包<br><a id="more"></a><br>最近在开发中遇到项目需要同时依赖echarts的4.8.0版本和5.0.0版本，有两种方法解决。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>把下载的4.8.0版本中，dist文件夹下的echarts.js文件copy出来，放到需要引入的文件夹下，比如lib。</li><li>在使用的地方直接引入就可以，如：<code>import echarts from &quot;@/lib/echarts.js&quot;</code></li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用npm安装2个版本的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save echarts@npm:echarts@4.8.0</span><br></pre></td></tr></table></figure></p><p>安装后package.json中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;echarts&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;echarts-gl&quot;: &quot;^2.0.9&quot;,</span><br><span class="line">    &quot;echarts4&quot;: &quot;npm:echarts@^4.8.0&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>可以看到，echarts是正常安装的5.0.0版本，echarts4就是安装的4.8.0版本。<br>使用的时候<code>import * as echarts from &#39;echarts4&#39;</code>就可以。<br>再有就是，笔者在项目中用到了z-render，可以这样引入<code>import * as zrender from &#39;echarts4/node_modules/zrender&#39;;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在同一个项目中，安装不同版本的一个包&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>手写动画库</title>
    <link href="/2024/02/20/%E6%89%8B%E5%86%99%E5%8A%A8%E7%94%BB%E5%BA%93/"/>
    <id>/2024/02/20/手写动画库/</id>
    <published>2024-02-20T07:03:29.000Z</published>
    <updated>2024-02-20T07:28:47.419Z</updated>
    
    <content type="html"><![CDATA[<p>简单实现一个动画库<br><a id="more"></a></p><blockquote><p>本动画库学习参考winter老师教程实现</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2024/02/20/手写动画库/1.png" alt="img"><br>通过上面的思维导图，动画库有Timeline，Animate，Easing三个类构成，对应三个文件。</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>案例代码在vite环境下构建</p><h3 id="index-html文件"><a href="#index-html文件" class="headerlink" title="index.html文件"></a>index.html文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Vite App&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      #el1 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">      &#125;</span><br><span class="line">      #el2 &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: rgb(13, 50, 146);</span><br><span class="line">      &#125;</span><br><span class="line">      .btns &#123;</span><br><span class="line">        margin-top: 50px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;el1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;el2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;btns&quot;&gt;</span><br><span class="line">      &lt;button id=&quot;startBtn&quot;&gt;start&lt;/button&gt;</span><br><span class="line">      &lt;button id=&quot;pauseBtn&quot;&gt;pause&lt;/button&gt;</span><br><span class="line">      &lt;button id=&quot;resumeBtn&quot;&gt;resume&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="main-js文件"><a href="#main-js文件" class="headerlink" title="main.js文件"></a>main.js文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import animate, &#123; Linear, QuadraticIn, QuinticIn &#125; from &quot;./animate&quot;;</span><br><span class="line">// 使用方法</span><br><span class="line">// 获取时间线的实例</span><br><span class="line">let tl = animate();</span><br><span class="line">// 向时间线中加入动画实例</span><br><span class="line">tl.add(&#123;</span><br><span class="line">  el: &apos;#el1&apos;, // 动画元素，可以是string或dom元素</span><br><span class="line">  property: &apos;transform&apos;, // 动画的属性</span><br><span class="line">  startValue: 0, // 动画初始值</span><br><span class="line">  endValue: 500, // 动画的结束值</span><br><span class="line">  duration: 2, // 动画持续时间 秒单位</span><br><span class="line">  delay: 0, // 动画的延迟 秒单位</span><br><span class="line">  timingFunction: QuadraticIn, // 动画的移动效果，可以查看Easing.js文件</span><br><span class="line">  template: v=&gt; `translate($&#123;v&#125;px)`, // 动画执行的每一帧，返给属性加工后得知，比如返回“500px”等</span><br><span class="line">  startTime: new Date(&apos;2024-2-20 9:36:00&apos;), // 可以指定具体的时间让动画执行</span><br><span class="line">  loop: &apos;reverse&apos;, // 动画是否循环 loop值真时正常动画 reverse反向动画</span><br><span class="line">&#125;);</span><br><span class="line">// 下面是对同一个元素el2的两个属性添加动画效果</span><br><span class="line">tl.add(&#123;</span><br><span class="line">  el: &apos;#el2&apos;,</span><br><span class="line">  property: &apos;top&apos;, </span><br><span class="line">  startValue: 0, </span><br><span class="line">  endValue: 500, </span><br><span class="line">  duration: 2, </span><br><span class="line">  delay: 0, </span><br><span class="line">  timingFunction: Linear, </span><br><span class="line">  template: v=&gt; `$&#123;v&#125;px`,</span><br><span class="line">  loop: true</span><br><span class="line">&#125;);</span><br><span class="line">tl.add(&#123;</span><br><span class="line">  el: &apos;#el2&apos;,</span><br><span class="line">  property: &apos;left&apos;, </span><br><span class="line">  startValue: 0, </span><br><span class="line">  endValue: 500, </span><br><span class="line">  duration: 2, </span><br><span class="line">  delay: 0, </span><br><span class="line">  timingFunction: Linear, </span><br><span class="line">  template: v=&gt; `$&#123;v&#125;px`,</span><br><span class="line">  loop: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 按钮事件</span><br><span class="line">document.querySelector(&apos;#startBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">  tl.start();</span><br><span class="line">&#125;, false);</span><br><span class="line">// document.querySelector(&apos;#resetBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">//   tl.reset();</span><br><span class="line">// &#125;, false);</span><br><span class="line">document.querySelector(&apos;#pauseBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">  tl.pause();</span><br><span class="line">&#125;, false);</span><br><span class="line">document.querySelector(&apos;#resumeBtn&apos;).addEventListener(&apos;click&apos;, ev=&gt; &#123;</span><br><span class="line">  tl.resume();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/%E5%8A%A8%E7%94%BB%E5%BA%93/animate" target="_blank" rel="noopener">sourceCode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单实现一个动画库&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="手写" scheme="/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>npm link</title>
    <link href="/2024/02/18/npm-link/"/>
    <id>/2024/02/18/npm-link/</id>
    <published>2024-02-18T03:15:29.000Z</published>
    <updated>2024-02-18T06:05:45.427Z</updated>
    
    <content type="html"><![CDATA[<p>npm link用法<br><a id="more"></a></p><h2 id="本地调试用"><a href="#本地调试用" class="headerlink" title="本地调试用"></a>本地调试用</h2><p>假设要开发一个工具库，可以供多个项目使用。<br>一种方法是发布到npm仓库中去，使用的时候，直接<code>npm i moduleName</code>,但是，这种方式不利于开发时候使用，每次改动都需要发布，其它依赖的项目还要更新依赖包，非常麻烦。<br>另一种方法是使用<code>npm link</code>,在命令行下<code>npm link --help</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm link (in package dir)</span><br><span class="line">npm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]</span><br><span class="line"></span><br><span class="line">alias: ln</span><br></pre></td></tr></table></figure></p><h3 id="具体的使用示例"><a href="#具体的使用示例" class="headerlink" title="具体的使用示例:"></a>具体的使用示例:</h3><p>1.在&lt;工具库&gt;目录下，使用<code>npm link</code>命令，会根据目录下的package.json文件，将项目名称和入口文件，软连接到nodejs的全局环境下。可以使用<code>npm ls --global --depth 0</code>命令查看当前全局都有哪些包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\nodejs -&gt; .\</span><br><span class="line">+-- corepack@0.10.0</span><br><span class="line">+-- hexo-cli@4.3.1</span><br><span class="line">+-- http-server@14.1.1</span><br><span class="line">+-- nodemon@3.0.2</span><br><span class="line">+-- npm@8.1.2</span><br><span class="line">+-- pnpm@8.15.1</span><br><span class="line">`-- simple-mind-map@0.9.7 -&gt; .\..\..\..\jinux\test\思维导图\mind-map-main\simple-mind-map</span><br></pre></td></tr></table></figure></p><p>上面是笔者nodejs全局下的包，只有<a href="mailto:simple-mind-map@0.9.7" target="_blank" rel="noopener">simple-mind-map@0.9.7</a>这个包是通过<code>npm link</code>软连接生成的，其他的都是npm全局安装的。<br>2.利用<code>npm link</code>生成软链接后，在需要引用&lt;工具库&gt;的项目目录下执行<code>npm link &lt;工具库名称&gt;</code>,这时在node_modules下就安装了这个工具库，而且是指向前面生成的软连接。<br>3.按照步骤2的方式，可以在多个项目中这样使用。当更改&lt;工具库&gt;代码后，其它引用这个依赖的项目也会自动更改。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><ul><li>如果不需要依赖&lt;工具库&gt;时，可以在项目目录下执行<code>npm unlink &lt;工具库名称&gt;</code>。</li><li>全局删除软连接，<code>npm rm --global &lt;工具库名称&gt;</code>，有时候软链接可能删除了，但是还能使用,可以进入到nodejs全局安装的目录手动把这个包删除。</li></ul><h3 id="实际工作中的小技巧"><a href="#实际工作中的小技巧" class="headerlink" title="实际工作中的小技巧"></a>实际工作中的小技巧</h3><p>比如，&lt;工具库&gt;这个包已经发布到npm上了，本地又有很多项目依赖，如果想每次发布这个包后，所有项目都跟着更新，步骤如下：</p><ul><li>全局安装&lt;工具库&gt;这个包,<code>npm i &lt;工具库名称&gt; -g</code>.</li><li>在依赖&lt;工具库&gt;这个包的项目下，执行<code>npm link &lt;工具库名称&gt;</code>.</li><li>全局更新包<code>npm update &lt;工具库名称&gt; -g</code>,所有link这个包的项目都会更新.</li></ul><p>刚开始笔者也有疑问,全局安装的包不是在哪里都可以使用吗?为什么还要<code>link</code>呢?其实,<code>npm i -g moduleName</code>是将模块安装到全局目录下,但是只能在命令行下使用,项目代码中想require引用的话,还需要<code>npm link</code>后才能使用.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm link用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="调试" scheme="/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅析npm参数init,create,exec</title>
    <link href="/2024/01/17/%E6%B5%85%E6%9E%90npm%E5%8F%82%E6%95%B0init-create-exec/"/>
    <id>/2024/01/17/浅析npm参数init-create-exec/</id>
    <published>2024-01-17T05:11:33.000Z</published>
    <updated>2024-01-17T06:07:51.209Z</updated>
    
    <content type="html"><![CDATA[<p>npm [init,create,exec,innit],npx的使用<br><a id="more"></a></p><h2 id="npm-exec"><a href="#npm-exec" class="headerlink" title="npm exec"></a>npm exec</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// pkg是包名</span><br><span class="line">npm exec &lt;pkg&gt;</span><br><span class="line">// 还有一种简写形式</span><br><span class="line">// npm官方文档中指出x,其实就是exec的别名,npm exec、npm x,两个命令是完全等价的。</span><br><span class="line">npm x &lt;pkg&gt;</span><br></pre></td></tr></table></figure><h3 id="npm-exec-lt-pkg-gt-的执行流程"><a href="#npm-exec-lt-pkg-gt-的执行流程" class="headerlink" title="npm exec &lt;pkg&gt;的执行流程"></a><code>npm exec &lt;pkg&gt;</code>的执行流程</h3><ul><li>在本地查找是否有<code>&lt;pkg&gt;</code>对应的<code>npm</code>包,若找到,则运行这个包的<code>package.json</code>中<code>bin</code>字段对应的可执行文件,若未找到,在远程<code>npm</code>仓库查找是否有<code>&lt;pkg&gt;</code>对应的<code>npm</code>包,若找到,则下载到本地,下载完成后运行这个包<code>package.json</code>中<code>bin</code>字段对应的可执行文件。</li><li>在执行<code>bin</code>字段有几点注意的,如果<code>bin</code>只有一个入口,那么可以执行,如果<code>bin</code>有多个入口,则寻找和包名一样的那个入口,如果没找到,则<code>npm exec &lt;pkg&gt;</code>报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create-vite这个npm包的package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;create-vite&quot;</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line">      &quot;create-vite&quot;: &quot;index.js&quot;,</span><br><span class="line">      &quot;cva&quot;: &quot;index.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="npm-exec-lt-pkg-gt-的执行案例"><a href="#npm-exec-lt-pkg-gt-的执行案例" class="headerlink" title="npm exec &lt;pkg&gt;的执行案例"></a><code>npm exec &lt;pkg&gt;</code>的执行案例</h3><p>以<code>create-vite</code>这个包为例子<br>执行<code>npm exec crate-vite</code>这条命令后,首先本地查找是否有<code>create-vite</code>这个<code>npm</code>包,找到,则运行<code>create-vite</code>这个<code>npm</code>包中的<code>package.json</code>中<code>bin</code>字段对应的可执行文件,即<code>index.js</code>这个文件。若未找到,在远程<code>npm</code>仓库查找是否有<code>create-vite</code>这个包,如果有,则下载到本地,并执行<code>package.json</code>中<code>bin</code>字段对应的可执行文件。</p><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p><code>npm</code>文档中提到：<code>npx</code>的二进制文件在<code>npm v7.0.0</code>中被重写,而独立的<code>npx</code>包在当时已弃用。<code>npx</code>使用<code>npm exec</code>命令,而不是单独的参数解析器和安装过程。并提供了一些支持,以保持与它在以前版本中接受的参数的向后兼容性。<br>因此:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx = npm exec</span><br><span class="line">npx = npm x</span><br></pre></td></tr></table></figure></p><p>所以上面的<code>npm exec create-vite</code>也可以使用<code>npx create-vite</code>去执行</p><h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm init &lt;initializer&gt;</span><br></pre></td></tr></table></figure><h3 id="无initializer"><a href="#无initializer" class="headerlink" title="无initializer"></a>无initializer</h3><p>后面没有<code>&lt;initializer&gt;</code>是用来创建package.json文件</p><h3 id="有initializer"><a href="#有initializer" class="headerlink" title="有initializer"></a>有initializer</h3><p>这里的<code>npm init &lt;initializer&gt;</code>实际会调用<code>npm exec create-&lt;initializer&gt;</code>, 也相当于<code>npx create-&lt;initializer&gt;</code>。<br>比如在使用vite时,<code>npm init vite</code>,实际是执行<code>npm exec create-vite</code></p><h2 id="npm-create-npm-innit"><a href="#npm-create-npm-innit" class="headerlink" title="npm create,npm innit"></a>npm create,npm innit</h2><p><code>npm</code>官方文档中指出<code>create,innit</code>其实就是<code>init</code>的别名,也就是说<code>npm init,npm create,npm innit</code>三个命令是完全等价的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm [init,create,exec,innit],npx的使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="nodejs" scheme="/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>软件工程中的版本管理</title>
    <link href="/2024/01/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>/2024/01/02/软件工程中的版本管理/</id>
    <published>2024-01-02T02:15:42.000Z</published>
    <updated>2024-01-11T07:00:59.285Z</updated>
    
    <content type="html"><![CDATA[<p>简单的介绍软件工程中的版本管理<br><a id="more"></a></p><h2 id="版本号的类型"><a href="#版本号的类型" class="headerlink" title="版本号的类型"></a>版本号的类型</h2><p>在软件开发中，版本（version）是指软件发布的不同版本或版本号。版本号通常由数字和字母组成，用于标识软件发布的时间、功能、修复的漏洞等信息。其中，一些常见的版本号命名包括：</p><ul><li>Alpha 版本：Alpha 版本通常是软件开发的早期版本，包含有限的功能，可能存在许多漏洞和问题，仅供开发人员进行内部测试和调试使用。</li><li>Beta 版本：Beta 版本是相对于 Alpha 版本而言的，通常包含更多的功能和修复了一些漏洞和问题，但仍然可能存在一些问题和缺陷。Beta 版本通常会发布给一些有限的测试用户或公众进行测试和反馈。</li><li>Release Candidate (RC) 版本：RC 版本是指预发布的版本，通常是最终版本发布之前的最后一个版本。RC 版本通常包含所有预计的功能和修复的漏洞，但仍然需要进行测试和反馈，以确保最终版本的质量和稳定性。</li><li>Stable 版本：Stable 版本是指最终发布的稳定版本，通常包含所有功能和修复的漏洞，经过了充分的测试和反馈，具有较高的质量和稳定性。</li></ul><h2 id="版本日期与时间命名的方式"><a href="#版本日期与时间命名的方式" class="headerlink" title="版本日期与时间命名的方式"></a>版本日期与时间命名的方式</h2><ul><li>Major.Minor.Patch：这种版本号命名方式通常由三个部分组成，例如 1.2.3，分别表示主版本号、次版本号和修订号。主版本号通常表示大的功能更新和重大变更，次版本号通常表示小的功能更新和优化，修订号通常表示修复的漏洞和问题。</li><li>Year.Month：这种版本号命名方式通常由两个部分组成，例如 2022.01，表示软件发布的年份和月份。这种命名方式通常用于一些周期性更新的软件。</li><li>Codename：这种版本号命名方式通常使用一个有意义的名称来代替版本号，例如 Ubuntu 发布的版本号通常使用一个动物名字来代替，例如 Ubuntu 22.04 LTS 的版本号为 “Jammy Jellyfish”。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>一个版本号的例子可以是 3.1.2-beta。其中，3 表示主版本号，1 表示次版本号，2 表示修订号，beta 表示预发布版本。这个版本号可以理解为软件发布的第三个主要版本，第一次次要更新，第二次修订更新，现在处于 beta 预发布阶段</li><li>一个包含版本号和时间戳的完整版本号可能如下所示：3.1.2-beta.202307151200，其中，202307151200 表示的是版本发布的时间，格式为年月日小时分钟。这个版本号可以表示一个预发布版本，在 2023 年 7 月 15 日 12:00 发布的第三个主要版本，第一次次要更新，第二次修订更新。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的介绍软件工程中的版本管理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>svg转canvas</title>
    <link href="/2023/10/12/svg%E8%BD%ACcanvas/"/>
    <id>/2023/10/12/svg转canvas/</id>
    <published>2023-10-12T02:34:12.000Z</published>
    <updated>2024-01-11T07:00:59.230Z</updated>
    
    <content type="html"><![CDATA[<p>svg转canvas小例子<br><a id="more"></a></p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;svg2canvas&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;svg-wrap&quot;&gt;</span><br><span class="line">        &lt;svg width=&quot;200&quot; height=&quot;200&quot; xmlns=&apos;http://www.w3.org/2000/svg&apos;&gt;</span><br><span class="line">            &lt;rect width=&quot;200&quot; height=&quot;200&quot; style=&quot;fill:#b44a4a&quot;&gt;&lt;/rect&gt;</span><br><span class="line">            &lt;text x=&quot;15&quot; y=&quot;50&quot; fill=&quot;#ffffff&quot;&gt;中文显示&lt;/text&gt;</span><br><span class="line">        &lt;/svg&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      window.onload = function()&#123;</span><br><span class="line">        //获取svg内容</span><br><span class="line">        var svg = document.getElementById(&apos;svg-wrap&apos;).innerHTML;</span><br><span class="line">        var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">        var c = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        //新建Image对象</span><br><span class="line">        var img = new Image();    </span><br><span class="line">        // 转换重点在这里</span><br><span class="line">        //svg编码成base64</span><br><span class="line">        img.src = &apos;data:image/svg+xml;base64,&apos; + window.btoa(unescape(encodeURIComponent(svg)));//svg内容中可以有中文字符</span><br><span class="line">        // img.src = &apos;data:image/svg+xml;base64,&apos; + window.btoa(svg);//svg内容中不能有中文字符</span><br><span class="line">        //图片初始化完成后调用</span><br><span class="line">        img.onload = function() &#123;</span><br><span class="line">          //将canvas的宽高设置为图像的宽高</span><br><span class="line">          canvas.width = img.width;</span><br><span class="line">          canvas.height = img.height;           </span><br><span class="line">          //canvas画图片</span><br><span class="line">          c.drawImage(img, 0, 0);</span><br><span class="line">          //将图片添加到body中</span><br><span class="line">          document.body.appendChild(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用了img可以加载base64数据，将svg转成base64数据。<br>用到了unescape，encodeURIComponent函数，<a href="https://www.zhihu.com/question/21861899" target="_blank" rel="noopener">详情可参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;svg转canvas小例子&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>vue中this.$message的实现</title>
    <link href="/2023/10/10/vue%E4%B8%ADthis.$message%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>/2023/10/10/vue中this.$message的实现/</id>
    <published>2023-10-10T06:31:29.000Z</published>
    <updated>2024-04-15T02:11:10.618Z</updated>
    
    <content type="html"><![CDATA[<p>vue中全局message组件的实现<br><a id="more"></a></p><h1 id="vue3中的-message"><a href="#vue3中的-message" class="headerlink" title="vue3中的$message"></a>vue3中的$message</h1><p>element plus中message组件可以this.$message来调用，参考它实现一个简版的message组件</p><h2 id="message-vue"><a href="#message-vue" class="headerlink" title="message.vue"></a>message.vue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition</span><br><span class="line">    @before-leave=&quot;onClose&quot;</span><br><span class="line">    @after-leave=&quot;$emit(&apos;destroy&apos;)&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div </span><br><span class="line">      v-show=&quot;visible&quot;</span><br><span class="line">      :id=&quot;id&quot;</span><br><span class="line">      :style=&quot;customStyle&quot;</span><br><span class="line">      class=&quot;message-wrap&quot;</span><br><span class="line">      @mouseenter=&quot;clearTimer&quot;</span><br><span class="line">      @mouseleave=&quot;startTimer&quot;</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;slot&gt;</span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, defineProps, computed, ref, onMounted, onBeforeUnmount, watch, getCurrentInstance &#125; from &apos;vue&apos;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &apos;message&apos;,</span><br><span class="line">  props: [&apos;message&apos;, &apos;id&apos;, &apos;offset&apos;, &apos;onClose&apos;, &apos;duration&apos;],</span><br><span class="line">  emits: &#123;</span><br><span class="line">    destroy: ()=&gt; true</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    const visible = ref(true);</span><br><span class="line">    let timer = null;</span><br><span class="line">    onMounted(()=&gt; &#123;</span><br><span class="line">      startTimer();</span><br><span class="line">    &#125;);</span><br><span class="line">    onBeforeUnmount(()=&gt; &#123;</span><br><span class="line">      document.removeEventListener(&apos;keydown&apos;, keydown, false);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 开始定时器</span><br><span class="line">    const startTimer = ()=&gt; &#123;</span><br><span class="line">      // 设置定时关闭</span><br><span class="line">      timer = setTimeout(()=&gt; &#123;</span><br><span class="line">        visible.value = false;</span><br><span class="line">      &#125;, props.duration || 5000);</span><br><span class="line">    &#125;</span><br><span class="line">    // 清除定时器</span><br><span class="line">    const clearTimer = ()=&gt; &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    // 样式计算属性</span><br><span class="line">    const customStyle = computed(()=&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        top: props.offset+&apos;px&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 案件按下回调函数</span><br><span class="line">    const keydown = (&#123; code &#125;)=&gt; &#123;</span><br><span class="line">      if(code === &apos;Escape&apos;) &#123;</span><br><span class="line">        if(visible.value) &#123;</span><br><span class="line">          visible.value = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加事件</span><br><span class="line">    document.addEventListener(&apos;keydown&apos;, keydown, false);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      visible,</span><br><span class="line">      customStyle,</span><br><span class="line">      startTimer,</span><br><span class="line">      clearTimer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.message-wrap &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  width: 200px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: 10px 10px;</span><br><span class="line">  color: rgb(233, 110, 110);</span><br><span class="line">  border: 1px solid rgb(243, 122, 122);</span><br><span class="line">  background-color: rgba(243, 122, 122, .1);</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  top: 10px;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  font-size: 13px;</span><br><span class="line">  user-select: none;</span><br><span class="line">  cursor: auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这里用到了vue自带的transition组件，这里使用了before-leave和after-leave两个钩子</p><h2 id="message-js"><a href="#message-js" class="headerlink" title="message.js"></a>message.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createVNode, render &#125; from &apos;vue&apos;;</span><br><span class="line">import MessageConstructor from &apos;./message.vue&apos;;</span><br><span class="line">const instances = [];</span><br><span class="line">let seed = 1;</span><br><span class="line">const message = (options=&#123;&#125;)=&gt; &#123;</span><br><span class="line">  let verticalOffset = 10;</span><br><span class="line">  if(typeof options === &apos;string&apos;) options = &#123; message: options &#125;</span><br><span class="line">  // 用于销毁vm，也就是从dom中删除</span><br><span class="line">  options.onDestroy = ()=&gt; &#123;</span><br><span class="line">    // console.log(&apos;destroy已经调用&apos;);</span><br><span class="line">    render(null, container);</span><br><span class="line">  &#125;</span><br><span class="line">  options.onClose = ()=&gt; &#123;</span><br><span class="line">    delInstance(options.id);</span><br><span class="line">  &#125;</span><br><span class="line">  options.id = seed++; // 设置id</span><br><span class="line">  // 计算高度</span><br><span class="line">  instances.forEach(vm=&gt; &#123;</span><br><span class="line">    verticalOffset += (vm.el.offsetHeight + 10);</span><br><span class="line">  &#125;);</span><br><span class="line">  options.offset = verticalOffset;</span><br><span class="line">  const vm = createVNode(MessageConstructor, options, options.message);</span><br><span class="line">  instances.push(vm);</span><br><span class="line">  const container = document.createElement(&apos;div&apos;);</span><br><span class="line">  render(vm, container);</span><br><span class="line">  document.body.appendChild(container.firstChild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 销毁的实例从instances中删除,并重新计算offset</span><br><span class="line">// 这里需要注意，一定在transition的before-leave回调中执行</span><br><span class="line">const delInstance = (id)=&gt; &#123;</span><br><span class="line">  let idx = instances.findIndex(vm=&gt; &#123;</span><br><span class="line">    return id === vm.component.props.id;</span><br><span class="line">  &#125;);</span><br><span class="line">  const curVm = instances[idx];</span><br><span class="line">  const removedHeight = curVm.el.offsetHeight;</span><br><span class="line">  // debugger;</span><br><span class="line">  const len = instances.length;</span><br><span class="line">  for(let i=idx; i&lt;len; i++) &#123;</span><br><span class="line">    const pos = parseInt(instances[i].el.style.top, 10) - removedHeight - 10;</span><br><span class="line">    instances[i].component.props.offset = pos;</span><br><span class="line">  &#125;</span><br><span class="line">  instances.splice(idx, 1);</span><br><span class="line">&#125;</span><br><span class="line">export default message;</span><br></pre></td></tr></table></figure><p>这里是全局调用$message时的逻辑，全局创建和销毁组件。</p><h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import message from &apos;./message&apos;;</span><br><span class="line">message.install = (app) =&gt; &#123;</span><br><span class="line">  app.config.globalProperties[&apos;$message&apos;] = message;</span><br><span class="line">&#125;</span><br><span class="line">export default message;</span><br></pre></td></tr></table></figure><p>对外导出，在main.js中引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Message from &apos;./components/message/index&apos;;</span><br><span class="line">let app = createApp(App);</span><br><span class="line">app = app.use(Message);</span><br><span class="line">app = app.mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="使用-message"><a href="#使用-message" class="headerlink" title="使用$message"></a>使用$message</h2><p>vue3的setup函数中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getCurrentInstance &#125; from &apos;vue&apos;;</span><br><span class="line">const &#123; proxy &#125; = getCurrentInstance();</span><br><span class="line">proxy.$message(&apos;message组件&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是vue3中全局调用组件的实现，vue2的实现也差不多，只是在创建组件，挂载，销毁时的api写法不一样，其它基本一致。<br><a href="https://github.com/element-plus/element-plus/tree/dev/packages/components/message" target="_blank" rel="noopener">vue3-message</a><br><a href="https://github.com/ElemeFE/element/tree/dev/packages/message" target="_blank" rel="noopener">vue2-message</a></p><h1 id="vue3中使用provide-inject"><a href="#vue3中使用provide-inject" class="headerlink" title="vue3中使用provide,inject"></a>vue3中使用provide,inject</h1><p>上面使用的是<code>app.config.globalProperties[&#39;$message&#39;] = message;</code>这种方法，但是，vue3最新的api中已经淘汰了这种方法，建议使用provide,inject<br>下面是一个新的例子，vue-router也是这么实现</p><h2 id="定义插件"><a href="#定义插件" class="headerlink" title="定义插件"></a>定义插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; inject &#125; from &apos;vue&apos;</span><br><span class="line">const watermark = &#123;</span><br><span class="line">  set: () =&gt; &#123;</span><br><span class="line">     console.log(&apos;set watermark&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">   show: () =&gt; &#123;</span><br><span class="line">     console.log(&apos;show watermark&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">   hide: () =&gt; &#123;</span><br><span class="line">     console.log(&apos;hide watermark&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">   clear: () =&gt; &#123;</span><br><span class="line">     console.log(&apos;clear watermark&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">   install (app, options) &#123;</span><br><span class="line">     const watermark = this</span><br><span class="line">     app.config.globalProperties.$watermark = watermark</span><br><span class="line">     app.provide(&apos;watermark&apos;, watermark)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">const useWaterMark = function () &#123;</span><br><span class="line"> return inject(&apos;watermark&apos;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">export &#123;</span><br><span class="line"> watermark,</span><br><span class="line"> useWaterMark</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用插件"><a href="#调用插件" class="headerlink" title="调用插件"></a>调用插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   demo</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import HelloWorld from &apos;./components/HelloWorld.vue&apos;</span><br><span class="line">import &#123; getCurrentInstance &#125; from &apos;vue&apos;</span><br><span class="line">import &#123; useWaterMark &#125; from &apos;./plugin/watermark.js&apos;</span><br><span class="line">​</span><br><span class="line">const watermark = useWaterMark()</span><br><span class="line">watermark.hide()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="vue2中的-loading"><a href="#vue2中的-loading" class="headerlink" title="vue2中的$loading"></a>vue2中的$loading</h1><h2 id="loading-vue"><a href="#loading-vue" class="headerlink" title="loading.vue"></a>loading.vue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;loading-wrap&quot; v-if=&quot;loading&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;/images/loading.gif&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; loadText &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        loading: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: [&apos;loadText&apos;],</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">#loading-wrap &#123;</span><br><span class="line">    background-color: rgba(0,0,0,.7);</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    z-index: 999;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    img &#123;</span><br><span class="line">      flex-grow: 0;</span><br><span class="line">      width: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import loadVue from &apos;./loading.vue&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    let vEl; </span><br><span class="line">    Vue.prototype._showloading = function(options = &#123;&#125;) &#123;</span><br><span class="line">      vEl = new Vue(Object.assign(&#123;&#125;, loadVue, &#123;</span><br><span class="line">        propsData: &#123;</span><br><span class="line">          loadText: &apos;加载中...&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">      document.body.appendChild(vEl.$mount().$el);</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.prototype._hideloading = function() &#123;</span><br><span class="line">      document.body.removeChild(vEl.$mount().$el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue中全局message组件的实现&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>面试知识点之计算机操作系统</title>
    <link href="/2023/09/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>/2023/09/20/面试知识点之计算机操作系统/</id>
    <published>2023-09-20T08:01:05.000Z</published>
    <updated>2024-01-11T07:00:59.293Z</updated>
    
    <content type="html"><![CDATA[<p>计算机操作系统<br><a id="more"></a></p><h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p>本部分主要是笔者在学习现代操作系统和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p><h2 id="现代操作系统阅读笔记"><a href="#现代操作系统阅读笔记" class="headerlink" title="现代操作系统阅读笔记"></a>现代操作系统阅读笔记</h2><h3 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h3><h4 id="1-操作系统定义"><a href="#1-操作系统定义" class="headerlink" title="1. 操作系统定义"></a>1. 操作系统定义</h4><p>操作系统是运行在内核态的软件，它执行两个基本上独立的任务。</p><ul><li><p>隐藏计算机底层硬件的实现，为用户及应用程序提供一个资源集的清晰抽象。</p></li><li><p>管理计算机硬件资源。</p></li></ul><p>任何操作系统的核心是它可处理的系统调用集。这些系统调用集真实地说明了操作系统做的工作。</p><h4 id="2-计算机运行模式"><a href="#2-计算机运行模式" class="headerlink" title="2. 计算机运行模式"></a>2. 计算机运行模式</h4><p>多数计算机有两种运行模式：内核态和用户态。</p><p>软件中最基础的部分是操作系统，它运行在内核态。这内核态模式下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下，在用户态下，只能使用机器指令中的一个子集。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-1.png" alt="计算机运行模式"></p><h4 id="3-shell-与-GUI"><a href="#3-shell-与-GUI" class="headerlink" title="3. shell 与 GUI"></a>3. shell 与 GUI</h4><p>用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（GUI）。</p><p>它们并不是操作系统的一部分，它们是运行在用户态最低层次的用户接口程序</p><h4 id="4-对于抽象的理解"><a href="#4-对于抽象的理解" class="headerlink" title="4. 对于抽象的理解"></a>4. 对于抽象的理解</h4><p>现代计算机系统中，大量使用了抽象这一概念。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其中第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。</p><p>以抽象的角度看操作系统，它的任务就是创建好的抽象，并实现和管理它所创建的抽象。</p><h4 id="5-多路复用资源方式"><a href="#5-多路复用资源方式" class="headerlink" title="5. 多路复用资源方式"></a>5. 多路复用资源方式</h4><p>在时间上复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。</p><p>在空间上复用：每个客户得到资源的一部分。</p><h4 id="6-I-O-设备的结构"><a href="#6-I-O-设备的结构" class="headerlink" title="6. I/O 设备的结构"></a>6. I/O 设备的结构</h4><p>I/O 设备一般包括两个部分：设备控制器和设备本身。控制器插在电路板上的一块芯片或一组芯片，这块电路板物理地控制芯片，它从操作系统接收命令。</p><p>控制器的任务是为操作系统提供一个简单的接口。每类设备控制器是不同的，所以需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。为了使用设备驱动程序，必须要把设备驱动程序装入到操作系统中，这样它可在核心态中运行。</p><p>每个设备控制器都有少量的用于通信的寄存器，所有的寄存器的集合构成了I/O 空间。</p><h4 id="7-IDE-概念"><a href="#7-IDE-概念" class="headerlink" title="7. IDE 概念"></a>7. IDE 概念</h4><p>IDE 表示集成驱动电子设备，是许多计算机的磁盘标准。</p><h4 id="8-实现输入输出的三种方式"><a href="#8-实现输入输出的三种方式" class="headerlink" title="8. 实现输入输出的三种方式"></a>8. 实现输入输出的三种方式</h4><p>第一种方式，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。当 I/O 结束后，设备驱动程序把数据送到指定的地方（若有此需要），并返回。然后操作系统将控制返回给调用者。这种方式称为忙等待（busy waiting），其缺点是要占据CPU ，CPU 一直轮询设备直到对应的 I/O 操作完成。</p><p>第二种方式，设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成。</p><p>  <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-2.png" alt="终端实例"></p><p>第三种方式，为I/O使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的CPU干预。</p><h4 id="9-CMOS-存储器"><a href="#9-CMOS-存储器" class="headerlink" title="9. CMOS 存储器"></a>9. CMOS 存储器</h4><p>CMOS 存储器是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。 CMOS 存储器和递增时间的时钟电路有一块小电池驱动，所以，即使计算机没有上电，时间也可以正确地更新。</p><h4 id="10-USB-概念"><a href="#10-USB-概念" class="headerlink" title="10. USB 概念"></a>10. USB 概念</h4><p>USB 是通用串行总线，是用来将所有的慢速 I/O 设备，诸如键盘和鼠标，与计算机相连。USB 是一种集中式总线，其根设备每 1ms 轮询一次 I/O 设备，看是否有消息收发。所有的 USB 设备共享一个 USB 设备驱动器，于是就不需要为新的 USB 设备安装新的设备驱动器了。</p><h4 id="11-即插即用概念"><a href="#11-即插即用概念" class="headerlink" title="11. 即插即用概念"></a>11. 即插即用概念</h4><p>在一般的计算机工作环境下，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求导致了 Intel 和微软设计了一种名为即插即用的 I/O 系统。</p><p>在即插即用之前，每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。即插即用所做的工作是，系统自动地收集有关 I/O 设备的信息，集中赋予 I/O 地址，然后通知每块卡所用的数值。</p><h4 id="12-计算机的启动"><a href="#12-计算机的启动" class="headerlink" title="12. 计算机的启动"></a>12. 计算机的启动</h4><p>Pentium 的简要启动过程如下。在每个 Pentium 上有一块母板。在母板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序存放在一块闪速 RAM 中，它是非可易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。</p><p>简要过程如下：</p><ol><li><p>BIOS 开始运行。它首先检查计算机设备的状态信息是否正常。</p></li><li><p>扫描并记录总线所连设备。</p></li><li><p>依次搜索启动设备，导入操作系统。</p></li><li><p>操作系统询问 BIOS ，获得配置信息，获取所有设备的驱动程序并调入内核。</p></li><li><p>初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。</p></li></ol><h4 id="13-操作系统分类"><a href="#13-操作系统分类" class="headerlink" title="13. 操作系统分类"></a>13. 操作系统分类</h4><p>大型机操作系统、服务器操作系统、多处理器操作系统、个人计算机操作系统、掌上计算机操作系统、嵌入式操作系统、传感器节点操作系统、实时操作系统、智能卡操作系统</p><h4 id="14-实时操作系统的基本概念"><a href="#14-实时操作系统的基本概念" class="headerlink" title="14. 实时操作系统的基本概念"></a>14. 实时操作系统的基本概念</h4><p>实时操作系统的特征是将时间作为关键参数。通常分为硬实时操作系统和软实时操作系统。</p><p>在硬实时操作系统中，某个规定的动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p><p>在软实时操作系统中，偶尔违反最终时限是不希望的，但可以接受，并且不会引起任何实时性的损害。</p><h4 id="15-UID"><a href="#15-UID" class="headerlink" title="15. UID"></a>15. UID</h4><p>系统管理器授权每个进程使用一个给定的 UID 标识。每个被启动的进程都有一个启动该进程的用户 UID 。子进程与父进程拥有一样 UID。用户可以是某个组的成员，每个组也有一个 GID 标识。</p><h4 id="16-文件路径"><a href="#16-文件路径" class="headerlink" title="16. 文件路径"></a>16. 文件路径</h4><p>在 UNIX 中，绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用正斜线 <code>/</code> 隔开。最开始的正斜线标识这是从根目录开始的绝对路径。</p><p>在 MS-DOS 和 Windows 中，用反斜线 <code>\</code> 作为分隔符。</p><h4 id="17-文件系统安装"><a href="#17-文件系统安装" class="headerlink" title="17. 文件系统安装"></a>17. 文件系统安装</h4><p>UNIX 一个重要概念是安装文件系统。几乎所有的个人计算机都有一个或多个光盘驱动器，可以插入 CD-ROM 和 DV D。它们几乎都有 USB 接口，可以插入 USB 存储棒（实际是固态磁盘驱动器）。为了提供一个出色的方式处理可移动介质，UNIX 允许把在 CD-ROM 或 DVD 上的文件系统接入到主文件树上。 mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。</p><h4 id="18-特殊文件"><a href="#18-特殊文件" class="headerlink" title="18. 特殊文件"></a>18. 特殊文件</h4><p>提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可通过同样的系统调用进行读写。</p><p>有两类特殊文件：块特殊文件和字符特殊文件。</p><p>块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第4块，程序可以直接访问设备的第4块而不必考虑存放该文件的文件系统结构。</p><p>字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在 /dev 目录中。例如，/dev/lp是打印机。</p><h4 id="19-文件保护"><a href="#19-文件保护" class="headerlink" title="19. 文件保护"></a>19. 文件保护</h4><p>UNIX 操作系统通过对每个文件赋予一个9位的二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个3位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的 rwx 位。</p><h4 id="20-系统调用概念"><a href="#20-系统调用概念" class="headerlink" title="20. 系统调用概念"></a>20. 系统调用概念</h4><p>如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。</p><h4 id="21-POSIX"><a href="#21-POSIX" class="headerlink" title="21. POSIX"></a>21. POSIX</h4><p>UNIX 有很多不兼容的版本，从而导致了混乱。为了能使编写的程序能够在任何版本的 UNIX 系统运行，IEEE提出了一个 UNIX 标准，称为 POSIX，目前大多数 UNIX 版本都支持他。 POSIX 标准定义了凡是 UNIX 必须支持的小型系统调用接口。</p><h4 id="22-Windows-Win32-API"><a href="#22-Windows-Win32-API" class="headerlink" title="22. Windows Win32 API"></a>22. Windows Win32 API</h4><p>Windows 和 UNIX 的主要差别在于编程方式。一个 UNIX 程序包括做各种处理的代码以及从事完成特定服务的系统调用。相反，一个 Windows 程序通常是一个事件驱动程序。其中主程序等待某些事件发生，然后调用一个过程处理该事件。</p><p>在 UNIX 中，系统调用（如read）和系统调用所使用的库过程（如read）之间几乎是一一对应的关系。换句话说，对于每个系统调用，差不多就涉及一个被调用的库过程。</p><p>在 Windows 中，情况就大不相同了。首先，库调用和实际的系统调用是几乎不对应的。微软定义了一套过程，称为应用编程接口（Application Program Interface，Win32 API），程序员用这套过程获得操作系统的服务。</p><p>Win32 并不是非常统一的或有一致的接口。其主要原因是由于 Win32 需要与早期的在 Windows 3.x 中使用的16位接口向后兼容。</p><p>Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。</p><h4 id="23-操作系统结构"><a href="#23-操作系统结构" class="headerlink" title="23. 操作系统结构"></a>23. 操作系统结构</h4><p>单体结构、层次式结构、微内核、客户机-服务器模式、虚拟机、外核、</p><h4 id="24-微内核的概念"><a href="#24-微内核的概念" class="headerlink" title="24. 微内核的概念"></a>24. 微内核的概念</h4><p>在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。</p><h4 id="25-机制与策略分离原则"><a href="#25-机制与策略分离原则" class="headerlink" title="25. 机制与策略分离原则"></a>25. 机制与策略分离原则</h4><p>策略指的是做什么，机制指的是怎么做。例如一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程以优先级）可以由用户态中的进程完成。在这个方式中，机制和策略是分离的，从而使系统内核变得更小。</p><h4 id="26-make-程序"><a href="#26-make-程序" class="headerlink" title="26. make 程序"></a>26. make 程序</h4><p>在 UNIX 系统中，有个名为 make 的程序（其大量的变体如 gmake、pmake 等），它读入 Makefile ，该 Makefile 说明哪个文件与哪个文件相关。make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后，是否有任何它依赖（代码和头文件）的文件已经被修改了。如果有，目标文件需要重新编译。在大型项目中，创建 Makefile 是一件容易出错的工作，所以出现了一些工具使该工作能够自动完成。</p><h3 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h3><h4 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h4><h4 id="1-进程模型"><a href="#1-进程模型" class="headerlink" title="1. 进程模型"></a>1. 进程模型</h4><p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p><p>由于CPU在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常也不可再现。所以，在对进程编程时决不能对时序做任何确定的假设。</p><h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><p>有4种主要事件导致进程的创建：</p><ul><li><p><strong>系统初始化</strong></p><blockquote><p>启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反，却具有某些专门的功能。停留在后台处理诸如电子邮件、Web 页面、新闻、打印之类活动的进程称为守护进程</p></blockquote></li><li><p><strong>执行了正在运行的进程所调用的进程创建系统调用</strong></p><blockquote><p>一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以容易地划分成若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。</p></blockquote></li><li><p><strong>用户请求创建一个新进程</strong></p><blockquote><p>在交互式系统中，键入一个命令或者点（双）击一个图标就可以启动一个程序。这两个动作中的任何一个都会开始一个新的进程，并在其中运行所选择的程序。</p></blockquote></li><li><p><strong>一个批处理作业的初始化</strong></p><blockquote><p>最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中（可能是远程地）提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p></blockquote></li></ul><p>在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。</p><p>在 Windows 中，一个Win32函数调用 CreateProcess 既处理进程的创建，也负责把正确的程序装入新的进程。</p><p>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。</p><h4 id="3-进程的终止"><a href="#3-进程的终止" class="headerlink" title="3. 进程的终止"></a>3. 进程的终止</h4><p>进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起：</p><ul><li><p><strong>正常退出（自愿的）</strong></p><blockquote><p>多数进程是由于完成了它们的工作而终止。在 UNIX 中该调用是exit，而在 Windows 中，相关的调用是 ExitProcess 。</p></blockquote></li><li><p><strong>出错退出（自愿的）</strong></p><blockquote><p>进程终止的第二个原因是进程发现了严重错误。</p></blockquote></li><li><p><strong>严重错误（非自愿）</strong></p><blockquote><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致。</p></blockquote></li><li><p><strong>被其他进程杀死（非自愿）</strong></p><blockquote><p>第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程。在 UNIX 中，这个系统调用是 kill 。在 Win32中对应的函数是 TerminateProcess 。</p></blockquote></li></ul><h4 id="4-进程的层次结构"><a href="#4-进程的层次结构" class="headerlink" title="4. 进程的层次结构"></a>4. 进程的层次结构</h4><p>某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。</p><p>在 UNIX 中，进程和它的所有子女以及后裔共同组成一个进程组。</p><p>在 Windows 中没有进程层次的概念，所有的进程都是地位相同的。惟一类似于进程层次的暗示是在创建进程的时侯，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。</p><h4 id="5-UNIX-启动时的初始化"><a href="#5-UNIX-启动时的初始化" class="headerlink" title="5. UNIX 启动时的初始化"></a>5. UNIX 启动时的初始化</h4><p>一个称为 init 的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。</p><h4 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6. 进程的状态"></a>6. 进程的状态</h4><p>进程存在三种状态：</p><ul><li>运行态（该时刻进程实际占用CPU）。</li><li>就绪态（可运行，但因为其他进程正在运行而暂时停止）。</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）。</li></ul><p>状态间的转化关系为</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-3.png" alt="进程间状态转换"></p><h4 id="7-进程的实现"><a href="#7-进程的实现" class="headerlink" title="7. 进程的实现"></a>7. 进程的实现</h4><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项。（也可称为进程控制块。）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p><h4 id="8-多道程序设计模型"><a href="#8-多道程序设计模型" class="headerlink" title="8. 多道程序设计模型"></a>8. 多道程序设计模型</h4><p>采用多道程序设计可以提高 CPU 的利用率。从概率的角度来看 CPU 的利用率。假设一个进程等待 I/O 操作的时间与其停留在内存中时间的比为p。当内存中同时有 n 个进程时，则所有 n 个进程都在等待 I/O（此时 CPU 空转）的概率是 pⁿ 。CPU 的利用率由下面的公式给出：</p><blockquote><p>CPU 利用率 = 1-pⁿ</p></blockquote><h4 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h4><h4 id="1-线程的使用原因"><a href="#1-线程的使用原因" class="headerlink" title="1. 线程的使用原因"></a>1. 线程的使用原因</h4><p>人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</p><p>第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。在许多系统中，创建一个线程较创建一个进程要快10～100倍。</p><p>需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</p><h4 id="2-线程模型"><a href="#2-线程模型" class="headerlink" title="2. 线程模型"></a>2. 线程模型</h4><p>进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。</p><p>线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。</p><h4 id="3-在用户空间中实现线程"><a href="#3-在用户空间中实现线程" class="headerlink" title="3. 在用户空间中实现线程"></a>3. 在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。我们已经见过其中的四个过程：pthread_create ，pthread_exit ，pthread_join 和 pthread_yield 。不过，一般还会有更多的过程。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-4.png" alt="用户线程实现"></p><p>在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和内核中的进程表类似。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p><p><strong>优点</strong></p><ol><li><p>用户级线程包可以在不支持线程的操作系统上实现。</p></li><li><p>线程的切换可以在几条指令内完成。进行类似于这样的线程切换至少比陷入内核要快一个数量级（或许更多）。</p></li><li><p>保存线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p></li><li><p>它允许每个进程有自己定制的调度算法。</p></li></ol><p><strong>缺点</strong></p><ol><li><p>第一个问题是如何实现阻塞系统调用。假设在还没有任何击键之前，一个线程读取键盘。让该线程实际进行该系统调用是不可接受的，因为这会停止所有的线程。</p></li><li><p>页面故障问题。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p></li><li><p>如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU 。</p></li><li><p>通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是CPU密集型而且极少有阻塞的应用程序而言，没有很大的意义。</p></li></ol><h4 id="4-在内核中实现线程"><a href="#4-在内核中实现线程" class="headerlink" title="4. 在内核中实现线程"></a>4. 在内核中实现线程</h4><p>在内核中实现线程时，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。内核的线程表保存了每个线程的寄存器、状态和其他信息。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-5.png" alt="内核线程实现"></p><p>所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的 CPU （或者没有可运行的线程存在了）为止。</p><h4 id="5-混合实现"><a href="#5-混合实现" class="headerlink" title="5. 混合实现"></a>5. 混合实现</h4><p>人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-6.png" alt="混合线程实现"></p><p>采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。</p><h4 id="6-调度程序激活机制"><a href="#6-调度程序激活机制" class="headerlink" title="6. 调度程序激活机制"></a>6. 调度程序激活机制</h4><p>调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。</p><p>使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这个机制称为上行调用。一旦如此激活，运行时系统就重新调度其线程。</p><p><strong>调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。</strong></p><h4 id="7-弹出式线程"><a href="#7-弹出式线程" class="headerlink" title="7. 弹出式线程"></a>7. 弹出式线程</h4><p>一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。</p><p>弹出式线程的关键好处是，由于这种线程相当新，没有历史这样，就有可能快速创建这类线程。对该新线程指定所要处理的消息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。</p><h4 id="三、-进程间通信"><a href="#三、-进程间通信" class="headerlink" title="三、 进程间通信"></a>三、 进程间通信</h4><p>进程间通信需要关注的三个问题：</p><ol><li><p>一个进程如何把信息传递给另一个。</p></li><li><p>如何确保两个或更多的进程在关键活动中不会出现交叉。</p></li><li><p>正确的顺序。</p></li></ol><h4 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h4><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。</p><h4 id="2-临界区"><a href="#2-临界区" class="headerlink" title="2. 临界区"></a>2. 临界区</h4><p>在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。</p><p>对于保证使用共享数据的并发进程能够正确和高效地进行协作，一个好的解决方案，需要满足以下4个条件：</p><ul><li>任何两个进程不能同时处于其临界区。</li><li>不应对CPU的速度和数量做任何假设。</li><li>临界区外运行的进程不得阻塞其他进程。</li><li>不得使进程无限期等待进入临界区。</li></ul><h4 id="3-忙等待的互斥"><a href="#3-忙等待的互斥" class="headerlink" title="3. 忙等待的互斥"></a>3. 忙等待的互斥</h4><h5 id="（1）-屏蔽中断"><a href="#（1）-屏蔽中断" class="headerlink" title="（1） 屏蔽中断"></a>（1） 屏蔽中断</h5><p>在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。</p><p><strong>缺点：</strong></p><ol><li><p>若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。</p></li><li><p>如果系统是多处理器（有两个或可能更多的处理器），则屏蔽中断仅仅对执行disable 指令的那个 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。</p></li></ol><p>但是对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。</p><p>所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</p><h5 id="（2）-锁变量"><a href="#（2）-锁变量" class="headerlink" title="（2） 锁变量"></a>（2） 锁变量</h5><p>设想有一个共享（锁）变量，其初始值为0。当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该进程将等待直到其值变为0。于是，0就表示临界区内没有进程，1表示已经有某个进程进入临界区。</p><p><strong>缺点：锁变量的读写不是原子操作，可能被其他进程中断</strong></p><p>假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行，将该锁变量设置为1。当第一个进程再次能运行时，它同样也将该锁设置为1，则此时同时有两个进程进入临界区中。</p><h5 id="（3）严格轮换法"><a href="#（3）严格轮换法" class="headerlink" title="（3）严格轮换法"></a>（3）严格轮换法</h5><p>定义一个整型变量 turn ，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程0检查 turn ，发现其值为0，于是进入临界区。进程1也发现其值为0，所以在一个等待循环中不停地测试 turn ，看其值何时变为1。连续测试一个变量直到某个值出现为止，称为忙等待。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-7.png" alt="严格轮换法"></p><p>只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁（spin lock）。</p><p><strong>缺点：</strong></p><ol><li><p>采用忙等待的方式，会浪费 CPU 时间。</p></li><li><p>该方案要求两个进程严格地轮流进入它们的临界区，会造成一个临界区外运行的进程阻塞其他进程的情况。</p></li></ol><h5 id="（4）Peterson-解法"><a href="#（4）Peterson-解法" class="headerlink" title="（4）Peterson 解法"></a>（4）Peterson 解法</h5><p>在使用共享变量（即进入其临界区）之前，各个进程使用其进程号0或1作为参数来调用 enter_region 。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 leave_region ，表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-8.png" alt="Peterson 解法"></p><h5 id="（5）TSL-指令"><a href="#（5）TSL-指令" class="headerlink" title="（5）TSL 指令"></a>（5）TSL 指令</h5><p>TSL 指令是硬件支持的一种方案，称为测试并加锁，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。</p><p>读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。因此不会出现前面第二种方法锁变量的问题。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-9.png" alt="TSL 指令"></p><p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为0时，任何进程都可以使用 TSL 指令将其设置为1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为0。</p><p>一个可替代 TSL 的指令是 XCHG ，它原子性地交换了两个位置的内容，它本质上与 TSL 的解决办法一样。所有的Intel x86 CPU 在低层同步中使用 XCHG 指令。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-10.png" alt="XCHG 指令"></p><p><strong>缺点：</strong></p><ol><li>采用忙等待的方式，会浪费 CPU 时间。</li></ol><h4 id="4-睡眠与唤醒"><a href="#4-睡眠与唤醒" class="headerlink" title="4. 睡眠与唤醒"></a>4. 睡眠与唤醒</h4><p>Peterson 解法和 TSL 或 XCHG 解法都是正确的，但它们都有忙等待的缺点。这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。</p><p>我们可以使用睡眠与唤醒的机制，使它们在无法进入临界区时将阻塞，而不是忙等待。</p><p>最简单的是 sleep 和 wakeup 。 sleep 是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup 调用有一个参数，即要被唤醒的进程。</p><p><strong>缺点：</strong></p><p>参考生产者-消费者问题，发给一个（尚）未睡眠进程的 wakeup 信号会出现丢失，从而出现生产者和消费者同时睡眠的情况。</p><p>一种快速的弥补方法是修改规则，加上一个唤醒等待位。当一个 wakeup 信号发送给一个清醒的进程信号时，将该位置1。随后，当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒。但原则上讲，这并没有从根本上解决问题。</p><h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h4><p>信号量是一个整型变量用来累计唤醒次数，供以后使用。一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。</p><p>对信号量一共有两种操作：down 和 up （分别为一般化后的 sleep 和 wakeup ）。</p><p>对一信号量执行 down 操作，则是检查其值是否大于0。若该值大于0，则将其值减1（即用掉一个保存的唤醒信号）并继续；若该值为0，则进程将睡眠，而且此时down操作并未结束。</p><p>对一信号量执行 up 操作，会对信号量的值增1。如果一个或多个进程在该信号量上睡眠，信号量的值仍旧是0，但在其上睡眠的进程会被唤醒一个。</p><p>检查数值、修改变量值以及可能发生的睡眠和唤醒操作均作为一个单一的、不可分割的原子操作完成。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。</p><h4 id="6-互斥量"><a href="#6-互斥量" class="headerlink" title="6. 互斥量"></a>6. 互斥量</h4><p>如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。</p><p>互斥量是一个可以处于两态之一的变量：解锁和加锁。当一个线程（或进程）需要访问临界区时，它调用 mutex_lock 。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用 mutex_unlock 。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-11.png" alt="互斥量"></p><p>enter_region 和 mutex_lock 的代码很相似，但有一个关键的区别。</p><p>当 enter_region 进入临界区失败时，它始终重复测试锁（忙等待）。实际上，由于时钟超时的作用，会调度其他进程运行。这样迟早拥有锁的进程会进入运行并释放锁。</p><p>在（用户）线程中，情形有所不同，因为没有时钟停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁。因此当 mutex_lock 取锁失败时，它调用 thread_yield 将 CPU 放弃给另一个线程。这样，就没有忙等待。在该线程下次运行时，它再一次对锁进行测试。</p><h4 id="7-条件变量"><a href="#7-条件变量" class="headerlink" title="7. 条件变量"></a>7. 条件变量</h4><p>条件变量允许线程由于一些未达到的条件而阻塞。</p><p>与条件变量相关的最重要的两个操作是 pthread_cond_wait 和 pthread_cond_signal 。前者阻塞调用线程直到另一其他线程向它发信号（使用后一个调用）。</p><p>条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。</p><h4 id="8-管程"><a href="#8-管程" class="headerlink" title="8. 管程"></a>8. 管程</h4><p>管程是一种高级同步原语，管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。</p><p>当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果</p><p>管程提供了一种实现互斥的简便途径，通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。</p><h4 id="9-消息传递"><a href="#9-消息传递" class="headerlink" title="9. 消息传递"></a>9. 消息传递</h4><p>这种进程间通信的方法使用两条原语 send 和 receive ，它们像信号量而不像管程，是系统调用而不是语言成分。</p><p>前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源（或者是任意源，如果接收者不介意的话）接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者，带着一个错误码立即返回。</p><h4 id="10-屏障"><a href="#10-屏障" class="headerlink" title="10. 屏障"></a>10. 屏障</h4><p>在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p><h4 id="四、调度"><a href="#四、调度" class="headerlink" title="四、调度"></a>四、调度</h4><p>当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序使用的算法称为调度算法。</p><h4 id="1-何时调度"><a href="#1-何时调度" class="headerlink" title="1. 何时调度"></a>1. 何时调度</h4><ol><li><p>在创建一个新进程之后，需要决定是运行父进程还是运行子进程。</p></li><li><p>在一个进程退出时必须做出调度决策。</p></li><li><p>当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</p></li><li><p>第四，在一个 I/O 中断发生时，必须做出调度决策。</p></li></ol><h4 id="2-调度算法分类"><a href="#2-调度算法分类" class="headerlink" title="2. 调度算法分类"></a>2. 调度算法分类</h4><ol><li>批处理。</li><li>交互式。</li><li>实时。</li></ol><h4 id="3-调度算法的目标"><a href="#3-调度算法的目标" class="headerlink" title="3. 调度算法的目标"></a>3. 调度算法的目标</h4><p>为了设计调度算法，有必要考虑什么是一个好的调度算法。某些目标取决于环境（批处理、交互式或实时），但是还有一些目标是适用于所有情形的。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-12.png" alt="调度算法的目标"></p><h4 id="4-批处理系统中的调度"><a href="#4-批处理系统中的调度" class="headerlink" title="4. 批处理系统中的调度"></a>4. 批处理系统中的调度</h4><h5 id="（1）先来先服务"><a href="#（1）先来先服务" class="headerlink" title="（1）先来先服务"></a>（1）先来先服务</h5><p>在所有调度算法中，最简单的是非抢占式的先来先服务算法。使用该算法，进程按照它们请求 CPU 的顺序使用 CPU 。</p><p><strong>优点：</strong></p><p>这个算法的主要优点是易于理解并且便于在程序中运用。</p><p><strong>缺点：</strong></p><p>平均等待时间过长。</p><h5 id="（2）最短作业优先"><a href="#（2）最短作业优先" class="headerlink" title="（2）最短作业优先"></a>（2）最短作业优先</h5><p>当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先算法。</p><p>只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的。</p><h5 id="（3）最短剩余时间优先"><a href="#（3）最短剩余时间优先" class="headerlink" title="（3）最短剩余时间优先"></a>（3）最短剩余时间优先</h5><p>最短作业优先的抢占式版本是最短剩余时间优先算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p><h4 id="5-交互式系统中的调度"><a href="#5-交互式系统中的调度" class="headerlink" title="5. 交互式系统中的调度"></a>5. 交互式系统中的调度</h4><h5 id="（1）轮转调度"><a href="#（1）轮转调度" class="headerlink" title="（1）轮转调度"></a>（1）轮转调度</h5><p>一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺 CPU 并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。</p><p>需要注意的是，时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20ms～50 ms通常是一个比较合理的折中。</p><h4 id="（2）优先级调度"><a href="#（2）优先级调度" class="headerlink" title="（2）优先级调度"></a>（2）优先级调度</h4><p>每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这个动作导致该进程的优先级低于次高优先级的进程，则进行进程切换。</p><h4 id="（3）多级队列"><a href="#（3）多级队列" class="headerlink" title="（3）多级队列"></a>（3）多级队列</h4><p>将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用其他调度方式。</p><h4 id="（4）最短进程优先"><a href="#（4）最短进程优先" class="headerlink" title="（4）最短进程优先"></a>（4）最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互进程，那将是非常好的。</p><h4 id="（5）保证调度"><a href="#（5）保证调度" class="headerlink" title="（5）保证调度"></a>（5）保证调度</h4><p>向用户作出明确的性能保证，然后去实现它。</p><p>一种很实际并很容易实现的保证是：若用户工作时有 n 个用户登录，则用户将获得 CPU 处理能力的 1/n 。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。看上去足够公平了。</p><h4 id="（6）彩票调度"><a href="#（6）彩票调度" class="headerlink" title="（6）彩票调度"></a>（6）彩票调度</h4><p>向进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。在应用到 CPU 调度时，系统可以掌握每秒钟50次的一种彩票，作为奖励每个获奖者可以得到20 ms 的 CPU 时间。</p><h4 id="（7）公平分享调度"><a href="#（7）公平分享调度" class="headerlink" title="（7）公平分享调度"></a>（7）公平分享调度</h4><p>到现在为止，我们假设被调度的都是各个进程自身，并不关注其所有者是谁。</p><p>为了避免这种情形，某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得50% CPU 时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。</p><h4 id="6-策略和机制"><a href="#6-策略和机制" class="headerlink" title="6. 策略和机制"></a>6. 策略和机制</h4><p>我们讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p><p>解决问题的方法是将调度机制与调度策略分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。</p><p>在这里，调度机制位于内核，而调度策略则由用户进程决定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机操作系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="面试题系列" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试知识点之算法</title>
    <link href="/2023/09/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E7%AE%97%E6%B3%95/"/>
    <id>/2023/09/20/面试知识点之算法/</id>
    <published>2023-09-20T05:53:59.000Z</published>
    <updated>2024-01-11T07:00:59.292Z</updated>
    
    <content type="html"><![CDATA[<p>算法知识总结<br><a id="more"></a></p><h1 id="算法知识总结"><a href="#算法知识总结" class="headerlink" title="算法知识总结"></a>算法知识总结</h1><p>本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#常用算法和数据结构总结">常用算法和数据结构总结</a><ul><li><a href="#排序">排序</a><ul><li><a href="#冒泡排序">冒泡排序</a></li><li><a href="#选择排序">选择排序</a></li><li><a href="#插入排序">插入排序</a></li><li><a href="#希尔排序">希尔排序</a></li><li><a href="#归并排序">归并排序</a></li><li><a href="#快速排序">快速排序</a></li><li><a href="#堆排序">堆排序</a></li><li><a href="#基数排序">基数排序</a></li><li><a href="#快速排序相对于其他排序效率更高的原因">快速排序相对于其他排序效率更高的原因</a></li><li><a href="#系统自带排序实现">系统自带排序实现</a></li><li><a href="#稳定性">稳定性</a></li><li><a href="#排序面试题目总结">排序面试题目总结</a></li></ul></li><li><a href="#树">树</a><ul><li><a href="#二叉树相关性质">二叉树相关性质</a></li><li><a href="#满二叉树">满二叉树</a></li><li><a href="#完全二叉树">完全二叉树</a></li><li><a href="#平衡二叉查找树avl">平衡二叉查找树（AVL）</a></li><li><a href="#b-树">B-树</a></li><li><a href="#b树">B 树</a></li><li><a href="#数据库索引">数据库索引</a></li><li><a href="#红黑树">红黑树</a></li><li><a href="#huffman-树">Huffman 树</a></li><li><a href="#二叉查找树">二叉查找树</a></li><li><a href="#求解二叉树中两个节点的最近公共祖先节点">求解二叉树中两个节点的最近公共祖先节点</a></li></ul></li><li><a href="#链表">链表</a><ul><li><a href="#反转单向链表">反转单向链表</a></li></ul></li><li><a href="#动态规划">动态规划</a><ul><li><a href="#爬楼梯问题">爬楼梯问题</a></li><li><a href="#递归方法分析">递归方法分析</a></li><li><a href="#备忘录方法">备忘录方法</a></li><li><a href="#迭代法">迭代法</a></li></ul></li><li><a href="#经典笔试题">经典笔试题</a><ul><li><a href="#1-js-实现一个函数完成超过范围的两个大整数相加功能">1. js 实现一个函数，完成超过范围的两个大整数相加功能</a></li><li><a href="#2-js-如何实现数组扁平化">2. js 如何实现数组扁平化？</a></li><li><a href="#3-js-如何实现数组去重">3. js 如何实现数组去重？</a></li><li><a href="#4-如何求数组的最大值和最小值">4. 如何求数组的最大值和最小值？</a></li><li><a href="#5-如何求两个数的最大公约数">5. 如何求两个数的最大公约数？</a></li><li><a href="#6-如何求两个数的最小公倍数">6. 如何求两个数的最小公倍数？</a></li><li><a href="#7-实现-indexof-方法">7. 实现 IndexOf 方法？</a></li><li><a href="#8-判断一个字符串是否为回文字符串">8. 判断一个字符串是否为回文字符串？</a></li><li><a href="#9-实现一个累加函数的功能比如-sum1232valueof">9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</a></li><li><a href="#10-使用-reduce-方法实现-foreachmapfilter">10. 使用 reduce 方法实现 forEach、map、filter</a></li><li><a href="#11-设计一个简单的任务队列要求v分别在-134-秒后打印出-1-2-3">11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</a></li><li><a href="#12-如何查找一篇英文文章中出现频率最高的单词">12. 如何查找一篇英文文章中出现频率最高的单词？</a></li></ul></li></ul></li><li><a href="#常见面试智力题总结">常见面试智力题总结</a><ul><li><a href="#1-时针与分针夹角度数问题">1. 时针与分针夹角度数问题？</a></li><li><a href="#2-用3升5升杯子怎么量出4升水">2. 用3升，5升杯子怎么量出4升水？</a></li><li><a href="#3-四个药罐中有一个浑浊的药罐浑浊的每片药片都比其他三个干净的药罐多一克如何只用一次天平找出浑浊的药罐">3. 浑浊药罐问题</a></li><li><a href="#4-四张卡片卡片正面是数字反面是字母现在桌上四张卡片状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1">4. 卡片证明问题</a></li><li><a href="#5-赛马问题25-匹马5-个赛道最少几次能选出最快的三匹马">5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</a></li><li><a href="#6-五队夫妇参加聚会每个人不能和自己的配偶握手只能最多和他人握手一次a问了其他人发现每个人的握手次数都">6. 五队夫妇参加聚会握手问题</a></li><li><a href="#7-你只能带行走-60-公里的油只能在起始点加油如何穿过-80-公里的沙漠">7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</a></li><li><a href="#8-烧一根不均匀的绳要用一个小时如何用它来判断一个小时十五分钟">8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</a></li><li><a href="#9-有7克2克砝码各一个天平一只如何只用这些物品三次将140克的盐分成5090克各一份">9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</a></li><li><a href="#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约另一辆火车以第小时20公里的速度从纽约开往洛杉矶如果有一只鸟以外30公里每小时的速度和两辆火车现时启动从洛杉矶出发碰到另辆车后返回依次在两辆火车来回的飞行直道两面辆火车相遇请问这只小鸟飞行了多长距离">10. 火车相对而行，小鸟飞行距离问题 </a></li><li><a href="#11-你有两个罐子50个红色弹球50个蓝色弹球随机选出一个罐子随机选取出一个弹球放入罐子怎么给红色弹球最大的选中机会在你的计划中得到红球的准确几率是多少">11. 弹球拾取几率问题</a></li><li><a href="#12-假设你有8个球其中一个略微重一些但是找出这个球的惟一方法是将两个球放在天平上对比最少要称多少次才能找出这个较重的球">12. 8个球使用天平称重问题</a></li><li><a href="#13-在房里有三盏灯房外有三个开关在房外看不见房内的情况你只能进门一次你用什么方法来区分那个开关控制那一盏灯">13. 三盏灯区分开关问题</a></li><li><a href="#14-他们都各自买了两对黑袜和两对白袜八对袜子的布质大小完全相同而每对袜子都有一张商标纸连着两位盲人不小心将八对袜子混在一起他们每人怎样才能取回黑袜和白袜各两对呢">14. 盲人黑白袜子问题</a></li><li><a href="#15-有三筐水果一筐装的全是苹果第二筐装的全是橘子第三筐是橘子与苹果混在一起筐上的标签都是骗人的就是说筐上的标签都是错的你的任务是拿出其中一筐从里面只拿一只水果然后正确写出三筐水果的标签">15. 水果标签问题</a></li><li><a href="#16-一个班级60喜欢足球70喜欢篮球80喜欢排球问即三种球都喜欢占比有多少">16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</a></li><li><a href="#17-五只鸡五天能下五个蛋一百天下一百个蛋需要多少只鸡">17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</a></li></ul></li><li><a href="#剑指-offer-思路总结">剑指 offer 思路总结</a><ul><li><a href="#题目">题目</a><ul><li><a href="#1-二维数组中的查找">1. 二维数组中的查找</a></li><li><a href="#2-替换空格">2. 替换空格</a></li><li><a href="#3-从尾到头打印链表">3. 从尾到头打印链表</a></li><li><a href="#4-重建二叉树">4. 重建二叉树</a></li><li><a href="#5-用两个栈实现队列">5. 用两个栈实现队列</a></li><li><a href="#6-旋转数组的最小数字">6. 旋转数组的最小数字</a></li><li><a href="#7-斐波那契数列">7. 斐波那契数列</a></li><li><a href="#8-跳台阶">8. 跳台阶</a></li><li><a href="#9-变态跳台阶">9. 变态跳台阶</a></li><li><a href="#10-矩形覆盖">10. 矩形覆盖</a></li><li><a href="#11-二进制中1的个数">11. 二进制中1的个数</a></li><li><a href="#12-数值的整数次方">12. 数值的整数次方</a></li><li><a href="#13-调整数组顺序使奇数位于偶数前面">13. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#14-链表中倒数第-k-个节点">14. 链表中倒数第 k 个节点</a></li><li><a href="#15-反转链表">15. 反转链表</a></li><li><a href="#16-合并两个排序的链表">16. 合并两个排序的链表</a></li><li><a href="#17-树的子结构">17. 树的子结构</a></li><li><a href="#18-二叉树的镜像">18. 二叉树的镜像</a></li><li><a href="#19-顺时针打印矩阵">19. 顺时针打印矩阵</a></li><li><a href="#20-定义一个栈实现-min-函数">20. 定义一个栈，实现 min 函数</a></li><li><a href="#21-栈的压入弹出">21. 栈的压入弹出</a></li><li><a href="#22-从上往下打印二叉树">22. 从上往下打印二叉树</a></li><li><a href="#23-二叉搜索树的后序遍历">23. 二叉搜索树的后序遍历</a></li><li><a href="#24-二叉树中和为某一值路径">24. 二叉树中和为某一值路径</a></li><li><a href="#25-复杂链表的复制">25. 复杂链表的复制</a></li><li><a href="#26-二叉搜索树与双向链表">26. 二叉搜索树与双向链表</a></li><li><a href="#27-字符串的排列">27. 字符串的排列</a></li><li><a href="#28-数组中出现次数超过一半的数字">28. 数组中出现次数超过一半的数字</a></li><li><a href="#29-最小的-k-个数">29. 最小的 K 个数</a></li><li><a href="#30-连续子数组的最大和">30. 连续子数组的最大和</a></li><li><a href="#31-整数中1出现的次数待深入理解">31. 整数中1出现的次数（待深入理解）</a></li><li><a href="#32-把数组排成最小的数">32. 把数组排成最小的数</a></li><li><a href="#33-丑数待深入理解">33. 丑数（待深入理解）</a></li><li><a href="#34-第一个只出现一次的字符">34. 第一个只出现一次的字符</a></li><li><a href="#35-数组中的逆序对">35. 数组中的逆序对</a></li><li><a href="#36-两个链表的第一个公共结点">36. 两个链表的第一个公共结点</a></li><li><a href="#37-数字在排序数组中出现的次数">37. 数字在排序数组中出现的次数</a></li><li><a href="#38-二叉树的深度">38. 二叉树的深度</a></li><li><a href="#39-平衡二叉树">39. 平衡二叉树</a></li><li><a href="#40-数组中只出现一次的数字">40. 数组中只出现一次的数字</a></li><li><a href="#41-和为-s-的连续正数序列">41. 和为 S 的连续正数序列</a></li><li><a href="#42-和为-s-的两个数字">42. 和为 S 的两个数字</a></li><li><a href="#43-左旋转字符串">43. 左旋转字符串</a></li><li><a href="#44-翻转单词顺序列">44. 翻转单词顺序列</a></li><li><a href="#45-扑克牌的顺子">45. 扑克牌的顺子</a></li><li><a href="#46-圆圈中最后剩下的数字约瑟夫环问题">46. 圆圈中最后剩下的数字（约瑟夫环问题）</a></li><li><a href="#47-123n">47. 1 2 3 … n</a></li><li><a href="#48-不用加减乘除做加法">48. 不用加减乘除做加法</a></li><li><a href="#49-把字符串转换成整数">49. 把字符串转换成整数。</a></li><li><a href="#50-数组中重复的数字">50. 数组中重复的数字</a></li><li><a href="#51-构建乘积数组">51. 构建乘积数组</a></li><li><a href="#52-正则表达式的匹配">52. 正则表达式的匹配</a></li><li><a href="#53-表示数值的字符串">53. 表示数值的字符串</a></li><li><a href="#54-字符流中第一个不重复的字符">54. 字符流中第一个不重复的字符</a></li><li><a href="#55-链表中环的入口结点">55. 链表中环的入口结点</a></li><li><a href="#56-删除链表中重复的结点">56. 删除链表中重复的结点</a></li><li><a href="#57-二叉树的下一个结点">57. 二叉树的下一个结点</a></li><li><a href="#58-对称二叉树">58. 对称二叉树</a></li><li><a href="#59-按之字形顺序打印二叉树待深入理解">59. 按之字形顺序打印二叉树（待深入理解）</a></li><li><a href="#60-从上到下按层打印二叉树同一层结点从左至右输出每一层输出一行">60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</a></li><li><a href="#61-序列化二叉树待深入理解">61. 序列化二叉树（待深入理解）</a></li><li><a href="#62-二叉搜索树的第-k-个节点">62. 二叉搜索树的第 K 个节点</a></li><li><a href="#63-数据流中的中位数待深入理解">63. 数据流中的中位数（待深入理解）</a></li><li><a href="#64-滑动窗口中的最大值待深入理解">64. 滑动窗口中的最大值（待深入理解）</a></li><li><a href="#65-矩阵中的路径待深入理解">65. 矩阵中的路径（待深入理解）</a></li><li><a href="#66-机器人的运动范围待深入理解">66. 机器人的运动范围（待深入理解）</a></li></ul></li><li><a href="#相关算法题">相关算法题</a><ul><li><a href="#1-明星问题">1. 明星问题</a></li><li><a href="#2-正负数组求和">2. 正负数组求和</a></li></ul></li></ul></li></ul><h1 id="常用算法和数据结构总结"><a href="#常用算法和数据结构总结" class="headerlink" title="常用算法和数据结构总结"></a>常用算法和数据结构总结</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，<br>最终达到完全有序。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lastIndex &gt; <span class="number">0</span>) &#123; <span class="comment">// 当最后一个交换的元素为第一个时，说明后面全部排序完毕</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span>, k = lastIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">              lastIndex = j; <span class="comment">// 设置最后一次交换元素的位置</span></span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序有两种优化方式。</p><p>一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。<br>因此我们不需要再执行之后的外层循环，此时可以直接结束。</p><p>一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下<br>一轮循环中无需再去比较。</p><p>优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p><p>冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="noopener">《图解排序算法(一)》</a><br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/" target="_blank" rel="noopener">《常见排序算法 - 鸡尾酒排序 》</a><br><a href="https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1" target="_blank" rel="noopener">《前端笔试&amp;面试爬坑系列—算法》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41" target="_blank" rel="noopener">《前端面试之道》</a></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p><p>在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实<br>我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较<br>仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> minIndex = i; <span class="comment">// 设置当前循环最小元素索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前元素比最小元素索引，则更新最小元素索引</span></span><br><span class="line">      <span class="keyword">if</span> (array[minIndex] &gt; array[j]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换最小元素到当前位置</span></span><br><span class="line">    <span class="comment">// [array[i], array[minIndex]] = [array[minIndex], array[i]];</span></span><br><span class="line">    swap(array, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = array[left];</span><br><span class="line">  array[left] = array[right];</span><br><span class="line">  array[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。</p><p>选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="noopener">《图解排序算法(一)》</a></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，<br>继续接，可能是中间数，就插在中间….依次</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环从 1 开始，0 位置为默认的已排序的序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = array[i]; <span class="comment">// 保存当前需要排序的元素</span></span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置</span></span><br><span class="line">    <span class="keyword">while</span> (j <span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将找到的位置插入元素</span></span><br><span class="line">    array[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p><p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="noopener">《图解排序算法(一)》</a></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元<br>素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hillSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一层确定增量的大小，每次增量的大小减半</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>); gap &gt;= <span class="number">1</span>; gap = <span class="built_in">parseInt</span>(gap &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个分组使用插入排序，相当于将插入排序的1换成了 n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = array[i];</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; array[j - gap] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - gap];</span><br><span class="line">        j -= gap;</span><br><span class="line">      &#125;</span><br><span class="line">      array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行<br>基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一<br>次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p><p>简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，<br>所以排序速度也很快。</p><p>希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p><p>插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，<br>所以希尔排序是一个不稳定的排序。</p><p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">《图解排序算法(二)之希尔排序》</a><br><a href="https://blog.csdn.net/u013630349/article/details/48250109" target="_blank" rel="noopener">《数据结构基础 希尔排序 之 算法复杂度浅析》</a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后<br>将数组排序合并，最终合并为排序好的数组。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于0，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>), <span class="comment">// 找到中间索引值</span></span><br><span class="line">    left = array.slice(<span class="number">0</span>, mid), <span class="comment">// 截取左半部分</span></span><br><span class="line">    right = array.slice(mid, length); <span class="comment">// 截取右半部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right)); <span class="comment">// 递归分解后，进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">leftArray, rightArray</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    leftLength = leftArray.length,</span><br><span class="line">    rightLength = rightArray.length,</span><br><span class="line">    il = <span class="number">0</span>,</span><br><span class="line">    ir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArray[il] &lt; rightArray[ir]) &#123;</span><br><span class="line">      result.push(leftArray[il++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(rightArray[ir++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength) &#123;</span><br><span class="line">    result.push(leftArray[il++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (ir &lt; rightLength) &#123;</span><br><span class="line">    result.push(rightArray[ir++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每<br>一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p><p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归<br>并排序的空间复杂度为 O(n)。</p><p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">《图解排序算法(四)之归并排序》</a><br><a href="https://www.zhihu.com/question/27274006" target="_blank" rel="noopener">《归并排序的空间复杂度？》</a></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据<br>都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, start, end</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span> || start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = partition(array, start, end); <span class="comment">// 将数组划分为两部分，并返回右部分的第一个元素的索引值</span></span><br><span class="line"></span><br><span class="line">  quickSort(array, start, index - <span class="number">1</span>); <span class="comment">// 递归排序左半部分</span></span><br><span class="line">  quickSort(array, index + <span class="number">1</span>, end); <span class="comment">// 递归排序右半部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, start, end</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pivot = array[start]; <span class="comment">// 取第一个值为枢纽值，获取枢纽值的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 start 等于 end 指针时结束循环</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 end 指针指向的值大等于枢纽值时，end 指针向前移动</span></span><br><span class="line">    <span class="keyword">while</span> (array[end] &gt;= pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将比枢纽值小的值交换到 start 位置</span></span><br><span class="line">    array[start] = array[end];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动</span></span><br><span class="line">    <span class="keyword">while</span> (array[start] &lt; pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将比枢纽值大的值交换到 end 位置，进入下一次循环</span></span><br><span class="line">    array[end] = array[start];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将枢纽值交换到中间点</span></span><br><span class="line">  array[start] = pivot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回中间索引值</span></span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值<br>等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者<br>start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的<br>值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递<br>归左右两边的的序列。</p><p>当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂<br>度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。</p><p>当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏<br>的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。</p><p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p><p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6262208.html" target="_blank" rel="noopener">《图解排序算法(五)之快速排序——三数取中法》</a><br><a href="https://segmentfault.com/a/1190000004410119#articleHeader2" target="_blank" rel="noopener">《关于快速排序的四种写法》</a><br><a href="https://harttle.land/2015/09/27/quick-sort.html" target="_blank" rel="noopener">《快速排序的时间和空间复杂度》</a><br><a href="https://blog.csdn.net/weshjiness/article/details/8660583" target="_blank" rel="noopener">《快速排序最好，最坏，平均复杂度分析》</a><br><a href="https://blog.csdn.net/qq_33758761/article/details/76782610" target="_blank" rel="noopener">《快速排序算法的递归深度》</a></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行<br>交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，<br>便能得到一个有序序列了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  buildMaxHeap(array); <span class="comment">// 将传入的数组建立为大顶堆</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(array, <span class="number">0</span>, i);</span><br><span class="line">    adjustMaxHeap(array, <span class="number">0</span>, i); <span class="comment">// 将剩下的元素重新构建为大顶堆</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustMaxHeap</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iMax,</span><br><span class="line">    iLeft,</span><br><span class="line">    iRight;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    iMax = index; <span class="comment">// 保存最大值的索引</span></span><br><span class="line">    iLeft = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">// 获取左子元素的索引</span></span><br><span class="line">    iRight = <span class="number">2</span> * index + <span class="number">2</span>; <span class="comment">// 获取右子元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子元素存在，且左子元素大于最大值，则更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) &#123;</span><br><span class="line">      iMax = iLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子元素存在，且右子元素大于最大值，则更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">      iMax = iRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树</span></span><br><span class="line">    <span class="keyword">if</span> (iMax !== index) &#123;</span><br><span class="line">      swap(array, index, iMax);</span><br><span class="line">      index = iMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果未被更新，说明该子树满足大顶堆的要求，退出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length,</span><br><span class="line">    iParent = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// 获取最后一个非叶子点的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    adjustMaxHeap(array, i, length); <span class="comment">// 循环调整每一个子树，使其满足大顶堆的要求</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = array[i];</span><br><span class="line">  array[i] = array[j];</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在<br>不管什么情况下都是 O(nlogn)。</p><p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">《图解排序算法(三)之堆排序》</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">《常见排序算法 - 堆排序 (Heap Sort)》</a><br><a href="https://www.zhihu.com/question/20729324" target="_blank" rel="noopener">《堆排序中建堆过程时间复杂度O(n)怎么来的？》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297" target="_blank" rel="noopener">《排序算法之 堆排序 及其时间复杂度和空间复杂度》</a><br><a href="https://blog.csdn.net/hrn1216/article/details/51465270" target="_blank" rel="noopener">《最小堆 构建、插入、删除的过程图解》</a></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将<br>所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样<br>从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> bucket = [],</span><br><span class="line">    max = array[<span class="number">0</span>],</span><br><span class="line">    loop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定排序数组中的最大值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">      max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定最大值的位数</span></span><br><span class="line">  loop = (max + <span class="string">''</span>).length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化桶</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bucket[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = array[j] + <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (str.length &gt;= i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = <span class="built_in">parseInt</span>(str[str.length - <span class="number">1</span> - i]); <span class="comment">// 获取当前位的值，作为插入的索引</span></span><br><span class="line">        bucket[k].push(array[j]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理位数不够的情况，高位默认为 0</span></span><br><span class="line">        bucket[<span class="number">0</span>].push(array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array.splice(<span class="number">0</span>, length); <span class="comment">// 清空旧的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用桶重新初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> t = bucket[i].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">        array.push(bucket[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bucket[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定<br>排序。</p><p>详细资料可以参考：<br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/" target="_blank" rel="noopener">《常见排序算法 - 基数排序》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44594415" target="_blank" rel="noopener">《排序算法之 基数排序 及其时间复杂度和空间复杂度》</a></p><p>算法总结可以参考：<br><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">《算法的时间复杂度和空间复杂度-总结》</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">《十大经典排序算法（动图演示）》</a><br><a href="https://blog.csdn.net/wangiijing/article/details/51485119" target="_blank" rel="noopener">《各类排序算法的对比及实现》</a></p><h3 id="快速排序相对于其他排序效率更高的原因"><a href="#快速排序相对于其他排序效率更高的原因" class="headerlink" title="快速排序相对于其他排序效率更高的原因"></a>快速排序相对于其他排序效率更高的原因</h3><p>上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同<br>数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p><p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看<br>的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最<br>坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？</p><p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因<br>此归并排序首先就被排除掉了。</p><p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p><p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在<br>枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我<br>们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互<br>换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较<br>是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p><p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机<br>中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原<br>理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当<br>前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理<br>来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于<br>空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行<br>数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显<br>提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来<br>说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更<br>高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可<br>以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其<br>他的因素。</p><p>相关资料可以参考：<br><a href="https://www.zhihu.com/question/23873747" target="_blank" rel="noopener">《为什么在平均情况下快速排序比堆排序要优秀？》</a><br><a href="https://blog.csdn.net/qq_36770641/article/details/82669788" target="_blank" rel="noopener">《为什么说快速排序是性能最好的排序算法？》</a></p><h3 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h3><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据<br>量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，<br>而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p><p>稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，<br>当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p><h3 id="排序面试题目总结"><a href="#排序面试题目总结" class="headerlink" title="排序面试题目总结"></a>排序面试题目总结</h3><ol><li><p>快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p></li><li><p>初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p></li><li><p>合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p></li><li><p>外部排序常用的算法是归并排序。</p></li><li><p>数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p></li><li><p>如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p></li><li><p>插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p></li><li><p>对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p></li><li><p>下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。<br>因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p></li><li><p>拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p></li><li><p>任何一个基于”比较”的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!，<br>时间下界为 O(nlogn)</p></li><li><p>m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p></li><li><p>对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</p></li><li><p>在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p></li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树相关性质"><a href="#二叉树相关性质" class="headerlink" title="二叉树相关性质"></a>二叉树相关性质</h3><ol><li><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p></li><li><p>叶节点或终端节点：度为零的节点； </p></li><li><p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 </p></li><li><p>树的高度或深度：树中节点的最大层次。</p></li><li><p>在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i&gt;=1。 </p></li><li><p>深度为 h 的二叉树最多有 2^h-1个结点(h&gt;=1)，最少有 h 个结点。</p></li><li><p>对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1； </p></li><li><p>给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。</p></li><li><p>二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 </p></li><li><p>二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 </p></li><li><p>二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。</p></li><li><p>二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。</p></li><li><p>一个带权的无向连通图的最小生成树的权值之和是唯一的。</p></li><li><p>只有一个结点的二叉树的度为 0 。</p></li><li><p>二叉树的度是以节点的最大的度数定义的。</p></li><li><p>树的后序遍历序列等同于该树对应的二叉树的中序序列。</p></li><li><p>树的先序遍历序列等同于该树对应的二叉树的先序序列。 </p></li><li><p>线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列：<br>debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。</p></li><li><p>递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，<br>也就是深度d！=logn，有可能d&gt;&gt;logn。所以栈大小应该是O（d）</p></li><li><p>一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，<br>即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。</p></li><li><p>引入二叉线索树的目的是加快查找结点的前驱或后继的速度。</p></li><li><p>二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。</p></li><li><p>不管是几叉树，节点数等于=分叉数+1</p></li><li><p>任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。</p></li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/adminabcd/article/details/46672759" target="_blank" rel="noopener">《n 个节点的二叉树有多少种形态》</a><br><a href="https://www.cnblogs.com/guoyaohua/p/8595289.html" target="_blank" rel="noopener">《数据结构二叉树知识点总结》</a><br><a href="https://www.jianshu.com/p/2943a21d2a99" target="_blank" rel="noopener">《还原二叉树–已知先序中序或者后序中序》</a><br><a href="https://blog.csdn.net/linraise/article/details/11745559" target="_blank" rel="noopener">《树、森林与二叉树的转换》</a></p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满<br>二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满<br>二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</p><p>性质：</p><ol><li><p>具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数) </p></li><li><p>有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则<br>如果 I&gt;1，则其父结点的编号为 I/2；</p></li><li><p>完全二叉树，如果 2 <em> I &lt;= N，则其左儿子（即左子树的根结点）的编号为2 </em> I；若2 <em> I &gt; N，则无左儿子；如<br>果 2 </em> I + 1 &lt;= N，则其右儿子的结点编号为 2 <em> I + 1；若 2 </em> I + 1 &gt; N，则无右儿子。</p></li></ol><h3 id="平衡二叉查找树（AVL）"><a href="#平衡二叉查找树（AVL）" class="headerlink" title="平衡二叉查找树（AVL）"></a>平衡二叉查找树（AVL）</h3><p>平衡二叉查找树具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li></ol><p>平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有<br>一点帮帮助，反而增加了维护的成本。</p><p>平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树<br>的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/suimeng/p/4560056.html" target="_blank" rel="noopener">《平衡二叉树，AVL树之图解篇》</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O<br>次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，<br>我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少<br>索引树的高度是提高索引效率的关键。</p><p>B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每<br>个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页<br>只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树<br>的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查<br>找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561220&amp;idx=1&amp;sn=2a6d8a0290f967027b1d54456f586405&amp;chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《漫画：什么是 B- 树？》</a></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。<br>B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点<br>中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够<br>包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含<br>了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561244&amp;idx=1&amp;sn=df3abafd3aa2f5a3abfe507bfc26982f&amp;chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《漫画：什么是 B+ 树？》</a></p><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建<br>立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是<br>由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。</p><p>相关资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">《深入浅出数据库索引原理》</a><br><a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html" target="_blank" rel="noopener">《数据库的最简单实现》</a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子<br>节点的最长路径不会超过最短路径的两倍。</p><p>红黑树的有具体的规则：</p><p>1.节点是红色或黑色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p><p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561574&amp;idx=1&amp;sn=edab54460a85c9686e0ec0f5d178907c&amp;chksm=f1feeaa5c68963b3689d23db68ab14a9c50a33dd5e9244a74d7765321b42af7ec14abfadf9ac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《漫画：什么是红黑树？》</a><br><a href="https://cloud.tencent.com/developer/article/1101517" target="_blank" rel="noopener">《漫画算法等精选文章目录》</a></p><h3 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h3><p>给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉<br>树，也称为 Huffman 树。</p><p>利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码<br>不是另一个字符编码的前缀。</p><p>性质：</p><ol><li><p>对应一组权重构造出来的 Huffman 树一般不是唯一的</p></li><li><p>Huffman 树具有最小的带权路径长度</p></li><li><p>Huffman 树中没有度为1的结点</p></li><li><p>哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近</p></li><li><p>Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和</p></li></ol><p>详细资料可以参考：</p><p><a href="https://blog.csdn.net/google19890102/article/details/54848262" target="_blank" rel="noopener">《数据结构和算法—— Huffman 树和 Huffman 编码》</a><br><a href="https://blog.csdn.net/fx677588/article/details/70767446" target="_blank" rel="noopener">《详细图解哈夫曼 Huffman 编码树》</a></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，<br>对于数值型和非数值型数据，比如字母和字符串，都是如此。</p><p>实现树节点类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类，树的节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现二叉查找树类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现树的节点插入方法</p><p>节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，<br>否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。<br>循环这个过程直到找到合适的插入位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insert(value) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断根节点是否为空，如果不为空则递归插入到树中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertNode(node, newNode) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。</span></span><br><span class="line">  <span class="keyword">if</span> (newNode.value &lt; node.value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.insertNode(node.left, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.insertNode(node.right, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过递归实现树的先序、中序、后序遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历通过递归实现</span></span><br><span class="line"><span class="comment">// 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。</span></span><br><span class="line"> preOrderTraverse() &#123;</span><br><span class="line">   <span class="keyword">this</span>.preOrderTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> preOrderTraverseNode(node) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     node.show();</span><br><span class="line">     <span class="keyword">this</span>.preOrderTraverseNode(node.left);</span><br><span class="line">     <span class="keyword">this</span>.preOrderTraverseNode(node.right);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 中序遍历通过递归实现</span></span><br><span class="line"> <span class="comment">// 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。</span></span><br><span class="line"> inOrderTraverse() &#123;</span><br><span class="line">   <span class="keyword">this</span>.inOrderTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> inOrderTraverseNode(node) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.inOrderTraverseNode(node.left);</span><br><span class="line">     node.show();</span><br><span class="line">     <span class="keyword">this</span>.inOrderTraverseNode(node.right);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后序遍历通过递归实现</span></span><br><span class="line"> <span class="comment">// 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。</span></span><br><span class="line"> postOrderTraverse() &#123;</span><br><span class="line">   <span class="keyword">this</span>.postOrderTraverseNode(<span class="keyword">this</span>.root);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> postOrderTraverseNode(node) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.postOrderTraverseNode(node.left);</span><br><span class="line">     <span class="keyword">this</span>.postOrderTraverseNode(node.right);</span><br><span class="line">     node.show();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过循环实现树的先序、中序、后序遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历通过循环实现</span></span><br><span class="line"><span class="comment">// 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将</span></span><br><span class="line"><span class="comment">// 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。</span></span><br><span class="line">preOrderTraverseByStack() &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现将根节点入栈，开始遍历</span></span><br><span class="line">  stack.push(<span class="keyword">this</span>.root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从栈中获取当前节点</span></span><br><span class="line">    <span class="keyword">let</span> node = stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行节点操作</span></span><br><span class="line">    node.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根</span></span><br><span class="line">    <span class="comment">// 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的</span></span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">      stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">      stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历通过循环实现</span></span><br><span class="line"><span class="comment">// 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有</span></span><br><span class="line"><span class="comment">// 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。</span></span><br><span class="line">inOrderTraverseByStack() &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [],</span><br><span class="line">    node = <span class="keyword">this</span>.root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">  <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">  <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">  <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> || node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      stack.push(node);</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node = stack.pop();</span><br><span class="line">      node.show();</span><br><span class="line">      node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历通过循环来实现</span></span><br><span class="line"><span class="comment">// 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次</span></span><br><span class="line"><span class="comment">// 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。</span></span><br><span class="line">postOrderTraverseByStack() &#123;</span><br><span class="line">  <span class="keyword">let</span> stack1 = [],</span><br><span class="line">    stack2 = [],</span><br><span class="line">    node = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line">  <span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">  <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line"></span><br><span class="line">  stack1.push(<span class="keyword">this</span>.root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack1.pop();</span><br><span class="line"></span><br><span class="line">    stack2.push(node);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">      stack1.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">      stack1.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack2.pop();</span><br><span class="line">    node.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现寻找最大最小节点值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找最小值，在最左边的叶子节点上</span></span><br><span class="line"> findMinNode(root) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (node &amp;&amp; node.left) &#123;</span><br><span class="line">     node = node.left;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 寻找最大值，在最右边的叶子节点上</span></span><br><span class="line"></span><br><span class="line"> findMaxNode(root) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (node &amp;&amp; node.right) &#123;</span><br><span class="line">     node = node.right;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现寻找特定大小节点值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找特定值</span></span><br><span class="line">find(value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.findNode(<span class="keyword">this</span>.root, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findNode(node, value) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; node.value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findNode(node.left, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findNode(node.right, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现移除节点值</p><p>移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如<br>果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 移除指定值节点</span></span><br><span class="line">remove(value) &#123;</span><br><span class="line">  <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.root, value);</span><br><span class="line">&#125;</span><br><span class="line">removeNode(node, value) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找指定节点</span></span><br><span class="line">  <span class="keyword">if</span> (value &lt; node.value) &#123;</span><br><span class="line">    node.left = <span class="keyword">this</span>.removeNode(node.left, value);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.value) &#123;</span><br><span class="line">    node.right = <span class="keyword">this</span>.removeNode(node.right, value);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种情况——没有叶节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点</span></span><br><span class="line">    <span class="comment">// 的值，保持树的特性，然后将替换的节点去掉</span></span><br><span class="line">    <span class="keyword">let</span> aux = <span class="keyword">this</span>.findMinNode(node.right);</span><br><span class="line">    node.value = aux.value;</span><br><span class="line">    node.right = <span class="keyword">this</span>.removeNode(node.right, aux);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求解二叉树中两个节点的最近公共祖先节点"><a href="#求解二叉树中两个节点的最近公共祖先节点" class="headerlink" title="求解二叉树中两个节点的最近公共祖先节点"></a>求解二叉树中两个节点的最近公共祖先节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑</span><br><span class="line"></span><br><span class="line">（1）该二叉树为搜索二叉树 </span><br><span class="line"></span><br><span class="line">    解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于</span><br><span class="line">    根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个</span><br><span class="line">    节点的值小时，该节点则为两个节点的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。</span><br><span class="line"></span><br><span class="line">    通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点</span><br><span class="line">    的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。</span><br><span class="line"></span><br><span class="line">    这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同</span><br><span class="line">    的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/xyzbaihaiping/article/details/52122885" target="_blank" rel="noopener">《二叉树中两个节点的最近公共祖先节点》</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><p>需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是<br>一道面试常考题。</p><p>思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> current = head;</span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">    <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">    <span class="comment">// 然后把当前节点的 next 设为上一个节点</span></span><br><span class="line">    <span class="comment">// 然后把 current 设为下一个节点，pre 设为当前节点</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        next = current.next;</span><br><span class="line">        current.next = pre;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？</p><h4 id="递归方法分析"><a href="#递归方法分析" class="headerlink" title="递归方法分析"></a>递归方法分析</h4><p>由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，<br>因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上<br>从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到<br>2级阶梯的走法数量。</p><p>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClimbingWays</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getClimbingWays(n - <span class="number">1</span>) + getClimbingWays(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度<br>为递归的深度 O(logn)。</p><h4 id="备忘录方法"><a href="#备忘录方法" class="headerlink" title="备忘录方法"></a>备忘录方法</h4><p>分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给<br>保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。</p><p>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClimbingWays</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.has(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = getClimbingWays(n - <span class="number">1</span>) + getClimbingWays(n - <span class="number">2</span>);</span><br><span class="line">    map.set(n, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。</p><p>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClimbingWays</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561168&amp;idx=1&amp;sn=9d1c6f7ba6d651c75399c4aa5254a7d8&amp;chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《漫画：什么是动态规划？（整合版）》</a></p><h2 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h2><h4 id="1-js-实现一个函数，完成超过范围的两个大整数相加功能"><a href="#1-js-实现一个函数，完成超过范围的两个大整数相加功能" class="headerlink" title="1. js 实现一个函数，完成超过范围的两个大整数相加功能"></a>1. js 实现一个函数，完成超过范围的两个大整数相加功能</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bigNumberAdd</span>(<span class="params">number1, number2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">""</span>, <span class="comment">// 保存最后结果</span></span><br><span class="line">    carry = <span class="literal">false</span>; <span class="comment">// 保留进位结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将字符串转换为数组</span></span><br><span class="line">  number1 = number1.split(<span class="string">""</span>);</span><br><span class="line">  number2 = number2.split(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当数组的长度都变为0，并且最终不再进位时，结束循环</span></span><br><span class="line">  <span class="keyword">while</span> (number1.length || number2.length || carry) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0</span></span><br><span class="line">    carry += ~~number1.pop() + ~~number2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取加法结果的个位加入最终结果</span></span><br><span class="line">    result = carry % <span class="number">10</span> + result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0</span></span><br><span class="line">    carry = carry &gt; <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回最终结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/fe_dev/article/details/80079372" target="_blank" rel="noopener">《JavaScript实现超范围的数相加》</a><br>   <a href="https://blog.csdn.net/q1059081877q/article/details/80689194" target="_blank" rel="noopener">《js 实现大整数加法》</a></p><h4 id="2-js-如何实现数组扁平化？"><a href="#2-js-如何实现数组扁平化？" class="headerlink" title="2. js 如何实现数组扁平化？"></a>2. js 如何实现数组扁平化？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">flattenArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">     result = array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, item</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中</span></span><br><span class="line">       <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(item) ? flattenArray(item) : item);</span><br><span class="line">     &#125;, []);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用递归的形式进行数组打平</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">flatArray</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(element))&#123;</span><br><span class="line">                flat(element);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.push(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flat(arr);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">flattenArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> array.toString().split(<span class="string">","</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(item);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">《JavaScript专题之数组扁平化》</a></p><h4 id="3-js-如何实现数组去重？"><a href="#3-js-如何实现数组去重？" class="headerlink" title="3. js 如何实现数组去重？"></a>3. js 如何实现数组去重？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(item) === <span class="number">-1</span>) &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">《JavaScript专题之数组去重》</a></p><h4 id="4-如何求数组的最大值和最小值？"><a href="#4-如何求数组的最大值和最小值？" class="headerlink" title="4. 如何求数组的最大值和最小值？"></a>4. 如何求数组的最大值和最小值？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">《JavaScript专题之如何求数组的最大值和最小值》</a></p><h4 id="5-如何求两个数的最大公约数？"><a href="#5-如何求两个数的最大公约数？" class="headerlink" title="5. 如何求两个数的最大公约数？"></a>5. 如何求两个数的最大公约数？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，</span><br><span class="line">直到余数为<span class="number">0</span>时，最后的被除数就是两个数的最大公约数。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCommonDivisor</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getMaxCommonDivisor(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-如何求两个数的最小公倍数？"><a href="#6-如何求两个数的最小公倍数？" class="headerlink" title="6. 如何求两个数的最小公倍数？"></a>6. 如何求两个数的最小公倍数？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本思想是采用将两个数相乘，然后除以它们的最大公约数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMinCommonMultiple</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b / getMaxCommonDivisor(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/cssfirefly/archive/2012/10/23/2734936.html" target="_blank" rel="noopener">《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》</a></p><h4 id="7-实现-IndexOf-方法？"><a href="#7-实现-IndexOf-方法？" class="headerlink" title="7. 实现 IndexOf 方法？"></a>7. 实现 IndexOf 方法？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexFun</span>(<span class="params">array, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === val) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-判断一个字符串是否为回文字符串？"><a href="#8-判断一个字符串是否为回文字符串？" class="headerlink" title="8. 判断一个字符串是否为回文字符串？"></a>8. 判断一个字符串是否为回文字符串？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/[\W_]/g</span>, <span class="comment">// 匹配所有非单词的字符以及下划线</span></span><br><span class="line">    newStr = str.replace(reg, <span class="string">""</span>).toLowerCase(), <span class="comment">// 替换为空字符并将大写字母转换为小写</span></span><br><span class="line">    reverseStr = newStr.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>); <span class="comment">// 将字符串反转</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr === newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf"><a href="#9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf" class="headerlink" title="9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()"></a>9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">result = args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pre + item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  result = args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + item;</span><br><span class="line">  &#125;, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-使用-reduce-方法实现-forEach、map、filter"><a href="#10-使用-reduce-方法实现-forEach、map、filter" class="headerlink" title="10. 使用 reduce 方法实现 forEach、map、filter"></a>10. 使用 reduce 方法实现 forEach、map、filter</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEachUseReduce</span>(<span class="params">array, handler</span>) </span>&#123;</span><br><span class="line">  array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, item, index</span>) </span>&#123;</span><br><span class="line">    handler(item, index);</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapUseReduce</span>(<span class="params">array, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mapItem = handler(item, index);</span><br><span class="line">    result.push(mapItem);</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterUseReduce</span>(<span class="params">array, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler(item, index)) &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”"><a href="#11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”" class="headerlink" title="11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”"></a>11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">    <span class="keyword">this</span>.time = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addTask(task, t) &#123;</span><br><span class="line">    <span class="keyword">this</span>.time += t;</span><br><span class="line">    <span class="keyword">this</span>.queue.push([task, <span class="keyword">this</span>.time]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        item[<span class="number">0</span>]();</span><br><span class="line">      &#125;, item[<span class="number">1</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-如何查找一篇英文文章中出现频率最高的单词？"><a href="#12-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="12. 如何查找一篇英文文章中出现频率最高的单词？"></a>12. 如何查找一篇英文文章中出现频率最高的单词？</h4>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMostWord</span>(<span class="params">article</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法性判断</span></span><br><span class="line"><span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数处理</span></span><br><span class="line">article = article.trim().toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wordList = article.match(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line"> visited = [],</span><br><span class="line"> maxNum = <span class="number">0</span>,</span><br><span class="line"> maxWord = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">article = <span class="string">" "</span> + wordList.join(<span class="string">"  "</span>) + <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">wordList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (visited.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">" "</span> + item + <span class="string">" "</span>, <span class="string">"g"</span>),</span><br><span class="line">     num = article.match(word).length;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">     maxNum = num;</span><br><span class="line">     maxWord = item;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxWord + <span class="string">"  "</span> + maxNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><h4 id="1-时针与分针夹角度数问题？"><a href="#1-时针与分针夹角度数问题？" class="headerlink" title="1. 时针与分针夹角度数问题？"></a>1. 时针与分针夹角度数问题？</h4><p>   分析：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</span><br><span class="line"></span><br><span class="line">我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。</span><br><span class="line"></span><br><span class="line">时针每走一格为 30 度。</span><br><span class="line"></span><br><span class="line">因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。</span><br><span class="line"></span><br><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure></p><p>   答案：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure></p><p>   详细资料参考：<br>   <a href="https://blog.csdn.net/prstaxy/article/details/22210829" target="_blank" rel="noopener">《面试智力题 — 时针与分针夹角度数问题》</a></p><h4 id="2-用3升，5升杯子怎么量出4升水？"><a href="#2-用3升，5升杯子怎么量出4升水？" class="headerlink" title="2. 用3升，5升杯子怎么量出4升水？"></a>2. 用3升，5升杯子怎么量出4升水？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。</span><br><span class="line"></span><br><span class="line">（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。</span><br><span class="line"></span><br><span class="line">（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</span><br></pre></td></tr></table></figure><h4 id="3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"><a href="#3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？" class="headerlink" title="3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"></a>3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。</span><br><span class="line"></span><br><span class="line">（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。</span><br><span class="line"></span><br><span class="line">（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4</span><br><span class="line">    片药片。</span><br><span class="line"></span><br><span class="line">（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</span><br></pre></td></tr></table></figure><h4 id="4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？"><a href="#4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？" class="headerlink" title="4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？"></a>4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</span><br></pre></td></tr></table></figure><h4 id="5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？"><a href="#5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？" class="headerlink" title="5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？"></a>5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我认为一共至少需要 7 次才能选出最快的三匹马。</span><br><span class="line"></span><br><span class="line">（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直</span><br><span class="line">    接淘汰掉，那么我们现在还剩下了 15 匹马。</span><br><span class="line"></span><br><span class="line">（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余</span><br><span class="line">    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，</span><br><span class="line">    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，</span><br><span class="line">    它们都有竞争最快第二第三的机会。</span><br><span class="line"></span><br><span class="line">（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</span><br></pre></td></tr></table></figure><h4 id="6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"><a href="#6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？" class="headerlink" title="6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"></a>6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。</span><br><span class="line"></span><br><span class="line">（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因</span><br><span class="line">    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。</span><br><span class="line"></span><br><span class="line">（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有</span><br><span class="line">    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。</span><br><span class="line"></span><br><span class="line">（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手</span><br><span class="line">    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数</span><br><span class="line">    为 1 的人是配偶。</span><br><span class="line"></span><br><span class="line">（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。</span><br><span class="line"></span><br><span class="line">（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。</span><br><span class="line"></span><br><span class="line">（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</span><br></pre></td></tr></table></figure><h4 id="7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？"><a href="#7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？" class="headerlink" title="7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？"></a>7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。</span><br><span class="line"></span><br><span class="line">（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路</span><br><span class="line">    程。</span><br></pre></td></tr></table></figure><h4 id="8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"><a href="#8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？" class="headerlink" title="8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"></a>8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。</span><br><span class="line">  </span><br><span class="line">（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。</span><br><span class="line"></span><br><span class="line">（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。</span><br><span class="line"></span><br><span class="line">（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。</span><br><span class="line"></span><br><span class="line">（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</span><br></pre></td></tr></table></figure><h4 id="9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"><a href="#9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？" class="headerlink" title="9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"></a>9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。</span><br><span class="line"></span><br><span class="line">（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。</span><br><span class="line"></span><br><span class="line">（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</span><br></pre></td></tr></table></figure><h4 id="10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"><a href="#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？" class="headerlink" title="10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"></a>10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此</span><br><span class="line">两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</span><br></pre></td></tr></table></figure><h4 id="11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"><a href="#11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？" class="headerlink" title="11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"></a>11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</span><br></pre></td></tr></table></figure><h4 id="12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"><a href="#12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？" class="headerlink" title="12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"></a>12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最少两次可以称出。</span><br><span class="line"></span><br><span class="line">首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。</span><br><span class="line"></span><br><span class="line">第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如</span><br><span class="line">果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</span><br></pre></td></tr></table></figure><h4 id="13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"><a href="#13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？" class="headerlink" title="13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"></a>13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）首先打开一盏灯 10 分钟，然后打开第二盏。</span><br><span class="line">（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开</span><br><span class="line">    的。</span><br></pre></td></tr></table></figure><h4 id="14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"><a href="#14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？" class="headerlink" title="14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"></a>14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</span><br></pre></td></tr></table></figure><h4 id="15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"><a href="#15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。" class="headerlink" title="15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"></a>15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。</span><br><span class="line"></span><br><span class="line">对应水果标签的筐的标签改为另一种水果。</span><br><span class="line"></span><br><span class="line">另一种水果标签的框改为混合。</span><br></pre></td></tr></table></figure><h4 id="16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？"><a href="#16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？" class="headerlink" title="16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？"></a>16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。</span><br><span class="line"></span><br><span class="line">（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多</span><br><span class="line">    90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。</span><br><span class="line"></span><br><span class="line">因此三种球都喜欢的人占比为 10%-60%</span><br></pre></td></tr></table></figure><h4 id="17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"><a href="#17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？" class="headerlink" title="17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"></a>17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</span><br></pre></td></tr></table></figure><p>   更多的智力题可以参考：<br>   <a href="https://blog.csdn.net/hilyoo/article/details/4445858" target="_blank" rel="noopener">《经典面试智力题200+题和解答》</a></p><h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><p>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动</span><br><span class="line">    ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20</span><br><span class="line">Are%20Happy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”</span><br><span class="line"></span><br><span class="line">str.replace(/\s/g,&quot;%20&quot;)</span><br></pre></td></tr></table></figure><h4 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，从尾到头打印链表每个节点的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的</span><br><span class="line">实现可以利用 Array 的 push 和 pop 方法来模拟。</span><br></pre></td></tr></table></figure><h4 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输</span><br><span class="line">入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左</span><br><span class="line">边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的</span><br><span class="line">时间复杂度为 O(n)，空间复杂度为 O(logn)。</span><br></pre></td></tr></table></figure><h4 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接</span><br><span class="line">将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中</span><br><span class="line">的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line"></span><br><span class="line">当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</span><br></pre></td></tr></table></figure><h4 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的</span><br><span class="line">最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大</span><br><span class="line">小为0，请返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相</span><br><span class="line">    邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。</span><br><span class="line"></span><br><span class="line">（2）二分法</span><br></pre></td></tr></table></figure><p>   相关资料可以参考：<br>   <a href="https://www.cnblogs.com/edisonchou/p/4746561.html" target="_blank" rel="noopener">《旋转数组的最小数字》</a></p><h4 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠</span><br><span class="line">加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</span><br></pre></td></tr></table></figure><h4 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一</span><br><span class="line">种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。</span><br><span class="line"></span><br><span class="line">和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</span><br></pre></td></tr></table></figure><h4 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。</span><br><span class="line"></span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。</span><br><span class="line">f(3) = f(3-1) + f(3-2) + f(3-3) </span><br><span class="line">...</span><br><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) </span><br><span class="line"></span><br><span class="line">再次总结可得</span><br><span class="line"></span><br><span class="line">              | 1       ,(n=0 ) </span><br><span class="line">f(n) =        | 1       ,(n=1 )</span><br><span class="line">              | 2*f(n-1),(n&gt;=2)</span><br></pre></td></tr></table></figure><h4 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共</span><br><span class="line">有多少种方法？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">依旧是斐波那契数列的应用</span><br></pre></td></tr></table></figure><h4 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后</span><br><span class="line">面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判</span><br><span class="line">断这个数可以经历多少次这样的过程。</span><br><span class="line"></span><br><span class="line">如：1100&amp;1011=1000</span><br></pre></td></tr></table></figure><h4 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。</span><br></pre></td></tr></table></figure><h4 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半</span><br><span class="line">部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到</span><br><span class="line">奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间</span><br><span class="line">复杂度为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="14-链表中倒数第-k-个节点"><a href="#14-链表中倒数第-k-个节点" class="headerlink" title="14. 链表中倒数第 k 个节点"></a>14. 链表中倒数第 k 个节点</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，输出该链表中倒数第 k 个结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后</span><br><span class="line">移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</span><br></pre></td></tr></table></figure><h4 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，反转链表后，输出链表的所有元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当</span><br><span class="line">前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne</span><br><span class="line">xt 节点，实现下一次循环。</span><br></pre></td></tr></table></figure><h4 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的方式，依次将两个链表的元素递归进行对比。</span><br></pre></td></tr></table></figure><h4 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的思想来解决</span><br><span class="line"></span><br><span class="line">第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。</span><br><span class="line">第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</span><br></pre></td></tr></table></figure><h4 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。 </span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</span><br></pre></td></tr></table></figure><h4 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下矩阵： 1 2 3 4</span><br><span class="line"> 5 6 7 8 </span><br><span class="line"> 9 10 11 12 </span><br><span class="line"> 13 14 15 16 </span><br><span class="line">则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一</span><br><span class="line">    次需要打印的数据范围。</span><br><span class="line"></span><br><span class="line">（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</span><br></pre></td></tr></table></figure><h4 id="20-定义一个栈，实现-min-函数"><a href="#20-定义一个栈，实现-min-函数" class="headerlink" title="20. 定义一个栈，实现 min 函数"></a>20. 定义一个栈，实现 min 函数</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小</span><br><span class="line">的值。</span><br></pre></td></tr></table></figure><h4 id="21-栈的压入弹出"><a href="#21-栈的压入弹出" class="headerlink" title="21. 栈的压入弹出"></a>21. 栈的压入弹出</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如</span><br><span class="line">序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序</span><br><span class="line">列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出</span><br><span class="line">栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中</span><br><span class="line">的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</span><br></pre></td></tr></table></figure><h4 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子</span><br><span class="line">节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</span><br></pre></td></tr></table></figure><h4 id="23-二叉搜索树的后序遍历"><a href="#23-二叉搜索树的后序遍历" class="headerlink" title="23. 二叉搜索树的后序遍历"></a>23. 二叉搜索树的后序遍历</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两</span><br><span class="line">个数字都互不相同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，</span><br><span class="line">所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我</span><br><span class="line">们可以利用这些特点来递归判断。</span><br></pre></td></tr></table></figure><h4 id="24-二叉树中和为某一值路径"><a href="#24-二叉树中和为某一值路径" class="headerlink" title="24. 二叉树中和为某一值路径"></a>24. 二叉树中和为某一值路径</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经</span><br><span class="line">过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</span><br></pre></td></tr></table></figure><h4 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25. 复杂链表的复制"></a>25. 复杂链表的复制</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为</span><br><span class="line">复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra</span><br><span class="line">    ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复</span><br><span class="line">    制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此</span><br><span class="line">    不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。</span><br><span class="line"></span><br><span class="line">（3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行</span><br><span class="line">    random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点</span><br><span class="line">    。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26. 二叉搜索树与双向链表"></a>26. 二叉搜索树与双向链表</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序</span><br><span class="line">序列。</span><br><span class="line"></span><br><span class="line">基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并</span><br><span class="line">将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点</span><br><span class="line">的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</span><br></pre></td></tr></table></figure><h4 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27. 字符串的排列"></a>27. 字符串的排列</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有</span><br><span class="line">字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可</span><br><span class="line">以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一</span><br><span class="line">个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html" target="_blank" rel="noopener">《字符串的排列》</a></p><h4 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28. 数组中出现次数超过一半的数字"></a>28. 数组中出现次数超过一半的数字</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数</span><br><span class="line">字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为</span><br><span class="line">    O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中</span><br><span class="line">    位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随</span><br><span class="line">    机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字</span><br><span class="line">    便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之</span><br><span class="line">    在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数</span><br><span class="line">    字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果</span><br><span class="line">    次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，</span><br><span class="line">    则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/ns_code/article/details/26957383" target="_blank" rel="noopener">《出现次数超过一半的数字》</a></p><h4 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29. 最小的 K 个数"></a>29. 最小的 K 个数</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂</span><br><span class="line">    度，最好的情况下为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part</span><br><span class="line">    ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢</span><br><span class="line">    纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢</span><br><span class="line">    纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划</span><br><span class="line">    分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平</span><br><span class="line">    均时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这</span><br><span class="line">    就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最</span><br><span class="line">    大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一</span><br><span class="line">    种方法的平均时间复杂度为 O(nlogk)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579" target="_blank" rel="noopener">《寻找最小的 k 个数》</a></p><h4 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30. 连续子数组的最大和"></a>30. 连续子数组的最大和</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计</span><br><span class="line">算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的</span><br><span class="line">正数会弥补它呢？例如：&#123;6,-3,-2,7,-15,1,2,2&#125;，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠</span><br><span class="line">住？（子向量的长度至少是1）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首</span><br><span class="line">    往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。</span><br><span class="line">    因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负</span><br><span class="line">    数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。</span><br><span class="line">    使用这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html" target="_blank" rel="noopener">《连续子数组的最大和》</a></p><h4 id="31-整数中1出现的次数（待深入理解）"><a href="#31-整数中1出现的次数（待深入理解）" class="headerlink" title="31. 整数中1出现的次数（待深入理解）"></a>31. 整数中1出现的次数（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、</span><br><span class="line">12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整</span><br><span class="line">数区间中1出现的次数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是求出1出现在每位上的次数，然后进行叠加。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/yi_Afly/article/details/52012593" target="_blank" rel="noopener">《从1到n整数中1出现的次数：O(logn)算法》</a></p><h4 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32. 把数组排成最小的数"></a>32. 把数组排成最小的数</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321</span><br><span class="line">&#125;，则打印出这三个数字能排成的最小数字为321323。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）求出数组的全排列，然后对每个排列结果进行比较。</span><br><span class="line"></span><br><span class="line">（2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的</span><br><span class="line">    结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html" target="_blank" rel="noopener">《把数组排成最小的数》</a></p><h4 id="33-丑数（待深入理解）"><a href="#33-丑数（待深入理解）" class="headerlink" title="33. 丑数（待深入理解）"></a>33. 丑数（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求</span><br><span class="line">按从小到大的顺序的第 N 个丑数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以</span><br><span class="line">    5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。</span><br><span class="line"></span><br><span class="line">（2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</span><br></pre></td></tr></table></figure><h4 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这</span><br><span class="line">    一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时</span><br><span class="line">    ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><h4 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35. 数组中的逆序对"></a>35. 数组中的逆序对</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对</span><br><span class="line">的总数 P。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果</span><br><span class="line">    后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比</span><br><span class="line">    较，因此这个算法的时间复杂度是 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂</span><br><span class="line">    度为 O(nlogn)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html" target="_blank" rel="noopener">《数组中的逆序对》</a></p><h4 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二</span><br><span class="line">    个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一</span><br><span class="line">    个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈</span><br><span class="line">    ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这</span><br><span class="line">    一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个</span><br><span class="line">    指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，</span><br><span class="line">    判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html" target="_blank" rel="noopener">《两个链表的第一个公共结点》</a></p><h4 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37. 数字在排序数组中出现的次数"></a>37. 数字在排序数组中出现的次数</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出</span><br><span class="line">现了 4 次，因此输出 4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要</span><br><span class="line">    去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束</span><br><span class="line">    位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如</span><br><span class="line">    果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值</span><br><span class="line">    是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们</span><br><span class="line">    下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结</span><br><span class="line">    束位置。这一种方法的平均时间复杂度为 O(logn)。</span><br></pre></td></tr></table></figure><h4 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深</span><br><span class="line">度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</span><br></pre></td></tr></table></figure><h4 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39. 平衡二叉树"></a>39. 平衡二叉树</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它</span><br><span class="line">    就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。</span><br><span class="line"></span><br><span class="line">（2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深</span><br><span class="line">    度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</span><br></pre></td></tr></table></figure><h4 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40. 数组中只出现一次的数字"></a>40. 数组中只出现一次的数字</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中</span><br><span class="line">    的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下</span><br><span class="line">    的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和</span><br><span class="line">    B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会</span><br><span class="line">    被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</span><br></pre></td></tr></table></figure><h4 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41. 和为 S 的连续正数序列"></a>41. 和为 S 的连续正数序列</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究</span><br><span class="line">竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。</span><br><span class="line">现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序</span><br><span class="line">列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后</span><br><span class="line">判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续</span><br><span class="line">往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连</span><br><span class="line">续序列，直到数组遍历完成终止。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html" target="_blank" rel="noopener">《和为 s 的连续正数序列》</a></p><h4 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42. 和为 S 的两个数字"></a>42. 和为 S 的两个数字</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数</span><br><span class="line">的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和</span><br><span class="line">为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素</span><br><span class="line">。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和</span><br><span class="line">比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html" target="_blank" rel="noopener">《和为 S 的字符串》</a></p><h4 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43. 左旋转字符串"></a>43. 左旋转字符串</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的</span><br><span class="line">字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “X</span><br><span class="line">YZdefabc”。是不是很简单？OK，搞定它！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">字符串裁剪后拼接</span><br></pre></td></tr></table></figure><h4 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有</span><br><span class="line">一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了</span><br><span class="line">，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</span><br></pre></td></tr></table></figure><h4 id="45-扑克牌的顺子"><a href="#45-扑克牌的顺子" class="headerlink" title="45. 扑克牌的顺子"></a>45. 扑克牌的顺子</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出</span><br><span class="line">了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王</span><br><span class="line">，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作1，J 为11，</span><br><span class="line">Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。</span><br><span class="line">现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数</span><br><span class="line">组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空</span><br><span class="line">缺，这个数组实际上还是连续的。</span><br><span class="line"></span><br><span class="line">于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如</span><br><span class="line">果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0</span><br><span class="line">数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html" target="_blank" rel="noopener">《扑克牌的顺子》</a></p><h4 id="46-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#46-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="46. 圆圈中最后剩下的数字（约瑟夫环问题）"></a>46. 圆圈中最后剩下的数字（约瑟夫环问题）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数</span><br><span class="line">字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）使用环形链表进行模拟。</span><br><span class="line"></span><br><span class="line">（2）根据规律得出（待深入理解）</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html" target="_blank" rel="noopener">《圆圈中最后剩下的数字》</a></p><h4 id="47-1-2-3-…-n"><a href="#47-1-2-3-…-n" class="headerlink" title="47. 1+2+3+…+n"></a>47. 1+2+3+…+n</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特</span><br><span class="line">性来实现。</span><br></pre></td></tr></table></figure><h4 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过位运算，递归来实现。</span><br></pre></td></tr></table></figure><h4 id="49-把字符串转换成整数。"><a href="#49-把字符串转换成整数。" class="headerlink" title="49. 把字符串转换成整数。"></a>49. 把字符串转换成整数。</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描</span><br><span class="line">述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。</span><br></pre></td></tr></table></figure><h4 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50. 数组中重复的数字"></a>50. 数组中重复的数字</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知</span><br><span class="line">道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O</span><br><span class="line">    (n)，空间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值</span><br><span class="line">    交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要</span><br><span class="line">    额外的内存空间。</span><br></pre></td></tr></table></figure><h4 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51. 构建乘积数组"></a>51. 构建乘积数组</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A</span><br><span class="line">[i+1]*...*A[n-1]。不能使用除法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1] </span><br><span class="line"></span><br><span class="line">      D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1] </span><br><span class="line"></span><br><span class="line">      B[i]=C[i]×D[i]</span><br><span class="line"></span><br><span class="line">      将乘积分为前后两个部分，分别循环求出后，再进行相乘。</span><br><span class="line"></span><br><span class="line">（2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://zhuanlan.zhihu.com/p/34804711" target="_blank" rel="noopener">《构建乘积数组》</a></p><h4 id="52-正则表达式的匹配"><a href="#52-正则表达式的匹配" class="headerlink" title="52. 正则表达式的匹配"></a>52. 正则表达式的匹配</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来匹配包括&apos;.&apos;和&apos;*&apos;的正则表达式。模式中的字符&apos;.&apos;表示任意一个字符，而&apos;*&apos;表示它前面的字符可以出现任</span><br><span class="line">意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，</span><br><span class="line">但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）状态机思路（待深入理解）</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html" target="_blank" rel="noopener">《正则表达式匹配》</a></p><h4 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53. 表示数值的字符串"></a>53. 表示数值的字符串</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-</span><br><span class="line">16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用正则表达式实现</span><br></pre></td></tr></table></figure><h4 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54. 字符流中第一个不重复的字符"></a>54. 字符流中第一个不重复的字符</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次</span><br><span class="line">的字符是 &quot;g&quot; 。当从该字符流中读出前六个字符 &quot;google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。 输出描述：如果当前字符流</span><br><span class="line">没有存在出现一次的字符，返回#字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">同第 34 题</span><br></pre></td></tr></table></figure><h4 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个链表中包含环，如何找出环的入口结点？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我</span><br><span class="line">们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此</span><br><span class="line">通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。</span><br><span class="line"></span><br><span class="line">然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇</span><br><span class="line">点就是环的入口节点。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html" target="_blank" rel="noopener">《链表中环的入口结点》</a><br>   <a href="https://blog.csdn.net/shansusu/article/details/50285735" target="_blank" rel="noopener">《《剑指offer》——链表中环的入口结点》</a></p><h4 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1-&gt;2-&gt;3-</span><br><span class="line">&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头</span><br><span class="line">结点也可能被删除，所以在链表头额外添加一个结点。</span><br><span class="line"></span><br><span class="line">接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除</span><br><span class="line">之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev</span><br><span class="line">要始终与下一个没有重复的结点连接在一起。</span><br></pre></td></tr></table></figure><h4 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57. 二叉树的下一个结点"></a>57. 二叉树的下一个结点</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，</span><br><span class="line">还有一个指向父节点的指针。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">这个问题我们可以分为三种情况来讨论。</span><br><span class="line"></span><br><span class="line">第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点</span><br><span class="line">出发，一直沿着左子节点的指针，就能找到下一个节点。</span><br><span class="line"></span><br><span class="line">第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节</span><br><span class="line">点。</span><br><span class="line"></span><br><span class="line">第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到</span><br><span class="line">一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</span><br></pre></td></tr></table></figure><h4 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58. 对称二叉树"></a>58. 对称二叉树</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式</span><br><span class="line">，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉</span><br><span class="line">树。</span><br></pre></td></tr></table></figure><h4 id="59-按之字形顺序打印二叉树（待深入理解）"><a href="#59-按之字形顺序打印二叉树（待深入理解）" class="headerlink" title="59. 按之字形顺序打印二叉树（待深入理解）"></a>59. 按之字形顺序打印二叉树（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照</span><br><span class="line">从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层</span><br><span class="line">，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每</span><br><span class="line">一个栈遍历完成后进入下一层循环。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/Print.html" target="_blank" rel="noopener">《按之字形顺序打印二叉树》</a></p><h4 id="60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"><a href="#60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。" class="headerlink" title="60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"></a>60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还</span><br><span class="line">没有打印的结点数，另一个变量表示下一次结点的数目。</span><br></pre></td></tr></table></figure><h4 id="61-序列化二叉树（待深入理解）"><a href="#61-序列化二叉树（待深入理解）" class="headerlink" title="61. 序列化二叉树（待深入理解）"></a>61. 序列化二叉树（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">数组模拟</span><br></pre></td></tr></table></figure><h4 id="62-二叉搜索树的第-K-个节点"><a href="#62-二叉搜索树的第-K-个节点" class="headerlink" title="62. 二叉搜索树的第 K 个节点"></a>62. 二叉搜索树的第 K 个节点</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一颗二叉搜索树，请找出其中的第 k 小的结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</span><br></pre></td></tr></table></figure><h4 id="63-数据流中的中位数（待深入理解）"><a href="#63-数据流中的中位数（待深入理解）" class="headerlink" title="63. 数据流中的中位数（待深入理解）"></a>63. 数据流中的中位数（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据</span><br><span class="line">流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br></pre></td></tr></table></figure><h4 id="64-滑动窗口中的最大值（待深入理解）"><a href="#64-滑动窗口中的最大值（待深入理解）" class="headerlink" title="64. 滑动窗口中的最大值（待深入理解）"></a>64. 滑动窗口中的最大值（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的</span><br><span class="line">大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下</span><br><span class="line">6个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2</span><br><span class="line">,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用队列的方式模拟</span><br></pre></td></tr></table></figure><h4 id="65-矩阵中的路径（待深入理解）"><a href="#65-矩阵中的路径（待深入理解）" class="headerlink" title="65. 矩阵中的路径（待深入理解）"></a>65. 矩阵中的路径（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每</span><br><span class="line">一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子</span><br><span class="line">。例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的</span><br><span class="line">第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure><h4 id="66-机器人的运动范围（待深入理解）"><a href="#66-机器人的运动范围（待深入理解）" class="headerlink" title="66. 机器人的运动范围（待深入理解）"></a>66. 机器人的运动范围（待深入理解）</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能</span><br><span class="line">进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是</span><br><span class="line">，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure><p>剑指 offer 相关资料可以参考：<br><a href="https://blog.csdn.net/zzl819954692/article/details/79648054" target="_blank" rel="noopener">《剑指 offer 题目练习及思路分析》</a><br><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html" target="_blank" rel="noopener">《JS 版剑指 offer》</a><br><a href="https://wiki.jikexueyuan.com/project/for-offer/" target="_blank" rel="noopener">《剑指 Offer 学习心得》</a></p><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h4 id="1-明星问题"><a href="#1-明星问题" class="headerlink" title="1. 明星问题"></a>1. 明星问题</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个</span><br><span class="line">函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。</span><br><span class="line">    这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明</span><br><span class="line">    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移</span><br><span class="line">    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩</span><br><span class="line">    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f" target="_blank" rel="noopener">《一个明星和 n-1 个群众》</a></p><h4 id="2-正负数组求和"><a href="#2-正负数组求和" class="headerlink" title="2. 正负数组求和"></a>2. 正负数组求和</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和</span><br><span class="line">最接近零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分</span><br><span class="line">    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动</span><br><span class="line">    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法知识总结&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题系列" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
