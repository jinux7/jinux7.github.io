<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-03-12T07:34:13.762Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>generator自动运行器</title>
    <link href="/2020/03/12/generator%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E5%99%A8/"/>
    <id>/2020/03/12/generator自动运行器/</id>
    <published>2020-03-12T07:08:06.000Z</published>
    <updated>2020-03-12T07:34:13.762Z</updated>
    
    <content type="html"><![CDATA[<p>手写一个generator自动运行器<br><a id="more"></a></p><h1 id="generator自动运行器"><a href="#generator自动运行器" class="headerlink" title="generator自动运行器"></a>generator自动运行器</h1><p>generator函数是es6新出的功能，之后又推出了async函数，操作异步真的是超级简单。我觉得我们在实际项目中使用generator的机会非常少，即使使用，一般也会依赖co这样的库来方便的使用generator。<br>但是我却想研究一下generator，所以写了一个generator不用手动的调用next函数，而是自动的调用。</p><h2 id="generator手动next代码"><a href="#generator手动next代码" class="headerlink" title="generator手动next代码"></a>generator手动next代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function *gen() &#123;</span><br><span class="line">    var val_1 = yield p1();</span><br><span class="line">    var val_2 = yield p2(val_1);</span><br><span class="line">    var val_3 = yield p3(val_2);</span><br><span class="line">  &#125; </span><br><span class="line">  var g = gen();</span><br><span class="line">  window.gObj = null;</span><br><span class="line">  window.gObj_index = 0;</span><br><span class="line">  gObj = g.next();</span><br><span class="line">  gObj.value.then(function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">    gObj = g.next(res);</span><br><span class="line">    gObj.value.then(function(res) &#123;</span><br><span class="line">      console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，需要在generator函数里手动定义yield的表达式，之后在执行的时候需要手动的调用next函数，但是可以看出来，还是有嵌套的情况。</p><h2 id="generator自动运行代码"><a href="#generator自动运行代码" class="headerlink" title="generator自动运行代码"></a>generator自动运行代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// p1,p2,p3是3个Promise的执行函数</span><br><span class="line">  var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // p1callback,p2callback,p3callback对应着p1,p2,p3的回调</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc generator的生成函数</span><br><span class="line">   * @param &#123; Array &#125; Promise的函数数组</span><br><span class="line">   * @retuen &#123; Function &#125; generator函数</span><br><span class="line">  */</span><br><span class="line">  function gen(arr) &#123;</span><br><span class="line">    var valArr = [];</span><br><span class="line">    return function *() &#123;</span><br><span class="line">      for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">        valArr[i] = yield arr[i](valArr[i-1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc 自动执行generator的next()的函数</span><br><span class="line">   * @param &#123; Function &#125; gen函数</span><br><span class="line">   * @param &#123; Array &#125; Promise函数对应的回调函数数组</span><br><span class="line">   * @param &#123; Any &#125; 向generator的next中传入的值</span><br><span class="line">  */</span><br><span class="line">  function co(gen, arr, res) &#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    var gObj = null;</span><br><span class="line">    var gObj_index = 0;</span><br><span class="line">    function innerCo(g, arr, res) &#123;</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      if(gObj.done) return void 0;</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        arr[gObj_index++](res);  </span><br><span class="line">        if(!gObj.done) &#123;</span><br><span class="line">          innerCo(g, arr, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    innerCo(g, arr, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行co函数</span><br><span class="line">  co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</span><br></pre></td></tr></table></figure><p>可以看出来，最后只需要<code>co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</code>这样一行代码，省去了定义yield，省去了调用next。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先，我并没有去参考co这样的库的使用方法，如何使用都是自己想出来的。</li><li>目前代码只是超级简化版，我也是想验证一下我的想法而已，只有resolve的回调，并没写reject的回调。</li></ul><p>最后，<a href="https://github.com/jinux7/study-collections/tree/master/generator-co" target="_blank" rel="noopener">代码在这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写一个generator自动运行器&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化之时间切片</title>
    <link href="/2020/03/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87/"/>
    <id>/2020/03/12/前端性能优化之时间切片/</id>
    <published>2020-03-12T06:12:08.000Z</published>
    <updated>2020-03-12T07:00:54.136Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化之时间切片<br><a id="more"></a></p><h1 id="前端性能优化之时间切片"><a href="#前端性能优化之时间切片" class="headerlink" title="前端性能优化之时间切片"></a>前端性能优化之时间切片</h1><p>从用户的输入，再到显示器在视觉上给用户的输出，这一过程如果超过 100ms，那么用户会察觉到网页的卡顿，所以为了解决这个问题，每个任务不能超过 50ms，W3C 性能工作组在 LongTask 规范中也将超过 50ms 的任务定义为长任务。<br>所以为了避免长任务，一种方案是使用 Web Worker，将长任务放在 Worker 线程中执行，缺点是无法访问 DOM，而另一种方案是使用时间切片。</p><h2 id="什么是时间切片"><a href="#什么是时间切片" class="headerlink" title="什么是时间切片"></a>什么是时间切片</h2><p>时间切片的核心思想是：如果任务不能在 50 毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。<br>所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过 50ms 的小任务分散在宏任务队列中执行。<br><img src="/2020/03/12/前端性能优化之时间切片/1.png" alt="img"><br>上图可以看到主线程中有一个长任务，这个任务会阻塞主线程。使用时间切片将它切割成很多个小任务后，如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/2.png" alt="img"><br>可以看到现在的主线程有很多密密麻麻的小任务，我们将它放大后如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/3.png" alt="img"><br>可以看到每个小任务中间是有空隙的，代表着任务执行了一小段时间后，将让出主线程的控制权，让浏览器执行其他的任务。</p><blockquote><p>使用时间切片的缺点是，任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。但是为了避免卡死浏览器，这种取舍是很有必要的。</p></blockquote><h2 id="如何使用时间切片"><a href="#如何使用时间切片" class="headerlink" title="如何使用时间切片"></a>如何使用时间切片</h2><p>时间切片是一种概念，也可以理解为一种技术方案，它不是某个 API 的名字，也不是某个工具的名字。<br>事实上，时间切片充分利用了“异步”，在早期，可以使用定时器来实现，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        otherThing() // 执行了50毫秒</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码当按钮被点击时，本应执行 100 毫秒的任务现在被拆分成了两个 50 毫秒的任务。<br>在实际应用中，我们可以进行一些封装，封装后的使用效果类似下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts([someThing, otherThing], function() &#123;</span><br><span class="line">    console.log(&apos;done~&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当然，关于ts这个函数的 API 的设计并不是本文的重点，这里想说明的是，在早期可以利用定时器来实现“时间切片”。<br>ES6 带来了迭代器的概念，并提供了生成器 Generator 函数用来生成迭代器对象，虽然 Generator 函数最正统的用法是生成迭代器对象，但这不妨我们利用它的特性做一些其他的事情。<br>Generator 函数提供了yield关键字，这个关键字可以让函数暂停执行。然后通过迭代器对象的next方法让函数继续执行。</p><blockquote><p>对 Generator 函数不熟悉的同学，需要先学习 Generator 函数的用法。<br>利用这个特性，我们可以设计出更方便使用的时间切片，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    yield</span><br><span class="line">    otherThing() // 执行了50毫秒</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到，我们只需要使用yield这个关键字就可以将本应执行 100 毫秒的任务拆分成了两个 50 毫秒的任务。<br>我们甚至可以将 yield 关键字放在循环里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        someThing() // 执行了50毫秒</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码我们写了一个死循环，但依然不会阻塞主线程，浏览器也不会卡死。</p><h2 id="基于生成器的-ts-实现原理"><a href="#基于生成器的-ts-实现原理" class="headerlink" title="基于生成器的 ts 实现原理"></a>基于生成器的 ts 实现原理</h2><p>通过前面的例子，我们会发现基于 Generator 的时间切片非常好用，但其实 ts 函数的实现原理非常简单，一个最简单的 ts 函数只需要九行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const res = gen.next()</span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码虽然全部只有 9 行，关键代码只有 3、4 行，但这几行代码充分利用了事件循环机制以及 Generator 函数的特性。</p><blockquote><p>创造出这样的代码我还是很开心的。</p></blockquote><p>上面代码核心思想是：通过yield关键字可以将任务暂停执行，从而让出主线程的控制权；通过定时器可以将“未完成的任务”重新放在任务队列中继续执行。</p><h2 id="避免把任务分解的过于零碎"><a href="#避免把任务分解的过于零碎" class="headerlink" title="避免把任务分解的过于零碎"></a>避免把任务分解的过于零碎</h2><p>使用yield来切割任务非常方便，但如果切割的粒度特别细，反而效率不高。假设我们的任务执行100ms，最好的方式是切割成两个执行50ms的任务，而不是切割成 100 个执行1ms的任务。假设被切割的任务之间的间隔为4ms，那么切割成 100 个执行1ms的任务的总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 4) * 100 = 500ms</span><br></pre></td></tr></table></figure></p><p>如果切割成两个执行时间为50ms的任务，那么总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(50 + 4) * 2 = 108ms</span><br></pre></td></tr></table></figure></p><p>可以看到，在不影响用户体验的情况下，下面的总执行时间要比前面的少了 4.6 倍。<br>保证切割的任务刚好接近50ms，可以在用户使用yield时自行评估，也可以在ts函数中根据任务的执行时间判断是否应该一次性执行多个任务。<br>我们将ts函数稍微改进一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const start = performance.now()</span><br><span class="line">        let res = null</span><br><span class="line">        do &#123;</span><br><span class="line">            res = gen.next()</span><br><span class="line">        &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 25)</span><br><span class="line"></span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们测试下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    const start = performance.now()</span><br><span class="line">    while (performance.now() - start &lt; 1000) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这段代码在之前的版本中，在我的电脑上可以打印出 215 次 11，在后面的版本中可以打印出 6300 次 11，说明在总时间相同的情况下，可以执行更多的任务。<br>再看另一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>在我的电脑上，这段代码在之前的版本中，被切割成一万个小任务，总执行时间为 46秒，在之后的版本中，被切割成 52 个小任务，总执行时间为 1.5秒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上代码出自于网络，这里感谢作者的付出，同时贴出作者的原创地址:<br><a href="https://ppt.baomitu.com/d/b267a4a3" target="_blank" rel="noopener">《让你的网页更丝滑》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之时间切片&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>手写mockjs</title>
    <link href="/2020/03/10/%E6%89%8B%E5%86%99mockjs/"/>
    <id>/2020/03/10/手写mockjs/</id>
    <published>2020-03-10T03:32:31.000Z</published>
    <updated>2020-03-10T05:43:36.531Z</updated>
    
    <content type="html"><![CDATA[<p>简单的写一个mockjs<br><a id="more"></a></p><h1 id="手写mockjs"><a href="#手写mockjs" class="headerlink" title="手写mockjs"></a>手写mockjs</h1><p>在我们前端的开发中，mock数据是必须走的一环，我们可以完全脱离后端接口，等我们前端开发好了之后，再跟后台接口的无缝对接。<br>其实mock数据的方式有很多，比如写一些静态text文档，用nodejs写一个后台服务，都可以满足mock数据的需求。但是，最方便的莫过于使用mockjs工具库了，他可以自动的拦截ajax请求，返回配置好的mock数据。<br>我第一次这个库大概是2016年，感觉很方便，后来也想过它的实现原理是什么，不过当时没有想出来。最近在使用vue的ant pro时候，里面就使用了mockjs，于是准备自己写一个mockjs。<br>我并没有看mockjs的源码，不知道它是怎么实现的，我的想法是既然它可以拦截ajax的请求，那么肯定对原生的XMLHttpRequest做了什么处理，于是乎，我准备覆盖掉原生的XMLHttpRequest对象，这样使用ajax的时候new出来的对象是我自己写的构造函数，不就可以满足拦截ajax请求的目的了吗。<br>我只是实现了拦截ajax的初级功能，并没有深入，点到为止。<br>mockjs代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">// 将原生的XMLHttpRequest缓存起来</span><br><span class="line">window.XMLHttpRequestMock = window.XMLHttpRequest;</span><br><span class="line">// mock对象，用来存储ajax的path和返回的数据</span><br><span class="line">window.mock = &#123;</span><br><span class="line">  urlData: &#123;&#125;,</span><br><span class="line">  setPath: function(path, data) &#123;</span><br><span class="line">    this.urlData[path] = data;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">// 覆盖原生XMLHttpRequest的构造函数</span><br><span class="line">function XmlMock() &#123;</span><br><span class="line">  this.type = null;</span><br><span class="line">  this.url = null;</span><br><span class="line">  this.onreadystatechange = null;</span><br><span class="line">&#125;</span><br><span class="line">// open方法</span><br><span class="line">XmlMock.prototype.open = function(type, url) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">  this.url = url;</span><br><span class="line">  this.readyState = 4;</span><br><span class="line">  this.status = 200</span><br><span class="line">&#125;</span><br><span class="line">// send方法，这里会判断，如果请求的path在mock.urlData中则返回设置好据的数，</span><br><span class="line">// 如果不在，则利用原生的XMLHttpRequest来进行ajax网络请求</span><br><span class="line">XmlMock.prototype.send = function(params) &#123;</span><br><span class="line">  var path = &apos;&apos;; </span><br><span class="line">  var _this = this; </span><br><span class="line">  for(var key in mock.urlData) &#123;</span><br><span class="line">    if((this.url).indexOf(key)&gt;-1) &#123;</span><br><span class="line">      path = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(path) &#123;</span><br><span class="line">    this.responseText = mock.urlData[path];</span><br><span class="line">    this.onreadystatechange(this);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    var xhr = new XMLHttpRequestMock();</span><br><span class="line">    xhr.open(&apos;get&apos;, this.url, false);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123;</span><br><span class="line">        _this.responseText = xhr.responseText;</span><br><span class="line">        _this.onreadystatechange(_this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.XMLHttpRequest = XmlMock;</span><br></pre></td></tr></table></figure></p><p>html使用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;./mock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  mock.setPath(&apos;get/小明&apos;, &#123;name: &apos;小明&apos;&#125;);</span><br><span class="line">  mock.setPath(&apos;get/小红&apos;, &#123;name: &apos;小红&apos;&#125;);</span><br><span class="line"></span><br><span class="line">  fetchData(&apos;http://jinux.top/get/小明&apos;, function(res) &#123;</span><br><span class="line">    console.log(&apos;小明mock数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  fetchData(&apos;http://jinux.top/get/小红&apos;, function(res) &#123;</span><br><span class="line">    console.log(&apos;小红mock数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 测试真实的ajax数据，用的实际百度的一个链接</span><br><span class="line">  var testUrl = &apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/home/js/nu_instant_search_baaa58d.js&apos;;</span><br><span class="line">  fetchData(testUrl, function(res) &#123;</span><br><span class="line">    console.log(&apos;百度的真是数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 封装的ajax请求方法</span><br><span class="line">  function fetchData(url, callback) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;get&apos;, url, false);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123;</span><br><span class="line">        callback(xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>最后，附上代码，<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99mockjs" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的写一个mockjs&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>wireshark抓包工具</title>
    <link href="/2020/03/09/wireshark%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    <id>/2020/03/09/wireshark抓包工具/</id>
    <published>2020-03-09T07:18:21.000Z</published>
    <updated>2020-03-09T08:11:46.624Z</updated>
    
    <content type="html"><![CDATA[<p>wireshark是一款非常厉害的网络抓包工具<br><a id="more"></a></p><h1 id="wireshark抓包工具"><a href="#wireshark抓包工具" class="headerlink" title="wireshark抓包工具"></a>wireshark抓包工具</h1><p>作为一个前端开发，讨论网络抓包有点不务正业，但是知道点还是有好处的。<br>我平时用到的抓包工具有wireshark和charles，charles使用起来简单些，抓取http请求比较直观，wireshark的功能就强大得多，各种网络协议都可以解析，具体的使用细节就不说了，简单的说一下tcp协议的三次握手和四次挥手在wireshark中被抓取的数据。<br>首先看一下tcp的三次握手和四次挥手图解过程<br>1.三次握手：<br><img src="/2020/03/09/wireshark抓包工具/1.png" alt="img"><br>2.四次挥手：<br><img src="/2020/03/09/wireshark抓包工具/2.png" alt="img"><br>3.最后，wireshark抓取的数据：<br><img src="/2020/03/09/wireshark抓包工具/3.png" alt="img"><br>可以看到，前3个tcp是握手过程，最后4个tcp是挥手过程，中间的TLS协议是加密协议，因为我抓取的是https协议，所以会有加密协议。<br>本想再贴一个http协议的抓取截屏，抓了几次太乱了，还有好多失败的包，不贴了，大同小异，大概了解过程就行了，有精力的话，继续深入研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wireshark是一款非常厉害的网络抓包工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javascript严格模式</title>
    <link href="/2020/02/28/javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/02/28/javascript严格模式/</id>
    <published>2020-02-28T07:05:50.000Z</published>
    <updated>2020-03-01T08:45:34.425Z</updated>
    
    <content type="html"><![CDATA[<p>js的严格模式和普通模式的区别<br><a id="more"></a></p><h1 id="javascript严格模式"><a href="#javascript严格模式" class="headerlink" title="javascript严格模式"></a>javascript严格模式</h1><p>随着javascript的不断发展，严格模式在开发中是必须使用的，他有什么好处呢？<br>严格模式消除了一些不确定的行为，并且对某些不安全的操作抛出异常。它有助于解析引擎，优化代码，提高执行速度，也为以后新标准的制定留出余地。下面将对严格模式做一个详细的介绍。</p><h2 id="1-启用严格模式"><a href="#1-启用严格模式" class="headerlink" title="1.启用严格模式"></a>1.启用严格模式</h2><p>要使一个javascript文件运行于严格模式，只需要在文件顶部添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure></p><p>这行代码是一个编译指示，用以告知解析引擎以严格模式解析脚本。严格模式可以用于整个脚本或单个函数。在用于脚本文件时，”use strict”需放在所有其它语句前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// whole-script strict mode syntax</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var v = &quot;Hi! I&apos;m a strict mode script!&quot;;</span><br></pre></td></tr></table></figure></p><p>而用于函数时，需方在函数内第一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function strict() &#123;</span><br><span class="line">  // Function-level strict mode syntax</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  function nested() &#123;</span><br><span class="line">    return &quot;And so am I!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &quot;Hi! I&apos;m a strict mode function@ &quot; + nested();</span><br><span class="line">&#125;</span><br><span class="line">function notStrict() &#123;</span><br><span class="line">  return &quot;I&apos;m not strict.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-严格模式带来的变化"><a href="#2-严格模式带来的变化" class="headerlink" title="2.严格模式带来的变化"></a>2.严格模式带来的变化</h2><p>在语法和行为这两方面，严格模式都做了一些改变。这些变化主要分为以下几类。</p><ul><li>对错误抛出异常，而不是静默地忽略；</li><li>简化变量的使用，去掉引擎难以优化的语法功能；</li><li>简化eval和arguments的使用；</li><li>增加安全特性；</li><li>为javascript迎接新标准做准备；</li></ul><h3 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h3><p>对错误抛出异常，而不是静默的忽略。严格模式将过去那些能够被静默忽略的错误变成异常抛出，因为这类错误代表着代码目的的矛盾。不一致的代码也许在当时不会产生什么不良后果，但未来可能会引起严重问题。严格模式不会容忍这些错误，使得开发者能够立即发现并且解决。</p><h4 id="1-1"><a href="#1-1" class="headerlink" title="(1)"></a>(1)</h4><p>在正常模式下，对一个没有声明的变量赋值，会自动作用到全局对象上（node的global对象，浏览器的window对象）。严格模式禁止这种做法，以避免意外地修改全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">mistypedVaraible = 17; // ReferenceError</span><br></pre></td></tr></table></figure></p><p>上面的代码将会抛出类型为ReferenceError的异常</p><h4 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h4><p>在正常模式下，引擎会默认忽略对NaN赋值的语句，但在严格模式下，引擎会以抛异常的方式，立即向开发者反馈错误。类似的还有给一个指定为不可写的属性赋值，对只有取值函数getter的属性赋值，给一个不可扩展的对象增加属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">// Assignment to NaN</span><br><span class="line">NaN = &apos;a&apos;; // TypeError: Cannot assign to read noly property &apos;NaN&apos; of #&lt;Object&gt;</span><br><span class="line">// Assignment to a non-writable property</span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj1, &quot;x&quot;, &#123;</span><br><span class="line">  value: 42,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line">obj1.x = 9; // throws a TypeError</span><br><span class="line">// Assignment to a getter-only property</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  get x() &#123;</span><br><span class="line">    return 18;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2.x = 5; // throws a TypeError</span><br><span class="line">// Assignment to a new property on a non-extensible object</span><br><span class="line">var fixed = &#123;&#125;;</span><br><span class="line">Object.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = &quot;ohai&quot;; // throws a TypeError</span><br></pre></td></tr></table></figure></p><h4 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h4><p>严格模式禁止删除一个声明为不可删除的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">delete Object.prototype; // throws a TypeError</span><br></pre></td></tr></table></figure></p><h4 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h4><p>严格模式禁止声明重名属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var o = &#123;</span><br><span class="line">  p: 1,</span><br><span class="line">  p: 2</span><br><span class="line">&#125;; // !!! syntax error</span><br></pre></td></tr></table></figure></p><h4 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h4><p>严格模式规定，函数的参数名必须唯一，否则抛出语法错误。在正常模式下，相同名称的参数，位置最靠后的会把前面的隐藏，但所有参数仍然可以借由arguments[i]访问，因此这种隐藏的意义不大，很可能写错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, a, c) &#123; // syntax error</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  return a + b + c; // wrong if this code ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h4><p>八进制数的写法。ECMAScript 5 标准下的严格模式禁止八进制数，但在ECMAScript 6标准下，八进制数前面需要加0o。Node支持前面加0o的八进制数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">// Right</span><br><span class="line">var a = 0o10; // ES6: Octal</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">// 以下代码异常</span><br><span class="line">// SyntaxError</span><br><span class="line">var sum = 015 + // syntax error</span><br><span class="line">          197 + 142;</span><br></pre></td></tr></table></figure></p><h4 id="7"><a href="#7" class="headerlink" title="(7)"></a>(7)</h4><p>严格模式禁止为基本数据类型添加属性，以下操作非法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  false.true = &quot;&quot;; // TypeError</span><br><span class="line">  (14).sailing = &quot;home&quot;;  // TypeError</span><br><span class="line">  &quot;with&quot;.you = &quot;far away&quot;; // TypeError</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2)"></a>2)</h3><p>简化变量的使用，去掉引擎难以优化的语法功能。</p><h4 id="1-2"><a href="#1-2" class="headerlink" title="(1)"></a>(1)</h4><p>严格模式禁止使用with。with的问题在于，其语句内部的变量名只有在运行的时候才能够被决定，这使得引擎在编译阶段难以生成高效的代码。因为with代码块中的名称即有可能代表语句内部的变量，也有可能是with表达式中的对象属性，还有可能位于代码块外，甚至是全局对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x = 18;</span><br><span class="line">with(obj) &#123; // syntax error</span><br><span class="line">  x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="(2)"></a>(2)</h4><p>严格模式下，eval有单独的作用域，不能够使用eval语句在它之外创建变量。正常模式下，语句<figure class="highlight plain"><figcaption><span>x;")```会为它所在的运行环境声明一个变量x，在严格模式下，x只在eval语句的内部有效。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">var x = 18;</span><br><span class="line">var evalX = eval(&quot;&apos;use strict&apos;; var x = 42; x&quot;);</span><br><span class="line">console.assert(x === 18);</span><br><span class="line">console.assert(evalX === 42);</span><br></pre></td></tr></table></figure></p><h4 id="3-1"><a href="#3-1" class="headerlink" title="(3)"></a>(3)</h4><p>严格模式禁止删除变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x;</span><br><span class="line">delete x;                  // syntax error</span><br><span class="line">eval(&quot;var y; delete y;&quot;);  // syntax error</span><br></pre></td></tr></table></figure></p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3)"></a>3)</h3><p>简化eval和arguments的使用。严格模式将eval和arguments的一些怪异和奇特的用法做了限制，并倾向于将eval和arguments当作关键字处理。</p><h4 id="1-3"><a href="#1-3" class="headerlink" title="(1)"></a>(1)</h4><p>严格模式不允许对eval和arguments赋值。以下语句运行都会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">eval = 18;</span><br><span class="line">arguments++;</span><br><span class="line">++eval;</span><br><span class="line">var obj = &#123; set p(arguments) &#123; &#125; &#125;;</span><br><span class="line">var eval;</span><br><span class="line">try &#123; &#125; catch(arguments) &#123; &#125;</span><br><span class="line">function x(eval) &#123; &#125;</span><br><span class="line">function arguments() &#123; &#125;</span><br><span class="line">var y = function eval() &#123; &#125;;</span><br><span class="line">var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 18;&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="2-3"><a href="#2-3" class="headerlink" title="(2)"></a>(2)</h4><p>在严格模式下，修改函数参数不会影响arguments，下面的示例代码能够正常运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  a = 42;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">var pair = f(18);</span><br><span class="line">console.assert(pair[0] === 42);</span><br><span class="line">console.assert(pair[1] === 18);</span><br></pre></td></tr></table></figure></p><h4 id="3-3"><a href="#3-3" class="headerlink" title="(3)"></a>(3)</h4><p>arguments.callee不能再使用了。正常模式下，arguments.callee返回正在执行的函数本身的引用。在严格模式下，这种用法被禁止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">var f = function() &#123;</span><br><span class="line">  return arguments.callee;</span><br><span class="line">&#125;</span><br><span class="line">f(); // throws a TypeError;</span><br></pre></td></tr></table></figure></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4)"></a>4)</h3><p>增加安全特性。在严格模式下，写出安全的代码变得更容易，引擎不会越俎代庖，除非使用者有意地这样做。</p><h4 id="1-4"><a href="#1-4" class="headerlink" title="(1)"></a>(1)</h4><p>在严格模式下，函数的上下文对象this可以是简单的值，并且避免了对全局对象的引用。在正常模式下，this只是一个对象，例如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(true);</span><br></pre></td></tr></table></figure></p><p>运行结果为[Boolean: true]，引擎会自动地将简单类型打包为对应的对象。单严格模式不会做这样的转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(true);</span><br></pre></td></tr></table></figure></p><p>运行结果为true。<br>正常模式下，如果不指定this对象，或者指定为undefined或null，则this引用的是全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(null);</span><br></pre></td></tr></table></figure></p><p>上面的代码打印出全局的global对象。但在严格模式下，除非使用call或apply明确指定this为global对象，否则this为null或者undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(null);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p><h4 id="2-4"><a href="#2-4" class="headerlink" title="(2)"></a>(2)</h4><p>严格模式禁止访问函数对象属性caller和arguments，这意味着不再可能遍历调用堆栈了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function outer() &#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">function inner() &#123;</span><br><span class="line">  console.log(arguments.callee.caller);</span><br><span class="line">  // TypeError: &apos;caller&apos;, &apos;callee&apos;, and</span><br><span class="line">  // &apos;arguments&apos; properties may not be accessed</span><br><span class="line">  // on strict mode functions or the arguments</span><br><span class="line">  // objects for calls to them</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5)"></a>5)</h3><p>保留关键字。严格模式将implements,interface,let,package,private,protected,public,static和yield作为保留字，用户代码不能以这些名称命名变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function package(protected) &#123; // SyntaxError</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var implements;             // SyntaxError </span><br><span class="line">  interface;                  // SyntaxError</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    break interface;          // SyntaxError</span><br><span class="line">  &#125;</span><br><span class="line">  function private() &#123; &#125;      // SyntaxError</span><br><span class="line">&#125;</span><br><span class="line">function fun(static) &#123;        // SyntaxError</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js的严格模式和普通模式的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>前端异常处理</title>
    <link href="/2020/02/27/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>/2020/02/27/前端异常处理/</id>
    <published>2020-02-27T06:23:25.000Z</published>
    <updated>2020-02-27T14:52:05.707Z</updated>
    
    <content type="html"><![CDATA[<p>异常在前端的处理<br><a id="more"></a></p><h1 id="前端异常处理"><a href="#前端异常处理" class="headerlink" title="前端异常处理"></a>前端异常处理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p><ul><li>增强用户体验；</li><li>远程定位问题；</li><li>未雨绸缪，及早发现问题；</li><li>无法复线问题，尤其是移动端，机型，系统都是问题；</li><li>完善的前端方案，前端监控系统；</li></ul><p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p><ul><li>JS 语法错误、代码异常</li><li>AJAX 请求异常</li><li>静态资源加载异常</li><li>Promise 异常</li><li>Iframe 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p>下面我会针对每种具体情况来说明如何处理这些异常。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。<br>1.同步运行时错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name = &apos;jartto&apos;;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： ReferenceError: nam is not defined</span><br><span class="line">    at index.html:16</span><br></pre></td></tr></table></figure></p><p>2.不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name = &apos;jartto;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</span><br></pre></td></tr></table></figure></p><p>3.异步错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(nam);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: nam is not defined</span><br><span class="line">    at index.html:31</span><br></pre></td></tr></table></figure></p><p>可以看出，try-catch是捕获不到异步错误的，下面会介绍异步的错误如何捕获。</p><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。<br>1.同步错误和异步错误都可以捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// message：错误信息（字符串）。</span><br><span class="line">// source：发生错误的脚本URL（字符串）</span><br><span class="line">// lineno：发生错误的行号（数字）</span><br><span class="line">// colno：发生错误的列号（数字）</span><br><span class="line">// error：Error对象（对象）</span><br><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  return true; // 这里返回true，控制台就不会输出被捕获的那个错误自己抛出的异常提示，见下面截图。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/27/前端异常处理/1.png" alt="img"><br><img src="/2020/02/27/前端异常处理/2.png" alt="img"><br>2.再试试语法错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">let name = &apos;Jartto</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p><p>语法错误还是不能捕获<br>3.我们试试网络请求异常的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;img src=&quot;./jartto.png&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>不论是静态资源异常，或者接口异常，错误都无法捕获到。<br>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx，上面已经有提到过。<br>需要注意：</p><ul><li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li><li>onerror 无法捕获语法错误；<br>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。<h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window，所以我们需要在每一个元素节点上监听error事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var nImgs = document.querySelectorAll(&apos;img&apos;);</span><br><span class="line">  nImgs.forEach(item=&gt; &#123;</span><br><span class="line">    item.addEventListener(&apos;error&apos;, function(ev) &#123;</span><br><span class="line">      console.log(&apos;捕获到异常：&apos;, ev);</span><br><span class="line">    &#125;, false);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>上面是来捕获页面中所有的img元素标签出现的错误。<br>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： Event &#123;isTrusted: true, type: &quot;error&quot;, target: img#img, currentTarget: img#img, eventPhase: 2, …&#125;</span><br></pre></td></tr></table></figure></p><p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。<br>需要注意：</p><ul><li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 addEventListener 重复监听。</li></ul><h3 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h3><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。<br>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。<br>解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;, e);</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br><span class="line">var pro = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  reject(&apos;错误&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// pro.catch(err=&gt; &#123;</span><br><span class="line">//   console.log(&apos;promise catch 捕获：&apos; + err);</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，如果忘记了catch的话，全局也可以捕获到Promise的错误。<br>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： PromiseRejectionEvent &#123;isTrusted: true, promise: Promise, reason: &quot;错误&quot;, type: &quot;unhandledrejection&quot;, target: Window, …&#125;</span><br></pre></td></tr></table></figure></p><p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。<br>补充一点：如果去掉控制台的异常显示，需要加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure></p><h3 id="iframe-异常"><a href="#iframe-异常" class="headerlink" title="iframe 异常"></a>iframe 异常</h3><p>对于 iframe 的异常捕获，我们还得借力 window.onerror<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.frames[0].onerror = function (message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&apos;捕获到 iframe 异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Script-error"><a href="#Script-error" class="headerlink" title="Script error"></a>Script error</h3><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：<br>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://jartto.wang/main.js&quot; crossorigin&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>或者动态去添加 js 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.crossOrigin = &apos;anonymous&apos;;</span><br><span class="line">script.src = url;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p>特别注意，服务器端需要设置：Access-Control-Allow-Origin<br>此外，我们也可以试试这个-解决 Script Error 的另类思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener = function (type, listener, options) &#123;</span><br><span class="line">  const wrappedListener = function (...args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return listener.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (err) &#123;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单解释一下：<br>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">   const originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">   EventTarget.prototype.addEventListener = function (type, listener, options) &#123;</span><br><span class="line">+    // 捕获添加事件时的堆栈</span><br><span class="line">+    const addStack = new Error(`Event ($&#123;type&#125;)`).stack;</span><br><span class="line">     const wrappedListener = function (...args) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         return listener.apply(this, args);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (err) &#123;</span><br><span class="line">+        // 异常发生时，扩展堆栈</span><br><span class="line">+        err.stack += &apos;\n&apos; + addStack;</span><br><span class="line">         throw err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h3><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？<br>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。<br>1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">  sessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;);</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">      sessionStorage.setItem(&apos;time_before_crash&apos;, new Date().toString());</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&apos;beforeunload&apos;, function () &#123;</span><br><span class="line">  sessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if(sessionStorage.getItem(&apos;good_exit&apos;) &amp;&amp;</span><br><span class="line">  sessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) &#123;</span><br><span class="line">  /*</span><br><span class="line">      insert crash logging code here</span><br><span class="line">  */</span><br><span class="line">  alert(&apos;Hey, welcome back from your crash, looks like you crashed on: &apos; + sessionStorage.getItem(&apos;time_before_crash&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控<br>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p><h3 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = (err, vm, info) =&gt; &#123;</span><br><span class="line">  console.error(&apos;通过vue errorHandler捕获的错误&apos;);</span><br><span class="line">  console.error(err);</span><br><span class="line">  console.error(vm);</span><br><span class="line">  console.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h3><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  console.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。<br>需要注意的是：error boundaries 并不会捕捉下面这些错误。</p><ul><li>事件处理器</li><li>异步代码</li><li>服务端的渲染代码</li><li>在 error boundaries 区域内的错误<br>我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    // Display fallback UI</span><br><span class="line">    this.setState(&#123; hasError: true &#125;);</span><br><span class="line">    // You can also log the error to an error reporting service</span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      // You can render any custom fallback UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后我们像使用普通组件那样使用它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure></p><p>componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。<br>实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！</p><h3 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h3><p>通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。<br>动态创建 img 标签的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function report(error) &#123;</span><br><span class="line">  let reportUrl = &apos;http://jartto.wang/report&apos;;</span><br><span class="line">  new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reporter.send = function(data) &#123;</span><br><span class="line">  // 只采集 30%</span><br><span class="line">  if(Math.random() &lt; 0.3) &#123;</span><br><span class="line">    send(data)      // 上报错误信息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p><ul><li>可疑区域增加 Try-Catch</li><li>全局监控 JS 异常 window.onerror</li><li>全局监控静态资源异常 window.addEventListener</li><li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li><li>VUE errorHandler 和 React componentDidCatch</li><li>监控网页崩溃：window 对象的 load 和 beforeunload</li><li>跨域 crossOrigin 解决</li></ul><p>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p>这篇文章部分代码<a href="https://github.com/jinux7/study-collections/tree/master/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常在前端的处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>html元素节点的attribute&amp;property</title>
    <link href="/2020/02/24/html%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84attribute-property/"/>
    <id>/2020/02/24/html元素节点的attribute-property/</id>
    <published>2020-02-24T03:06:49.000Z</published>
    <updated>2020-02-24T04:25:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>元素节点attr和prop区别<br><a id="more"></a></p><h1 id="html元素节点的attribute-amp-property"><a href="#html元素节点的attribute-amp-property" class="headerlink" title="html元素节点的attribute&amp;property"></a>html元素节点的attribute&amp;property</h1><p>元素节点的attrbute和property大家可能都是用过，但是也是容易被大家忽略它俩到底区别在哪里。<br>想当初在使用jquery时,$(‘ele’).attr(),$(‘’ele).prop(),这两个方法我也是没有深入研究，再后来使用angular的时候有看到attribute和property的区别，今天我好好总结一下。</p><h2 id="attribute和property如何使用"><a href="#attribute和property如何使用" class="headerlink" title="attribute和property如何使用"></a>attribute和property如何使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这样一个input节点</span><br><span class="line">&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;</span><br><span class="line">// 首先，使用attribute来操作</span><br><span class="line">var nEle = document.getElementById(&apos;inp&apos;);</span><br><span class="line">nEle.setAttribute(&apos;class&apos;, &apos;wrap&apos;);</span><br><span class="line">nEle.getAttribute(&apos;class&apos;);</span><br><span class="line">// 使用property来操作</span><br><span class="line">nEle.index = 1;</span><br><span class="line">nEle.type = &apos;text&apos;;</span><br></pre></td></tr></table></figure><p>其实，attribute是在这个元素节点上设置属性，而property是在这个元素节点的dom对象上设置属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 想看看元素节点的attribute属性</span><br><span class="line">nEle.attributes</span><br><span class="line">// 想看看元素节点的property属性</span><br><span class="line">console.dir(nEle);</span><br><span class="line">// 打印出来的内容可以看到attributes也在其中</span><br></pre></td></tr></table></figure></p><h2 id="attribute和property实际区别"><a href="#attribute和property实际区别" class="headerlink" title="attribute和property实际区别"></a>attribute和property实际区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;</span><br><span class="line">// 还是这个元素节点</span><br><span class="line">// 页面加载时如果使用getAttribute(&apos;value&apos;)是可以获取&apos;val&apos;值的，当然，nEle.value也可以获取到</span><br><span class="line">   &apos;val&apos;。</span><br><span class="line">// 但是，如果现在你在input框中，把&apos;val&apos;改成&apos;val123&apos;</span><br><span class="line">// 你再使用getAttribute(&apos;value&apos;)方式获取到的还是&apos;val&apos;,而使用nEle.value可以获取到最新值&apos;val123&apos;</span><br><span class="line">// 从这样一个简单的操作，可以理解为，attribute时html元素上的，而property是html元素对象上的。</span><br></pre></td></tr></table></figure><p>其实，两者区别还有很多，这里不一一列举，一个小例子知道其区别就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元素节点attr和prop区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>http请求头的安全策略</title>
    <link href="/2020/02/18/http%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%9A%84%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    <id>/2020/02/18/http请求头的安全策略/</id>
    <published>2020-02-18T07:51:36.000Z</published>
    <updated>2020-02-18T08:56:33.335Z</updated>
    
    <content type="html"><![CDATA[<p>http请求头中相关安全的头字段<br><a id="more"></a></p><h1 id="http请求头的安全策略"><a href="#http请求头的安全策略" class="headerlink" title="http请求头的安全策略"></a>http请求头的安全策略</h1><p>我们的项目在经过开发，测试之后，还得经过安全小组的安全漏斗扫描，经常会暴漏一些返回头缺少安全字段的漏洞，今天我稍加整理常用的几个。<br>如果想了解更多的请求头和响应头的字段信息，可以看本站另一篇文章，<a href="/2019/04/15/http请求头响应头字段详解/">这里</a></p><h2 id="1-X-Frame-Options"><a href="#1-X-Frame-Options" class="headerlink" title="1.X-Frame-Options"></a>1.X-Frame-Options</h2><p>如果网站可以嵌入到IFRAME元素中，则攻击者可以在社交场合设计一种情况，即受害者被指向攻击者控制的网站，该网站构成目标网站的框架。然后攻击者可以操纵受害者在目标网站上不知不觉地执行操作。即使有跨站点请求伪造保护，这种攻击也是可能的，并且被称为“clickjacking”，有关更多信息，<a href="https://www.owasp.org/index.php/Clickjacking" target="_blank" rel="noopener">请参阅</a>。为了避免这种情况，创建了“X-Frame-Options”标题。此标题允许网站所有者决定允许哪些网站构建其网站。<br>通常的建议是将此标头设置为“SAMEORIGIN”，它只允许属于同源策略的资源构成受保护资源的框架，或者设置为“DENY”，它拒绝任何资源（本地或远程）尝试框架也提供“X-Frame-Options”标头的资源。如下所示：<br>X-Frame-Options：SAMEORIGIN<br>请注意，“X-Frame-Options”标题已被弃用，将由内容安全策略中的Frame-Options指令替换，该指令仍处于活动开发阶段。但是，“X-Frame-Options”标题目前具有更广泛的支持，因此仍应实施安全措施。<br>说白了呢，就是让你的网站禁止被嵌套。<br>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;httpProtocol&gt;</span><br><span class="line">  &lt;customHeaders&gt;</span><br><span class="line">    &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt;</span><br><span class="line">  &lt;/customHeaders&gt;</span><br><span class="line">&lt;/httpProtocol&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-Content-Security-Policy"><a href="#2-Content-Security-Policy" class="headerlink" title="2.Content-Security-Policy"></a>2.Content-Security-Policy</h2><p>内容安全策略（CSP）旨在允许Web应用程序的所有者通知客户端浏览器有关应用程序的预期行为（包括内容源，脚本源，插件类型和其他远程资源），这允许浏览器更多智能地执行安全约束。虽然CSP本质上是复杂的，如果没有适当部署它可能会变得混乱，一个应用良好的CSP可以大大降低利用大多数形式的跨站点脚本攻击的机会。<br>需要整个帖子来深入了解CSP允许的功能和不同设置，因此建议进一步阅读。以下是Mozilla开发者网络对CSP的<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP" target="_blank" rel="noopener">精彩介绍性帖子</a><br>下面的简要示例显示了如何使用CSP指定您的网站希望从任何URI加载图像，从受信任的媒体提供商（包括内容分发网络）列表中插入插件内容，以及仅从您控制的服务器加载脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy：default-src&apos;self&apos;; img-src *; object-src media1.example.com media2.example.com * .cdn.example.com; script-src trustedscripts.example.com</span><br></pre></td></tr></table></figure></p><p>请注意，使用CSP的主要问题涉及策略错误配置（即使用“不安全内联”），或使用过于宽松的策略，因此在实施CSP时应特别注意。<br>这个呢，是将你引入的一切，加一个限制，这样如果别人想通过一些手段在你的网站加一些不好的东西，我们就可以有效地防止了。<br>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;httpProtocol&gt;</span><br><span class="line">  &lt;customHeaders&gt;</span><br><span class="line">    &lt;add name=&quot;Content-Security-Policy&quot; value=&quot;script-src &apos;unsafe-inline&apos; http://localhost:56504; object-src &apos;none&apos;; style-src &apos;unsafe-inline&apos; http://localhost:56504;&quot; /&gt;</span><br><span class="line">    &lt;/customHeaders&gt;</span><br><span class="line">  &lt;/httpProtocol&gt;</span><br></pre></td></tr></table></figure></p><p>其中预设值有以下这些：</p><ul><li>none 不匹配任何东西。</li><li>self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。</li><li>unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。</li><li>unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。</li></ul><h1 id="3-X-Content-Type-Options"><a href="#3-X-Content-Type-Options" class="headerlink" title="3.X-Content-Type-Options"></a>3.X-Content-Type-Options</h1><p>互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：”text/html”代表html文档，”image/png”是PNG图片，”text/css”是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。<br>例如，我们即使给一个html文档指定Content-Type为”text/plain”，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure></p><p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// php</span><br><span class="line">header(&quot;X-Content-Type-Options:nosniff&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="4-X-XSS-Protection"><a href="#4-X-XSS-Protection" class="headerlink" title="4.X-XSS-Protection"></a>4.X-XSS-Protection</h2><p>顾名思义，这个响应头是用来防范XSS的。最早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置：</p><ul><li>0：禁用XSS保护；</li><li>1：启用XSS保护；</li><li>1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；<br>浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。<br>demo:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// php</span><br><span class="line">header(&quot;X-XSS-Protection: 1&quot;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http请求头中相关安全的头字段&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图片裁剪插件</title>
    <link href="/2020/02/16/%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E6%8F%92%E4%BB%B6/"/>
    <id>/2020/02/16/图片裁剪插件/</id>
    <published>2020-02-16T07:51:13.000Z</published>
    <updated>2020-02-17T01:33:58.172Z</updated>
    
    <content type="html"><![CDATA[<p>一个图片裁剪插件，并穿给后端<br><a id="more"></a></p><h1 id="图片裁剪插件"><a href="#图片裁剪插件" class="headerlink" title="图片裁剪插件"></a>图片裁剪插件</h1><p>我们在日常开发中，裁剪图片并上传，是经常出现的需求。前几天，就有一个这样的需求，但是要求比较特殊，于是自己写了一个图片裁剪插件，因为自己写的改起来比较灵活。</p><h2 id="其实裁剪图片无非就是"><a href="#其实裁剪图片无非就是" class="headerlink" title="其实裁剪图片无非就是:"></a>其实裁剪图片无非就是:</h2><ul><li>文件选择图片，利用FileReader将文件格式的图片转成base64格式。</li><li>把这个base64格式显示在页面上，作为原图。</li><li>可以在原图的上面弄一个剪裁的方框，可以用鼠标来控制大小并移动，我觉得这里是最难的，需要很强的逻辑能力。</li><li>再利用canvas，以原图为基准，进行画图的裁剪，最后通过canvas方法得到裁剪后的base64格式图片。</li><li>最后把base64格式的图片转成Blob对象，利用ajax传送给后端。</li></ul><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="选择图片文件转base64"><a href="#选择图片文件转base64" class="headerlink" title="选择图片文件转base64"></a>选择图片文件转base64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function file2base64(imgFile, callBack) &#123;</span><br><span class="line">  var fr = new FileReader();</span><br><span class="line">  fr.onload = function() &#123;</span><br><span class="line">    // fr.result就是base64格式数据</span><br><span class="line">    callBack(fr.result);</span><br><span class="line">  &#125;</span><br><span class="line">  fr.readAsDataURL(imgFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将base64图片转化blob"><a href="#将base64图片转化blob" class="headerlink" title="将base64图片转化blob"></a>将base64图片转化blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function base64url2blob(base64url) &#123;</span><br><span class="line">  var binaryString = atob(base64url.split(&apos;,&apos;)[1]),</span><br><span class="line">        mimeType = base64url.split(&apos;,&apos;)[0].match(/:(.*?);/)[1],</span><br><span class="line">        length = binaryString.length,</span><br><span class="line">        u8arr = new Uint8Array(length),</span><br><span class="line">        blob;</span><br><span class="line">    while(length--) &#123;</span><br><span class="line">      u8arr[length] = binaryString.charCodeAt(length);</span><br><span class="line">    &#125;</span><br><span class="line">    blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;);</span><br><span class="line">    return blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图片转化为blob"><a href="#将图片转化为blob" class="headerlink" title="将图片转化为blob"></a>将图片转化为blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function img2blob(nImg, compressVal) &#123;</span><br><span class="line">  // 获取图片原始宽高</span><br><span class="line">  var cloneImg = nImg.cloneNode(true);</span><br><span class="line">  var nCanvas = document.createElement(&apos;canvas&apos;);</span><br><span class="line">  nCanvas.style.display = &apos;none&apos;;</span><br><span class="line">  document.body.appendChild(nCanvas);</span><br><span class="line">  nCanvas.width = cloneImg.width;</span><br><span class="line">  nCanvas.height = cloneImg.height;</span><br><span class="line">  var ctx = nCanvas.getContext(&quot;2d&quot;);</span><br><span class="line">  ctx.drawImage(nImg,0,0,cloneImg.width,cloneImg.height);</span><br><span class="line">  var base64Data = nCanvas.toDataURL(&quot;image/jpeg&quot;, compressVal);</span><br><span class="line">  var blob = this.base64url2blob(base64Data);</span><br><span class="line">  return blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是几个重要的格式转换方法。<br>最后，贴出源码demo，里边包含后端接收的nodejs代码。<br><a href="https://github.com/jinux7/study-collections/tree/master/image-clipper-upload" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个图片裁剪插件，并穿给后端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="图片处理" scheme="/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手写一个自己的webpack</title>
    <link href="/2020/01/31/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84webpack/"/>
    <id>/2020/01/31/手写一个自己的webpack/</id>
    <published>2020-01-31T07:51:30.000Z</published>
    <updated>2020-01-31T09:24:16.564Z</updated>
    
    <content type="html"><![CDATA[<p>一个超级简化版的webpack打包工具<br><a id="more"></a></p><h1 id="手写一个自己的webpack"><a href="#手写一个自己的webpack" class="headerlink" title="手写一个自己的webpack"></a>手写一个自己的webpack</h1><p>webpack现在用的人非常多，我们在开发vue，react，angular的时候默认的打包工具就是webpack，作为一名前端开发者来说，webpack是现在必须掌握的技能之一。随着webpack版本的不断增加，功能和复杂度越来越高，会配置的话都得学一阵子，但是，抛开使用来说，想没想过它的原理是什么？如果自己写一个该从哪里入手呢，今天我就写一个简化版的webpack。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>简化版的webpack，实现了它的最基础的功能，也就是模块化的引用处理，比如，main.js文件依赖了a.js文件，使用es6的语法import语法，浏览器是不支持的，需要用工具打包成浏览器支持的语法，我就实现这个最基础的功能。</p><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>打包文件，首先需要分析代码，比如，入口文件main.js，分析出import语句，都依赖哪些文件，再去读取这些依赖的文件，而分析js代码就需要babel这个工具库，babel工具库可以将es6代码转换成es5，es3代码，功能特别强大。</p><h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><p>这里，依赖babel的3个工具，分别是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;@babel/core&quot;: &quot;^7.8.3&quot;,</span><br><span class="line">&quot;@babel/parser&quot;: &quot;^7.8.3&quot;,</span><br><span class="line">&quot;@babel/traverse&quot;: &quot;^7.8.3&quot;</span><br></pre></td></tr></table></figure></p><p>parser是用来将js代码解析成ast语法书。<br>traverse可以将ast语法书进行遍历，对相应的ast语法书节点做单独的获取或者处理。<br>babel-core是babel的核心，可以将es6的js代码或ast语法书转化成es5代码。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>用paser将es6的代码先转成ast语法树</p><h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>用traverse处理ast语法书中的import节点，获取依赖文件路径，并获取依赖文件的代码，重复做步骤1，步骤2的处理。</p><h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>用babel-core将获取到的文件全部转成es5语法。</p><h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>最后把这些文件拼接成一个可执行的js代码，保存起来，html直接引用就可以执行了。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>上面步骤都说了，但是还是有点抽象，下面贴出代码，一目了然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const parser = require(&apos;@babel/parser&apos;);</span><br><span class="line">const traverse = require(&apos;@babel/traverse&apos;).default;</span><br><span class="line">const babel = require(&apos;@babel/core&apos;);</span><br><span class="line"></span><br><span class="line">let ID = 0;</span><br><span class="line">function createAsset(fileName) &#123;</span><br><span class="line">  // 这个文件里所依赖的其它文件路径</span><br><span class="line">  let dependencies = [];</span><br><span class="line">  const content = fs.readFileSync(fileName, &apos;utf8&apos;);</span><br><span class="line">  // 用babel的parser来解析读取的的文件内容content,获取ast抽象语法书</span><br><span class="line">  const ast = parser.parse(content, &#123;</span><br><span class="line">    sourceType: &apos;module&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 用babel的traverse功能来观察ast语法树的相应节点，进行相应的处理</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration(&#123; node &#125;) &#123;</span><br><span class="line">      // console.log(node.source.value);</span><br><span class="line">      dependencies.push(node.source.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 用babel来讲es6语法转成es5语法</span><br><span class="line">  const &#123; code &#125; = babel.transformFromAstSync(ast, null, &#123;</span><br><span class="line">    presets: [&apos;@babel/preset-env&apos;]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  let id = ID++;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    id,</span><br><span class="line">    fileName,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createGraph() &#123;</span><br><span class="line">  const mainAsset = createAsset(&apos;./src/main.js&apos;);</span><br><span class="line">  // 队列存放单个文件资源,这里利用循环队列去搜寻依赖文件，而没有使用递归方法</span><br><span class="line">  const queue = [ mainAsset ];</span><br><span class="line">  for(const asset of queue) &#123;</span><br><span class="line">    const dirname = path.dirname(asset.fileName);</span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line">    asset.dependencies.forEach(relativePath =&gt; &#123;</span><br><span class="line">      const absolutePath = path.join(dirname, relativePath);</span><br><span class="line">      const child = createAsset(absolutePath);</span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return queue;</span><br><span class="line">&#125;</span><br><span class="line">// 打包生成处理后的js文件</span><br><span class="line">function bundle() &#123;</span><br><span class="line">  const graph = createGraph(&apos;./src/main.js&apos;);</span><br><span class="line">  let modules = ``;</span><br><span class="line">  graph.forEach(mod=&gt; &#123;</span><br><span class="line">    modules += `</span><br><span class="line">      $&#123;mod.id&#125;: [</span><br><span class="line">        function(require, module, exports) &#123;</span><br><span class="line">          $&#123;mod.code&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        $&#123;JSON.stringify(mod.mapping)&#125;</span><br><span class="line">      ],</span><br><span class="line">    `;</span><br><span class="line">  &#125;);</span><br><span class="line">  const result = `(function(modules) &#123;</span><br><span class="line">    function require(id) &#123;</span><br><span class="line">      const fn = modules[id][0],</span><br><span class="line">            mapping = modules[id][1];</span><br><span class="line">      function localRequire(relativePath) &#123;</span><br><span class="line">        return require(mapping[relativePath]);</span><br><span class="line">      &#125;</span><br><span class="line">      const module = &#123;</span><br><span class="line">        exports: &#123;&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn(localRequire, module, module.exports);</span><br><span class="line">      return module.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    require(0);</span><br><span class="line">  &#125;)(&#123;$&#123;modules&#125;&#125;)`;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = bundle();</span><br><span class="line">fs.writeFileSync(&apos;./dist/bundle.js&apos;, result);</span><br></pre></td></tr></table></figure></p><h2 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99webpack/nux-webpack" target="_blank" rel="noopener">截这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个超级简化版的webpack打包工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>简单的聊聊iframe</title>
    <link href="/2020/01/19/%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E8%81%8Aiframe/"/>
    <id>/2020/01/19/简单的聊聊iframe/</id>
    <published>2020-01-19T06:11:04.000Z</published>
    <updated>2020-01-19T06:41:47.197Z</updated>
    
    <content type="html"><![CDATA[<p>iframe在html中的简单使用<br><a id="more"></a></p><h1 id="简单的聊聊iframe"><a href="#简单的聊聊iframe" class="headerlink" title="简单的聊聊iframe"></a>简单的聊聊iframe</h1><p>我们在前端开发中，iframe的使用场景很多，即便是vue，react时代，我还是乐此不疲的在项目中使用iframe，因为它会隔离页面彼此的环境，避免造成一些不必要的干扰。</p><h2 id="在同域下使用iframe"><a href="#在同域下使用iframe" class="headerlink" title="在同域下使用iframe"></a>在同域下使用iframe</h2><p>在同域下使用iframe,父级页面可以获取iframe页面里的信息，还可以操作iframe页面中的内容。<br><a href="https://github.com/jinux7/study-collections/tree/master/iframe/same-origin" target="_blank" rel="noopener">案例</a><br>在同域下没什么好说的，父页面可以随意控制子页面。</p><h2 id="跨域下使用iframe"><a href="#跨域下使用iframe" class="headerlink" title="跨域下使用iframe"></a>跨域下使用iframe</h2><p>跨域下使用iframe,父页面是不能操作子页面的，但是子页面可以操作父页面。<br>而且，后台返回的头信息，还能够更加严格的控制iframe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;DENY&apos;); // 不允许此页面被iframe加载</span><br><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;SAMEORIGIN&apos;); // 只可以在相同域名下加载</span><br><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;allow-from http://baidu.com/&apos;); // 允许指定的url加载iframe,但是这个属性在chrome,firefox,opera并不好使,只在edge中兼容</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/jinux7/study-collections/tree/master/iframe/cross-origin" target="_blank" rel="noopener">案例</a><br>目前为止，没有找到跨域控制iframe页面内容的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iframe在html中的简单使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构的JavaScript实现</title>
    <link href="/2019/11/28/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/"/>
    <id>/2019/11/28/常用数据结构的JavaScript实现/</id>
    <published>2019-11-28T08:12:54.000Z</published>
    <updated>2019-11-28T08:16:47.245Z</updated>
    
    <content type="html"><![CDATA[<p>一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现<br><a id="more"></a></p><h1 id="常用数据结构的JavaScript实现"><a href="#常用数据结构的JavaScript实现" class="headerlink" title="常用数据结构的JavaScript实现"></a>常用数据结构的JavaScript实现</h1><p>觉得这篇文章很不错，收藏下来，感谢作者。<br><a href="https://mp.weixin.qq.com/s/04PFD6dHhUjdh7wpT33UMQ" target="_blank" rel="noopener">这里是连接哦</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux的常用操作</title>
    <link href="/2019/11/28/linux%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>/2019/11/28/linux的常用操作/</id>
    <published>2019-11-28T01:46:55.000Z</published>
    <updated>2020-02-04T01:52:10.250Z</updated>
    
    <content type="html"><![CDATA[<p>linux的一些基础常用操作<br><a id="more"></a></p><h1 id="linux的常用操作"><a href="#linux的常用操作" class="headerlink" title="linux的常用操作"></a>linux的常用操作</h1><h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><p>在linux下安装应用的方法有很多，我也尝试了好几种，最后感觉还是用yum安装方便。<br>在使用yum安装应用的时候需要配置一下yum源，这里写出两条命令，常用的应用软件都已经有了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -O http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="文件的移动"><a href="#文件的移动" class="headerlink" title="文件的移动"></a>文件的移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将repo结尾的文件移动到当前目录的back文件夹下</span><br><span class="line">mv *.repo ./back</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、删除文件命令</span><br><span class="line">rm -f 文件名</span><br><span class="line">将会强行删除文件，且无提示</span><br><span class="line">需要注意：</span><br><span class="line">使用rm -rf要格外注意，linux中没有回收站，慎重删除</span><br><span class="line">2、删除文件夹以及文件夹中的所有文件命令：</span><br><span class="line">rm -rf 目录名字</span><br><span class="line">其中：</span><br><span class="line">-r：向下递归删除</span><br><span class="line">-f：直接强行删除，且没有任何提示</span><br></pre></td></tr></table></figure><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep node</span><br></pre></td></tr></table></figure><h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><h3 id="搜索一个程序所在位置"><a href="#搜索一个程序所在位置" class="headerlink" title="搜索一个程序所在位置"></a>搜索一个程序所在位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">whereis &lt;程序名称&gt;</span><br><span class="line">查找软件的安装路径</span><br><span class="line">-b 只查找二进制文件</span><br><span class="line">-m 只查找帮助文件</span><br><span class="line">-s 只查找源代码</span><br><span class="line">-u 排除指定类型文件</span><br><span class="line">-f 只显示文件名</span><br><span class="line">-B &lt;目录&gt; 在指定目录下查找二进制文件</span><br><span class="line">-M &lt;目录&gt; 在指定目录下查找帮助文件</span><br><span class="line">-S &lt;目录&gt; 在指定目录下查找源代码</span><br></pre></td></tr></table></figure><h3 id="查找一个文件夹所在目录"><a href="#查找一个文件夹所在目录" class="headerlink" title="查找一个文件夹所在目录"></a>查找一个文件夹所在目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &lt;文件名&gt;</span><br></pre></td></tr></table></figure><h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><p>使用之前确保安装了lrzsz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lrzsz</span><br></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><h3 id="开启nginx服务"><a href="#开启nginx服务" class="headerlink" title="开启nginx服务"></a>开启nginx服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf.default</span><br><span class="line">// 以我的nginx安装目录为例，nginx.conf.default这个文件就是nginx的主默认配置文件</span><br></pre></td></tr></table></figure><h2 id="压缩和解压zip"><a href="#压缩和解压zip" class="headerlink" title="压缩和解压zip"></a>压缩和解压zip</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装zip</span><br><span class="line">yum install zip</span><br><span class="line">// 安装unzip</span><br><span class="line">yum install unzip</span><br></pre></td></tr></table></figure><h3 id="使用zip"><a href="#使用zip" class="headerlink" title="使用zip"></a>使用zip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：</span><br><span class="line">zip -q -r html.zip /home/html</span><br><span class="line">// 如果在我们在 /home/html 目录下，可以执行以下命令：</span><br><span class="line">zip -q -r html.zip *</span><br></pre></td></tr></table></figure><h3 id="使用unzip"><a href="#使用unzip" class="headerlink" title="使用unzip"></a>使用unzip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 它会默认将文件解压到当前目录 </span><br><span class="line"># unzip test.zip </span><br><span class="line">// 如果要解压到指定目录，可以加上 -d 选项</span><br><span class="line"># unzip test.zip -d /root/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的一些基础常用操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>chrome浏览器设置可跨域</title>
    <link href="/2019/11/20/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%8F%AF%E8%B7%A8%E5%9F%9F/"/>
    <id>/2019/11/20/chrome浏览器设置可跨域/</id>
    <published>2019-11-20T07:39:35.000Z</published>
    <updated>2019-11-20T08:02:01.960Z</updated>
    
    <content type="html"><![CDATA[<p>chrome浏览器设置可跨域<br><a id="more"></a></p><h1 id="chrome浏览器设置可跨域"><a href="#chrome浏览器设置可跨域" class="headerlink" title="chrome浏览器设置可跨域"></a>chrome浏览器设置可跨域</h1><p>跨域方法很多种，我比较喜欢简单粗暴的修改chrome配置<br>1.先chrome鼠标右键打开下，点击打开属性，出现下面这幅图<br><img src="/2019/11/20/chrome浏览器设置可跨域/1.png" alt="img"><br>2.将下面的这段粘贴在目标的字符串的后面，注意要隔着一个空格<br>chrome版本49之前：–disable-web-security<br>chrome版本49之后：open -a Google\ Chrome –args –disable-web-security –user-data-dir</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;chrome浏览器设置可跨域&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>css初始化</title>
    <link href="/2019/10/30/css%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>/2019/10/30/css初始化/</id>
    <published>2019-10-30T08:16:54.000Z</published>
    <updated>2019-10-30T08:31:54.672Z</updated>
    
    <content type="html"><![CDATA[<p>css的初始化设计<br><a id="more"></a></p><h1 id="css初始化"><a href="#css初始化" class="headerlink" title="css初始化"></a>css初始化</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">charset</span> <span class="string">"utf-8"</span>;<span class="selector-tag">html</span>&#123;<span class="attribute">background-color</span>:<span class="number">#fff</span>;<span class="attribute">color</span>:<span class="number">#000</span>;<span class="attribute">font-size</span>:<span class="number">12px</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">legend</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">xmp</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">xmp</span>,<span class="selector-tag">tt</span>,<span class="selector-tag">code</span>,<span class="selector-tag">kbd</span>,<span class="selector-tag">samp</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5</span>;<span class="attribute">font-family</span>:tahoma,arial,<span class="string">"Hiragino Sans GB"</span>,simsun,sans-serif&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">small</span>,<span class="selector-tag">big</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">font-family</span>:tahoma,arial,<span class="string">"Hiragino Sans GB"</span>,<span class="string">"微软雅黑"</span>,simsun,sans-serif&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">b</span>,<span class="selector-tag">strong</span>&#123;<span class="attribute">font-weight</span>:normal&#125;</span><br><span class="line"><span class="selector-tag">address</span>,<span class="selector-tag">cite</span>,<span class="selector-tag">dfn</span>,<span class="selector-tag">em</span>,<span class="selector-tag">i</span>,<span class="selector-tag">optgroup</span>,<span class="selector-tag">var</span>&#123;<span class="attribute">font-style</span>:normal&#125;</span><br><span class="line"><span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;<span class="attribute">border-spacing</span>:<span class="number">0</span>;<span class="attribute">text-align</span>:left&#125;</span><br><span class="line"><span class="selector-tag">caption</span>,<span class="selector-tag">th</span>&#123;<span class="attribute">text-align</span>:inherit&#125;</span><br><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">menu</span>&#123;<span class="attribute">list-style</span>:none&#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>,<span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">object</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">vertical-align</span>:middle&#125;</span><br><span class="line"><span class="selector-tag">article</span>,<span class="selector-tag">aside</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">figcaption</span>,<span class="selector-tag">hgroup</span>,<span class="selector-tag">details</span>,<span class="selector-tag">menu</span>&#123;<span class="attribute">display</span>:block&#125;</span><br><span class="line">audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>,<span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,<span class="selector-tag">q</span><span class="selector-pseudo">:before</span>,<span class="selector-tag">q</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>:<span class="string">"\0020"</span>&#125;</span><br><span class="line"><span class="selector-tag">textarea</span>&#123;<span class="attribute">overflow</span>:auto;<span class="attribute">resize</span>:vertical&#125;</span><br><span class="line"><span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>,<span class="selector-tag">a</span>&#123;<span class="attribute">outline</span>:<span class="number">0</span> none;<span class="attribute">border</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::-moz-focus-inner</span>,<span class="selector-tag">input</span><span class="selector-pseudo">::-moz-focus-inner</span>&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">mark</span>&#123;<span class="attribute">background-color</span>:transparent&#125;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">ins</span>,<span class="selector-tag">s</span>,<span class="selector-tag">u</span>,<span class="selector-tag">del</span>&#123;<span class="attribute">text-decoration</span>:none&#125;</span><br><span class="line"><span class="selector-tag">sup</span>,<span class="selector-tag">sub</span>&#123;<span class="attribute">vertical-align</span>:baseline&#125;</span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">overflow-x</span>: hidden;<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">font-size</span>: <span class="number">50px</span>;<span class="attribute">-webkit-tap-highlight-color</span>: transparent;&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: Arial, <span class="string">"Microsoft Yahei"</span>, <span class="string">"Helvetica Neue"</span>, Helvetica, sans-serif;<span class="attribute">color</span>: <span class="number">#333</span>;<span class="attribute">font-size</span>: .<span class="number">28em</span>;<span class="attribute">line-height</span>: <span class="number">1</span>;<span class="attribute">-webkit-text-size-adjust</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">hr</span> &#123;<span class="attribute">height</span>: .<span class="number">02rem</span>;<span class="attribute">margin</span>: .<span class="number">1rem</span> <span class="number">0</span>;<span class="attribute">border</span>: medium none;<span class="attribute">border-top</span>: .<span class="number">02rem</span> solid <span class="number">#cacaca</span>;&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="number">#25a4bb</span>;<span class="attribute">text-decoration</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">input</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;<span class="comment">/*屏蔽阴影*/</span></span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(0,0,0,0);</span><br><span class="line">    <span class="comment">/*ios android去除自带阴影的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止长按链接与图片弹出菜单 */</span></span><br><span class="line">    <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止选中文本(如无文本选中需求,此为必选项) */</span></span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;  </span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">-webkit-overflow-scrolling: touch; // ios滑动不卡顿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css的初始化设计&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="样式" scheme="/tags/%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>VUE自定义组件v-model使用</title>
    <link href="/2019/10/22/VUE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6v-model%E4%BD%BF%E7%94%A8/"/>
    <id>/2019/10/22/VUE自定义组件v-model使用/</id>
    <published>2019-10-22T05:55:13.000Z</published>
    <updated>2019-10-22T06:18:00.062Z</updated>
    
    <content type="html"><![CDATA[<p>vue中自定义组件v-model双向数据绑定的使用<br><a id="more"></a></p><h1 id="VUE自定义组件v-model使用"><a href="#VUE自定义组件v-model使用" class="headerlink" title="VUE自定义组件v-model使用"></a>VUE自定义组件v-model使用</h1><p>我们在写vue组建的时候，可以往组件里传prop，但是普通的属性都是单向数据流，要想在子组件里修改父组件里值，必须在父组件中定义一个事件，在子组件里<code>this.$emit(&#39;事件名&#39;,&#39;...参数&#39;)</code>,但是我觉得好麻烦，要想实现数据的双向绑定还得定义子组件调用的事件方法，我们可以直接使用<code>v-model</code>,可以简单些。<br>父组件代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Child v-model=<span class="string">"val"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      val: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子组件代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;val&#125;&#125;</span><br><span class="line">    &lt;div @click=<span class="string">"changeVal"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: [<span class="string">'val'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeVal () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="number">456</span>); <span class="comment">// 注意这里默认是input事件哦</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是双向数据绑定写着会简单些。<br>最后，看一下vue中v-model的语法糖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"price"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> :value=<span class="string">"price"</span> @input=<span class="string">"price=$event.target.value"</span>&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue中自定义组件v-model双向数据绑定的使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端优化之Pre技术简介</title>
    <link href="/2019/10/14/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E4%B9%8BPre%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/"/>
    <id>/2019/10/14/前端优化之Pre技术简介/</id>
    <published>2019-10-14T05:06:31.000Z</published>
    <updated>2019-10-14T05:23:30.164Z</updated>
    
    <content type="html"><![CDATA[<p>link标签中pre技术的介绍<br><a id="more"></a></p><h1 id="前端优化之Pre技术简介"><a href="#前端优化之Pre技术简介" class="headerlink" title="前端优化之Pre技术简介"></a>前端优化之Pre技术简介</h1><p>Pre技术：预加载技术。提供在不影响当前页面情况下，浏览器预加载资源的性能优化方案。</p><h2 id="DNS-Prefetch"><a href="#DNS-Prefetch" class="headerlink" title="DNS Prefetch"></a>DNS Prefetch</h2><p>就是上述提到的，用于告知浏览器，尽可能预先解析指定域名的DNS。使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"//the-domain-to-be-prefetched.com"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>至于兼容性，可以说是目前为止所有的Pre技术里最好的了，<a href="http://caniuse.com/#search=dns-prefetch" target="_blank" rel="noopener">兼容性查看</a><br>IE是从IE9开始支持DNS Prefetch的，但是，是从IE10开始支持dns-prefetch。IE9里，并不是使用dns-prefetch来定义一个DNS的预解析，而是使用prefetch。挺尴尬的，因为prefetch在w3规范里又被用到了另一个Pre技术，下面会讲到。</p><h2 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h2><p>预连接。和DNS Prefetch类似，但是，更进一步。它不仅要求浏览器预解析指定域名的DNS，还需要预先与服务器握手以及TLS协商（如果使用了HTTPS）。使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//the-domain-to-be-preconnect.com"</span> crossorigin=<span class="string">"anonymous"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p><a href="http://caniuse.com/#search=preconnect" target="_blank" rel="noopener">兼容性查看</a><br>由于会与服务器握手，因此，就需要确定“是否跨域”。和script类似，带crossorigin属性，以告知浏览器如何处理跨域和cookie。</p><h2 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h2><p>上述DNS Prefetch里提到过，IE9里使用的DNS Prefetch类型名是prefetch，但是，这个类型名在规范里又被用于另外一个意图。<br>Prefetch：预获取，在Preconnect基础上更进一步，它要求浏览器获取整个的指定资源，link[href]值指定的是某个具体资源，而不是简单的一个域名了。除了和Preconnect一样拥有rel、href和crossorigin外，还有as，可用于告知浏览器资源类型，这个类型和MIME不一样，是一个统称类型，比如：所有的图片都是as=”image”，JS的是as=”script”，HTML的是 as=”html”等，<a href="https://fetch.spec.whatwg.org/#concept-request-destination" target="_blank" rel="noopener">具体可以参考</a>。<br>使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"//the-domain.com/prefetch.js"</span> crossorigin <span class="keyword">as</span>=<span class="string">"script"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>as属性并不是必须的，但是建议加上，以便浏览器能更好的添加请求Header来优化资源的获取。<br>使用Prefetch，整个资源都会被加载，但是，浏览器不允许对资源预处理或执行，资源只是被提前加载，并缓存起来，以便将来使用。<a href="http://caniuse.com/#search=prefetch" target="_blank" rel="noopener">兼容性查看</a></p><h2 id="Prerender"><a href="#Prerender" class="headerlink" title="Prerender"></a>Prerender</h2><p>预渲染。与Prefetch类似，浏览器会下载整个资源，但是，Prefetch不允许浏览器对资源做预处理和执行，而Prerender则会告知浏览器，下载资源（HTML）并解析/执行它，包括被解析资源的子资源，这意味着会下载该HTML中的图片、样式、脚本等等。<br>Prerender没有as属性，它下载的是HTML，使用方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//the-domain-to-be-preconnect.com"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>由于不允许对当前页面产生影响，浏览器设置预渲染的页面visibilityState属性为hidden。<a href="http://caniuse.com/#search=prerender" target="_blank" rel="noopener">兼容性查看</a><br>建议少用这个，太耗资源。而且，查看上述兼容性，你会看到Chrome 58里又把这个功能干掉了。</p><h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>预加载。这是一个和Prefetch几乎一模一样的功能，但是，其加载的资源适用的场景又完全不一样。使用方式只是将上述Prefetch中的prefetch改成preload。其他的完全一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"//the-domain.com/prefetch.png"</span> crossorigin <span class="keyword">as</span>=<span class="string">"image"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>与Prefetch*不同之处在于：</p><ul><li>Prefetch的优先级很低，低到浏览器可以不加载</li><li>Preload的优先级很高，浏览器一定要加载</li><li>Prefetch加载的资源用于将来某个页面中（这意味着它可能压根不会被用到）</li><li>Preload加载的资源用于当前页面中</li></ul><p>所以，在使用prefetch还是preload时候，需要考虑上述的不同点，而不应该盲目使用。[Preload以前叫Subresource]<br><a href="http://caniuse.com/#search=preload" target="_blank" rel="noopener">兼容性查看</a><br>最后，上述Pre技术，除了Preload，其他的Pre都可能“不被浏览器执行”，这不是兼容性的问题，而是，这些Pre都不是浏览器必须行为，浏览器会根据一定的策略决定是否Pre相应的资源或操作，这些策略包括：CPU、内存等的占用率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;link标签中pre技术的介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>&lt;script&gt;标签的defer,async,module</title>
    <link href="/2019/10/14/script-%E6%A0%87%E7%AD%BE%E7%9A%84defer-async-module/"/>
    <id>/2019/10/14/script-标签的defer-async-module/</id>
    <published>2019-10-14T03:15:11.000Z</published>
    <updated>2019-10-14T04:32:47.370Z</updated>
    
    <content type="html"><![CDATA[<p><code>&lt;script&gt;</code>标签中defer,async,module的使用<br><a id="more"></a></p><h1 id="lt-script-标签的defer-async-module"><a href="#lt-script-标签的defer-async-module" class="headerlink" title="&lt;script>标签的defer,async,module"></a>&lt;script>标签的defer,async,module</h1><h2 id="defer-amp-async"><a href="#defer-amp-async" class="headerlink" title="defer&amp;async"></a>defer&amp;async</h2><p>传统方法<br>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"application/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">// module code</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="application/</span>javascript<span class="string">" src="</span>path/to/myModule.js<span class="string">"&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=”application/javascript”可以省略。<br>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。<br>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>&lt;script&gt;</code>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。<br>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>加载规则<br>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入type=”module”属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。<br>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。<br><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./foo.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>一旦使用了async属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。<br>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">"./utils.js"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>对于外部的模块脚本（上例是foo.js），有几点需要注意。</li><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明use strict。</li><li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li><li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。<br>下面是一个示例模块。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="keyword">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中defer,async,module的使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>测试相关术语整理</title>
    <link href="/2019/10/12/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E6%95%B4%E7%90%86/"/>
    <id>/2019/10/12/测试相关术语整理/</id>
    <published>2019-10-12T07:38:38.000Z</published>
    <updated>2019-10-12T07:55:59.342Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一些测试的相关术语<br><a id="more"></a></p><h1 id="测试相关术语整理"><a href="#测试相关术语整理" class="headerlink" title="测试相关术语整理"></a>测试相关术语整理</h1><p>作为一名前端开发工程师，工作中肯定会和测试同事打交道，为了不丢面子，一些测试用语还是应该知道滴。</p><ul><li>Unit testing（单元测试），指一段代码的基本测试，其实际大小是未定的，通常是一个函数或子程序，一般由开发者执行。</li><li>Integration testing（集成测试），被测试系统的所有组件都集成在一起，找出被测试系统组件之间关系和接口中的错误。该测试一般在单元测试之后进行。</li><li>Acceptance testing（验收测试），系统开发生命周期方法论的一个阶段，这时相关的用户和／或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。这是管理性和防御性控制。</li><li>Alpha testing (α测试),是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。</li><li>Beta testing(β测试),测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。</li><li>Black box testing（黑盒测试），指测试人员不关心程序具体如何实现的一种测试方法。根据软件的规格对软件进行各种输入和观察软件的各种输出结果来发现软件的缺陷的测试，这类测试不考虑软件内部的运作原理，因此软件对用户来说就像一个黑盒子。</li><li>White box testing（白盒测试），根据软件内部的工作原理分析来进行测试,基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。</li><li>Automated Testing（自动化测试），使用自动化测试工具来进行测试，这类测试一般不需要人干预，通常在GUI、性能等测试中用得较多。</li><li>Bug (错误)，有时称作defect（缺陷）或error（错误），软件程序中存在的编程错误，可能会带来不必要的副作用，软件的功能和特性与设计规格说明书或用户需求不一致的方面。软件缺陷表现特征为：软件未达到产品说明书标明的功能；软件出现产品说明书指明不会出现的错误；软件功能超出产品说明书指明的范围；虽然产品说明书未指出但是软件应达到的目标；软件测试人员或用户认为软件难以理解，不易使用，运行速度缓慢等问题。 Bug report（错误报告），也称为“Bug record（错误记录）”，记录发现的软件错误信息的文档，通常包括错误描述、复现步骤、抓取的错误图像和注释等。</li><li>Bug tracking system（错误跟踪系统，BTS），也称为“Defect tracking system，DTS”，管理软件测试缺陷的专用数据库系统，可以高效率地完成软件缺陷的报告、验证、修改、查询、统计、存储等任务。尤其适用于大型多语言软件的测试管理。</li><li>“抓虫大扫除”（Bug Bash）：在某一个版本的发行里程碑到达之后，在发行之前项目经理向全体开发组织发出通知，告诉大家哪一天的某个时间是Bug Bash的时间，到时候全体成员，包括开发、测试、文档等团队、甚至市场部门的员工，全都放下手中的工作，在规定的那一个或几个小时的时间里，每个人把自己当作是用户一样来使用这个未成品的软件，并且进行竞赛，看谁能找到最多的Bug。这样做的目的是，不是按照测试方案的顺序来检查软件，而是通过像真正的用户那样来使用软件，即完全是任意性的、无规则的顺序，看看在这样的使用条件下，还有没有仍旧没有被发现的严重的Bug。我们往往采用谁找到最严重的Bug 就得奖的方法来鼓励大家尽力找出Bug。抓虫大扫除一结束，项目经理马上进行新呈交的Bug数量的统计，然后向开发组织中的全体员工公布。得奖的小有免费的咖啡、午餐、电影票等，大有各种礼物。所以每次Bug Bash 大家都踊跃参加，找到很多测试案例执行时没找到的问题。</li><li>Exception（异常/例外），一个引起正常程序执行挂起的事件。</li><li>Crash（崩溃），计算机系统或组件突然并完全的丧失功能，例如软件或系统突然退出或没有任何反应（死机）。</li><li>Build（工作版本），软件开发过程中用于内部测试的功能和性能等不完善的软件版本。工作版本既可以是系统的可操作版本，也可以是展示要在最终产品中提供的部分功能的部分系统。</li><li>Functional testing (功能测试)，也称为behavioral testing（行为测试），根据产品特征、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化软件的功能测试，用于验证应用程序或网站对目标用户能正确工作。使用适当的平台、浏览器和测试脚本，以保证目标用户的体验将足够好，就像应用程序是专门为该市场开发的一样。</li><li>Load testing（负载测试），通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。在这种测试中，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力。负载测试的目标是确定并确保系统在超出最大预期工作量的情况下仍能正常运行。此外，负载测试还要评估性能特征，例如，响应时间、事务处理速率和其他与时间相关的方面。</li><li>Performance testing（性能测试），评价一个产品或组件与性能需求是否符合的测试。包括负载测试、强度测试、数据库容量测试、基准测试等类型。</li><li>Pilot testing（引导测试），软件开发中，验证系统在真实硬件和客户基础上处理典型操作的能力。在软件外包测试中，引导测试通常是客户检查软件测试公司测试能力的一种形式，只有通过了客户特定的引导测试，软件测试公司才能接受客户真实软件项目的软件测试。</li><li>Portability testing（可移植性测试），测试软件是否可以被成功移植到指定的硬件或软件平台上。</li><li>Compatibility Testing（兼容性测试），也称“Configuration testing（配置测试）”，测试软件是否和系统的其它与之交互的元素之间兼容，如：浏览器、操作系统、硬件等。验证测试对象在不同的软件和硬件配置中的运行情况。</li><li>Installing testing（安装测试），确保该软件在正常情况和异常情况的不同条件下，例如，进行首次安装、升级、完整的或自定义的安装都能进行安装。异常情况包括磁盘空间不足、缺少目录创建权限等。核实软件在安装后可立即正常运行。安装测试包括测试安装代码以及安装手册。安装手册提供如何进行安装，安装代码提供安装一些程序能够运行的基础数据。</li><li>International testing（国际化测试），国际化测试的目的是测试软件的国际化支持能力，发现软件的国际化的潜在问题，保证软件在世界不同区域中都能正常运行。国际化测试使用每种可能的国际输入类型，针对任何区域性或区域设置检查产品的功能是否正常，软件国际化测试的重点在于执行国际字符串的输入/输出功能。国际化测试数据必须包含东亚语言、德语、复杂脚本字符和英语（可选）的混合字符。</li><li>Localizability testing(本地化能力测试)，本地化能力是指不需要重新设计或修改代码，将程序的用户界面翻译成任何目标语言的能力。为了降低本地化能力测试的成本，提高测试效率，本地化能力侧是通常在软件的伪本地化版本上进行。本地化能力测试中发现的典型错误包括：字符的硬编码（即软件中需要本地化的字符写在了代码内部），对需要本地化的字符长度设置了国定值，在软件运行时以控件位置定位，图标和位图中包含了需要本地化的文本，软件的用户界面与文档术语不一致等。</li><li>Localization testing（本地化测试），本地化测试的对象是软件的本地化版本。本地化测试的目的是测试特定目标区域设置的软件本地化质量。本地化测试的环境是在本地化的操作系统上安装本地化的软件。从测试方法上可以分为基本功能测试，安装/卸载测试，当地区域的软硬件兼容性测试。测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和联机帮助等部分。</li><li>Ad hoc testing (随机测试)，没有书面测试用例、记录期望结果、检查列表、脚本或指令的测试。主要是根据测试者的经验对软件进行功能和性能抽查。随机测试是根据测试说明书执行用例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</li><li>Smoke testing（冒烟测试），冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作。冒烟测试的执行者是版本编译人员。参考“Sanity testing（健全测试）”。</li><li>Sanity testing（健全测试），软件主要功能成分的简单测试以保证它是否能进行基本的测试。</li><li>User interface（用户界面，UI），广义是指使用户可以和计算机进行交互的硬件和/或软件。狭义是指软件中的可见外观及其底层与用户交互的部分（菜单、对话框、窗口和其它控件）。</li><li>User interface testing (用户界面测试)，指测试用户界面的风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等等。UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。</li><li>Static testing（静态测试），不通过执行来测试一个系统。如代码检查，文档检查和评审等。</li><li>Regression testing（回归测试），在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，对软件的任何新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再现。</li><li>Capture/Replay Tool (捕获/回放工具)，一种测试工具，能够捕获在测试过程中传递给软件的输入，并且能够在以后的时间中，重复这个执行的过程。这类工具一般在GUI测试中用的较多。</li><li>Debug（调试），开发人员确定引起错误的根本原因和确定可能的修复措施的过程。一般发生在子系统或单元模块编码完成时，或者根据测试错误报告指出错误以后，开发人员需要执行调试过程来解决已存在的错误。</li><li>Deployment（部署），也称为shipment(发布)，对内部IT系统而言，指它的第一个版本通过彻底的测试、形成产品、交付给付款客户的阶段。 Dynamic testing（动态测试），通过执行软件的手段来测试软件。</li><li>Garbage characters（乱码字符），程序界面中显示的无意义的字符，例如，程序对双字节字符集的字符不支持时，这些字符不能正确显示。</li><li>GB 18030 testing（GB 18030测试），软件支持GB 18030字符集标准能力的测试，包括GB 18030字符的输入、输出、显示、存储的支持程度。</li><li>Priority（优先权），从商业角度出发是指错误的重要性，尤其是从客户和用户的角度出发，是指错误对于系统的可行性和可接受性的影响。与“Severity（严重性）”相对照。</li><li>Severity（严重性），错误对被测系统的影响程度，在终端用户条件下发生的可能性，软件错误妨碍系统使用的程度。</li><li>Quality assurance（质量保证QA），采取相关活动，以保证一个开发组织交付的产品满足性能需求和已确立的标准和过程。</li><li>Review（评审），在产品开发过程中，把产品提交给项目成员、用户、管理者或其它相关人员评价或批准的过程。</li><li>Screen shot（抓屏、截图），软件测试中，将软件界面中的错误（窗口、菜单、对话框等）的全部或一部分，使用专用工具存储成图像文件，以便于后续处理。</li><li>Software life cycle（软件生命周期），开始于一个软件产品的构思，结束于该产品不再被使用的这段期间。</li><li>Structured query language（结构化查询语句，SQL），在一个关系数据库中查询和处理数据的一种语言。</li><li>TBD(To be determined，待定)，在测试文档中标是一项进行中的尚未最终确定的工作。</li><li>Test（测试），执行软件以验证其满足指定的需求并检测错误的过程。检测已有条件之间的不同，并评价软件项的特性软件项的分析过程。软件工程过程的一个活动，它将软件在预定的条件下运行以判断软件是否符合预期结果。</li><li>Test case（测试用例），为特定目标而开发的一组测试输入、执行条件和预期结果，其目标可以是测试某个程序路径或核实是否满足某个特定的需求。</li><li>Testing coverage（测试覆盖），指测试系统覆盖被测试系统的程度，一项给定测试或一组测试对某个给定系统或构件的所有指定测试用例进行处理所达到的程度。</li><li>Testing environment（测试环境），进行测试的环境，包括测试平台、测试基础设施、测试实验室和其他设施。</li><li>Testing item（测试项），作为测试对象的工作版本。</li><li>Testing plan（测试计划），描述了要进行的测试活动的范围、方法、资源和进度的文档。它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。</li><li>Testing procedure（测试过程），指设置、执行给定测试用例并对测试结果进行评估的一系列详细步骤。</li><li>Testing script（测试脚本），一般指的是一个特定测试的一系列指令，这些指令可以被自动化测试工具执行。</li><li>Testing suite（测试包），一组测试用里的执行框架；一种组织测试用例的方法。在测试包里，测试用例可以组合起来创造出独特的测试条件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍一些测试的相关术语&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>带标签的模板字符串</title>
    <link href="/2019/10/12/%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>/2019/10/12/带标签的模板字符串/</id>
    <published>2019-10-12T07:01:55.000Z</published>
    <updated>2019-10-12T07:14:01.991Z</updated>
    
    <content type="html"><![CDATA[<p>模板字符串的特殊用法<br><a id="more"></a></p><h1 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h1><p>模板字符串中我们使用 ${exporession} 作为占位符，而作为字符串连接的语法糖是其最基本的用法，而带标签的模板字符串则是一种函数调用，这能够让模板字符串更加强大，拥有真正模板引擎的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params">strs, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strs)</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name =<span class="string">'jinux'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">a <span class="string">`name: <span class="subst">$&#123;name&#125;</span>, age: <span class="subst">$&#123;age&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>在浏览器的console面板打印一下。<br>可以看到，标签模板字符串的标签函数的第一个参数是由原始的字符串由占位字符串分割而成的字符串组成的数组，剩下的参数则是对应占位符的值。<br>利用这个特性常被提到的是避免XSS攻击：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">literals, ...placeholders</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> placeholders.reduce(<span class="function">(<span class="params">pre, val, i</span>) =&gt;</span> pre + literals[i] + val</span><br><span class="line">    .replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>), <span class="string">''</span>) + literals[literals.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模板字符串的特殊用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
