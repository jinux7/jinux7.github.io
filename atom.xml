<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-06-24T02:22:16.588Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见的web攻击方式</title>
    <link href="/2020/06/24/%E5%B8%B8%E8%A7%81%E7%9A%84web%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>/2020/06/24/常见的web攻击方式/</id>
    <published>2020-06-24T01:38:08.000Z</published>
    <updated>2020-06-24T02:22:16.588Z</updated>
    
    <content type="html"><![CDATA[<p>常见的web攻击方式<br><a id="more"></a></p><h1 id="常见的web攻击方式"><a href="#常见的web攻击方式" class="headerlink" title="常见的web攻击方式"></a>常见的web攻击方式</h1><p>简要的介绍下web常见的几种攻击方式</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>详请见本站文章<a href="https://jinux7.github.io/2018/11/28/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS/" target="_blank" rel="noopener">web安全之XSS</a></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>详请见本站文章<a href="https://jinux7.github.io/2018/11/28/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/" target="_blank" rel="noopener">web安全之CSRF</a></p><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>比如你访问黑客网站A，A网站iframe引入了一个博客网站B，A网站将iframe透明化，并且在iframe下面放一张美女图片，图片上有一个更新美女信息的按钮，这个按钮正好跟B网站发布信息按钮重合，当你不在意的点击了图片上的按钮，实际你点击的是透明化的B网站的发布信息按钮。</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入是对后端数据库的攻击<br>前端页面输入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：admin</span><br><span class="line">密码：<span class="number">1</span><span class="string">'or'</span><span class="number">1</span><span class="string">'='</span><span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这里的密码是一段SQL语句，后台在利用前端传来的红户名和密码拼装好一段SQL语句，并查询就会返回true。<br>拼接后的SQL语句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE username = <span class="string">'admin'</span> AND password = <span class="string">'1'</span>or<span class="string">'1'</span>=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="OS注入"><a href="#OS注入" class="headerlink" title="OS注入"></a>OS注入</h2><p>OS注入式针对操作系统的<br>以nodejs为例，假如在接口中需要从github下载用户指定的repo，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'mz/child_process'</span>).exec;</span><br><span class="line"><span class="keyword">let</span> params = <span class="comment">// 用户输入的参数</span></span><br><span class="line">exec(<span class="string">`git clone <span class="subst">$&#123;params.repo&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></p><p>如果传入的参数是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/xx/xx.git &amp;&amp; rm -rf /*</span></span><br></pre></td></tr></table></figure></p><p>执行完拉取库的命令后继续执行一个删除当前路径下所有文件的操作。</p><h2 id="请求劫持"><a href="#请求劫持" class="headerlink" title="请求劫持"></a>请求劫持</h2><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS服务器（DNS解析的各个步骤）被纂改，修改了域名解析的结果，使得访问到的不是预期的ip。</p><h3 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h3><p>运营商劫持，此时大概只能升级HTTPS了。</p><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">可以看一下阮老师的这篇文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的web攻击方式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>chrome调试之overrides</title>
    <link href="/2020/06/22/chrome%E8%B0%83%E8%AF%95%E4%B9%8Boverrides/"/>
    <id>/2020/06/22/chrome调试之overrides/</id>
    <published>2020-06-22T03:19:42.000Z</published>
    <updated>2020-06-22T05:23:18.857Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器调试之overrides<br><a id="more"></a></p><h1 id="chrome调试之overrides"><a href="#chrome调试之overrides" class="headerlink" title="chrome调试之overrides"></a>chrome调试之overrides</h1><p>平时我们用浏览器调试代码很普遍，今天我介绍一个浏览器的小技能，可以覆盖网站的代码，在本地生成一个一样的文件，刷新网站的时候浏览器会加载本地生成的文件，这样，可以实时的修改代码并且观察修改后的效果。<br>启用步骤：<br>1.在浏览器的调试面板进入sources.<br>2.点击overrides,会看到一个<code>+ Select folder for overrides</code>,点击加号选择一个存放文件的文件夹。（注意浏览器上方会有一个权限提示，点击允许）<br>3.这时还是在sources面板下，点击Page，切换到此网站的源代码展示目录，选择一个要调试的文件（html,js,css均可），单击右键，选择<code>Save for overrides</code>, 之后可以在刚才选择的文件夹下看到这个保存到本地的文件，修改这个文件后再刷新页面，就可以看到修改后的变化了。<br>4.在overrides面板下可以看到<code>Enable Local Overrides</code>,切换这个选项可以控制本地代码是否参与执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器调试之overrides&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="调试" scheme="/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="浏览器" scheme="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>jwt、session、oauth简单介绍</title>
    <link href="/2020/06/19/jwt%E3%80%81session%E3%80%81oauth%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>/2020/06/19/jwt、session、oauth简单介绍/</id>
    <published>2020-06-19T03:04:57.000Z</published>
    <updated>2020-06-19T03:33:41.954Z</updated>
    
    <content type="html"><![CDATA[<p>jwt、session、oauth的鉴权简单说明<br><a id="more"></a></p><h1 id="jwt、session、oauth简单介绍"><a href="#jwt、session、oauth简单介绍" class="headerlink" title="jwt、session、oauth简单介绍"></a>jwt、session、oauth简单介绍</h1><h2 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h2><p>jwt是json web token的缩写，jwt的鉴权流程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用户向服务器发送用户名和密码。</span><br><span class="line"><span class="number">2</span>、服务器验证通过后，生成jwt，可以有选择的在其中    保存用户信息及数据。也可以加密。    </span><br><span class="line"><span class="number">3</span>、服务器向用户返回jwt。</span><br><span class="line"><span class="number">4</span>、用户随后的每一次请求，都会在 cookie 或者 header或参数里，将 jwt 传回服务器鉴权。</span><br><span class="line"><span class="number">5</span>、服务器收到jwt，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure></p><p>jwt内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分为 头部（header),载荷（payload)，签证（signature). 用 “.” 分隔。</span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1</span><br><span class="line">NDM0ODg3NjgsImp0aSI6ImFjYzhmZjIzLWM1MjgtNDk3OS04N</span><br><span class="line">TYwLWY0NGFmYWNhNDY4MiIsImlzcyI6ImJpenN2YyIsIm5iZ</span><br><span class="line">iI6NTQzNDgxNTY4LCJzdWIiOiJ0b2tlbi14ajZqOTo3emg1Y</span><br><span class="line">md2OGI1cWZrN2JoNnJxZ3o3djV0OGJ2amhiNHNoazQ5aGh6O</span><br><span class="line">GtjcWN6NmpnNWI3ejIifQ.dRKURNOUFOlgO7zBxMajF7<span class="number">-8</span>Wn</span><br><span class="line"><span class="number">0</span>zYs8x2t0UU6SYtP4</span><br></pre></td></tr></table></figure></p><p>优缺点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有跨域问题、集群下登录信息同步的问题。</span><br><span class="line">一旦签发，到期前无法简单废止，最好用https。</span><br><span class="line">server无状态，性能高。</span><br></pre></td></tr></table></figure></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session是利用cookie做健全的，流程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用户向服务器发送用户名和密码。</span><br><span class="line"><span class="number">2</span>、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</span><br><span class="line"><span class="number">3</span>、服务器向用户返回一个 session_id，写入用户的 Cookie。</span><br><span class="line"><span class="number">4</span>、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</span><br><span class="line"><span class="number">5</span>、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure></p><p>优缺点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扩展性不好，存在跨域 和 集群session同步的问题。</span><br><span class="line">面对csrf 攻击，不如jwt。</span><br></pre></td></tr></table></figure></p><h2 id="oauth-用于第三方认证"><a href="#oauth-用于第三方认证" class="headerlink" title="oauth 用于第三方认证"></a>oauth 用于第三方认证</h2><p>目的在于让客户端安全可控地获取”用户”的授权。<br>比如说，登录微博（客户端）的时候，懒得新建账号了就用qq账号登录，选择qq登录。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oauth场景，客户端不必保存登录用户（qq）的登录密码。  </span><br><span class="line">更精细的控制权限，即权限的到期时间，提升安全性。</span><br><span class="line">有四种模式：</span><br><span class="line">    授权码模式（authorization code）</span><br><span class="line">    简化模式（implicit）</span><br><span class="line">    密码模式（resource owner password credentials）</span><br><span class="line">    客户端模式（client credentials）</span><br></pre></td></tr></table></figure></p><p>这里我做了一个github的第三方登录鉴权，详情<a href="https://github.com/jinux7/study-collections/tree/master/oauth-github%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">点这里</a>查看。<br>在做鉴权之前，需要登录github，之后在setting-&gt;Developer settings开启github鉴权功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jwt、session、oauth的鉴权简单说明&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="github" scheme="/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1和HTTP2的区别</title>
    <link href="/2020/06/18/HTTP1%E5%92%8CHTTP2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>/2020/06/18/HTTP1和HTTP2的区别/</id>
    <published>2020-06-18T06:51:59.000Z</published>
    <updated>2020-06-18T08:36:58.916Z</updated>
    
    <content type="html"><![CDATA[<p>简单的说一下http1和http2的区别<br><a id="more"></a></p><h1 id="HTTP1和HTTP2的区别"><a href="#HTTP1和HTTP2的区别" class="headerlink" title="HTTP1和HTTP2的区别"></a>HTTP1和HTTP2的区别</h1><h2 id="Http1-x"><a href="#Http1-x" class="headerlink" title="Http1.x"></a>Http1.x</h2><p>缺陷：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞。</p><h2 id="Http1-0-短连接"><a href="#Http1-0-短连接" class="headerlink" title="Http1.0(短连接)"></a>Http1.0(短连接)</h2><p>缺陷：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；<br>解决方案：添加头信息——非标准的Connection字段Connection: keep-alive</p><h2 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h2><p>改进点：<br>1.持久连接（与Http1其它版本的最大区别）<br>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive(对于同一个域名，大多数浏览器允许同时建立6个持久连接)<br>2.管道机制<br>即在同一个TCP连接里面，客户端可以同时发送多个请求。<br>3.分块传输编码<br>即服务端每产生一块数据，就发送一块，采用”流模式”而取代”缓存模式”。<br>4.新增请求方式<br>PUT:请求服务器存储一个资源;<br>DELETE：请求服务器删除标识的资源；<br>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；<br>TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；<br>CONNECT：保留将来使用<br>5.缺点：<br>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”</p><ul><li>避免方式：一是减少请求数，二是同时多开持久连接</li></ul><h2 id="Http-2-0"><a href="#Http-2-0" class="headerlink" title="Http/2.0"></a>Http/2.0</h2><p>特点：<br>1.采用二进制格式而非文本格式；<br>2.完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；（解决了线头阻塞的问题，与Http1最重要的区别）<br>3.使用报头压缩，降低开销<br>4.服务器推送</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。<br>二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。</p><h3 id="完全多路复用"><a href="#完全多路复用" class="headerlink" title="完全多路复用"></a>完全多路复用</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><h3 id="报头压缩"><a href="#报头压缩" class="headerlink" title="报头压缩"></a>报头压缩</h3><p>1.HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>2.对于相同的头部，不必再通过请求发送，只需发送一次；<br>3.HTTP/2 对这一点做了优化，引入了头信息压缩机制；<br>4.一方面，头信息使用gzip或compress压缩后再发送；<br>5.另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的说一下http1和http2的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs常驻后台运行</title>
    <link href="/2020/06/05/Nodejs%E5%B8%B8%E9%A9%BB%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>/2020/06/05/Nodejs常驻后台运行/</id>
    <published>2020-06-05T09:05:27.000Z</published>
    <updated>2020-06-08T01:28:29.261Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs程序在后台运行<br><a id="more"></a></p><h1 id="Nodejs常驻后台运行"><a href="#Nodejs常驻后台运行" class="headerlink" title="Nodejs常驻后台运行"></a>Nodejs常驻后台运行</h1><p>nodejs是通过命令行方式执行，当用户的xshell断开时Nodejs也就停止运行了。下面介绍几种办法让Nodejs常驻在后台运行</p><h2 id="pm2-推荐"><a href="#pm2-推荐" class="headerlink" title="pm2(推荐)"></a>pm2(推荐)</h2><p><a href="http://pm2.io/" target="_blank" rel="noopener">官网地址</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br><span class="line">pm2 start app.js        <span class="comment">// 启动</span></span><br><span class="line">pm2 start app.js -i max <span class="comment">//启动 使用所有CPU核心的集群</span></span><br><span class="line">pm2 stop app.js         <span class="comment">// 停止</span></span><br><span class="line">pm2 stop all            <span class="comment">// 停止所有</span></span><br><span class="line">pm2 restart app.js      <span class="comment">// 重启</span></span><br><span class="line">pm2 restart all         <span class="comment">// 重启所有</span></span><br><span class="line">pm2 <span class="keyword">delete</span>  app.js      <span class="comment">// 关闭</span></span><br></pre></td></tr></table></figure></p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup node app.js &amp;</span><br></pre></td></tr></table></figure><h2 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h2><p><a href="https://github.com/nodejitsu/forever" target="_blank" rel="noopener">github地址</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install forever -g</span><br><span class="line">forever start app.js    <span class="comment">//启动</span></span><br><span class="line">forever stop app.js     <span class="comment">//关闭</span></span><br><span class="line">forever stopall         <span class="comment">//关闭全部</span></span><br><span class="line">forever restart app.js  <span class="comment">//重启</span></span><br><span class="line">forever restartall      <span class="comment">//重启全部</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs程序在后台运行&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="linux" scheme="/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>前端埋点</title>
    <link href="/2020/05/29/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/"/>
    <id>/2020/05/29/前端埋点/</id>
    <published>2020-05-29T03:13:42.000Z</published>
    <updated>2020-05-29T06:16:56.139Z</updated>
    
    <content type="html"><![CDATA[<p>全面的介绍前端埋点知识<br><a id="more"></a></p><h1 id="前端埋点"><a href="#前端埋点" class="headerlink" title="前端埋点"></a>前端埋点</h1><p>所谓「埋点」，就是在正常的功能逻辑中添加统计逻辑。拿统计微信右上角「+」的点击次数为例，上报的数据可以采用KEY-VALUE形式，我们定义KEY为「CLICK_ADD_BTN」，VALUE的值为点击的次数。当用户点击「+」时，展示菜单的代码会通过按钮的「回调」来触发执行，程序猿在业务代码执行完后，又加上了统计代码，把「CLICK_ADD_BTN」对应的VALUE加1，「+」被统计到了一次使用。<br>目前常见的前端埋点技术有3类：代码埋点、可视化埋点、无埋点（无埋点属于埋点的一个子集）。</p><h2 id="代码埋点："><a href="#代码埋点：" class="headerlink" title="代码埋点："></a>代码埋点：</h2><p>控件操作发生时通过预先写好的代码来发送数据。<br>优点：</p><ul><li>控制发送数据时间，事件自定义属性详细记录</li></ul><p>缺点：</p><ul><li>时间、人力成本大，数据传输的时效性。</li></ul><h2 id="可视化埋点："><a href="#可视化埋点：" class="headerlink" title="可视化埋点："></a>可视化埋点：</h2><p>利用可视化交互手段，通过可视化界面配置控件操作与事件操作发生关系。通过后台截屏的方式采集数据。<br>优点：</p><ul><li>成本低，速度快</li></ul><p>缺点：</p><ul><li>行为记录信息少，支持的分析方式少</li></ul><h2 id="无埋点："><a href="#无埋点：" class="headerlink" title="无埋点："></a>无埋点：</h2><p>Growing IO和Heap analytics，这2家是国内与国外的无埋点技术公司代表。用户展现界面元素时，通过控件绑定触发事件，事件被触发的时候系统会有相应的接口让开发者处理这些行为。现在市面上主流无埋点做法有两种，一种是预先跟踪所有的渲染信息，一种是滞后跟踪的渲染信息。<br>优点：</p><ul><li>无需埋点，方便快捷</li></ul><p>缺点：</p><ul><li>行为记录信息少，传输压力大</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，关于埋点有无问题，可视化埋点和代码优劣问题，不管选择哪个都要从自身情况去考虑，自身分析场景来体验和对比，选择最适合自己的。适合自己的才是最好的。<br>这里推荐两篇介绍比较详细的前端埋点博文:<br><a href="http://www.imooc.com/article/27151" target="_blank" rel="noopener">第一篇</a><br><a href="https://blog.csdn.net/ywl570717586/article/details/89852222" target="_blank" rel="noopener">第二篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全面的介绍前端埋点知识&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>微前端</title>
    <link href="/2020/05/25/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <id>/2020/05/25/微前端/</id>
    <published>2020-05-25T07:11:09.000Z</published>
    <updated>2020-05-25T07:53:46.365Z</updated>
    
    <content type="html"><![CDATA[<p>初探微前端<br><a id="more"></a></p><h1 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h1><p>微前端最近火了起来，作为紧跟技术潮流的笔者来说，当然要了解一下。<br>贴出一篇笔者觉得不错的文章，<a href="https://www.lizenghai.com/archives/40308.html#i-17" target="_blank" rel="noopener">Single-Spa + Vue Cli 微前端落地指南</a>。这篇文章写得很不错，笔者就是按照他的思路一步一步的完成了一个微前端的demo。但是，笔者的demo只包含vue，父项目和子项目都是用的vue搭建的，相对来说比较简单些，而且，在实际开发的项目中都是一样的框架也是最好的选择。<br>最后，自己用vue写的一个demo，完成了主框架引入了两个子框架。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E5%BE%AE%E5%89%8D%E7%AB%AF" target="_blank" rel="noopener">demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初探微前端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>hash&amp;history单页面路由框架</title>
    <link href="/2020/05/18/hash-history%E5%8D%95%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6/"/>
    <id>/2020/05/18/hash-history单页面路由框架/</id>
    <published>2020-05-18T03:30:17.000Z</published>
    <updated>2020-05-18T05:20:29.624Z</updated>
    
    <content type="html"><![CDATA[<p>hash和history路由形式的单页面框架<br><a id="more"></a></p><h1 id="hash-amp-history单页面路由框架"><a href="#hash-amp-history单页面路由框架" class="headerlink" title="hash&amp;history单页面路由框架"></a>hash&amp;history单页面路由框架</h1><p>现在vue,react,angular三大框架已经垄断了前端的单页面应用，用起来很方便，今天笔者写两个hash和history路由的小框架，有时候小项目可能也能用到，相比其它框架可能会配置灵活些。在使用vue等框架之前的单页面应用都是这样做的。<br>细节不写了，附上demo代码：<br><a href="https://github.com/jinux7/study-collections/tree/master/hash%26history%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hash和history路由形式的单页面框架&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写vue</title>
    <link href="/2020/04/27/%E6%89%8B%E5%86%99vue/"/>
    <id>/2020/04/27/手写vue/</id>
    <published>2020-04-27T05:54:30.000Z</published>
    <updated>2020-04-27T08:04:30.936Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个基础功能的vue<br><a id="more"></a></p><h1 id="手写vue"><a href="#手写vue" class="headerlink" title="手写vue"></a>手写vue</h1><p>实现一个非常简化版vue，暂时实现了<code>v-text,v-html,v-model,@eventName</code>指令，还有插值表达式<code>｛｛｝｝</code>,<br>一共写了4个类去实现，Vue是主类，Dep依赖收集类，Watcher是观察者类，Dep依赖收集去触发Watcher观察者定义的的方法，Compile类是用来解析html的dom元素的，解析的时候向对应的数据添加依赖，这样数据改变视图跟着改变。<br>下面是代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(option) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = option.el &amp;&amp; <span class="built_in">document</span>.querySelector(option.el);</span><br><span class="line">    <span class="keyword">this</span>.$data = option.data;</span><br><span class="line">    <span class="keyword">this</span>.$methods = option.methods;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observer(<span class="keyword">this</span>.$data);</span><br><span class="line">    <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给data值设置get，set的数据劫持</span></span><br><span class="line">  observer(daObj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> daObj === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> daObj) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = daObj[key];</span><br><span class="line">        <span class="keyword">if</span>(value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.observer(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); </span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(daObj, key, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              Dep.target &amp;&amp; dep.push(Dep.target);</span><br><span class="line">              <span class="keyword">return</span> value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(val) &#123;</span><br><span class="line">              value = val;</span><br><span class="line">              <span class="comment">// 这里注意。依赖触发要在value=val的下边</span></span><br><span class="line">              dep.dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  push(watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers.push(watcher);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers.forEach(<span class="function"><span class="params">watcher</span>=&gt;</span> &#123;</span><br><span class="line">      watcher &amp;&amp; watcher.callback &amp;&amp; watcher.callback(); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(callback) &#123;</span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译模板字符串类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseHtml(el, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  parseHtml(el, vm) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(el.childNodes).forEach(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理带有指令的节点元素</span></span><br><span class="line">      <span class="keyword">this</span>.updateDirect(item, vm);</span><br><span class="line">      <span class="keyword">if</span>(item.nodeType === <span class="number">1</span> &amp;&amp; item.childNodes.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归解析</span></span><br><span class="line">        <span class="keyword">this</span>.parseHtml(item, vm);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.nodeType === <span class="number">3</span> &amp;&amp; <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>.test(item.textContent)) &#123;</span><br><span class="line">        <span class="keyword">let</span> epx = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.updateText(item, vm, epx);</span><br><span class="line">        <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.updateText(item, vm, epx);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是指令节点</span></span><br><span class="line">  updateDirect(node, vm) &#123;</span><br><span class="line">    <span class="comment">// 如果元素节点的属性是一个json对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> node.attributes === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="comment">// 转换成数组</span></span><br><span class="line">      <span class="keyword">let</span> attrs = <span class="built_in">Array</span>.from(node.attributes);</span><br><span class="line">      <span class="keyword">if</span>(attrs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;attrs.length; i++) &#123;</span><br><span class="line">          <span class="comment">// v-xxx指令</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="regexp">/^v\-.+/</span>.test(attrs[i].name)) &#123;</span><br><span class="line">            <span class="keyword">let</span> handleStr = attrs[i].name.substring(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> epx = attrs[i].value;</span><br><span class="line">            <span class="keyword">this</span>[<span class="string">'dir'</span>+handleStr](node, vm, epx);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// @事件</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="regexp">/^\@.+/</span>.test(attrs[i].name))&#123;</span><br><span class="line">            <span class="keyword">let</span> eventName = attrs[i].name.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> callbackName = attrs[i].value;</span><br><span class="line">            <span class="keyword">this</span>[<span class="string">'eventHandler'</span>](node, vm, eventName, callbackName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理指令节点数据响应</span></span><br><span class="line">  dirtext(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateText(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateText(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirhtml(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateHtml(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateHtml(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirmodel(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateValue(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateValue(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 添加input事件</span></span><br><span class="line">    node.addEventListener(<span class="string">'input'</span>, (ev)=&gt; &#123;</span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx + <span class="string">'="'</span> + ev.target.value + <span class="string">'"'</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理指令事件</span></span><br><span class="line">  eventHandler(node, vm, eventName, callbackName) &#123;</span><br><span class="line">    node.addEventListener(eventName, vm.$methods[callbackName]||loop, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改元素节点的textContent</span></span><br><span class="line">  updateText(node, vm, epx) &#123;</span><br><span class="line">    node.textContent = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改元素节点的innerHTML</span></span><br><span class="line">  updateHtml(node, vm, epx) &#123;</span><br><span class="line">    node.innerHTML = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改input元素的value</span></span><br><span class="line">  updateValue(node, vm, epx) &#123;</span><br><span class="line">    node.value = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>代码不多，但是基本功能已经实现。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99vue" target="_blank" rel="noopener">代码点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个基础功能的vue&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>手写vuex</title>
    <link href="/2020/04/21/%E6%89%8B%E5%86%99vuex/"/>
    <id>/2020/04/21/手写vuex/</id>
    <published>2020-04-21T06:52:06.000Z</published>
    <updated>2020-04-21T07:16:43.862Z</updated>
    
    <content type="html"><![CDATA[<p>简单的实现vuex的功能<br><a id="more"></a></p><h1 id="手写vuex"><a href="#手写vuex" class="headerlink" title="手写vuex"></a>手写vuex</h1><p>vuex是vue的一个状态管理插件，现在使用的场景非常多，今天，自己简单的实现一下vuex的几个小功能，如<code>state,getter,commit,mutations,dispatch,actions</code>,暂时先实现这么多，有精力的话再补充<code>module,map等</code>。</p><h2 id="vuex在vue中的使用"><a href="#vuex在vue中的使用" class="headerlink" title="vuex在vue中的使用"></a>vuex在vue中的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// store.js文件，也就是配置store的文件</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  getter: &#123;</span><br><span class="line">    getterCount(state) &#123;</span><br><span class="line">      return state.count + 5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num) &#123;</span><br><span class="line">      state.count += num; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addAction(state, num) &#123;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        state.commit(&apos;add&apos;, num);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// vue的main.js文件中引入store</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br><span class="line"></span><br><span class="line">// vue具体页面使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h2&gt;state-&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;getter-&gt;&#123;&#123;$store.getter.getterCount&#125;&#125;&lt;/h2&gt;  </span><br><span class="line">    &lt;h2&gt;computed-&gt;&#123;&#123;mill&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;onAdd&quot;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;onAddDispatch&quot;&gt;addDispatch&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    mill() &#123;</span><br><span class="line">      return this.$store.state.count + 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onAdd() &#123;</span><br><span class="line">      this.$store.commit(&apos;add&apos;, 15);</span><br><span class="line">    &#125;,</span><br><span class="line">    onAddDispatch() &#123;</span><br><span class="line">      this.$store.dispatch(&apos;addAction&apos;, 10);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vuex的实现代码"><a href="#vuex的实现代码" class="headerlink" title="vuex的实现代码"></a>vuex的实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">let Vue;</span><br><span class="line">class Store &#123;</span><br><span class="line">  constructor(options = &#123;&#125;) &#123;</span><br><span class="line">    this.options = options;</span><br><span class="line">    this.vueState = new Vue(&#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          state: options.state</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 处理getter操作</span><br><span class="line">    this.getter = &#123;&#125;;</span><br><span class="line">    Object.keys(this.options.getter).forEach(item=&gt; &#123;</span><br><span class="line">      Object.defineProperty(this.getter, item, &#123;</span><br><span class="line">        get: ()=&gt; &#123;</span><br><span class="line">          return this.options.getter[item](this.options.state);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // commit方法和mutations</span><br><span class="line">  commit(type, val) &#123;</span><br><span class="line">    Object.keys(this.options.mutations).forEach(item=&gt; &#123;</span><br><span class="line">      if(item === type) &#123;</span><br><span class="line">        this.options.mutations[item](this.options.state, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // dispatch方法和actions</span><br><span class="line">  dispatch(type, val) &#123;</span><br><span class="line">    Object.keys(this.options.actions).forEach(item=&gt; &#123;</span><br><span class="line">      if(item === type) &#123;</span><br><span class="line">        this.options.actions[item](this, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取Store的state，来源于this.vueState，是Vue的一个实例，可以实现了store.state的数据绑定更新页面</span><br><span class="line">  get state () &#123;</span><br><span class="line">      return this.vueState.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 供Vue.use()调用 </span><br><span class="line">function install(_Vue) &#123;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">      beforeCreate: function () &#123;</span><br><span class="line">          const options = this.$options;</span><br><span class="line">          if (options.store) &#123;</span><br><span class="line">              this.$store = options.store;</span><br><span class="line">          &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">              this.$store = options.parent.$store;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的实现vuex的功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly入门</title>
    <link href="/2020/04/15/WebAssembly%E5%85%A5%E9%97%A8/"/>
    <id>/2020/04/15/WebAssembly入门/</id>
    <published>2020-04-15T03:15:30.000Z</published>
    <updated>2020-04-27T07:53:06.088Z</updated>
    
    <content type="html"><![CDATA[<p>WebAssembly简单实例<br><a id="more"></a></p><h1 id="WebAssembly入门"><a href="#WebAssembly入门" class="headerlink" title="WebAssembly入门"></a>WebAssembly入门</h1><p>WebAssembly是一门新技术，可以将c,c++,java等文件编译成.wasm文件，再被js引入到html中使用。<br>今天我介绍一种简单的方式生成.wasm文件，不需要使用繁琐的系统工具来完成。<br><a href="https://webassembly.studio/" target="_blank" rel="noopener">在线webassembly</a>,这个网站可以在线写c语言代码，在线打包成.wasm文件，还可以看例子，学习具体的使用。<br>贴一个小例子，也是按照这个在线编辑器copy下来的，<a href="https://github.com/jinux7/study-collections/tree/master/webAssembly" target="_blank" rel="noopener">demo点这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebAssembly简单实例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>点击或触摸事件中的相关X,Y介绍</title>
    <link href="/2020/04/13/%E7%82%B9%E5%87%BB%E6%88%96%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3X-Y%E4%BB%8B%E7%BB%8D/"/>
    <id>/2020/04/13/点击或触摸事件中的相关X-Y介绍/</id>
    <published>2020-04-13T01:30:07.000Z</published>
    <updated>2020-04-13T01:54:39.236Z</updated>
    
    <content type="html"><![CDATA[<p>点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍<br><a id="more"></a></p><h1 id="点击或触摸事件中的相关X-Y介绍"><a href="#点击或触摸事件中的相关X-Y介绍" class="headerlink" title="点击或触摸事件中的相关X,Y介绍"></a>点击或触摸事件中的相关X,Y介绍</h1><h2 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h2><p>我们在使用点击事件时，想获取当前鼠标在页面中的位置，可以把事件对象打印出来，看到了下图中的一些相关于x，y的属性。<br><img src="/2020/04/13/点击或触摸事件中的相关X-Y介绍/1.png" alt="img"></p><h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><h3 id="clientX、clientY"><a href="#clientX、clientY" class="headerlink" title="clientX、clientY"></a>clientX、clientY</h3><p>点击位置距离当前body可视区域的x，y坐标</p><h3 id="pageX、pageY"><a href="#pageX、pageY" class="headerlink" title="pageX、pageY"></a>pageX、pageY</h3><p>对于整个页面来说，包括了被卷去的body部分的长度</p><h3 id="screenX、screenY"><a href="#screenX、screenY" class="headerlink" title="screenX、screenY"></a>screenX、screenY</h3><p>点击位置距离当前电脑屏幕的x，y坐标</p><h3 id="offsetX、offsetY"><a href="#offsetX、offsetY" class="headerlink" title="offsetX、offsetY"></a>offsetX、offsetY</h3><p>相对于带有定位的父盒子的x，y坐标</p><h3 id="x、y"><a href="#x、y" class="headerlink" title="x、y"></a>x、y</h3><p>和screenX、screenY一样</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2020/04/13/点击或触摸事件中的相关X-Y介绍/2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>web全景图之pannellum</title>
    <link href="/2020/04/09/web%E5%85%A8%E6%99%AF%E5%9B%BE%E4%B9%8Bpannellum/"/>
    <id>/2020/04/09/web全景图之pannellum/</id>
    <published>2020-04-09T06:32:37.000Z</published>
    <updated>2020-04-09T07:12:53.174Z</updated>
    
    <content type="html"><![CDATA[<p>开发web全景图的工具库pannellum<br><a id="more"></a></p><h1 id="web全景图之pannellum"><a href="#web全景图之pannellum" class="headerlink" title="web全景图之pannellum"></a>web全景图之pannellum</h1><p>最近需要开发一个室内全景图的项目，类似于贝壳的VR看房，直接用three.js开发成本太高，于是在网上找到了pannellum这个工具库，不依赖其它的库，而且还小，使用简单。</p><h2 id="pannellum官网地址"><a href="#pannellum官网地址" class="headerlink" title="pannellum官网地址"></a>pannellum官网地址</h2><p><a href="https://pannellum.org/" target="_blank" rel="noopener">pannellum官网地址</a></p><h2 id="自己做了一个小demo"><a href="#自己做了一个小demo" class="headerlink" title="自己做了一个小demo"></a>自己做了一个小demo</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/pannellum-web%E5%85%A8%E6%99%AF" target="_blank" rel="noopener">demo地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发web全景图的工具库pannellum&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="3D" scheme="/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>AlloyFinger手势库分析</title>
    <link href="/2020/03/26/AlloyFinger%E6%89%8B%E5%8A%BF%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>/2020/03/26/AlloyFinger手势库分析/</id>
    <published>2020-03-26T09:13:31.000Z</published>
    <updated>2020-03-27T01:24:40.048Z</updated>
    
    <content type="html"><![CDATA[<p>移动端手势库AlloyFinger分析<br><a id="more"></a></p><h1 id="AlloyFinger手势库分析"><a href="#AlloyFinger手势库分析" class="headerlink" title="AlloyFinger手势库分析"></a>AlloyFinger手势库分析</h1><p>AlloyFinger这个移动端手势库是腾讯的AlloyTeam团队开发的，体积小，功能强大，简单易用，具体的使用方法见<a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="noopener">AlloyFinger github</a><br>这两天闲暇的时候好好的读了几遍这个库的代码，写好了注释，理解了作者的思路，受益匪浅。<br>注释代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 移动端手势库</span><br><span class="line"> * @desc 分析</span><br><span class="line"> */</span><br><span class="line">;</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  // 获取两点间距离工具函数</span><br><span class="line">  function getLen(v) &#123;</span><br><span class="line">      return Math.sqrt(v.x * v.x + v.y * v.y);</span><br><span class="line">  &#125;</span><br><span class="line">  // dot和getAngle函数用来算两次手势状态之间的夹角, cross函数用来算方向的, getRotateAngle函数算手势真正的角度的</span><br><span class="line">  function dot(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.x + v1.y * v2.y;</span><br><span class="line">  &#125;</span><br><span class="line"> // 求两次手势状态之间的夹角</span><br><span class="line">  function getAngle(v1, v2) &#123;</span><br><span class="line">      var mr = getLen(v1) * getLen(v2);</span><br><span class="line">      if (mr === 0) return 0;</span><br><span class="line">      var r = dot(v1, v2) / mr;</span><br><span class="line">      if (r &gt; 1) r = 1;</span><br><span class="line">      return Math.acos(r);</span><br><span class="line">  &#125;</span><br><span class="line">  // 利用cross结果的正负来判断旋转的方向(大于0为逆时针, 小于0为顺时针)</span><br><span class="line">  function cross(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.y - v2.x * v1.y;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果cross大于0那就是逆时针对于屏幕是正角,对于第一象限是负角,所以 角度 * -1, 然后角度单位换算</span><br><span class="line">  function getRotateAngle(v1, v2) &#123;</span><br><span class="line">      var angle = getAngle(v1, v2);</span><br><span class="line">      if (cross(v1, v2) &gt; 0) &#123;</span><br><span class="line">          angle *= -1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return angle * 180 / Math.PI;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var HandlerAdmin = function(el) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">      this.el = el;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 函数管理构造函数</span><br><span class="line">  function HandlerAdmin(el) &#123;</span><br><span class="line">    this.handlers = [];</span><br><span class="line">    this.el = el;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.add = function(handler) &#123;</span><br><span class="line">    this.handlers.push(handler);</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.del = function(handler) &#123;</span><br><span class="line">    // 如果什么也不传，清空函数数组</span><br><span class="line">    if(!handler) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 比对数组中的函数，并且删除它</span><br><span class="line">    for(var i=this.handlers.length; i&gt;=0; i--) &#123;</span><br><span class="line">      if(this.handlers[i] === handler) &#123;</span><br><span class="line">          this.handlers.splice(i, 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 运行需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.dispatch = function() &#123;</span><br><span class="line">    for(var i=0,len=this.handlers.length; i&lt;len; i++) &#123;</span><br><span class="line">        var handler = this.handlers[i];</span><br><span class="line">        // 运行这些函数的时候，是作为元素的事件触发的，所以，这些函数的this要指向这个元素</span><br><span class="line">        if(typeof handler === &apos;function&apos;) handler.apply(this.el, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化函数管理对象</span><br><span class="line">  function wrapFunc(el, handler) &#123;</span><br><span class="line">    var handlerAdmin = new HandlerAdmin(el);</span><br><span class="line">    handlerAdmin.add(handler);</span><br><span class="line">    return handlerAdmin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 手势库构造函数</span><br><span class="line">  function AlloyFinger(el, option) &#123;</span><br><span class="line">    // 获取添加事件的元素</span><br><span class="line">    this.element = typeof el === &apos;string&apos; ? document.querySelector(el) : el;</span><br><span class="line">    // 因为添加事件后这些方法的执行上下文是this.element，所以给方法bind JinuxFinger这个执行上下文</span><br><span class="line">    this.start = this.start.bind(this);</span><br><span class="line">    this.move = this.move.bind(this);</span><br><span class="line">    this.end = this.end.bind(this);</span><br><span class="line">    this.cancel = this.cancel.bind(this);</span><br><span class="line">    // 给这个元素添加事件</span><br><span class="line">    this.element.addEventListener(&quot;touchstart&quot;, this.start, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchmove&quot;, this.move, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchend&quot;, this.end, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchcancel&quot;, this.cancel, false);</span><br><span class="line">    // 定义一些实例属性</span><br><span class="line">    this.preV = &#123; x: null, y: null &#125;; // 两个手指间的x距离和y距离</span><br><span class="line">    this.pinchStartLen = null; // 捏拽的长度</span><br><span class="line">    this.zoom = 1; // 缩放比例</span><br><span class="line">    this.isDoubleTap = false; // 是否是双击</span><br><span class="line">    var noop = function() &#123;&#125; // 空函数</span><br><span class="line">    // 实例化JinuxFinger时，设置的手势回调函数</span><br><span class="line">    this.rotate = wrapFunc(this.element, option.rotate || noop); // 旋转</span><br><span class="line">    this.touchStart = wrapFunc(this.element, option.touchStart || noop); // 触摸开始  </span><br><span class="line">    this.multipointStart = wrapFunc(this.element, option.multipointStart || noop); // 多个手指触摸开始 </span><br><span class="line">    this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop); // 多个手指触摸结束，如4个手指触摸，屏幕上剩下1个或不剩都会触发</span><br><span class="line">    this.pinch = wrapFunc(this.element, option.pinch || noop); // 两个手指捏拽</span><br><span class="line">    this.swipe = wrapFunc(this.element, option.swipe || noop); // 上下左右滑动，手指离开时触发</span><br><span class="line">    this.tap = wrapFunc(this.element, option.tap || noop); // 无论是单击还是双击都会触发</span><br><span class="line">    this.doubleTap = wrapFunc(this.element, option.doubleTap || noop); // 双击触发</span><br><span class="line">    this.longTap = wrapFunc(this.element, option.longTap || noop); // 单手指长按触发，750ms</span><br><span class="line">    this.singleTap = wrapFunc(this.element, option.singleTap || noop); // 单击触发，250ms</span><br><span class="line">    this.pressMove = wrapFunc(this.element, option.pressMove || noop); // 1个手指屏幕上移动触发</span><br><span class="line">    this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop); // 2个以上手指屏幕上移动触发</span><br><span class="line">    this.touchMove = wrapFunc(this.element, option.touchMove || noop); // 无论几个手指在屏幕上移动都会触发</span><br><span class="line">    this.touchEnd = wrapFunc(this.element, option.touchEnd || noop); // 触摸结束都会触发</span><br><span class="line">    this.touchCancel = wrapFunc(this.element, option.touchCancel || noop); // 事件简单的说是在移动端发生了触摸中断，一般情况下就是优先级比当前活动更高的事件时，才会触发的。比如正在看新闻，手指滑动屏幕的时候，突然来电话，直接中断了触摸事件，跳转到了通话，页面此时就触发了touchcancel事件。这个事件不容易在浏览器的模拟器中模拟，之前我在用电脑的任务栏切换的时候，受到启发，可以试试在浏览器模拟器触摸的同时，按下键盘上的Alt+Tab键，果然触发了touchcancel事件，有兴趣的小伙伴可以试一下。</span><br><span class="line">    </span><br><span class="line">    this._cancelAllHandler = this.cancelAll.bind(this);</span><br><span class="line">    // 触发window的scroll事件时，清除现有touch事件的回调函数执行</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line"></span><br><span class="line">    this.delta = null; // 双击的间隔时间</span><br><span class="line">    this.last = null; // 相对于下一次点击，前一次点击的时间</span><br><span class="line">    this.now = null; // 当前点击保存用的时间，也可以理解为相对于上一次点击，这个是当前点击的时间</span><br><span class="line">    this.tapTimeout = null;</span><br><span class="line">    this.singleTapTimeout = null;</span><br><span class="line">    this.longTapTimeout = null;</span><br><span class="line">    this.swipeTimeout = null;</span><br><span class="line">    this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">    this.preTapPosition = &#123; x: null, y: null &#125;; // 相对于下次点击，前一次点击手指x,y坐标的保存对象</span><br><span class="line">  &#125;</span><br><span class="line">  AlloyFinger.prototype = &#123;</span><br><span class="line">    start: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 屏幕上没有手指则返回</span><br><span class="line">      this.now = Date.now(); // 设置touch开始时的时间</span><br><span class="line">      this.x1 = evt.touches[0].pageX; // 第一个手指触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动</span><br><span class="line">      this.y1 = evt.touches[0].pageY; // 第一个手指触点相对于HTML文档左边沿的的Y坐标</span><br><span class="line">      this.delta = this.now - (this.last || this.now); // 双击的间隔时间</span><br><span class="line">      this.touchStart.dispatch(evt, this.element); // 触发了touchStart回调函数</span><br><span class="line">      if (this.preTapPosition.x !== null) &#123; // 如果不为null，说明之前已经有点击了</span><br><span class="line">          // 判断是否满足手指双击条件</span><br><span class="line">          this.isDoubleTap = (this.delta &gt; 0 &amp;&amp; this.delta &lt;= 250 &amp;&amp; Math.abs(this.preTapPosition.x - this.x1) &lt; 30 &amp;&amp; Math.abs(this.preTapPosition.y - this.y1) &lt; 30);</span><br><span class="line">          if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">      this.preTapPosition.x = this.x1; // 保存当前手指x坐标</span><br><span class="line">      this.preTapPosition.y = this.y1;// 保存当前手指y坐标</span><br><span class="line">      this.last = this.now; // 保存当前时间</span><br><span class="line">      var preV = this.preV, </span><br><span class="line">          len = evt.touches.length; // 现在屏幕上有多少个手指</span><br><span class="line">      if (len &gt; 1) &#123; // 两个手指以上触摸情况</span><br><span class="line">          this._cancelLongTap(); // 清除长按回调函数的执行</span><br><span class="line">          this._cancelSingleTap(); // 清除点击函数的执行</span><br><span class="line">          // 计算两个手指x,y的距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 &#125;;</span><br><span class="line">          // 赋值给preV</span><br><span class="line">          preV.x = v.x; </span><br><span class="line">          preV.y = v.y;</span><br><span class="line">          this.pinchStartLen = getLen(preV); // 计算出两个手指间的距离</span><br><span class="line">          this.multipointStart.dispatch(evt, this.element); // 触发多点触碰函数回调</span><br><span class="line">      &#125;</span><br><span class="line">      this._preventTap = false; // 长按是否回调执行，否 </span><br><span class="line">      this.longTapTimeout = setTimeout(function () &#123; // 长按触发回调函数的定时器</span><br><span class="line">          this.longTap.dispatch(evt, this.element); // 触发长按回调函数</span><br><span class="line">          this._preventTap = true; // 长按是否回调执行，是</span><br><span class="line">      &#125;.bind(this), 750); // 长按是手指按下750ms后触发</span><br><span class="line">  &#125;,</span><br><span class="line">  move: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 没有touches属性则返回</span><br><span class="line">      var preV = this.preV, // 两个手指间距离暂存preV里</span><br><span class="line">          len = evt.touches.length, // 屏幕上的手指数</span><br><span class="line">          currentX = evt.touches[0].pageX, // 屏幕上第一个手指的pageX暂存</span><br><span class="line">          currentY = evt.touches[0].pageY; // 屏幕上第一个手指的pageY暂存</span><br><span class="line">      this.isDoubleTap = false; // 手指移动了，就不是双击了</span><br><span class="line">      if (len &gt; 1) &#123; // 手指大于2个情况</span><br><span class="line">          var sCurrentX = evt.touches[1].pageX, // 屏幕上第2个手指的pageX暂存</span><br><span class="line">              sCurrentY = evt.touches[1].pageY; // 屏幕上第2个手指的pageY暂存</span><br><span class="line">          // 两个手指间距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY &#125;;</span><br><span class="line"></span><br><span class="line">          if (preV.x !== null) &#123;</span><br><span class="line">              if (this.pinchStartLen &gt; 0) &#123; // move之前两指间的距离如果大于0情况</span><br><span class="line">                  evt.zoom = getLen(v) / this.pinchStartLen; // move后的距离/move前的，就是捏拽的比例</span><br><span class="line">                  this.pinch.dispatch(evt, this.element); // 触发捏拽回调，并将zoom属性传递到事件对象里</span><br><span class="line">              &#125;</span><br><span class="line">              // 获取手指移动的角度</span><br><span class="line">              evt.angle = getRotateAngle(v, preV);</span><br><span class="line">              this.rotate.dispatch(evt, this.element); // 触发旋转回调函数</span><br><span class="line">          &#125;</span><br><span class="line">          preV.x = v.x; // move时将现在两指间的距离x赋值给preV</span><br><span class="line">          preV.y = v.y; // move时将现在两指间的距离y赋值给preV</span><br><span class="line"></span><br><span class="line">          if (this.x2 !== null &amp;&amp; this.sx2 !== null) &#123; // 因为是两个手指，所以取的是两个手指中间的值，两次move之间的偏移量,参考下变一个手指情况</span><br><span class="line">              evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;</span><br><span class="line">              evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;</span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          this.twoFingerPressMove.dispatch(evt, this.element); // 两个以上手指移动的事件回调</span><br><span class="line"></span><br><span class="line">          this.sx2 = sCurrentX; // 第二个手指坐标x暂存</span><br><span class="line">          this.sy2 = sCurrentY; // 第二个手指坐标y暂存</span><br><span class="line">      &#125; else &#123; // 单指move情况下</span><br><span class="line">          if (this.x2 !== null) &#123; // 第一次移动this.x2=null的,第二次之后才为true</span><br><span class="line">              evt.deltaX = currentX - this.x2; // x方向两次move事件的差值</span><br><span class="line">              evt.deltaY = currentY - this.y2; // y方向两次move事件的差值</span><br><span class="line"></span><br><span class="line">              //move事件中添加对当前触摸点到初始触摸点的判断，</span><br><span class="line">              //如果曾经大于过某个距离(比如10),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。</span><br><span class="line">              var movedX = Math.abs(this.x1 - this.x2),</span><br><span class="line">                  movedY = Math.abs(this.y1 - this.y2);</span><br><span class="line"></span><br><span class="line">              if(movedX &gt; 10 || movedY &gt; 10)&#123;</span><br><span class="line">                  this._preventTap = true;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          this.pressMove.dispatch(evt, this.element); // 一个手指移动的触发回调</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchMove.dispatch(evt, this.element); // 有移动就触发touchMove事件回调</span><br><span class="line"></span><br><span class="line">      this._cancelLongTap(); // 有移动事件了，清除长按的事件回调</span><br><span class="line">      this.x2 = currentX; // 将当前第一个手指的坐标x复制给this.x2</span><br><span class="line">      this.y2 = currentY; // 将当前第一个手指的坐标y复制给this.y2</span><br><span class="line">      </span><br><span class="line">      if (len &gt; 1) &#123; // 两个以上手指，阻止浏览器默认事件</span><br><span class="line">          evt.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  end: function (evt) &#123;</span><br><span class="line">      if (!evt.changedTouches) return; // end事件触发时，changedTouches为空，则返回</span><br><span class="line">      this._cancelLongTap(); // 取消长按的回调函数</span><br><span class="line">      var self = this; // this暂存在bianliangself</span><br><span class="line">      if (evt.touches.length &lt; 2) &#123; // 目前屏幕上留下的手指0或者1个</span><br><span class="line">          this.multipointEnd.dispatch(evt, this.element); // 调用多指触摸的结束回调</span><br><span class="line">          this.sx2 = this.sy2 = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //swipe</span><br><span class="line">      // this.x2或this.y2有值说明有在屏幕上移动，并且计算移动后离开屏幕时的坐标与this.x1手指刚触摸屏幕时的坐标差值大于30，可以出发swipe事件回调</span><br><span class="line">      if ((this.x2 &amp;&amp; Math.abs(this.x1 - this.x2) &gt; 30) ||</span><br><span class="line">          (this.y2 &amp;&amp; Math.abs(this.y1 - this.y2) &gt; 30)) &#123;</span><br><span class="line">          // 获取滑动的方向  </span><br><span class="line">          evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);</span><br><span class="line">          this.swipeTimeout = setTimeout(function () &#123; // 触发swipe回调函数，加入宏任务队列</span><br><span class="line">              self.swipe.dispatch(evt, self.element);</span><br><span class="line"></span><br><span class="line">          &#125;, 0)</span><br><span class="line">      &#125; else &#123; // 这里说明不是swipe事件，只是点击事件</span><br><span class="line">          this.tapTimeout = setTimeout(function () &#123; // 点击定时器</span><br><span class="line">              if(!self._preventTap)&#123; // 长按事件函数没有执行</span><br><span class="line">                  self.tap.dispatch(evt, self.element); // 执行tap回调</span><br><span class="line">              &#125;</span><br><span class="line">              // trigger double tap immediately</span><br><span class="line">              if (self.isDoubleTap) &#123; // 如果是双击的话</span><br><span class="line">                  self.doubleTap.dispatch(evt, self.element); // 执行双击事件回调</span><br><span class="line">                  self.isDoubleTap = false; // 执行之后设置双击标识为假</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line"></span><br><span class="line">          if (!self.isDoubleTap) &#123; // 如果不是双击操作</span><br><span class="line">              self.singleTapTimeout = setTimeout(function () &#123; // 250ms后执行singleTap事件回调</span><br><span class="line">                  self.singleTap.dispatch(evt, self.element);</span><br><span class="line">              &#125;, 250);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchEnd.dispatch(evt, this.element); // 手指离开都会触发touchEnd事件回调</span><br><span class="line">      // 手指离开后将一些属性重置</span><br><span class="line">      this.preV.x = 0;</span><br><span class="line">      this.preV.y = 0;</span><br><span class="line">      this.zoom = 1;</span><br><span class="line">      this.pinchStartLen = null;</span><br><span class="line">      this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelAll: function () &#123;</span><br><span class="line">      this._preventTap = true; // 阻止tap事件</span><br><span class="line">      clearTimeout(this.singleTapTimeout); // 清除singleTapTimeout定时器</span><br><span class="line">      clearTimeout(this.tapTimeout); // 清除tapTimeout定时器</span><br><span class="line">      clearTimeout(this.longTapTimeout); // 清除longTapTimeout定时器</span><br><span class="line">      clearTimeout(this.swipeTimeout); // 清除swipeTimeout定时器</span><br><span class="line">  &#125;,</span><br><span class="line">  cancel: function (evt) &#123; // cancel事件</span><br><span class="line">      this.cancelAll()</span><br><span class="line">      this.touchCancel.dispatch(evt, this.element); // 触发touchCancel回调</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelLongTap: function () &#123; // 清除longTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.longTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelSingleTap: function () &#123; // 清除singleTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.singleTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 计算swipe的方向函数</span><br><span class="line">  _swipeDirection: function (x1, x2, y1, y2) &#123;</span><br><span class="line">      return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? &apos;Left&apos; : &apos;Right&apos;) : (y1 - y2 &gt; 0 ? &apos;Up&apos; : &apos;Down&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件添加回调函数</span><br><span class="line">  on: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].add(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件删除回调函数</span><br><span class="line">  off: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].del(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 实例销毁函数</span><br><span class="line">  destroy: function() &#123;</span><br><span class="line">      if(this.singleTapTimeout) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      if(this.tapTimeout) clearTimeout(this.tapTimeout);</span><br><span class="line">      if(this.longTapTimeout) clearTimeout(this.longTapTimeout);</span><br><span class="line">      if(this.swipeTimeout) clearTimeout(this.swipeTimeout);</span><br><span class="line"></span><br><span class="line">      this.element.removeEventListener(&quot;touchstart&quot;, this.start);</span><br><span class="line">      this.element.removeEventListener(&quot;touchmove&quot;, this.move);</span><br><span class="line">      this.element.removeEventListener(&quot;touchend&quot;, this.end);</span><br><span class="line">      this.element.removeEventListener(&quot;touchcancel&quot;, this.cancel);</span><br><span class="line"></span><br><span class="line">      this.rotate.del();</span><br><span class="line">      this.touchStart.del();</span><br><span class="line">      this.multipointStart.del();</span><br><span class="line">      this.multipointEnd.del();</span><br><span class="line">      this.pinch.del();</span><br><span class="line">      this.swipe.del();</span><br><span class="line">      this.tap.del();</span><br><span class="line">      this.doubleTap.del();</span><br><span class="line">      this.longTap.del();</span><br><span class="line">      this.singleTap.del();</span><br><span class="line">      this.pressMove.del();</span><br><span class="line">      this.twoFingerPressMove.del()</span><br><span class="line">      this.touchMove.del();</span><br><span class="line">      this.touchEnd.del();</span><br><span class="line">      this.touchCancel.del();</span><br><span class="line"></span><br><span class="line">      this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;</span><br><span class="line"></span><br><span class="line">      window.removeEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 暴露给外部使用</span><br><span class="line">  if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">    module.exports = AlloyFinger;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      window.AlloyFinger = AlloyFinger;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端手势库AlloyFinger分析&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写call,apply,bind函数</title>
    <link href="/2020/03/25/%E6%89%8B%E5%86%99call-apply-bind%E5%87%BD%E6%95%B0/"/>
    <id>/2020/03/25/手写call-apply-bind函数/</id>
    <published>2020-03-25T06:17:43.000Z</published>
    <updated>2020-03-25T07:01:19.519Z</updated>
    
    <content type="html"><![CDATA[<p>手写call,apply,bind函数<br><a id="more"></a></p><h1 id="手写call-apply-bind函数"><a href="#手写call-apply-bind函数" class="headerlink" title="手写call,apply,bind函数"></a>手写call,apply,bind函数</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = arguments[1];</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myApply(testObj, [1, 2, 3]);</span><br></pre></td></tr></table></figure></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  let _this = this</span><br><span class="line">  let args = [...arguments].slice(1)</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 判断是否被当做构造函数使用</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return _this.apply(this, args.concat([...arguments]))</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat([...arguments]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myBind(testObj, 1)(2, 3);</span><br></pre></td></tr></table></figure></p><p>以上就是我们常用的call，apply，bind函数的手写实现，但是，用到了es6的[…arg]结构语法，下面只写一个call实现的es5版本。</p><h2 id="call-es5版"><a href="#call-es5版" class="headerlink" title="call es5版"></a>call es5版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var fnStr = `context.fn(`;</span><br><span class="line">    for(var i=0, len=arg.length; i&lt;len; i++) &#123;</span><br><span class="line">        if(i === (len-1)) &#123;</span><br><span class="line">            fnStr += arg[i];    </span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fnStr += arg[i] + &apos;,&apos;;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += &apos;)&apos;;</span><br><span class="line">    console.log(fnStr);</span><br><span class="line">    var result = eval(fnStr);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写call,apply,bind函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="/2020/03/20/%E6%89%8B%E5%86%99Promise/"/>
    <id>/2020/03/20/手写Promise/</id>
    <published>2020-03-20T05:30:12.000Z</published>
    <updated>2020-03-20T07:20:42.907Z</updated>
    
    <content type="html"><![CDATA[<p>模拟一个Promise功能<br><a id="more"></a></p><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>现在的异步基本上都是用Promise来实现的，用起来很方便，但是，Promise是怎么实现的呢，它的then回调是怎么工作的，带着这些疑问，决定自己实现一个Promise。<br>早在2年前，其实我就实现过一个Promise，不过那个原理比较笨，还用到了定时器循环，后来陆续看了些其他人的写法，还是有点没绕明白，这两天又看了向军老师的实现方式，觉得很好，自己也实现一下。<br>主要的难以理解的地方是then函数的写法，这个地方明白了整个Promise也就理解了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  // 等待状态</span><br><span class="line">  static PENDING = &quot;pending&quot;;</span><br><span class="line">  // 成功状态</span><br><span class="line">  static FULFILLED = &quot;fulfilled&quot;;</span><br><span class="line">  // 拒绝状态</span><br><span class="line">  static REJECTED = &quot;rejected&quot;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态是等待</span><br><span class="line">    this.status = MyPromise.PENDING;</span><br><span class="line">    // 成功值</span><br><span class="line">    this.value = null;</span><br><span class="line">    // 拒绝值</span><br><span class="line">    this.reason = null;</span><br><span class="line">    // then的回调数组</span><br><span class="line">    this.callbacks = [];</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 成功调用函数</span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.status = MyPromise.FULFILLED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onFulfilled(this.value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 拒绝调用函数</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      this.status = MyPromise.REJECTED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onRejected(this.reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then函数</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    if (typeof onFulfilled != &quot;function&quot;) &#123;</span><br><span class="line">      onFulfilled = () =&gt; this.value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof onRejected != &quot;function&quot;) &#123;</span><br><span class="line">      onRejected = () =&gt; this.reason;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链式调用，返回一个MyPromise</span><br><span class="line">    const p = new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">        this.callbacks.push(&#123;</span><br><span class="line">          onFulfilled: (value)=&gt; &#123;</span><br><span class="line">            let result = onFulfilled(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected: (value)=&gt; &#123;</span><br><span class="line">            let result = onRejected(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.FULFILLED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onFulfilled(this.value);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.REJECTED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onRejected(this.reason);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(value instanceof MyPromise) &#123;</span><br><span class="line">        value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.all方法</span><br><span class="line">  static all(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      let values = [];</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            values.push(value);</span><br><span class="line">            if(values.length === promises.length) &#123;</span><br><span class="line">              resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.race方法</span><br><span class="line">  static race(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>demo代码<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99promise" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟一个Promise功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>nodejs环境变量NODE_ENV</title>
    <link href="/2020/03/17/nodejs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE-ENV/"/>
    <id>/2020/03/17/nodejs环境变量NODE-ENV/</id>
    <published>2020-03-17T07:20:52.000Z</published>
    <updated>2020-03-17T08:14:52.457Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs环境变量NODE_ENV的设置和获取<br><a id="more"></a></p><h1 id="nodejs环境变量NODE-ENV"><a href="#nodejs环境变量NODE-ENV" class="headerlink" title="nodejs环境变量NODE_ENV"></a>nodejs环境变量NODE_ENV</h1><p>我们在使用webpack打包的时候，会根据环境变量的不同做各种操作，那么，环境变量是如何设置和获取的呢？<br>首先说一下，在命令行中设置的环境变量是临时的，当命令行关闭后就没有了，要想持久化的设置环境变量，只能到我的电脑，属性，高级，环境变量里设置。</p><p>首先，创建一个app.js的文件，内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.NODE_ENV);</span><br></pre></td></tr></table></figure></p><p>我们把环境变量打印出来看看。<br>在命令行下(window系统的cmd可以，powershell和git bash不行)，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set NODE_ENV=pro &amp;&amp; node app.js</span><br></pre></td></tr></table></figure></p><p>打印出<code>pro</code><br>如果想在powershell和git bash都可以使用，那就得利用npm，在package.json中的scripts里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;pro&quot;: &quot;set NODE_ENV=pro &amp;&amp; node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>利用npm可以获取NODE_ENV的值。<br>这种方法的不足是，<code>set NODE_ENV=pro</code>是window的方式，而linux和ios是<code>export NODE_ENV=&#39;pro&#39;</code>,为了一套命令的兼容性，<br>我们可以使用<code>cross-env</code>这个nodejs模块，使用方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>好了，我们已经可以获取NODE_ENV环境变量了。<br>再介绍一个可以获取命令行参数的方便方法，<code>process.env.npm_config_argv</code><br>看名字就知道，只能在npm命令下使用，我们来看看具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.npm_config_argv);</span><br></pre></td></tr></table></figure></p><p>当我们执行<code>npm run dev</code><br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;remain&quot;:[],&quot;cooked&quot;:[&quot;run&quot;,&quot;dev&quot;],&quot;original&quot;:[&quot;run&quot;,&quot;dev&quot;]&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以分析是dev还是pro来处理不同操作。<br>其实，我们想做的莫非就是利用命令行中不同的参数做不同的操作而已，nodejs有一个<code>process.argv</code>属性，可以获取命令行下的参数，来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.argv);</span><br></pre></td></tr></table></figure></p><p>我们在命令行下执行：<code>node app.js dev pro</code>。<br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;C:\\Program Files\\nodejs\\node.exe&apos;,</span><br><span class="line">  &apos;C:\\Jinux\\test\\nodejs-env\\app.js&apos;,</span><br><span class="line">  &apos;dev&apos;,</span><br><span class="line">  &apos;pro&apos; ]</span><br></pre></td></tr></table></figure></p><p>我们还是可以根据命令行下的参数做不同的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs环境变量NODE_ENV的设置和获取&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iPhoneX适配</title>
    <link href="/2020/03/13/iPhoneX%E9%80%82%E9%85%8D/"/>
    <id>/2020/03/13/iPhoneX适配/</id>
    <published>2020-03-13T06:24:28.000Z</published>
    <updated>2020-03-13T06:44:07.611Z</updated>
    
    <content type="html"><![CDATA[<p>h5在iPhoneX中的页面兼容处理<br><a id="more"></a></p><h1 id="iPhoneX适配"><a href="#iPhoneX适配" class="headerlink" title="iPhoneX适配"></a>iPhoneX适配</h1><h2 id="基础设备信息"><a href="#基础设备信息" class="headerlink" title="基础设备信息"></a>基础设备信息</h2><p>首先在了解iPhoneX适配之前，需要了解关于iPhone设备的一些基础</p><h3 id="关于iPhone的一些基础参数"><a href="#关于iPhone的一些基础参数" class="headerlink" title="关于iPhone的一些基础参数"></a>关于iPhone的一些基础参数</h3><p><img src="/2020/03/13/iPhoneX适配/1.webp" alt="img"></p><h3 id="iPhoneX设备信息"><a href="#iPhoneX设备信息" class="headerlink" title="iPhoneX设备信息"></a>iPhoneX设备信息</h3><p>iPhoneX屏幕组成：上部齐刘海sensor housing（44pt） + 安全区域safe area + 底部手势区域Home Indicator（34pt）<br>safe area（安全区域）<br><img src="/2020/03/13/iPhoneX适配/2.webp" alt="img"><br>安全区域以外的是上部“齐刘海” 和 下部“手势区域”，一般情况下，我们都会在安全区域（safe area）中进行页面的编写；</p><h2 id="iPhoneX适配-1"><a href="#iPhoneX适配-1" class="headerlink" title="iPhoneX适配"></a>iPhoneX适配</h2><h3 id="适配方案viewport-fit"><a href="#适配方案viewport-fit" class="headerlink" title="适配方案viewport-fit"></a>适配方案viewport-fit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><p>viewport-fit有两个值，contain和 cover<br>默认是contain，页面内容显示在safe area中（不包括上部的齐刘海和下部的手势区域）<br>cover值：页面内容充满屏幕</p><h3 id="适配方案css-constant"><a href="#适配方案css-constant" class="headerlink" title="适配方案css constant()"></a>适配方案css constant()</h3><p>css constant()<br>有四个值：<code>safe-area-inset-top , safe-area-inset-left , safe-area-inset-right , safe-area-inset-bottom</code><br>1)当viewport-fit:contain，上面这个四个值无效<br>2)当viewport-fit:cover，这四个值需要设置，页面才会显示在安全区域中，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            </span><br><span class="line">    padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                </span><br><span class="line">    padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                </span><br><span class="line">    padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="适配方案媒体查询"><a href="#适配方案媒体查询" class="headerlink" title="适配方案媒体查询"></a>适配方案媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123;</span><br><span class="line">  // iphoneX css部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="viewport-fit-contain"><a href="#viewport-fit-contain" class="headerlink" title="viewport-fit:contain"></a>viewport-fit:contain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=contain&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="viewpoer-fit-cover-css-canstant"><a href="#viewpoer-fit-cover-css-canstant" class="headerlink" title="viewpoer-fit: cover + css canstant()"></a>viewpoer-fit: cover + css canstant()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            </span><br><span class="line">  padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                </span><br><span class="line">  padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                </span><br><span class="line">  padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css的媒体查询"><a href="#css的媒体查询" class="headerlink" title="css的媒体查询"></a>css的媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123;</span><br><span class="line">  // iphoneX css部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;h5在iPhoneX中的页面兼容处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="兼容性" scheme="/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>generator自动运行器</title>
    <link href="/2020/03/12/generator%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E5%99%A8/"/>
    <id>/2020/03/12/generator自动运行器/</id>
    <published>2020-03-12T07:08:06.000Z</published>
    <updated>2020-03-12T07:34:13.762Z</updated>
    
    <content type="html"><![CDATA[<p>手写一个generator自动运行器<br><a id="more"></a></p><h1 id="generator自动运行器"><a href="#generator自动运行器" class="headerlink" title="generator自动运行器"></a>generator自动运行器</h1><p>generator函数是es6新出的功能，之后又推出了async函数，操作异步真的是超级简单。我觉得我们在实际项目中使用generator的机会非常少，即使使用，一般也会依赖co这样的库来方便的使用generator。<br>但是我却想研究一下generator，所以写了一个generator不用手动的调用next函数，而是自动的调用。</p><h2 id="generator手动next代码"><a href="#generator手动next代码" class="headerlink" title="generator手动next代码"></a>generator手动next代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function *gen() &#123;</span><br><span class="line">    var val_1 = yield p1();</span><br><span class="line">    var val_2 = yield p2(val_1);</span><br><span class="line">    var val_3 = yield p3(val_2);</span><br><span class="line">  &#125; </span><br><span class="line">  var g = gen();</span><br><span class="line">  window.gObj = null;</span><br><span class="line">  window.gObj_index = 0;</span><br><span class="line">  gObj = g.next();</span><br><span class="line">  gObj.value.then(function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">    gObj = g.next(res);</span><br><span class="line">    gObj.value.then(function(res) &#123;</span><br><span class="line">      console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，需要在generator函数里手动定义yield的表达式，之后在执行的时候需要手动的调用next函数，但是可以看出来，还是有嵌套的情况。</p><h2 id="generator自动运行代码"><a href="#generator自动运行代码" class="headerlink" title="generator自动运行代码"></a>generator自动运行代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// p1,p2,p3是3个Promise的执行函数</span><br><span class="line">  var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // p1callback,p2callback,p3callback对应着p1,p2,p3的回调</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc generator的生成函数</span><br><span class="line">   * @param &#123; Array &#125; Promise的函数数组</span><br><span class="line">   * @retuen &#123; Function &#125; generator函数</span><br><span class="line">  */</span><br><span class="line">  function gen(arr) &#123;</span><br><span class="line">    var valArr = [];</span><br><span class="line">    return function *() &#123;</span><br><span class="line">      for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">        valArr[i] = yield arr[i](valArr[i-1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc 自动执行generator的next()的函数</span><br><span class="line">   * @param &#123; Function &#125; gen函数</span><br><span class="line">   * @param &#123; Array &#125; Promise函数对应的回调函数数组</span><br><span class="line">   * @param &#123; Any &#125; 向generator的next中传入的值</span><br><span class="line">  */</span><br><span class="line">  function co(gen, arr, res) &#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    var gObj = null;</span><br><span class="line">    var gObj_index = 0;</span><br><span class="line">    function innerCo(g, arr, res) &#123;</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      if(gObj.done) return void 0;</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        arr[gObj_index++](res);  </span><br><span class="line">        if(!gObj.done) &#123;</span><br><span class="line">          innerCo(g, arr, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    innerCo(g, arr, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行co函数</span><br><span class="line">  co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</span><br></pre></td></tr></table></figure><p>可以看出来，最后只需要<code>co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</code>这样一行代码，省去了定义yield，省去了调用next。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先，我并没有去参考co这样的库的使用方法，如何使用都是自己想出来的。</li><li>目前代码只是超级简化版，我也是想验证一下我的想法而已，只有resolve的回调，并没写reject的回调。</li></ul><p>最后，<a href="https://github.com/jinux7/study-collections/tree/master/generator-co" target="_blank" rel="noopener">代码在这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写一个generator自动运行器&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化之时间切片</title>
    <link href="/2020/03/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87/"/>
    <id>/2020/03/12/前端性能优化之时间切片/</id>
    <published>2020-03-12T06:12:08.000Z</published>
    <updated>2020-03-12T07:00:54.136Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化之时间切片<br><a id="more"></a></p><h1 id="前端性能优化之时间切片"><a href="#前端性能优化之时间切片" class="headerlink" title="前端性能优化之时间切片"></a>前端性能优化之时间切片</h1><p>从用户的输入，再到显示器在视觉上给用户的输出，这一过程如果超过 100ms，那么用户会察觉到网页的卡顿，所以为了解决这个问题，每个任务不能超过 50ms，W3C 性能工作组在 LongTask 规范中也将超过 50ms 的任务定义为长任务。<br>所以为了避免长任务，一种方案是使用 Web Worker，将长任务放在 Worker 线程中执行，缺点是无法访问 DOM，而另一种方案是使用时间切片。</p><h2 id="什么是时间切片"><a href="#什么是时间切片" class="headerlink" title="什么是时间切片"></a>什么是时间切片</h2><p>时间切片的核心思想是：如果任务不能在 50 毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。<br>所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过 50ms 的小任务分散在宏任务队列中执行。<br><img src="/2020/03/12/前端性能优化之时间切片/1.png" alt="img"><br>上图可以看到主线程中有一个长任务，这个任务会阻塞主线程。使用时间切片将它切割成很多个小任务后，如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/2.png" alt="img"><br>可以看到现在的主线程有很多密密麻麻的小任务，我们将它放大后如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/3.png" alt="img"><br>可以看到每个小任务中间是有空隙的，代表着任务执行了一小段时间后，将让出主线程的控制权，让浏览器执行其他的任务。</p><blockquote><p>使用时间切片的缺点是，任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。但是为了避免卡死浏览器，这种取舍是很有必要的。</p></blockquote><h2 id="如何使用时间切片"><a href="#如何使用时间切片" class="headerlink" title="如何使用时间切片"></a>如何使用时间切片</h2><p>时间切片是一种概念，也可以理解为一种技术方案，它不是某个 API 的名字，也不是某个工具的名字。<br>事实上，时间切片充分利用了“异步”，在早期，可以使用定时器来实现，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        otherThing() // 执行了50毫秒</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码当按钮被点击时，本应执行 100 毫秒的任务现在被拆分成了两个 50 毫秒的任务。<br>在实际应用中，我们可以进行一些封装，封装后的使用效果类似下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts([someThing, otherThing], function() &#123;</span><br><span class="line">    console.log(&apos;done~&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当然，关于ts这个函数的 API 的设计并不是本文的重点，这里想说明的是，在早期可以利用定时器来实现“时间切片”。<br>ES6 带来了迭代器的概念，并提供了生成器 Generator 函数用来生成迭代器对象，虽然 Generator 函数最正统的用法是生成迭代器对象，但这不妨我们利用它的特性做一些其他的事情。<br>Generator 函数提供了yield关键字，这个关键字可以让函数暂停执行。然后通过迭代器对象的next方法让函数继续执行。</p><blockquote><p>对 Generator 函数不熟悉的同学，需要先学习 Generator 函数的用法。<br>利用这个特性，我们可以设计出更方便使用的时间切片，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    yield</span><br><span class="line">    otherThing() // 执行了50毫秒</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到，我们只需要使用yield这个关键字就可以将本应执行 100 毫秒的任务拆分成了两个 50 毫秒的任务。<br>我们甚至可以将 yield 关键字放在循环里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        someThing() // 执行了50毫秒</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码我们写了一个死循环，但依然不会阻塞主线程，浏览器也不会卡死。</p><h2 id="基于生成器的-ts-实现原理"><a href="#基于生成器的-ts-实现原理" class="headerlink" title="基于生成器的 ts 实现原理"></a>基于生成器的 ts 实现原理</h2><p>通过前面的例子，我们会发现基于 Generator 的时间切片非常好用，但其实 ts 函数的实现原理非常简单，一个最简单的 ts 函数只需要九行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const res = gen.next()</span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码虽然全部只有 9 行，关键代码只有 3、4 行，但这几行代码充分利用了事件循环机制以及 Generator 函数的特性。</p><blockquote><p>创造出这样的代码我还是很开心的。</p></blockquote><p>上面代码核心思想是：通过yield关键字可以将任务暂停执行，从而让出主线程的控制权；通过定时器可以将“未完成的任务”重新放在任务队列中继续执行。</p><h2 id="避免把任务分解的过于零碎"><a href="#避免把任务分解的过于零碎" class="headerlink" title="避免把任务分解的过于零碎"></a>避免把任务分解的过于零碎</h2><p>使用yield来切割任务非常方便，但如果切割的粒度特别细，反而效率不高。假设我们的任务执行100ms，最好的方式是切割成两个执行50ms的任务，而不是切割成 100 个执行1ms的任务。假设被切割的任务之间的间隔为4ms，那么切割成 100 个执行1ms的任务的总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 4) * 100 = 500ms</span><br></pre></td></tr></table></figure></p><p>如果切割成两个执行时间为50ms的任务，那么总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(50 + 4) * 2 = 108ms</span><br></pre></td></tr></table></figure></p><p>可以看到，在不影响用户体验的情况下，下面的总执行时间要比前面的少了 4.6 倍。<br>保证切割的任务刚好接近50ms，可以在用户使用yield时自行评估，也可以在ts函数中根据任务的执行时间判断是否应该一次性执行多个任务。<br>我们将ts函数稍微改进一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const start = performance.now()</span><br><span class="line">        let res = null</span><br><span class="line">        do &#123;</span><br><span class="line">            res = gen.next()</span><br><span class="line">        &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 25)</span><br><span class="line"></span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们测试下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    const start = performance.now()</span><br><span class="line">    while (performance.now() - start &lt; 1000) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这段代码在之前的版本中，在我的电脑上可以打印出 215 次 11，在后面的版本中可以打印出 6300 次 11，说明在总时间相同的情况下，可以执行更多的任务。<br>再看另一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>在我的电脑上，这段代码在之前的版本中，被切割成一万个小任务，总执行时间为 46秒，在之后的版本中，被切割成 52 个小任务，总执行时间为 1.5秒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上代码出自于网络，这里感谢作者的付出，同时贴出作者的原创地址:<br><a href="https://ppt.baomitu.com/d/b267a4a3" target="_blank" rel="noopener">《让你的网页更丝滑》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之时间切片&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
</feed>
