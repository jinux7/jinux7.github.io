<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-03-27T01:24:40.048Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AlloyFinger手势库分析</title>
    <link href="/2020/03/26/AlloyFinger%E6%89%8B%E5%8A%BF%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>/2020/03/26/AlloyFinger手势库分析/</id>
    <published>2020-03-26T09:13:31.000Z</published>
    <updated>2020-03-27T01:24:40.048Z</updated>
    
    <content type="html"><![CDATA[<p>移动端手势库AlloyFinger分析<br><a id="more"></a></p><h1 id="AlloyFinger手势库分析"><a href="#AlloyFinger手势库分析" class="headerlink" title="AlloyFinger手势库分析"></a>AlloyFinger手势库分析</h1><p>AlloyFinger这个移动端手势库是腾讯的AlloyTeam团队开发的，体积小，功能强大，简单易用，具体的使用方法见<a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="noopener">AlloyFinger github</a><br>这两天闲暇的时候好好的读了几遍这个库的代码，写好了注释，理解了作者的思路，受益匪浅。<br>注释代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 移动端手势库</span><br><span class="line"> * @desc 分析</span><br><span class="line"> */</span><br><span class="line">;</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  // 获取两点间距离工具函数</span><br><span class="line">  function getLen(v) &#123;</span><br><span class="line">      return Math.sqrt(v.x * v.x + v.y * v.y);</span><br><span class="line">  &#125;</span><br><span class="line">  // dot和getAngle函数用来算两次手势状态之间的夹角, cross函数用来算方向的, getRotateAngle函数算手势真正的角度的</span><br><span class="line">  function dot(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.x + v1.y * v2.y;</span><br><span class="line">  &#125;</span><br><span class="line"> // 求两次手势状态之间的夹角</span><br><span class="line">  function getAngle(v1, v2) &#123;</span><br><span class="line">      var mr = getLen(v1) * getLen(v2);</span><br><span class="line">      if (mr === 0) return 0;</span><br><span class="line">      var r = dot(v1, v2) / mr;</span><br><span class="line">      if (r &gt; 1) r = 1;</span><br><span class="line">      return Math.acos(r);</span><br><span class="line">  &#125;</span><br><span class="line">  // 利用cross结果的正负来判断旋转的方向(大于0为逆时针, 小于0为顺时针)</span><br><span class="line">  function cross(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.y - v2.x * v1.y;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果cross大于0那就是逆时针对于屏幕是正角,对于第一象限是负角,所以 角度 * -1, 然后角度单位换算</span><br><span class="line">  function getRotateAngle(v1, v2) &#123;</span><br><span class="line">      var angle = getAngle(v1, v2);</span><br><span class="line">      if (cross(v1, v2) &gt; 0) &#123;</span><br><span class="line">          angle *= -1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return angle * 180 / Math.PI;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var HandlerAdmin = function(el) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">      this.el = el;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 函数管理构造函数</span><br><span class="line">  function HandlerAdmin(el) &#123;</span><br><span class="line">    this.handlers = [];</span><br><span class="line">    this.el = el;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.add = function(handler) &#123;</span><br><span class="line">    this.handlers.push(handler);</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.del = function(handler) &#123;</span><br><span class="line">    // 如果什么也不传，清空函数数组</span><br><span class="line">    if(!handler) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 比对数组中的函数，并且删除它</span><br><span class="line">    for(var i=this.handlers.length; i&gt;=0; i--) &#123;</span><br><span class="line">      if(this.handlers[i] === handler) &#123;</span><br><span class="line">          this.handlers.splice(i, 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 运行需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.dispatch = function() &#123;</span><br><span class="line">    for(var i=0,len=this.handlers.length; i&lt;len; i++) &#123;</span><br><span class="line">        var handler = this.handlers[i];</span><br><span class="line">        // 运行这些函数的时候，是作为元素的事件触发的，所以，这些函数的this要指向这个元素</span><br><span class="line">        if(typeof handler === &apos;function&apos;) handler.apply(this.el, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化函数管理对象</span><br><span class="line">  function wrapFunc(el, handler) &#123;</span><br><span class="line">    var handlerAdmin = new HandlerAdmin(el);</span><br><span class="line">    handlerAdmin.add(handler);</span><br><span class="line">    return handlerAdmin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 手势库构造函数</span><br><span class="line">  function AlloyFinger(el, option) &#123;</span><br><span class="line">    // 获取添加事件的元素</span><br><span class="line">    this.element = typeof el === &apos;string&apos; ? document.querySelector(el) : el;</span><br><span class="line">    // 因为添加事件后这些方法的执行上下文是this.element，所以给方法bind JinuxFinger这个执行上下文</span><br><span class="line">    this.start = this.start.bind(this);</span><br><span class="line">    this.move = this.move.bind(this);</span><br><span class="line">    this.end = this.end.bind(this);</span><br><span class="line">    this.cancel = this.cancel.bind(this);</span><br><span class="line">    // 给这个元素添加事件</span><br><span class="line">    this.element.addEventListener(&quot;touchstart&quot;, this.start, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchmove&quot;, this.move, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchend&quot;, this.end, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchcancel&quot;, this.cancel, false);</span><br><span class="line">    // 定义一些实例属性</span><br><span class="line">    this.preV = &#123; x: null, y: null &#125;; // 两个手指间的x距离和y距离</span><br><span class="line">    this.pinchStartLen = null; // 捏拽的长度</span><br><span class="line">    this.zoom = 1; // 缩放比例</span><br><span class="line">    this.isDoubleTap = false; // 是否是双击</span><br><span class="line">    var noop = function() &#123;&#125; // 空函数</span><br><span class="line">    // 实例化JinuxFinger时，设置的手势回调函数</span><br><span class="line">    this.rotate = wrapFunc(this.element, option.rotate || noop); // 旋转</span><br><span class="line">    this.touchStart = wrapFunc(this.element, option.touchStart || noop); // 触摸开始  </span><br><span class="line">    this.multipointStart = wrapFunc(this.element, option.multipointStart || noop); // 多个手指触摸开始 </span><br><span class="line">    this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop); // 多个手指触摸结束，如4个手指触摸，屏幕上剩下1个或不剩都会触发</span><br><span class="line">    this.pinch = wrapFunc(this.element, option.pinch || noop); // 两个手指捏拽</span><br><span class="line">    this.swipe = wrapFunc(this.element, option.swipe || noop); // 上下左右滑动，手指离开时触发</span><br><span class="line">    this.tap = wrapFunc(this.element, option.tap || noop); // 无论是单击还是双击都会触发</span><br><span class="line">    this.doubleTap = wrapFunc(this.element, option.doubleTap || noop); // 双击触发</span><br><span class="line">    this.longTap = wrapFunc(this.element, option.longTap || noop); // 单手指长按触发，750ms</span><br><span class="line">    this.singleTap = wrapFunc(this.element, option.singleTap || noop); // 单击触发，250ms</span><br><span class="line">    this.pressMove = wrapFunc(this.element, option.pressMove || noop); // 1个手指屏幕上移动触发</span><br><span class="line">    this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop); // 2个以上手指屏幕上移动触发</span><br><span class="line">    this.touchMove = wrapFunc(this.element, option.touchMove || noop); // 无论几个手指在屏幕上移动都会触发</span><br><span class="line">    this.touchEnd = wrapFunc(this.element, option.touchEnd || noop); // 触摸结束都会触发</span><br><span class="line">    this.touchCancel = wrapFunc(this.element, option.touchCancel || noop); // 事件简单的说是在移动端发生了触摸中断，一般情况下就是优先级比当前活动更高的事件时，才会触发的。比如正在看新闻，手指滑动屏幕的时候，突然来电话，直接中断了触摸事件，跳转到了通话，页面此时就触发了touchcancel事件。这个事件不容易在浏览器的模拟器中模拟，之前我在用电脑的任务栏切换的时候，受到启发，可以试试在浏览器模拟器触摸的同时，按下键盘上的Alt+Tab键，果然触发了touchcancel事件，有兴趣的小伙伴可以试一下。</span><br><span class="line">    </span><br><span class="line">    this._cancelAllHandler = this.cancelAll.bind(this);</span><br><span class="line">    // 触发window的scroll事件时，清除现有touch事件的回调函数执行</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line"></span><br><span class="line">    this.delta = null; // 双击的间隔时间</span><br><span class="line">    this.last = null; // 相对于下一次点击，前一次点击的时间</span><br><span class="line">    this.now = null; // 当前点击保存用的时间，也可以理解为相对于上一次点击，这个是当前点击的时间</span><br><span class="line">    this.tapTimeout = null;</span><br><span class="line">    this.singleTapTimeout = null;</span><br><span class="line">    this.longTapTimeout = null;</span><br><span class="line">    this.swipeTimeout = null;</span><br><span class="line">    this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">    this.preTapPosition = &#123; x: null, y: null &#125;; // 相对于下次点击，前一次点击手指x,y坐标的保存对象</span><br><span class="line">  &#125;</span><br><span class="line">  AlloyFinger.prototype = &#123;</span><br><span class="line">    start: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 屏幕上没有手指则返回</span><br><span class="line">      this.now = Date.now(); // 设置touch开始时的时间</span><br><span class="line">      this.x1 = evt.touches[0].pageX; // 第一个手指触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动</span><br><span class="line">      this.y1 = evt.touches[0].pageY; // 第一个手指触点相对于HTML文档左边沿的的Y坐标</span><br><span class="line">      this.delta = this.now - (this.last || this.now); // 双击的间隔时间</span><br><span class="line">      this.touchStart.dispatch(evt, this.element); // 触发了touchStart回调函数</span><br><span class="line">      if (this.preTapPosition.x !== null) &#123; // 如果不为null，说明之前已经有点击了</span><br><span class="line">          // 判断是否满足手指双击条件</span><br><span class="line">          this.isDoubleTap = (this.delta &gt; 0 &amp;&amp; this.delta &lt;= 250 &amp;&amp; Math.abs(this.preTapPosition.x - this.x1) &lt; 30 &amp;&amp; Math.abs(this.preTapPosition.y - this.y1) &lt; 30);</span><br><span class="line">          if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">      this.preTapPosition.x = this.x1; // 保存当前手指x坐标</span><br><span class="line">      this.preTapPosition.y = this.y1;// 保存当前手指y坐标</span><br><span class="line">      this.last = this.now; // 保存当前时间</span><br><span class="line">      var preV = this.preV, </span><br><span class="line">          len = evt.touches.length; // 现在屏幕上有多少个手指</span><br><span class="line">      if (len &gt; 1) &#123; // 两个手指以上触摸情况</span><br><span class="line">          this._cancelLongTap(); // 清除长按回调函数的执行</span><br><span class="line">          this._cancelSingleTap(); // 清除点击函数的执行</span><br><span class="line">          // 计算两个手指x,y的距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 &#125;;</span><br><span class="line">          // 赋值给preV</span><br><span class="line">          preV.x = v.x; </span><br><span class="line">          preV.y = v.y;</span><br><span class="line">          this.pinchStartLen = getLen(preV); // 计算出两个手指间的距离</span><br><span class="line">          this.multipointStart.dispatch(evt, this.element); // 触发多点触碰函数回调</span><br><span class="line">      &#125;</span><br><span class="line">      this._preventTap = false; // 长按是否回调执行，否 </span><br><span class="line">      this.longTapTimeout = setTimeout(function () &#123; // 长按触发回调函数的定时器</span><br><span class="line">          this.longTap.dispatch(evt, this.element); // 触发长按回调函数</span><br><span class="line">          this._preventTap = true; // 长按是否回调执行，是</span><br><span class="line">      &#125;.bind(this), 750); // 长按是手指按下750ms后触发</span><br><span class="line">  &#125;,</span><br><span class="line">  move: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 没有touches属性则返回</span><br><span class="line">      var preV = this.preV, // 两个手指间距离暂存preV里</span><br><span class="line">          len = evt.touches.length, // 屏幕上的手指数</span><br><span class="line">          currentX = evt.touches[0].pageX, // 屏幕上第一个手指的pageX暂存</span><br><span class="line">          currentY = evt.touches[0].pageY; // 屏幕上第一个手指的pageY暂存</span><br><span class="line">      this.isDoubleTap = false; // 手指移动了，就不是双击了</span><br><span class="line">      if (len &gt; 1) &#123; // 手指大于2个情况</span><br><span class="line">          var sCurrentX = evt.touches[1].pageX, // 屏幕上第2个手指的pageX暂存</span><br><span class="line">              sCurrentY = evt.touches[1].pageY; // 屏幕上第2个手指的pageY暂存</span><br><span class="line">          // 两个手指间距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY &#125;;</span><br><span class="line"></span><br><span class="line">          if (preV.x !== null) &#123;</span><br><span class="line">              if (this.pinchStartLen &gt; 0) &#123; // move之前两指间的距离如果大于0情况</span><br><span class="line">                  evt.zoom = getLen(v) / this.pinchStartLen; // move后的距离/move前的，就是捏拽的比例</span><br><span class="line">                  this.pinch.dispatch(evt, this.element); // 触发捏拽回调，并将zoom属性传递到事件对象里</span><br><span class="line">              &#125;</span><br><span class="line">              // 获取手指移动的角度</span><br><span class="line">              evt.angle = getRotateAngle(v, preV);</span><br><span class="line">              this.rotate.dispatch(evt, this.element); // 触发旋转回调函数</span><br><span class="line">          &#125;</span><br><span class="line">          preV.x = v.x; // move时将现在两指间的距离x赋值给preV</span><br><span class="line">          preV.y = v.y; // move时将现在两指间的距离y赋值给preV</span><br><span class="line"></span><br><span class="line">          if (this.x2 !== null &amp;&amp; this.sx2 !== null) &#123; // 因为是两个手指，所以取的是两个手指中间的值，两次move之间的偏移量,参考下变一个手指情况</span><br><span class="line">              evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;</span><br><span class="line">              evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;</span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          this.twoFingerPressMove.dispatch(evt, this.element); // 两个以上手指移动的事件回调</span><br><span class="line"></span><br><span class="line">          this.sx2 = sCurrentX; // 第二个手指坐标x暂存</span><br><span class="line">          this.sy2 = sCurrentY; // 第二个手指坐标y暂存</span><br><span class="line">      &#125; else &#123; // 单指move情况下</span><br><span class="line">          if (this.x2 !== null) &#123; // 第一次移动this.x2=null的,第二次之后才为true</span><br><span class="line">              evt.deltaX = currentX - this.x2; // x方向两次move事件的差值</span><br><span class="line">              evt.deltaY = currentY - this.y2; // y方向两次move事件的差值</span><br><span class="line"></span><br><span class="line">              //move事件中添加对当前触摸点到初始触摸点的判断，</span><br><span class="line">              //如果曾经大于过某个距离(比如10),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。</span><br><span class="line">              var movedX = Math.abs(this.x1 - this.x2),</span><br><span class="line">                  movedY = Math.abs(this.y1 - this.y2);</span><br><span class="line"></span><br><span class="line">              if(movedX &gt; 10 || movedY &gt; 10)&#123;</span><br><span class="line">                  this._preventTap = true;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          this.pressMove.dispatch(evt, this.element); // 一个手指移动的触发回调</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchMove.dispatch(evt, this.element); // 有移动就触发touchMove事件回调</span><br><span class="line"></span><br><span class="line">      this._cancelLongTap(); // 有移动事件了，清除长按的事件回调</span><br><span class="line">      this.x2 = currentX; // 将当前第一个手指的坐标x复制给this.x2</span><br><span class="line">      this.y2 = currentY; // 将当前第一个手指的坐标y复制给this.y2</span><br><span class="line">      </span><br><span class="line">      if (len &gt; 1) &#123; // 两个以上手指，阻止浏览器默认事件</span><br><span class="line">          evt.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  end: function (evt) &#123;</span><br><span class="line">      if (!evt.changedTouches) return; // end事件触发时，changedTouches为空，则返回</span><br><span class="line">      this._cancelLongTap(); // 取消长按的回调函数</span><br><span class="line">      var self = this; // this暂存在bianliangself</span><br><span class="line">      if (evt.touches.length &lt; 2) &#123; // 目前屏幕上留下的手指0或者1个</span><br><span class="line">          this.multipointEnd.dispatch(evt, this.element); // 调用多指触摸的结束回调</span><br><span class="line">          this.sx2 = this.sy2 = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //swipe</span><br><span class="line">      // this.x2或this.y2有值说明有在屏幕上移动，并且计算移动后离开屏幕时的坐标与this.x1手指刚触摸屏幕时的坐标差值大于30，可以出发swipe事件回调</span><br><span class="line">      if ((this.x2 &amp;&amp; Math.abs(this.x1 - this.x2) &gt; 30) ||</span><br><span class="line">          (this.y2 &amp;&amp; Math.abs(this.y1 - this.y2) &gt; 30)) &#123;</span><br><span class="line">          // 获取滑动的方向  </span><br><span class="line">          evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);</span><br><span class="line">          this.swipeTimeout = setTimeout(function () &#123; // 触发swipe回调函数，加入宏任务队列</span><br><span class="line">              self.swipe.dispatch(evt, self.element);</span><br><span class="line"></span><br><span class="line">          &#125;, 0)</span><br><span class="line">      &#125; else &#123; // 这里说明不是swipe事件，只是点击事件</span><br><span class="line">          this.tapTimeout = setTimeout(function () &#123; // 点击定时器</span><br><span class="line">              if(!self._preventTap)&#123; // 长按事件函数没有执行</span><br><span class="line">                  self.tap.dispatch(evt, self.element); // 执行tap回调</span><br><span class="line">              &#125;</span><br><span class="line">              // trigger double tap immediately</span><br><span class="line">              if (self.isDoubleTap) &#123; // 如果是双击的话</span><br><span class="line">                  self.doubleTap.dispatch(evt, self.element); // 执行双击事件回调</span><br><span class="line">                  self.isDoubleTap = false; // 执行之后设置双击标识为假</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line"></span><br><span class="line">          if (!self.isDoubleTap) &#123; // 如果不是双击操作</span><br><span class="line">              self.singleTapTimeout = setTimeout(function () &#123; // 250ms后执行singleTap事件回调</span><br><span class="line">                  self.singleTap.dispatch(evt, self.element);</span><br><span class="line">              &#125;, 250);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchEnd.dispatch(evt, this.element); // 手指离开都会触发touchEnd事件回调</span><br><span class="line">      // 手指离开后将一些属性重置</span><br><span class="line">      this.preV.x = 0;</span><br><span class="line">      this.preV.y = 0;</span><br><span class="line">      this.zoom = 1;</span><br><span class="line">      this.pinchStartLen = null;</span><br><span class="line">      this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelAll: function () &#123;</span><br><span class="line">      this._preventTap = true; // 阻止tap事件</span><br><span class="line">      clearTimeout(this.singleTapTimeout); // 清除singleTapTimeout定时器</span><br><span class="line">      clearTimeout(this.tapTimeout); // 清除tapTimeout定时器</span><br><span class="line">      clearTimeout(this.longTapTimeout); // 清除longTapTimeout定时器</span><br><span class="line">      clearTimeout(this.swipeTimeout); // 清除swipeTimeout定时器</span><br><span class="line">  &#125;,</span><br><span class="line">  cancel: function (evt) &#123; // cancel事件</span><br><span class="line">      this.cancelAll()</span><br><span class="line">      this.touchCancel.dispatch(evt, this.element); // 触发touchCancel回调</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelLongTap: function () &#123; // 清除longTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.longTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelSingleTap: function () &#123; // 清除singleTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.singleTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 计算swipe的方向函数</span><br><span class="line">  _swipeDirection: function (x1, x2, y1, y2) &#123;</span><br><span class="line">      return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? &apos;Left&apos; : &apos;Right&apos;) : (y1 - y2 &gt; 0 ? &apos;Up&apos; : &apos;Down&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件添加回调函数</span><br><span class="line">  on: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].add(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件删除回调函数</span><br><span class="line">  off: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].del(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 实例销毁函数</span><br><span class="line">  destroy: function() &#123;</span><br><span class="line">      if(this.singleTapTimeout) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      if(this.tapTimeout) clearTimeout(this.tapTimeout);</span><br><span class="line">      if(this.longTapTimeout) clearTimeout(this.longTapTimeout);</span><br><span class="line">      if(this.swipeTimeout) clearTimeout(this.swipeTimeout);</span><br><span class="line"></span><br><span class="line">      this.element.removeEventListener(&quot;touchstart&quot;, this.start);</span><br><span class="line">      this.element.removeEventListener(&quot;touchmove&quot;, this.move);</span><br><span class="line">      this.element.removeEventListener(&quot;touchend&quot;, this.end);</span><br><span class="line">      this.element.removeEventListener(&quot;touchcancel&quot;, this.cancel);</span><br><span class="line"></span><br><span class="line">      this.rotate.del();</span><br><span class="line">      this.touchStart.del();</span><br><span class="line">      this.multipointStart.del();</span><br><span class="line">      this.multipointEnd.del();</span><br><span class="line">      this.pinch.del();</span><br><span class="line">      this.swipe.del();</span><br><span class="line">      this.tap.del();</span><br><span class="line">      this.doubleTap.del();</span><br><span class="line">      this.longTap.del();</span><br><span class="line">      this.singleTap.del();</span><br><span class="line">      this.pressMove.del();</span><br><span class="line">      this.twoFingerPressMove.del()</span><br><span class="line">      this.touchMove.del();</span><br><span class="line">      this.touchEnd.del();</span><br><span class="line">      this.touchCancel.del();</span><br><span class="line"></span><br><span class="line">      this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;</span><br><span class="line"></span><br><span class="line">      window.removeEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 暴露给外部使用</span><br><span class="line">  if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">    module.exports = AlloyFinger;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      window.AlloyFinger = AlloyFinger;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端手势库AlloyFinger分析&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写call,apply,bind函数</title>
    <link href="/2020/03/25/%E6%89%8B%E5%86%99call-apply-bind%E5%87%BD%E6%95%B0/"/>
    <id>/2020/03/25/手写call-apply-bind函数/</id>
    <published>2020-03-25T06:17:43.000Z</published>
    <updated>2020-03-25T07:01:19.519Z</updated>
    
    <content type="html"><![CDATA[<p>手写call,apply,bind函数<br><a id="more"></a></p><h1 id="手写call-apply-bind函数"><a href="#手写call-apply-bind函数" class="headerlink" title="手写call,apply,bind函数"></a>手写call,apply,bind函数</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = arguments[1];</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myApply(testObj, [1, 2, 3]);</span><br></pre></td></tr></table></figure></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  let _this = this</span><br><span class="line">  let args = [...arguments].slice(1)</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 判断是否被当做构造函数使用</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return _this.apply(this, args.concat([...arguments]))</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat([...arguments]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myBind(testObj, 1)(2, 3);</span><br></pre></td></tr></table></figure></p><p>以上就是我们常用的call，apply，bind函数的手写实现，但是，用到了es6的[…arg]结构语法，下面只写一个call实现的es5版本。</p><h2 id="call-es5版"><a href="#call-es5版" class="headerlink" title="call es5版"></a>call es5版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var fnStr = `context.fn(`;</span><br><span class="line">    for(var i=0, len=arg.length; i&lt;len; i++) &#123;</span><br><span class="line">        if(i === (len-1)) &#123;</span><br><span class="line">            fnStr += arg[i];    </span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fnStr += arg[i] + &apos;,&apos;;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += &apos;)&apos;;</span><br><span class="line">    console.log(fnStr);</span><br><span class="line">    var result = eval(fnStr);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写call,apply,bind函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="/2020/03/20/%E6%89%8B%E5%86%99Promise/"/>
    <id>/2020/03/20/手写Promise/</id>
    <published>2020-03-20T05:30:12.000Z</published>
    <updated>2020-03-20T07:20:42.907Z</updated>
    
    <content type="html"><![CDATA[<p>模拟一个Promise功能<br><a id="more"></a></p><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>现在的异步基本上都是用Promise来实现的，用起来很方便，但是，Promise是怎么实现的呢，它的then回调是怎么工作的，带着这些疑问，决定自己实现一个Promise。<br>早在2年前，其实我就实现过一个Promise，不过那个原理比较笨，还用到了定时器循环，后来陆续看了些其他人的写法，还是有点没绕明白，这两天又看了向军老师的实现方式，觉得很好，自己也实现一下。<br>主要的难以理解的地方是then函数的写法，这个地方明白了整个Promise也就理解了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  // 等待状态</span><br><span class="line">  static PENDING = &quot;pending&quot;;</span><br><span class="line">  // 成功状态</span><br><span class="line">  static FULFILLED = &quot;fulfilled&quot;;</span><br><span class="line">  // 拒绝状态</span><br><span class="line">  static REJECTED = &quot;rejected&quot;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态是等待</span><br><span class="line">    this.status = MyPromise.PENDING;</span><br><span class="line">    // 成功值</span><br><span class="line">    this.value = null;</span><br><span class="line">    // 拒绝值</span><br><span class="line">    this.reason = null;</span><br><span class="line">    // then的回调数组</span><br><span class="line">    this.callbacks = [];</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 成功调用函数</span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.status = MyPromise.FULFILLED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onFulfilled(this.value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 拒绝调用函数</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      this.status = MyPromise.REJECTED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onRejected(this.reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then函数</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    if (typeof onFulfilled != &quot;function&quot;) &#123;</span><br><span class="line">      onFulfilled = () =&gt; this.value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof onRejected != &quot;function&quot;) &#123;</span><br><span class="line">      onRejected = () =&gt; this.reason;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链式调用，返回一个MyPromise</span><br><span class="line">    const p = new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">        this.callbacks.push(&#123;</span><br><span class="line">          onFulfilled: (value)=&gt; &#123;</span><br><span class="line">            let result = onFulfilled(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected: (value)=&gt; &#123;</span><br><span class="line">            let result = onRejected(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.FULFILLED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onFulfilled(this.value);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.REJECTED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onRejected(this.reason);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(value instanceof MyPromise) &#123;</span><br><span class="line">        value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.all方法</span><br><span class="line">  static all(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      let values = [];</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            values.push(value);</span><br><span class="line">            if(values.length === promises.length) &#123;</span><br><span class="line">              resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.race方法</span><br><span class="line">  static race(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>demo代码<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99promise" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟一个Promise功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>nodejs环境变量NODE_ENV</title>
    <link href="/2020/03/17/nodejs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE-ENV/"/>
    <id>/2020/03/17/nodejs环境变量NODE-ENV/</id>
    <published>2020-03-17T07:20:52.000Z</published>
    <updated>2020-03-17T08:14:52.457Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs环境变量NODE_ENV的设置和获取<br><a id="more"></a></p><h1 id="nodejs环境变量NODE-ENV"><a href="#nodejs环境变量NODE-ENV" class="headerlink" title="nodejs环境变量NODE_ENV"></a>nodejs环境变量NODE_ENV</h1><p>我们在使用webpack打包的时候，会根据环境变量的不同做各种操作，那么，环境变量是如何设置和获取的呢？<br>首先说一下，在命令行中设置的环境变量是临时的，当命令行关闭后就没有了，要想持久化的设置环境变量，只能到我的电脑，属性，高级，环境变量里设置。</p><p>首先，创建一个app.js的文件，内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.NODE_ENV);</span><br></pre></td></tr></table></figure></p><p>我们把环境变量打印出来看看。<br>在命令行下(window系统的cmd可以，powershell和git bash不行)，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set NODE_ENV=pro &amp;&amp; node app.js</span><br></pre></td></tr></table></figure></p><p>打印出<code>pro</code><br>如果想在powershell和git bash都可以使用，那就得利用npm，在package.json中的scripts里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;pro&quot;: &quot;set NODE_ENV=pro &amp;&amp; node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>利用npm可以获取NODE_ENV的值。<br>这种方法的不足是，<code>set NODE_ENV=pro</code>是window的方式，而linux和ios是<code>export NODE_ENV=&#39;pro&#39;</code>,为了一套命令的兼容性，<br>我们可以使用<code>cross-env</code>这个nodejs模块，使用方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>好了，我们已经可以获取NODE_ENV环境变量了。<br>再介绍一个可以获取命令行参数的方便方法，<code>process.env.npm_config_argv</code><br>看名字就知道，只能在npm命令下使用，我们来看看具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.npm_config_argv);</span><br></pre></td></tr></table></figure></p><p>当我们执行<code>npm run dev</code><br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;remain&quot;:[],&quot;cooked&quot;:[&quot;run&quot;,&quot;dev&quot;],&quot;original&quot;:[&quot;run&quot;,&quot;dev&quot;]&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以分析是dev还是pro来处理不同操作。<br>其实，我们想做的莫非就是利用命令行中不同的参数做不同的操作而已，nodejs有一个<code>process.argv</code>属性，可以获取命令行下的参数，来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.argv);</span><br></pre></td></tr></table></figure></p><p>我们在命令行下执行：<code>node app.js dev pro</code>。<br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;C:\\Program Files\\nodejs\\node.exe&apos;,</span><br><span class="line">  &apos;C:\\Jinux\\test\\nodejs-env\\app.js&apos;,</span><br><span class="line">  &apos;dev&apos;,</span><br><span class="line">  &apos;pro&apos; ]</span><br></pre></td></tr></table></figure></p><p>我们还是可以根据命令行下的参数做不同的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs环境变量NODE_ENV的设置和获取&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iPhoneX适配</title>
    <link href="/2020/03/13/iPhoneX%E9%80%82%E9%85%8D/"/>
    <id>/2020/03/13/iPhoneX适配/</id>
    <published>2020-03-13T06:24:28.000Z</published>
    <updated>2020-03-13T06:44:07.611Z</updated>
    
    <content type="html"><![CDATA[<p>h5在iPhoneX中的页面兼容处理<br><a id="more"></a></p><h1 id="iPhoneX适配"><a href="#iPhoneX适配" class="headerlink" title="iPhoneX适配"></a>iPhoneX适配</h1><h2 id="基础设备信息"><a href="#基础设备信息" class="headerlink" title="基础设备信息"></a>基础设备信息</h2><p>首先在了解iPhoneX适配之前，需要了解关于iPhone设备的一些基础</p><h3 id="关于iPhone的一些基础参数"><a href="#关于iPhone的一些基础参数" class="headerlink" title="关于iPhone的一些基础参数"></a>关于iPhone的一些基础参数</h3><p><img src="/2020/03/13/iPhoneX适配/1.webp" alt="img"></p><h3 id="iPhoneX设备信息"><a href="#iPhoneX设备信息" class="headerlink" title="iPhoneX设备信息"></a>iPhoneX设备信息</h3><p>iPhoneX屏幕组成：上部齐刘海sensor housing（44pt） + 安全区域safe area + 底部手势区域Home Indicator（34pt）<br>safe area（安全区域）<br><img src="/2020/03/13/iPhoneX适配/2.webp" alt="img"><br>安全区域以外的是上部“齐刘海” 和 下部“手势区域”，一般情况下，我们都会在安全区域（safe area）中进行页面的编写；</p><h2 id="iPhoneX适配-1"><a href="#iPhoneX适配-1" class="headerlink" title="iPhoneX适配"></a>iPhoneX适配</h2><h3 id="适配方案viewport-fit"><a href="#适配方案viewport-fit" class="headerlink" title="适配方案viewport-fit"></a>适配方案viewport-fit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><p>viewport-fit有两个值，contain和 cover<br>默认是contain，页面内容显示在safe area中（不包括上部的齐刘海和下部的手势区域）<br>cover值：页面内容充满屏幕</p><h3 id="适配方案css-constant"><a href="#适配方案css-constant" class="headerlink" title="适配方案css constant()"></a>适配方案css constant()</h3><p>css constant()<br>有四个值：<code>safe-area-inset-top , safe-area-inset-left , safe-area-inset-right , safe-area-inset-bottom</code><br>1)当viewport-fit:contain，上面这个四个值无效<br>2)当viewport-fit:cover，这四个值需要设置，页面才会显示在安全区域中，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            </span><br><span class="line">    padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                </span><br><span class="line">    padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                </span><br><span class="line">    padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="适配方案媒体查询"><a href="#适配方案媒体查询" class="headerlink" title="适配方案媒体查询"></a>适配方案媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123;</span><br><span class="line">  // iphoneX css部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="viewport-fit-contain"><a href="#viewport-fit-contain" class="headerlink" title="viewport-fit:contain"></a>viewport-fit:contain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=contain&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="viewpoer-fit-cover-css-canstant"><a href="#viewpoer-fit-cover-css-canstant" class="headerlink" title="viewpoer-fit: cover + css canstant()"></a>viewpoer-fit: cover + css canstant()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            </span><br><span class="line">  padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                </span><br><span class="line">  padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                </span><br><span class="line">  padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css的媒体查询"><a href="#css的媒体查询" class="headerlink" title="css的媒体查询"></a>css的媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123;</span><br><span class="line">  // iphoneX css部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;h5在iPhoneX中的页面兼容处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="兼容性" scheme="/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>generator自动运行器</title>
    <link href="/2020/03/12/generator%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E5%99%A8/"/>
    <id>/2020/03/12/generator自动运行器/</id>
    <published>2020-03-12T07:08:06.000Z</published>
    <updated>2020-03-12T07:34:13.762Z</updated>
    
    <content type="html"><![CDATA[<p>手写一个generator自动运行器<br><a id="more"></a></p><h1 id="generator自动运行器"><a href="#generator自动运行器" class="headerlink" title="generator自动运行器"></a>generator自动运行器</h1><p>generator函数是es6新出的功能，之后又推出了async函数，操作异步真的是超级简单。我觉得我们在实际项目中使用generator的机会非常少，即使使用，一般也会依赖co这样的库来方便的使用generator。<br>但是我却想研究一下generator，所以写了一个generator不用手动的调用next函数，而是自动的调用。</p><h2 id="generator手动next代码"><a href="#generator手动next代码" class="headerlink" title="generator手动next代码"></a>generator手动next代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function *gen() &#123;</span><br><span class="line">    var val_1 = yield p1();</span><br><span class="line">    var val_2 = yield p2(val_1);</span><br><span class="line">    var val_3 = yield p3(val_2);</span><br><span class="line">  &#125; </span><br><span class="line">  var g = gen();</span><br><span class="line">  window.gObj = null;</span><br><span class="line">  window.gObj_index = 0;</span><br><span class="line">  gObj = g.next();</span><br><span class="line">  gObj.value.then(function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">    gObj = g.next(res);</span><br><span class="line">    gObj.value.then(function(res) &#123;</span><br><span class="line">      console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，需要在generator函数里手动定义yield的表达式，之后在执行的时候需要手动的调用next函数，但是可以看出来，还是有嵌套的情况。</p><h2 id="generator自动运行代码"><a href="#generator自动运行代码" class="headerlink" title="generator自动运行代码"></a>generator自动运行代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// p1,p2,p3是3个Promise的执行函数</span><br><span class="line">  var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // p1callback,p2callback,p3callback对应着p1,p2,p3的回调</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc generator的生成函数</span><br><span class="line">   * @param &#123; Array &#125; Promise的函数数组</span><br><span class="line">   * @retuen &#123; Function &#125; generator函数</span><br><span class="line">  */</span><br><span class="line">  function gen(arr) &#123;</span><br><span class="line">    var valArr = [];</span><br><span class="line">    return function *() &#123;</span><br><span class="line">      for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">        valArr[i] = yield arr[i](valArr[i-1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc 自动执行generator的next()的函数</span><br><span class="line">   * @param &#123; Function &#125; gen函数</span><br><span class="line">   * @param &#123; Array &#125; Promise函数对应的回调函数数组</span><br><span class="line">   * @param &#123; Any &#125; 向generator的next中传入的值</span><br><span class="line">  */</span><br><span class="line">  function co(gen, arr, res) &#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    var gObj = null;</span><br><span class="line">    var gObj_index = 0;</span><br><span class="line">    function innerCo(g, arr, res) &#123;</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      if(gObj.done) return void 0;</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        arr[gObj_index++](res);  </span><br><span class="line">        if(!gObj.done) &#123;</span><br><span class="line">          innerCo(g, arr, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    innerCo(g, arr, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行co函数</span><br><span class="line">  co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</span><br></pre></td></tr></table></figure><p>可以看出来，最后只需要<code>co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</code>这样一行代码，省去了定义yield，省去了调用next。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先，我并没有去参考co这样的库的使用方法，如何使用都是自己想出来的。</li><li>目前代码只是超级简化版，我也是想验证一下我的想法而已，只有resolve的回调，并没写reject的回调。</li></ul><p>最后，<a href="https://github.com/jinux7/study-collections/tree/master/generator-co" target="_blank" rel="noopener">代码在这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写一个generator自动运行器&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化之时间切片</title>
    <link href="/2020/03/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87/"/>
    <id>/2020/03/12/前端性能优化之时间切片/</id>
    <published>2020-03-12T06:12:08.000Z</published>
    <updated>2020-03-12T07:00:54.136Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化之时间切片<br><a id="more"></a></p><h1 id="前端性能优化之时间切片"><a href="#前端性能优化之时间切片" class="headerlink" title="前端性能优化之时间切片"></a>前端性能优化之时间切片</h1><p>从用户的输入，再到显示器在视觉上给用户的输出，这一过程如果超过 100ms，那么用户会察觉到网页的卡顿，所以为了解决这个问题，每个任务不能超过 50ms，W3C 性能工作组在 LongTask 规范中也将超过 50ms 的任务定义为长任务。<br>所以为了避免长任务，一种方案是使用 Web Worker，将长任务放在 Worker 线程中执行，缺点是无法访问 DOM，而另一种方案是使用时间切片。</p><h2 id="什么是时间切片"><a href="#什么是时间切片" class="headerlink" title="什么是时间切片"></a>什么是时间切片</h2><p>时间切片的核心思想是：如果任务不能在 50 毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。<br>所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过 50ms 的小任务分散在宏任务队列中执行。<br><img src="/2020/03/12/前端性能优化之时间切片/1.png" alt="img"><br>上图可以看到主线程中有一个长任务，这个任务会阻塞主线程。使用时间切片将它切割成很多个小任务后，如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/2.png" alt="img"><br>可以看到现在的主线程有很多密密麻麻的小任务，我们将它放大后如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/3.png" alt="img"><br>可以看到每个小任务中间是有空隙的，代表着任务执行了一小段时间后，将让出主线程的控制权，让浏览器执行其他的任务。</p><blockquote><p>使用时间切片的缺点是，任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。但是为了避免卡死浏览器，这种取舍是很有必要的。</p></blockquote><h2 id="如何使用时间切片"><a href="#如何使用时间切片" class="headerlink" title="如何使用时间切片"></a>如何使用时间切片</h2><p>时间切片是一种概念，也可以理解为一种技术方案，它不是某个 API 的名字，也不是某个工具的名字。<br>事实上，时间切片充分利用了“异步”，在早期，可以使用定时器来实现，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        otherThing() // 执行了50毫秒</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码当按钮被点击时，本应执行 100 毫秒的任务现在被拆分成了两个 50 毫秒的任务。<br>在实际应用中，我们可以进行一些封装，封装后的使用效果类似下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts([someThing, otherThing], function() &#123;</span><br><span class="line">    console.log(&apos;done~&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当然，关于ts这个函数的 API 的设计并不是本文的重点，这里想说明的是，在早期可以利用定时器来实现“时间切片”。<br>ES6 带来了迭代器的概念，并提供了生成器 Generator 函数用来生成迭代器对象，虽然 Generator 函数最正统的用法是生成迭代器对象，但这不妨我们利用它的特性做一些其他的事情。<br>Generator 函数提供了yield关键字，这个关键字可以让函数暂停执行。然后通过迭代器对象的next方法让函数继续执行。</p><blockquote><p>对 Generator 函数不熟悉的同学，需要先学习 Generator 函数的用法。<br>利用这个特性，我们可以设计出更方便使用的时间切片，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    yield</span><br><span class="line">    otherThing() // 执行了50毫秒</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到，我们只需要使用yield这个关键字就可以将本应执行 100 毫秒的任务拆分成了两个 50 毫秒的任务。<br>我们甚至可以将 yield 关键字放在循环里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        someThing() // 执行了50毫秒</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码我们写了一个死循环，但依然不会阻塞主线程，浏览器也不会卡死。</p><h2 id="基于生成器的-ts-实现原理"><a href="#基于生成器的-ts-实现原理" class="headerlink" title="基于生成器的 ts 实现原理"></a>基于生成器的 ts 实现原理</h2><p>通过前面的例子，我们会发现基于 Generator 的时间切片非常好用，但其实 ts 函数的实现原理非常简单，一个最简单的 ts 函数只需要九行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const res = gen.next()</span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码虽然全部只有 9 行，关键代码只有 3、4 行，但这几行代码充分利用了事件循环机制以及 Generator 函数的特性。</p><blockquote><p>创造出这样的代码我还是很开心的。</p></blockquote><p>上面代码核心思想是：通过yield关键字可以将任务暂停执行，从而让出主线程的控制权；通过定时器可以将“未完成的任务”重新放在任务队列中继续执行。</p><h2 id="避免把任务分解的过于零碎"><a href="#避免把任务分解的过于零碎" class="headerlink" title="避免把任务分解的过于零碎"></a>避免把任务分解的过于零碎</h2><p>使用yield来切割任务非常方便，但如果切割的粒度特别细，反而效率不高。假设我们的任务执行100ms，最好的方式是切割成两个执行50ms的任务，而不是切割成 100 个执行1ms的任务。假设被切割的任务之间的间隔为4ms，那么切割成 100 个执行1ms的任务的总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 4) * 100 = 500ms</span><br></pre></td></tr></table></figure></p><p>如果切割成两个执行时间为50ms的任务，那么总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(50 + 4) * 2 = 108ms</span><br></pre></td></tr></table></figure></p><p>可以看到，在不影响用户体验的情况下，下面的总执行时间要比前面的少了 4.6 倍。<br>保证切割的任务刚好接近50ms，可以在用户使用yield时自行评估，也可以在ts函数中根据任务的执行时间判断是否应该一次性执行多个任务。<br>我们将ts函数稍微改进一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const start = performance.now()</span><br><span class="line">        let res = null</span><br><span class="line">        do &#123;</span><br><span class="line">            res = gen.next()</span><br><span class="line">        &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 25)</span><br><span class="line"></span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们测试下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    const start = performance.now()</span><br><span class="line">    while (performance.now() - start &lt; 1000) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这段代码在之前的版本中，在我的电脑上可以打印出 215 次 11，在后面的版本中可以打印出 6300 次 11，说明在总时间相同的情况下，可以执行更多的任务。<br>再看另一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>在我的电脑上，这段代码在之前的版本中，被切割成一万个小任务，总执行时间为 46秒，在之后的版本中，被切割成 52 个小任务，总执行时间为 1.5秒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上代码出自于网络，这里感谢作者的付出，同时贴出作者的原创地址:<br><a href="https://ppt.baomitu.com/d/b267a4a3" target="_blank" rel="noopener">《让你的网页更丝滑》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之时间切片&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>手写mockjs</title>
    <link href="/2020/03/10/%E6%89%8B%E5%86%99mockjs/"/>
    <id>/2020/03/10/手写mockjs/</id>
    <published>2020-03-10T03:32:31.000Z</published>
    <updated>2020-03-10T05:43:36.531Z</updated>
    
    <content type="html"><![CDATA[<p>简单的写一个mockjs<br><a id="more"></a></p><h1 id="手写mockjs"><a href="#手写mockjs" class="headerlink" title="手写mockjs"></a>手写mockjs</h1><p>在我们前端的开发中，mock数据是必须走的一环，我们可以完全脱离后端接口，等我们前端开发好了之后，再跟后台接口的无缝对接。<br>其实mock数据的方式有很多，比如写一些静态text文档，用nodejs写一个后台服务，都可以满足mock数据的需求。但是，最方便的莫过于使用mockjs工具库了，他可以自动的拦截ajax请求，返回配置好的mock数据。<br>我第一次这个库大概是2016年，感觉很方便，后来也想过它的实现原理是什么，不过当时没有想出来。最近在使用vue的ant pro时候，里面就使用了mockjs，于是准备自己写一个mockjs。<br>我并没有看mockjs的源码，不知道它是怎么实现的，我的想法是既然它可以拦截ajax的请求，那么肯定对原生的XMLHttpRequest做了什么处理，于是乎，我准备覆盖掉原生的XMLHttpRequest对象，这样使用ajax的时候new出来的对象是我自己写的构造函数，不就可以满足拦截ajax请求的目的了吗。<br>我只是实现了拦截ajax的初级功能，并没有深入，点到为止。<br>mockjs代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">// 将原生的XMLHttpRequest缓存起来</span><br><span class="line">window.XMLHttpRequestMock = window.XMLHttpRequest;</span><br><span class="line">// mock对象，用来存储ajax的path和返回的数据</span><br><span class="line">window.mock = &#123;</span><br><span class="line">  urlData: &#123;&#125;,</span><br><span class="line">  setPath: function(path, data) &#123;</span><br><span class="line">    this.urlData[path] = data;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">// 覆盖原生XMLHttpRequest的构造函数</span><br><span class="line">function XmlMock() &#123;</span><br><span class="line">  this.type = null;</span><br><span class="line">  this.url = null;</span><br><span class="line">  this.onreadystatechange = null;</span><br><span class="line">&#125;</span><br><span class="line">// open方法</span><br><span class="line">XmlMock.prototype.open = function(type, url) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">  this.url = url;</span><br><span class="line">  this.readyState = 4;</span><br><span class="line">  this.status = 200</span><br><span class="line">&#125;</span><br><span class="line">// send方法，这里会判断，如果请求的path在mock.urlData中则返回设置好据的数，</span><br><span class="line">// 如果不在，则利用原生的XMLHttpRequest来进行ajax网络请求</span><br><span class="line">XmlMock.prototype.send = function(params) &#123;</span><br><span class="line">  var path = &apos;&apos;; </span><br><span class="line">  var _this = this; </span><br><span class="line">  for(var key in mock.urlData) &#123;</span><br><span class="line">    if((this.url).indexOf(key)&gt;-1) &#123;</span><br><span class="line">      path = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(path) &#123;</span><br><span class="line">    this.responseText = mock.urlData[path];</span><br><span class="line">    this.onreadystatechange(this);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    var xhr = new XMLHttpRequestMock();</span><br><span class="line">    xhr.open(&apos;get&apos;, this.url, false);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123;</span><br><span class="line">        _this.responseText = xhr.responseText;</span><br><span class="line">        _this.onreadystatechange(_this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.XMLHttpRequest = XmlMock;</span><br></pre></td></tr></table></figure></p><p>html使用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;./mock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  mock.setPath(&apos;get/小明&apos;, &#123;name: &apos;小明&apos;&#125;);</span><br><span class="line">  mock.setPath(&apos;get/小红&apos;, &#123;name: &apos;小红&apos;&#125;);</span><br><span class="line"></span><br><span class="line">  fetchData(&apos;http://jinux.top/get/小明&apos;, function(res) &#123;</span><br><span class="line">    console.log(&apos;小明mock数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  fetchData(&apos;http://jinux.top/get/小红&apos;, function(res) &#123;</span><br><span class="line">    console.log(&apos;小红mock数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 测试真实的ajax数据，用的实际百度的一个链接</span><br><span class="line">  var testUrl = &apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/home/js/nu_instant_search_baaa58d.js&apos;;</span><br><span class="line">  fetchData(testUrl, function(res) &#123;</span><br><span class="line">    console.log(&apos;百度的真是数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 封装的ajax请求方法</span><br><span class="line">  function fetchData(url, callback) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;get&apos;, url, false);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123;</span><br><span class="line">        callback(xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>最后，附上代码，<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99mockjs" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的写一个mockjs&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>wireshark抓包工具</title>
    <link href="/2020/03/09/wireshark%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    <id>/2020/03/09/wireshark抓包工具/</id>
    <published>2020-03-09T07:18:21.000Z</published>
    <updated>2020-03-09T08:11:46.624Z</updated>
    
    <content type="html"><![CDATA[<p>wireshark是一款非常厉害的网络抓包工具<br><a id="more"></a></p><h1 id="wireshark抓包工具"><a href="#wireshark抓包工具" class="headerlink" title="wireshark抓包工具"></a>wireshark抓包工具</h1><p>作为一个前端开发，讨论网络抓包有点不务正业，但是知道点还是有好处的。<br>我平时用到的抓包工具有wireshark和charles，charles使用起来简单些，抓取http请求比较直观，wireshark的功能就强大得多，各种网络协议都可以解析，具体的使用细节就不说了，简单的说一下tcp协议的三次握手和四次挥手在wireshark中被抓取的数据。<br>首先看一下tcp的三次握手和四次挥手图解过程<br>1.三次握手：<br><img src="/2020/03/09/wireshark抓包工具/1.png" alt="img"><br>2.四次挥手：<br><img src="/2020/03/09/wireshark抓包工具/2.png" alt="img"><br>3.最后，wireshark抓取的数据：<br><img src="/2020/03/09/wireshark抓包工具/3.png" alt="img"><br>可以看到，前3个tcp是握手过程，最后4个tcp是挥手过程，中间的TLS协议是加密协议，因为我抓取的是https协议，所以会有加密协议。<br>本想再贴一个http协议的抓取截屏，抓了几次太乱了，还有好多失败的包，不贴了，大同小异，大概了解过程就行了，有精力的话，继续深入研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wireshark是一款非常厉害的网络抓包工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javascript严格模式</title>
    <link href="/2020/02/28/javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/02/28/javascript严格模式/</id>
    <published>2020-02-28T07:05:50.000Z</published>
    <updated>2020-03-01T08:45:34.425Z</updated>
    
    <content type="html"><![CDATA[<p>js的严格模式和普通模式的区别<br><a id="more"></a></p><h1 id="javascript严格模式"><a href="#javascript严格模式" class="headerlink" title="javascript严格模式"></a>javascript严格模式</h1><p>随着javascript的不断发展，严格模式在开发中是必须使用的，他有什么好处呢？<br>严格模式消除了一些不确定的行为，并且对某些不安全的操作抛出异常。它有助于解析引擎，优化代码，提高执行速度，也为以后新标准的制定留出余地。下面将对严格模式做一个详细的介绍。</p><h2 id="1-启用严格模式"><a href="#1-启用严格模式" class="headerlink" title="1.启用严格模式"></a>1.启用严格模式</h2><p>要使一个javascript文件运行于严格模式，只需要在文件顶部添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure></p><p>这行代码是一个编译指示，用以告知解析引擎以严格模式解析脚本。严格模式可以用于整个脚本或单个函数。在用于脚本文件时，”use strict”需放在所有其它语句前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// whole-script strict mode syntax</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var v = &quot;Hi! I&apos;m a strict mode script!&quot;;</span><br></pre></td></tr></table></figure></p><p>而用于函数时，需方在函数内第一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function strict() &#123;</span><br><span class="line">  // Function-level strict mode syntax</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  function nested() &#123;</span><br><span class="line">    return &quot;And so am I!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &quot;Hi! I&apos;m a strict mode function@ &quot; + nested();</span><br><span class="line">&#125;</span><br><span class="line">function notStrict() &#123;</span><br><span class="line">  return &quot;I&apos;m not strict.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-严格模式带来的变化"><a href="#2-严格模式带来的变化" class="headerlink" title="2.严格模式带来的变化"></a>2.严格模式带来的变化</h2><p>在语法和行为这两方面，严格模式都做了一些改变。这些变化主要分为以下几类。</p><ul><li>对错误抛出异常，而不是静默地忽略；</li><li>简化变量的使用，去掉引擎难以优化的语法功能；</li><li>简化eval和arguments的使用；</li><li>增加安全特性；</li><li>为javascript迎接新标准做准备；</li></ul><h3 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h3><p>对错误抛出异常，而不是静默的忽略。严格模式将过去那些能够被静默忽略的错误变成异常抛出，因为这类错误代表着代码目的的矛盾。不一致的代码也许在当时不会产生什么不良后果，但未来可能会引起严重问题。严格模式不会容忍这些错误，使得开发者能够立即发现并且解决。</p><h4 id="1-1"><a href="#1-1" class="headerlink" title="(1)"></a>(1)</h4><p>在正常模式下，对一个没有声明的变量赋值，会自动作用到全局对象上（node的global对象，浏览器的window对象）。严格模式禁止这种做法，以避免意外地修改全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">mistypedVaraible = 17; // ReferenceError</span><br></pre></td></tr></table></figure></p><p>上面的代码将会抛出类型为ReferenceError的异常</p><h4 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h4><p>在正常模式下，引擎会默认忽略对NaN赋值的语句，但在严格模式下，引擎会以抛异常的方式，立即向开发者反馈错误。类似的还有给一个指定为不可写的属性赋值，对只有取值函数getter的属性赋值，给一个不可扩展的对象增加属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">// Assignment to NaN</span><br><span class="line">NaN = &apos;a&apos;; // TypeError: Cannot assign to read noly property &apos;NaN&apos; of #&lt;Object&gt;</span><br><span class="line">// Assignment to a non-writable property</span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj1, &quot;x&quot;, &#123;</span><br><span class="line">  value: 42,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line">obj1.x = 9; // throws a TypeError</span><br><span class="line">// Assignment to a getter-only property</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  get x() &#123;</span><br><span class="line">    return 18;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2.x = 5; // throws a TypeError</span><br><span class="line">// Assignment to a new property on a non-extensible object</span><br><span class="line">var fixed = &#123;&#125;;</span><br><span class="line">Object.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = &quot;ohai&quot;; // throws a TypeError</span><br></pre></td></tr></table></figure></p><h4 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h4><p>严格模式禁止删除一个声明为不可删除的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">delete Object.prototype; // throws a TypeError</span><br></pre></td></tr></table></figure></p><h4 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h4><p>严格模式禁止声明重名属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var o = &#123;</span><br><span class="line">  p: 1,</span><br><span class="line">  p: 2</span><br><span class="line">&#125;; // !!! syntax error</span><br></pre></td></tr></table></figure></p><h4 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h4><p>严格模式规定，函数的参数名必须唯一，否则抛出语法错误。在正常模式下，相同名称的参数，位置最靠后的会把前面的隐藏，但所有参数仍然可以借由arguments[i]访问，因此这种隐藏的意义不大，很可能写错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, a, c) &#123; // syntax error</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  return a + b + c; // wrong if this code ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h4><p>八进制数的写法。ECMAScript 5 标准下的严格模式禁止八进制数，但在ECMAScript 6标准下，八进制数前面需要加0o。Node支持前面加0o的八进制数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">// Right</span><br><span class="line">var a = 0o10; // ES6: Octal</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">// 以下代码异常</span><br><span class="line">// SyntaxError</span><br><span class="line">var sum = 015 + // syntax error</span><br><span class="line">          197 + 142;</span><br></pre></td></tr></table></figure></p><h4 id="7"><a href="#7" class="headerlink" title="(7)"></a>(7)</h4><p>严格模式禁止为基本数据类型添加属性，以下操作非法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  false.true = &quot;&quot;; // TypeError</span><br><span class="line">  (14).sailing = &quot;home&quot;;  // TypeError</span><br><span class="line">  &quot;with&quot;.you = &quot;far away&quot;; // TypeError</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2)"></a>2)</h3><p>简化变量的使用，去掉引擎难以优化的语法功能。</p><h4 id="1-2"><a href="#1-2" class="headerlink" title="(1)"></a>(1)</h4><p>严格模式禁止使用with。with的问题在于，其语句内部的变量名只有在运行的时候才能够被决定，这使得引擎在编译阶段难以生成高效的代码。因为with代码块中的名称即有可能代表语句内部的变量，也有可能是with表达式中的对象属性，还有可能位于代码块外，甚至是全局对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x = 18;</span><br><span class="line">with(obj) &#123; // syntax error</span><br><span class="line">  x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="(2)"></a>(2)</h4><p>严格模式下，eval有单独的作用域，不能够使用eval语句在它之外创建变量。正常模式下，语句<figure class="highlight plain"><figcaption><span>x;")```会为它所在的运行环境声明一个变量x，在严格模式下，x只在eval语句的内部有效。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">var x = 18;</span><br><span class="line">var evalX = eval(&quot;&apos;use strict&apos;; var x = 42; x&quot;);</span><br><span class="line">console.assert(x === 18);</span><br><span class="line">console.assert(evalX === 42);</span><br></pre></td></tr></table></figure></p><h4 id="3-1"><a href="#3-1" class="headerlink" title="(3)"></a>(3)</h4><p>严格模式禁止删除变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x;</span><br><span class="line">delete x;                  // syntax error</span><br><span class="line">eval(&quot;var y; delete y;&quot;);  // syntax error</span><br></pre></td></tr></table></figure></p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3)"></a>3)</h3><p>简化eval和arguments的使用。严格模式将eval和arguments的一些怪异和奇特的用法做了限制，并倾向于将eval和arguments当作关键字处理。</p><h4 id="1-3"><a href="#1-3" class="headerlink" title="(1)"></a>(1)</h4><p>严格模式不允许对eval和arguments赋值。以下语句运行都会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">eval = 18;</span><br><span class="line">arguments++;</span><br><span class="line">++eval;</span><br><span class="line">var obj = &#123; set p(arguments) &#123; &#125; &#125;;</span><br><span class="line">var eval;</span><br><span class="line">try &#123; &#125; catch(arguments) &#123; &#125;</span><br><span class="line">function x(eval) &#123; &#125;</span><br><span class="line">function arguments() &#123; &#125;</span><br><span class="line">var y = function eval() &#123; &#125;;</span><br><span class="line">var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 18;&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="2-3"><a href="#2-3" class="headerlink" title="(2)"></a>(2)</h4><p>在严格模式下，修改函数参数不会影响arguments，下面的示例代码能够正常运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  a = 42;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">var pair = f(18);</span><br><span class="line">console.assert(pair[0] === 42);</span><br><span class="line">console.assert(pair[1] === 18);</span><br></pre></td></tr></table></figure></p><h4 id="3-3"><a href="#3-3" class="headerlink" title="(3)"></a>(3)</h4><p>arguments.callee不能再使用了。正常模式下，arguments.callee返回正在执行的函数本身的引用。在严格模式下，这种用法被禁止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">var f = function() &#123;</span><br><span class="line">  return arguments.callee;</span><br><span class="line">&#125;</span><br><span class="line">f(); // throws a TypeError;</span><br></pre></td></tr></table></figure></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4)"></a>4)</h3><p>增加安全特性。在严格模式下，写出安全的代码变得更容易，引擎不会越俎代庖，除非使用者有意地这样做。</p><h4 id="1-4"><a href="#1-4" class="headerlink" title="(1)"></a>(1)</h4><p>在严格模式下，函数的上下文对象this可以是简单的值，并且避免了对全局对象的引用。在正常模式下，this只是一个对象，例如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(true);</span><br></pre></td></tr></table></figure></p><p>运行结果为[Boolean: true]，引擎会自动地将简单类型打包为对应的对象。单严格模式不会做这样的转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(true);</span><br></pre></td></tr></table></figure></p><p>运行结果为true。<br>正常模式下，如果不指定this对象，或者指定为undefined或null，则this引用的是全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(null);</span><br></pre></td></tr></table></figure></p><p>上面的代码打印出全局的global对象。但在严格模式下，除非使用call或apply明确指定this为global对象，否则this为null或者undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(null);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p><h4 id="2-4"><a href="#2-4" class="headerlink" title="(2)"></a>(2)</h4><p>严格模式禁止访问函数对象属性caller和arguments，这意味着不再可能遍历调用堆栈了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function outer() &#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">function inner() &#123;</span><br><span class="line">  console.log(arguments.callee.caller);</span><br><span class="line">  // TypeError: &apos;caller&apos;, &apos;callee&apos;, and</span><br><span class="line">  // &apos;arguments&apos; properties may not be accessed</span><br><span class="line">  // on strict mode functions or the arguments</span><br><span class="line">  // objects for calls to them</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5)"></a>5)</h3><p>保留关键字。严格模式将implements,interface,let,package,private,protected,public,static和yield作为保留字，用户代码不能以这些名称命名变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function package(protected) &#123; // SyntaxError</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var implements;             // SyntaxError </span><br><span class="line">  interface;                  // SyntaxError</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    break interface;          // SyntaxError</span><br><span class="line">  &#125;</span><br><span class="line">  function private() &#123; &#125;      // SyntaxError</span><br><span class="line">&#125;</span><br><span class="line">function fun(static) &#123;        // SyntaxError</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js的严格模式和普通模式的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>前端异常处理</title>
    <link href="/2020/02/27/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>/2020/02/27/前端异常处理/</id>
    <published>2020-02-27T06:23:25.000Z</published>
    <updated>2020-02-27T14:52:05.707Z</updated>
    
    <content type="html"><![CDATA[<p>异常在前端的处理<br><a id="more"></a></p><h1 id="前端异常处理"><a href="#前端异常处理" class="headerlink" title="前端异常处理"></a>前端异常处理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p><ul><li>增强用户体验；</li><li>远程定位问题；</li><li>未雨绸缪，及早发现问题；</li><li>无法复线问题，尤其是移动端，机型，系统都是问题；</li><li>完善的前端方案，前端监控系统；</li></ul><p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p><ul><li>JS 语法错误、代码异常</li><li>AJAX 请求异常</li><li>静态资源加载异常</li><li>Promise 异常</li><li>Iframe 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p>下面我会针对每种具体情况来说明如何处理这些异常。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。<br>1.同步运行时错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name = &apos;jartto&apos;;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： ReferenceError: nam is not defined</span><br><span class="line">    at index.html:16</span><br></pre></td></tr></table></figure></p><p>2.不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name = &apos;jartto;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</span><br></pre></td></tr></table></figure></p><p>3.异步错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(nam);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: nam is not defined</span><br><span class="line">    at index.html:31</span><br></pre></td></tr></table></figure></p><p>可以看出，try-catch是捕获不到异步错误的，下面会介绍异步的错误如何捕获。</p><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。<br>1.同步错误和异步错误都可以捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// message：错误信息（字符串）。</span><br><span class="line">// source：发生错误的脚本URL（字符串）</span><br><span class="line">// lineno：发生错误的行号（数字）</span><br><span class="line">// colno：发生错误的列号（数字）</span><br><span class="line">// error：Error对象（对象）</span><br><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  return true; // 这里返回true，控制台就不会输出被捕获的那个错误自己抛出的异常提示，见下面截图。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/27/前端异常处理/1.png" alt="img"><br><img src="/2020/02/27/前端异常处理/2.png" alt="img"><br>2.再试试语法错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">let name = &apos;Jartto</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p><p>语法错误还是不能捕获<br>3.我们试试网络请求异常的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;img src=&quot;./jartto.png&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>不论是静态资源异常，或者接口异常，错误都无法捕获到。<br>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx，上面已经有提到过。<br>需要注意：</p><ul><li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li><li>onerror 无法捕获语法错误；<br>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。<h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window，所以我们需要在每一个元素节点上监听error事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var nImgs = document.querySelectorAll(&apos;img&apos;);</span><br><span class="line">  nImgs.forEach(item=&gt; &#123;</span><br><span class="line">    item.addEventListener(&apos;error&apos;, function(ev) &#123;</span><br><span class="line">      console.log(&apos;捕获到异常：&apos;, ev);</span><br><span class="line">    &#125;, false);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>上面是来捕获页面中所有的img元素标签出现的错误。<br>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： Event &#123;isTrusted: true, type: &quot;error&quot;, target: img#img, currentTarget: img#img, eventPhase: 2, …&#125;</span><br></pre></td></tr></table></figure></p><p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。<br>需要注意：</p><ul><li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 addEventListener 重复监听。</li></ul><h3 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h3><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。<br>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。<br>解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;, e);</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br><span class="line">var pro = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  reject(&apos;错误&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// pro.catch(err=&gt; &#123;</span><br><span class="line">//   console.log(&apos;promise catch 捕获：&apos; + err);</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，如果忘记了catch的话，全局也可以捕获到Promise的错误。<br>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： PromiseRejectionEvent &#123;isTrusted: true, promise: Promise, reason: &quot;错误&quot;, type: &quot;unhandledrejection&quot;, target: Window, …&#125;</span><br></pre></td></tr></table></figure></p><p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。<br>补充一点：如果去掉控制台的异常显示，需要加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure></p><h3 id="iframe-异常"><a href="#iframe-异常" class="headerlink" title="iframe 异常"></a>iframe 异常</h3><p>对于 iframe 的异常捕获，我们还得借力 window.onerror<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.frames[0].onerror = function (message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&apos;捕获到 iframe 异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Script-error"><a href="#Script-error" class="headerlink" title="Script error"></a>Script error</h3><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：<br>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://jartto.wang/main.js&quot; crossorigin&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>或者动态去添加 js 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.crossOrigin = &apos;anonymous&apos;;</span><br><span class="line">script.src = url;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p>特别注意，服务器端需要设置：Access-Control-Allow-Origin<br>此外，我们也可以试试这个-解决 Script Error 的另类思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener = function (type, listener, options) &#123;</span><br><span class="line">  const wrappedListener = function (...args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return listener.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (err) &#123;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单解释一下：<br>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">   const originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">   EventTarget.prototype.addEventListener = function (type, listener, options) &#123;</span><br><span class="line">+    // 捕获添加事件时的堆栈</span><br><span class="line">+    const addStack = new Error(`Event ($&#123;type&#125;)`).stack;</span><br><span class="line">     const wrappedListener = function (...args) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         return listener.apply(this, args);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (err) &#123;</span><br><span class="line">+        // 异常发生时，扩展堆栈</span><br><span class="line">+        err.stack += &apos;\n&apos; + addStack;</span><br><span class="line">         throw err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h3><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？<br>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。<br>1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">  sessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;);</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">      sessionStorage.setItem(&apos;time_before_crash&apos;, new Date().toString());</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&apos;beforeunload&apos;, function () &#123;</span><br><span class="line">  sessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if(sessionStorage.getItem(&apos;good_exit&apos;) &amp;&amp;</span><br><span class="line">  sessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) &#123;</span><br><span class="line">  /*</span><br><span class="line">      insert crash logging code here</span><br><span class="line">  */</span><br><span class="line">  alert(&apos;Hey, welcome back from your crash, looks like you crashed on: &apos; + sessionStorage.getItem(&apos;time_before_crash&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控<br>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p><h3 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = (err, vm, info) =&gt; &#123;</span><br><span class="line">  console.error(&apos;通过vue errorHandler捕获的错误&apos;);</span><br><span class="line">  console.error(err);</span><br><span class="line">  console.error(vm);</span><br><span class="line">  console.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h3><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  console.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。<br>需要注意的是：error boundaries 并不会捕捉下面这些错误。</p><ul><li>事件处理器</li><li>异步代码</li><li>服务端的渲染代码</li><li>在 error boundaries 区域内的错误<br>我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    // Display fallback UI</span><br><span class="line">    this.setState(&#123; hasError: true &#125;);</span><br><span class="line">    // You can also log the error to an error reporting service</span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      // You can render any custom fallback UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后我们像使用普通组件那样使用它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure></p><p>componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。<br>实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！</p><h3 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h3><p>通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。<br>动态创建 img 标签的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function report(error) &#123;</span><br><span class="line">  let reportUrl = &apos;http://jartto.wang/report&apos;;</span><br><span class="line">  new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reporter.send = function(data) &#123;</span><br><span class="line">  // 只采集 30%</span><br><span class="line">  if(Math.random() &lt; 0.3) &#123;</span><br><span class="line">    send(data)      // 上报错误信息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p><ul><li>可疑区域增加 Try-Catch</li><li>全局监控 JS 异常 window.onerror</li><li>全局监控静态资源异常 window.addEventListener</li><li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li><li>VUE errorHandler 和 React componentDidCatch</li><li>监控网页崩溃：window 对象的 load 和 beforeunload</li><li>跨域 crossOrigin 解决</li></ul><p>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p>这篇文章部分代码<a href="https://github.com/jinux7/study-collections/tree/master/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常在前端的处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>html元素节点的attribute&amp;property</title>
    <link href="/2020/02/24/html%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84attribute-property/"/>
    <id>/2020/02/24/html元素节点的attribute-property/</id>
    <published>2020-02-24T03:06:49.000Z</published>
    <updated>2020-02-24T04:25:00.112Z</updated>
    
    <content type="html"><![CDATA[<p>元素节点attr和prop区别<br><a id="more"></a></p><h1 id="html元素节点的attribute-amp-property"><a href="#html元素节点的attribute-amp-property" class="headerlink" title="html元素节点的attribute&amp;property"></a>html元素节点的attribute&amp;property</h1><p>元素节点的attrbute和property大家可能都是用过，但是也是容易被大家忽略它俩到底区别在哪里。<br>想当初在使用jquery时,$(‘ele’).attr(),$(‘’ele).prop(),这两个方法我也是没有深入研究，再后来使用angular的时候有看到attribute和property的区别，今天我好好总结一下。</p><h2 id="attribute和property如何使用"><a href="#attribute和property如何使用" class="headerlink" title="attribute和property如何使用"></a>attribute和property如何使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这样一个input节点</span><br><span class="line">&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;</span><br><span class="line">// 首先，使用attribute来操作</span><br><span class="line">var nEle = document.getElementById(&apos;inp&apos;);</span><br><span class="line">nEle.setAttribute(&apos;class&apos;, &apos;wrap&apos;);</span><br><span class="line">nEle.getAttribute(&apos;class&apos;);</span><br><span class="line">// 使用property来操作</span><br><span class="line">nEle.index = 1;</span><br><span class="line">nEle.type = &apos;text&apos;;</span><br></pre></td></tr></table></figure><p>其实，attribute是在这个元素节点上设置属性，而property是在这个元素节点的dom对象上设置属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 想看看元素节点的attribute属性</span><br><span class="line">nEle.attributes</span><br><span class="line">// 想看看元素节点的property属性</span><br><span class="line">console.dir(nEle);</span><br><span class="line">// 打印出来的内容可以看到attributes也在其中</span><br></pre></td></tr></table></figure></p><h2 id="attribute和property实际区别"><a href="#attribute和property实际区别" class="headerlink" title="attribute和property实际区别"></a>attribute和property实际区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;inp&quot; type=&quot;text&quot; value=&quot;val&quot; /&gt;</span><br><span class="line">// 还是这个元素节点</span><br><span class="line">// 页面加载时如果使用getAttribute(&apos;value&apos;)是可以获取&apos;val&apos;值的，当然，nEle.value也可以获取到</span><br><span class="line">   &apos;val&apos;。</span><br><span class="line">// 但是，如果现在你在input框中，把&apos;val&apos;改成&apos;val123&apos;</span><br><span class="line">// 你再使用getAttribute(&apos;value&apos;)方式获取到的还是&apos;val&apos;,而使用nEle.value可以获取到最新值&apos;val123&apos;</span><br><span class="line">// 从这样一个简单的操作，可以理解为，attribute时html元素上的，而property是html元素对象上的。</span><br></pre></td></tr></table></figure><p>其实，两者区别还有很多，这里不一一列举，一个小例子知道其区别就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元素节点attr和prop区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>http请求头的安全策略</title>
    <link href="/2020/02/18/http%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%9A%84%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    <id>/2020/02/18/http请求头的安全策略/</id>
    <published>2020-02-18T07:51:36.000Z</published>
    <updated>2020-02-18T08:56:33.335Z</updated>
    
    <content type="html"><![CDATA[<p>http请求头中相关安全的头字段<br><a id="more"></a></p><h1 id="http请求头的安全策略"><a href="#http请求头的安全策略" class="headerlink" title="http请求头的安全策略"></a>http请求头的安全策略</h1><p>我们的项目在经过开发，测试之后，还得经过安全小组的安全漏斗扫描，经常会暴漏一些返回头缺少安全字段的漏洞，今天我稍加整理常用的几个。<br>如果想了解更多的请求头和响应头的字段信息，可以看本站另一篇文章，<a href="/2019/04/15/http请求头响应头字段详解/">这里</a></p><h2 id="1-X-Frame-Options"><a href="#1-X-Frame-Options" class="headerlink" title="1.X-Frame-Options"></a>1.X-Frame-Options</h2><p>如果网站可以嵌入到IFRAME元素中，则攻击者可以在社交场合设计一种情况，即受害者被指向攻击者控制的网站，该网站构成目标网站的框架。然后攻击者可以操纵受害者在目标网站上不知不觉地执行操作。即使有跨站点请求伪造保护，这种攻击也是可能的，并且被称为“clickjacking”，有关更多信息，<a href="https://www.owasp.org/index.php/Clickjacking" target="_blank" rel="noopener">请参阅</a>。为了避免这种情况，创建了“X-Frame-Options”标题。此标题允许网站所有者决定允许哪些网站构建其网站。<br>通常的建议是将此标头设置为“SAMEORIGIN”，它只允许属于同源策略的资源构成受保护资源的框架，或者设置为“DENY”，它拒绝任何资源（本地或远程）尝试框架也提供“X-Frame-Options”标头的资源。如下所示：<br>X-Frame-Options：SAMEORIGIN<br>请注意，“X-Frame-Options”标题已被弃用，将由内容安全策略中的Frame-Options指令替换，该指令仍处于活动开发阶段。但是，“X-Frame-Options”标题目前具有更广泛的支持，因此仍应实施安全措施。<br>说白了呢，就是让你的网站禁止被嵌套。<br>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;httpProtocol&gt;</span><br><span class="line">  &lt;customHeaders&gt;</span><br><span class="line">    &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt;</span><br><span class="line">  &lt;/customHeaders&gt;</span><br><span class="line">&lt;/httpProtocol&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-Content-Security-Policy"><a href="#2-Content-Security-Policy" class="headerlink" title="2.Content-Security-Policy"></a>2.Content-Security-Policy</h2><p>内容安全策略（CSP）旨在允许Web应用程序的所有者通知客户端浏览器有关应用程序的预期行为（包括内容源，脚本源，插件类型和其他远程资源），这允许浏览器更多智能地执行安全约束。虽然CSP本质上是复杂的，如果没有适当部署它可能会变得混乱，一个应用良好的CSP可以大大降低利用大多数形式的跨站点脚本攻击的机会。<br>需要整个帖子来深入了解CSP允许的功能和不同设置，因此建议进一步阅读。以下是Mozilla开发者网络对CSP的<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP" target="_blank" rel="noopener">精彩介绍性帖子</a><br>下面的简要示例显示了如何使用CSP指定您的网站希望从任何URI加载图像，从受信任的媒体提供商（包括内容分发网络）列表中插入插件内容，以及仅从您控制的服务器加载脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy：default-src&apos;self&apos;; img-src *; object-src media1.example.com media2.example.com * .cdn.example.com; script-src trustedscripts.example.com</span><br></pre></td></tr></table></figure></p><p>请注意，使用CSP的主要问题涉及策略错误配置（即使用“不安全内联”），或使用过于宽松的策略，因此在实施CSP时应特别注意。<br>这个呢，是将你引入的一切，加一个限制，这样如果别人想通过一些手段在你的网站加一些不好的东西，我们就可以有效地防止了。<br>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;httpProtocol&gt;</span><br><span class="line">  &lt;customHeaders&gt;</span><br><span class="line">    &lt;add name=&quot;Content-Security-Policy&quot; value=&quot;script-src &apos;unsafe-inline&apos; http://localhost:56504; object-src &apos;none&apos;; style-src &apos;unsafe-inline&apos; http://localhost:56504;&quot; /&gt;</span><br><span class="line">    &lt;/customHeaders&gt;</span><br><span class="line">  &lt;/httpProtocol&gt;</span><br></pre></td></tr></table></figure></p><p>其中预设值有以下这些：</p><ul><li>none 不匹配任何东西。</li><li>self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。</li><li>unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。</li><li>unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。</li></ul><h1 id="3-X-Content-Type-Options"><a href="#3-X-Content-Type-Options" class="headerlink" title="3.X-Content-Type-Options"></a>3.X-Content-Type-Options</h1><p>互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：”text/html”代表html文档，”image/png”是PNG图片，”text/css”是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。<br>例如，我们即使给一个html文档指定Content-Type为”text/plain”，在IE8-中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。通过下面这个响应头可以禁用浏览器的类型猜测行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure></p><p>demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// php</span><br><span class="line">header(&quot;X-Content-Type-Options:nosniff&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="4-X-XSS-Protection"><a href="#4-X-XSS-Protection" class="headerlink" title="4.X-XSS-Protection"></a>4.X-XSS-Protection</h2><p>顾名思义，这个响应头是用来防范XSS的。最早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置：</p><ul><li>0：禁用XSS保护；</li><li>1：启用XSS保护；</li><li>1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）；<br>浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。<br>demo:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// php</span><br><span class="line">header(&quot;X-XSS-Protection: 1&quot;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http请求头中相关安全的头字段&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图片裁剪插件</title>
    <link href="/2020/02/16/%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E6%8F%92%E4%BB%B6/"/>
    <id>/2020/02/16/图片裁剪插件/</id>
    <published>2020-02-16T07:51:13.000Z</published>
    <updated>2020-02-17T01:33:58.172Z</updated>
    
    <content type="html"><![CDATA[<p>一个图片裁剪插件，并穿给后端<br><a id="more"></a></p><h1 id="图片裁剪插件"><a href="#图片裁剪插件" class="headerlink" title="图片裁剪插件"></a>图片裁剪插件</h1><p>我们在日常开发中，裁剪图片并上传，是经常出现的需求。前几天，就有一个这样的需求，但是要求比较特殊，于是自己写了一个图片裁剪插件，因为自己写的改起来比较灵活。</p><h2 id="其实裁剪图片无非就是"><a href="#其实裁剪图片无非就是" class="headerlink" title="其实裁剪图片无非就是:"></a>其实裁剪图片无非就是:</h2><ul><li>文件选择图片，利用FileReader将文件格式的图片转成base64格式。</li><li>把这个base64格式显示在页面上，作为原图。</li><li>可以在原图的上面弄一个剪裁的方框，可以用鼠标来控制大小并移动，我觉得这里是最难的，需要很强的逻辑能力。</li><li>再利用canvas，以原图为基准，进行画图的裁剪，最后通过canvas方法得到裁剪后的base64格式图片。</li><li>最后把base64格式的图片转成Blob对象，利用ajax传送给后端。</li></ul><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="选择图片文件转base64"><a href="#选择图片文件转base64" class="headerlink" title="选择图片文件转base64"></a>选择图片文件转base64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function file2base64(imgFile, callBack) &#123;</span><br><span class="line">  var fr = new FileReader();</span><br><span class="line">  fr.onload = function() &#123;</span><br><span class="line">    // fr.result就是base64格式数据</span><br><span class="line">    callBack(fr.result);</span><br><span class="line">  &#125;</span><br><span class="line">  fr.readAsDataURL(imgFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将base64图片转化blob"><a href="#将base64图片转化blob" class="headerlink" title="将base64图片转化blob"></a>将base64图片转化blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function base64url2blob(base64url) &#123;</span><br><span class="line">  var binaryString = atob(base64url.split(&apos;,&apos;)[1]),</span><br><span class="line">        mimeType = base64url.split(&apos;,&apos;)[0].match(/:(.*?);/)[1],</span><br><span class="line">        length = binaryString.length,</span><br><span class="line">        u8arr = new Uint8Array(length),</span><br><span class="line">        blob;</span><br><span class="line">    while(length--) &#123;</span><br><span class="line">      u8arr[length] = binaryString.charCodeAt(length);</span><br><span class="line">    &#125;</span><br><span class="line">    blob = new Blob([u8arr.buffer], &#123;type: mimeType&#125;);</span><br><span class="line">    return blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图片转化为blob"><a href="#将图片转化为blob" class="headerlink" title="将图片转化为blob"></a>将图片转化为blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function img2blob(nImg, compressVal) &#123;</span><br><span class="line">  // 获取图片原始宽高</span><br><span class="line">  var cloneImg = nImg.cloneNode(true);</span><br><span class="line">  var nCanvas = document.createElement(&apos;canvas&apos;);</span><br><span class="line">  nCanvas.style.display = &apos;none&apos;;</span><br><span class="line">  document.body.appendChild(nCanvas);</span><br><span class="line">  nCanvas.width = cloneImg.width;</span><br><span class="line">  nCanvas.height = cloneImg.height;</span><br><span class="line">  var ctx = nCanvas.getContext(&quot;2d&quot;);</span><br><span class="line">  ctx.drawImage(nImg,0,0,cloneImg.width,cloneImg.height);</span><br><span class="line">  var base64Data = nCanvas.toDataURL(&quot;image/jpeg&quot;, compressVal);</span><br><span class="line">  var blob = this.base64url2blob(base64Data);</span><br><span class="line">  return blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是几个重要的格式转换方法。<br>最后，贴出源码demo，里边包含后端接收的nodejs代码。<br><a href="https://github.com/jinux7/study-collections/tree/master/image-clipper-upload" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个图片裁剪插件，并穿给后端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="图片处理" scheme="/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手写一个自己的webpack</title>
    <link href="/2020/01/31/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84webpack/"/>
    <id>/2020/01/31/手写一个自己的webpack/</id>
    <published>2020-01-31T07:51:30.000Z</published>
    <updated>2020-01-31T09:24:16.564Z</updated>
    
    <content type="html"><![CDATA[<p>一个超级简化版的webpack打包工具<br><a id="more"></a></p><h1 id="手写一个自己的webpack"><a href="#手写一个自己的webpack" class="headerlink" title="手写一个自己的webpack"></a>手写一个自己的webpack</h1><p>webpack现在用的人非常多，我们在开发vue，react，angular的时候默认的打包工具就是webpack，作为一名前端开发者来说，webpack是现在必须掌握的技能之一。随着webpack版本的不断增加，功能和复杂度越来越高，会配置的话都得学一阵子，但是，抛开使用来说，想没想过它的原理是什么？如果自己写一个该从哪里入手呢，今天我就写一个简化版的webpack。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>简化版的webpack，实现了它的最基础的功能，也就是模块化的引用处理，比如，main.js文件依赖了a.js文件，使用es6的语法import语法，浏览器是不支持的，需要用工具打包成浏览器支持的语法，我就实现这个最基础的功能。</p><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>打包文件，首先需要分析代码，比如，入口文件main.js，分析出import语句，都依赖哪些文件，再去读取这些依赖的文件，而分析js代码就需要babel这个工具库，babel工具库可以将es6代码转换成es5，es3代码，功能特别强大。</p><h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><p>这里，依赖babel的3个工具，分别是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;@babel/core&quot;: &quot;^7.8.3&quot;,</span><br><span class="line">&quot;@babel/parser&quot;: &quot;^7.8.3&quot;,</span><br><span class="line">&quot;@babel/traverse&quot;: &quot;^7.8.3&quot;</span><br></pre></td></tr></table></figure></p><p>parser是用来将js代码解析成ast语法书。<br>traverse可以将ast语法书进行遍历，对相应的ast语法书节点做单独的获取或者处理。<br>babel-core是babel的核心，可以将es6的js代码或ast语法书转化成es5代码。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>用paser将es6的代码先转成ast语法树</p><h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>用traverse处理ast语法书中的import节点，获取依赖文件路径，并获取依赖文件的代码，重复做步骤1，步骤2的处理。</p><h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>用babel-core将获取到的文件全部转成es5语法。</p><h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>最后把这些文件拼接成一个可执行的js代码，保存起来，html直接引用就可以执行了。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>上面步骤都说了，但是还是有点抽象，下面贴出代码，一目了然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const parser = require(&apos;@babel/parser&apos;);</span><br><span class="line">const traverse = require(&apos;@babel/traverse&apos;).default;</span><br><span class="line">const babel = require(&apos;@babel/core&apos;);</span><br><span class="line"></span><br><span class="line">let ID = 0;</span><br><span class="line">function createAsset(fileName) &#123;</span><br><span class="line">  // 这个文件里所依赖的其它文件路径</span><br><span class="line">  let dependencies = [];</span><br><span class="line">  const content = fs.readFileSync(fileName, &apos;utf8&apos;);</span><br><span class="line">  // 用babel的parser来解析读取的的文件内容content,获取ast抽象语法书</span><br><span class="line">  const ast = parser.parse(content, &#123;</span><br><span class="line">    sourceType: &apos;module&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 用babel的traverse功能来观察ast语法树的相应节点，进行相应的处理</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration(&#123; node &#125;) &#123;</span><br><span class="line">      // console.log(node.source.value);</span><br><span class="line">      dependencies.push(node.source.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 用babel来讲es6语法转成es5语法</span><br><span class="line">  const &#123; code &#125; = babel.transformFromAstSync(ast, null, &#123;</span><br><span class="line">    presets: [&apos;@babel/preset-env&apos;]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  let id = ID++;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    id,</span><br><span class="line">    fileName,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createGraph() &#123;</span><br><span class="line">  const mainAsset = createAsset(&apos;./src/main.js&apos;);</span><br><span class="line">  // 队列存放单个文件资源,这里利用循环队列去搜寻依赖文件，而没有使用递归方法</span><br><span class="line">  const queue = [ mainAsset ];</span><br><span class="line">  for(const asset of queue) &#123;</span><br><span class="line">    const dirname = path.dirname(asset.fileName);</span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line">    asset.dependencies.forEach(relativePath =&gt; &#123;</span><br><span class="line">      const absolutePath = path.join(dirname, relativePath);</span><br><span class="line">      const child = createAsset(absolutePath);</span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return queue;</span><br><span class="line">&#125;</span><br><span class="line">// 打包生成处理后的js文件</span><br><span class="line">function bundle() &#123;</span><br><span class="line">  const graph = createGraph(&apos;./src/main.js&apos;);</span><br><span class="line">  let modules = ``;</span><br><span class="line">  graph.forEach(mod=&gt; &#123;</span><br><span class="line">    modules += `</span><br><span class="line">      $&#123;mod.id&#125;: [</span><br><span class="line">        function(require, module, exports) &#123;</span><br><span class="line">          $&#123;mod.code&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        $&#123;JSON.stringify(mod.mapping)&#125;</span><br><span class="line">      ],</span><br><span class="line">    `;</span><br><span class="line">  &#125;);</span><br><span class="line">  const result = `(function(modules) &#123;</span><br><span class="line">    function require(id) &#123;</span><br><span class="line">      const fn = modules[id][0],</span><br><span class="line">            mapping = modules[id][1];</span><br><span class="line">      function localRequire(relativePath) &#123;</span><br><span class="line">        return require(mapping[relativePath]);</span><br><span class="line">      &#125;</span><br><span class="line">      const module = &#123;</span><br><span class="line">        exports: &#123;&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn(localRequire, module, module.exports);</span><br><span class="line">      return module.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    require(0);</span><br><span class="line">  &#125;)(&#123;$&#123;modules&#125;&#125;)`;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = bundle();</span><br><span class="line">fs.writeFileSync(&apos;./dist/bundle.js&apos;, result);</span><br></pre></td></tr></table></figure></p><h2 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99webpack/nux-webpack" target="_blank" rel="noopener">截这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个超级简化版的webpack打包工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>简单的聊聊iframe</title>
    <link href="/2020/01/19/%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E8%81%8Aiframe/"/>
    <id>/2020/01/19/简单的聊聊iframe/</id>
    <published>2020-01-19T06:11:04.000Z</published>
    <updated>2020-01-19T06:41:47.197Z</updated>
    
    <content type="html"><![CDATA[<p>iframe在html中的简单使用<br><a id="more"></a></p><h1 id="简单的聊聊iframe"><a href="#简单的聊聊iframe" class="headerlink" title="简单的聊聊iframe"></a>简单的聊聊iframe</h1><p>我们在前端开发中，iframe的使用场景很多，即便是vue，react时代，我还是乐此不疲的在项目中使用iframe，因为它会隔离页面彼此的环境，避免造成一些不必要的干扰。</p><h2 id="在同域下使用iframe"><a href="#在同域下使用iframe" class="headerlink" title="在同域下使用iframe"></a>在同域下使用iframe</h2><p>在同域下使用iframe,父级页面可以获取iframe页面里的信息，还可以操作iframe页面中的内容。<br><a href="https://github.com/jinux7/study-collections/tree/master/iframe/same-origin" target="_blank" rel="noopener">案例</a><br>在同域下没什么好说的，父页面可以随意控制子页面。</p><h2 id="跨域下使用iframe"><a href="#跨域下使用iframe" class="headerlink" title="跨域下使用iframe"></a>跨域下使用iframe</h2><p>跨域下使用iframe,父页面是不能操作子页面的，但是子页面可以操作父页面。<br>而且，后台返回的头信息，还能够更加严格的控制iframe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;DENY&apos;); // 不允许此页面被iframe加载</span><br><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;SAMEORIGIN&apos;); // 只可以在相同域名下加载</span><br><span class="line">res.setHeader(&apos;X-Frame-Options&apos;, &apos;allow-from http://baidu.com/&apos;); // 允许指定的url加载iframe,但是这个属性在chrome,firefox,opera并不好使,只在edge中兼容</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/jinux7/study-collections/tree/master/iframe/cross-origin" target="_blank" rel="noopener">案例</a><br>目前为止，没有找到跨域控制iframe页面内容的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iframe在html中的简单使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="html" scheme="/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构的JavaScript实现</title>
    <link href="/2019/11/28/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/"/>
    <id>/2019/11/28/常用数据结构的JavaScript实现/</id>
    <published>2019-11-28T08:12:54.000Z</published>
    <updated>2019-11-28T08:16:47.245Z</updated>
    
    <content type="html"><![CDATA[<p>一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现<br><a id="more"></a></p><h1 id="常用数据结构的JavaScript实现"><a href="#常用数据结构的JavaScript实现" class="headerlink" title="常用数据结构的JavaScript实现"></a>常用数据结构的JavaScript实现</h1><p>觉得这篇文章很不错，收藏下来，感谢作者。<br><a href="https://mp.weixin.qq.com/s/04PFD6dHhUjdh7wpT33UMQ" target="_blank" rel="noopener">这里是连接哦</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些传统的数据结构,如栈,队列,链表,哈希表,树在js中如何的实现&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux的常用操作</title>
    <link href="/2019/11/28/linux%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>/2019/11/28/linux的常用操作/</id>
    <published>2019-11-28T01:46:55.000Z</published>
    <updated>2020-02-04T01:52:10.250Z</updated>
    
    <content type="html"><![CDATA[<p>linux的一些基础常用操作<br><a id="more"></a></p><h1 id="linux的常用操作"><a href="#linux的常用操作" class="headerlink" title="linux的常用操作"></a>linux的常用操作</h1><h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><p>在linux下安装应用的方法有很多，我也尝试了好几种，最后感觉还是用yum安装方便。<br>在使用yum安装应用的时候需要配置一下yum源，这里写出两条命令，常用的应用软件都已经有了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -O http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="文件的移动"><a href="#文件的移动" class="headerlink" title="文件的移动"></a>文件的移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将repo结尾的文件移动到当前目录的back文件夹下</span><br><span class="line">mv *.repo ./back</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、删除文件命令</span><br><span class="line">rm -f 文件名</span><br><span class="line">将会强行删除文件，且无提示</span><br><span class="line">需要注意：</span><br><span class="line">使用rm -rf要格外注意，linux中没有回收站，慎重删除</span><br><span class="line">2、删除文件夹以及文件夹中的所有文件命令：</span><br><span class="line">rm -rf 目录名字</span><br><span class="line">其中：</span><br><span class="line">-r：向下递归删除</span><br><span class="line">-f：直接强行删除，且没有任何提示</span><br></pre></td></tr></table></figure><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep node</span><br></pre></td></tr></table></figure><h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><h3 id="搜索一个程序所在位置"><a href="#搜索一个程序所在位置" class="headerlink" title="搜索一个程序所在位置"></a>搜索一个程序所在位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">whereis &lt;程序名称&gt;</span><br><span class="line">查找软件的安装路径</span><br><span class="line">-b 只查找二进制文件</span><br><span class="line">-m 只查找帮助文件</span><br><span class="line">-s 只查找源代码</span><br><span class="line">-u 排除指定类型文件</span><br><span class="line">-f 只显示文件名</span><br><span class="line">-B &lt;目录&gt; 在指定目录下查找二进制文件</span><br><span class="line">-M &lt;目录&gt; 在指定目录下查找帮助文件</span><br><span class="line">-S &lt;目录&gt; 在指定目录下查找源代码</span><br></pre></td></tr></table></figure><h3 id="查找一个文件夹所在目录"><a href="#查找一个文件夹所在目录" class="headerlink" title="查找一个文件夹所在目录"></a>查找一个文件夹所在目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &lt;文件名&gt;</span><br></pre></td></tr></table></figure><h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><p>使用之前确保安装了lrzsz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lrzsz</span><br></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><h3 id="开启nginx服务"><a href="#开启nginx服务" class="headerlink" title="开启nginx服务"></a>开启nginx服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf.default</span><br><span class="line">// 以我的nginx安装目录为例，nginx.conf.default这个文件就是nginx的主默认配置文件</span><br></pre></td></tr></table></figure><h2 id="压缩和解压zip"><a href="#压缩和解压zip" class="headerlink" title="压缩和解压zip"></a>压缩和解压zip</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装zip</span><br><span class="line">yum install zip</span><br><span class="line">// 安装unzip</span><br><span class="line">yum install unzip</span><br></pre></td></tr></table></figure><h3 id="使用zip"><a href="#使用zip" class="headerlink" title="使用zip"></a>使用zip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：</span><br><span class="line">zip -q -r html.zip /home/html</span><br><span class="line">// 如果在我们在 /home/html 目录下，可以执行以下命令：</span><br><span class="line">zip -q -r html.zip *</span><br></pre></td></tr></table></figure><h3 id="使用unzip"><a href="#使用unzip" class="headerlink" title="使用unzip"></a>使用unzip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 它会默认将文件解压到当前目录 </span><br><span class="line"># unzip test.zip </span><br><span class="line">// 如果要解压到指定目录，可以加上 -d 选项</span><br><span class="line"># unzip test.zip -d /root/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的一些基础常用操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>chrome浏览器设置可跨域</title>
    <link href="/2019/11/20/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%8F%AF%E8%B7%A8%E5%9F%9F/"/>
    <id>/2019/11/20/chrome浏览器设置可跨域/</id>
    <published>2019-11-20T07:39:35.000Z</published>
    <updated>2019-11-20T08:02:01.960Z</updated>
    
    <content type="html"><![CDATA[<p>chrome浏览器设置可跨域<br><a id="more"></a></p><h1 id="chrome浏览器设置可跨域"><a href="#chrome浏览器设置可跨域" class="headerlink" title="chrome浏览器设置可跨域"></a>chrome浏览器设置可跨域</h1><p>跨域方法很多种，我比较喜欢简单粗暴的修改chrome配置<br>1.先chrome鼠标右键打开下，点击打开属性，出现下面这幅图<br><img src="/2019/11/20/chrome浏览器设置可跨域/1.png" alt="img"><br>2.将下面的这段粘贴在目标的字符串的后面，注意要隔着一个空格<br>chrome版本49之前：–disable-web-security<br>chrome版本49之后：open -a Google\ Chrome –args –disable-web-security –user-data-dir</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;chrome浏览器设置可跨域&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>css初始化</title>
    <link href="/2019/10/30/css%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>/2019/10/30/css初始化/</id>
    <published>2019-10-30T08:16:54.000Z</published>
    <updated>2019-10-30T08:31:54.672Z</updated>
    
    <content type="html"><![CDATA[<p>css的初始化设计<br><a id="more"></a></p><h1 id="css初始化"><a href="#css初始化" class="headerlink" title="css初始化"></a>css初始化</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">charset</span> <span class="string">"utf-8"</span>;<span class="selector-tag">html</span>&#123;<span class="attribute">background-color</span>:<span class="number">#fff</span>;<span class="attribute">color</span>:<span class="number">#000</span>;<span class="attribute">font-size</span>:<span class="number">12px</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">legend</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">xmp</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">xmp</span>,<span class="selector-tag">tt</span>,<span class="selector-tag">code</span>,<span class="selector-tag">kbd</span>,<span class="selector-tag">samp</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5</span>;<span class="attribute">font-family</span>:tahoma,arial,<span class="string">"Hiragino Sans GB"</span>,simsun,sans-serif&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">small</span>,<span class="selector-tag">big</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">font-size</span>:<span class="number">100%</span>&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">font-family</span>:tahoma,arial,<span class="string">"Hiragino Sans GB"</span>,<span class="string">"微软雅黑"</span>,simsun,sans-serif&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">b</span>,<span class="selector-tag">strong</span>&#123;<span class="attribute">font-weight</span>:normal&#125;</span><br><span class="line"><span class="selector-tag">address</span>,<span class="selector-tag">cite</span>,<span class="selector-tag">dfn</span>,<span class="selector-tag">em</span>,<span class="selector-tag">i</span>,<span class="selector-tag">optgroup</span>,<span class="selector-tag">var</span>&#123;<span class="attribute">font-style</span>:normal&#125;</span><br><span class="line"><span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;<span class="attribute">border-spacing</span>:<span class="number">0</span>;<span class="attribute">text-align</span>:left&#125;</span><br><span class="line"><span class="selector-tag">caption</span>,<span class="selector-tag">th</span>&#123;<span class="attribute">text-align</span>:inherit&#125;</span><br><span class="line"><span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">menu</span>&#123;<span class="attribute">list-style</span>:none&#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>,<span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">object</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">vertical-align</span>:middle&#125;</span><br><span class="line"><span class="selector-tag">article</span>,<span class="selector-tag">aside</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">figcaption</span>,<span class="selector-tag">hgroup</span>,<span class="selector-tag">details</span>,<span class="selector-tag">menu</span>&#123;<span class="attribute">display</span>:block&#125;</span><br><span class="line">audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>,<span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,<span class="selector-tag">q</span><span class="selector-pseudo">:before</span>,<span class="selector-tag">q</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>:<span class="string">"\0020"</span>&#125;</span><br><span class="line"><span class="selector-tag">textarea</span>&#123;<span class="attribute">overflow</span>:auto;<span class="attribute">resize</span>:vertical&#125;</span><br><span class="line"><span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">button</span>,<span class="selector-tag">select</span>,<span class="selector-tag">a</span>&#123;<span class="attribute">outline</span>:<span class="number">0</span> none;<span class="attribute">border</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::-moz-focus-inner</span>,<span class="selector-tag">input</span><span class="selector-pseudo">::-moz-focus-inner</span>&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">mark</span>&#123;<span class="attribute">background-color</span>:transparent&#125;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">ins</span>,<span class="selector-tag">s</span>,<span class="selector-tag">u</span>,<span class="selector-tag">del</span>&#123;<span class="attribute">text-decoration</span>:none&#125;</span><br><span class="line"><span class="selector-tag">sup</span>,<span class="selector-tag">sub</span>&#123;<span class="attribute">vertical-align</span>:baseline&#125;</span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">overflow-x</span>: hidden;<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">font-size</span>: <span class="number">50px</span>;<span class="attribute">-webkit-tap-highlight-color</span>: transparent;&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: Arial, <span class="string">"Microsoft Yahei"</span>, <span class="string">"Helvetica Neue"</span>, Helvetica, sans-serif;<span class="attribute">color</span>: <span class="number">#333</span>;<span class="attribute">font-size</span>: .<span class="number">28em</span>;<span class="attribute">line-height</span>: <span class="number">1</span>;<span class="attribute">-webkit-text-size-adjust</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">hr</span> &#123;<span class="attribute">height</span>: .<span class="number">02rem</span>;<span class="attribute">margin</span>: .<span class="number">1rem</span> <span class="number">0</span>;<span class="attribute">border</span>: medium none;<span class="attribute">border-top</span>: .<span class="number">02rem</span> solid <span class="number">#cacaca</span>;&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="number">#25a4bb</span>;<span class="attribute">text-decoration</span>: none;&#125;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">input</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;<span class="comment">/*屏蔽阴影*/</span></span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(0,0,0,0);</span><br><span class="line">    <span class="comment">/*ios android去除自带阴影的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止长按链接与图片弹出菜单 */</span></span><br><span class="line">    <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止选中文本(如无文本选中需求,此为必选项) */</span></span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;  </span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">-webkit-overflow-scrolling: touch; // ios滑动不卡顿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css的初始化设计&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="样式" scheme="/tags/%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
</feed>
