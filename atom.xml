<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2025-07-01T08:19:28.600Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>下载M3U8格式视频</title>
    <link href="/2025/07/01/%E4%B8%8B%E8%BD%BDM3U8%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91/"/>
    <id>/2025/07/01/下载M3U8格式视频/</id>
    <published>2025-07-01T06:42:45.000Z</published>
    <updated>2025-07-01T08:19:28.600Z</updated>
    
    <content type="html"><![CDATA[<p>使用nodejs下载M3U8格式视频<br><a id="more"></a></p><h2 id="M3U8格式视频播放"><a href="#M3U8格式视频播放" class="headerlink" title="M3U8格式视频播放"></a>M3U8格式视频播放</h2><p>如何播放M3U8格式视频请参考<a href="https://jinux.top/2024/04/19/web%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">这里</a></p><h2 id="M3U8格式视频下载"><a href="#M3U8格式视频下载" class="headerlink" title="M3U8格式视频下载"></a>M3U8格式视频下载</h2><h3 id="解析M3U8文件"><a href="#解析M3U8文件" class="headerlink" title="解析M3U8文件"></a>解析M3U8文件</h3><p>使用<code>m3u8-parser</code>这个库解析。<br>解析后可以得到一个数组，里边有下载ts格式文件的链接等信息。</p><h3 id="下载ts文件"><a href="#下载ts文件" class="headerlink" title="下载ts文件"></a>下载ts文件</h3><p>下载ts文件可以使用<code>axios</code>这个库。<br>为了提高下载速度，可以并行下载多个ts文件，也就是同时使用axios发起多个请求。<br>这里注意一下，同时发起请求的时候别使用<code>Promise.all</code>这个函数，因为<code>Promise.all</code>这个函数等待所有请求成功后执行回调，但是一般一个视频会包含上百个ts文件，好多请求会失败，所以这里使用了<code>Promise.allSettled</code>函数，这个函数等待所有请求都执行完毕，并且执行结果会标注成功或者失败，利用这个特性可以制作<code>fileList.txt</code>文件，后续<code>ffmpeg</code>利用这个文件将ts文件合并成mp4文件。</p><h3 id="创建fileList-txt文件"><a href="#创建fileList-txt文件" class="headerlink" title="创建fileList.txt文件"></a>创建fileList.txt文件</h3><p>fileList.txt文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file qThMvh4b.ts</span><br><span class="line">file JYFQD1Ml.ts</span><br><span class="line">file UxTCj4Lz.ts</span><br><span class="line">file fLEDwwSM.ts</span><br><span class="line">file fbA1SzC5.ts</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="合并ts文件转成mp4"><a href="#合并ts文件转成mp4" class="headerlink" title="合并ts文件转成mp4"></a>合并ts文件转成mp4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg()</span><br><span class="line">.input(path.resolve(TEMPFOLDER, &apos;fileList.txt&apos;))</span><br><span class="line">.inputFormat(&apos;concat&apos;)</span><br><span class="line">.videoCodec(&apos;copy&apos;)</span><br><span class="line">.audioCodec(&apos;copy&apos;)</span><br><span class="line">.format(&apos;mp4&apos;)</span><br><span class="line">.save(path.resolve(&apos;./&apos;, OUTPUTFILENAME));</span><br></pre></td></tr></table></figure><p>这里需要注意，<code>fluent-ffmpeg</code>是nodejs下方便调用ffmpeg的库，所以必须事先在电脑中已经安装好ffmpeg，并且<code>ffmpeg</code>的安装目录必须添加到环境变量中。</p><h3 id="清除ts文件"><a href="#清除ts文件" class="headerlink" title="清除ts文件"></a>清除ts文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.rm(folderPath, &#123; recursive: true, force: true &#125;, (err) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">      throw err;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`$&#123;folderPath&#125; 已被删除`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/video%E8%A7%86%E9%A2%91/%E4%B8%8B%E8%BD%BDm3u8%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91" target="_blank" rel="noopener">代码链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用nodejs下载M3U8格式视频&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>uniapp开发纪要</title>
    <link href="/2025/06/09/uniapp%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/"/>
    <id>/2025/06/09/uniapp开发纪要/</id>
    <published>2025-06-09T07:17:23.000Z</published>
    <updated>2025-06-09T07:47:18.477Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些uniapp开发中遇到的问题和解决技巧<br><a id="more"></a></p><h2 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h2><blockquote><p>手机：荣耀200<br>  系统：MagicOs 9.0<br>  HBuilderX版本：</p></blockquote><ul><li>HBuilderX的工具—&gt;设置—&gt;运行配置—&gt;adb路径，换成HBuilderX目录下plugins/launcher-tools/tools/adbs/1.0.36/adb.exe</li><li>设置—&gt;系统和更新—&gt;开发人员选项【USB调试】打开</li><li>设置—&gt;系统和更新—&gt;开发人员选项【“仅充电”模式下允许ADB调试】打开</li><li>设置—&gt;系统和更新—&gt;开发人员选项【选择USB配置】RNDIS(USB以太网)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些uniapp开发中遇到的问题和解决技巧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="uniapp" scheme="/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js实战之Py与Js模型互转</title>
    <link href="/2025/06/04/Tensorflow-js%E5%AE%9E%E6%88%98%E4%B9%8BPy%E4%B8%8EJs%E6%A8%A1%E5%9E%8B%E4%BA%92%E8%BD%AC/"/>
    <id>/2025/06/04/Tensorflow-js实战之Py与Js模型互转/</id>
    <published>2025-06-04T06:31:13.000Z</published>
    <updated>2025-06-05T05:04:44.641Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js-Py与Js模型互转<br><a id="more"></a></p><h2 id="Python模型"><a href="#Python模型" class="headerlink" title="Python模型"></a>Python模型</h2><p>通过Python版本的Tensorflow/Keras生成的模型。<br>包括：Tensorflow Saved Model、Keras HDF5 Model等</p><h2 id="Javascript模型"><a href="#Javascript模型" class="headerlink" title="Javascript模型"></a>Javascript模型</h2><p>可以在Tensorflow.js中运行的模型。<br>包括：tfjs_layers_model、tfjs_graph_model等</p><h2 id="模型互转"><a href="#模型互转" class="headerlink" title="模型互转"></a>模型互转</h2><h3 id="Py模型转Js模型"><a href="#Py模型转Js模型" class="headerlink" title="Py模型转Js模型"></a>Py模型转Js模型</h3><p>使用<a href="https://github.com/tensorflow/tfjs/tree/master/tfjs-converter" target="_blank" rel="noopener">Tensorflow.js-converter</a>工具转换</p><h4 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h4><p>使用conda创建一个Python环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name tfjs python=3.6.8</span><br></pre></td></tr></table></figure></p><h4 id="安装Tensorflow-js-converter包"><a href="#安装Tensorflow-js-converter包" class="headerlink" title="安装Tensorflow.js-converter包"></a>安装Tensorflow.js-converter包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflowjs==2.8.4 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h4 id="转换模型"><a href="#转换模型" class="headerlink" title="转换模型"></a>转换模型</h4><h5 id="tf-saved-model-gt-tfjs-graph-model"><a href="#tf-saved-model-gt-tfjs-graph-model" class="headerlink" title="tf_saved_model-&gt;tfjs_graph_model"></a>tf_saved_model-&gt;tfjs_graph_model</h5><p><a href="https://www.kaggle.com/models/google/mobilenet-v2" target="_blank" rel="noopener">下载tf_saved_model模型</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 转换命令</span><br><span class="line">tensorflowjs_converter --input_format=tf_saved_model --output_format=tfjs_graph_model --signature_name=serving_default --saved_model_tags=serve D:\jinux\github\tensorflow.js-tutorial\code\Py与Js模型互转\source\model\Py\saveModel D:\jinux\github\tensorflow.js-tutorial\code\Py与Js模型互转\source\model\Js\graphModel</span><br></pre></td></tr></table></figure></p><p>见<code>source/example</code>目录下引用转换后模型的案例。</p><blockquote><p>目前其他格式转换报错，还在研究中……</p></blockquote><h3 id="Js模型转Py模型"><a href="#Js模型转Py模型" class="headerlink" title="Js模型转Py模型"></a>Js模型转Py模型</h3><p>很少会用到这种转换</p><h3 id="Js模型转jS模型"><a href="#Js模型转jS模型" class="headerlink" title="Js模型转jS模型"></a>Js模型转jS模型</h3><p>分片、量化、加速</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/Py%E4%B8%8EJs%E6%A8%A1%E5%9E%8B%E4%BA%92%E8%BD%AC/source" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js-Py与Js模型互转&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js实战之预训练模型使用</title>
    <link href="/2025/06/04/Tensorflow-js%E5%AE%9E%E6%88%98%E4%B9%8B%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/"/>
    <id>/2025/06/04/Tensorflow-js实战之预训练模型使用/</id>
    <published>2025-06-04T06:29:07.000Z</published>
    <updated>2025-06-05T05:00:33.627Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js使用预训练模型<br><a id="more"></a><br>这里列举了一些利用Tensorflow.js框架使用预训练模型的例子。</p><h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/图像分类.gif" alt="图像分类"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="视频识物"><a href="#视频识物" class="headerlink" title="视频识物"></a>视频识物</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/视频识物.gif" alt="视频识物"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E8%A7%86%E9%A2%91%E8%AF%86%E7%89%A9/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/语音识别.gif" alt="语音识别"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="面部定位"><a href="#面部定位" class="headerlink" title="面部定位"></a>面部定位</h2><p><img src="/2025/06/04/Tensorflow-js实战之预训练模型使用/面部定位.gif" alt="面部定位"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B/%E9%9D%A2%E9%83%A8%E5%AE%9A%E4%BD%8D/source" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js使用预训练模型&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js实战之训练模型</title>
    <link href="/2025/06/04/Tensorflow-js%E5%AE%9E%E6%88%98%E4%B9%8B%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <id>/2025/06/04/Tensorflow-js实战之训练模型/</id>
    <published>2025-06-04T06:27:48.000Z</published>
    <updated>2025-06-05T01:34:13.752Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js自己训练模型<br><a id="more"></a><br>这里列举了一些从头开始利用Tensorflow.js框架训练模型的例子。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/线性回归.gif" alt="线性回归"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="线性回归归一化"><a href="#线性回归归一化" class="headerlink" title="线性回归归一化"></a>线性回归归一化</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/线性回归归一化.gif" alt="线性回归归一化"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%BD%92%E4%B8%80%E5%8C%96/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/逻辑回归.gif" alt="逻辑回归"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="多层神经网络XOR"><a href="#多层神经网络XOR" class="headerlink" title="多层神经网络XOR"></a>多层神经网络XOR</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/多层神经网络XOR.gif" alt="多层神经网络XOR"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CXOR/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/多分类.gif" alt="多分类"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E5%A4%9A%E5%88%86%E7%B1%BB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/手写数字识别.gif" alt="手写数字识别"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="迁移学习-图像分类"><a href="#迁移学习-图像分类" class="headerlink" title="迁移学习-图像分类"></a>迁移学习-图像分类</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/迁移学习-图像分类.gif" alt="迁移学习-图像分类"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/source" target="_blank" rel="noopener">Source Code</a></p><h2 id="迁移学习-语音识别"><a href="#迁移学习-语音识别" class="headerlink" title="迁移学习-语音识别"></a>迁移学习-语音识别</h2><p><img src="/2025/06/04/Tensorflow-js实战之训练模型/迁移学习-语音识别.gif" alt="迁移学习-语音识别"><br><a href="https://github.com/jinux7/tensorflow.js-tutorial/tree/main/code/%E8%AE%AD%E7%BB%83%E6%A1%88%E4%BE%8B/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js自己训练模型&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js入门</title>
    <link href="/2025/06/04/Tensorflow-js%E5%85%A5%E9%97%A8/"/>
    <id>/2025/06/04/Tensorflow-js入门/</id>
    <published>2025-06-04T06:25:15.000Z</published>
    <updated>2025-06-04T06:50:06.357Z</updated>
    
    <content type="html"><![CDATA[<p>Tensorflow.js简单入门教程<br><a id="more"></a></p><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><h3 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h3><ul><li>机器学习是对能通过经验自动改进的计算机算法的研究。</li><li>机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。</li></ul><h3 id="机器学习如何运作？"><a href="#机器学习如何运作？" class="headerlink" title="机器学习如何运作？"></a>机器学习如何运作？</h3><ul><li>神经网络。</li><li>决策树，支持向量机，贝叶斯分类器，强化学习等。</li></ul><h3 id="什么是神经网络？"><a href="#什么是神经网络？" class="headerlink" title="什么是神经网络？"></a>什么是神经网络？</h3><ul><li>神经网络指的是人工神经网络</li><li>人工神经网络是一种运算模型（就是输入输出的映射），由大量的节点（或称神经元）之间相互联接构成。</li></ul><h3 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h3><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><ul><li>给大量输入和输出，算出神经网络里所有神经元的权重，偏置，然后给定新的输入，可以算出新的输出。</li><li>在机器学习里输入输出被称为特征和标签，大量输入输出被称为训练集。</li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul><li>初始化：随机生成一些权重和偏置。</li><li>计算损失：给定特征，计算出标签，得到它与真实标签差得多远。</li><li>优化：微调权重和偏置，使损失变小。</li></ul><h4 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h4><ul><li>使用损失函数</li><li>损失函数有均方误差，对数损失，交叉熵等。</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>使用优化器</li><li>优化器有随机梯度下降（SGD），Adam等。</li></ul><h2 id="Tensorflow-js基础"><a href="#Tensorflow-js基础" class="headerlink" title="Tensorflow.js基础"></a>Tensorflow.js基础</h2><h3 id="Tensorflow-js是什么？"><a href="#Tensorflow-js是什么？" class="headerlink" title="Tensorflow.js是什么？"></a>Tensorflow.js是什么？</h3><ul><li>一个用javascript实现的机器学习库。</li><li>可以直接在浏览器和Node.js中使用机器学习技术。</li></ul><h3 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h3><ul><li>运行现有模型。</li><li>重新训练现有模型。</li><li>使用javascript从0开发机器学习模型。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="在浏览器中安装"><a href="#在浏览器中安装" class="headerlink" title="在浏览器中安装"></a>在浏览器中安装</h4><p>使用script标签引入TensorFlow.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;!-- Load TensorFlow.js --&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Place your code in the script tag below. You can also use an external .js file --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // Notice there is no &apos;import&apos; statement. &apos;tf&apos; is available on the index-page</span><br><span class="line">      // because of the script tag above.</span><br><span class="line"></span><br><span class="line">      // Define a model for linear regression.</span><br><span class="line">      const model = tf.sequential();</span><br><span class="line">      model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));</span><br><span class="line"></span><br><span class="line">      // Prepare the model for training: Specify the loss and the optimizer.</span><br><span class="line">      model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);</span><br><span class="line"></span><br><span class="line">      // Generate some synthetic data for training.</span><br><span class="line">      const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);</span><br><span class="line">      const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);</span><br><span class="line"></span><br><span class="line">      // Train the model using the data.</span><br><span class="line">      model.fit(xs, ys).then(() =&gt; &#123;</span><br><span class="line">        // Use the model to do inference on a data point the model hasn&apos;t seen before:</span><br><span class="line">        // Open the browser devtools to see the output</span><br><span class="line">        model.predict(tf.tensor2d([5], [1, 1])).print();</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>使用NPM包安装，并使用Parcel，Webpack，vite等构建工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import * as tf from &apos;@tensorflow/tfjs&apos;;</span><br><span class="line"></span><br><span class="line">//定义一个线性回归模型。</span><br><span class="line">const model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123;units: 1, inputShape: [1]&#125;));</span><br><span class="line"></span><br><span class="line">model.compile(&#123;loss: &apos;meanSquaredError&apos;, optimizer: &apos;sgd&apos;&#125;);</span><br><span class="line"></span><br><span class="line">// 为训练生成一些合成数据</span><br><span class="line">const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);</span><br><span class="line">const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);</span><br><span class="line"></span><br><span class="line">// 使用数据训练模型</span><br><span class="line">model.fit(xs, ys, &#123;epochs: 10&#125;).then(() =&gt; &#123;</span><br><span class="line">  // 在该模型从未看到过的数据点上使用模型进行推理</span><br><span class="line">  model.predict(tf.tensor2d([5], [1, 1])).print();</span><br><span class="line">  //  打开浏览器开发工具查看输出</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="在Node-js中安装"><a href="#在Node-js中安装" class="headerlink" title="在Node.js中安装"></a>在Node.js中安装</h4><p>安装带有原生C++绑定的TensorFlow.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs-node</span><br><span class="line">或</span><br><span class="line">npm install @tensorflow/tfjs-node-gpu</span><br></pre></td></tr></table></figure></p><ul><li>安装纯javascript版本，这个性能比较慢。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure></li></ul><h3 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量(Tensor)"></a>张量(Tensor)</h3><p>TensorFlow.js中数据的中心单位是张量：一组数值形成一个或多个维度的数组。 张量实例具有定义数组形状的形状属性。<br>Tensorflow.js中数据的主要表现形式就是tensor（张量）：由 一组数值形成一维或多维数组。一个Tensor实例有一个shape属性来定义这一组数值如何组成张量,而最主要的Tensor实例的构造函数就是 tf.tensor 函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 2x3 Tensor</span><br><span class="line">const shape = [2, 3]; // 2 行, 3 列</span><br><span class="line">const a = tf.tensor([1.0, 2.0, 3.0, 10.0, 20.0, 30.0], shape);</span><br><span class="line">a.print(); // 打印张量值</span><br><span class="line">// 输出:    [[1 , 2 , 3 ],</span><br><span class="line">//          [10, 20, 30]]</span><br><span class="line"></span><br><span class="line">// shape也可以用下面的方式实现:</span><br><span class="line">const b = tf.tensor([[1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]);</span><br><span class="line">b.print();</span><br><span class="line">// 输出:    [[1 , 2 , 3 ],</span><br><span class="line">//          [10, 20, 30]]</span><br></pre></td></tr></table></figure></p><p>但是，为了构造低秩张量，我们推荐使用下面的函数来增强代码的可读性：tf.scalar（零维）, tf.tensor1d（一维）, tf.tensor2d（二维）, tf.tensor3d（三维）、tf.tensor4d（四维）以及 tf.ones（值全是1）或者tf.zeros（值全是0） ，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const a = tf.scalar(3.14);</span><br><span class="line">a.print(); // 输出零维张量</span><br><span class="line"></span><br><span class="line">const b = tf.tensor2d([[2, 3, 4], [5, 6, 7]]);</span><br><span class="line">b.print(); // 输出二维张量</span><br><span class="line"></span><br><span class="line">const c = tf.zeros([2, 3]);</span><br><span class="line">c.print(); // 输出2行3列的值全是0的张量</span><br><span class="line"></span><br><span class="line">const d = tf.ones([3, 5]);</span><br><span class="line">d.print(); // 输出3行5列的值全是1的张量</span><br></pre></td></tr></table></figure></p><p>在TensorFlow.js中，张量是不变的; 一旦创建你就不能改变它们的值。 但是，您可以对它们执行操作来生成新的张量。</p><h3 id="变量-variables"><a href="#变量-variables" class="headerlink" title="变量(variables)"></a>变量(variables)</h3><p>Variables变量是通过张量进行初始化得到的。不像Tensor的值不可变，变量的值是可变的。你可以使用变量的assign方法分配一个新的tensor到这个变量上，这是变量就会改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const initialValues = tf.zeros([5]);</span><br><span class="line">const biases = tf.variable(initialValues); // 初始化biases</span><br><span class="line">biases.print(); // 输出: [0, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">const updatedValues = tf.tensor1d([0, 1, 0, 1, 0]);</span><br><span class="line">biases.assign(updatedValues); // 更新 biases的值</span><br><span class="line">biases.print(); // 输出: [0, 1, 0, 1, 0]</span><br></pre></td></tr></table></figure></p><p>如上所示，首先使用tf.zeros得到一个张量，然后利用这个张量初始化得到一个变量，接着我们就可以打印这个变量，并且通Object.prototype.toString.call(biases)方法可以判断变量也是一个对象，接着，我们再生成一个张量，然后变量调用assign方法传入这个张量，就可以得到一个新的变量了，如下：<br><img src="/2025/06/04/Tensorflow-js入门/1.png" alt="img"><br>由此我们可以得出一个结论：变量由张量生成，且张量不可变而变量可变。<br>以上就是Tensorflow.js 张量和变量的相关介绍，希望对大家有所帮助。</p><h3 id="操作-operations"><a href="#操作-operations" class="headerlink" title="操作(operations)"></a>操作(operations)</h3><p>ensors 可以用保存数据，而 operations 可以操作数据。TensorFlow.js 提供了多种适用于张量的线性代数和机器学习的运算的 operations。由于张量是不可改变的，所以 operations 操作并不会改变 tensors 的值，而是返回新的张量。</p><h4 id="operations-提供了类似-square-等一元运算"><a href="#operations-提供了类似-square-等一元运算" class="headerlink" title="operations 提供了类似 square 等一元运算"></a>operations 提供了类似 square 等一元运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);</span><br><span class="line">x.square().print();  // or tf.square(x)</span><br><span class="line">// [1, 4, 1.9999999, 1]</span><br><span class="line"></span><br><span class="line">const x = tf.tensor1d([1, 2, 4, -1]);</span><br><span class="line">x.sqrt().print();  // or tf.sqrt(x)</span><br><span class="line">// [1, 1.4142135, 2, NaN]</span><br></pre></td></tr></table></figure><h4 id="operations-提供了类似-add、sub-等二元运算"><a href="#operations-提供了类似-add、sub-等二元运算" class="headerlink" title="operations 提供了类似 add、sub 等二元运算"></a>operations 提供了类似 add、sub 等二元运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = tf.tensor1d([1, 2, 3, 4]);</span><br><span class="line">const b = tf.tensor1d([10, 20, 30, 40]);</span><br><span class="line"></span><br><span class="line">a.add(b).print();  // or tf.add(a, b)</span><br><span class="line">// [11, 22, 33, 44]</span><br></pre></td></tr></table></figure><h4 id="支持链式操作"><a href="#支持链式操作" class="headerlink" title="支持链式操作"></a>支持链式操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const e = tf.tensor2d([[1.0, 2.0], [3.0, 4.0]]);</span><br><span class="line">const f = tf.tensor2d([[5.0, 6.0], [7.0, 8.0]])</span><br><span class="line">const sq_sum = e.add(f).square();</span><br><span class="line">sq_sum.print();</span><br><span class="line">// Output: [[36 , 64 ],</span><br><span class="line">//          [100, 144]]</span><br><span class="line"></span><br><span class="line">// 所有的操作都暴露在函数的命名空间中，也可以进行下面操作，得到相同的结果</span><br><span class="line">const sq_sum = tf.square(tf.add(e, f));</span><br></pre></td></tr></table></figure><h3 id="模型-model"><a href="#模型-model" class="headerlink" title="模型(model)"></a>模型(model)</h3><p>机器学习中，一个 model 是一个带有可训练参数的函数。这个函数将输入转化为输出。通俗的来说，这个函数表达了输入和输出之间的变换关系。我们通过在数据集上训练模型来获得最佳参数。训练好的模型可以精确的将输入数据转换为我们想得到的输出。<br>TensorFlow.js 有两种创建机器学习的方法：<br>用 Layers API（用 layers 来创建模型）<br>用 Core API（底端算子，例如 tf.matMul() 或 tf.add() 等）来建立模型<br>我们首先会用高层API：Layers API来建立模型。然后，我们会展示如何用Core API来搭建相同的模型。</p><h4 id="用Layers-API创建模型"><a href="#用Layers-API创建模型" class="headerlink" title="用Layers API创建模型"></a>用Layers API创建模型</h4><p>Layers API有两种方式创建模型：第一种是创建 sequential 模型，第二种是创建 functional 模型。下面两段会分别解释这两种模型创建方式。</p><h5 id="使用sequential-model"><a href="#使用sequential-model" class="headerlink" title="使用sequential model"></a>使用sequential model</h5><p>最常见的模型是 Sequential 模型。Sequential 模型将网络的每一层简单的叠在一起。您可以将需要的层按顺序写在一个列表里，然后将列表作为 sequential() 函数的输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const model = tf.sequential(&#123;</span><br><span class="line"> layers: [</span><br><span class="line">   tf.layers.dense(&#123;inputShape: [784], units: 32, activation: &apos;relu&apos;&#125;),</span><br><span class="line">   tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;),</span><br><span class="line"> ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>或用 add() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123;inputShape: [784], units: 32, activation: &apos;relu&apos;&#125;));</span><br><span class="line">model.add(tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;));</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：模型的第一层需要“输入形状”参数（inputShape）。不要在“输入型状”中包含 batch size（批次大小）。假设您要向模型输入一个形状为[B, 784]的张量（B 是任意batch size），您只需要将“输入型状”设为[784]。</p></blockquote><p>您可以通过model.layers来使用模型中的每一层。例如，您可以用 model.inputLayers 和 model.outputLayers 来调用输入层和输出层。</p><h5 id="使用functional-model"><a href="#使用functional-model" class="headerlink" title="使用functional model"></a>使用functional model</h5><p>我们也可以通过 tf.model() 来创建 LayersModel。tf.model() 和 tf.sequential() 的主要区别为，您可以用 tf.model() 来创建任何非闭环的计算图。<br>以下是一段如何用 tf.model() API 建立和上文相同模型的列子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 用apply()方法创建任意计算图</span><br><span class="line">const input = tf.input(&#123;shape: [784]&#125;);</span><br><span class="line">const dense1 = tf.layers.dense(&#123;units: 32, activation: &apos;relu&apos;&#125;).apply(input);</span><br><span class="line">const dense2 = tf.layers.dense(&#123;units: 10, activation: &apos;softmax&apos;&#125;).apply(dense1);</span><br><span class="line">const model = tf.model(&#123;inputs: input, outputs: dense2&#125;);</span><br></pre></td></tr></table></figure></p><p>我们在每一层用 apply() 将上一层的输出作为本层的输入。apply() 返回一个 SymbolicTensor（类似于张量，但不包含任何数值）<br>不同于 sequential model 使用 inputShape 来定义第一层的输入，我们用 tf.input() 创建的 SymbolicTensor 作为第一层的输入<br>如果您向 apply() 输入一个数值张量，它会进行计算并返还一个数值张量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const t = tf.tensor([-2, 1, 0, 5]);</span><br><span class="line">const o = tf.layers.activation(&#123;activation: &apos;relu&apos;&#125;).apply(t);</span><br><span class="line">o.print(); // [0, 1, 0, 5]</span><br></pre></td></tr></table></figure></p><p>这个方式适用于单独测试每一层并检查它们的输出。<br>和 sequential model 一样，您可以通过 model.layers 来使用模型中的每一层。例如，您可以用 model.inputLayers 和 model.outputLayers 来调用输入层和输出层。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>Sequential model和functional model都属于 LayersModel类。使用 LayersModels 让验证更方便：它要求您定义输入形状，并用您定义的形状来验证您对模型的输入。LayersModel 会自动计算模型中所有张量的形状。知道张量的形状后，模型就可以自动创建它所需要的参数。您也可以用形状信息来判断两层相邻的层是否相互兼容。</p><h4 id="模型总览"><a href="#模型总览" class="headerlink" title="模型总览"></a>模型总览</h4><p>使用 model.summary() 可以显示很多模型的重要信息，包括：</p><ul><li>每一层的名字和类型</li><li>每一层的输出形状</li><li>每一层的权重数量</li><li>每一层的输入</li><li>一个模型拥有的可训练参数总量，和不可训练参数总量</li></ul><p>用前面定义的模型来做例子，我们可以在命令行中得到以下信息：</p><table><thead><tr><th>Layer(type)</th><th>Output shape</th><th>Param #</th></tr></thead><tbody><tr><td>dense_Dense1 (Dense)</td><td>[null,32]</td><td>25120</td></tr><tr><td>dense_Dense2 (Dense)</td><td>[null,10]</td><td>330</td></tr><tr><td>Total params: 25450 Trainable params: 25450 Non-trainable params: 0</td><td></td><td></td></tr></tbody></table><p>注意：每一层的输出形状中都含有 null 值。模型的输入形状包含了批次大小，而批次大小是可以灵活更变的，所以批次的值在张量形状中以 null 显示。</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>相对于底端API而言，使用 LayersModel的另一个好处是方便存储、加载模型。LayersModel 包含如下信息：</p><ul><li>可用于重建模型的模型架构信息</li><li>模型的权重</li><li>训练配置（例如损失函数，优化器和评估方式）</li><li>优化器的状态（可用于继续训练模型）</li></ul><p>存储和加载模型只需要一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const saveResult = await model.save(&apos;localstorage://my-model-1&apos;);</span><br><span class="line">const model = await tf.loadLayersModel(&apos;localstorage://my-model-1&apos;);</span><br></pre></td></tr></table></figure></p><p>在这个例子中，模型被存储在浏览器的本地存储里。请访问 model.save() 和 save and load 了解如何把模型保存在不同的媒介中（例如 file storage, IndexedDB, 触发下载到浏览器等等）。</p><h4 id="自定义层"><a href="#自定义层" class="headerlink" title="自定义层"></a>自定义层</h4><p>层是创建模型的基础。如果您的模型需要定制化计算模块，您可以写一个自定义层并插入模型中。下面的例子是一个计算平方和的自定义层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SquaredSumLayer extends tf.layers.Layer &#123;</span><br><span class="line"> constructor() &#123;</span><br><span class="line">   super(&#123;&#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> // In this case, the output is a scalar.</span><br><span class="line"> computeOutputShape(inputShape) &#123; return []; &#125;</span><br><span class="line"></span><br><span class="line"> // call() is where we do the computation.</span><br><span class="line"> call(input, kwargs) &#123; return input.square().sum();&#125;</span><br><span class="line"></span><br><span class="line"> // Every layer needs a unique name.</span><br><span class="line"> getClassName() &#123; return &apos;SquaredSum&apos;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用 apply() 方法在一个张量上测试这个自定义层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const t = tf.tensor([-2, 1, 0, 5]);</span><br><span class="line">const o = new SquaredSumLayer().apply(t);</span><br><span class="line">o.print(); // prints 30</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：如果您在模型中包含了自定义层，模型将不能序列化</p></blockquote><h4 id="用Core-API创建模型"><a href="#用Core-API创建模型" class="headerlink" title="用Core API创建模型"></a>用Core API创建模型</h4><p>本文开头提到了两种在 TensorFlow.js 中建立模型的方法。最常用的方式是使用 Layers API，因为它的模式是基于广泛应用的 Keras API（详情见 best practices and reduces cognitive load）。Layers API 提供了大量方便的工具，例如权重初始化，模型序列化，训练监测，可迁移性和安全检查。<br>当您遇到如下情况时，可能会需要使用 Core API：</p><ul><li>您需要更多灵活性和控制</li><li>您不需要序列化或可以创造自己的序列化方法</li></ul><p>用 Core API 写的模型包含了一系列的函数。这些函数以一个或多个张量作为输入，并输出另一个张量。我们可以用 Core API 来重写之前定义的模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The weights and biases for the two dense layers.</span><br><span class="line">const w1 = tf.variable(tf.randomNormal([784, 32]));</span><br><span class="line">const b1 = tf.variable(tf.randomNormal([32]));</span><br><span class="line">const w2 = tf.variable(tf.randomNormal([32, 10]));</span><br><span class="line">const b2 = tf.variable(tf.randomNormal([10]));</span><br><span class="line"></span><br><span class="line">function model(x) &#123;</span><br><span class="line">  return x.matMul(w1).add(b1).relu().matMul(w2).add(b2).softmax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Core API 中，我们需要自己创建和初始化权重。每个权重都是一个 Variable，TensorFlow.js 会把 Variable 权重设为可训练张量。您可以用 tf.variable() 创建 Variable 或把一个已存在的张量放到 Variable 中。</p><h3 id="内存管理-dispose-amp-tidy"><a href="#内存管理-dispose-amp-tidy" class="headerlink" title="内存管理(dispose&amp;tidy)"></a>内存管理(dispose&amp;tidy)</h3><p>因为TensorFlow.js使用了GPU来加速数学运算，因此当tensorflow处理张量和变量时就有必要来管理GPU内存。在TensorFlow.js中，我们可以通过dispose 和 tf.tidy这两种方法来管理内存。</p><h4 id="dispose"><a href="#dispose" class="headerlink" title="dispose"></a>dispose</h4><p>您可以在张量或变量上调用dispose来清除它并释放其GPU内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const x = tf.tensor2d([[0.0, 2.0], [4.0, 6.0]]);</span><br><span class="line">const x_squared = x.square();</span><br><span class="line"></span><br><span class="line">x.dispose();</span><br><span class="line">x_squared.dispose();</span><br></pre></td></tr></table></figure></p><h4 id="tf-tidy"><a href="#tf-tidy" class="headerlink" title="tf.tidy"></a>tf.tidy</h4><p>进行大量的张量操作时使用dispose可能会很麻烦。 TensorFlow.js提供了另一个函数tf.tidy，它对JavaScript中的常规范围起到类似的作用，不同的是它针对GPU支持的张量。<br>tf.tidy执行一个函数并清除所有创建的中间张量，释放它们的GPU内存。 它不清除内部函数的返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const average = tf.tidy(() =&gt; &#123;</span><br><span class="line">  const y = tf.tensor1d([1.0, 2.0, 3.0, 4.0]);</span><br><span class="line">  const z = tf.ones([4]);</span><br><span class="line"></span><br><span class="line">  return y.sub(z).square().mean();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">average.print()</span><br></pre></td></tr></table></figure></p><p>使用tf.tidy将有助于防止应用程序中的内存泄漏。它也可以用来更谨慎地控制内存何时回收。</p><h4 id="两个重要的注意事项"><a href="#两个重要的注意事项" class="headerlink" title="两个重要的注意事项"></a>两个重要的注意事项</h4><p>传递给tf.tidy的函数应该是同步的，并且不会返回Promise。我们建议在tf.tidy内不要有更新UI或在发出远程请求的代码。<br>tf.tidy不会清理变量。变量通常持续到机器学习模型的整个生命周期，因此TensorFlow.js不会清理它们，即使它们是在tidy中创建的。不过，您可以手动调用dispose处理它们。</p><h2 id="Tensorflow-js实战例子"><a href="#Tensorflow-js实战例子" class="headerlink" title="Tensorflow.js实战例子"></a>Tensorflow.js实战例子</h2><p>TensorFlow.js的工作依然是围绕神经网络展开的，基本的工作过程包含了如下几个典型步骤：<br><img src="/2025/06/04/Tensorflow-js入门/2.png" alt="img"><br>下面将通过TensorFlow.js官方网站提供的数据拟合的示例来了解整个流程。</p><h3 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h3><p>Define 阶段是使用TensorFlow.js的第一步，这个阶段中需要初始化神经网络模型，你可以在TensorFlow的tf.layers对象上找到具备各种功能和特征的隐藏层，通过模型实例的add方法将其逐层添加到神经网络中，从而实现张量变形处理、卷积神经网络、循环神经网络等复杂模型，当内置模型无法满足需求时，还可以自定义模型层，TensorFlow的高阶API可以帮助开发者以声明式的编码来完成神经网络的结构搭建，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*创建模型*/</span><br><span class="line">function createModel() &#123;</span><br><span class="line">   const model = tf.sequential(); </span><br><span class="line">   model.add(tf.layers.dense(&#123;inputShape: [1], units: 1, useBias: true&#125;));</span><br><span class="line">   model.add(tf.layers.dense(&#123;units: 1, useBias: true&#125;));</span><br><span class="line">   return model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile阶段需要对训练过程进行一些参数预设，你可以先温习一下上一章中介绍过的BP神经网络的工作过程，然后再来理解下面的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.compile(&#123;</span><br><span class="line">   optimizer: tf.train.adam(),</span><br><span class="line">   loss: tf.losses.meanSquaredError,</span><br><span class="line">   metrics: [&apos;mse&apos;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>loss（损失）用于定义损失函数，它是神经网络的实际输出和期望输出之间偏差的量化评估标准，最常用的损失函数就是均方差损失（tf.losses.meanSquaredError），其他损失函数可以在TensorFlow的API文档中进行查看；optimizer(优化器)是指误差反向传播结束后，神经网络进行权重调整时所使用的的算法。权重调整的目的就是为了使损失函数达到极小值，所以通常采用“梯度下降”的思想来进行逼近，梯度方向是指函数在某一点变化最显著的方向，但实际的情况往往并没有这么简单，假设下图是一个神经网络的损失函数曲线：<br><img src="/2025/06/04/Tensorflow-js入门/3.png" alt="img"><br>可以看到损失函数的形态、初始参数的位置以及优化过程的步长等都可能对训练过程和训练结果产生影响，这就需要在optimizer配置项中指定优化算法来达到较好的训练效果；metrics配置项用于指定模型的度量指标，大多数情况下可以直接使用损失函数来作为度量标准。</p><h3 id="Fit"><a href="#Fit" class="headerlink" title="Fit"></a>Fit</h3><p>Fit 阶段执行的是模型训练的工作（fit本身是拟合的意思），通过调用模型的fit方法就可以启动训练循环，官方示例代码如下(fit方法接收的参数分别为输入张量集、输出张量集和配置参数)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const batchSize = 32;</span><br><span class="line">const epochs = 50;</span><br><span class="line"></span><br><span class="line">await model.fit(inputs, labels, &#123;</span><br><span class="line">   batchSize,</span><br><span class="line">   epochs,</span><br><span class="line">   shuffle: true,</span><br><span class="line">   callbacks: tfvis.show.fitCallbacks(</span><br><span class="line">      &#123; name: &apos;Training Performance&apos; &#125;,</span><br><span class="line">      [&apos;loss&apos;, &apos;mse&apos;], </span><br><span class="line">      &#123; height: 200, callbacks: [&apos;onEpochEnd&apos;] &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>相关参数说明如下（其他参数可参考官方开发文档）：</p><ul><li>batchSize（批大小）指每个循环中使用的样本数，通常取值为32~512</li><li>epochs指定整个训练集上的数据的总循环次数</li><li>shuffle指是否在每个epochs中打乱训练样本的次序</li><li>callbacks指定了训练过程中的回调函数</li></ul><p>神经网络的训练是循环进行的，假设总训练样本大小为320个，那么上面的示例代码所描述的训练过程是：先使用下标为0^31的样本来训练神经网络，然后使用optimizer来更新一次权重，再使用下标为32^63的样本进行训练，再更新权重，直到总样本中所有数据均被使用过一次，上述过程被称为一个epoch，接着打乱整个训练样本的次序，再重复共计50轮，callbacks回调函数参数直接关联了tfvis库，它是TensorFlow提供的专用可视化工具模块。</p><h3 id="Evaluate"><a href="#Evaluate" class="headerlink" title="Evaluate"></a>Evaluate</h3><p>Evaluate阶段需要对模型的训练结果进行评估，调用模型实例的evaluate方法就可以使用测试数据来获得损失函数和度量标准的数值。你可能已经注意到TensorFlow在定制训练过程时更加关注如何使用样本数据，而并没有将“度量指标小于给定阈值”作为训练终止的条件（例如brain.js中就可以通过设置errorthresh参数），在复杂神经网络的构建和设计中，开发者很可能需要一边构建一边进行非正式的训练测试，度量指标最终并不一定能够降低到给定的阈值以下，以此作为训练终止条件很可能会使训练过程陷入无限循环，所以使用固定的训练次数配合可视化工具来观察训练过程就更为合理。</p><h3 id="Predict"><a href="#Predict" class="headerlink" title="Predict"></a>Predict</h3><p>Predict阶段是使用神经网络模型进行预测的阶段，这也是前端工程师参与度最高的部分，毕竟模型输出的结果只是数据，如何利用这些预测结果来制作一些更有趣或者更加智能化的应用或许才是前端工程师更应该关注的问题。从前文的过程中不难看出，TensorFlow.js提供的能力是围绕神经网络模型展开的，应用层很难直接使用，开发者通常都需要借助官方模型仓库中提供的预训练模型或者使用其他基于TensorFlow.js构建的第三方应用，例如人脸识别框架face-api.js（它可以在浏览器端和Node.js中实现快速的人脸追踪和身份识别），语义化更加明确的机器学习框架ml5.js（可以直接调用API来实现图像分类、姿势估计、人物抠图、风格迁移、物体识别等更加具体的任务），可以实现手部跟踪的handtrack.js等等，如果TensorFlow的相关知识让你觉得过于晦涩，也可以先尝试使用这些更高层的框架来构建一些有趣的程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是对Tensorflow.js的简单介绍，下边列出几个常用的链接，对学习Tensorflow.js有更加详细的了解<br><a href="https://tensorflow.google.cn/js?hl=zh-cn" target="_blank" rel="noopener">TensorFlow.js中文官网</a><br><a href="https://www.w3cschool.cn/tensorflowjs/" target="_blank" rel="noopener">w3cschool</a><br><a href="https://www.kaggle.com/models" target="_blank" rel="noopener">TensorFlow.js模型下载</a><br><a href="https://modelscope.cn/datasets" target="_blank" rel="noopener">训练数据集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tensorflow.js简单入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
      <category term="Tensorflow.js" scheme="/tags/Tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust 锈化前端工具链</title>
    <link href="/2025/06/03/%E4%BD%BF%E7%94%A8-Rust-%E9%94%88%E5%8C%96%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>/2025/06/03/使用-Rust-锈化前端工具链/</id>
    <published>2025-06-03T06:12:23.000Z</published>
    <updated>2025-06-03T06:54:08.055Z</updated>
    
    <content type="html"><![CDATA[<p>使用Rust构建前端工具链<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来，Rust的受欢迎程度不断上升。首先，在操作系统领域，Rust 已成为 Linux 内核官方认可的开发语言之一，Windows 也宣布将使用 Rust 来重写内核，并重写部分驱动程序。此外，国内手机厂商 Vivo 也宣布使用 Rust 开发了名为“蓝河”的操作系统。除此之外，Rust 在图形渲染、游戏开发、中间件开发、边缘计算、计算安全等领域也是遍地开花，可以说，Rust 正在以惊人的速度重塑着各个领域的发展，让人不禁感叹 Rust 已经在重写万物了。</p><p>那回到前端领域，正在进行一场构建工具的革命，除了老牌的 Babel 竞争对手<a href="https://swc.rs/" target="_blank" rel="noopener">swc</a>，一些新兴的前端构建工具也都在使用 Rust 进行开发，例如<a href="https://turbo.build/pack" target="_blank" rel="noopener">Turbopack</a>、<a href="https://parceljs.org/" target="_blank" rel="noopener">Parcel</a>，对标 Webpack 的<a href="https://www.rspack.dev/" target="_blank" rel="noopener">Rspack</a>，对标 Vite 的<a href="https://farm-fe.github.io/" target="_blank" rel="noopener">Farm</a>等等。所以，对于广大前端同胞来说，C/C++ 太难，学习和掌握 Rust 是一个不错的选择，虽然 Rust 也不见得容易许多，它有着陡峭的学习曲线，但它或许是我们突破闭塞的前端区间的一把钥匙，帮助我们打开通往新世界的大门。</p><h2 id="锈化开发工具的方式"><a href="#锈化开发工具的方式" class="headerlink" title="锈化开发工具的方式"></a>锈化开发工具的方式</h2><p>虽说 Rust 的学习曲线可能相对陡峭，但笔者认为这是对于要全面掌握 Rust 这门语言而言的，而我们学习语言的目的最重要的是掌握一项可以帮我们解决问题的技能，因此，对于 Rust 不需要抱有太多的恐惧和敬畏之心，只需要摒除杂念立马开始学习 + 撸码，剩下的就交给时间来慢慢积累经验。此外，对于不是那么复杂应用来说，熟悉 Rust 基本语法和数据结构，翻过「所有权机制」和「生命周期」两座大山，基本也足以应付了。</p><p>本文建立在读者已经有一定的 Rust 知识基础上，对于 Rust 基本语法就不做赘述了。当前，大部分前端研发都是在 Node 环境下进行的，所以我们通过 Rust 来改造开发工具，主要有两种形式：</p><ul><li><p>使用 WASM 的方式，基于<a href="https://rustwasm.github.io/wasm-pack/" target="_blank" rel="noopener">wasm-pack</a>，将 Rust 代码编译成 WASM，以供 Node 调用</p></li><li><p>将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于napi-rs和neon来实现</p></li></ul><p>在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么此时就应该选择 Node addons 的方式了。而<a href="https://napi.rs/" target="_blank" rel="noopener">napi-rs</a>和<a href="https://neon-bindings.com/" target="_blank" rel="noopener">neon</a>的选择的话，napi-rs相对而言比较简单和轻量，而且针对不同版本的 Node 不需要重新编译，所以我们考虑选择napi-rs作为锈化开发工具的方式。</p><h2 id="初识-NAPI-RS"><a href="#初识-NAPI-RS" class="headerlink" title="初识 NAPI-RS"></a>初识 NAPI-RS</h2><p>我们可以通过 napi-rs 的开发工具 <strong>@napi-rs/cli</strong>以及<a href="https://github.com/napi-rs/package-template" target="_blank" rel="noopener">项目模板</a>来初始化一个应用，这里推荐使用项目模板，因为经过笔者的测试，开发工具创建的项目内容上相较于模板比较落后，对于后续深入使用上会造成一定的困惑。</p><p>从 napi-rs 项目模板内容上看，可以发现项目结构完善，工程化相关能力非常齐全，提供了构建工具、测试用例编写、Github CI 工作流等等必须的能力，我们只需要关注编码就可以了。</p><p>我们先来关注一下生成的 napi-rs 项目文件。从package.json和npm分析可以看出，一个 napi-rs 项目主要是由主包和 npm 下的针对不同平台的编译构建结果子包组成，napi-rs 会根据用户的配置，将用户的 Rust 代码构建为不同平台下的 Node 扩展 binding 文件，这些文件会放到 npm 下对应的平台目录中，再由 package.json 中 main 字段指定导出，用户在安装主包的时候，会根据用户电脑情况加载对应构建结果子包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@tarojs/parse-css-to-stylesheet-darwin-x64&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.25&quot;,</span><br><span class="line">  &quot;os&quot;: [</span><br><span class="line">    &quot;darwin&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;cpu&quot;: [</span><br><span class="line">    &quot;x64&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;main&quot;: &quot;parse-css-to-stylesheet.darwin-x64.node&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;parse-css-to-stylesheet.darwin-x64.node&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &quot;https://github.com/NervJS/parse-css-to-stylesheet&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在主包入口index.js中将根据用户宿主平台，加载对应的扩展文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">switch (platform) &#123;</span><br><span class="line">  case &apos;win32&apos;:</span><br><span class="line">    switch (arch) &#123;</span><br><span class="line">      case &apos;x64&apos;:</span><br><span class="line">        localFileExisted = existsSync(</span><br><span class="line">          join(__dirname, &apos;parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">        )</span><br><span class="line">        try &#123;</span><br><span class="line">          if (localFileExisted) &#123;</span><br><span class="line">            nativeBinding = require(&apos;./parse-css-to-stylesheet.win32-x64-msvc.node&apos;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            nativeBinding = require(&apos;@tarojs/parse-css-to-stylesheet-win32-x64-msvc&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          loadError = e</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    break</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>从@napi-rs/triples这个包中可以看到所有支持的平台列表，而对于常规性的 Node 应用来说，我们不需要构建这么多平台，一般来说构建x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台也足够了，这样也能减少 CI 的构建时间。</p><p>napi-rs 默认构建的平台是x86_64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu，在<a href="https://github.com/napi-rs/napi-rs/blob/main/cli/src/utils/target.ts#L25" target="_blank" rel="noopener">这里</a>可以看到，所以为了增加 MAC Book M 系列电脑的支持，我们需要增加aarch64-apple-darwin的配置，可以在 package.json 中napi字段中添加，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;napi&quot;: &#123;</span><br><span class="line">  &quot;binaryName&quot;: &quot;taro&quot;,</span><br><span class="line">  &quot;triples&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: true,</span><br><span class="line">    &quot;additional&quot;: [</span><br><span class="line">      &quot;aarch64-apple-darwin&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>接下来就可以开始我们的编码之旅咯！</p><h2 id="基于-NAPI-RS-开发-Node-扩展"><a href="#基于-NAPI-RS-开发-Node-扩展" class="headerlink" title="基于 NAPI-RS 开发 Node 扩展"></a>基于 NAPI-RS 开发 Node 扩展</h2><p>基于 napi-rs 开发 Node 扩展，除了 Rust 编码本身外，无非需要关注两种情况，即 JavaScript 调用 Rust 和 Rust 调用 JavaScript。</p><h3 id="JavaScript-调用-Rust"><a href="#JavaScript-调用-Rust" class="headerlink" title="JavaScript 调用 Rust"></a>JavaScript 调用 Rust</h3><h4 id="调用-Rust-函数"><a href="#调用-Rust-函数" class="headerlink" title="调用 Rust 函数"></a>调用 Rust 函数</h4><p>这是最常见的用法，因为我们一般使用 Rust 开发 Node 扩展，也是为了将一些 CPU 密集型任务的任务使用 Rust 来实现，再暴露给 JS 来调用，从而达到提升应用性能的目的，最为常见的是 Rust 暴露方法给到 JS 调用，通过项目模板生成的 napi-rs 示例也可以看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/lib.rs </span><br><span class="line">use napi_derive::napi;</span><br><span class="line"></span><br><span class="line">#[napi]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码，通过给plus_100函数添加#[napi]属性宏，这样可以标记该函数，表示该函数可以通过 N-API 在 Node.js 中调用，在项目编译后的 typing 文件中，我们能看到对应生成了 JS 函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function plus100(input: number): number</span><br></pre></td></tr></table></figure></p><p>可以看到这里生成 JS 函数名是 napi-rs 自己的规则，我们也可以自定义暴露的函数名，通过js_name属性可以指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#[napi(js_name = &quot;plus_100&quot;)]</span><br><span class="line">pub fn plus_100(input: u32) -&gt; u32 &#123;</span><br><span class="line">  input + 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，除了暴露函数这一基本操作之外，我们还可以暴露常量、对象、类、enum 等等给到 JS 侧去调用，这些可以通过 napi-rs 的<a href="https://napi.rs/docs/concepts/values" target="_blank" rel="noopener">官方文档</a>可以查阅到。</p><h4 id="以-Object-作为参数"><a href="#以-Object-作为参数" class="headerlink" title="以 Object 作为参数"></a>以 Object 作为参数</h4><p>而在 JS 调用 Rust 编码中，最需要关注的是调用函数时，JS 侧给 Rust 传对象作为参数，这里为了提升性能，建议提前在 Rust 中定义好传递对象的数据结构，在 JS 中以引入该数据结构定义，规范数据传递即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 定义好数据结构</span><br><span class="line">// napi(object) 表示紧随其后的 struct （结构体）将通过 N-API 以 JavaScript 对象的形式暴露出去</span><br><span class="line">#[napi(object)]</span><br><span class="line">pub struct Project &#123;</span><br><span class="line">  pub project_root: String,</span><br><span class="line">  pub project_name: String,</span><br><span class="line">  pub npm: NpmType,</span><br><span class="line">  pub description: Option,</span><br><span class="line">  pub typescript: Option,</span><br><span class="line">  pub template: String,</span><br><span class="line">  pub css: CSSType,</span><br><span class="line">  pub auto_install: Option,</span><br><span class="line">  pub framework: FrameworkType,</span><br><span class="line">  pub template_root: String,</span><br><span class="line">  pub version: String,</span><br><span class="line">  pub date: Option,</span><br><span class="line">  pub compiler: Option,</span><br><span class="line">  pub period: PeriodType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JS 中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义，其中 Project 由 Rust binding 中暴露</span><br><span class="line">export function createProject(conf: Project)</span><br><span class="line"></span><br><span class="line">// 函数调用</span><br><span class="line">createProject(&#123;</span><br><span class="line">  projectRoot: projectDir,</span><br><span class="line">  projectName,</span><br><span class="line">  template,</span><br><span class="line">  npm,</span><br><span class="line">  framework,</span><br><span class="line">  css: this.conf.css || CSSType.None,</span><br><span class="line">  autoInstall: autoInstall,</span><br><span class="line">  templateRoot: getRootPath(),</span><br><span class="line">  version: getPkgVersion(),</span><br><span class="line">  typescript: this.conf.typescript,</span><br><span class="line">  date: this.conf.date,</span><br><span class="line">  description: this.conf.description,</span><br><span class="line">  compiler: this.conf.compiler,</span><br><span class="line">  period: PeriodType.CreateAPP,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="Rust-调用-JavaScript"><a href="#Rust-调用-JavaScript" class="headerlink" title="Rust 调用 JavaScript"></a>Rust 调用 JavaScript</h3><p>而 Rust 中也可以调用 JS 提供的方法，这在做 Node 开发工具的时候非常有用，因为有时候我们需要读取开发人员的配置代码给到 Rust 调用，其中就可能会遇到 Rust 调用 JavaScript 中函数的情况。</p><h4 id="一个调用-JS-函数的简单例子"><a href="#一个调用-JS-函数的简单例子" class="headerlink" title="一个调用 JS 函数的简单例子"></a>一个调用 JS 函数的简单例子</h4><p>在 napi-rs 中调用 JS 函数主要通过ThreadsafeFunction来实现，请看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  for n in 0..100 &#123;</span><br><span class="line">    let tsfn = callback.clone();</span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述例子中，call_threadsafe_function函数接受了一个类型为ThreadsafeFunction<u32>的参数，这表明call_threadsafe_function被编译为 JS 函数后将接受一个回调函数作为参数，而该回调函数的有效参数为u32即number类型，而在call_threadsafe_function函数体中，通过thread::spawn开辟子线程，以阻塞的方式调用这个传入的回调函数。</u32></p><p>通过ThreadsafeFunction的call方法可以调用到传入的 JS 回调函数，但是我们会发现它拿不到返回值，如果我们需要获取到 JS 回调函数的返回值时，我们需要使用call_with_return_value和call_async两个方法。</p><h4 id="获取-JS-函数的返回值"><a href="#获取-JS-函数的返回值" class="headerlink" title="获取 JS 函数的返回值"></a>获取 JS 函数的返回值</h4><p>对比call与call_with_return_value的实现可以看出，call_with_return_value比call多一个回调函数参数，并且可以指定 JS 回调函数返回值的类型，并且该类型需要满足FromNapiValue这个 trait，因为call_with_return_value在处理 JS 回调函数时会调用它的from_napi_value方法将 JS 数据转为 Rust 的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/napi-rs/napi-rs/blob/main/crates/napi/src/threadsafe_function.rs#L428</span><br><span class="line">pub fn call(&amp;self, value: Result, mode: ThreadsafeFunctionCallMode) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::Direct,</span><br><span class="line">            callback: Box::new(|_d: Result| Ok(())),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn call_with_return_value Result&lt;()&gt;&gt;(</span><br><span class="line">  &amp;self,</span><br><span class="line">  value: Result,</span><br><span class="line">  mode: ThreadsafeFunctionCallMode,</span><br><span class="line">  cb: F,</span><br><span class="line">) -&gt; Status &#123;</span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Status::Closing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">      sys::napi_call_threadsafe_function(</span><br><span class="line">        self.handle.get_raw(),</span><br><span class="line">        Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">          ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">            data,</span><br><span class="line">            call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">            callback: Box::new(move |d: Result| &#123;</span><br><span class="line">              d.and_then(|d| D::from_napi_value(d.0.env, d.0.value).and_then(cb))</span><br><span class="line">            &#125;),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)))</span><br><span class="line">        .cast(),</span><br><span class="line">        mode.into(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    .into()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>call_with_return_value的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">  callback.call_with_return_value(Ok(1), ThreadsafeFunctionCallMode::Blocking, move |result: u32| &#123;</span><br><span class="line">    println!(&quot;callback: &#123;result:?&#125;&quot;);</span><br><span class="line">    Ok(())</span><br><span class="line">  &#125;);</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，JS 回调函数的返回值是在call_with_return_value的第三个回调函数参数中获取到的，这就导致如果我们需要依赖这个 JS 函数返回值的话，我们后续的逻辑代码只能写在call_with_return_value的第三个回调函数参数中，对我们的代码逻辑书写造成诸多不便，代码可读性降低，所以推荐使用call_async方法来执行 JS 函数，并获取参数。</p><h4 id="使用call-async获取-JS-函数返回值"><a href="#使用call-async获取-JS-函数返回值" class="headerlink" title="使用call_async获取 JS 函数返回值"></a>使用call_async获取 JS 函数返回值</h4><p>从call_async的实现可以看出，它首先使用了tokio创建了一个 one-shot 通道，让 JS 函数以不阻塞的方式异步运行，并在执行完成后通过sender 发送操作结果，而使用receiver进行等待执行结果，并将结果返回，同时要使用call_async方法，需要在Cargo.toml中为napi依赖打开tokio_rt特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(feature = &quot;tokio_rt&quot;)]</span><br><span class="line">pub async fn call_async(&amp;self, value: Result) -&gt; Result &#123;</span><br><span class="line">  let (sender, receiver) = tokio::sync::oneshot::channel::&gt;();</span><br><span class="line"></span><br><span class="line">  self.handle.with_read_aborted(|aborted| &#123;</span><br><span class="line">    if aborted &#123;</span><br><span class="line">      return Err(crate::Error::from_status(Status::Closing));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_status!(</span><br><span class="line">      unsafe &#123;</span><br><span class="line">        sys::napi_call_threadsafe_function(</span><br><span class="line">          self.handle.get_raw(),</span><br><span class="line">          Box::into_raw(Box::new(value.map(|data| &#123;</span><br><span class="line">            ThreadsafeFunctionCallJsBackData &#123;</span><br><span class="line">              data,</span><br><span class="line">              call_variant: ThreadsafeFunctionCallVariant::WithCallback,</span><br><span class="line">              callback: Box::new(move |d: Result| &#123;</span><br><span class="line">                sender</span><br><span class="line">                  .send(d.and_then(|d| D::from_napi_value(d.0.env, d.0.value)))</span><br><span class="line">                  .map_err(|_| &#123;</span><br><span class="line">                    crate::Error::from_reason(&quot;Failed to send return value to tokio sender&quot;)</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)))</span><br><span class="line">          .cast(),</span><br><span class="line">          ThreadsafeFunctionCallMode::NonBlocking.into(),</span><br><span class="line">        )</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Threadsafe function call_async failed&quot;</span><br><span class="line">    )</span><br><span class="line">  &#125;)?;</span><br><span class="line">  receiver</span><br><span class="line">    .await</span><br><span class="line">    .map_err(|_| &#123;</span><br><span class="line">      crate::Error::new(</span><br><span class="line">        Status::GenericFailure,</span><br><span class="line">        &quot;Receive value from threadsafe function sender failed&quot;,</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">    .and_then(|ret| ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见call_async使用时将引入 Rust 的异步编程，我们可以使用async/await关键字来进行调用，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#[napi]</span><br><span class="line">pub async fn call_threadsafe_function(callback: ThreadsafeFunction) -&gt; Result &#123;</span><br><span class="line">  let result = match callback.call_async::(Ok(1)).await &#123;</span><br><span class="line">    Ok(res) =&gt; res,</span><br><span class="line">    Err(e) =&gt; &#123;</span><br><span class="line">      println!(&quot;Error: &#123;&#125;&quot;, e);</span><br><span class="line">      0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  println!(&quot;result: &#123;result:?&#125;&quot;);</span><br><span class="line">  Ok(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时生成的 JS 函数定义为如下，可以看出callThreadsafeFunction变成了一个异步函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export function callThreadsafeFunction(callback: (err: Error | null, value: number) =&gt; any): Promise&lt;number&gt;</span><br></pre></td></tr></table></figure></p><p>所以在 JS 中调用方式及输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const result = await callThreadsafeFunction((err, value) =&gt; &#123;</span><br><span class="line">  return value + 1</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// result: 2</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p><h4 id="正确处理-JS-函数的返回值"><a href="#正确处理-JS-函数的返回值" class="headerlink" title="正确处理 JS 函数的返回值"></a>正确处理 JS 函数的返回值</h4><p>从前面call_async的实现可以看出，call_async返回的数据，也即 JS 函数返回值需要满足如下泛型约束D: ‘static + FromNapiValue，而 napi-rs 默认会为数值、字符串、布尔等基本 JS 数据类型实现FromNpiValuetrait，但是如果我们的 JS 回调想要返回一个对象时，则需要自己手动实现FromNpiValuetrait，这样可以让call_async获取到 JS 返回数据时自动调用FromNpiValuetrait 的from_napi_value方法将 JS 返回数据转换为 Rust 的数据格式，以下是一个简单的示例。</p><p>假如需要在 Rust 调用一个 JS 函数，JS 函数会返回一个对象，包含三个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  setPageName?: string,</span><br><span class="line">  changeExt?: boolean,</span><br><span class="line">  setSubPkgName?: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在 Rust 中获取到返回的对象，并转为 Rust 数据，那么首先我们可以定义一个类似的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">pub struct JSReturnObject &#123;</span><br><span class="line">  pub set_page_name: Option,</span><br><span class="line">  pub change_ext: Option,</span><br><span class="line">  pub set_sub_pkg_page_name: Option,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时为它实现FromNpiValuetrait 就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">impl FromNapiValue for JSReturnObject &#123;</span><br><span class="line">  unsafe fn from_napi_value(env: napi_env, napi_val: napi_value) -&gt; Result &#123;</span><br><span class="line">    let obj = JsObject::from_napi_value(env, napi_val)?;</span><br><span class="line">    let mut js_return_object = JSReturnObject &#123;</span><br><span class="line">      set_page_name: None,</span><br><span class="line">      change_ext: None,</span><br><span class="line">      set_sub_pkg_page_name: None,</span><br><span class="line">    &#125;;</span><br><span class="line">    let has_set_page_name = obj.has_named_property(&quot;setPageName&quot;)?;</span><br><span class="line">    let has_change_ext = obj.has_named_property(&quot;changeExt&quot;)?;</span><br><span class="line">    let has_set_sub_pkg_page_name = obj.has_named_property(&quot;setSubPkgName&quot;)?;</span><br><span class="line">    if has_set_page_name &#123;</span><br><span class="line">      js_return_object.set_page_name = Some(obj.get_named_property::(&quot;setPageName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_set_sub_pkg_page_name &#123;</span><br><span class="line">      js_return_object.set_sub_pkg_page_name = Some(obj.get_named_property::(&quot;setSubPkgName&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    if has_change_ext &#123;</span><br><span class="line">      js_return_object.change_ext = Some(obj.get_named_property::(&quot;changeExt&quot;)?);</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(js_return_object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，先调用JsObject::from_napi_value方法将传入数据转为JsObject，然后调用</p><p>JsObject的has_named_property方法获取到对应的属性值，经过处理后可以构建出JSReturnObject结构体数据，并进行返回。而使用的时候，为call_async指定泛型参数类型为JSReturnObject，接下来就可以获取到 JS 返回值进行处理了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result: JSReturnObject = js_handler</span><br><span class="line">  .call_async(Ok(options.clone()))</span><br><span class="line">  .await</span><br><span class="line">  .with_context(|| format!(&quot;模板自定义函数调用失败: &#123;&#125;&quot;, file_relative_path))?;</span><br></pre></td></tr></table></figure></p><h2 id="使用-VSCode-进行调试"><a href="#使用-VSCode-进行调试" class="headerlink" title="使用 VSCode 进行调试"></a>使用 VSCode 进行调试</h2><p>我们可以使用 VSCode 来调试我们的 napi-rs 应用，我们可以参考Taro 项目，在项目的 .vscode 目录下新增 launch.json 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;lldb&quot;, // 调试器类型，这里指定为lldb，通常用于C/C++/Rust等语言</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;, // 请求类型，可以是&apos;launch&apos;或&apos;attach&apos;，&apos;launch&apos;表示启动一个新的调试会话</span><br><span class="line">      &quot;name&quot;: &quot;debug-init&quot;, // 配置名称，显示在VS Code的启动配置下拉菜单中</span><br><span class="line">      &quot;sourceLanguages&quot;: [&quot;rust&quot;], // 指定源码语言，此处为Rust</span><br><span class="line">      &quot;program&quot;: &quot;node&quot;, // 要调试的程序，这里是指Node.js的可执行文件</span><br><span class="line">      &quot;args&quot;: [</span><br><span class="line">        // 程序参数，这里指定了使用node运行taro-cli包的初始化命令，创建一个名为test_pro的新项目</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/packages/taro-cli/bin/taro&quot;,</span><br><span class="line">        &quot;init&quot;,</span><br><span class="line">        &quot;test_pro&quot;</span><br><span class="line">  ],</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 当前工作目录，这里指工作区根目录</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;build binding debug&quot;, // 调试前需要执行的任务的名称，这里指定了一个任务以在调试前构建项目</span><br><span class="line">      &quot;postDebugTask&quot;: &quot;remove test_pro&quot; // 调试后需要执行的任务的名称，此处指定了一个任务以在调试后清理或删除test_pro项目</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述配置中，指定调试器类型为lldb，启动一个新的调试会话来调试我们用 Rust 编写的程序，该程序主要通过 Node.js 来执行一个初始化新项目 test_pro 的命令，在调试开始前后会飞别执行 Rust binding 的构建以及 test_pro 项目的删除。</p><p>然后在要调试的代码处添加断点，然后执行调试即可。</p><h2 id="构建发布"><a href="#构建发布" class="headerlink" title="构建发布"></a>构建发布</h2><p>napi-rs 的项目模板默认基于 <a href="https://github.com/napi-rs/package-template/blob/main/.github/workflows/CI.yml" target="_blank" rel="noopener">Github Action</a> 来实现自动构建产物及发布，并且已经有相当完整的配置了，从Github Action配置文件中可以看到 CI 具体执行的任务，CI 任务首先会执行 package.json 中的构建命令，构建出各个端的 binding，并会actions/upload-artifact@v3action 将构建产物上传，然后会对构建产物执行相关测试，测试通过后会将构建产物下载下来，并执行artifacts命令将构建产物移动到目的文件夹下，最后会进行发布，当 git 提交信息为semver规范版本号时，将会触发 CI 发布，将包发到 NPM 中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;0.0.1&apos;</span><br></pre></td></tr></table></figure></p><p>前面提到我们一般只需要针对x86_64-apple-darwin、aarch64-apple-darwin、x86_64-pc-windows-msvc、x86_64-unknown-linux-gnu这四个平台进行构建，所以我们可以调整 Github Action 配置，去掉不需要构建的平台以提升 CI 速度。</p><p>此外，当我们有特殊需求的时候，例如不需要重新生成胶水 JS 代码、需要将构建产物移动到其他目录（默认是当前目录下的 npm 目录）下等等，可以查看<a href="https://github.com/napi-rs/napi-rs/tree/main/cli" target="_blank" rel="noopener">@napi-rs/cli</a>的文档进行相应调整。</p><p>不需要重新生成胶水 JS 代码，可以通过在napi build命令下添加–no-js实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;build&quot;: &quot;napi build --platform --release --no-js --dts binding.d.ts&quot;,</span><br><span class="line">  &quot;build:debug&quot;: &quot;napi build --platform --no-js --dts binding.d.ts&quot;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要将构建产物移动到其他目录，可以通过在napi artifacts命令下添加 –cwd 和 –npm-dir 参数来实现，前者指定工作目录，后者指定要移动的目录的相对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;artifacts&quot;: &quot;napi artifacts --npm-dir ../../npm2 --cwd ./&quot;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 在前端领域的应用无疑将成为未来的重要发展趋势，随着越来越多的公司和团队开始投入到这一领域，我们看到了 Rust 在前端研发生态构建中的独特优势和潜力，Rust 的高效性和安全性使其成为优化 Node 工具的理想选择。本文简单介绍了如何使用 NAPI-RS 来开发、调试和发布 Node 扩展，可以有效地优化我们的开发工具，并提升其性能。</p><p>在未来，我们可以预见 Rust 与前端结合的可能性将会更加广泛。随着 WebAssembly（WASM）的发展，我们可以期待 Rust 将在前端应用的性能优化、复杂应用的开发以及多线程等领域发挥更大的作用。同时，Rust 的出色的内存管理和错误处理机制也将帮助前端开发者构建更加健壮、安全的应用。</p><p>当然，Rust 与前端的结合并不仅仅限于性能优化，Rust 的优秀特性，如模式匹配、类型推断和零成本抽象，也为前端开发带来了新的编程范式和思维方式，这将有助于提升前端代码的可读性和可维护性，为前端开发提供了新的思考角度和工具，并可能引领前端开发进入一个全新的阶段。</p><p><a href="https://juejin.cn/post/7321410906426998810#heading-13" target="_blank" rel="noopener">来自</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Rust构建前端工具链&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="Rust" scheme="/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>solidity进阶</title>
    <link href="/2025/03/11/solidity%E8%BF%9B%E9%98%B6/"/>
    <id>/2025/03/11/solidity进阶/</id>
    <published>2025-03-11T01:56:30.000Z</published>
    <updated>2025-03-11T05:33:38.778Z</updated>
    
    <content type="html"><![CDATA[<p>solidity进阶-ERC20代币开发<br><a id="more"></a></p><h1 id="什么是ERC"><a href="#什么是ERC" class="headerlink" title="什么是ERC"></a>什么是ERC</h1><p>ERC 全称是“Ethereum Request for Comment”，表示以太坊的意见征求稿，ERC 中包含技术和组织等注意事项及标准。这套标准其实不光由以太坊官方提出，还由一些以太坊爱好者提出。是以太坊生态系统中被广泛使用的关键标准。</p><h2 id="代币-token-标准"><a href="#代币-token-标准" class="headerlink" title="代币(token)标准"></a>代币(token)标准</h2><ul><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/" target="_blank" rel="noopener">ERC-20</a> - 同质化（可互换）代币的标准接口，比如投票代币、质押代币或虚拟货币。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/" target="_blank" rel="noopener">ERC-721</a> - 非同质化代币的标准接口，比如艺术作品或歌曲的契约。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-777/" target="_blank" rel="noopener">ERC-777</a> - 关于 ERC-20 的代币标准改进。</li><li><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/" target="_blank" rel="noopener">ERC-1155</a> - 一个能包括同质化和非同质化资产的代币标准。</li></ul><h2 id="ERC-20-代币"><a href="#ERC-20-代币" class="headerlink" title="ERC-20 代币"></a>ERC-20 代币</h2><p><code>千言万语汇成一句话：造钱</code></p><blockquote><p>什么叫做代币  代替货币 </p></blockquote><p>代币可以在以太坊中表示任何东西：</p><ul><li>在线平台中的信誉积分</li><li>游戏中一个角色的技能</li><li>彩票</li><li>金融资产类似于公司股份的资产</li><li>像美元一样的法定货币</li><li>一克黄金</li><li>以及更多</li></ul><blockquote><p>ERC-20以太坊代币标准是创建与更广泛的以太坊网络兼容的可替换代币的蓝图。以太坊，或称Ethereum，是一种加密货币，允许创建各种应用，包括代币，与大多数传统应用不同，它不需要中心化服务机构就可以运作。</p><p>简单来说，<strong>ERC-20</strong>就是一套<strong>基于以太坊网络的标准代币发行协议</strong>。有了ERC-20，<strong>开发者们得以高效、可靠、低成本地创造专属自己项目的代币；</strong>我们甚至可以将ERC-20视为以太坊网络为早期区块链世界做出的最重要贡献，也是以太坊网络第一个真正意义上的杀手级应用。</p></blockquote><p>如果我们把众多区块链项目的开发者，看作是在一个小区门口商铺里，经营不同业态的众多商户。这些商户根据自己的专长提供各自不同的商品和服务，也都希望发行自己店铺专属的消费储值卡。方便消费者光顾的同时，也能提升用户的体验和粘性</p><p>以太坊就像是运营这个小区底商的物业公司，它提供一整套标准化的储值卡发放协议和配套服务。借助这套叫做ERC-20的整体解决方案，每个商户（开发者）都可以傻瓜式地发行专属于自己店铺的消费储值卡，同时由于这种储值卡采用了统一的协议，可以非常方便地和其他商户的储值卡做无缝兑换。</p><p>于是借助ERC-20，用户可以通过持有其中一种储值卡（token）很方便地享受整个生态的各种服务；商户（开发者）则节约了开发运营成本、同时提升了获取用户的效率；而物业公司（以太坊基金会和矿工）则可以通过做大生态体量实现更多的租金（ETH增值）和储值卡结算手续费（Gas费用）收入。</p><p>ERC-20就是用这种做大生态价值的方式，实现了用户、开发者和以太坊网络三方面的共赢。</p><p><strong><em>ERC-20的应用案例</em></strong></p><p>为了让你对ERC-20有更具象化的认识，这里援引 <a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/author/alyssa.hertig" target="_blank" rel="noopener">Alyssa Hertig</a> 在 <a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">What is the ERC-20 Ethereum Token Standard?</a> 中列举的一些比较知名的基于ERC-20协议代币：</p><blockquote><p>Tether (USDT)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">Chainlink</a> (LINK)<br>Binance coin (BNB)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">USD coin</a> (USDC)<br>Wrapped bitcoin (WBTC)<br><a href="https://link.zhihu.com/?target=https%3A//www.coindesk.com/tech/2021/02/09/what-is-the-erc-20-ethereum-token-standard/" target="_blank" rel="noopener">Dai</a> (DAI)</p></blockquote><p>需要特别指出的是，这上面提到的Tether发行的稳定币USDT除了基于ERC-20协议的版本之外，其实还有基于其他公链发行的多个版本，只不过ERC-20版的发行量最大，知名度也最高。</p><h1 id="openzeppelin-智能合约库"><a href="#openzeppelin-智能合约库" class="headerlink" title="openzeppelin 智能合约库"></a>openzeppelin 智能合约库</h1><p>官网：<a href="https://www.openzeppelin.com/" target="_blank" rel="noopener">https://www.openzeppelin.com/</a></p><p>GitHub：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts</a></p><p>OpenZeppelin 是一个使用以太坊智能合约语言 Solidity 进行构建的开发框架，可以简化智能合约和 Dapp 的开发。</p><p>OpenZeppelin合约和库已成为行业标准，其开源代码模板经历了以太坊及其他区块链的实战考验，帮助开发者最大限度降低风险。OpenZeppelin代码包括使用度最高的ERC标准及拓展部署，已被社区在各类指南以及操作教程中大量使用。</p><h2 id="Contract-Wizard"><a href="#Contract-Wizard" class="headerlink" title="Contract Wizard"></a>Contract Wizard</h2><p>OpenZeppelin开发了一种基于网络的线上智能合约交互式工具，它可能是使用OpenZeppelin代码编写智能合约最简单快捷的方式。这一工具称为<a href="https://docs.openzeppelin.com/contracts/4.x/wizard" target="_blank" rel="noopener">Contracts Wizard</a>。</p><h1 id="ERC-20-代币实现"><a href="#ERC-20-代币实现" class="headerlink" title="ERC-20 代币实现"></a>ERC-20 代币实现</h1><p><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top" target="_blank" rel="noopener">https://ethereum.org/zh/developers/docs/standards/tokens/erc-20/#top</a></p><p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</a></p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20" target="_blank" rel="noopener">https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20</a></p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol" target="_blank" rel="noopener">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/ERC20.sol</a></p><p><a href="https://www.openzeppelin.com/contracts" target="_blank" rel="noopener">https://www.openzeppelin.com/contracts</a></p><p><a href="https://ethereum.org/zh/" target="_blank" rel="noopener">https://ethereum.org/zh/</a></p><p><a href="https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions" target="_blank" rel="noopener">https://www.osgeo.cn/solidity/units-and-global-variables.html#special-variables-and-functions</a></p><p>ERC-20（以太坊意见征求 20）由 Fabian Vogelsteller 提出于 2015 年 11 月。这是一个能实现智能合约中代币的应用程序接口标准。</p><p>ERC-20 的功能示例包括：</p><ul><li>将代币从一个帐户转到另一个帐户</li><li>获取帐户的当前代币余额</li><li>获取网络上可用代币的总供应量</li><li>批准一个帐户中一定的代币金额由第三方帐户使用</li></ul><p>如果智能合约实施了下列方法和事件，它可以被称为 ERC-20 代币合约， 一旦部署，将负责跟踪以太坊上创建的代币。</p><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function name() public view returns (string)</span><br><span class="line">function symbol() public view returns (string)</span><br><span class="line">function decimals() public view returns (uint8)</span><br><span class="line">function totalSupply() public view returns (uint256)</span><br><span class="line">function balanceOf(address _owner) public view returns (uint256 balance)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success)</span><br><span class="line">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span><br></pre></td></tr></table></figure><p>事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 _value)</span><br><span class="line">event Approval(address indexed _owner, address indexed _spender, uint256 _value)</span><br></pre></td></tr></table></figure><h2 id="代币1"><a href="#代币1" class="headerlink" title="代币1"></a>代币1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract QfCoin &#123;</span><br><span class="line">    event Transfer(address, address, uint256);</span><br><span class="line">    event Approval(address, address, uint256);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    // override 重载</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, string memory _symbol) &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // transfer() 函数 IERC20 中的 transfer 函数， Token 实现。调用方 amount 币会增加 Token 数量，接收方此函数相应的狗改土，加入、分红、抽奖等。</span><br><span class="line">    //  转账函数</span><br><span class="line">    function transfer(address recipient, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // approve 函数</span><br><span class="line">    // approve() 函数：IERC20 的 approve 函数， Token 授权逻辑。被授权方 spender 可以控制授权方的 amount 数量的 Token 。</span><br><span class="line">    function approve(address spender, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        allowance[msg.sender][spender] = amount;</span><br><span class="line">        emit Approval(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // transferFrom() 功能：IERC20 中的 transferFrom 函数，授权逻辑。被授权方将授权方实现 sender 的 amount 数量的 Token 授权给接收方 recipient。</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address sender,</span><br><span class="line">        address recipient,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        allowance[sender][msg.sender] -= amount;</span><br><span class="line">        balanceOf[sender] == amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(uint256 amount) public &#123;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        totalSupply += amount;</span><br><span class="line">        emit Transfer(address(0), msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代币2"><a href="#代币2" class="headerlink" title="代币2"></a>代币2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.9;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    /*</span><br><span class="line">    &#123;</span><br><span class="line">        addressA: 90,</span><br><span class="line">        addressB: 0,</span><br><span class="line">        addressC: 20,</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    event Transfer(address _from, address _to, uint256 _value);</span><br><span class="line">    event Approval(address _owner, address _spender, uint256 _value);</span><br><span class="line">    // 代币的名字与标识 数量</span><br><span class="line">    uint256 _totalSupply;</span><br><span class="line">    string _name;</span><br><span class="line">    string _symbol;</span><br><span class="line">    uint8 _decimals;</span><br><span class="line">    // 创建地址与余额的映射</span><br><span class="line">    mapping(address =&gt; uint256) _balanceOf;</span><br><span class="line">    // 创建授权额度的结构</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) _allowance;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    address1 : &#123;</span><br><span class="line">        address11:1000w</span><br><span class="line">        address22:200w</span><br><span class="line">    &#125; </span><br><span class="line">    address3:&#123;</span><br><span class="line">        address11:1000w</span><br><span class="line">        address22:200w</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        _name = &quot;HeHeCoin&quot;;</span><br><span class="line">        _symbol = &quot;HHC&quot;;</span><br><span class="line">        _decimals = 18;</span><br><span class="line">        _totalSupply = 100 * 10000 * 10**_decimals;</span><br><span class="line">        _balanceOf[msg.sender] += _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取一下代币的名字</span><br><span class="line">    function name() public view returns (string memory) &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function symbol() public view returns (string memory) &#123;</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function decimals() public view returns (uint8) &#123;</span><br><span class="line">        return _decimals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据地址获取余额</span><br><span class="line">    function balanceOf(address _owner) public view returns (uint256) &#123;</span><br><span class="line">        return _balanceOf[_owner];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转账</span><br><span class="line">    function transfer(address _to, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        _balanceOf[msg.sender] -= _value;</span><br><span class="line">        _balanceOf[_to] += _value;</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // token的逻辑授权 给被授权方一定的权限 可以直接转移授权方的同肯</span><br><span class="line">    function approve(address _spender, uint256 _value)</span><br><span class="line">        public</span><br><span class="line">        returns (bool success)</span><br><span class="line">    &#123;</span><br><span class="line">        //  调用这个方法的人</span><br><span class="line">        _allowance[msg.sender][_spender] = _value;</span><br><span class="line">        emit Approval(msg.sender, _spender, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看额度</span><br><span class="line">    function allowance(address _owner, address _spender)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return _allowance[_owner][_spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  被给与额度的账户主动的 划走代币</span><br><span class="line">    function transferFrom(</span><br><span class="line">        address _from,</span><br><span class="line">        address _to,</span><br><span class="line">        uint256 _value</span><br><span class="line">    ) public returns (bool success) &#123;</span><br><span class="line">        // 额度减少</span><br><span class="line">        _allowance[_from][_to] -= _value;</span><br><span class="line">        // 被划走账户余额减少</span><br><span class="line">        _balanceOf[_from] -= _value;</span><br><span class="line">        // 划走账户的余额添加</span><br><span class="line">        _balanceOf[_to] += _value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</span><br><span class="line">0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</span><br><span class="line">0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</span><br><span class="line">0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  : &#123;</span><br><span class="line">       0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2: 100w,</span><br><span class="line">       0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db: 50w,</span><br><span class="line">   &#125;</span><br><span class="line">   0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB : &#123;</span><br><span class="line">       0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2:666,</span><br><span class="line">       0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db:777,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  100w </span><br><span class="line">授权   0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2  666</span><br><span class="line">授权   0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db  777</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="ERC-20代币部署"><a href="#ERC-20代币部署" class="headerlink" title="ERC-20代币部署"></a>ERC-20代币部署</h1><ol><li>将环境切换切MetaMask钱包环境并选择钱包账户</li></ol><p><img src="/2025/03/11/solidity进阶/1.png" alt="image-20221212212504003"></p><ol start="2"><li>点击Deploy ，输入代币的名字和表示 部署合约</li></ol><p><img src="/2025/03/11/solidity进阶/2.png" alt="image-20221212212645585"></p><p>部署成功结果</p><p><img src="/2025/03/11/solidity进阶/3.png" alt="image-20221212213033774"></p><p>合约地址 0x639DfECe957A8D705f028D1950890598C30789ed</p><p>交易hash 0x28aa84834efc9c787c4cd584128f456e16b933eddf250859833b395656153847</p><p>在metaMask 添加代币</p><p><img src="/2025/03/11/solidity进阶/4.png" alt="image-20221212214003856"></p><p><img src="/2025/03/11/solidity进阶/5.png" alt="image-20221212214043557"></p><p>智能合约初始化的时候没有规定代币的数量，所以添加结果为0MTC</p><p><img src="/2025/03/11/solidity进阶/6.png" alt="image-20221212214148279"></p><p>后续通过mint 铸造方法，添加货币</p><p><img src="/2025/03/11/solidity进阶/7.png" alt="image-20221212214355382"></p><p>接下来就可以在测试网络中进行代币转账了</p><h1 id="Web3-js-和-ether-js-介绍"><a href="#Web3-js-和-ether-js-介绍" class="headerlink" title="Web3.js 和 ether.js 介绍"></a>Web3.js 和 ether.js 介绍</h1><p>Web3.js 和 ethers.js 都是 JavaScript 库，其作用是使开发者可以与以太坊区块链交互。这两个库都很实用，都能满足大多数以太坊开发者的需求。下面将重点围绕 Web3.js 和 Ethers.js 的相同点和不同点来对它们进行比较，以便你能更好地理解它们的细微区别。</p><p> 什么是 web3.js？ </p><p><img src="/2025/03/11/solidity进阶/8.png" alt="image.png"></p><p>Web3.js 是一个由以太坊基金会开发和维护的开源JavaScript库，使用HTTP或 IPC(Inter-Process Communication进程间通信) 连接 或 WebSocket 来和本地或远程以太坊节点进行交互的库。类比于 JavaScript库 axios 对 Web 服务器进行 Ajax 调用，您可以使用Web3.js来读取和写入以太坊区块链。</p><p>web3.js。因此，有更广泛的支持，因为有更多的开发人员支持它。</p><p>Web3.js 库由一系列模块的集合，服务于以太坊生态系统的各个功能，如：</p><p>●web3-eth 用来与以太坊区块链及合约的交互；</p><p>●web3-shh Whisper 协议相关，进行p2p通信和广播；</p><p>●web3-bzz swarm 协议（去中心化文件存储）相关；</p><p>●web3-utils 包含一些对 DApp 开发者有用的方法。</p><p>官网：<a href="https://web3js.org/" target="_blank" rel="noopener">https://web3js.org</a></p><p>GitHub: <a href="https://github.com/web3/web3.js" target="_blank" rel="noopener">https://github.com/web3/web3.js</a></p><p> 什么是 ethers.js？ </p><p>ETHERS.JS</p><p><img src="/2025/03/11/solidity进阶/9.png" alt="image.png"></p><p>ethers.js库旨在为以太坊区块链及其生态系统提供一个小而完整的 JavaScript API 库，ethers.js 对比使用 web3.js 代码量更少，接口也更简洁。</p><p>可以通过<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC" target="_blank" rel="noopener">JSON-RPC</a>、<a href="https://infura.io/" target="_blank" rel="noopener">INFURA</a>、<a href="https://etherscan.io/" target="_blank" rel="noopener">Etherscan</a>、<a href="https://alchemyapi.io/" target="_blank" rel="noopener">Alchemy</a>、<a href="https://developers.cloudflare.com/distributed-web/ethereum-gateway/" target="_blank" rel="noopener">Cloudflare</a>或<a href="https://metamask.io/" target="_blank" rel="noopener">MetaMask</a>连接到以太坊节点。</p><p>与 web3.js 相似，ethers.js 常用模块有:</p><p>●Ethers.provider 封装与以太坊区块链的连接。它可以用于签发查询和发送已签名的交易，这将改变区块链的状态。</p><p>●Ethers.contract 部署智能合约并与它交互。具体来说，该模块中的函数用于侦听从智能合约发射的事件、调用智能合约提供的函数、获取有关智能合约的信息，以及部署智能合约。</p><p>●Ethers.utils 提供用于格式化数据和处理用户输入的实用程序函数。Ethers.utils 的作用方式与 web3-utils 相似，能够简化去中心化应用的构建流程。</p><p>●Ethers.wallets 提供的功能与我们目前讨论过的其他模块截然不同。Ethers.wallet 的作用是使你可以与现有钱包（以太坊地址）建立连接、创建新钱包以及对交易签名。</p><p>官网：<a href="https://ethers.org/" target="_blank" rel="noopener">https://ethers.org</a></p><p>GitHub：<a href="https://github.com/ethers-io/ethers.js" target="_blank" rel="noopener">https://github.com/ethers-io/ethers.js</a></p><p> web3.js 和 ethers.js 该如何选择 </p><p> 作者对比 </p><p>Web3.js 所有者是<a href="https://ethereum.org/en/" target="_blank" rel="noopener">以太坊基金会</a></p><p>ethers.js 所有者是Richard Moore</p><p>两个库都能够完成任务。Ethers.js 在近两年来越来越受欢迎，下载量和项目使用量都不断增加。Web3.js 一直以来都作为标杆存在，并且仍然拥有许多开发者共享资源。后面将介绍如何连接到 <a href="https://infura.io/dashboard" target="_blank" rel="noopener">Infura API</a> 并使用 web3.js 和 ethers.js 发送交易。</p><h1 id="web3-与智能合约"><a href="#web3-与智能合约" class="headerlink" title="web3 与智能合约"></a>web3 与智能合约</h1><ol><li>获取合约部署后的配置文件  在 <code>artifacts</code> 下的的 <code>合约名.json</code>文件</li><li><img src="/2025/03/11/solidity进阶/10.png" alt="image-20221212221505979"></li></ol><p><a href="https://web3js.readthedocs.io/en/v1.8.1/" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/v1.8.1/</a></p><h2 id="window-ethereum-API"><a href="#window-ethereum-API" class="headerlink" title="window.ethereum API"></a><strong>window.ethereum API</strong></h2><p>MetaMask会向网页注入一个全局的API变量window.ethereum，出于历史遗留原因， 这个全局API变量也可以使用window.web3.currentProvider来访问。该API允许 网站请求用户登录，可以从用户接入的区块链读取数据，并切能够提示用户签名 要提交的交易。</p><p>你可以使用这个API来检测一个浏览器是否注入了window.ethereum：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ethereum !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'MetaMask is installed!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ethereum API本身很简单，它同时也封装了以太坊JSON-RPC消息，就像那些流行的库例如web3、 truffle、ethjs、Embark等等一样。</p><h3 id="ethereum-isConnected"><a href="#ethereum-isConnected" class="headerlink" title="ethereum.isConnected()"></a>ethereum.isConnected()</h3><p>如果提供者连接到当前链返回true，否则返回false。</p><p>如果提供商未连接，则必须重新加载页面才能重新建立连接。</p><h3 id="eth-requestAccounts-请求用户授权"><a href="#eth-requestAccounts-请求用户授权" class="headerlink" title="eth_requestAccounts - 请求用户授权"></a>eth_requestAccounts - 请求用户授权</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方式1</span></span><br><span class="line">ethereum.request(&#123; <span class="attr">method</span>: <span class="string">'eth_requestAccounts'</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// You now have an array of accounts!</span></span><br><span class="line">    <span class="comment">// Currently only ever one:</span></span><br><span class="line">    <span class="comment">// ['0xFDEa65C8e26263F459A1B5de9555D2931A33b825']</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason === <span class="string">"User rejected provider access"</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="ethereum-selectedAddress-获取当前用户账号"><a href="#ethereum-selectedAddress-获取当前用户账号" class="headerlink" title="ethereum.selectedAddress - 获取当前用户账号"></a>ethereum.selectedAddress - 获取当前用户账号</h3><p>ethereum.selectedAddress 属性返回表示用户当前选择的以太坊账号，16进制字符串表示</p><h3 id="ethereum-isMetaMask-检测是否使用MetaMask"><a href="#ethereum-isMetaMask-检测是否使用MetaMask" class="headerlink" title="ethereum.isMetaMask - 检测是否使用MetaMask"></a>ethereum.isMetaMask - 检测是否使用MetaMask</h3><p>ethereum.isMetaMask返回true或false，表示当前用户是否安装了MetaMask。</p><h3 id="ethereum-autoRefreshOnNetworkChange-网络切换时是否自动刷新"><a href="#ethereum-autoRefreshOnNetworkChange-网络切换时是否自动刷新" class="headerlink" title="ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新"></a>ethereum.autoRefreshOnNetworkChange - 网络切换时是否自动刷新</h3><p>当用户切换网络时，MetaMask扩展会自动刷新。 ethereum.autoRefreshOnNetworkChange这个实验性质的属性允许你关闭 默认的网络切换自动刷新功能。</p><h3 id="ethereum-on-监听MetaMask事件"><a href="#ethereum-on-监听MetaMask事件" class="headerlink" title="ethereum.on() - 监听MetaMask事件"></a>ethereum.on() - 监听MetaMask事件</h3><p>ethereum.on()方法用来监听MetaMask的事件，其原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethereum.on(eventName, callback)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>eventName：要监听的事件名称</li><li>callback：事件触发时的回调函数</li></ul><p>目前支持下列事件：</p><ul><li>accountsChanged：当用户选中账号变化时触发</li><li>networkChanged：当所连接网络ID变化时触发</li></ul><p>注意：networkChanged事件只有当你禁用ethereum.autoRefreshOnNetworkChange属性时才有用。</p><p>下面的代码在用户切换MetaMask账号后输出新账号到控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ethereum.on(<span class="string">'accountsChanged'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(accounts[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="调用智能合约-MetaMask"><a href="#调用智能合约-MetaMask" class="headerlink" title="调用智能合约(MetaMask)"></a>调用智能合约(MetaMask)</h2><h3 id="实例web3"><a href="#实例web3" class="headerlink" title="实例web3"></a>实例web3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="keyword">import</span> mtcContract <span class="keyword">from</span> <span class="string">"./contracts/contract_Ballot.json"</span>;</span><br><span class="line"><span class="comment">// 链接上web3 格尔丽的环境</span></span><br><span class="line"><span class="keyword">const</span> geerliWS =</span><br><span class="line">  <span class="string">"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb"</span>;</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || geerliWS);</span><br></pre></td></tr></table></figure><h3 id="账户链接"><a href="#账户链接" class="headerlink" title="账户链接"></a>账户链接</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> account = <span class="keyword">await</span> web3.eth.requestAccounts();</span><br></pre></td></tr></table></figure><h3 id="实例合约"><a href="#实例合约" class="headerlink" title="实例合约"></a>实例合约</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> web3.eth.Contract(智能合约abi,合约地址)</span><br><span class="line"><span class="keyword">this</span>.votoContract = <span class="keyword">new</span> web3.eth.Contract(</span><br><span class="line">      mtcContract.abi,</span><br><span class="line">      <span class="string">"0x1D108E4B9162668e1adACD07727b3de749818d0a"</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>不需要消耗gas的方法 call (不修改数据的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.methods.myMethod([param1[, param2[, ...]]]).call(options [, defaultBlock] [, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the callback</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).call(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using the promise</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).call(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改数据消耗gas的方法 send</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.methods.myMethod([param1[, param2[, ...]]]).send(options[, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the callback</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).send(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, transactionHash</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using the promise</span></span><br><span class="line">myContract.methods.myMethod(<span class="number">123</span>).send(&#123;<span class="attr">from</span>: <span class="string">'0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'</span>&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">receipt</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// receipt can also be a new contract instance, when coming from a "contract.deploy(&#123;...&#125;).send()"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意:数据修改完成后根据需求监听<code>receipt</code>事件</p></li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.events.MyEvent([options][, callback])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myContract.events.MyEvent(&#123;</span><br><span class="line">    filter: &#123;<span class="attr">myIndexedParam</span>: [<span class="number">20</span>,<span class="number">23</span>], <span class="attr">myOtherIndexedParam</span>: <span class="string">'0x123456789...'</span>&#125;, <span class="comment">// Using an array means OR: e.g. 20 or 23</span></span><br><span class="line">    fromBlock: <span class="number">0</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, event</span>)</span>&#123; <span class="built_in">console</span>.log(event); &#125;)</span><br><span class="line">.on(<span class="string">"connected"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">subscriptionId</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(subscriptionId);</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event); <span class="comment">// same results as the optional callback above</span></span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'changed'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// remove event from local database</span></span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, receipt</span>) </span>&#123; <span class="comment">// If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;web3 与智能合约&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;代币信息&lt;/h1&gt;</span><br><span class="line">    名称: &#123;&#123; name  &#125;&#125; &lt;br&gt;</span><br><span class="line">    标识: &#123;&#123; symbol &#125;&#125; &lt;br&gt;</span><br><span class="line">    发行量 &#123;&#123; web3.utils.fromWei(totalSupply,&quot;ether&quot; ) &#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;账户信息&lt;/h2&gt;</span><br><span class="line">    地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br&gt;</span><br><span class="line">    余额: &#123;&#123;web3.utils.fromWei(balanceOf,&quot;ether&quot;)&#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;操作&lt;/h2&gt;</span><br><span class="line">    收款方: &lt;input type=&quot;text&quot; v-model=&quot;toAddress&quot;&gt; &lt;br&gt;</span><br><span class="line">    金额:&lt;input type=&quot;text&quot; v-model=&quot;money&quot;&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;转账&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const Web3 = require(&quot;web3&quot;);</span><br><span class="line">import &#123; abi &#125; from &quot;./contracts/HHC.json&quot;;</span><br><span class="line">console.log(abi);</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name:&quot;&quot;,</span><br><span class="line">      symbol:&quot;&quot;,</span><br><span class="line">      totalSupply: &quot;&quot;,</span><br><span class="line">      balanceOf: &quot;&quot;,</span><br><span class="line">      accounts:[],</span><br><span class="line">      toAddress: &quot;0xE251ddBe6191594922bfd3d338529EC9C613eB67&quot;,</span><br><span class="line">      money:1,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 初始化web3实例</span><br><span class="line">    async initWeb3() &#123;</span><br><span class="line">      const geerliWS =</span><br><span class="line">        &quot;wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;;</span><br><span class="line">      this.web3 = new Web3(Web3.givenProvider || geerliWS);</span><br><span class="line">      // 获取metamask钱包使用的用户</span><br><span class="line">      this.accounts = await this.web3.eth.requestAccounts();</span><br><span class="line">      console.log( this.accounts)</span><br><span class="line">      this.initContract();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化智能合约</span><br><span class="line">    initContract() &#123;</span><br><span class="line">      // 代币 hhc 智能合约地址</span><br><span class="line">      this.HccCont = new this.web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        &quot;0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5&quot;</span><br><span class="line">      );</span><br><span class="line">      this.getCoinInfo();</span><br><span class="line">      this.addEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取代币的信息</span><br><span class="line">    async getCoinInfo() &#123;</span><br><span class="line">      // 不修改状态数据 不消耗gas</span><br><span class="line">      this.name = await this.HccCont.methods.name().call();</span><br><span class="line">      this.symbol = await this.HccCont.methods.symbol().call();</span><br><span class="line">      this.totalSupply = await this.HccCont.methods.totalSupply().call();</span><br><span class="line">      this.balanceOf = await this.HccCont.methods.balanceOf(this.accounts[0]).call();</span><br><span class="line">    &#125;,</span><br><span class="line">    send() &#123;</span><br><span class="line">      // 修改状态数据</span><br><span class="line">      const weiNum = this.web3.utils.toWei(String(this.money), &apos;ether&apos;);</span><br><span class="line">      console.log(weiNum)</span><br><span class="line">      this.HccCont.methods.transfer(this.toAddress,weiNum).send(&#123;</span><br><span class="line">        from: this.accounts[0],</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(&apos;receipt&apos;, function(receipt)&#123;</span><br><span class="line">        console.log(&quot;交易成功&quot;)</span><br><span class="line">        console.log(receipt)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    addEvents() &#123;</span><br><span class="line">      this.HccCont.events.Transfer(&#123;</span><br><span class="line">        filter: &#123;&#125;,</span><br><span class="line">        fromBlock: 8161338,</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(&quot;data&quot;,(event) =&gt; &#123;</span><br><span class="line">        console.log(&quot;events transfer&quot;);</span><br><span class="line">        console.log(event)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    if (typeof window.ethereum !== &quot;undefined&quot;) &#123;</span><br><span class="line">      console.log(&quot;MetaMask is installed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.initWeb3();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="调用智能合约-纯web3"><a href="#调用智能合约-纯web3" class="headerlink" title="调用智能合约(纯web3)"></a>调用智能合约(纯web3)</h2><blockquote><p>调用智能合约也相当于是通过web3 发起一个交易</p><p>核心在于  web3.eth.sendSignedTransaction(transHash)</p><p>在构建hash数据时候将调用的合约信息添加进入</p></blockquote><h3 id="构建调用智能合约交易hash"><a href="#构建调用智能合约交易hash" class="headerlink" title="构建调用智能合约交易hash"></a>构建调用智能合约交易hash</h3><p>将智能合约的方法调用 通过<code>encodeABI</code>进行转化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contractData = <span class="keyword">await</span> contract.methods.transfer(<span class="string">"转账地址"</span>,web3.utils.toWei(<span class="string">'转账金额'</span>)).encodeABI()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建交易hash</span></span><br><span class="line"><span class="keyword">async</span> createTransationHx(key, fromAddress, toAddress, money) &#123;</span><br><span class="line">  <span class="comment">// key 私钥</span></span><br><span class="line">  <span class="comment">// fromAddress 发送方地址</span></span><br><span class="line">  <span class="comment">// toAddress 接受方地址</span></span><br><span class="line">  <span class="comment">// money 转账金额</span></span><br><span class="line">  <span class="comment">// 当前地址交易次数</span></span><br><span class="line">  <span class="keyword">const</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromAddress);</span><br><span class="line">  <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">  <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">  <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.utils.toWei(money);</span><br><span class="line"><span class="keyword">const</span> contractData = <span class="keyword">await</span> contract.methods.transfer(<span class="string">"0x9B0DbF610175F5c783ec169DAdDa5E8B17055626"</span>,web3.utils.toWei(<span class="string">'30000'</span>)).encodeABI()</span><br><span class="line">  <span class="comment">// 转账的记录对象</span></span><br><span class="line">  <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">    <span class="keyword">from</span>: fromAddress,</span><br><span class="line">    nonce: nonce,</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">    to:<span class="string">""</span>,<span class="comment">//智能合约地址,</span></span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    data: contractData, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">  <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">  rawTx.gas = gas;</span><br><span class="line">  <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">  <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">  tx.sign(privateKey);</span><br><span class="line">  <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">  <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">  <span class="keyword">return</span> transationHx;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="常规转账发起"><a href="#常规转账发起" class="headerlink" title="常规转账发起"></a>常规转账发起</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> sendToken() &#123;</span><br><span class="line">     <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">     <span class="keyword">let</span> keystore = <span class="keyword">this</span>.walletInfo.keystore;</span><br><span class="line">     <span class="keyword">let</span> wallet;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">       alert(<span class="string">"密码错误"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(prikey)</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">from</span>  = <span class="keyword">this</span>.walletInfo.lowerCaseAddress;</span><br><span class="line">     <span class="keyword">const</span> to = <span class="keyword">this</span>.to;</span><br><span class="line">     <span class="keyword">const</span> money = <span class="keyword">this</span>.money;</span><br><span class="line">     <span class="comment">// 获取交易hx</span></span><br><span class="line">     <span class="keyword">const</span> transHash = <span class="keyword">await</span> <span class="keyword">this</span>.createTransationHx(prikey,<span class="keyword">from</span>,to,money)</span><br><span class="line">     <span class="comment">// 发布交易信息</span></span><br><span class="line">     web3.eth</span><br><span class="line">       .sendSignedTransaction(transHash)</span><br><span class="line">       .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">       &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">         <span class="keyword">const</span> &#123; transactionHash &#125; = ret;</span><br><span class="line">         <span class="comment">// 从区块节点中获取交易hash</span></span><br><span class="line">         <span class="keyword">this</span>.createOrderData(transactionHash);</span><br><span class="line">       &#125;)</span><br><span class="line">       .on(<span class="string">'confirmation'</span>, (ret)=&gt;&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'confirmation'</span>,ret)</span><br><span class="line">       &#125;)</span><br><span class="line">       .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;web3 与智能合约&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;代币信息&lt;/</span>h1&gt;</span><br><span class="line">    名称: &#123;&#123; name &#125;&#125; &lt;br /&gt;</span><br><span class="line">    标识: &#123;&#123; symbol &#125;&#125; &lt;br /&gt;</span><br><span class="line">    发行量 &#123;&#123; web3.utils.fromWei(totalSupply, <span class="string">"ether"</span>) &#125;&#125; &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;账户信息&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    地址: &#123;&#123; accounts[0] &#125;&#125; &lt;br /</span>&gt;</span><br><span class="line">    eth余额: &#123;&#123; web3.utils.fromWei(ethBalance, <span class="string">"ether"</span>) &#125;&#125;&lt;br /&gt;</span><br><span class="line">    代币余额: &#123;&#123; web3.utils.fromWei(balanceOf, <span class="string">"ether"</span>) &#125;&#125; &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;操作&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    收款方: &lt;input type="text" v-model="toAddress" /</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    金额:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"money"</span> /&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">    &lt;button @click=<span class="string">"send"</span>&gt;代币转账&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="sendEth"&gt;转账Eth&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>);</span><br><span class="line"><span class="keyword">const</span> Tx = <span class="built_in">require</span>(<span class="string">"ethereumjs-tx"</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; abi &#125; <span class="keyword">from</span> <span class="string">"./contracts/HHC.json"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(abi);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">""</span>,</span><br><span class="line">      symbol: <span class="string">""</span>,</span><br><span class="line">      totalSupply: <span class="string">""</span>,</span><br><span class="line">      balanceOf: <span class="string">""</span>,</span><br><span class="line">      accounts: [],</span><br><span class="line">      toAddress: <span class="string">"0xE251ddBe6191594922bfd3d338529EC9C613eB67"</span>,</span><br><span class="line">      money: <span class="string">"1"</span>,</span><br><span class="line">      ethBalance: <span class="string">"0"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 初始化web3实例</span></span><br><span class="line">    <span class="keyword">async</span> initWeb3() &#123;</span><br><span class="line">      <span class="keyword">const</span> geerliWS =</span><br><span class="line">        <span class="string">"wss://goerli.infura.io/ws/v3/e4f789009c9245eeaad1d93ce9d059bb"</span>;</span><br><span class="line">      <span class="keyword">this</span>.web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || geerliWS);</span><br><span class="line">      <span class="comment">// 获取metamask钱包使用的用户</span></span><br><span class="line">      <span class="keyword">this</span>.accounts = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.requestAccounts();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.accounts);</span><br><span class="line">      <span class="keyword">this</span>.ethBalance = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getBalance(<span class="keyword">this</span>.accounts[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.ethBalance);</span><br><span class="line">      <span class="keyword">this</span>.initContract();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 初始化智能合约</span></span><br><span class="line">    initContract() &#123;</span><br><span class="line">      <span class="comment">// 代币 hhc 智能合约地址</span></span><br><span class="line">      <span class="keyword">this</span>.HccCont = <span class="keyword">new</span> <span class="keyword">this</span>.web3.eth.Contract(</span><br><span class="line">        abi,</span><br><span class="line">        <span class="string">"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">this</span>.getCoinInfo();</span><br><span class="line">      <span class="keyword">this</span>.addEvents();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取代币的信息</span></span><br><span class="line">    <span class="keyword">async</span> getCoinInfo() &#123;</span><br><span class="line">      <span class="comment">// 不修改状态数据 不消耗gas</span></span><br><span class="line">      <span class="keyword">this</span>.name = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.name().call();</span><br><span class="line">      <span class="keyword">this</span>.symbol = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.symbol().call();</span><br><span class="line">      <span class="keyword">this</span>.totalSupply = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.totalSupply().call();</span><br><span class="line">      <span class="keyword">this</span>.balanceOf = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods</span><br><span class="line">        .balanceOf(<span class="keyword">this</span>.accounts[<span class="number">0</span>])</span><br><span class="line">        .call();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过metamask 调用智能合约</span></span><br><span class="line">    send() &#123;</span><br><span class="line">      <span class="comment">// 修改状态数据</span></span><br><span class="line">      <span class="keyword">const</span> weiNum = <span class="keyword">this</span>.web3.utils.toWei(<span class="built_in">String</span>(<span class="keyword">this</span>.money), <span class="string">"ether"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(weiNum);</span><br><span class="line">      <span class="keyword">this</span>.HccCont.methods</span><br><span class="line">        .transfer(<span class="keyword">this</span>.toAddress, weiNum)</span><br><span class="line">        .send(&#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="keyword">this</span>.accounts[<span class="number">0</span>],</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">receipt</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易成功"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(receipt);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 生成交易的hash 数据</span></span><br><span class="line">    <span class="keyword">async</span> createTransationHx(prikey,<span class="keyword">from</span>,to,money) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"money"</span>,<span class="keyword">typeof</span> money, money)</span><br><span class="line">       <span class="comment">// 当前地址交易次数</span></span><br><span class="line">      <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(prikey, <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">      <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getGasPrice();</span><br><span class="line">      <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">this</span>.web3.utils.toWei(money);</span><br><span class="line">      <span class="comment">// 转账的记录对象</span></span><br><span class="line">      <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        nonce: nonce,</span><br><span class="line">        gasPrice: gasPrice,</span><br><span class="line">        to,<span class="comment">//智能合约地址,</span></span><br><span class="line">        value: value,</span><br><span class="line">        data:<span class="string">""</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">       <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.estimateGas(rawTx);</span><br><span class="line">       rawTx.gas = gas;</span><br><span class="line">        <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">      <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">      <span class="keyword">return</span> transationHx;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代币转账</span></span><br><span class="line">    <span class="keyword">async</span> createCoinTransationHx(prikey,<span class="keyword">from</span>,to,money) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"money"</span>,<span class="keyword">typeof</span> money, money)</span><br><span class="line">       <span class="comment">// 当前地址交易次数</span></span><br><span class="line">      <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(prikey, <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">      <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.getGasPrice();</span><br><span class="line">      <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">this</span>.web3.utils.toWei(money);</span><br><span class="line">      <span class="comment">// 转账的记录对象</span></span><br><span class="line">      <span class="comment">// 代币转账</span></span><br><span class="line">      <span class="keyword">const</span> contractAbi = <span class="keyword">await</span> <span class="keyword">this</span>.HccCont.methods.transfer(to,value).encodeABI();</span><br><span class="line">      <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">        <span class="keyword">from</span>,</span><br><span class="line">        nonce: nonce,</span><br><span class="line">        gasPrice: gasPrice,</span><br><span class="line">        to:<span class="string">'0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5'</span>,<span class="comment">//eth 转账 to 目标地址 ，智能合约 to 智能合约地址</span></span><br><span class="line">        value: <span class="number">0</span>, <span class="comment">//eth 转账 数量</span></span><br><span class="line">        data:contractAbi, <span class="comment">//智能合约方法的abi编码</span></span><br><span class="line">      &#125;;</span><br><span class="line">       <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">       <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.web3.eth.estimateGas(rawTx);</span><br><span class="line">       rawTx.gas = gas;</span><br><span class="line">        <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">      <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">      <span class="keyword">return</span> transationHx;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过纯web3调用智能合约</span></span><br><span class="line">    <span class="keyword">async</span> sendEth() &#123;</span><br><span class="line">      <span class="keyword">const</span> prikey =</span><br><span class="line">        <span class="string">"71676f2ff44e36e78a276b16ac389ee8536790c8dfb12392c002050d6f162902"</span>;</span><br><span class="line">      <span class="comment">// 获取转账的hash</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">from</span> = <span class="keyword">this</span>.accounts[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 代币hash</span></span><br><span class="line">      <span class="keyword">const</span> transHash = <span class="keyword">await</span> <span class="keyword">this</span>.createCoinTransationHx(prikey, <span class="keyword">from</span>, <span class="keyword">this</span>.toAddress, <span class="keyword">this</span>.money);</span><br><span class="line">      <span class="comment">// 珠链币的hash</span></span><br><span class="line">      <span class="comment">// const transHash = await this.createTransationHx(prikey, from, this.toAddress, this.money);</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"transHash"</span>,transHash);</span><br><span class="line">      <span class="comment">// 发起交易</span></span><br><span class="line">      <span class="keyword">this</span>.web3.eth</span><br><span class="line">        .sendSignedTransaction(transHash)</span><br><span class="line">        .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    addEvents() &#123;</span><br><span class="line">      <span class="keyword">this</span>.HccCont.events</span><br><span class="line">        .Transfer(&#123;</span><br><span class="line">          filter: &#123;&#125;,</span><br><span class="line">          fromBlock: <span class="number">8161338</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .on(<span class="string">"data"</span>, (event) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"events transfer"</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(event);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.ethereum !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"MetaMask is installed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.initWeb3();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solidity进阶-ERC20代币开发&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>solidity入门</title>
    <link href="/2025/03/11/solidity%E5%85%A5%E9%97%A8/"/>
    <id>/2025/03/11/solidity入门/</id>
    <published>2025-03-11T01:53:27.000Z</published>
    <updated>2025-03-11T05:23:41.472Z</updated>
    
    <content type="html"><![CDATA[<p>solidity语法基础入门<br><a id="more"></a></p><h1 id="Solidity-开发环境"><a href="#Solidity-开发环境" class="headerlink" title="Solidity 开发环境"></a>Solidity 开发环境</h1><ol><li>Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。</li><li>以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常用的以太坊开发环境包括Truffle、Embark和Buidler （Hardhat）。</li><li>以太坊虚拟机：以太坊虚拟机（Ethereum Virtual Machine，EVM）是以太坊区块链的运行环境，用于在以太坊区块链上运行智能合约。常用的以太坊虚拟机包括ganache-cli和geth。</li><li>以太坊浏览器：以太坊浏览器是一种用于浏览、搜索和交互以太坊区块链数据的工具。常用的以太坊浏览器包括Etherscan、Etherchain和Blockchain Explorer。</li></ol><h2 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a><a href="https://hardhat.org/" target="_blank" rel="noopener">Hardhat</a></h2><p><a href="https://hardhat.org/" target="_blank" rel="noopener">https://hardhat.org/</a></p><p>Hardhat是目前最好的框架之一，支持快速测试，同时提供了最好的教程和最简单的集成。 老实说，每个喜欢JS框架的人都应该在某个时候试用Hardhat。它真的很容易上手，具有快速的测试， 而且入门非常简单。Hardhat的Discord也总是非常迅速地回答问题，因此，如果遇到问题，你 总是可以寻求帮助。Hathat使用Waffle和Ethers.js进行测试 —— 可以说是更好的JavaScript 智能合约框架 —— 开发人员的生活质量确实能得到一些改善。</p><p>Hardhat还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 这个项目给人一种很棒的感觉：很干净。它会执行你想要的操作。真的很快。该项目正在不断改进， Hardhat显然致力于使智能合约开发人员的生活更轻松。</p><p>Hardhat概要：</p><p>ETH基金会资助的项目，以前的名字是Builder<br>技术：Javascript，Web3.js和Ethers.js插件，OpenZeppelin可升级合同插件， Etherscan插件，区块链分叉<br>区块链：Hardhat运行时环境/本地、测试网、主网<br>测试支持：Waffle<br>维护：非常活跃<br>支持：活跃<br>开源</p><h2 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h2><p><a href="https://trufflesuite.com/" target="_blank" rel="noopener">https://trufflesuite.com/</a></p><p>几年来Truffle一直是以太坊智能合约的默认开发框架，这是有充分理由的。 Truffle是一个强大的框架，为其他许多人树立了标准。你很容易找到使用此平台的项目， 因此查找示例很容易。Truffle也可以很容易地与它的姊妹工具Drizzle和Ganache集成在一起。 特别是Ganache，它是工程师运行本地区块链的最流行方法之一。对于那些正在寻找更多工具的人， 你可以为升级的Truffle团队帐户付费，并可以访问智能合约的持续集成，可视化部署和监视。 Truffle还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 Truffle的开发团队显然是一群有才华的工程师，他们想要使世界成为一个更好的智能合约场所。</p><p>Truffle测试的运行速度不如hardhat那样快，并且由于用户数量众多，获得支持可能很困难。 我很期待看到被ConsenSys收购后他们将如何改善这个项目。Truffle的文档质量似乎开始下降 并且很难遵循，但是如果你用Google搜索遇到的错误，则很可能会遇到遇到该错误并已解决的人。 我发现改善项目的一些最佳方法是在GitHub上发布问题。无论如何，保持生态系统不断壮大是我们 的开源职责！</p><p>由于几乎每个人都熟悉它，因此获得同行的支持通常很容易。我真的希望看到团队在这个项目 上获得更多支持，因为他们有这么多用户。我希望他们能看到本文并致力于改善其文档，以使 其能够继续作为测试和部署智能合约的首选平台之一。</p><p>Truffle概要：</p><p>使用最广泛的平台；最近被ConsenSys收购（2020年11月）<br>技术：Javascript，Web3.js，OpenZeppelin可升级合同插件，Etherscan插件，区块链分叉<br>区块链：Ganache /本地，测试网，主网<br>有测试<br>维护：非常活跃<br>支持：活跃<br>开源，可以付费升级</p><h2 id="Embark"><a href="#Embark" class="headerlink" title="Embark"></a>Embark</h2><p>Embark是整个DAPP框架。这是一个全栈的区块链平台。在Gitter的 一些帮助下，我能够将Chainlink合约部署到Kovan网络。它带有一个UI，允许你在GUI中与区块链 和合约进行交互。Embark有一段学习曲线，我没有花足够的时间来克服，但它展示了其潜力。这就是 为什么我想将其包括在这里的原因，因为我觉得我没有完全消化很多东西。</p><p>我希望看到人们更多地尝试该框架并看到其功能。由于在项目中花费的时间有限，我觉得我可能 无法在这里做到公正。我确实认为将前端与后端解耦仍然是最佳做法，但是如果你需要启动一个 具有良好前端的项目并且不关心解耦，那么您应该100％尝试这个项目。</p><p>这是一个很酷的项目，如果有人喜欢Hardhat和Truffle，并且又想与全栈解决方案集成，那么我愿意 推荐Embark给他。</p><p>Embark概要：</p><p>具有大量功能的JavaScript框架用于前端开发<br>技术：JavaScript，Web3.js，代理合约支持<br>区块链：Ganache /本地，测试网，主网<br>支持测试<br>维护：轻度活跃<br>支持：活跃<br>开源</p><h1 id="Remix基本使用"><a href="#Remix基本使用" class="headerlink" title="Remix基本使用"></a>Remix基本使用</h1><p>Remix 是以太坊智能合约编程语言Solidity IDE，其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。<br><a href="https://remix.ethereum.org/" target="_blank" rel="noopener">官网</a> <a href="https://remix.ethereum.org/。" target="_blank" rel="noopener">https://remix.ethereum.org/。</a></p><h2 id="Remix基本功能"><a href="#Remix基本功能" class="headerlink" title="Remix基本功能"></a>Remix基本功能</h2><p><img src="/2025/03/11/solidity入门/1.png" alt="image-20221208134636521"></p><h2 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h2><ol><li><p>如上图创建一个空的工作空间</p></li><li><p>在工作空间下创建一个智能合约文件,ex: <code>HelloWord.sol</code></p><ul><li>智能合约文件以<code>.sol</code>结尾，</li><li>文件名采用大驼峰命名法</li><li>文件名和合约名保持一致</li></ul></li><li><p>编写合约代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/2.png" alt="image-20221208140310359"></p></li></ol><h2 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h2><p><img src="/2025/03/11/solidity入门/3.png" alt="image-20221208140810607"></p><p>编译结果：</p><p>目录产生一个<code>artifacts</code> 文件夹</p><p><img src="/2025/03/11/solidity入门/4.png" alt="image-20221208140957454"></p><h2 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h2><ol><li>通过第四个菜单进入部署界面</li><li>选择部署环境</li><li>选择部署合约的账户地址</li><li>设置gas限制</li><li>选择要部署的合约</li><li><p><code>deploy</code>按钮进行部署</p><p><img src="/2025/03/11/solidity入门/5.png" alt="image-20221208141436813"></p></li></ol><p>部署成功效果</p><p><img src="/2025/03/11/solidity入门/6.png" alt="image-20221208141815165"></p><h2 id="合约调试"><a href="#合约调试" class="headerlink" title="合约调试"></a>合约调试</h2><ol><li>通过函数的返回值查看变量</li></ol><p><img src="/2025/03/11/solidity入门/7.png" alt="image-20221208142340517"></p><ol start="2"><li>event Log </li></ol><p>​       solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/8.png" alt="image-20221208145721522"></p><h1 id="本地部署ReMix-IDE"><a href="#本地部署ReMix-IDE" class="headerlink" title="本地部署ReMix IDE"></a>本地部署ReMix IDE</h1><p>在线Remix访问缓慢，如果你有很好的网络环境也可以本地部署一套。<br>在本地部署Remix需要准备两个东西：一个是Remix-project，可以理解为Remix的前端；另一个是Remixd，可以理解为Remix的后端，它们的Github仓库地址分别是：<br><a href="https://github.com/ethereum/remix-project" target="_blank" rel="noopener">https://github.com/ethereum/remix-project</a><br><a href="https://github.com/ethereum/remix-project/tree/master/libs/remixd" target="_blank" rel="noopener">https://github.com/ethereum/remix-project/tree/master/libs/remixd</a></p><h2 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h2><p>如果要运行合并到主分支中的最新更改，请运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:latest</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:latest</span><br></pre></td></tr></table></figure><p>如果你想运行最新的 remix-live 版本运行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:remix_live</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:remix_live</span><br></pre></td></tr></table></figure><h2 id="docker-compose方式安装"><a href="#docker-compose方式安装" class="headerlink" title="docker-compose方式安装"></a>docker-compose方式安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> pull</span><br><span class="line">docker<span class="literal">-compose</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure><h2 id="部署-Remixd"><a href="#部署-Remixd" class="headerlink" title="部署 Remixd"></a>部署 Remixd</h2><p>Remixd 的安装使用步骤如下：</p><p>1.通过 npm 或者 yarn 安装 Remixd（建议用yarn）</p><p>npm 命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> @remix<span class="literal">-project</span>/remixd</span><br><span class="line">yarn add global @remix<span class="literal">-project</span>/remixd</span><br></pre></td></tr></table></figure><p>2.启动 Remix-IDE</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remixd <span class="literal">-s</span> ./shared_project <span class="literal">-u</span> http://localhost:<span class="number">8080</span></span><br></pre></td></tr></table></figure><p>3.在 Remix-IDE 上点两下</p><p>一个点 Solidity，选择相应环境；另一个点 Connect to Localhost，连接本地环境</p><p><img src="/2025/03/11/solidity入门/9.png" alt></p><p><img src="/2025/03/11/solidity入门/10.png" alt></p><h1 id="Solidity基础介绍"><a href="#Solidity基础介绍" class="headerlink" title="Solidity基础介绍"></a>Solidity基础介绍</h1><h2 id="认识一个最简单的存储合约"><a href="#认识一个最简单的存储合约" class="headerlink" title="认识一个最简单的存储合约"></a>认识一个最简单的存储合约</h2><p><img src="/2025/03/11/solidity入门/11.png" alt="image-20221214103704773"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">import &quot;&quot;;</span><br><span class="line">// 导入</span><br><span class="line"></span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    // 状态变量  </span><br><span class="line">    // 函数</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="授权协议"><a href="#授权协议" class="headerlink" title="授权协议"></a>授权协议</h3><ul><li>默认情况下，在发布源代码时加入机器可读许可证说明是很重要的。由于提供源代码总是涉及版权方面的法律问题，Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符,比如：<code>// SPDX-License-Identifier: MIT</code></li></ul><p>至于什么是SPDX 大家可以参考如下资料：</p><p>首先是SPDX，这是个组织名，其网站为：<br><a href="https://spdx.org/licenses/" target="_blank" rel="noopener">SPDX 许可证列表 |软件包数据交换 （SPDX）</a><br>SPDX-License-Identifier 组合起来就是在指SPDX的许可证列表<br>后面的格式为 ：+ SPDX的许可证列表中的某个许可证</p><p>比如上面例子中的MIT 许可：</p><p>MIT 基本信息<br>全名：MIT License <a href="https://spdx.org/licenses/MIT.html" target="_blank" rel="noopener">麻省理工学院许可证</a> 标志符：<a href="https://zh.wikipedia.org/zh-cn/MIT許可證" target="_blank" rel="noopener">MIT</a><br>MIT的具体内容<br>特此免费授予获得（“软件”）副本的任何人不受限制地处理本软件的许可，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或出售本软件副本的权利</p><h3 id="Solidity版本限制"><a href="#Solidity版本限制" class="headerlink" title="Solidity版本限制"></a>Solidity版本限制</h3><ul><li>第二行是告诉编译器源代码所适用的Solidity版本为&gt;=0.7.0 及 &lt;0.9.0 。这样的说明是为了确保合约不会在新的编译器版本中发生异常的行为。关键字 <code>pragma</code> 是告知编译器如何处理源代码的通用指令</li></ul><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>在一个去中心化的世界，我们的程序并不紧紧活一台机器的CPU 上, 在一个去中心化的世界是由很多节点组成的P2P 网络。合约代码会在各节点上[<a href="https://ethereum.org/en/developers/docs/nodes-and-clients/" target="_blank" rel="noopener">Full Node</a>]单独运行，而事实上P2P的各节点相互之间都不信任的，所以每个节点都会存一份自己的状态（Distributed Ledger,分布式账本），在该示例就是name，当调用set()的时候，大家都改变了name，此时需要一种共识机制（PoS），如果PoS认为name合法，此次调用完成。 否则回滚上一个name的值，因此每一次改变状态变量的调用都是以一个事务Transcation来执行。</p><h2 id="Api文档"><a href="#Api文档" class="headerlink" title="Api文档"></a>Api文档</h2><p><a href="https://solidity-by-example.org/" target="_blank" rel="noopener">https://solidity-by-example.org/</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p><strong>局部变量</strong></p></li><li><ul><li>在函数内部声明</li><li>不存储到链上</li></ul></li><li><p><strong>状态变量</strong></p></li><li><ul><li>在函数外部声明</li><li>状态变量是永久地存储在链上的值。</li></ul></li><li><p><strong>全局变量</strong> </p></li><li><ul><li>内置提供有关区块链的信息比如<code>block</code>、<code>msg</code>等</li></ul><p>全局变量 </p></li></ul><p>这些是全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">返回</th></tr></thead><tbody><tr><td style="text-align:left">blockhash(uint blockNumber) returns (bytes32)</td><td style="text-align:left">给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td></tr><tr><td style="text-align:left">block.coinbase (address payable)</td><td style="text-align:left">当前区块矿工的地址</td></tr><tr><td style="text-align:left">block.difficulty (uint)</td><td style="text-align:left">当前区块的难度</td></tr><tr><td style="text-align:left">block.gaslimit (uint)</td><td style="text-align:left">当前区块的gaslimit</td></tr><tr><td style="text-align:left">block.number (uint)</td><td style="text-align:left">当前区块的number</td></tr><tr><td style="text-align:left">block.timestamp (uint)</td><td style="text-align:left">当前区块的时间戳，为unix纪元以来的秒</td></tr><tr><td style="text-align:left">gasleft() returns (uint256)</td><td style="text-align:left">剩余 gas</td></tr><tr><td style="text-align:left">msg.data (bytes calldata)</td><td style="text-align:left">完成 calldata</td></tr><tr><td style="text-align:left">msg.sender (address payable)</td><td style="text-align:left">消息发送者 (当前 caller)</td></tr><tr><td style="text-align:left">msg.sig (bytes4)</td><td style="text-align:left">calldata的前四个字节 (function identifier)</td></tr><tr><td style="text-align:left">msg.value (uint)</td><td style="text-align:left">当前消息的wei值</td></tr><tr><td style="text-align:left">now (uint)</td><td style="text-align:left">当前块的时间戳</td></tr><tr><td style="text-align:left">tx.gasprice (uint)</td><td style="text-align:left">交易的gas价格</td></tr><tr><td style="text-align:left">tx.origin (address payable)</td><td style="text-align:left">交易的发送方</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function doSomething() public view returns(uint, address) &#123;</span><br><span class="line"></span><br><span class="line">        // 内置全局变量</span><br><span class="line">        uint timestamp = block.timestamp; // 获取区块时间戳</span><br><span class="line">        address sender = msg.sender; // 获取区块地址</span><br><span class="line">        return (timestamp,sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/12.png" alt="image-20221208152548299"></p><p>状态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    uint public nun = 123;</span><br><span class="line"></span><br><span class="line">    function doSomething() public&#123;</span><br><span class="line">        nun ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/13.png" alt="image-20221208152817271"></p><p>局部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    function doSomething() public pure  returns(uint)&#123;</span><br><span class="line">        uint num = 123;</span><br><span class="line">        num ++;</span><br><span class="line">        // 局部变量不保存每次使用都重置</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在为变量命名时，请记住以下规则。</p><ul><li>不应使用 Solidity 保留关键字作为变量名。例如，<code>break</code>或<code>boolean</code>变量名无效。</li><li>不应以数字(0-9)开头，必须以字母或下划线开头。例如，<code>123test</code>是一个无效的变量名，但是<code>_123test</code>是一个有效的变量名。</li><li>变量名区分大小写。例如，<code>Name</code>和<code>name</code>是两个不同的变量。</li></ul><h2 id="Solidity-可见性修饰符"><a href="#Solidity-可见性修饰符" class="headerlink" title="Solidity 可见性修饰符"></a><strong>Solidity 可见性修饰符</strong></h2><p>1.public – 所有合约与账号都可以调用<br>2.private -只有在定义该函数的合约可以调用<br>3.internal- 当前合约或者继承该合约的，类似java 里面的protected 关键字。<br>4.external – 只有其他合约或者账号可以调用,定义该函数的合约不能调用,除非使用 this 关键字</p><p><img src="/2025/03/11/solidity入门/14.png" alt="image-20221208153812857"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Storage &#123;</span><br><span class="line">    function set() public &#123; // 定义函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function OutsideFunc(uint x) pure returns (uint) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Solidity有两个关键字与函数输出相关：return和returns，他们的区别在于： </p><blockquote><p> returns加在函数名后面，用于声明返回的变量类型及变量名。</p><p>return用于函数主体中，返回指定的变量。</p></blockquote></li><li><p>view和pure的用法</p><blockquote><p>getter 类型的函数可以被view 或者 pure 修饰。 view 修饰的函数不能改变状态变量。pure 则既不能改变状态变量，也不取读取状态变量。</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ViewPureTest &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">    // 不能改变状态变量.</span><br><span class="line">    function addToX(uint y) public view returns (uint) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //函数中没有任何状态变量出现。</span><br><span class="line">    function add(uint i, uint j) public pure returns (uint) &#123;</span><br><span class="line">        return i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们无法确定该用view还是pure时，remix会给我们完善的提示信息</p><h2 id="错误Errors"><a href="#错误Errors" class="headerlink" title="错误Errors"></a>错误Errors</h2><blockquote><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   assert(bool condition)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  − 如果不满足条件，此方法调用将导致一个无效的操作码，对状态所做的任何更改将被还原。这个方法是用来处理内部错误的。</p><ul><li><p><code>require(bool condition)</code> − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。</p></li><li><p><code>require(bool condition, string memory message)</code> − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。它提供了一个提供自定义消息的选项。</p></li><li><p><code>revert()</code> − 此方法将中止执行并将所做的更改还原为执行前状态。</p></li><li><p><code>revert(string memory reason)</code> − 此方法将中止执行并将所做的更改还原为执行前状态。它提供了一个提供自定义消息的选项。</p></li></ul></blockquote><p>回退状态：但是gas费用是需要消耗</p><p>assert 合约内部错误</p><p>require 外部参数错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数被2整除</span><br></pre></td></tr></table></figure><p>assert 内部错误</p><p>Solidity 为应对失败，允许用户定义 <code>error</code> 来描述错误的名称和数据。 跟用错误字符串相比， <code>error</code> 更便宜并且允许你编码额外的数据，还可以用 NatSpec 为用户去描述错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">error NotFoundUser(address account, uint256 uid);</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">    mapping(address =&gt; uint256) users;</span><br><span class="line"></span><br><span class="line">    function getUser(address _account, uint256 _uid) public view &#123;</span><br><span class="line">        uint256 uid = users[msg.sender];</span><br><span class="line">        if (uid &lt; _uid) &#123;</span><br><span class="line">            revert NotFoundUser(_account, _uid);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br></pre></td></tr></table></figure><h2 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h2><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><p>  solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/11/solidity入门/15.png" alt="image-20221208145721522"></p><h1 id="变量的数据位置"><a href="#变量的数据位置" class="headerlink" title="变量的数据位置"></a>变量的数据位置</h1><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>在合约中声明和使用的变量都有一个数据位置，指明变量值应该存储在哪里。合约变量的数据位置将会影响Gas消耗量。</p><p>Solidity 提供4种类型的数据位置。</p><ul><li>Storage</li><li>Memory</li><li>Calldata</li><li>Stack</li></ul><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。</p><p>保存在存储区(Storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p><ul><li>存储中的数据是永久存在的。存储是一个key/value库</li><li>存储中的数据写入区块链，因此会修改状态，这也是存储使用成本高的原因。</li><li>占用一个256位的槽需要消耗20000 gas</li><li>修改一个已经使用的存储槽的值，需要消耗5000 gas</li><li>当清零一个存储槽时，会返还一定数量的gas</li><li>存储按256位的槽位分配，即使没有完全使用一个槽位，也需要支付其开销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct storage myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。</p><p>通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p><ul><li>内存是一个字节数组，槽大小位256位（32字节）</li><li>数据仅在函数执行期间存在，执行完毕后就被销毁</li><li>读或写一个内存槽都会消耗3gas</li><li>为了避免矿工的工作量过大，22个操作之后的单操作成本会上涨</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public view returns (MyStruct memory) &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct memory myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">        return myStruct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Calldata"><a href="#Calldata" class="headerlink" title="Calldata"></a>Calldata</h3><p>Calldata是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，Calldata是外部函数的参数(而不是返回参数)的默认位置。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>堆栈是由EVM (Ethereum虚拟机)维护的非持久性数据。EVM使用堆栈数据位置在执行期间加载变量。堆栈位置最多有1024个级别的限制。</p><p>可以看到，要永久性存储，可以保存在存储区(Storage)。</p><h2 id="数据位置规则"><a href="#数据位置规则" class="headerlink" title="数据位置规则"></a>数据位置规则</h2><h3 id="规则1-–-状态变量"><a href="#规则1-–-状态变量" class="headerlink" title="规则1 – 状态变量"></a>规则1 – 状态变量</h3><p>状态变量总是存储在存储区中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，不能显式地标记状态变量的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   uint storage stateVariable; // 错误  </span><br><span class="line">   uint[] memory stateArray; // 错误  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则2-–-函数参数与返回值"><a href="#规则2-–-函数参数与返回值" class="headerlink" title="规则2 – 函数参数与返回值"></a>规则2 – 函数参数与返回值</h3><p>函数参数包括返回参数都存储在内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line"></span><br><span class="line">   function calculate(uint num1, uint num2) public pure returns (uint result) &#123;</span><br><span class="line">       return num1 + num2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p><h3 id="规则3-–-局部变量"><a href="#规则3-–-局部变量" class="headerlink" title="规则3 – 局部变量"></a>规则3 – 局部变量</h3><p>值类型的局部变量存储在内存中。但是，对于引用类型，需要显式地指定数据位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract Locations &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是状态变量 */  </span><br><span class="line"></span><br><span class="line">  // 存储在storage中  </span><br><span class="line">  bool flag;  </span><br><span class="line">  uint number;  </span><br><span class="line">  address account;  </span><br><span class="line"></span><br><span class="line">  function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">    /* 此处都是局部变量  */  </span><br><span class="line"></span><br><span class="line">    // 值类型</span><br><span class="line">    // 所以它们被存储在内存中</span><br><span class="line">    bool flag2;  </span><br><span class="line">    uint number2;  </span><br><span class="line">    address account2;  </span><br><span class="line"></span><br><span class="line">    // 引用类型，需要显示指定数据位置，此处指定为内存</span><br><span class="line">    uint[] memory localArray;        </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能显式覆盖具有值类型的局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是局部变量  */  </span><br><span class="line">  // 值类型</span><br><span class="line">  bool memory flag2;  // 错误</span><br><span class="line">  uint Storage number2;  // 错误 </span><br><span class="line">  address account2;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则4-–-外部函数的参数"><a href="#规则4-–-外部函数的参数" class="headerlink" title="规则4 – 外部函数的参数"></a>规则4 – 外部函数的参数</h3><p>外部函数的参数(不包括返回参数)存储在Calldata中。</p><h2 id="赋值的数据位置规则"><a href="#赋值的数据位置规则" class="headerlink" title="赋值的数据位置规则"></a>赋值的数据位置规则</h2><h1 id="Solidity数据类型"><a href="#Solidity数据类型" class="headerlink" title="Solidity数据类型"></a>Solidity数据类型</h1><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。</p><p>Solidity中，变量类型有以下几大类：</p><ul><li>值类型</li><li>地址类型</li><li>引用类型</li></ul><p><img src="/2025/03/11/solidity入门/16.png" alt></p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">保留字</th><th style="text-align:left">取值</th></tr></thead><tbody><tr><td style="text-align:left">布尔型</td><td style="text-align:left">bool</td><td style="text-align:left">true/false</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int/uint</td><td style="text-align:left">有符号整数/无符号整数。</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">int8 to int256</td><td style="text-align:left">8位到256位的带符号整型数。int256与int相同。</td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left">uint8 to uint256</td><td style="text-align:left">8位到256位的无符号整型。uint256和uint是一样的。</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">fixed/unfixed</td><td style="text-align:left">有符号和无符号的定长浮点型</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">fixedMxN</td><td style="text-align:left">带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr><tr><td style="text-align:left">定长浮点型</td><td style="text-align:left">ufixedMxN</td><td style="text-align:left">无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr></tbody></table><h2 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h2><p>地址类型表示以太坊地址，长度为20字节。地址可以使用<code>.balance</code>方法获得余额，也可以使用<code>.transfer</code>方法将余额转到另一个地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address x = <span class="number">0x212</span>;</span><br><span class="line">address myAddress = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>) </span><br><span class="line">    x.transfer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="引用类型-复合数据类型"><a href="#引用类型-复合数据类型" class="headerlink" title="引用类型/复合数据类型"></a>引用类型/复合数据类型</h2><p>Solidity中，有一些数据类型由值类型组合而成，相比于简单的值类型，这些类型通常通过名称引用，被称为引用类型。</p><p>引用类型包括：</p><ul><li>数组 (字符串与bytes是特殊的数组，所以也是引用类型)</li><li>struct (结构体)</li><li>map (映射)</li></ul><p>“<code>undefined</code>”或“<code>null</code>”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。 要处理任何意外的值，应该使用错误处理来恢复整个交易，或者返回一个带有第二个<code>bool</code> 值的元组表示成功。</p><h2 id="bool-布尔类型"><a href="#bool-布尔类型" class="headerlink" title="bool/布尔类型"></a><strong>bool/布尔类型</strong></h2><p>布尔值的取值范围为 true 和 false 。</p><p>默认值：<code>false</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">  error NotEqual(bool A,bool B);</span><br><span class="line">bool public A; // false</span><br><span class="line">bool public B = true;//true</span><br><span class="line">  // require(A==B,&quot;A not equal B&quot;);</span><br><span class="line"></span><br><span class="line">  if (A != B) &#123;</span><br><span class="line">    error NotEqual(A,B);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符：<br>●!（逻辑非）<br>●&amp;&amp; （逻辑与， “and” ）<br>●|| （逻辑或， “or” ）<br>●== （等于）<br>●!= （不等于）</p><h2 id="int、uint-整数类型"><a href="#int、uint-整数类型" class="headerlink" title="int、uint/整数类型"></a><strong>int、uint/整数类型</strong></h2><blockquote><p><code>int/uint：</code>变长的<strong>有符号</strong>或<strong>无符号</strong>整型。变量支持的步长以<code>8</code>递增，支持从<code>uint8</code>到<code>uint256</code>，以及<code>int8</code>到<code>int256</code>。需要注意的是，<code>uint</code>和<code>int</code>默认代表的是<code>uint256</code>和<code>int256</code>。</p></blockquote><p><code>int</code> 有符号整型(包含负数)</p><p>默认为<code>int256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>int8</code> 取值范围：-(2 <strong> 7)到 2 </strong> 7 -1</li><li><code>int16</code>取值范围：-(2 <strong> 15)到 2 </strong> 15 -1</li><li>…</li><li><code>intX</code>取值范围：-(2<strong><code>X</code>-1)到 2</strong>(<code>X</code>-1) -1</li><li><code>int256</code>取值范围：-(2 <strong> 255)到 2 </strong> 255 -1</li></ul><p><code>uint</code> 无符号整型</p><p>默认为<code>uint256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>uint8</code>取值范围：0 到 2 ** 8 - 1</li><li><code>uint16</code>取值范围：0 到 2 ** 16 - 1</li><li>…</li><li><code>uintX</code>取值范围：0 到 2 ** <code>X</code> - 1</li><li><code>uint256</code>取值范围：0 到 2 ** 256 - 1</li></ul><p>对于整形 X，可以使用 type(X).min 和 type(X).max 去获取这个类型的最小值与最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestIntval &#123;</span><br><span class="line">  int8 public i8 = -1;</span><br><span class="line">    int public i256 = 456;</span><br><span class="line">    int public i = -123; // int 等同于 int256</span><br><span class="line">    // int 的最大最小值</span><br><span class="line">    int public minInt = type(int).min;</span><br><span class="line">    int public maxInt = type(int).max;</span><br><span class="line"></span><br><span class="line">    uint8 public u8 = 1;</span><br><span class="line">    uint256 public u256 = 456;</span><br><span class="line">    uint public u = 123; // uint  等同于 uint256 </span><br><span class="line">// uint 的最大最小值</span><br><span class="line">    uint public minUInt = type(uint).min;</span><br><span class="line">    uint public maxUInt = type(uint).max;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function mini() public pure returns(uint8)&#123;</span><br><span class="line">        return type(uint8).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="address-地址"><a href="#address-地址" class="headerlink" title="address/地址"></a><strong>address/地址</strong></h2><p>默认值: 0x0000000000000000000000000000000000000000</p><p>20字节的16进制地址用来表示一个账户 或者合约地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    //与其他机器语言相区别的类型就是这个address 类型，160-bit/20byte</span><br><span class="line">    address public myAddr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;</span><br><span class="line">    //合约自己的地址</span><br><span class="line">    address contractAddress = address(this);</span><br><span class="line">    //跟普通的地址类型一样，但多了两个方法 transfer/send 这两个方法后面章节会讲到</span><br><span class="line">    // address sender = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line">  //可以使用 balance 属性来查询一个地址的余额</span><br><span class="line">    function getBalance()</span><br><span class="line">        public view</span><br><span class="line">        returns (uint256, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        require(myAddr.balance &lt; contractAddress.balance, &quot;1 must lg 2&quot;);</span><br><span class="line">        return (myAddr.balance, contractAddress.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bytes-字节数组"><a href="#bytes-字节数组" class="headerlink" title="bytes/字节数组"></a><strong>bytes/字节数组</strong></h2><p>在计算机中的最小存储单位是 bit(位)</p><ul><li>1byte等于8位</li><li><p>Solidity中，byte可以赋值为</p></li><li><ul><li>16进制数字</li><li>单引号的单个或多个字符</li></ul></li></ul><p>定长字节数组</p><p>bytes1 后面数字1是表示1字节 bytes默认等于bytes1<br>Bytes2 后面数字2是表示2字节<br>Bytes3 后面数字3是表示3字节<br>bytes4 后面数字4是表示4字节</p><p>…</p><p>bytes32 后面数字32是表示32字节</p><p>bytes32 等价于 int256或uint256 的位数</p><p>成员变量</p><p><code>.length</code> 表示这个字节数组的长度（只读）</p><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string/字符串"></a><strong>string/字符串</strong></h2><ol><li>中文特殊字符需要用<code>unicode</code>编码</li><li>通过concat 方法进行拼接</li><li>bytes 和 string之间转化</li><li><code>string</code>字符串不能通过<code>length</code>方法获取其长度。</li><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code>可以通过这个方法比较两个字符串是否相等。</li><li><code>abi.encodePacked(s1, s2)</code>:通过这个方法进行字符串合并拼接。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    string public str1 = &quot;123&quot;;</span><br><span class="line">    // 中文不适用unicode编码报错</span><br><span class="line">    // string public str2 = =&quot;你好&quot;;</span><br><span class="line">    string public str2 = unicode&quot;abc&quot;;</span><br><span class="line">    function concat() public view returns(string memory) &#123;</span><br><span class="line">        string memory result = string.concat(str1,str2);</span><br><span class="line">        return  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function caoncat2(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        return string.concat(_a,_b);</span><br><span class="line">    &#125;</span><br><span class="line">     function caoncat3(string memory _a, string memory _b) public pure returns(bytes memory) &#123;</span><br><span class="line">          bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return bytes.concat(_ba,_bb);</span><br><span class="line">    &#125;</span><br><span class="line">      function caoncat4(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return string(bytes.concat(_ba,_bb));</span><br><span class="line">    &#125;</span><br><span class="line">     // 比较s1和s2是否相等，相等返回true，不相等返回false</span><br><span class="line">    function compareEqual(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;   </span><br><span class="line">        // 不支持字符直接比较</span><br><span class="line">        return s1 == s2;</span><br><span class="line">        // return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组</span><br><span class="line">    function mergeS1AndS2ReturnBytes(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encodePacked(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组转换为string</span><br><span class="line">    function mergeS1AndS2ReturnString(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return string(abi.encodePacked(s1, s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum(枚举)"></a>Enum(枚举)</h2><p>枚举将一个变量的取值限制为几个预定义值中的一个。精确使用枚举类型有助于减少代码中的bug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ontract UserState &#123;</span><br><span class="line">  // 枚举</span><br><span class="line">  //默认值是列表中的第一个元素</span><br><span class="line">  enum State &#123; </span><br><span class="line">    Online,  // 0</span><br><span class="line">    Offline,// 1</span><br><span class="line">    Unknown// 2</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  State public status;</span><br><span class="line">  function get() public view returns (State) &#123;</span><br><span class="line">      return status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过将uint传递到输入来更新状态</span><br><span class="line">  function set(State _status) public &#123;</span><br><span class="line">      status = _status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 也可以是这样确定属性的更新</span><br><span class="line">  function off() public &#123;</span><br><span class="line">      status = State.Offline;</span><br><span class="line">  &#125;</span><br><span class="line">  // delete 将枚举重置为其第一个值 0</span><br><span class="line">  function reset() public &#123;</span><br><span class="line">      delete status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array-数组"><a href="#array-数组" class="headerlink" title="array/数组"></a><strong>array/数组</strong></h2><blockquote><p>T[k]: 元素类型为T，固定长度为K的数组  uint[5] </p><p>T[]: 元素类型为T, 长度可以动态调整</p></blockquote><h3 id="一、固定长度的数组（Arrays）"><a href="#一、固定长度的数组（Arrays）" class="headerlink" title="一、固定长度的数组（Arrays）"></a>一、固定长度的数组（Arrays）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    // 创建定长数组</span><br><span class="line">    uint256[5] public arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    // 定长数组求和</span><br><span class="line">    function getAll() public view returns (uint256) &#123;</span><br><span class="line">        uint256 num = 0;</span><br><span class="line">        for (uint256 i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            num += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint256[5] memory) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取定长数组长度</span><br><span class="line">    function getLenth() public view returns (uint256) &#123;</span><br><span class="line">        return arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改长度失败</span><br><span class="line">    function changeLenth() public &#123;</span><br><span class="line">        // arr.length = 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改内部数据</span><br><span class="line">    function change(uint256 _idx, uint256 _val) public &#123;</span><br><span class="line">        arr[_idx] = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // push 修改</span><br><span class="line">    // function change(uint256 _val) public &#123;</span><br><span class="line">    //     arr.push(_val);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、可变长度的Arrays"><a href="#二、可变长度的Arrays" class="headerlink" title="二、可变长度的Arrays"></a>二、可变长度的Arrays</h3><p><code>uint [] T = [1,2,3,4,5]</code>，这句代码表示声明了一个可变长度的<code>T</code>数组，因为我们给它初始化了<code>5</code>个无符号整数，所以它的长度默认为<code>5</code>。</p><p><code>&gt;=0.5.0</code>的版本中<code>length</code>方法只读，不可修改。 5版本之前支持length属性修改，缺失的以0补位</p><p><img src="/2025/03/11/solidity入门/17.png" alt="image-20221214150932547"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint [] T = [1,2,3,4,5];</span><br></pre></td></tr></table></figure><h3 id="三、二维数组-数组里面放数组"><a href="#三、二维数组-数组里面放数组" class="headerlink" title="三、二维数组 - 数组里面放数组"></a>三、二维数组 - 数组里面放数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[2][3] T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line"></span><br><span class="line">    function T_len() public view returns (uint256) &#123;</span><br><span class="line">        return T.length; // uint256: 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function getT() public view returns (uint256[2][3] memory) &#123;</span><br><span class="line">        return T;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    function change() public &#123;</span><br><span class="line">        T[1][0] = 55;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uint [2][3] T = [[1,2],[3,4],[5,6]]</code>这是一个三行两列的数组，你会发现和Java、C语言等的其它语言中二位数组里面的列和行之间的顺序刚好相反。在其它语言中，上面的内容应该是这么存储<code>uint [2][3] T = [[1,2,3],[4,5,6]]</code>。</p><p>上面的<code>数组T</code>是<code>storage</code>类型的数组，对于<code>storage</code>类型的数组，数组里面可以存放任意类型的值（比如：其它数组，结构体，字典／映射等等）。对于<code>memory</code>类型的数组，如果它是一个<code>public</code>类型的函数的参数，那么它里面的内容不能是一个<code>mapping(映射／字典)</code>，并且它必须是一个<code>ABI</code>类型。</p><h3 id="四、数组字面量-Array-Literals-内联数组-Inline-Arrays"><a href="#四、数组字面量-Array-Literals-内联数组-Inline-Arrays" class="headerlink" title="四、数组字面量 Array Literals / 内联数组 Inline Arrays"></a>四、数组字面量 Array Literals / 内联数组 Inline Arrays</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    function f() pure public &#123;</span><br><span class="line">        g([1, 2, 3]); </span><br><span class="line">        g([uint(1),2,3])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function g(uint[3] memory _data) pure public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><blockquote><p>通过基本数据类型来组合成自定义复杂的数据类型</p></blockquote><p>语法结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 关键字  结构体名称 &#123;</span><br><span class="line">类型1  属性名1;</span><br><span class="line">类型2  属性名2；</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">uint8 age;</span><br><span class="line">string id;</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建结构变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构体 变量名 = 结构体(属性1，属性2，...)</span><br><span class="line">结构体 变量名 = 结构体(&#123;属性1：value1，属性2：value2Ï&#125;)</span><br><span class="line"></span><br><span class="line">Person student1 = Person(18,1,&quot;柯南&quot;)；</span><br><span class="line">Person student2 = Person(&#123;age:17, id: 2, name: &quot;迪迦Ï&quot;&#125;)</span><br></pre></td></tr></table></figure><p>修改结构体变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setStudent(uint _age, string _name) public &#123;</span><br><span class="line">student1.age = _age</span><br><span class="line">student1.name = _name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中返回结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getStudent() public view returns(Person) &#123;</span><br><span class="line">return student1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract Structs &#123;</span><br><span class="line">    struct Todo &#123;</span><br><span class="line">        string text;</span><br><span class="line">        bool completed;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构体数组</span><br><span class="line">  </span><br><span class="line">    Todo[] public todos;</span><br><span class="line"></span><br><span class="line">    // 初始化结构的3种方法</span><br><span class="line">    function create(string calldata _text) public &#123;</span><br><span class="line">        // 1.像函数一样调用它</span><br><span class="line">        todos.push(Todo(_text, false));</span><br><span class="line">        // 2. 键值对</span><br><span class="line">        todos.push(Todo(&#123;text: _text, completed: false&#125;));</span><br><span class="line">        // 3.初始化一个空结构，然后更新它</span><br><span class="line">        Todo memory todo;</span><br><span class="line">        todo.text = _text;</span><br><span class="line">        todos.push(todo);// completed 没有定义,默认为 false</span><br><span class="line">    &#125;</span><br><span class="line">    //通过索引获取结构体数组中一个元素,并更新内部的属性</span><br><span class="line">    function update(uint _index) public &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        todo.completed = !todo.completed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典／映射（Mappings"><a href="#字典／映射（Mappings" class="headerlink" title="字典／映射（Mappings)"></a>字典／映射（Mappings)</h2><blockquote><p>与数组和结构体一样，映射也是引用类型。</p><p>是一个一对一键值存储关系。</p><p>可以理解成js中的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(<span class="function"><span class="params">_KeyType</span> =&gt;</span> _ValueType)</span><br></pre></td></tr></table></figure><ul><li><code>_KeyType</code> – 可以是任何内置类型，或者bytes和字符串。不允许使用引用类型或复杂对象。</li><li><code>_ValueType</code> – 可以是任何类型。</li></ul><p><strong>注意</strong></p><ul><li>映射的数据位置(data location)只能是storage，通常用于状态变量。</li><li>映射可以标记为public，Solidity 自动为它创建getter。</li><li>mapping 不能直接在函数返回</li></ul><p>创建mapping </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint256 _amount) public &#123;</span><br><span class="line">        balances[msg.sender] = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAmount() public view  returns(uint)&#123;</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract LedgerBalance &#123;</span><br><span class="line">   mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">   function updateBalance(uint newBalance) public &#123;</span><br><span class="line">      balances[msg.sender] = newBalance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Updater &#123;</span><br><span class="line">   function updateBalance() public returns (uint) &#123;</span><br><span class="line">      LedgerBalance ledgerBalance = new LedgerBalance();</span><br><span class="line">      ledgerBalance.updateBalance(10);</span><br><span class="line">      return ledgerBalance.balances(address(this));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    //从地址到uint的映射</span><br><span class="line">    mapping(address =&gt; uint) public myMap;</span><br><span class="line"></span><br><span class="line">    function get(address _addr) public view returns (uint) &#123;</span><br><span class="line">        //映射始终返回一个值。</span><br><span class="line">//如果从未设置该值，它将返回默认值。</span><br><span class="line">        return myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新此地址的值 </span><br><span class="line">    function set(address _addr, uint _i) public &#123;</span><br><span class="line">        myMap[_addr] = _i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove(address _addr) public &#123;</span><br><span class="line">//将值重置为默认值</span><br><span class="line">        delete myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//嵌套 mapping</span><br><span class="line">contract NestedMapping &#123;</span><br><span class="line">    //嵌套映射（从地址映射到另一个映射）</span><br><span class="line">    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;</span><br><span class="line"></span><br><span class="line">    function get(address _addr1, uint _i) public view returns (bool) &#123;</span><br><span class="line">        // 可以从嵌套映射中获取值</span><br><span class="line">        return nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(</span><br><span class="line">        address _addr1,</span><br><span class="line">        uint _i,</span><br><span class="line">        bool _boo</span><br><span class="line">    ) public &#123;</span><br><span class="line">        nested[_addr1][_i] = _boo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除 mapping 的一个元素</span><br><span class="line">    function remove(address _addr1, uint _i) public &#123;</span><br><span class="line">        delete nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solidity运算符"><a href="#Solidity运算符" class="headerlink" title="Solidity运算符"></a>Solidity运算符</h1><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>+ (加)</strong> 求和 <strong>例:</strong> A + B = 30</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>– (减)</strong> 相减 <strong>例:</strong> A – B = -10</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>* (乘)</strong> 相乘 <strong>例:</strong> A * B = 200</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>/ (除)</strong> 相除 <strong>例:</strong> B / A = 2</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>% (取模)</strong> 取模运算 <strong>例:</strong> B % A = 0</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>++ (递增)</strong> 递增 <strong>例:</strong> A++ = 11</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>— (递减)</strong> 递减 <strong>例:</strong> A– = 9</td></tr></tbody></table><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>== (等于)</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>!= (不等于)</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>&gt; (大于)</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>&lt; (小于)</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>&gt;= (大于等于)</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>&lt;= (小于等于)</strong></td></tr></tbody></table><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>&amp;&amp; (逻辑与)</strong> 如果两个操作数都非零，则条件为真。 <strong>例:</strong> (A &amp;&amp; B) 为真</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">**\</td><td>\</td><td>(逻辑或)<strong> 如果这两个操作数中有一个非零，则条件为真。 </strong>例:** (A \</td><td>\</td><td>B) 为真</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>! (逻辑非)</strong> 反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。 <strong>例:</strong> ! (A &amp;&amp; B) 为假</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>&amp; (位与)</strong> 对其整数参数的每个位执行位与操作。 <strong>例:</strong> (A &amp; B) 为 2.</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">**\</td><td>(位或)<strong> 对其整数参数的每个位执行位或操作。 </strong>例:** (A \</td><td>B) 为 3.</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>^ (位异或)</strong> 对其整数参数的每个位执行位异或操作。 <strong>例:</strong> (A ^ B) 为 1.</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>~ (位非)</strong> 一元操作符，反转操作数中的所有位。 <strong>例:</strong> (~B) 为 -4.</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>&lt;&lt; (左移位))</strong> 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由0填充。将一个值向左移动一个位置相当于乘以2，移动两个位置相当于乘以4，以此类推。 <strong>例:</strong> (A &lt;&lt; 1) 为 4.</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>&gt;&gt; (右移位)</strong> 左操作数的值向右移动，移动位置数量由右操作数指定 <strong>例:</strong> (A &gt;&gt; 1) 为 1.</td></tr></tbody></table><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>solidity 支持的赋值运算符，如下表所示：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>= (简单赋值)</strong> 将右侧操作数的值赋给左侧操作数 <strong>例:</strong> C = A + B 表示 A + B 赋给 C</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>+= (相加赋值)</strong> 将右操作数添加到左操作数并将结果赋给左操作数。 <strong>例:</strong> C += A 等价于 C = C + A</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>−= (相减赋值)</strong> 从左操作数减去右操作数并将结果赋给左操作数。 <strong>例:</strong> C -= A 等价于 C = C – A</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>*= (相乘赋值)</strong> 将右操作数与左操作数相乘，并将结果赋给左操作数。 <strong>例:</strong> C <em>= A 等价于 C = C </em> A</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>/= (相除赋值)</strong> 将左操作数与右操作数分开，并将结果分配给左操作数。 <strong>例:</strong> C /= A 等价于 C = C / A</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>%= (取模赋值)</strong> 使用两个操作数取模，并将结果赋给左边的操作数。 <strong>例:</strong> C %= A 等价于 C = C % A</td></tr></tbody></table><blockquote><p><strong>注意</strong> – 同样的逻辑也适用于位运算符，因此它们将变成<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p></blockquote><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">运算符与描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>? : (条件运算符 )</strong> 如果条件为真 ? 则取值X : 否则值Y</td></tr></tbody></table><h1 id="Solidity循环语句"><a href="#Solidity循环语句" class="headerlink" title="Solidity循环语句"></a>Solidity循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (表达式) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">        int256 start = 1;</span><br><span class="line">        while (start &lt;= max) &#123;</span><br><span class="line">            start++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>Solidity 中， do…while循环的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125; while (表达式);</span><br><span class="line">注意: 不要漏掉do后面的分号。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract TestBool &#123;</span><br><span class="line">   uint public num  = 10;</span><br><span class="line">   function test () public returns(uint) &#123;</span><br><span class="line">       int  start = 1;</span><br><span class="line">       int  max = 10;</span><br><span class="line">       do&#123;</span><br><span class="line">         start ++;</span><br><span class="line">         num ++;</span><br><span class="line">       &#125;while(start &lt;=max);</span><br><span class="line">       return num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 测试条件; 迭代语句) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         if(start == 1) &#123;</span><br><span class="line">            //  break;  // 跳出循环 num 10</span><br><span class="line">            continue; // 跳出本次循环</span><br><span class="line">        &#125;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Solidity条件语句"><a href="#Solidity条件语句" class="headerlink" title="Solidity条件语句"></a>Solidity条件语句</h1><p>Solidity支持条件语句，让程序可以根据条件执行不同的操作。条件语句包括：</p><ul><li><code>if</code></li><li><code>if...else</code></li><li><code>if...else if</code></li></ul><p><img src="/2025/03/11/solidity入门/18.png" alt="image-20221208161811890"></p><h1 id="Solidity中的函数"><a href="#Solidity中的函数" class="headerlink" title="Solidity中的函数"></a>Solidity中的函数</h1><h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><blockquote><p>函数修饰符用于修改函数的行为。例如，向函数添加条件限制。</p><p>修饰符定义中出现特殊符号<code>_</code>的地方，用于插入函数体。如果在调用此函数时，满足了修饰符的条件，则执行该函数，否则将抛出异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    uint256 price = 10;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义修饰符 onlyOwner 不带参数</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用修饰符 onlyOwner 限制只有发布者才能调用</span><br><span class="line">    function changePrice(uint256 _price)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        onlyOwner</span><br><span class="line">        returns (address, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return (owner, _price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图函数（view）"><a href="#视图函数（view）" class="headerlink" title="视图函数（view）"></a>视图函数（view）</h2><blockquote><p>View(视图)函数 使用状态变量，但是不修改状态</p></blockquote><p>如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p><ul><li>修改状态变量。</li><li>触发事件。</li><li>创建合约。</li><li>使用<code>selfdestruct</code>。</li><li>发送以太。</li><li>调用任何不是视图函数或纯函数的函数</li><li>使用底层调用</li><li>使用包含某些操作码的内联程序集。</li></ul><p>Getter方法是默认的视图函数。声明视图函数，可以在函数声明里，添加<code>view</code>关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getResult() public view returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1; // 局部变量</span><br><span class="line">        uint256 b = 2;</span><br><span class="line">        uint256 product = a * b;</span><br><span class="line">        uint256 sum = a + b;</span><br><span class="line">        return (product, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯函数（Pure）"><a href="#纯函数（Pure）" class="headerlink" title="纯函数（Pure）"></a>纯函数（Pure）</h2><blockquote><p>Pure(纯)函数<strong>不读取</strong>或修改状态。</p><p>声明纯函数，可以在函数声明里，添加<code>pure</code>关键字。</p></blockquote><p>如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告</p><ul><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li><li>访问任何区块、交易、msg等特殊变量(msg.sig 与 msg.data 允许读取)。</li><li>调用任何不是纯函数的函数。</li><li>使用包含特定操作码的内联程序集。</li></ul><p>如果发生错误，纯函数可以使用<code>revert()</code>和<code>require()</code>函数来还原潜在的状态更改。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote><p>同一个作用域内，相同函数名可以定义多个函数。这些函数的参数(参数类型或参数数量)必须不一样。仅仅是返回值不一样不被允许。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getSum(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSum(</span><br><span class="line">        uint256 a,</span><br><span class="line">        uint256 b,</span><br><span class="line">        uint256 c</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><blockquote><p>Solidity 提供了常用的加密函数。以下是一些重要函数：</p><ul><li><code>keccak256(bytes memory) returns (bytes32)</code> 计算输入的Keccak-256散列。</li><li><code>sha256(bytes memory) returns (bytes32)</code> 计算输入的SHA-256散列。</li><li><code>ripemd160(bytes memory) returns (bytes20)</code> 计算输入的RIPEMD-160散列。</li><li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>从椭圆曲线签名中恢复与公钥相关的地址，或在出错时返回零。函数参数对应于签名的ECDSA值: r – 签名的前32字节; s: 签名的第二个32字节; v: 签名的最后一个字节。这个方法返回一个地址。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Test &#123;   </span><br><span class="line">   function callKeccak256() public pure returns(bytes32 result)&#123;</span><br><span class="line">      return keccak256(&quot;ABC&quot;);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><h2 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h2><blockquote><p>就像Java、C++中，类的继承一样，Solidity中，合约继承是扩展合约功能的一种方式。Solidity支持单继承和多继承。</p></blockquote><p>Solidity中，合约继承的重要特点：</p><ul><li>派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用<code>this</code>。</li><li>如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。</li><li>可以使用<code>super</code>关键字或父合同名称调用父合同的函数。</li><li>在多重继承的情况下，使用<code>super</code>的父合约函数调用，优先选择被最多继承的合约。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint256 private data;</span><br><span class="line">    uint256 public info;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        info = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increment(uint256 a) private pure returns (uint256) &#123;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateData(uint256 a) public &#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData() public view returns (uint256) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function compute(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is Base &#123;</span><br><span class="line">    uint256 private result;</span><br><span class="line">    Base private base;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        base = new Base();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getComputedResult() public &#123;</span><br><span class="line">        result = compute(3, 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getResult() public view returns (uint256) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>构造函数是使用<code>construct</code>关键字声明的特殊函数，用于初始化合约的状态变量。合约中构造函数是可选的，可以省略。</p></blockquote><p>构造函数有以下重要特性：</p><ul><li>一个合约只能有一个构造函数。</li><li>构造函数在创建合约时执行一次，用于初始化合约状态。</li><li>在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。</li><li>构造函数可以是公共的，也可以是内部的。</li><li>内部构造函数将合约标记为抽象合约。</li><li>如果没有定义构造函数，则使用默认构造函数。</li></ul><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solidity语法基础入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包开发</title>
    <link href="/2025/03/10/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91/"/>
    <id>/2025/03/10/以太坊钱包开发/</id>
    <published>2025-03-10T08:48:28.000Z</published>
    <updated>2025-03-11T04:12:09.781Z</updated>
    
    <content type="html"><![CDATA[<p>使用vue开发以太坊钱包<br><a id="more"></a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>版本信息:</p><p>Node  16.14</p><p>安装vue-cli </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>验证vue-cli 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vue -V</span><br><span class="line">// 结果 出现vue版本号 安装成功</span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure><p>通过vue-cli创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vue create &lt;项目名称&gt;</span><br><span class="line">// 选择配置</span><br><span class="line">Vue CLI v5.0.8</span><br><span class="line">? Please pick a preset: </span><br><span class="line">  Default ([Vue 3] babel, eslint) </span><br><span class="line">  Default ([Vue 2] babel, eslint) </span><br><span class="line">❯ Manually select features  `选择该项`</span><br></pre></td></tr></table></figure><p>选择自定义配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to </span><br><span class="line">toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)</span><br><span class="line"> ◉ Babel `选择该项`</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◉ Router `选择该项`</span><br><span class="line"> ◯ Vuex</span><br><span class="line">❯◉ CSS Pre-processors `选择该项`</span><br><span class="line"> ◯ Linter / Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure><p>选择vue版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Choose a version of Vue.js that you want to start the project with (Use arrow </span><br><span class="line">keys)</span><br><span class="line">❯ 3.x </span><br><span class="line">  2.x</span><br></pre></td></tr></table></figure><p>选择路由设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router? (Requires proper server setup <span class="keyword">for</span> index fallback </span><br><span class="line"><span class="keyword">in</span> production) (Y/n) y  `输入y或者n`</span><br></pre></td></tr></table></figure><p>选择预处理语言</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported </span><br><span class="line">by default): </span><br><span class="line">  Sass/SCSS (with dart-sass) </span><br><span class="line">❯ Less </span><br><span class="line">  Stylus</span><br></pre></td></tr></table></figure><p>选择配置文件存放目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, ESLint, etc.? </span><br><span class="line">❯ In dedicated config files </span><br><span class="line">  In package.json</span><br></pre></td></tr></table></figure><p>安装成功后 运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 项目名称</span><br><span class="line">$ npm run serve</span><br></pre></td></tr></table></figure><p>成功界面 </p><p><img src="/2025/03/10/以太坊钱包开发/1.png" alt="image-20230102200435157"></p><h2 id="第三方包安装"><a href="#第三方包安装" class="headerlink" title="第三方包安装"></a>第三方包安装</h2><h3 id="web3相关第三方包"><a href="#web3相关第三方包" class="headerlink" title="web3相关第三方包"></a>web3相关第三方包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet</span><br></pre></td></tr></table></figure><blockquote><p>注： ethereumjs-tx 使用1.3.7 版本</p></blockquote><h3 id="node-polyfill-兼容文件配置"><a href="#node-polyfill-兼容文件配置" class="headerlink" title="node-polyfill 兼容文件配置"></a>node-polyfill 兼容文件配置</h3><ol><li><p>下载polyfill 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-polyfill-webpack-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js 文件中配置插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line">++ <span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">++  configureWebpack: &#123;</span><br><span class="line">++    plugins: [</span><br><span class="line">++      <span class="keyword">new</span> NodePolyfillWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置vant-ui-ui组件库"><a href="#配置vant-ui-ui组件库" class="headerlink" title="配置vant-ui ui组件库"></a>配置vant-ui ui组件库</h3><p><a href="https://vant-contrib.gitee.io/vant/#/zh-CN" target="_blank" rel="noopener">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vant</span><br><span class="line">$ npm i unplugin-vue-components -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在vue.config.js 文件中配置插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">"@vue/cli-service"</span>);</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// vant</span></span><br><span class="line">++ <span class="keyword">const</span> &#123; VantResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>);</span><br><span class="line">++ <span class="keyword">const</span> ComponentsPlugin = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> NodePolyfillWebpackPlugin(),</span><br><span class="line">++    ComponentsPlugin(&#123; <span class="attr">resolvers</span>: [VantResolver()]&#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试 在app.vue文件添加代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line"> &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/2.png" alt="image-20230102202255947"></p><h3 id="通过vw配置响应式"><a href="#通过vw配置响应式" class="headerlink" title="通过vw配置响应式"></a>通过vw配置响应式</h3><p><a href="https://www.cnblogs.com/hongrun/p/16130707.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongrun/p/16130707.html</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在根目录下创建 名为 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">"px"</span>, <span class="comment">// 要转化的单位</span></span><br><span class="line">      viewportWidth: <span class="number">375</span>, <span class="comment">// UI设计稿的宽度</span></span><br><span class="line">      unitPrecision: <span class="number">6</span>, <span class="comment">// 转换后的精度，即小数点位数</span></span><br><span class="line">      propList: [<span class="string">"*"</span>], <span class="comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span></span><br><span class="line">      viewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定需要转换成的视窗单位，默认vw</span></span><br><span class="line">      fontViewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名，</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 默认值1，小于或等于1px则不进行转换</span></span><br><span class="line">      mediaQuery: <span class="literal">true</span>, <span class="comment">// 是否在媒体查询的css代码中也进行转换，默认false</span></span><br><span class="line">      replace: <span class="literal">true</span>, <span class="comment">// 是否转换后直接更换属性值</span></span><br><span class="line">      exclude: [<span class="regexp">/node_modules/</span>], <span class="comment">// 设置忽略文件，用正则做目录名匹配</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="web3连接到以太坊网络（测试网、主网）"><a href="#web3连接到以太坊网络（测试网、主网）" class="headerlink" title="web3连接到以太坊网络（测试网、主网）"></a>web3连接到以太坊网络（测试网、主网）</h1><ol><li>什么是web3<br>web3是以太坊官方开提供的一个连接以太坊区块链的模块，允许您使用HTTP或IPC与本地或远程以太坊节点进行交互，它包含以太坊生态系统的几乎所有功能。web3模块主要连接以太坊暴露出来的RPC层。开发者利用web3连接RPC层，可以连接任何暴露了RPC接口的节点，从而与区块链交互。web3是一个集合库，支持多种开发语言使用wbe3，其中的JavaScript API叫做web3.js、另外还有web3.py、web3j，web3.js将是我们钱包开发项目的重点。</li></ol><p>web3.eth：用于与以太坊区块链和智能合约之间的交互。</p><p>web3.utils：包含一些辅助方法。</p><p>web3.shh：用于协议进行通信的P2P和广播。</p><p>web3.bzz：用于与群网络交互的Bzz模块。</p><p>github地址：<a href="https://github.com/web3/web3.js/tree/v1.0.0-beta.34" target="_blank" rel="noopener">https://github.com/web3/web3.js/tree/v1.0.0-beta.34</a></p><p>web3.js开发文档：<a href="https://web3js.readthedocs.io/en/v1.8.1/" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/v1.8.1/</a></p><p>web3.js 中文文档 : <a href="https://learnblockchain.cn/docs/web3.js/" target="_blank" rel="noopener">https://learnblockchain.cn/docs/web3.js/</a></p><ol start="2"><li>实例化web3对象<br>web3要与以坊节点进行交互，需要创建一个web3对象，下面看看如何创建。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="comment">// "Web3.providers.givenProvider" will be set if in an Ethereum supported browser.</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">'ws://some.local-or-remote.node:8546'</span>);</span><br></pre></td></tr></table></figure><p>根据API可知需要指定节点地址，我们将ws://some.local-or-remote.node:8546换成其它连接到以太坊网络的节点的地址，以此来确定连接的以太坊的网络。那么连接到以太坊网络的节点的地址是多少呢？这里我们需要使用到infura。</p><ol start="3"><li>获取连接到以太坊网络的节点地址<br>infura提供公开的 Ethereum主网和测试网络节点，到infura.io网站注册后即可获取各个网络的地址。请按照如下步骤获取地址。</li></ol><p>第一步：打开 infura网站地址：<a href="https://infura.io/dashboard，使用邮箱注册后登陆" target="_blank" rel="noopener">https://infura.io/dashboard，使用邮箱注册后登陆</a></p><p>第二步：点击上图标记的“create new project”按钮创建一个新项目。然后弹出如下弹框，在输入框输入项目名，如”MyEtherWallet“，然后点击“create project”按钮创建。</p><p><img src="/2025/03/10/以太坊钱包开发/3.png" alt></p><p>第三步：然后会显示如下界面，点击下图中的选择框，可以看到提供主网、Kovan测试网络、Ropsten测试网络、GoerLi测试网络的节点地址。</p><p><img src="/2025/03/10/以太坊钱包开发/4.png" alt="image.png"></p><p>第四步：选择GoerLi测试网络，然后复制地址，将获取到类似这样的地址：<a href="https://kovan.infura.io/v3/d93f......cd67，如下。" target="_blank" rel="noopener">https://kovan.infura.io/v3/d93f......cd67，如下。</a></p><p><img src="/2025/03/10/以太坊钱包开发/5.png" alt="image.png"></p><ol start="4"><li>连接到以太坊GoerLi测试网络<br>现在将复制的地址替换掉实例化web对象的地址，如下</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">"web3"</span>)</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">'wss://goerli.infura.io/ws/v3/cb7e63cf28244e4499b4b6fb6162e746'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Web3:"</span>, web3)</span><br></pre></td></tr></table></figure><p>连接到以太坊主网与GoerLi测试网络一样的，只需复制主网节点的地址去实例化web3即可。由于在主网上交易需要花费gas，因此我们基于GoerLi测试网络进行开发，后续开发完成后可再切换到主网。</p><p><img src="/2025/03/10/以太坊钱包开发/6.png" alt="image-20230102215334761"></p><h1 id="Web3js-高频-Api"><a href="#Web3js-高频-Api" class="headerlink" title="Web3js 高频 Api"></a>Web3js 高频 Api</h1><h2 id="账号创建"><a href="#账号创建" class="headerlink" title="账号创建"></a>账号创建</h2><ol><li>创建账号需要使用web3.js的如下API</li></ol><p>API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create([entropy]);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/7.png" alt="image.png"><br>参数：</p><p>entropy - String (可选): 它是一个可选项，是一个随机字符串，将作为解锁账号的密码。如果没有传递字符串，则使用random生成随机字符串。</p><p>返回值：</p><p>Object：包含以下字段的一个帐户对象：</p><p>address- string：帐户地址。</p><p>privateKey- string：帐户私钥。前端永远不应该在localstorage中以未加密的方式共享或存储！</p><p>signTransaction(tx [, callback])- Function：签名交易的方法。</p><p>sign(data)- Function：签名二进制交易的方法。</p><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br><span class="line">&#123;</span><br><span class="line">address: <span class="string">"0xF2CD2AA0c7926743B1D4310b2BC984a0a453c3d4"</span>,</span><br><span class="line">privateKey: <span class="string">"0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098"</span>,</span><br><span class="line">signTransaction: <span class="function"><span class="keyword">function</span>(<span class="params">tx</span>)</span>&#123;...&#125;,</span><br><span class="line">sign: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;,</span><br><span class="line">encrypt: <span class="function"><span class="keyword">function</span>(<span class="params">password</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>获取地址<br>使用API<code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>addreds</code>属性，即账户的私钥。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account = web3.eth.accounts.create(<span class="string">"123456"</span>)</span><br><span class="line"><span class="keyword">let</span> address = account.address</span><br><span class="line"><span class="comment">//address：0xfF0B5A0AA68249cD161b606679DB49CBD9a12cd0</span></span><br></pre></td></tr></table></figure><p>3.获取私钥</p><p>使用API<code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>privateKey</code>属性，即账户的私钥。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> account = web3.eth.accounts.create()</span><br><span class="line"><span class="keyword">let</span> privateKey = account.privateKey</span><br><span class="line"><span class="comment">//privateKey:0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709</span></span><br></pre></td></tr></table></figure><h2 id="余额获取"><a href="#余额获取" class="headerlink" title="余额获取"></a>余额获取</h2><p>根据地址获取以wei为单位余额</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getBalance(address).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a>单位转换</h2><ol><li>Eth 转为 wei</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Web3 或者实例后的web3对象都可以</span><br><span class="line"><span class="keyword">const</span> num = Web3.utils.toWei(<span class="string">"0.3"</span>);</span><br><span class="line"><span class="keyword">const</span> num = web3.utils.toWei(<span class="string">"0.3"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"><span class="comment">// 300000000000000000</span></span><br></pre></td></tr></table></figure><ol start="2"><li>wei 转为Eth</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Web3 或者实例后的web3对象都可以</span><br><span class="line"> <span class="keyword">this</span>.balance = Web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br><span class="line"> <span class="keyword">this</span>.balance = web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br></pre></td></tr></table></figure><h2 id="Eth转账"><a href="#Eth转账" class="headerlink" title="Eth转账"></a>Eth转账</h2><p><strong>API</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendSignedTransaction(signedTransactionData [, callback])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p><code>signedTransactionData</code>-<code>String</code>：以HEX格式签名的交易数据。</p><p>交易数据对象可以包含如下字段：</p><ul><li><code>from</code>- <code>String|Number</code>：发送帐户的地址。如果未指定，则使用web3.eth.defaultAccount属性。或web3.eth.accounts.wallet中本地钱包的地址。</li><li><code>to</code>- <code>String</code>:(可选）消息的目标地址，若未定义则为合同发送消息。</li><li><code>value</code>- <code>Number|String|BN|BigNumber</code>:(可选）为wei中的交易转移的数量，如果是合约发送消息，则是捐赠给合约地址。</li><li><code>gas</code> - <code>Number</code>:(可选，默认：待定）用于交易的gas（未使用的gas会退还）。</li><li><code>gasPrice</code>- <code>Number|String|BN|BigNumber</code>:(可选）此交易的gas价格，以wei为单位，默认为<a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#eth-gasprice" target="_blank" rel="noopener">web3.eth.gasPrice</a>。</li><li><code>data</code>- <code>String</code>:(可选）包含合同上函数调用数据的<a href="http://solidity.readthedocs.io/en/latest/abi-spec.html" target="_blank" rel="noopener">ABI字节字符串</a>。</li><li><code>nonce</code>- <code>Number</code>:(可选）随机数的整数。</li></ul></li><li><p><code>callback</code>-<code>Function</code>：（可选）可选回调，将错误对象作为第一个参数返回，结果作为第二个参数返回。</p></li></ul><p><strong>返回</strong></p><p><code>PromiEvent</code>：promise组合的事件，将在交易完成时调用。包含以下事件</p><ul><li><code>&quot;transactionHash&quot;</code>返回<code>String</code>：在发送事务并且事务哈希可用之后立即触发。</li><li><code>&quot;receipt&quot;</code>返回<code>Object</code>：在交易确认时触发。</li><li><code>&quot;confirmation&quot;</code>返回<code>Number</code>，<code>Object</code>：每次确认都会被调用，直到第12次确认。接收确认编号作为第一个参数，将数据作为第二个参数。</li><li><code>&quot;error&quot;</code>返回<code>Error</code>：如果在发送过程中发生错误，则会触发。</li></ul><ol><li><p>构建转账参数</p><p>区块链转账和支付宝转账类似，需要 <code>发送方</code> 、<code>接收方</code>、<code>金额</code>、<code>密码</code></p><p>另外需要添加部分区块链参数：<code>矿工费gas</code>、<code>地址转账交易次数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取账户交易次数</span></span><br><span class="line"> <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromaddress);</span><br><span class="line"> <span class="comment">// 获取预计转账gas费</span></span><br><span class="line"> <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line"> <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line"> <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.utils.toWei(number);</span><br><span class="line"> <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">   <span class="keyword">from</span>: fromaddress,</span><br><span class="line">   nonce: nonce,</span><br><span class="line">   gasPrice: gasPrice,</span><br><span class="line">   to: toaddress,</span><br><span class="line">   value: balance,</span><br><span class="line">   data: <span class="string">"0x00"</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过转账参数计算最终gas费用，并将通过私钥将转账参数进行编码加密</p><blockquote><p>ethereumjs-tx 第三方库请选择1.3.7版本</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tx <span class="keyword">from</span> <span class="string">"ethereumjs-tx"</span>;  </span><br><span class="line"><span class="comment">// 将私钥去除“ox”后进行hex转化</span></span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(privatekey.slice(<span class="number">2</span>), <span class="string">"hex"</span>);</span><br><span class="line">      <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">      <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">      rawTx.gas = gas;</span><br><span class="line">     <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">      tx.sign(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.serialize();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>sendSignedTransaction</code> api发送转账交易，并且获取交易id</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web3.eth</span><br><span class="line">  .sendSignedTransaction(<span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>))</span><br><span class="line">  .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;)</span></span><br><span class="line">  <span class="comment">// .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;)</span></span><br><span class="line">  .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>区块链浏览器或者目标钱包产看转账结果</p><p>goerli区块链浏览器 <a href="https://goerli.etherscan.io/tx/交易id" target="_blank" rel="noopener">https://goerli.etherscan.io/tx/交易id</a></p></li></ol><h1 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在前面的教程中我们对以太坊钱包已经有了一定的认识，上一章也重点介绍了账号地址的生成过程，在以太坊钱包中一个重点就是账户系统，在这个模块中很多初学同学不是很清楚密码、keystore、助记词与私钥它们之间的关系。下面我们来看看它们之间到底有着怎样的爱恨情仇，让大家琢磨不透。</p></blockquote><p><code>密码</code></p><p>密码不是私钥，它是在创建账户时候的密码（可以修改）</p><p>密码在以下情况下会使用到：</p><ol><li>作为转账的支付密码</li><li>用keystore导入钱包的时候需要输入的密码，用来解锁keystore的</li></ol><p><code>私钥 Private Key</code></p><p>私钥由64位长度的十六进制的字符组成，比如：<code>0xA4356E49C88C8B7AB370AF7D5C0C54F0261AAA006F6BDE09CD4745CF54E0115A</code>，一个账户只有一个私钥且不能修改。<br>通常一个钱包中私钥和公钥是成对出现的，有了私钥，我们就可以通过一定的算法生成公钥，再通过公钥经过一定的算法生成地址，这一过程都是不可逆的。私钥一定要妥善保管，若被泄漏别人可以通过私钥解锁账号转出你的该账号的数字货币。</p><p><code>公钥 Public Key</code></p><p>公钥(Public Key)是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</p><p><code>Keystore</code></p><p>Keystore常见于以太坊钱包，它是将私钥以加密的方式保存为一份 JSON 文件，这份 JSON 文件就是 keystore，所以它就是加密后的私钥。Keystore必须配合钱包密码才能导入并使用该账号。当黑客盗取 Keystore 后，在没有密码情况下, 有可能通过暴力破解 Keystore 密码解开 Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。</p><p><code>助记词 Mnemonic</code></p><p>私钥是64位长度的十六进制的字符，不利于记录且容易记错，所以用算法将一串随机数转化为了一串12 ~ 24个容易记住的单词，方便保存记录。注意：</p><ol><li>助记词是私钥的另一种表现形式</li><li>助记词=私钥，这是不正确的说法，通过助记词可以获取相关联的多个私钥，但是通过其中一个私钥是不能获取助记词的，因此<strong>助记词≠私钥</strong>。</li></ol><p>BIP</p><p>要弄清楚助记词与私钥的关系，得清楚BIP协议，是<code>Bitcoin Improvement Proposals</code>的缩写，意思是Bitcoin 的改进建议，用于提出 Bitcoin 的新功能或改进措施。BIP协议衍生了很多的版本，主要有BIP32、BIP39、BIP44。</p><p><strong>BIP32</strong></p><p>BIP32是 HD钱包的核心提案，通过种子来生成主私钥，然后派生海量的子私钥和地址，种子是一串很长的随机数。</p><p><strong>BIP39</strong></p><p>由于种子是一串很长的随机数，不利于记录，所以我们用算法将种子转化为一串12 ~ 24个的单词，方便保存记录，这就是BIP39，它扩展了 HD钱包种子的生成算法。</p><p><strong>BIP44</strong></p><p>BIP44 是在 BIP32 和 BIP43 的基础上增加多币种，提出的层次结构非常全面，它允许处理多个币种，多个帐户，每个帐户有数百万个地址。</p><p>在BIP32路径中定义以下5个级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m/purpse&apos;/coin_type&apos;/account&apos;/change/address_index</span><br></pre></td></tr></table></figure><ul><li>purpose：在BIP43之后建议将常数设置为44’。表示根据BIP44规范使用该节点的子树。</li><li>Coin_type：币种，代表一个主节点（种子）可用于无限数量的独立加密币，如比特币，Litecoin或Namecoin。此级别为每个加密币创建一个单独的子树，避免重用已经在其它链上存在的地址。开发人员可以为他们的项目注册未使用的号码。</li><li>Account：账户，此级别为了设置独立的用户身份可以将所有币种放在一个的帐户中，从0开始按顺序递增。</li><li>Change：常量0用于外部链，常量1用于内部链，外部链用于钱包在外部用于接收和付款。内部链用于在钱包外部不可见的地址，如返回交易变更。</li><li>Address_index：地址索引，按顺序递增的方式从索引0开始编号。</li></ul><p>BIP44的规则使得 HD钱包非常强大，用户只需要保存一个种子，就能控制所有币种，所有账户的钱包，因此由BIP39 生成的助记词非常重要，所以一定安全妥善保管，那么会不会被破解呢？如果一个 HD 钱包助记词是 12 个单词，一共有 2048 个单词可能性，那么随机的生成的助记词所有可能性大概是<code>5e+39</code>，因此几乎不可能被破解。</p><p><code>HD钱包</code></p><p>通过BIP协议生成账号的钱包叫做HD钱包。这个HD钱包，并不是Hardware Wallet硬件钱包，这里的 HD 是<code>Hierarchical Deterministic</code>的缩写，意思是分层确定性，所以HD钱包的全称为比特币分成确定性钱包 。</p><h2 id="密码、私钥、keystore与助记词的关系"><a href="#密码、私钥、keystore与助记词的关系" class="headerlink" title="密码、私钥、keystore与助记词的关系"></a>密码、私钥、keystore与助记词的关系</h2><p><img src="/2025/03/10/以太坊钱包开发/8.png" alt="img"></p><h2 id="钱包的核心：私钥"><a href="#钱包的核心：私钥" class="headerlink" title="钱包的核心：私钥"></a>钱包的核心：私钥</h2><p>基于以上的分析，我们对以太坊钱包的账号系统有了一个很好的认识，那么我们在使用钱包的过程中，该如何保管自己的钱包呢？主要包含以下几种方式：</p><ul><li>私钥（Private Key）</li><li>Keystore+密码（Keystore+Password）</li><li>助记词（Mnemonic code）</li></ul><p>通过以上三种中的一种方式都可以解锁账号，然后掌控它，所以对于每种方式中的数据都必须妥善包括，如有泄漏，请尽快转移数字资产。</p><p>我们可以得到以下总结：</p><ul><li>通过私钥+密码可以生成keystore，即加密私钥；</li><li>通过keystore+密码可以获取私钥，即解密keystore。</li><li>通过助记词根据不同的路径获取不同的私钥，即使用HD钱包将助记词转化成种子来生成主私钥，然后派生海量的子私钥和地址。</li></ul><p>可以看出这几种方式的核心其实都是为了获得私钥，然后去解锁账号，因此钱包的核心功能是私钥的创建、存储和使用。</p><p><strong>参考资料</strong></p><p><a href="https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html" target="_blank" rel="noopener">https://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a><br><a href="https://github.com/ethereum/EIPs/issues/84" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/84</a><br><a href="https://github.com/ethereum/EIPs/issues/85" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/85</a></p><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><blockquote><p>从无到有创建一个新的账户</p></blockquote><h3 id="web3-直接创建账户"><a href="#web3-直接创建账户" class="headerlink" title="web3 直接创建账户"></a>web3 直接创建账户</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create(<span class="string">'2435@#@#@±±±±!!!!678543213456764321§34567543213456785432134567'</span>);</span><br></pre></td></tr></table></figure><h3 id="助记词-创建账户"><a href="#助记词-创建账户" class="headerlink" title="助记词 创建账户"></a>助记词 创建账户</h3><p>需要使用<code>bip39</code>协议将助记词转换成种子，再通过<code>ethereumjs-wallet</code>库生成hd钱包，根据路径的不同从hd钱包中获取不同的keypair，keypair中就包含有公钥、私钥，再通过<code>ethereumjs-util</code>库将公钥生成地址，从而根据助记词获取所有关联的账号，能获取到公钥、私钥、地址等数据信息。</p><h4 id="1-依赖库"><a href="#1-依赖库" class="headerlink" title="1. 依赖库"></a>1. 依赖库</h4><p>需要用到三个库：bip39、ethereumjs-wallet/hdkey、ethereumjs-util。先安装依赖库，<code>cd</code>到项目跟路径运行命令<code>npm i bip39 ethereumjs-wallet ethereumjs-util</code>。</p><ul><li><a href="https://github.com/bitcoinjs/bip39" target="_blank" rel="noopener">bip39</a>：随机产生新的 mnemonic code，并可以将其转成 binary 的 seed。</li><li><a href="https://github.com/ethereumjs/ethereumjs-wallet" target="_blank" rel="noopener">ethereumjs-wallet</a>：生成和管理公私钥，下面使用其中 hdkey 子套件来创建 HD 钱包。</li><li><a href="https://github.com/ethereumjs/ethereumjs-util" target="_blank" rel="noopener">ethereumjs-util</a>：Ethereum 的一个工具库。</li><li><a href="https://iancoleman.io/bip39/" target="_blank" rel="noopener">https://iancoleman.io/bip39/</a></li></ul><h4 id="2-通过助记词创建账号"><a href="#2-通过助记词创建账号" class="headerlink" title="2. 通过助记词创建账号"></a>2. 通过助记词创建账号</h4><ul><li><p>创建助记词</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入bip39模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bip39 <span class="keyword">from</span> <span class="string">"bip39"</span>;</span><br><span class="line"><span class="comment">// 创建助记词 </span></span><br><span class="line"><span class="keyword">let</span> mnemonic = bip39.generateMnemonic();</span><br><span class="line"><span class="built_in">console</span>.log(mnemonic);</span><br><span class="line"><span class="comment">// 结果 12位助记词</span></span><br><span class="line"><span class="comment">// vote select solar shy embrace immense lizard stamp scrub vague negative forward</span></span><br></pre></td></tr></table></figure></li><li><p>根据助记词生成密钥对 keypair</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 导入分层钱包模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; hdkey &#125; <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;</span><br><span class="line">      <span class="comment">//1.将助记词转成seed</span></span><br><span class="line">      <span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.mnemonicToSeed(<span class="string">"12位助记词"</span>);</span><br><span class="line">      <span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line">      <span class="keyword">let</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">      <span class="comment">//4.生成钱包中在m/44'/60'/0'/0/i路径的keypair</span></span><br><span class="line">      <span class="keyword">let</span> keypair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(keypair);</span><br></pre></td></tr></table></figure><p>keypair 密钥对</p><p><img src="/2025/03/10/以太坊钱包开发/9.png" alt="image-20221208222354836"></p><h4 id="3-由keypair-获取钱包地址和私钥"><a href="#3-由keypair-获取钱包地址和私钥" class="headerlink" title="3. 由keypair 获取钱包地址和私钥"></a>3. 由keypair 获取钱包地址和私钥</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.getWallet();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"lowerCaseAddress"</span>, lowerCaseAddress);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"CheckSumAddress"</span>, CheckSumAddress);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"prikey"</span>, prikey);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lowerCaseAddress 0xd9fc0fd4412616c7075e68b151ab3a7bcb9a3f54</span></span><br><span class="line"><span class="comment">CheckSumAddress 0xd9fC0FD4412616c7075E68b151ab3A7bcB9A3f54</span></span><br><span class="line"><span class="comment">prikey 3fc11495517f1f015bbcb6c311da66e3b26b23e4c91c1285ccc4b69d9d274002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="导出账户"><a href="#导出账户" class="headerlink" title="导出账户"></a>导出账户</h2><blockquote><p>一个已经存在的账户导出 私钥 和 keystore</p></blockquote><ol><li>通过分层钱包对象 + 密码 创建keystore</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(data.pass1); <span class="comment">// 参数必须为 字符串</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过私钥和密码创建 keystore </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keystore = <span class="keyword">await</span> web3.eth.accounts.encrypt(<span class="string">"账户私钥"</span>,<span class="string">"密码"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟keystore数据</span></span><br><span class="line"><span class="keyword">const</span> keystoreJsonV3 = &#123;</span><br><span class="line">        version: <span class="number">3</span>,</span><br><span class="line">        id: <span class="string">"dbb70fb2-52ad-4e1f-9c19-0b50329f89c3"</span>,</span><br><span class="line">        address: <span class="string">"445b469888528dacd9b87246c5ce70407adaa411"</span>,</span><br><span class="line">        crypto: &#123;</span><br><span class="line">          ciphertext:</span><br><span class="line">            <span class="string">"1e53e7e775644422600188b8134907992db40d278064ea3a966da4dcdf80db64"</span>,</span><br><span class="line">          cipherparams: &#123; <span class="attr">iv</span>: <span class="string">"f9d2b047019674eee449b316f4a21491"</span> &#125;,</span><br><span class="line">          cipher: <span class="string">"aes-128-ctr"</span>,</span><br><span class="line">          kdf: <span class="string">"scrypt"</span>,</span><br><span class="line">          kdfparams: &#123;</span><br><span class="line">            dklen: <span class="number">32</span>,</span><br><span class="line">            salt: <span class="string">"153e074d78d0ba36fae3e46e582c42e53f61653cb5d4f1a3a3f68094e6ca0160"</span>,</span><br><span class="line">            n: <span class="number">8192</span>,</span><br><span class="line">            r: <span class="number">8</span>,</span><br><span class="line">            p: <span class="number">1</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          mac: <span class="string">"e91456c59b2505c16b80c2495ab7b4633273c2ae366cb6953f27de8cfebad629"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"> <span class="keyword">const</span> res = web3.eth.accounts.decrypt(keystoreJsonV3, <span class="string">"1235"</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过keystore解密私钥</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br></pre></td></tr></table></figure><h2 id="导入账户"><a href="#导入账户" class="headerlink" title="导入账户"></a>导入账户</h2><blockquote><p>通过 私钥、助记词、keystore 导入一个已经存在的钱包账户 地址 和 私钥</p></blockquote><ol><li>通过keystore获取 私钥和地址 </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line"><span class="keyword">let</span> address = wallet.getAddressString()</span><br></pre></td></tr></table></figure><ol start="2"><li>通过助记词 获取地址和私钥</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mnemonic=prompt(<span class="string">"请输入助记词"</span>)</span><br><span class="line"><span class="keyword">let</span> seed = bip39.mnemonicToSeed(mnemonic)</span><br><span class="line"><span class="keyword">let</span> hdwallet = hdkey.fromMasterSeed(seed)</span><br><span class="line"><span class="keyword">let</span> keypair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.getWallet();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>通过私钥获取 地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;     </span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> Buffer( prompt(<span class="string">"请输入私钥"</span>), <span class="string">'hex'</span> )</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.fromPrivateKey(privatekey)</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br></pre></td></tr></table></figure></li></ol><h1 id="区块链钱包项目流程"><a href="#区块链钱包项目流程" class="headerlink" title="区块链钱包项目流程"></a>区块链钱包项目流程</h1><p><img src="/2025/03/10/以太坊钱包开发/10.png" alt="image-20221209110335777"></p><h3 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1.项目准备"></a>1.项目准备</h3><p>​         直接采用随堂demo创建的项目 不需要重新创建</p><h4 id="web3相关第三方包-1"><a href="#web3相关第三方包-1" class="headerlink" title="web3相关第三方包"></a>web3相关第三方包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3 bip39 ethereumjs-tx@1.3.7 ethereumjs-util ethereumjs-wallet</span><br></pre></td></tr></table></figure><blockquote><p>注： ethereumjs-tx 使用1.3.7 版本</p></blockquote><h4 id="node-polyfill-兼容文件配置-1"><a href="#node-polyfill-兼容文件配置-1" class="headerlink" title="node-polyfill 兼容文件配置"></a>node-polyfill 兼容文件配置</h4><ol><li><p>下载polyfill 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-polyfill-webpack-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js 文件中配置插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line">++ <span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">++  configureWebpack: &#123;</span><br><span class="line">++    plugins: [</span><br><span class="line">++      <span class="keyword">new</span> NodePolyfillWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置vant-ui-ui组件库-1"><a href="#配置vant-ui-ui组件库-1" class="headerlink" title="配置vant-ui ui组件库"></a>配置vant-ui ui组件库</h4><p><a href="https://vant-contrib.gitee.io/vant/#/zh-CN" target="_blank" rel="noopener">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vant</span><br><span class="line">$ npm i unplugin-vue-components -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在vue.config.js 文件中配置插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">"@vue/cli-service"</span>);</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> NodePolyfillWebpackPlugin = <span class="built_in">require</span>(<span class="string">"node-polyfill-webpack-plugin"</span>);</span><br><span class="line"><span class="comment">// vant</span></span><br><span class="line">++ <span class="keyword">const</span> &#123; VantResolver &#125; = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>);</span><br><span class="line">++ <span class="keyword">const</span> ComponentsPlugin = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: <span class="literal">true</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> NodePolyfillWebpackPlugin(),</span><br><span class="line">++    ComponentsPlugin(&#123; <span class="attr">resolvers</span>: [VantResolver()]&#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试 在app.vue文件添加代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;van-button type=&quot;primary&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line"> &lt;van-button type=&quot;success&quot;&gt;test&lt;/van-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/10/以太坊钱包开发/11.png" alt="image-20230102202255947"></p><h4 id="通过vw配置响应式-1"><a href="#通过vw配置响应式-1" class="headerlink" title="通过vw配置响应式"></a>通过vw配置响应式</h4><p><a href="https://www.cnblogs.com/hongrun/p/16130707.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongrun/p/16130707.html</a></p><ol><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px-to-viewport -D</span><br></pre></td></tr></table></figure><ol start="2"><li>在根目录下创建 名为 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">      unitToConvert: <span class="string">"px"</span>, <span class="comment">// 要转化的单位</span></span><br><span class="line">      viewportWidth: <span class="number">375</span>, <span class="comment">// UI设计稿的宽度</span></span><br><span class="line">      unitPrecision: <span class="number">6</span>, <span class="comment">// 转换后的精度，即小数点位数</span></span><br><span class="line">      propList: [<span class="string">"*"</span>], <span class="comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span></span><br><span class="line">      viewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定需要转换成的视窗单位，默认vw</span></span><br><span class="line">      fontViewportUnit: <span class="string">"vw"</span>, <span class="comment">// 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: ["wrap"], // 指定不转换为视窗单位的类名，</span></span><br><span class="line">      minPixelValue: <span class="number">1</span>, <span class="comment">// 默认值1，小于或等于1px则不进行转换</span></span><br><span class="line">      mediaQuery: <span class="literal">true</span>, <span class="comment">// 是否在媒体查询的css代码中也进行转换，默认false</span></span><br><span class="line">      replace: <span class="literal">true</span>, <span class="comment">// 是否转换后直接更换属性值</span></span><br><span class="line">      exclude: [<span class="regexp">/node_modules/</span>], <span class="comment">// 设置忽略文件，用正则做目录名匹配</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="封装缓存函数"><a href="#封装缓存函数" class="headerlink" title="封装缓存函数"></a>封装缓存函数</h4><p>整个项目为了保证钱包的安全性，所有账户相关的操作，不经过中心化服务器，只在缓存使用</p><p>在这里可以参考<code>webstorage</code>增加过期时间，cookie 等的封装</p><p>创建 src/utils/storage.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  setItem(key, val) &#123;</span><br><span class="line">    localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(val || <span class="string">""</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  getItem(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> val;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      val = <span class="built_in">JSON</span>.parse(localStorage.getItem(key));</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      val = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Storage();</span><br></pre></td></tr></table></figure><h4 id="app-vue-文件引入"><a href="#app-vue-文件引入" class="headerlink" title="app.vue 文件引入"></a>app.vue 文件引入</h4><p>在app.vue 引入文件并且初始化web3.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">   &lt;h3&gt; qf - eth -wallet&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// import * as util from &quot;ethereumjs-util&quot;;</span><br><span class="line">import ethwallet from &quot;ethereumjs-wallet&quot;;  </span><br><span class="line">import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import * as bip39 from &quot;bip39&quot;;</span><br><span class="line">import Tx from &quot;ethereumjs-tx&quot;;</span><br><span class="line">import Web3 from &quot;web3&quot;;</span><br><span class="line">import storage from &quot;@/utils/storage&quot;;</span><br><span class="line">var web3 = new Web3(</span><br><span class="line">  Web3.givenProvider ||</span><br><span class="line">    &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-通过Mnemonic助记词创建钱包"><a href="#2-通过Mnemonic助记词创建钱包" class="headerlink" title="2.通过Mnemonic助记词创建钱包"></a>2.通过Mnemonic助记词创建钱包</h3><blockquote><p> 判断缓存是否有 钱包对象</p><ol><li>有钱包对象显示钱包信息  地址 私钥  余额</li><li>没有钱包对象显示创建钱包按钮</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;qf - eth -wallet&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;创建钱包&lt;/h4&gt;</span><br><span class="line">    &lt;van-button type=&quot;primary&quot; @click=&quot;createWallet&quot;&gt; 创建钱包 &lt;/van-button&gt;</span><br><span class="line">    &lt;van-button type=&quot;primary&quot; @click=&quot;importWallet&quot;&gt;</span><br><span class="line">      导入钱包-助记词</span><br><span class="line">    &lt;/van-button&gt;</span><br><span class="line">    &lt;h4&gt;钱包信息&lt;/h4&gt;</span><br><span class="line">    &#123;&#123; wallet &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">// import * as util from &quot;ethereumjs-util&quot;;</span><br><span class="line">import ethwallet from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import &#123; hdkey &#125; from &quot;ethereumjs-wallet&quot;;</span><br><span class="line">import * as bip39 from &quot;bip39&quot;;</span><br><span class="line">import Tx from &quot;ethereumjs-tx&quot;;</span><br><span class="line">import storage from &quot;@/utils/storage&quot;;</span><br><span class="line">import Web3 from &quot;web3&quot;;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;;</span><br><span class="line">var web3 = new Web3(</span><br><span class="line">  Web3.givenProvider ||</span><br><span class="line">    &quot;https://goerli.infura.io/v3/e4f789009c9245eeaad1d93ce9d059bb&quot;</span><br><span class="line">);</span><br><span class="line">const wallet = reactive(storage.getItem(&quot;wallet&quot;) || &#123;&#125;);</span><br><span class="line">console.log(wallet);</span><br><span class="line">async function createWallet() &#123;</span><br><span class="line">  const pass = prompt(&quot;请输入您的钱包密码&quot;);</span><br><span class="line">  if (!pass) return false;</span><br><span class="line">  let mnemonic = bip39.generateMnemonic();</span><br><span class="line">  alert(&quot;您的助记词为:&quot; + mnemonic);</span><br><span class="line">  const checkMnemonic = prompt(&quot;请输入您的助记词&quot;);</span><br><span class="line">  if (mnemonic === checkMnemonic) &#123;</span><br><span class="line">    //1.将助记词转成seed</span><br><span class="line">    let seed = await bip39.mnemonicToSeed(mnemonic);</span><br><span class="line">    //3.通过hdkey将seed生成HD Wallet</span><br><span class="line">    let hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">    //4.生成钱包中在m/44&apos;/60&apos;/0&apos;/0/i路径的keypair</span><br><span class="line">    let keyPair = hdWallet.derivePath(&quot;m/44&apos;/60&apos;/0&apos;/0/0&quot;);</span><br><span class="line">    // 获取钱包对象</span><br><span class="line">    let wallet = keyPair.getWallet();</span><br><span class="line">    // 获取钱包地址</span><br><span class="line">    let lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">    // 获取钱包校验地址</span><br><span class="line">    let CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line">    // 获取私钥</span><br><span class="line">    let prikey = wallet.getPrivateKey().toString(&quot;hex&quot;);</span><br><span class="line">    let keystore = await wallet.toV3(pass);</span><br><span class="line">    console.log(keystore);</span><br><span class="line">    // 保存钱包信息</span><br><span class="line">    const walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: 0,</span><br><span class="line">      mnemonic, // 助记词不应该记录下来仅仅是为了便于演示</span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(&quot;wallet&quot;, walletInfo);</span><br><span class="line">    wallet = walletInfo;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(&quot;助记词错误请重新输入&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-显示余额"><a href="#3-显示余额" class="headerlink" title="3.显示余额"></a>3.显示余额</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balance = ref(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取余额</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!wallet.address) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 根据地址查询余额</span></span><br><span class="line">  web3.eth.getBalance(wallet.address).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    balance.value = web3.utils.fromWei(ret, <span class="string">"ether"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">getBalance()</span><br></pre></td></tr></table></figure><h3 id="4-转账交易"><a href="#4-转账交易" class="headerlink" title="4.转账交易"></a>4.转账交易</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 获取用户输入金额 与 地址 </span><br><span class="line"><span class="number">2.</span> 调用send 方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keystore = storage.getItem(<span class="string">"wallet"</span>).keystore;</span><br><span class="line">  <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">  <span class="keyword">let</span> walletobj;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    walletobj = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    alert(<span class="string">"密码错误"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> key = walletobj.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">  <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">  <span class="comment">// console.log(privateKey);</span></span><br><span class="line">  <span class="keyword">const</span> fromaddress = wallet.address;</span><br><span class="line">  <span class="comment">// 获取账户交易次数</span></span><br><span class="line">  <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(fromaddress);</span><br><span class="line">  <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">  <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.eth.getGasPrice();</span><br><span class="line">  <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">  <span class="built_in">console</span>.log(number.value, <span class="keyword">typeof</span> number.value);</span><br><span class="line">  <span class="keyword">let</span> balance = Web3.utils.toWei(number.value);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">  <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">    <span class="keyword">from</span>: fromaddress,</span><br><span class="line">    nonce: nonce,</span><br><span class="line">    gasPrice: gasPrice,</span><br><span class="line">    to: toaddress.value,</span><br><span class="line">    value: balance,</span><br><span class="line">    data: <span class="string">"0x00"</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">  <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.eth.estimateGas(rawTx);</span><br><span class="line">  rawTx.gas = gas;</span><br><span class="line">  <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">  <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">  tx.sign(privateKey);</span><br><span class="line">  <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line"></span><br><span class="line">  web3.eth</span><br><span class="line">    .sendSignedTransaction(<span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>))</span><br><span class="line">    .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// .on('receipt', (ret)=&gt;&#123;console.log('receipt')&#125;)</span></span><br><span class="line">    <span class="comment">// .on('confirmation', (ret)=&gt;&#123;console.log('confirmation')&#125;)</span></span><br><span class="line">    .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"error:"</span> + err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-导出账户信息"><a href="#5-导出账户信息" class="headerlink" title="5.导出账户信息"></a>5.导出账户信息</h3><ul><li>导出私钥</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">exportKey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">       <span class="keyword">let</span> walletObj;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        walletObj = <span class="keyword">await</span> ethwallet.fromV3(wallet.keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         alert(<span class="string">"密码错误"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = walletObj.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">   alert(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导出keystore </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缓存对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exportKeyStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">JSON</span>.stringify(wallet.keystore))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-解锁账户信息"><a href="#6-解锁账户信息" class="headerlink" title="6.解锁账户信息"></a>6.解锁账户信息</h3><ul><li><p>助记词解锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">添加助记词导入钱包方法</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">importWallet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mnemonic = prompt(<span class="string">"请输入助记词"</span>);</span><br><span class="line">  <span class="keyword">const</span> pass = prompt(<span class="string">"请输入您的钱包密码"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!pass) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//1.将助记词转成seed</span></span><br><span class="line">    <span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.mnemonicToSeed(mnemonic);</span><br><span class="line">    <span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line">    <span class="keyword">let</span> hdWallet = hdkey.fromMasterSeed(seed);</span><br><span class="line">    <span class="comment">//4.生成钱包中在m/44'/60'/0'/0/i路径的keypair</span></span><br><span class="line">    <span class="keyword">let</span> keyPair = hdWallet.derivePath(<span class="string">"m/44'/60'/0'/0/0"</span>);</span><br><span class="line">    <span class="comment">// 获取钱包对象</span></span><br><span class="line">    <span class="keyword">let</span> wallet = keyPair.getWallet();</span><br><span class="line">    <span class="comment">// 获取钱包地址</span></span><br><span class="line">    <span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">    <span class="comment">// 获取钱包校验地址</span></span><br><span class="line">    <span class="keyword">let</span> CheckSumAddress = wallet.getChecksumAddressString();</span><br><span class="line">    <span class="comment">// 获取私钥</span></span><br><span class="line">    <span class="keyword">let</span> prikey = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">    <span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(pass);</span><br><span class="line">    <span class="built_in">console</span>.log(keystore);</span><br><span class="line">    <span class="comment">// 保存钱包信息</span></span><br><span class="line">    <span class="keyword">const</span> walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: <span class="number">0</span>,</span><br><span class="line">      mnemonic, <span class="comment">// 助记词不应该记录下来仅仅是为了便于演示</span></span><br><span class="line">    &#125;;</span><br><span class="line">    storage.setItem(<span class="string">"wallet"</span>, walletInfo);</span><br><span class="line">    wallet = walletInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>私钥解锁</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">importByPrivateKey</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> key = prompt(<span class="string">"请输入私钥"</span>)</span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> Buffer(key , <span class="string">'hex'</span> )</span><br><span class="line">  <span class="keyword">let</span> pass =  prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.fromPrivateKey(privatekey)</span><br><span class="line">  <span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.toV3(pass);</span><br><span class="line">  <span class="comment">// 获取钱包地址</span></span><br><span class="line">  <span class="keyword">let</span> lowerCaseAddress = wallet.getAddressString();</span><br><span class="line">  <span class="keyword">const</span> walletInfo = &#123;</span><br><span class="line">      address: lowerCaseAddress,</span><br><span class="line">      prikey: key,</span><br><span class="line">      keystore,</span><br><span class="line">      balance: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(walletInfo)</span><br><span class="line">    storage.setItem(<span class="string">"wallet"</span>, walletInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>未来展望<ul><li>通过uniapp 、rn、electron 将项目变为app和桌面端应用</li><li>app添加扫码转账功能</li><li>增加erc20代币转账功能</li><li>增加nft数字藏品商城功能</li><li>增加Dao 应用</li></ul></li></ol><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol><li><p>通过智能合约文件 获取abi</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; abi &#125; <span class="keyword">from</span> <span class="string">"@/contract/HHC.json"</span>;</span><br></pre></td></tr></table></figure></li><li><p>在web3实例的基础上创建智能合约实例</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hhc = <span class="keyword">new</span> <span class="keyword">this</span>.web3.eth.Contract(</span><br><span class="line">  abi,</span><br><span class="line">  <span class="string">"0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过智能合约实例获取代币余额</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> num = <span class="keyword">await</span> hhc.methods.balanceOf(address).call();</span><br><span class="line">Web3.utils.fromWei(num, <span class="string">"ether"</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>智能合约交易hash 创建</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> createCoinTransationHx(contractInstance, method, to, value) &#123;</span><br><span class="line">   <span class="keyword">let</span> pass = prompt(<span class="string">"请输入密码"</span>);</span><br><span class="line">   <span class="keyword">let</span> wallet;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     wallet = <span class="keyword">await</span> ethwallet.fromV3(keystore, pass);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     alert(<span class="string">"密码错误"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.getPrivateKey().toString(<span class="string">"hex"</span>);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">from</span> = <span class="keyword">this</span>.ownerAddress;</span><br><span class="line">   <span class="comment">// 当前地址交易次数</span></span><br><span class="line">   <span class="keyword">const</span> nonce = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.getTransactionCount(<span class="keyword">from</span>);</span><br><span class="line">   <span class="keyword">var</span> privateKey = <span class="keyword">new</span> Buffer(key, <span class="string">"hex"</span>);</span><br><span class="line">   <span class="comment">// 获取预计转账gas费</span></span><br><span class="line">   <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.getGasPrice();</span><br><span class="line">   <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line">   <span class="keyword">let</span> weiValue = <span class="keyword">await</span> Web3.utils.toWei(value);</span><br><span class="line">   <span class="comment">// 转账的记录对象</span></span><br><span class="line">   <span class="comment">// 代币转账</span></span><br><span class="line">   <span class="comment">// this.HccCont = new this.web3.eth.Contract(</span></span><br><span class="line">   <span class="comment">//   abi,</span></span><br><span class="line">   <span class="comment">//   "0x18dAaC8e2E422fDB5e26715eF1EcDca11F78eDE5"</span></span><br><span class="line">   <span class="comment">// );</span></span><br><span class="line">   <span class="keyword">const</span> contractAbi = <span class="keyword">await</span> contractInstance.methods[method](</span><br><span class="line">     to,</span><br><span class="line">     weiValue</span><br><span class="line">   ).encodeABI();</span><br><span class="line">   <span class="comment">// console.log(contractAbi);</span></span><br><span class="line">   <span class="comment">// console.log(contractInstance._address);</span></span><br><span class="line">   <span class="comment">// return false;</span></span><br><span class="line">   <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">     <span class="keyword">from</span>: <span class="keyword">this</span>.ownerAddress,</span><br><span class="line">     nonce: nonce,</span><br><span class="line">     gasPrice: gasPrice,</span><br><span class="line">     to: contractInstance._address, <span class="comment">//eth 转账 to 目标地址 ，智能合约 to 智能合约地址</span></span><br><span class="line">     value: <span class="number">0</span>, <span class="comment">//eth 转账 数量</span></span><br><span class="line">     data: contractAbi, <span class="comment">//智能合约方法的abi编码</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">   <span class="keyword">let</span> gas = <span class="keyword">await</span> <span class="keyword">this</span>.instance.eth.estimateGas(rawTx);</span><br><span class="line">   rawTx.gas = gas;</span><br><span class="line">   <span class="comment">// 通过tx实现交易对象的加密操作</span></span><br><span class="line">   <span class="keyword">var</span> tx = <span class="keyword">new</span> Tx(rawTx);</span><br><span class="line">   tx.sign(privateKey);</span><br><span class="line">   <span class="keyword">var</span> serializedTx = tx.serialize();</span><br><span class="line">   <span class="keyword">var</span> transationHx = <span class="string">"0x"</span> + serializedTx.toString(<span class="string">"hex"</span>);</span><br><span class="line">   <span class="keyword">return</span> transationHx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>智能合约代币转账</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.web3.eth</span><br><span class="line">      .sendSignedTransaction(hx)</span><br><span class="line">      .on(<span class="string">"transactionHash"</span>, (txid) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"交易成功,请在区块链浏览器查看"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"交易id"</span>, txid);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"receipt"</span>, (ret) =&gt; &#123;</span><br><span class="line">        cb &amp;&amp; cb(ret);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"receipt"</span>, ret);</span><br><span class="line">        <span class="keyword">const</span> &#123; transactionHash &#125; = ret;</span><br><span class="line">        <span class="keyword">this</span>.createOrderData(transactionHash);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"latestBlockHash"</span>, (...arg) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"latestBlockHash"</span>, arg);</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error:"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以上内容来自千锋教育，并无商业用途，仅供学习使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用vue开发以太坊钱包&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="WEB3" scheme="/tags/WEB3/"/>
    
  </entry>
  
  <entry>
    <title>RAG系统搭建(基础版)</title>
    <link href="/2025/02/20/RAG%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA-%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    <id>/2025/02/20/RAG系统搭建-基础版/</id>
    <published>2025-02-20T07:32:05.000Z</published>
    <updated>2025-02-21T06:11:52.607Z</updated>
    
    <content type="html"><![CDATA[<p>简单的搭建一个大语言模型的RAG系统<br><a id="more"></a><br>RAG（Retrieval-Augmented Generation）系统是一种结合了信息检索（Retrieval）和文本生成（Generation）能力的框架，通过将传统的基于检索的方法与现代的生成模型相结合，来提升对任务的回答质量和准确性。<br><img src="/2025/02/20/RAG系统搭建-基础版/1.png" alt="img"></p><h2 id="python环境搭建"><a href="#python环境搭建" class="headerlink" title="python环境搭建"></a>python环境搭建</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用Anaconda来安装python环境，可以直接在系统的应用商店中安装。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>打开Anaconda PowerShell Prompt<br>1.创建环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name envName python=3.10 // 目前最好使用3.10版本，对各种库的兼容性比较好</span><br></pre></td></tr></table></figure></p><p>2.激活环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate envName</span><br></pre></td></tr></table></figure></p><p>3.查看当前环境列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure></p><p>4.卸载环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 确保当前激活环境非要删除的envName</span><br><span class="line">conda env remove --name envName</span><br></pre></td></tr></table></figure></p><p>5.安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 安装单个包</span><br><span class="line">pip install package_name</span><br><span class="line"></span><br><span class="line">// 根据requirements.txt文件安装所有依赖</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p>6.更换镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">华为云：https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure></p><p>7.查看当前环境都安装了哪些依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></p><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p><a href="https://huggingface.co/models" target="_blank" rel="noopener">HuggingFace模型</a>，这个网站需要科学上网，所以国内使用<a href="https://modelscope.cn/models" target="_blank" rel="noopener">modelscope</a></p><h3 id="安装modelscope依赖库"><a href="#安装modelscope依赖库" class="headerlink" title="安装modelscope依赖库"></a>安装modelscope依赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install modelscope -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="Sentence-Transformer模型下载"><a href="#Sentence-Transformer模型下载" class="headerlink" title="Sentence Transformer模型下载"></a>Sentence Transformer模型下载</h3><p>在进行RAG之前，需要使用词向量模型进行Embedding，将文本进行向量化处理，执行下述命令下载模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 模型下载</span><br><span class="line">from modelscope import snapshot_download</span><br><span class="line"></span><br><span class="line"># model_id 模型的id</span><br><span class="line"># cache_dir 模型下载路径</span><br><span class="line">model_dir = snapshot_download(model_id=&apos;Ceceliachenen/paraphrase-multilingual-MiniLM-L12-v2&apos;, cache_dir=&apos;D:/jinux/models&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="LLM模型下载"><a href="#LLM模型下载" class="headerlink" title="LLM模型下载"></a>LLM模型下载</h3><p>这里选择千问0.5B大模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from modelscope import snapshot_download</span><br><span class="line"></span><br><span class="line">model_dir = snapshot_download(model_id=&apos;Qwen/Qwen2.5-0.5B-Instruct&apos;, cache_dir=&apos;D:/jinux/models&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><p>下边案例所需要的依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install llama_index -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install llama_index.llms.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install transformers -i https://repo.huaweicloud.com/repository/pypi/simple</span><br><span class="line">pip install llama_index.embeddings.huggingface -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure></p><h2 id="调用本地模型进行推理测试"><a href="#调用本地模型进行推理测试" class="headerlink" title="调用本地模型进行推理测试"></a>调用本地模型进行推理测试</h2><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from llama_index.llms.huggingface import HuggingFaceLLM</span><br><span class="line">from llama_index.core.llms import ChatMessage</span><br><span class="line"></span><br><span class="line"># 使用HuggingFace 加载本地大模型</span><br><span class="line">llm = HuggingFaceLLM(</span><br><span class="line">  # 给定的是本地模型的全路径</span><br><span class="line">  model_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字</span><br><span class="line">  tokenizer_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 模型名字</span><br><span class="line">  model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;,</span><br><span class="line">  tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;</span><br><span class="line">)</span><br><span class="line">rsp = llm.chat(messages=[ChatMessage(content=&quot;请简单的介绍一下jinux&quot;)])</span><br><span class="line">print(rsp)</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">Jenkins 是一个开源的自动化构建工具，它允许开发者......</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line"> JLinux 是一种基于 Linux 的开源操作系统，由阿里云......</span><br></pre></td></tr></table></figure><p>推理结果每次都是错的。</p><h2 id="创建知识库-RAG"><a href="#创建知识库-RAG" class="headerlink" title="创建知识库(RAG)"></a>创建知识库(RAG)</h2><h3 id="执行代码-1"><a href="#执行代码-1" class="headerlink" title="执行代码"></a>执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings</span><br><span class="line">from llama_index.embeddings.huggingface import HuggingFaceEmbedding</span><br><span class="line">from llama_index.llms.huggingface import HuggingFaceLLM</span><br><span class="line"></span><br><span class="line"># 初始化一个HuggingFaceEmbedding对象，用于将文本转换为向量表示</span><br><span class="line"># 指定了一个预训练的sentence-transformer模型的路径</span><br><span class="line">embed_model = HuggingFaceEmbedding(</span><br><span class="line">    model_name=r&quot;D:\jinux\models\Ceceliachenen\paraphrase-multilingual-MiniLM-L12-v2&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 将创建的嵌入模型赋值给全局设置的embed_model属性，</span><br><span class="line"># 这样在后续的索引构建过程中就会使用这个模型。</span><br><span class="line">Settings.embed_model = embed_model</span><br><span class="line"></span><br><span class="line"># 推理模型（生成模型）</span><br><span class="line">llm = HuggingFaceLLM(</span><br><span class="line">  # 给定的是本地模型的全路径</span><br><span class="line">  model_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 这里是下载的模型名字</span><br><span class="line">  tokenizer_name=r&quot;D:\jinux\models\Qwen\Qwen2___5-0___5B-Instruct&quot;, # 模型名字</span><br><span class="line">  model_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;,</span><br><span class="line">  tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;:True&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置全局的llm属性，这样在索引查询时会使用这个模型</span><br><span class="line">Settings.llm = llm</span><br><span class="line"></span><br><span class="line"># RAG 系统构建过程</span><br><span class="line"># 从指定目录读取所有文档，并加载数据到内存中，required_exts 只加载指定扩展名的文档</span><br><span class="line">documents = SimpleDirectoryReader(&quot;./documents&quot;, required_exts=[&quot;.txt&quot;]).load_data()</span><br><span class="line"></span><br><span class="line"># 创建一个VectorStoreIndex，并使用之前加载的文档来构建索引</span><br><span class="line"># 此索引将文档转换为向量，并存储这些向量以便于快速检索</span><br><span class="line"># 默认是存储在内存中的</span><br><span class="line">index = VectorStoreIndex.from_documents(documents)</span><br><span class="line"></span><br><span class="line"># 创建一个查询引擎，这个引擎可以接收查询并返回相关文档的响应</span><br><span class="line">query_engine = index.as_query_engine()</span><br><span class="line">response = query_engine.query(&quot;请简单的介绍一下jinux&quot;)</span><br><span class="line"></span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他是一个大龄前端程序员。</span><br><span class="line">他的工作经历和职业背景主要集中在工作中遇到的年龄危机以及他正在学习AI方面知识上。由于他是一位大龄程序员，他在工作中可能会面临一些挑战，比如可能被裁员的风险。因此，他需要不断学习新的技能和知识来应对这些风险。</span><br></pre></td></tr></table></figure><p>测试结果是正确的，因为提供的文档中有这些信息。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>上述代码原理见下图<br><img src="/2025/02/20/RAG系统搭建-基础版/2.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个RAG系统非常简单，但是基本原理是这样的，通过向量化的方式，将文本转换为向量，然后通过向量检索的方式，找到最相似的文本，最后再交给LLM模型进行推理，得到最终的答案。<br><a href="https://github.com/jinux7/study-collections/tree/master/python/AI" target="_blank" rel="noopener">源码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的搭建一个大语言模型的RAG系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>docker基础教程</title>
    <link href="/2025/02/06/docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>/2025/02/06/docker基础教程/</id>
    <published>2025-02-06T06:58:27.000Z</published>
    <updated>2025-03-05T06:07:35.720Z</updated>
    
    <content type="html"><![CDATA[<p>docker基础入门教程<br><a id="more"></a></p><blockquote><p>本文章运行环境是window11专业版 版本号24H2</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><ul><li>任务栏搜索”功能”，点击”启用或关闭windows功能”</li><li>勾选”适用于Linux的Windows子系统”和”虚拟机平台”,点击确定后重启电脑</li></ul><h3 id="安装wsl2"><a href="#安装wsl2" class="headerlink" title="安装wsl2"></a>安装wsl2</h3><ul><li>使用管理员身份打开CMD</li><li>输入命令<code>wsl --set-default-version 2</code></li><li>输入命令<code>wsl --update</code>也可以<code>wsl --update --web-download</code></li></ul><h3 id="下载docker"><a href="#下载docker" class="headerlink" title="下载docker"></a>下载docker</h3><ul><li><a href="https://www.docker.com/" target="_blank" rel="noopener">docker官网</a></li><li>下载后安装(intel core处理器下载AMD的安装文件)</li></ul><p>安装后可在CMD中执行<code>docker --version</code>查看docker版本</p><h2 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h2><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># 删除 image 文件</span><br><span class="line">docker image rm [imageName]</span><br></pre></td></tr></table></figure></p><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 是最重要、最常用的 image 仓库。</p><h2 id="实例（hello-world）"><a href="#实例（hello-world）" class="headerlink" title="实例（hello world）"></a>实例（hello world）</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello world</a>“，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站。</p><blockquote><p>1.右键点击系统托盘（右下角）的 Docker 图标，选择 Settings（或直接打开 Docker Desktop）。<br>  2.进入 Docker Engine 配置页面。<br>  3.在编辑框中修改 registry-mirrors 字段，添加国内镜像源地址<br>    {<br>      “builder”: {<br>        “gc”: {<br>          “defaultKeepStorage”: “20GB”,<br>          “enabled”: true<br>        }<br>      },<br>      “experimental”: false,<br>      “registry-mirrors”: [<br>        “<a href="https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;" target="_blank" rel="noopener">https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;</a>,<br>        “<a href="https://docker.m.daocloud.io&quot;" target="_blank" rel="noopener">https://docker.m.daocloud.io&quot;</a>,<br>        “<a href="https://hub-mirror.c.163.com&quot;" target="_blank" rel="noopener">https://hub-mirror.c.163.com&quot;</a>,<br>        “<a href="https://mirror.baidubce.com&quot;" target="_blank" rel="noopener">https://mirror.baidubce.com&quot;</a>,<br>        “<a href="https://your_preferred_mirror&quot;" target="_blank" rel="noopener">https://your_preferred_mirror&quot;</a>,<br>        “<a href="https://dockerhub.icu&quot;" target="_blank" rel="noopener">https://dockerhub.icu&quot;</a>,<br>        “<a href="https://docker.registry.cyou&quot;" target="_blank" rel="noopener">https://docker.registry.cyou&quot;</a>,<br>        “<a href="https://docker-cf.registry.cyou&quot;" target="_blank" rel="noopener">https://docker-cf.registry.cyou&quot;</a>,<br>        “<a href="https://dockercf.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://dockercf.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://docker.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://docker.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://dockertest.jsdelivr.fyi&quot;" target="_blank" rel="noopener">https://dockertest.jsdelivr.fyi&quot;</a>,<br>        “<a href="https://mirror.aliyuncs.com&quot;" target="_blank" rel="noopener">https://mirror.aliyuncs.com&quot;</a>,<br>        “<a href="https://dockerproxy.com&quot;" target="_blank" rel="noopener">https://dockerproxy.com&quot;</a>,<br>        “<a href="https://mirror.baidubce.com&quot;" target="_blank" rel="noopener">https://mirror.baidubce.com&quot;</a>,<br>        “<a href="https://docker.m.daocloud.io&quot;" target="_blank" rel="noopener">https://docker.m.daocloud.io&quot;</a>,<br>        “<a href="https://docker.nju.edu.cn&quot;" target="_blank" rel="noopener">https://docker.nju.edu.cn&quot;</a>,<br>        “<a href="https://docker.mirrors.sjtug.sjtu.edu.cn&quot;" target="_blank" rel="noopener">https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</a>,<br>        “<a href="https://docker.mirrors.ustc.edu.cn&quot;" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn&quot;</a>,<br>        “<a href="https://mirror.iscas.ac.cn&quot;" target="_blank" rel="noopener">https://mirror.iscas.ac.cn&quot;</a>,<br>        “<a href="https://docker.rainbond.cc&quot;" target="_blank" rel="noopener">https://docker.rainbond.cc&quot;</a><br>      ]<br>    }<br>  4.点击 Apply &amp; Restart，等待 Docker 重启生效。</p></blockquote><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<code>library</code>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure></p><p>抓取成功以后，就可以在本机看到这个 image 文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><p>现在，运行这个 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure></p><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br></pre></td></tr></table></figure></p><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></p><p>对于那些不会自动终止的容器，必须使用<code>docker container kill</code> 命令手动终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container kill [containID]</span><br></pre></td></tr></table></figure></p><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure></p><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure></p><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="实例（制作自己的-Docker-容器）"><a href="#实例（制作自己的-Docker-容器）" class="headerlink" title="实例（制作自己的 Docker 容器）"></a>实例（制作自己的 Docker 容器）</h2><p>下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先下载源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jinux7/koa-demos.git</span><br><span class="line">cd koa-demos</span><br></pre></td></tr></table></figure></p><h3 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></p><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></p><p>上面代码一共五行，含义如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</span><br><span class="line">COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app：指定接下来的工作路径为/app。</span><br><span class="line">RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span><br><span class="line">EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br></pre></td></tr></table></figure></p><h3 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t koa-demo .</span><br><span class="line"># 或者</span><br><span class="line">docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"># 或者</span><br><span class="line">docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面命令的各个参数含义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p参数：容器的 3000 端口映射到本机的 8000 端口。</span><br><span class="line">-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</span><br><span class="line">koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</span><br><span class="line">/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span><br></pre></td></tr></table></figure></p><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app#</span><br></pre></td></tr></table></figure></p><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app# node demos/01.js</span><br></pre></td></tr></table></figure></p><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not" target="_blank" rel="noopener">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 demo 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在本机的另一个终端窗口，查出容器的 ID</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 停止指定的容器运行</span><br><span class="line">docker container kill [containerID]</span><br></pre></td></tr></table></figure></p><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查出容器的 ID</span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"># 删除指定的容器文件</span><br><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure></p><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></p><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></p><h3 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>注册一个账户。然后，用下面的命令登录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></p><p>接着，为本地的 image 标注用户名和版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"># 实例</span><br><span class="line">docker image tag koa-demos:0.0.1 jinux/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></p><p>也可以不标注用户名，重新构建一下 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></p><p>最后，发布 image 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></p><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><blockquote><p>这里的<code>imageName</code>是镜像名，<code>username/repository</code>是用户名下的仓库名，<code>tag</code>版本对用着<code>imageName</code>镜像，一般来说一个仓库下包含着一个镜像的不同版本。</p></blockquote><h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><h3 id="docker-container-start"><a href="#docker-container-start" class="headerlink" title="docker container start"></a>docker container start</h3><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start [containerID]</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-stop"><a href="#docker-container-stop" class="headerlink" title="docker container stop"></a>docker container stop</h3><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop [containerID]</span><br></pre></td></tr></table></figure></p><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><h3 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a>docker container logs</h3><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [containerID]</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-exec"><a href="#docker-container-exec" class="headerlink" title="docker container exec"></a>docker container exec</h3><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="docker-container-cp"><a href="#docker-container-cp" class="headerlink" title="docker container cp"></a>docker container cp</h3><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker基础入门教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="docker" scheme="/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>element-plus全局设置组件默认属性</title>
    <link href="/2025/01/09/element-plus%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7/"/>
    <id>/2025/01/09/element-plus全局设置组件默认属性/</id>
    <published>2025-01-09T08:17:43.000Z</published>
    <updated>2025-01-09T08:30:49.193Z</updated>
    
    <content type="html"><![CDATA[<p>element-plus全局设置组件默认属性<br><a id="more"></a><br>以Dialog组件的close-on-click-modal属性为例，默认是true，通过点击modal可以关闭Dialog。<br>现在全局把它设置成false</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementPlus, &#123; ElDialog &#125; from &quot;element-plus&quot;;</span><br><span class="line">ElDialog.props.closeOnclickModal.default = false;</span><br><span class="line">const app = Vue.createApp(App);</span><br><span class="line">app.use(ElementPlus);</span><br></pre></td></tr></table></figure><p><code>ElDialog.props.closeOnclickModal.default = false;</code>这句来修改默认属性</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementPlus from &quot;element-plus&quot;;</span><br><span class="line">const app = Vue.createApp(App);</span><br><span class="line">app.use(ElementPlus);</span><br><span class="line">app._context.components.ElDialog[&apos;props&apos;].closeOnClickModal.default = false;</span><br></pre></td></tr></table></figure><p><code>app._context.components.ElDialog[&#39;props&#39;].closeOnClickModal.default = false;</code>这句来修改默认属性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上举例了ElDialog组件，其他组件也可以这样设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;element-plus全局设置组件默认属性&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nodejs通过usb库调用tspl协议控制标签打印机GODEX(G500-U)</title>
    <link href="/2024/11/12/nodejs%E9%80%9A%E8%BF%87usb%E5%BA%93%E8%B0%83%E7%94%A8tspl%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%E6%A0%87%E7%AD%BE%E6%89%93%E5%8D%B0%E6%9C%BAGODEX-G500-U/"/>
    <id>/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/</id>
    <published>2024-11-12T07:30:31.000Z</published>
    <updated>2024-11-13T08:20:37.181Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs通过usb库调用tspl协议控制标签打印机GODEX<br><a id="more"></a></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>首先要下载Zadig，下载地址<a href="https://zadig.akeo.ie/" target="_blank" rel="noopener">传送门</a>，他是一个usb通用驱动程序，因为GODEX官方驱动执行device.open会报错。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>接上打印机并开机，然后按照下图做，以达到驱动能被open的目的。<br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/1.png" alt="img"><br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/2.png" alt="img"><br><img src="/2024/11/12/nodejs通过usb库调用tspl协议控制标签打印机GODEX-G500-U/3.png" alt="img"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>安装nodejs依赖，方法为<code>npm install usb</code></p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usb = <span class="built_in">require</span>(<span class="string">'usb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 你的设备的vendorId和productId</span></span><br><span class="line"><span class="comment"> * 这两个id可以通过Zadig工具获取，也可以通过usb.getDeviceList()方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> vendorId = <span class="number">0x195F</span>;</span><br><span class="line"><span class="keyword">const</span> productId = <span class="number">0x1</span>;</span><br><span class="line"><span class="comment">// 打印方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintLabel</span>(<span class="params">cmds</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> device = usb.findByIds(vendorId, productId)</span><br><span class="line">device.open()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = device.interfaces.length ; i &lt; len ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, len2 = device.interfaces[i].endpoints.length ; j &lt; len2 ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (device.interfaces[i].endpoints[j].direction == <span class="string">'out'</span>) &#123;</span><br><span class="line">device.interfaces[i].claim() <span class="comment">// 找到了要用的对象后，首先要声明所有权</span></span><br><span class="line"><span class="keyword">let</span> outEndpoint = device.interfaces[i].endpoints[j]</span><br><span class="line">outEndpoint.transferType = <span class="number">2</span> <span class="comment">// bulk 批量传输</span></span><br><span class="line">outEndpoint.transfer(cmds, (err) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line">device.close()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">device.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commands = <span class="string">`</span></span><br><span class="line"><span class="string">  ^Q30,3</span></span><br><span class="line"><span class="string">  ^W50</span></span><br><span class="line"><span class="string">  ^H5</span></span><br><span class="line"><span class="string">  ^P1</span></span><br><span class="line"><span class="string">  ^S2</span></span><br><span class="line"><span class="string">  ^AT</span></span><br><span class="line"><span class="string">  ^C1</span></span><br><span class="line"><span class="string">  ^R0</span></span><br><span class="line"><span class="string">  ~Q+0</span></span><br><span class="line"><span class="string">  ^O0</span></span><br><span class="line"><span class="string">  ^D0</span></span><br><span class="line"><span class="string">  ^E12</span></span><br><span class="line"><span class="string">  ~R200</span></span><br><span class="line"><span class="string">  ^XSET,ROTATION,0</span></span><br><span class="line"><span class="string">  ^L</span></span><br><span class="line"><span class="string">  Dy2-me-dd</span></span><br><span class="line"><span class="string">  Th:m:s</span></span><br><span class="line"><span class="string">  BQ,26,15,2,46,40,0,0,WS003</span></span><br><span class="line"><span class="string">  AE,25,130,1,1,0,0,WS00301002</span></span><br><span class="line"><span class="string">  AD,90,178,1,1,0,0,WS003</span></span><br><span class="line"><span class="string">  AB,310,114,1,1,0,0,1241</span></span><br><span class="line"><span class="string">  XRB26,65,4,0,10</span></span><br><span class="line"><span class="string">  WS00301002</span></span><br><span class="line"><span class="string">  XRB325,71,4,0,4</span></span><br><span class="line"><span class="string">  1241</span></span><br><span class="line"><span class="string">  E</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// 调用打印方法</span></span><br><span class="line">PrintLabel(commands)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs通过usb库调用tspl协议控制标签打印机GODEX&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="打印" scheme="/tags/%E6%89%93%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>Web移动端在线IDE(online-editor)</title>
    <link href="/2024/09/18/Web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9C%A8%E7%BA%BFIDE-online-editor/"/>
    <id>/2024/09/18/Web移动端在线IDE-online-editor/</id>
    <published>2024-09-18T07:36:51.000Z</published>
    <updated>2024-09-18T11:09:55.061Z</updated>
    
    <content type="html"><![CDATA[<p>web在线编辑器，适配移动端<br><a id="more"></a></p><blockquote><p>常用的在线编辑器有：<br><a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox</a><br><a href="https://codepen.io/" target="_blank" rel="noopener">codepen</a><br><a href="https://stackblitz.com/" target="_blank" rel="noopener">stackblitz</a><br><a href="https://playcode.io/" target="_blank" rel="noopener">playcode</a><br><a href="https://jsfiddle.net/" target="_blank" rel="noopener">jsfiddle</a></p></blockquote><h2 id="IDE组成"><a href="#IDE组成" class="headerlink" title="IDE组成"></a>IDE组成</h2><p>在线编辑器由编辑区，预览区，打印输出区三部分组成。<br>对应的组件分别是：<code>Editor</code>,<code>Preview</code>,<code>Console</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Layout.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;layout-wrap&quot;&gt;</span><br><span class="line">    &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">    &lt;div class=&quot;content-wrap&quot;&gt;</span><br><span class="line">      &lt;Editor&gt;&lt;/Editor&gt;</span><br><span class="line">      &lt;Preview&gt;&lt;/Preview&gt;</span><br><span class="line">      &lt;Console&gt;&lt;/Console&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><p>编辑区就是输入代码的地方，前端常用的代码编辑工具是<code>vsCode</code>，<code>vsCode</code>有一个在线库<code>monaco-editor</code>，这个库是微软专门为浏览器开发的一个在线<code>vsCode</code>，功能与在本地使用的<code>vsCode</code>基本一样，所以，在编辑功能这里使用这个工具库。<br><code>monaco-editor</code>的具体使用可以参考官网<a href="https://github.com/microsoft/monaco-editor" target="_blank" rel="noopener">monaco-editor</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// Editor.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;editor-wrap&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;$store.languageType===1&quot;&gt;</span><br><span class="line">      &lt;div ref=&quot;refHtml&quot; class=&quot;html-wrap&quot;&gt;html&lt;/div&gt;</span><br><span class="line">      &lt;div ref=&quot;refJs&quot; class=&quot;js-wrap&quot;&gt;js&lt;/div&gt;</span><br><span class="line">      &lt;div ref=&quot;refCss&quot; class=&quot;css-wrap&quot;&gt;css&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else ref=&quot;refVue&quot; class=&quot;vue-wrap&quot;&gt;vue&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; onMounted, ref, getCurrentInstance, watch, nextTick &#125; from &apos;vue&apos;;</span><br><span class="line">import * as monaco from &apos;monaco-editor/esm/vs/editor/editor.api&apos;</span><br><span class="line">import &#123; languageMap &#125; from &apos;@/config/constants&apos;</span><br><span class="line"></span><br><span class="line">const &#123; proxy &#125; = getCurrentInstance();</span><br><span class="line">const refHtml = ref(null);</span><br><span class="line">const refJs = ref(null);</span><br><span class="line">const refCss = ref(null);</span><br><span class="line">const refVue = ref(null);</span><br><span class="line">const editorArr = [];</span><br><span class="line">const createEditor = async (el, language) =&gt; &#123;</span><br><span class="line">  const editor = monaco.editor.create(el, &#123;</span><br><span class="line">    model: null,</span><br><span class="line">    minimap: &#123;</span><br><span class="line">      enabled: false // 关闭小地图</span><br><span class="line">    &#125;,</span><br><span class="line">    wordWrap: &apos;on&apos;, // 代码超出换行</span><br><span class="line">    theme: &apos;vs-dark&apos;, // 主题</span><br><span class="line">    fontSize: 14,</span><br><span class="line">    fontFamily: &apos;Microsoft YaHei&apos;,</span><br><span class="line">    contextmenu: false, // 不显示右键菜单</span><br><span class="line">    fixedOverflowWidgets: true, // 让语法提示层能溢出容器</span><br><span class="line">    readOnly: false</span><br><span class="line">  &#125;)</span><br><span class="line">  // 设置文档内容</span><br><span class="line">  updateDoc(editor, proxy.$store[languageMap[language]], language)</span><br><span class="line">  // 支持textMate语法解析</span><br><span class="line">  // wire(language, editor)</span><br><span class="line">  // 监听编辑事件</span><br><span class="line">  editor.onDidChangeModelContent(() =&gt; &#123;</span><br><span class="line">    // console.log(&apos;code-change&apos;, editor.getValue())</span><br><span class="line">    proxy.$store[languageMap[language]] = editor.getValue();</span><br><span class="line">  &#125;)</span><br><span class="line">  // 监听失焦事件</span><br><span class="line">  editor.onDidBlurEditorText(() =&gt; &#123;</span><br><span class="line">    // console.log(&apos;blur&apos;, editor.getValue())</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // editor添加入数组保存</span><br><span class="line">  editorArr.push(editor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新编辑器文档模型</span><br><span class="line">const updateDoc = (editor, code, language) =&gt; &#123;</span><br><span class="line">  language = language===&apos;vue&apos;?&apos;html&apos;:language;</span><br><span class="line">  let oldModel = editor.getModel();</span><br><span class="line">  let newModel = monaco.editor.createModel(code, language);</span><br><span class="line">  editor.setModel(newModel);</span><br><span class="line">  if (oldModel) &#123;</span><br><span class="line">    oldModel.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onMounted(()=&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">watch(()=&gt; proxy.$store.languageType, async ()=&gt; &#123;</span><br><span class="line">  if(proxy.$store.languageType===1) &#123;</span><br><span class="line">    await nextTick(()=&gt; &#123;</span><br><span class="line">      createEditor(refHtml.value, &apos;html&apos;);</span><br><span class="line">      createEditor(refJs.value, &apos;javascript&apos;);</span><br><span class="line">      createEditor(refCss.value, &apos;css&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;else if(proxy.$store.languageType===2) &#123;</span><br><span class="line">    await nextTick(()=&gt; &#123;</span><br><span class="line">      createEditor(refVue.value, &apos;vue&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; immediate: true &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.editor-wrap &#123;</span><br><span class="line">  .html-wrap, .js-wrap, .css-wrap, .vue-wrap &#123;</span><br><span class="line">    min-height: 30vh;</span><br><span class="line">    border: 1px solid #eeeeee;</span><br><span class="line">    margin: 5px;</span><br><span class="line">  &#125;</span><br><span class="line">  .vue-wrap &#123;</span><br><span class="line">    min-height: 50vh;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><p>预览区域应该与主页面隔绝，避免预览的代码污染主体页面。所以需要弄一个沙箱环境，这里选择最简单的<code>iframe</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Preview.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;preview-wrap&quot;&gt;</span><br><span class="line">    &lt;p&gt;预览&lt;/p&gt;</span><br><span class="line">    &lt;iframe v-if=&quot;$store.iframeShow&quot; :srcdoc=&quot;$store.docContent&quot; :key=&quot;$store.docContent&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.preview-wrap &#123;</span><br><span class="line">  height: 50vh;</span><br><span class="line">  border: 1px solid #eeeeee;</span><br><span class="line">  margin: 5px;</span><br><span class="line">  iframe &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    border: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><code>iframe</code>的<code>srcdoc</code>内容是点击<code>运行</code>按钮生成的，这段代码在<code>Header</code>组件内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Header.vue</span><br><span class="line">// vanilla代码生成</span><br><span class="line">const createHtml = (htmlStr=&apos;&apos;, jsStr=&apos;&apos;, cssStr=&apos;&apos;)=&gt; &#123;</span><br><span class="line">  if(proxy.$store.languageType===1) &#123;</span><br><span class="line">    let head = `</span><br><span class="line">      &lt;title&gt;预览&lt;\/title&gt;</span><br><span class="line">      &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">          $&#123;cssStr&#125;</span><br><span class="line">      &lt;\/style&gt;</span><br><span class="line">    `;</span><br><span class="line">    let jsContent = `</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        $&#123;jsStr&#125;</span><br><span class="line">      &lt;\/script&gt;</span><br><span class="line">    `;</span><br><span class="line">    let body = `</span><br><span class="line">      $&#123;htmlStr&#125;</span><br><span class="line">      $&#123;jsContent&#125;</span><br><span class="line">    `;</span><br><span class="line">    return `&lt;!DOCTYPE html&gt;</span><br><span class="line">      &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">          &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">          $&#123;head&#125;</span><br><span class="line">      &lt;\/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/console.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        $&#123;body&#125;</span><br><span class="line">      &lt;\/body&gt;</span><br><span class="line">      &lt;\/html&gt;</span><br><span class="line">    `;</span><br><span class="line">  &#125;else if(proxy.$store.languageType===2) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// vue代码生成</span><br><span class="line">const createVue = (sfcStr)=&gt; &#123;</span><br><span class="line">  return `&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot; \/&gt;</span><br><span class="line">        &lt;title&gt;预览&lt;\/title&gt;</span><br><span class="line">      &lt;\/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/vue.runtime.global.prod.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/vue3-sfc-loader.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        &lt;script src=&quot;/onlineEditor/lib/console.js&quot;&gt;&lt;\/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">          /* &lt;!-- */</span><br><span class="line">          const config = &#123;</span><br><span class="line">            files: &#123;</span><br><span class="line">              &apos;\/main.vue&apos;: \`$&#123;sfcStr&#125;\`,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          /* --&gt; */</span><br><span class="line"></span><br><span class="line">          const options = &#123;</span><br><span class="line">            devMode: true,</span><br><span class="line">            moduleCache: &#123;</span><br><span class="line">              vue: Vue,</span><br><span class="line">            &#125;,</span><br><span class="line">            async getFile(url) &#123;</span><br><span class="line">              </span><br><span class="line">              if ( config.files[url] )</span><br><span class="line">                return config.files[url];</span><br><span class="line">              </span><br><span class="line">              const res = await fetch(url);</span><br><span class="line">              if ( !res.ok )</span><br><span class="line">                throw Object.assign(new Error(res.statusText + &apos; &apos; + url), &#123; res &#125;);</span><br><span class="line">              return &#123;</span><br><span class="line">                getContentData: asBinary =&gt; asBinary ? res.arrayBuffer() : res.text(),</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            addStyle(textContent) &#123;</span><br><span class="line"></span><br><span class="line">              const style = Object.assign(document.createElement(&apos;style&apos;), &#123; textContent &#125;);</span><br><span class="line">              const ref = document.head.getElementsByTagName(&apos;style&apos;)[0] || null;</span><br><span class="line">              document.head.insertBefore(style, ref);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            handleModule: async function (type, getContentData, path, options) &#123;</span><br><span class="line"></span><br><span class="line">              switch (type) &#123; </span><br><span class="line">                case &apos;.png&apos;:</span><br><span class="line">                  return getContentData(true);</span><br><span class="line">              &#125; </span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            log(type, ...args) &#123;</span><br><span class="line"></span><br><span class="line">              console[type](...args);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          const app = Vue.createApp(Vue.defineAsyncComponent(() =&gt; window[&apos;vue3-sfc-loader&apos;].loadModule(&apos;/main.vue&apos;, options)))</span><br><span class="line">          app.mount(document.body);</span><br><span class="line"></span><br><span class="line">        &lt;\/script&gt;</span><br><span class="line">      &lt;\/body&gt;</span><br><span class="line">    &lt;\/html&gt;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p>打印输出，首先要把预览<code>iframe</code>里的<code>console</code>的所有方法拦截，之后用<code>window.parent.postMessage</code>方法，把信息发送给主页面。当然，主页面也需要注册<code>message</code>事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">window.addEventListener(&apos;message&apos;, (ev) =&gt; &#123;</span><br><span class="line">  if(ev.data.type === &apos;console&apos;) &#123;</span><br><span class="line">    proxy.$store.consoleContent.push(ev.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>iframe</code>中的拦截<code>console</code>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// public/lib/console.js</span><br><span class="line">function ProxyConsole() &#123;&#125;;</span><br><span class="line">// 拦截console的所有方法</span><br><span class="line">[</span><br><span class="line">    &apos;debug&apos;,</span><br><span class="line">    &apos;clear&apos;,</span><br><span class="line">    &apos;error&apos;,</span><br><span class="line">    &apos;info&apos;,</span><br><span class="line">    &apos;log&apos;,</span><br><span class="line">    &apos;warn&apos;,</span><br><span class="line">    &apos;dir&apos;,</span><br><span class="line">    &apos;props&apos;,</span><br><span class="line">    &apos;group&apos;,</span><br><span class="line">    &apos;groupEnd&apos;,</span><br><span class="line">    &apos;dirxml&apos;,</span><br><span class="line">    &apos;table&apos;,</span><br><span class="line">    &apos;trace&apos;,</span><br><span class="line">    &apos;assert&apos;,</span><br><span class="line">    &apos;count&apos;,</span><br><span class="line">    &apos;markTimeline&apos;,</span><br><span class="line">    &apos;profile&apos;,</span><br><span class="line">    &apos;profileEnd&apos;,</span><br><span class="line">    &apos;time&apos;,</span><br><span class="line">    &apos;timeEnd&apos;,</span><br><span class="line">    &apos;timeStamp&apos;,</span><br><span class="line">    &apos;groupCollapsed&apos;</span><br><span class="line">].forEach((method) =&gt; &#123;</span><br><span class="line">    let originMethod = console[method]</span><br><span class="line">    // 设置原型方法</span><br><span class="line">    ProxyConsole.prototype[method] = function (...args) &#123;</span><br><span class="line">        // 发送信息给父窗口</span><br><span class="line">        window.parent.postMessage(&#123;</span><br><span class="line">            type: &apos;console&apos;,</span><br><span class="line">            method,</span><br><span class="line">            data: any2str(args)</span><br><span class="line">        &#125;)</span><br><span class="line">        // 调用原始方法</span><br><span class="line">        originMethod.apply(ProxyConsole, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 覆盖原console对象</span><br><span class="line">window.console = new ProxyConsole()</span><br><span class="line"></span><br><span class="line">// 处理console的参数转字符串</span><br><span class="line">const any2str = (arr)=&gt; &#123;</span><br><span class="line">  let str = &apos;&apos;;</span><br><span class="line">  arr.forEach(item=&gt; &#123;</span><br><span class="line">    str += change2str(item) + &apos; &apos;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const type = arg=&gt; &#123;</span><br><span class="line">  return Object.prototype.toString.call(arg).slice(7, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const change2str = content=&gt; &#123;</span><br><span class="line">  let contentType = type(content)</span><br><span class="line">  switch (contentType) &#123;</span><br><span class="line">    case &apos;boolean&apos;: // 布尔值</span><br><span class="line">      content = content ? &apos;true&apos; : &apos;false&apos;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;null&apos;: // null</span><br><span class="line">      content = &apos;null&apos;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;undefined&apos;: // undefined</span><br><span class="line">      content = &apos;undefined&apos;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;symbol&apos;: // Symbol，Symbol不能直接通过postMessage进行传递，会报错，需要转成字符串</span><br><span class="line">      content = content.toString()</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return content;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>界面截图：<br><img src="/2024/09/18/Web移动端在线IDE-online-editor/1.png" alt="img"></p><p>本实例使用<code>vue3+webpack</code>开发，<code>monaco-editor</code>在<code>vite</code>中的兼容性不是很好，所以选择<code>webpack</code>。<br><a href="https://github.com/jinux7/study-collections/tree/master/onlineEditor" target="_blank" rel="noopener">本实例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web在线编辑器，适配移动端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript教程(二)</title>
    <link href="/2024/08/01/TypeScript%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
    <id>/2024/08/01/TypeScript教程-二/</id>
    <published>2024-08-01T06:37:21.000Z</published>
    <updated>2024-08-02T02:52:25.948Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript进阶教程<br><a id="more"></a></p><h1 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type-Challenges"></a>Type-Challenges</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学习完<code>TypeScript</code>一些基础知识后，已经可以熟练使用一些基本类型定义了，但对于<code>TypeScript</code>的高级用法却依旧无法入门，为了更有趣的学习<code>TypeScript</code>高级用法，选择<a href="https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md" target="_blank" rel="noopener">Type-Challenges</a>类型挑战来作为我们学习的目标。</p><p>在<code>Type-Challenges</code>中，可以从简单(<code>easy</code>)、中等(<code>medium</code>)、困难(<code>hard</code>)以及地狱(<code>extreme</code>)难度，循序渐进的学习<code>TypeScript</code>高级技巧。</p><p>如果你需要选择其它的方向来深入学习<code>TypeScript</code>高级技巧，这里也有一些推荐的开源项目：</p><ul><li>官方内置：在<code>lib.es5.d.ts</code>文件中，<code>TypeScript</code>官方默认内置了一些辅助工具函数，例如：<code>Partial</code>、<code>Required</code>、<code>Pick</code>以及<code>Record</code>等等。</li><li>其它开源库：<a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="noopener">utility-types</a>、<a href="https://github.com/millsp/ts-toolbelt" target="_blank" rel="noopener">ts-toolbelt</a>、<a href="https://github.com/andnp/SimplyTyped" target="_blank" rel="noopener">SimplyTyped</a></li></ul><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="加号和减号"><a href="#加号和减号" class="headerlink" title="加号和减号"></a>加号和减号</h3><blockquote><p>tip<br>加号和减号的用法类似。</p></blockquote><p>在一些内置工具中，可能会出现<code>+</code>或者<code>-</code>这些符号，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Required&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><p>观察以上结果可以得出结论：<code>-?</code>是去掉类型中属性后面的<code>?</code>，整个<code>Required</code>的实际效果是去掉<code>T</code>类型中所有属性键后面的<code>?</code>，让所有属性变成必填的。</p><h3 id="keyof-和-in"><a href="#keyof-和-in" class="headerlink" title="keyof 和 in"></a>keyof 和 in</h3><p><code>keyof</code>和<code>in</code>经常会连在一起使用，当它们连在一起使用时，通常表示一个迭代的过程。</p><h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>在<code>TS</code>中，<code>keyof T</code>这段代码表示获取<code>T</code>类型中所有属性键，这些属性键组合成一个联合类型，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = keyof Person</span><br></pre></td></tr></table></figure></p><p><code>TS</code>中的<code>keyof T</code>，它有点类似<code>JavaScript</code>中的<code>Object.keys()</code>，它们的共同点都是获取属性键的集合，只不过<code>keyof T</code>得到的结果是一个联合类型，而<code>Object.keys()</code>得到的是一个数组。</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p><code>in</code>操作符的右侧通常跟一个联合类型，可以使用<code>in</code>来迭代这个联合类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅演示使用, K为每次迭代的项</span></span><br><span class="line">K <span class="keyword">in</span> <span class="string">'name'</span> | <span class="string">'age'</span> | <span class="string">'sex'</span></span><br><span class="line">K = <span class="string">'name'</span> <span class="comment">// 第一次迭代结果</span></span><br><span class="line">K = <span class="string">'age'</span>  <span class="comment">// 第二次迭代结果</span></span><br><span class="line">K = <span class="string">'sex'</span>  <span class="comment">// 第三次迭代结果</span></span><br></pre></td></tr></table></figure></p><p>根据<code>keyof</code>和<code>in</code>的特点，我们可以撰写一些辅助工具，这里以<code>Readonly</code>为例。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; readony name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Readonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>[P in keyof T]</code>：这段代码表示遍历<code>T</code>中的每一个属性键，每次遍历时属性键取名为<code>P</code>，这和<code>JavaScript</code>中的<code>for in</code>非常类似：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的迭代</span></span><br><span class="line">P <span class="keyword">in</span> keyof T</span><br><span class="line"></span><br><span class="line"><span class="comment">// js中的迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure></li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>TS</code>中的<code>typeof</code>，可以用来获取一个<code>JavaScript</code>变量的类型，经常用于获取一个普通对象或者一个函数的类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'AAA'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：(a: number, b:number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> t1  = <span class="keyword">typeof</span> add</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> obj</span><br></pre></td></tr></table></figure></p><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>类型表示永远不会有值的一种类型。</p><p>例如，如果一个函数抛出一个错误，那么这个函数就可以用<code>never</code>或者<code>void</code>来表示其返回值，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never更适合用来表示永远没有返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void适合用来表示返回值为空的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlerError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>never</code>的另外一个知识点是：如果一个联合类型中存在<code>never</code>，那么实际的联合类型并不会包含<code>never</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span> | never</span><br><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="keyword">type</span> test = <span class="string">'name'</span> | <span class="string">'age'</span></span><br></pre></td></tr></table></figure></p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><code>extends</code>关键词，一般有两种用法：<strong>类型约束</strong>和<strong>条件类型</strong>。</p><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>类型约束经常和泛型一起使用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型约束</span></span><br><span class="line">U <span class="keyword">extends</span> keyof T</span><br></pre></td></tr></table></figure></p><p><code>keyof T</code>是一个整体，它表示一个联合类型。<code>U extends Union</code>这一整段表示<code>U</code>的类型被收缩在一个联合类型的范围内。例如： <code>U extends &#39;name&#39; | &#39;age&#39;</code>，则表示<code>U</code>只能为<code>name</code>或者<code>age</code>二者其中之一。</p><h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>常见的条件类型表现形式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? <span class="string">'Y'</span> : <span class="string">'N'</span></span><br></pre></td></tr></table></figure></p><p>我们发现条件类型有点像<code>JavaScript</code>中的三元表达式，事实上它们的工作原理是类似的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = <span class="literal">true</span> <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="literal">true</span> : <span class="literal">false</span>                    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span> | <span class="string">'age'</span> ? <span class="literal">true</span> : <span class="literal">false</span>           <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? <span class="literal">true</span> : <span class="literal">false</span>   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> result4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; ? <span class="literal">true</span> : <span class="literal">false</span>         <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>在条件类型中，有一个特别需要注意的东西就是：<strong>分布式条件类型</strong>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置工具：交集</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br><span class="line"><span class="keyword">type</span> type1 = <span class="string">'name'</span>|<span class="string">'age'</span></span><br><span class="line"><span class="keyword">type</span> type2 = <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集结果：'name'</span></span><br><span class="line"><span class="keyword">type</span> result = Extract&lt;type1, type2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推理步骤</span></span><br><span class="line"><span class="string">'name'</span>|<span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">step1： (<span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never) =&gt; <span class="string">'name'</span></span><br><span class="line">step2:  <span class="function">(<span class="params">'age' <span class="keyword">extends</span> 'name'|'address'|'sex' ? 'age' : never</span>)   =&gt;</span> never</span><br><span class="line">result: <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><p><code>T extends U ? T : never</code>：因为<code>T</code>是一个联合类型，所以这里适用于<strong>分布式条件类型</strong>的概念。根据其概念，在实际的过程中会把<code>T</code>类型中的每一个子类型进行迭代，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代：</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never</span><br><span class="line"><span class="comment">// 第二次迭代：</span></span><br><span class="line"><span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'name'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure></li><li><p>在迭代完成之后，会把每次迭代的结果组合成一个新的联合类型(根据<code>never</code>类型的特点，最后的结果会剔除掉<code>never</code>)，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="function"><span class="params">never</span> =&gt;</span> <span class="string">'name'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p><code>infer</code>关键词的作用是延时推导，它会在类型未推导时进行占位，等到真正推导成功后，它能准确的返回正确的类型。</p><p>为了更好的理解<code>infer</code>关键词的用法，我们使用<code>ReturnType</code>这个例子来说明，<code>ReturnType</code>是一个用来获取函数返回类型的工具。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: number</span></span><br><span class="line"><span class="keyword">type</span> result = ReturnType&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends (...args: any) =&gt; infer R</code>：如果不看<code>infer R</code>，这段代码实际表示：<code>T</code>是不是一个函数类型。</li><li><code>(...args: any) =&gt; infer R</code>：这段代码实际表示一个函数类型，其中把它的参数使用<code>args</code>来表示，把它的返回类型用<code>R</code>来进行占位。<br>如果<code>T</code>满足是一个函数类型，那么我们返回其函数的返回类型，也就是<code>R</code>；如果不是一个函数类型，就返回<code>never</code>。</li></ul><p><code>TS</code>中的<code>infer</code>占位更像<code>JavaScript</code>中的模板字符串：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的返回类型使用R占位表示</span></span><br><span class="line">(...args: <span class="built_in">any</span>) =&gt; info R</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串中的值，使用变量name占位表示</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><h3 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp; 符号"></a>&amp; 符号</h3><p>在<code>TS</code>中有两种类型值得我们重点关注：<strong>联合类型</strong>和<strong>交叉类型</strong>。</p><p>联合类型一般适用于基本类型的<strong>合并</strong>，它使用<code>|</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = <span class="string">'name'</span> | <span class="number">1</span> | <span class="literal">true</span> | <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>而交叉类型则适用于对象或者函数的<strong>合并</strong>，它使用<code>&amp;</code>符号进行连接，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = T &amp; U</span><br></pre></td></tr></table></figure></p><p><code>T &amp; U</code>表示一个新的类型，其中这个类型包含<code>T</code>和<code>U</code>中所有的键，这和<code>JavaScript</code>中的<code>Object.assign()</code>函数的作用非常类似。</p><p>根据交叉类型的概念，我们可以封装一个合并对象的<code>merge</code>函数，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.8.4以上版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> unknown <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> unknown <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts v4.8.4以下版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">T</span> &amp; <span class="title">U</span>&gt;(<span class="params">to: T, <span class="keyword">from</span>: U</span>): <span class="title">K</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    ;(to <span class="keyword">as</span> K)[key] = <span class="keyword">from</span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to <span class="keyword">as</span> K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; name: <span class="string">'AAA'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; age: <span class="number">23</span> &#125;</span><br><span class="line"><span class="comment">// js结果：&#123; name：'AAA'; age: 23; &#125;</span></span><br><span class="line"><span class="comment">// ts结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">const</span> result = merge(obj1, obj2)</span><br></pre></td></tr></table></figure></p><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="内置Pick-选取"><a href="#内置Pick-选取" class="headerlink" title="内置Pick(选取)"></a>内置Pick(选取)</h3><p><link-and-solution num="4"></link-and-solution></p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>Pick</code>表示从一个类型中选取指定的几个字段组合成一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: &#123; name: string; address: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PickResult = Pick&lt;Person, <span class="string">'name'</span> | <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof T</code>：表示<code>K</code>只能是<code>keyof T</code>的子类型，如果我们在使用<code>Pick</code>的时候传递了不存在于<code>T</code>的字段，会报错：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：phone无法分配给keyof T</span></span><br><span class="line"><span class="keyword">type</span> result = MyPick&lt;Person, <span class="string">'name'</span> | <span class="string">'phone'</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Readonly-只读"><a href="#内置Readonly-只读" class="headerlink" title="内置Readonly(只读)"></a>内置Readonly(只读)</h3><p><link-and-solution num="7"></link-and-solution></p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p><code>Readonly</code>是用来让所有属性变为只读，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; readonly name: string; readonly age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MyReadonly&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TupleToObject-元组转对象"><a href="#TupleToObject-元组转对象" class="headerlink" title="TupleToObject(元组转对象)"></a>TupleToObject(元组转对象)</h3><p><link-and-solution num="11"></link-and-solution></p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToObject&lt;T&gt;</code>是用来把一个元组转换成一个<code>key/value</code>相同的对象，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：readonly ['msg', 'name']</span></span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="string">'msg'</span>, <span class="string">'name'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 结果：&#123; msg: 'msg'; name: 'name'; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToObject&lt;<span class="keyword">typeof</span> tuple&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>as const</code>：常用来进行常量断言，在此处表示将<code>[&#39;msg&#39;,&#39;name&#39;]</code>推导常量元组，表示其不能新增、删除、修改元素，可以使用<code>as readonly</code>来辅助理解。</li><li><code>T[number]</code>：表示返回数组中所有数字型索引的元素，形成一个联合类型，例如：<code>&#39;msg&#39;|&#39;name&#39;</code>。</li></ul><h3 id="First-数组第一个元素"><a href="#First-数组第一个元素" class="headerlink" title="First(数组第一个元素)"></a>First(数组第一个元素)</h3><p><link-and-solution num="14"></link-and-solution></p><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>First&lt;T&gt;</code>用来返回数组的第一个元素，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = First&lt;[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result2 = First&lt;[]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? never : T[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 占位实现方式</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer R, ...infer L] ? R : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends []</code>：用来判断<code>T</code>是否是一个空数组。</li><li><code>T[0]</code>：根据下标取数组第一个元素。</li><li><code>infer R</code>： 表示数组第一个元素的占位。</li><li><code>...infer L</code>: 表示数组剩余元素的占位。</li></ul><h3 id="Length-元组的长度"><a href="#Length-元组的长度" class="headerlink" title="Length(元组的长度)"></a>Length(元组的长度)</h3><p><link-and-solution num="18"></link-and-solution></p><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>Length&lt;T&gt;</code>用来获取一个数组(包括类数组)的长度，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result1 = Length&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果：10</span></span><br><span class="line"><span class="keyword">type</span> result2 = Length&lt;&#123; <span class="number">5</span>: <span class="string">'5'</span>, length: <span class="number">10</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> &#123; length: <span class="built_in">number</span>; &#125; ? T[<span class="string">'length'</span>] : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends { length: number; }</code>：判断<code>T</code>是否是<code>{ length: number; }</code>的子类型，如果是则代表<code>T</code>为数组或者类数组。</li><li><code>T[&#39;length&#39;]</code>：取<code>T</code>对象的<code>length</code>属性的值(注意，在<code>TypeScript</code>中不能使用<code>T.length</code>来取值，而应该使用<code>T[&#39;length&#39;]</code>)。</li></ul><h3 id="内置Exclude-排除"><a href="#内置Exclude-排除" class="headerlink" title="内置Exclude(排除)"></a>内置Exclude(排除)</h3><p><link-and-solution num="43"></link-and-solution></p><h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><p><code>Exclude</code>是排除的意思，它从<code>T</code>类型中排除属于<code>U</code>类型的子集，可以理解成取<code>T</code>对于<code>U</code>的差集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> ExcludeResult = Exclude&lt;<span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span>, <span class="string">'sex'</span>|<span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br></pre></td></tr></table></figure><ul><li><code>T extends U</code>：这段代码会从<code>T</code>的子类型开始分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U </span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span></span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'name'</span> |</span><br><span class="line">  <span class="string">'age'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'age'</span> |</span><br><span class="line">  <span class="string">'sex'</span> <span class="keyword">extends</span> <span class="string">'sex'</span>|<span class="string">'address'</span> ? never : <span class="string">'sex'</span></span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="PromiseType-promise包裹类型"><a href="#PromiseType-promise包裹类型" class="headerlink" title="PromiseType(promise包裹类型)"></a>PromiseType(promise包裹类型)</h3><p><link-and-solution num="189"></link-and-solution></p><h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseType</code>是用来获取<code>Promise</code>包裹类型的，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span> (<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>|<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：(） =&gt; Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> getInfo</span><br><span class="line"><span class="comment">// 结果：Promise&lt;string|number&gt;</span></span><br><span class="line"><span class="keyword">type</span> returnResult = ReturnType&lt;funcType&gt;</span><br><span class="line"><span class="comment">// 结果：string|number</span></span><br><span class="line"><span class="keyword">type</span> PromiseResult = PromiseType&lt;returnResult&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PromiseType&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer R&gt;</span><br><span class="line">    ? R <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">      ? PromiseType&lt;R&gt;</span><br><span class="line">      : R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends Promise&lt;infer R&gt;</code>：判断<code>T</code>是否是<code>Promise&lt;infer R&gt;</code>的子类型，也就是说<code>T</code>必须满足<code>Promise&lt;any&gt;</code>的形式。</li></ul><h3 id="If-判断"><a href="#If-判断" class="headerlink" title="If(判断)"></a>If(判断)</h3><p><link-and-solution num="268"></link-and-solution></p><h4 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h4><p><code>If&lt;C, T, F&gt;</code>用来表示根据<code>C</code>的值来返回<code>T</code>或者<code>F</code>，如果<code>C</code>为<code>true</code>，则返回<code>T</code>；如果<code>C</code>为<code>false</code>，则返回<code>F</code>，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a'</span></span><br><span class="line"><span class="keyword">type</span> result1 = If&lt;<span class="literal">true</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'b'</span></span><br><span class="line"><span class="keyword">type</span> result2 = If&lt;<span class="literal">false</span>, <span class="string">'a'</span>, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>根据上案例，我们可以直观的发现<code>If&lt;C, T, F&gt;</code>的作用有点类似<code>JavaScript</code>中的三元表达式：<code>C ? T : F</code>。</p><h4 id="实现方式-7"><a href="#实现方式-7" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> If&lt;C <span class="keyword">extends</span> <span class="built_in">boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>C extends boolean</code>：表示<code>C</code>为<code>boolean</code>类型的子类型，既<code>C</code>只能为<code>true</code>或者<code>false</code>，传递其它值报错。</li><li><code>C extends true</code>：如果用<code>JavaScript</code>来表示的话，相当于<code>C===true</code>.</li></ul><h3 id="Concat-数组concat方法"><a href="#Concat-数组concat方法" class="headerlink" title="Concat(数组concat方法)"></a>Concat(数组concat方法)</h3><p><link-and-solution num="533"></link-and-solution></p><h4 id="用法-8"><a href="#用法-8" class="headerlink" title="用法"></a>用法</h4><p><code>Concat&lt;T, U&gt;</code>用来将两个数组合并起来，类似实现数组的<code>concat</code>方法，使用方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Concat&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-8"><a href="#实现方式-8" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...U]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends any[]</code>：用来限制<code>T</code>是一个数组，如果传递非数组会报错，<code>U</code>也是一样的道理。</li><li><code>[...T, ...U]</code>：可以理解成<code>JavaScript</code>的扩展运算符<code>...</code>。</li></ul><h3 id="Includes-数组includes方法"><a href="#Includes-数组includes方法" class="headerlink" title="Includes(数组includes方法)"></a>Includes(数组includes方法)</h3><p><link-and-solution num="898"></link-and-solution></p><h4 id="用法-9"><a href="#用法-9" class="headerlink" title="用法"></a>用法</h4><p><code>Includes&lt;T, U&gt;</code>用来判断<code>U</code>是否在数组<code>T</code>中，类似实现数组的<code>includes</code>方法，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = Includes&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'1'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-9"><a href="#实现方式-9" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = U <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 完善版</span></span><br><span class="line"><span class="keyword">type</span> MyIncludes&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[], U&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> [infer R, ...infer L]</span><br><span class="line">    ? Equal&lt;R, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : MyIncludes&lt;L, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[number]</code>：它返回数组中所有数字类型键对应的值，将这些值构造成一个联合类型，例如：<code>1 | 2 | 3</code>。</li><li><code>U extends T[number]</code>：判断<code>U</code>是否是某个联合类型的子类型，例如：<code>1 extends 1 | 2 | 3</code>。</li><li><code>Equal</code>：是用来判断两个值是否相等的辅助方法。</li></ul><h3 id="Push-数组push方法"><a href="#Push-数组push方法" class="headerlink" title="Push(数组push方法)"></a>Push(数组push方法)</h3><p><link-and-solution num="3057"></link-and-solution></p><h4 id="用法-10"><a href="#用法-10" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = Push&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-10"><a href="#实现方式-10" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push实现</span></span><br><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [...T, K]</span><br></pre></td></tr></table></figure><h3 id="Unshift-数组unshift方法"><a href="#Unshift-数组unshift方法" class="headerlink" title="Unshift(数组unshift方法)"></a>Unshift(数组unshift方法)</h3><p><link-and-solution num="3060"></link-and-solution></p><p>与<code>pop</code>和<code>push</code>方法相似的另外一对方法叫<code>shift</code>和<code>unshift</code>，它们的实现思路是一样的。</p><h4 id="用法-11"><a href="#用法-11" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[0, 1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unshift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-11"><a href="#实现方式-11" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unshift实现</span></span><br><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], K&gt; = [K, ...T]</span><br></pre></td></tr></table></figure><h3 id="内置Parameters-函数的参数类型"><a href="#内置Parameters-函数的参数类型" class="headerlink" title="内置Parameters(函数的参数类型)"></a>内置Parameters(函数的参数类型)</h3><p><link-and-solution num="3312"></link-and-solution></p><h4 id="用法-12"><a href="#用法-12" class="headerlink" title="用法"></a>用法</h4><p><code>Parameters</code>是用来获取一个函数的参数类型的，其中获取的结果是一个元组，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// [number, string]</span></span><br><span class="line"><span class="keyword">type</span> result = MyParameters&lt;<span class="keyword">typeof</span> add&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-12"><a href="#实现方式-12" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyParameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span> ? R : never</span><br></pre></td></tr></table></figure><h3 id="内置Partial-可填-和内置Required-必填"><a href="#内置Partial-可填-和内置Required-必填" class="headerlink" title="内置Partial(可填)和内置Required(必填)"></a>内置Partial(可填)和内置Required(必填)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-13"><a href="#用法-13" class="headerlink" title="用法"></a>用法</h4><p><code>Partial</code>和<code>Required</code>一个是让所有属性可填、另外一个是让所有属性必填，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name?: string; age?: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> PartialResult = MyPartial&lt;Person&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: &#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> RequiredResult = MyRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-13"><a href="#实现方式-13" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPartial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置Record-构造"><a href="#内置Record-构造" class="headerlink" title="内置Record(构造)"></a>内置Record(构造)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-14"><a href="#用法-14" class="headerlink" title="用法"></a>用法</h4><p><code>Record&lt;K, T&gt;</code>用来将<code>K</code>的每一个键(<code>k</code>)指定为<code>T</code>类型，这样由多个<code>k/T</code>组合成了一个新的类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keys = <span class="string">'Cat'</span>|<span class="string">'Dot'</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  Cat: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  Dog: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> RecordResult = Record&lt;keys, Animal&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-14"><a href="#实现方式-14" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRecord&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof any</code>：此代码表示<code>K</code>是<code>keyof any</code>任意类型其所有键的子类型，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K为 'Dog'|'cat'</span></span><br><span class="line"><span class="keyword">type</span> UnionKeys = <span class="string">'Dog'</span> | <span class="string">'Cat'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K为'name'|'age'</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TypeKeys = keyof Person</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Extract-交集"><a href="#内置Extract-交集" class="headerlink" title="内置Extract(交集)"></a>内置Extract(交集)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-15"><a href="#用法-15" class="headerlink" title="用法"></a>用法</h4><p><code>Extract&lt;T, U&gt;</code>用来取联合类型<code>T</code>和<code>U</code>的交集，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'age'|'address'</span></span><br><span class="line"><span class="keyword">type</span> ExtractResult = Extract&lt;keyof Person, <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-15"><a href="#实现方式-15" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExtract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends U</code>：此代码会自动将<code>T</code>的子类型进行分发，例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T extends U</span><br><span class="line">=&gt; <span class="string">'name'</span>|<span class="string">'age'</span>|<span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? T : never</span><br><span class="line">=&gt; (</span><br><span class="line">  <span class="string">'name'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'name'</span> : never |</span><br><span class="line">  <span class="string">'age'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'sex'</span> ? <span class="string">'age'</span> : never |</span><br><span class="line">  <span class="string">'address'</span> extends <span class="string">'age'</span>|<span class="string">'address'</span>|<span class="string">'address'</span> ? <span class="string">'age'</span> : never</span><br><span class="line">)</span><br><span class="line">=&gt; <span class="string">'age'</span>|<span class="string">'address'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="内置ReturnType-函数返回类型"><a href="#内置ReturnType-函数返回类型" class="headerlink" title="内置ReturnType(函数返回类型)"></a>内置ReturnType(函数返回类型)</h3><p><link-and-solution num="2"></link-and-solution></p><h4 id="用法-16"><a href="#用法-16" class="headerlink" title="用法"></a>用法</h4><p><code>ReturnType&lt;T&gt;</code>是用来获取一个函数的返回类型的，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span> (<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：number</span></span><br><span class="line">type result = ReturnType&lt;<span class="keyword">typeof</span> getRandom&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-16"><a href="#实现方式-16" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T extends (...args: any) =&gt; infer R</code>：判断<code>T</code>类型是否是一个函数的子类型，既<code>T</code>是不是一个函数。</li><li><code>infer R</code>：表示待推导的函数返回类型为<code>R</code>，后续可以在表达式中使用<code>R</code>来代替真正的返回类型。</li></ul><h3 id="内置Omit-移除"><a href="#内置Omit-移除" class="headerlink" title="内置Omit(移除)"></a>内置Omit(移除)</h3><p><link-and-solution num="3"></link-and-solution></p><h4 id="用法-17"><a href="#用法-17" class="headerlink" title="用法"></a>用法</h4><p><code>Omit</code>是移除的意思，它用来在<code>T</code>类型中移除指定的字段，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; name？: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> OmitResult = Omit&lt;Person, <span class="string">'address'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-17"><a href="#实现方式-17" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Omit</code>可以借助在上面已经实现过的<code>Pick</code>和<code>Exclude</code>配合来实现，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Omit实现</span></span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K&gt; = MyPick&lt;T, MyExclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li>使用<code>MyExclude&lt;keyof T, K&gt;</code>，可以从<code>T</code>中移除指定的字段，移除后得到一个新的联合类型：<code>&#39;name&#39;|&#39;age&#39;</code></li><li>使用<code>MyPick&lt;T, &#39;name&#39;|&#39;age&#39;&gt;</code>，可以从<code>T</code>中选取这两个字段，组合成一个新的类型。</li></ul><h3 id="Readonly-按需Readonly"><a href="#Readonly-按需Readonly" class="headerlink" title="Readonly(按需Readonly)"></a>Readonly(按需Readonly)</h3><p><link-and-solution num="8"></link-and-solution></p><h4 id="用法-18"><a href="#用法-18" class="headerlink" title="用法"></a>用法</h4><p>不同于初级实现中的<code>Readonly</code>，在中级实现的<code>Readonly</code>中，如果我们传递了指定的字段，那么<code>Readonly</code>会表现为按需实现<code>readonly</code>，用法如下。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected1 &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Expected2 &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  readonly desc?: <span class="built_in">string</span>;</span><br><span class="line">  readonly completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult1 = Readonly&lt;Todo&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyResult2 = Readonly&lt;Todo, <span class="string">'desc'</span>|<span class="string">'completed'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line"><span class="keyword">const</span> obj: ReadonlyResult2 = &#123;</span><br><span class="line">  title: <span class="string">'AAA'</span>,</span><br><span class="line">  desc: <span class="string">'23'</span>,</span><br><span class="line">  completed: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">obj.title = <span class="string">'aaa'</span></span><br><span class="line">obj.desc = <span class="string">'32'</span> <span class="comment">// error</span></span><br><span class="line">obj.completed = <span class="literal">false</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-18"><a href="#实现方式-18" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts v4.4+版本可直接用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = T &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts v4.5+版本必须用</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>K extends keyof T = keyof T</code>：如要传递了<code>K</code>，那么只能是<code>T</code>中已经存在的属性，不存在则报错；如果不传递，则默认值为<code>keyof T</code>，意味着全部属性都添加<code>readonly</code>。</li><li><code>T &amp; U</code>：在本例中表示将<code>T</code>和<code>U</code>中的字段结合起来，如果没有<code>&amp;</code>会丢失一些属性，例如<code>title</code>。</li></ul><h3 id="DeepReadonly-深度Readonly"><a href="#DeepReadonly-深度Readonly" class="headerlink" title="DeepReadonly(深度Readonly)"></a>DeepReadonly(深度Readonly)</h3><p><link-and-solution num="9"></link-and-solution></p><h4 id="用法-19"><a href="#用法-19" class="headerlink" title="用法"></a>用法</h4><p><code>DeepReadonly</code>用来将一个嵌套对象类型中所有字段全部添加<code>readonly</code>关键词，例如：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型：</span></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">  b: <span class="built_in">string</span></span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="built_in">boolean</span></span><br><span class="line">    e: <span class="literal">undefined</span>,</span><br><span class="line">    f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> Y = &#123;</span><br><span class="line">  readonly b: <span class="built_in">string</span></span><br><span class="line">  readonly c: &#123;</span><br><span class="line">    readonly d: <span class="built_in">boolean</span></span><br><span class="line">    readonly e: <span class="literal">undefined</span>,</span><br><span class="line">    readonly f: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-19"><a href="#实现方式-19" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; ? DeepReadonly&lt;T[P]&gt; : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[P] extends { [key: string]: any }</code>：这段表示<code>T[P]</code>是否是一个包含索引签名的字段，如果包含我们认为它是一个嵌套对象，就可以递归调用<code>DeepReadonly</code>。</li></ul><h3 id="TupleToUnion-元组转联合类型"><a href="#TupleToUnion-元组转联合类型" class="headerlink" title="TupleToUnion(元组转联合类型)"></a>TupleToUnion(元组转联合类型)</h3><p><link-and-solution num="10"></link-and-solution></p><h4 id="用法-20"><a href="#用法-20" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToUnion</code>是用来将一个元组转换成联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'1' | '2' | '3'</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToUnion&lt;[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-20"><a href="#实现方式-20" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: T[number]</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>]</span><br><span class="line"><span class="comment">// way2: 递归</span></span><br><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">    ? R | TupleToUnion&lt;args&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[number]</code>：它会自动迭代元组的数字型索引，然后将所有元素组合成一个联合类型。</li><li><code>R | TupleToUnion&lt;args&gt;</code>：<code>R</code>表示每一次迭代中的第一个元素，它的迭代过程可以用下面伪代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">'3'</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | TupleToUnion&lt;args&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line"><span class="keyword">const</span> R = <span class="string">'3'</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">''</span>]</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">'1'</span> | <span class="string">'2'</span> | <span class="string">'3'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Chainable-可串联构造器"><a href="#Chainable-可串联构造器" class="headerlink" title="Chainable(可串联构造器)"></a>Chainable(可串联构造器)</h3><p><link-and-solution num="12"></link-and-solution></p><h4 id="用法-21"><a href="#用法-21" class="headerlink" title="用法"></a>用法</h4><p><code>Chainable</code>是用来让一个对象可以进行链式调用的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  foo: <span class="built_in">number</span></span><br><span class="line">  bar: &#123;</span><br><span class="line">    value: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> obj: Chainable&lt;&#123;&#125;&gt;</span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">const</span> result = obj</span><br><span class="line">  .options(<span class="string">'foo'</span>, <span class="number">123</span>)</span><br><span class="line">  .options(<span class="string">'bar'</span>, &#123; value: <span class="string">'Hello'</span> &#125;)</span><br><span class="line">  .options(<span class="string">'name'</span>, <span class="string">'TypeScript'</span>)</span><br><span class="line">  .get()</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-21"><a href="#实现方式-21" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chainable&lt;T&gt; = &#123;</span><br><span class="line">  options&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, V&gt;(key: K, value: V): Chainable&lt;T &amp; &#123;[k <span class="keyword">in</span> K]: V&#125;&gt;</span><br><span class="line">  <span class="keyword">get</span>(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>{[k in K]: V}</code>：每次调用<code>options</code>时，把<code>key/value</code>构造成一个对象，例如：<code>{ foo: 123 }</code>。</li><li><code>T &amp; U</code>：此处使用到<code>&amp;</code>关键词，用来合并<code>T</code>和<code>U</code>两个对象中的所有<code>key</code>。</li><li><code>Chainable&lt;&gt;</code>：递归调用<code>Chainable</code>，赋予新对象以链式调用的能力。</li></ul><h3 id="Last-数组最后一个元素"><a href="#Last-数组最后一个元素" class="headerlink" title="Last(数组最后一个元素)"></a>Last(数组最后一个元素)</h3><p><link-and-solution num="15"></link-and-solution></p><h4 id="用法-22"><a href="#用法-22" class="headerlink" title="用法"></a>用法</h4><p><code>Last</code>是用来获取数组中最后一个元素的，它和我们之前已经实现的<code>First</code>思路很相似。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = Last&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-22"><a href="#实现方式-22" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Last</code>的实现方式很巧妙，因为它既可以在索引上做文章来实现，也可以用占位的思想来实现。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1：索引思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [<span class="built_in">any</span>, ...T][T[<span class="string">'length'</span>]]</span><br><span class="line"><span class="comment">// way2: 后占位思想</span></span><br><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer R, infer L] ? L : never</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><p><code>[any, ...T]</code>：此代码表示我们构建了一个新数组，并添加了一个新元素到第一个位置，然后把原数组<code>T</code>中的元素依次扩展到新数组中，可以用以下伪代码表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 新数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="built_in">any</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 结果: 3</span></span><br><span class="line"><span class="keyword">const</span> result = arr[T[<span class="string">'length'</span>]]</span><br></pre></td></tr></table></figure></li><li><p><code>T[&#39;length&#39;]</code>：这里我们获取到的是原始<code>T</code>数组的长度，例如<code>[1, 2, 3]</code>，长度值为<code>3</code>。而在新数组中，索引为<code>3</code>的位置正好是最后一个元素的索引，通过这种方式就能达到我们的目的。</p></li><li><code>T extends [...infer R, infer L]</code>：这段代码表示，我们将原数组中最后一个元素使用<code>L</code>进行占位，而其它元素我们用一个<code>R</code>数组表示。这样，如果数组满足这种格式，就能正确返回最后一个元素的值。</li></ul><h3 id="Pop-数组Pop方法"><a href="#Pop-数组Pop方法" class="headerlink" title="Pop(数组Pop方法)"></a>Pop(数组Pop方法)</h3><p><link-and-solution num="16"></link-and-solution></p><p>继续沿用以上处理索引思想或占位的思想，我们能快速实现数组<code>pop</code>方法。</p><h4 id="用法-23"><a href="#用法-23" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Pop&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2：[]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Pop&lt;[]&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-23"><a href="#实现方式-23" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop实现</span></span><br><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> []</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> [...infer Rest, infer L]</span><br><span class="line">      ? Rest</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure><h3 id="PromiseAll返回类型"><a href="#PromiseAll返回类型" class="headerlink" title="PromiseAll返回类型"></a>PromiseAll返回类型</h3><p><link-and-solution num="20"></link-and-solution></p><h4 id="用法-24"><a href="#用法-24" class="headerlink" title="用法"></a>用法</h4><p><code>PromiseAll</code>是用来取<code>Promise.all()</code>函数所有返回的类型，其用法如下<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result1 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result2 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)] <span class="keyword">as</span> <span class="keyword">const</span>)</span><br><span class="line"><span class="keyword">const</span> result3 = PromiseAll([<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)])</span><br><span class="line"><span class="keyword">const</span> result4 = PromiseAll&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1： Promise&lt;[1, 2, 3]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">typeof</span> result1</span><br><span class="line"><span class="comment">// 结果2： Promise&lt;[1, 2, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="keyword">typeof</span> result2</span><br><span class="line"><span class="comment">// 结果3： Promise&lt;[number, number, number]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="keyword">typeof</span> result3</span><br><span class="line"><span class="comment">// 结果4： Promise&lt;number[]&gt;</span></span><br><span class="line"><span class="keyword">type</span> t4 = <span class="keyword">typeof</span> result4</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-24"><a href="#实现方式-24" class="headerlink" title="实现方式"></a>实现方式</h4><p>与之前的例子不同，<code>PromiseAll</code>我们声明的是一个<code>function</code>而不是<code>type</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Awaited为内置类型</span></span><br><span class="line"><span class="keyword">type</span> PromiseAllType&lt;T&gt; = <span class="built_in">Promise</span>&lt;&#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: Awaited&lt;T[P]&gt;</span><br><span class="line">&#125;&gt;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">values: readonly [...T]</span>): <span class="title">PromiseAllType</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li>因为<code>Promise.all()</code>函数接受的是一个数组，因此泛型<code>T</code>限制为一个<code>any[]</code>类型的数组。</li><li><code>PromiseAllType</code>的实现思路有点像之前的<code>PromiseType</code>，只不过这里多了一层<code>Promise</code>的包裹，因为<code>Promise.all()</code>的返回类型也是一个<code>Promise</code>。</li></ul><h3 id="LookUp-查找"><a href="#LookUp-查找" class="headerlink" title="LookUp(查找)"></a>LookUp(查找)</h3><p><link-and-solution num="62"></link-and-solution></p><h4 id="用法-25"><a href="#用法-25" class="headerlink" title="用法"></a>用法</h4><p><code>LookUp</code>是用来根据类型值查<code>type</code>找类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'cat'</span></span><br><span class="line">  color: <span class="string">'black'</span> | <span class="string">'orange'</span> | <span class="string">'gray'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'dog'</span></span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">  name: <span class="string">'wang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Dog</span></span><br><span class="line"><span class="keyword">type</span> result = LookUp&lt;Cat | Dog, <span class="string">'dog'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-25"><a href="#实现方式-25" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LookUp&lt;</span><br><span class="line">  U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: <span class="built_in">string</span>; &#125;,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = U <span class="keyword">extends</span> &#123; <span class="keyword">type</span>: T &#125; ? U : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>U extends { type: string; }</code>：这段代码限制<code>U</code>的类型必须是具有属性为<code>type</code>的对象。</li><li><code>U extends { type: T }</code>：如果把<code>T</code>的值实际带入，为<code>U extends { type: &#39;dog&#39; }</code>，表示判断<code>U</code>中的<code>type</code>值是不是<code>dog</code>，是则返回<code>U</code>。</li></ul><h3 id="Trim、TrimLeft以及TrimRight"><a href="#Trim、TrimLeft以及TrimRight" class="headerlink" title="Trim、TrimLeft以及TrimRight"></a>Trim、TrimLeft以及TrimRight</h3><p>TrimLeft：<link-and-solution num="106"><br>TrimRight：<link-and-solution num="4803"><br>Trim：<link-and-solution num="108"></link-and-solution></link-and-solution></link-and-solution></p><h4 id="用法-26"><a href="#用法-26" class="headerlink" title="用法"></a>用法</h4><p><code>Trim</code>、<code>TrimLeft</code>以及<code>TrimRight</code>这几个工具比较好理解，它们都是用来移除字符串中的空白符的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = TrimLeft&lt;<span class="string">' str'</span>&gt;  <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t2 = Trim&lt;<span class="string">' str '</span>&gt;     <span class="comment">// 'str'</span></span><br><span class="line"><span class="keyword">type</span> t3 = TrimRight&lt;<span class="string">'str '</span>&gt; <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-26"><a href="#实现方式-26" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">' '</span> | <span class="string">'\n'</span> | <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? TrimLeft&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> (<span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> | <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span>) ? Trim&lt;R&gt; : S</span><br><span class="line"><span class="keyword">type</span> TrimRight&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span> ? TrimRight&lt;R&gt; : S</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>TrimLeft</code>和<code>TrimRight</code>的实现思路是相同的，区别在于空白符的占位出现在左侧还是右侧。</li><li><code>Trim</code>的实现就是把<code>TrimLeft</code>和<code>TrimRight</code>所做的事情结合起来。</li></ul><h3 id="Capitalize-首字母大写-和UnCapitalize-首字母小写"><a href="#Capitalize-首字母大写-和UnCapitalize-首字母小写" class="headerlink" title="Capitalize(首字母大写)和UnCapitalize(首字母小写)"></a>Capitalize(首字母大写)和UnCapitalize(首字母小写)</h3><p><link-and-solution num="110"></link-and-solution></p><h4 id="用法-27"><a href="#用法-27" class="headerlink" title="用法"></a>用法</h4><p><code>Capitalize</code>是用来将一个字符串的首字母变成大写的，而<code>UnCapitalize</code>所做的事情跟它相反，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = Capitalize&lt;<span class="string">'hello'</span>&gt;   <span class="comment">// 'Hello'</span></span><br><span class="line"><span class="keyword">type</span> t2 = UnCapitalize&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-27"><a href="#实现方式-27" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br><span class="line"><span class="keyword">type</span> UnCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer char&#125;</span><span class="subst">$&#123;infer L&#125;</span>`</span> ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;char&gt;&#125;</span><span class="subst">$&#123;L&#125;</span>`</span> : S</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>无论是<code>Capitalize</code>还是<code>UnCapitalize</code>，它们都依赖内置的工具函数<code>Uppercase</code>或者<code>Lowercase</code>。对于<code>Capitalize</code>而言，我们只需要把首字母隔离出来，然后调用<code>Uppercase</code>即可。对于<code>UnCapitalize</code>而言，我们把首字母调用<code>Lowercase</code>即可。</li></ul><h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><p><link-and-solution num="116"></link-and-solution></p><h4 id="用法-28"><a href="#用法-28" class="headerlink" title="用法"></a>用法</h4><p><code>Replace</code>是用来将字符串中第一次出现的某段内容，使用指定的字符串进行替换，而<code>ReplaceAll</code>是全部替换，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：'foofoobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： foobarbar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Replace&lt;<span class="string">'foobarbar'</span>, <span class="string">''</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-28"><a href="#实现方式-28" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><p><link-and-solution num="119"></link-and-solution></p><h4 id="用法-29"><a href="#用法-29" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceAll</code>是用来将字符串中指定字符全部替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'foofoofoo'</span></span><br><span class="line"><span class="keyword">type</span> t = ReplaceAll&lt;<span class="string">'foobarbar'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-29"><a href="#实现方式-29" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceAll&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  to <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? <span class="keyword">from</span> <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">        ? S</span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;ReplaceAll&lt;L, <span class="keyword">from</span>, to&gt;&#125;</span><span class="subst">$&#123;to&#125;</span><span class="subst">$&#123;ReplaceAll&lt;R, <span class="keyword">from</span>, to&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="AppendArgument-追加参数"><a href="#AppendArgument-追加参数" class="headerlink" title="AppendArgument(追加参数)"></a>AppendArgument(追加参数)</h3><p><link-and-solution num="191"></link-and-solution></p><h4 id="用法-30"><a href="#用法-30" class="headerlink" title="用法"></a>用法</h4><p><code>AppendArgument</code>是用来向一个函数追加一个参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结果：(a: number, b: number) =&gt; number</span></span><br><span class="line"><span class="keyword">type</span> result = AppendArgument&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-30"><a href="#实现方式-30" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendArgument&lt;Fn, A&gt; = Fn <span class="keyword">extends</span> (...args: infer R) =&gt; infer T ? <span class="function">(<span class="params">...args: [...R, A]</span>) =&gt;</span> T : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>我们首先利用<code>infer</code>关键词得到了<code>Fn</code>函数的参数类型以及返回类型，然后把新的参数添加到参数列表，并原样返回其函数类型。</li></ul><h3 id="Permutation-排列组合"><a href="#Permutation-排列组合" class="headerlink" title="Permutation(排列组合)"></a>Permutation(排列组合)</h3><p><link-and-solution num="296"></link-and-solution></p><h4 id="用法-31"><a href="#用法-31" class="headerlink" title="用法"></a>用法</h4><p><code>Permutation</code>是用来将联合类型中的每一个类型进行排列组合，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['A', 'B'] | ['B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result1 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']</span></span><br><span class="line"><span class="keyword">type</span> result2 = Permutation&lt;<span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-31"><a href="#实现方式-31" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Permutation&lt;T, U = T&gt; = </span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? []</span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [T, ...Permutation&lt;Exclude&lt;U, T&gt;&gt;]</span><br><span class="line">      : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>[T] extends [never]</code>：这段代码主要是为了处理联合类型为空的情况。</li><li><code>T extends U</code>：这段代码主要是需要使用<strong>分布式条件类型</strong>这个知识点，当<code>T extends U</code>成立时，在其后的判断语句中，<code>T</code>代表当前迭代的类型。</li><li><code>&lt;Exclude&lt;U, T&gt;</code>：因为此时的<code>T</code>代表当前迭代的类型，所以我们从原始联合类型中排除当前类型，然后递归调用<code>Permutation</code>。当<code>T</code>为<code>A</code>时，递归调用<code>Permutation&lt;&#39;B&#39; | &#39;C&#39;&gt;</code>, 此时结果为<code>[&#39;A&#39;]</code> + <code>[&#39;B&#39;, &#39;C&#39;]</code> 或 <code>[&#39;A&#39;]</code> + <code>[&#39;C&#39;, &#39;B&#39;]</code>。</li></ul><h3 id="LengthOfString-字符串的长度"><a href="#LengthOfString-字符串的长度" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="298"></link-and-solution></p><h4 id="用法-32"><a href="#用法-32" class="headerlink" title="用法"></a>用法</h4><p><code>LengthOfString</code>是用来计算一个字符串长度的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'Hello'</span>&gt; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-32"><a href="#实现方式-32" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;R, [...T, Char]&gt;</span><br><span class="line">      : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>我们通过一个泛型的辅助数组来帮计算字符串的长度，在第一次符合条件时，将其第一个字符添加到数组中，在后续的递归过程中，如果不符合条件，直接返回<code>T[&#39;length&#39;]</code>，这个过程可以用如下代码表示：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>], S = <span class="string">'hello'</span>, R = <span class="string">'ello'</span></span><br><span class="line"><span class="comment">// 第二次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>], S = <span class="string">'ello'</span>, R = <span class="string">'llo'</span></span><br><span class="line"><span class="comment">// 第三次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>], S = <span class="string">'llo'</span>, R = <span class="string">'lo'</span></span><br><span class="line"><span class="comment">// 第四次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>], S = <span class="string">'lo'</span>, R = <span class="string">'o'</span></span><br><span class="line"><span class="comment">// 第五次递归</span></span><br><span class="line"><span class="keyword">const</span> T = [<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>, <span class="string">'o'</span>], S = <span class="string">'o'</span>, R = <span class="string">''</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Flatten-数组降维"><a href="#Flatten-数组降维" class="headerlink" title="Flatten(数组降维)"></a>Flatten(数组降维)</h3><p><link-and-solution num="459"></link-and-solution></p><h4 id="用法-33"><a href="#用法-33" class="headerlink" title="用法"></a>用法</h4><p><code>Flatten</code>是用来将多维数组进行降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Flatten&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>]]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-33"><a href="#实现方式-33" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer L, ...infer R]</span><br><span class="line">      ? L <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">        ? [...Flatten&lt;L&gt;, ...Flatten&lt;R&gt;]</span><br><span class="line">        : [L, ...Flatten&lt;R&gt;]</span><br><span class="line">      : []</span><br></pre></td></tr></table></figure><p>代码详解：<code>Flatten</code>数组降维的主要思路是，遍历数组中的每一个元素，判断其是否为一个数组，如果是，则递归调用<code>Flatten</code>，进行降维。</p><h3 id="AppendToObject-对象添加新属性"><a href="#AppendToObject-对象添加新属性" class="headerlink" title="AppendToObject(对象添加新属性)"></a>AppendToObject(对象添加新属性)</h3><p><link-and-solution num="527"></link-and-solution></p><h4 id="用法-34"><a href="#用法-34" class="headerlink" title="用法"></a>用法</h4><p><code>AppendToObject</code>是用来向指定对象添加一个额外的属性(<code>key/value</code>)，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = AppendToObject&lt;&#123; id: <span class="built_in">number</span>; &#125;, <span class="string">'name'</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-34"><a href="#实现方式-34" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> basicKeyType = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line"><span class="keyword">type</span> AppendToObject&lt;T, K <span class="keyword">extends</span> basicKeyType, V&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T | K]: P <span class="keyword">extends</span> keyof T ? T[P] : V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>basicKeyType</code>：在<code>JavaScript</code>中，因为一个对象的属性只能是<code>string</code>、<code>number</code>或者<code>symbol</code>这三种类型，所以我们限定<code>K</code>必须满足此条件。</li><li><code>keyof T | K</code>：这里表示<code>keyof T</code>的联合类型和<code>K</code>，组合成一个新的联合类型。</li></ul><h3 id="Absolute-绝对值"><a href="#Absolute-绝对值" class="headerlink" title="Absolute(绝对值)"></a>Absolute(绝对值)</h3><p><link-and-solution num="529"></link-and-solution></p><h4 id="用法-35"><a href="#用法-35" class="headerlink" title="用法"></a>用法</h4><p><code>Absolute</code>是用来取一个数的绝对值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1："531"</span></span><br><span class="line"><span class="keyword">type</span> result1 = Absolute&lt;<span class="number">-531</span>&gt;</span><br><span class="line"><span class="comment">// 结果2："9999"</span></span><br><span class="line"><span class="keyword">type</span> result2 = Absolute&lt;<span class="number">9</span>_999n&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-35"><a href="#实现方式-35" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberLike = <span class="built_in">number</span> | <span class="built_in">string</span> | bigint</span><br><span class="line"><span class="keyword">type</span> Absolute&lt;T <span class="keyword">extends</span> NumberLike&gt; =  <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`-<span class="subst">$&#123;infer N&#125;</span>`</span> ? N : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>NumberLike</code>：我们认为<code>&#39;1&#39;</code>和<code>1</code>都是一个合法的数字，所以定义一个辅助的<code>NumberList</code>联合类型。</li><li><code>${T}</code> extends <code>-${infer N}</code>：这里判断我们传递的数字是否为负数，如果是则直接取其正数部分，否则直接返回。</li></ul><p><strong>注意</strong>：这里说到的取绝对值，最后的结果之所以是一个字符串类型，是因为<code>TS</code>对递归次数有限制。如果你想要真正的数字类型，可以考虑实现一个<code>MakeArray</code>辅助方法，使用此方法可以将字符串类型的数字，转换成一个真正的数字类型，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; =</span><br><span class="line">  N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span></span><br><span class="line">  ? T</span><br><span class="line">  : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = MakeArray&lt;<span class="string">'3'</span>&gt;[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="StringToArray-字符串转数组"><a href="#StringToArray-字符串转数组" class="headerlink" title="StringToArray(字符串转数组)"></a>StringToArray(字符串转数组)</h3><blockquote><p>tip<br>此题不属于type-challenges类型挑战题</p></blockquote><h4 id="用法-36"><a href="#用法-36" class="headerlink" title="用法"></a>用法</h4><p><code>StringToArray</code>是用来将一个字符串转换成一个数组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToArray&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-36"><a href="#实现方式-36" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToArray&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? StringToArray&lt;R, [...U, Char]&gt;</span><br><span class="line">      : U</span><br></pre></td></tr></table></figure><p>代码详解：<code>StringToArray</code>的实现主要是使用了递归的思想，它每次拿到字符串中一个字符，然后存入一个辅助数组中，当字符串为空时，直接返回这个辅助数组。</p><h3 id="StringToUnion-字符串转联合类型"><a href="#StringToUnion-字符串转联合类型" class="headerlink" title="StringToUnion(字符串转联合类型)"></a>StringToUnion(字符串转联合类型)</h3><p><link-and-solution num="531"></link-and-solution></p><h4 id="用法-37"><a href="#用法-37" class="headerlink" title="用法"></a>用法</h4><p>在实现<code>StringToArray</code>后，我们能够很容易实现<code>StringToUnion</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'h' | 'e' | 'l' | 'l' | 'o'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'hello'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-37"><a href="#实现方式-37" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 递归思想</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">      ? Char | StringToUnion&lt;R&gt;</span><br><span class="line">      : never</span><br><span class="line"><span class="comment">// way2: 借用StringToArray</span></span><br><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = StringToArray&lt;S&gt;[<span class="built_in">number</span>]</span><br></pre></td></tr></table></figure><p>代码详解：<code>StringToArray&lt;S&gt;</code>返回的是一个数组，<code>T[number]</code>表示对一个数组进行数字类型索引迭代，其迭代结果是每个元素组合成的一个联合类型。</p><h3 id="Merge-类型合并"><a href="#Merge-类型合并" class="headerlink" title="Merge(类型合并)"></a>Merge(类型合并)</h3><p><link-and-solution num="599"></link-and-solution></p><h4 id="用法-38"><a href="#用法-38" class="headerlink" title="用法"></a>用法</h4><p><code>Merge</code>是用来合并两个类型，如果有重复的字段类型，则第二个的字段类型覆盖第一个的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">  c: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Merge&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-38"><a href="#实现方式-38" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Merge&lt;F, S&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof F | keyof S]: P <span class="keyword">extends</span> keyof S ? S[P] : P <span class="keyword">extends</span> keyof F ? F[P] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>keyof F | keyof S</code>：这段代码的含义是将<code>F</code>和<code>S</code>这两个对象的键组合成一个新的联合类型。</li><li><code>P extends</code>：这里进行了两次<code>extends</code>判断，其中第二次不能直接写成<code>F[P]</code>，而应该多判断一次，当满足条件时才使用<code>F[P]</code>，这是因为<code>P</code>的类型判断无法作用于<code>:</code>符号后面。</li></ul><h3 id="KebabCase-字符串转连字符"><a href="#KebabCase-字符串转连字符" class="headerlink" title="KebabCase(字符串转连字符)"></a>KebabCase(字符串转连字符)</h3><p><link-and-solution num="612"></link-and-solution></p><h4 id="用法-39"><a href="#用法-39" class="headerlink" title="用法"></a>用法</h4><p><code>KebabCase</code>是用来将驼峰形式字符串，转成连字符形式字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：foo-bar-baz</span></span><br><span class="line"><span class="keyword">type</span> result = KebabCase&lt;<span class="string">'FooBarBaz'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-39"><a href="#实现方式-39" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KebabCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? S2 <span class="keyword">extends</span> Uncapitalize&lt;S2&gt;</span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span><span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;Uncapitalize&lt;S1&gt;&#125;</span>-<span class="subst">$&#123;KebabCase&lt;S2&gt;&#125;</span>`</span></span><br><span class="line">      : S</span><br></pre></td></tr></table></figure><h3 id="Diff-类型差异部分"><a href="#Diff-类型差异部分" class="headerlink" title="Diff(类型差异部分)"></a>Diff(类型差异部分)</h3><p><link-and-solution num="645"></link-and-solution></p><h4 id="用法-40"><a href="#用法-40" class="headerlink" title="用法"></a>用法</h4><p><code>Diff</code>是用来获取两个类型的不同部分的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; id: number; gender: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = Diff&lt;Foo, Bar&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-40"><a href="#实现方式-40" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiffKeys&lt;T, U&gt; = Exclude&lt;keyof T | keyof U, keyof (T | U)&gt;</span><br><span class="line"><span class="keyword">type</span> Diff&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> DiffKeys&lt;T, U&gt;]: K <span class="keyword">extends</span> keyof T ? T[K] : K <span class="keyword">extends</span> keyof U ? U[K] : never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>keyof Foo | keyof Bar</code>：这段代码是把<code>T</code>和<code>U</code>中的所有属性组合成一个新的联合类型。</li><li><code>keyof (T | U)</code>：这段代码是取<code>T</code>和<code>U</code>的公共属性。</li><li><code>Exclude&lt;K1, K2&gt;</code>：这段代码主要是用来从<code>K1</code>中排除<code>K2</code>，带入以上例子也就是排除掉所有公共属性。</li><li><code>Diff&lt;T, U&gt;</code>：在获取到<code>DiffKeys</code>后，就可以迭代的方式获取到每个属性<code>key</code>，它所对应的类型了。</li><li><code>K extends keyof U</code>：额外再判断一次，是因为<code>K</code>不能在三元表达式右侧使用。</li></ul><h3 id="AnyOf-数组元素真值判断"><a href="#AnyOf-数组元素真值判断" class="headerlink" title="AnyOf(数组元素真值判断)"></a>AnyOf(数组元素真值判断)</h3><p><link-and-solution num="949"></link-and-solution></p><h4 id="用法-41"><a href="#用法-41" class="headerlink" title="用法"></a>用法</h4><p><code>AnyOf</code>用来判断数组元素真假值的，如果任一值为真，返回<code>true</code>；数组为空或者全部为<code>false</code>，才返回<code>false</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AnyOf&lt;[<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>, &#123; name: <span class="string">'name'</span> &#125;]&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AnyOf&lt;[<span class="number">0</span>, <span class="string">''</span>, <span class="literal">false</span>, [], &#123;&#125;]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-41"><a href="#实现方式-41" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FalsyType = <span class="number">0</span> | <span class="string">''</span> | <span class="literal">false</span> | <span class="literal">undefined</span> | <span class="literal">null</span> | [] | &#123; [key: <span class="built_in">string</span>]: never &#125;</span><br><span class="line"><span class="keyword">type</span> AnyOf&lt;T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> FalsyType ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：因为我们就是要区分<code>true/false</code>，所以我们把所有为<code>false</code>的值全部列举出来，然后使用<code>T[number]</code>索引迭代，依次去跟<code>FalsyType</code>比较，其中<code>{ [key: string]: never }</code>表示空对象<code>{}</code>。</p><h3 id="IsNever-是否是Never类型"><a href="#IsNever-是否是Never类型" class="headerlink" title="IsNever(是否是Never类型)"></a>IsNever(是否是Never类型)</h3><p><link-and-solution num="1042"></link-and-solution></p><h4 id="用法-42"><a href="#用法-42" class="headerlink" title="用法"></a>用法</h4><p><code>IsNever</code>是用来判断是否为<code>never</code>类型，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsNever&lt;<span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsNever&lt;never&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result3 = IsNever&lt;never | <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-42"><a href="#实现方式-42" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Equal&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 类型数组</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = T[] <span class="keyword">extends</span> never[] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 数组值</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way3: 值比较</span></span><br><span class="line"><span class="keyword">type</span> IsNever&lt;T&gt; = Equal&lt;T, never&gt;</span><br></pre></td></tr></table></figure><h3 id="IsUnion-是否联合类型"><a href="#IsUnion-是否联合类型" class="headerlink" title="IsUnion(是否联合类型)"></a>IsUnion(是否联合类型)</h3><p><link-and-solution num="1097"></link-and-solution></p><h4 id="用法-43"><a href="#用法-43" class="headerlink" title="用法"></a>用法</h4><p><code>IsUnion</code>是用来判断一个类型是否为联合类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsUnion&lt;<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">boolean</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsUnion&lt;never&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-43"><a href="#实现方式-43" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// way1: 排除法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> U</span><br><span class="line">      ? [Exclude&lt;U, T&gt;] <span class="keyword">extends</span> [never]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br><span class="line"><span class="comment">// way2: 正反对比法</span></span><br><span class="line"><span class="keyword">type</span> IsUnion&lt;T, U = T&gt; = </span><br><span class="line">  (T <span class="keyword">extends</span> U</span><br><span class="line">    ? U <span class="keyword">extends</span> T</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : unknown</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  ) <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：上面的实现虽然代码不多，但可能无法一下子就弄明白，为了更好的理解这种实现方式，我们来看如下两个案例分析：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例一</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step1: <span class="built_in">string</span> | <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">step2: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">number</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step3: <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="function"><span class="params">number</span> =&gt;</span> [<span class="built_in">string</span>] <span class="keyword">extends</span> [never] =&gt; <span class="literal">true</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">true</span></span><br><span class="line">result: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例二</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="built_in">string</span></span><br><span class="line">step1: <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">step2: [never] <span class="keyword">extends</span> [never] =&gt; <span class="literal">false</span></span><br><span class="line">result: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>根据之前我们学到的<strong>分布式条件类型</strong>知识，<code>T extends U</code>的时候，会把<code>T</code>进行子类型分发。</p><p>如案例一的<code>step3</code>、<code>step4</code>，在分发后会把每次迭代的结果联合起来，组合成最终的结果。</p><h3 id="ReplaceKeys-类型替换"><a href="#ReplaceKeys-类型替换" class="headerlink" title="ReplaceKeys(类型替换)"></a>ReplaceKeys(类型替换)</h3><p><link-and-solution num="1130"></link-and-solution></p><h4 id="用法-44"><a href="#用法-44" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceKeys</code>是用来在一个类型中，使用指定的Y类型来替换已经存在的T类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; id: number; name: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceKeys&lt;&#123; id: <span class="built_in">number</span>; name: <span class="built_in">string</span>; &#125;, <span class="string">'name'</span>, &#123; name: <span class="built_in">boolean</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-44"><a href="#实现方式-44" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceKeys&lt;U, T, Y&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof U]:</span><br><span class="line">    P <span class="keyword">extends</span> T</span><br><span class="line">      ? P <span class="keyword">extends</span> keyof Y</span><br><span class="line">        ? Y[P]</span><br><span class="line">        : never</span><br><span class="line">      : U[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RemoveIndexSignature-移除索引签名"><a href="#RemoveIndexSignature-移除索引签名" class="headerlink" title="RemoveIndexSignature(移除索引签名)"></a>RemoveIndexSignature(移除索引签名)</h3><p><link-and-solution num="1367"></link-and-solution></p><h4 id="用法-45"><a href="#用法-45" class="headerlink" title="用法"></a>用法</h4><p><code>RemoveIndexSignature</code>是用来移除一个类型中的索引签名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  foo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; foo(): void; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = RemoveIndexSignature&lt;Foo&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-45"><a href="#实现方式-45" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckIndexSignature&lt;T, P&gt; = P <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> RemoveIndexSignature&lt;T, K = PropertyKey&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never)] : T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>CheckIndexSignature</code>：因为索引签名有一个特点，为<code>string | number | symbol</code>，所以我们通过<code>P extends T ? true : false</code>形式排除此索引签名。其原理如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooKeys = <span class="built_in">string</span> | <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">example1: T = <span class="string">'foo'</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="string">'foo'</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">false</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">example2: T = <span class="built_in">string</span>, P = <span class="built_in">string</span> | <span class="built_in">number</span> | symbol</span><br><span class="line">step1: (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol) <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">step2: (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">       (symbol <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>) |</span><br><span class="line">step3: <span class="literal">true</span> | <span class="literal">false</span> | <span class="literal">false</span></span><br><span class="line">step4: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">step5: <span class="built_in">boolean</span></span><br></pre></td></tr></table></figure></li><li><p><code>as xxx</code>：在之前的案例中，我们介绍过<code>as</code>的用法，在这里有<strong>加工</strong>或<strong>再次断言</strong>的意思。在使用<code>in</code>操作符进行迭代时，对每一个<code>P</code>再使用<code>CheckIndexSignature</code>加工一下，如果是索引签名，这里的结果为<code>never</code>，为<code>never</code>时表示跳过当前迭代，进而达到排除索引签名的目的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代 P = 'foo'</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="literal">false</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; P</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代 P = string</span></span><br><span class="line">   CheckIndexSignature&lt;P, K&gt; <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; <span class="built_in">boolean</span> <span class="keyword">extends</span> <span class="literal">false</span> ? P : never</span><br><span class="line">=&gt; never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终结果</span></span><br><span class="line"><span class="keyword">type</span> result = &#123; foo(): <span class="built_in">void</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="PercentageParser-百分比解析"><a href="#PercentageParser-百分比解析" class="headerlink" title="PercentageParser(百分比解析)"></a>PercentageParser(百分比解析)</h3><p><link-and-solution num="1978"></link-and-solution></p><h4 id="用法-46"><a href="#用法-46" class="headerlink" title="用法"></a>用法</h4><p><code>PercentageParser</code>是用来解析百分比字符串的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = PercentageParser&lt;<span class="string">'+85%'</span>&gt; <span class="comment">// ['+', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result2 = PercentageParser&lt;<span class="string">'-85%'</span>&gt; <span class="comment">// ['-', '85', '%']</span></span><br><span class="line"><span class="keyword">type</span> result3 = PercentageParser&lt;<span class="string">'85'</span>&gt;   <span class="comment">// ['', '85', '']</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-46"><a href="#实现方式-46" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckPrefix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">'+'</span> | <span class="string">'-'</span> ? S : never</span><br><span class="line"><span class="keyword">type</span> CheckSuffix&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>%`</span> ? [L, <span class="string">'%'</span>] : [S, <span class="string">''</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PercentageParser&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;CheckPrefix&lt;infer L&gt;&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? [L, ...CheckSuffix&lt;R&gt;]</span><br><span class="line">    : [<span class="string">''</span>, ...CheckSuffix&lt;S&gt;]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>CheckPrefix</code>是用来处理百分比字符串前面的符号的，如果存在<code>+</code>或者<code>-</code>，则原样返回，如果不存在则返回<code>never</code>，表示没有符号。</li><li><code>CheckSuffix</code>是用来处理百分比字符串后面的百分比符号的，如果存在，则返回一个数组(最后一项固定为百分比符号)；如果不存在，则返回的数组最后一个元素固定为空字符串。</li></ul><h3 id="DropChar-移除字符"><a href="#DropChar-移除字符" class="headerlink" title="DropChar(移除字符)"></a>DropChar(移除字符)</h3><p><link-and-solution num="2070"></link-and-solution></p><h4 id="用法-47"><a href="#用法-47" class="headerlink" title="用法"></a>用法</h4><p><code>DropChar</code>是用来在字符串中移除指定字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：butterfly!</span></span><br><span class="line"><span class="keyword">type</span> result = DropChar&lt;<span class="string">' b u t t e r f l y ! '</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-47"><a href="#实现方式-47" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DropChar&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = C <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span><span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? DropChar&lt;<span class="string">`<span class="subst">$&#123;L&#125;</span><span class="subst">$&#123;R&#125;</span>`</span>, C&gt;</span><br><span class="line">    : S</span><br></pre></td></tr></table></figure><p>代码详解：<code>DropChar</code>和<code>ReplaceAll</code>的实现思路非常相似，首先需要判断待移除的字符是不是空字符串，如果是，则直接返回原始字符串；如果不是，先判断字符串中是否包含待移除的字符，包含则递归调用；不包含则直接返回原始字符串。</p><h3 id="MinusOne-减一"><a href="#MinusOne-减一" class="headerlink" title="MinusOne(减一)"></a>MinusOne(减一)</h3><p><link-and-solution num="2257"></link-and-solution></p><p><code>MinusOne</code>是用来实现数字减一的，其用法如下：</p><h4 id="用法-48"><a href="#用法-48" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：99</span></span><br><span class="line"><span class="keyword">type</span> result = MinusOne&lt;<span class="number">100</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-48"><a href="#实现方式-48" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinusOne&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = N <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">  ? T <span class="keyword">extends</span> [infer F, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : never</span><br><span class="line">  : MinusOne&lt;N, [<span class="number">0</span>, ...T]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：在实现<code>MinusOne</code>的时候，借用了一个空数组，首先判断数组的长度是否等于传递的数字<code>N</code>，如果相等则从数组中随意移除一位，然后返回剩下数组的长度即可；如果不相等，则往数组中添加一个元素，再递归调用<code>MinusOne</code>。</p><p><strong>注意</strong>：由于<code>TS</code>在递归调用时存在最大递归调用次数，所以对于比较大的数字会提示错误。</p><h3 id="PickByType-根据类型选取"><a href="#PickByType-根据类型选取" class="headerlink" title="PickByType(根据类型选取)"></a>PickByType(根据类型选取)</h3><p><link-and-solution num="2595"></link-and-solution></p><h4 id="用法-49"><a href="#用法-49" class="headerlink" title="用法"></a>用法</h4><p><code>PickByType</code>是用来根据类型选取属性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; isReadonly: boolean, isEnable: boolean &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = PickByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-49"><a href="#实现方式-49" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PickByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> U ? P : never]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：<code>PickByType</code>的实现，可以使用<code>as</code>进行第二次断言，当类型满足时就返回当前迭代的<code>P</code>，不满足类型时就返回<code>never</code>，因为<code>never</code>最后会被排除，所以最后的迭代结果只有满足类型的键。</p><h3 id="StartsWith-字符串startsWith方法"><a href="#StartsWith-字符串startsWith方法" class="headerlink" title="StartsWith(字符串startsWith方法)"></a>StartsWith(字符串startsWith方法)</h3><p><link-and-solution num="2688"></link-and-solution></p><h4 id="用法-50"><a href="#用法-50" class="headerlink" title="用法"></a>用法</h4><p><code>StartsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>startsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = StartsWith&lt;<span class="string">'abc'</span>, <span class="string">'ab'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-50"><a href="#实现方式-50" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StartsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;C&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="EndsWith-字符串endsWith方法"><a href="#EndsWith-字符串endsWith方法" class="headerlink" title="EndsWith(字符串endsWith方法)"></a>EndsWith(字符串endsWith方法)</h3><p><link-and-solution num="2693"></link-and-solution></p><h4 id="用法-51"><a href="#用法-51" class="headerlink" title="用法"></a>用法</h4><p><code>EndsWith</code>是用来实现<code>JavaScript</code>中字符串的<code>endsWith</code>功能，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = endsWith&lt;<span class="string">'abc'</span>, <span class="string">'bc'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-51"><a href="#实现方式-51" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EndsWith&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;C&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="PartialByKeys-按需可选"><a href="#PartialByKeys-按需可选" class="headerlink" title="PartialByKeys(按需可选)"></a>PartialByKeys(按需可选)</h3><p><link-and-solution num="2757"></link-and-solution></p><h4 id="用法-52"><a href="#用法-52" class="headerlink" title="用法"></a>用法</h4><p><code>PartialByKeys</code>是用来实现按需可选的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> UserPartialName &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  address: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserPartialName</span></span><br><span class="line"><span class="keyword">type</span> result = PartialByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-52"><a href="#实现方式-52" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PartialByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Omit</code>部分：根据之前介绍的<code>Omit</code>的知识，<code>Omit&lt;T, K&gt;</code>表示从<code>T</code>中剔除含有<code>K</code>的类型。</li><li><code>CopyKeys</code>部分：如果不使用<code>CopyKeys</code>，最后的结果为<code>T &amp; U</code>形式，它实际上与使用<code>CopyKeys</code>的结果是一样的。这里使用<code>CopyKeys</code>，很大程度上是为了测试。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用CopyKeys，结果为true；不使用，结果为false</span></span><br><span class="line"><span class="keyword">type</span> result1 = Equal&lt;PartialByKeys&lt;User, <span class="string">'name'</span>&gt;, UserPartialName&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RequiredByKeys-按需必填"><a href="#RequiredByKeys-按需必填" class="headerlink" title="RequiredByKeys(按需必填)"></a>RequiredByKeys(按需必填)</h3><p><link-and-solution num="2759"></link-and-solution></p><p>在实现<code>PartialByKeys</code>后，很容易按照相同的思路去实现<code>RequiredByKeys</code>。</p><h4 id="用法-53"><a href="#用法-53" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredByKeys</code>是用来实现按需必填的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UserRequiredName &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  address?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：UserRequiredName</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredByKeys&lt;User, <span class="string">'name'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-53"><a href="#实现方式-53" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CopyKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequiredByKeys&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> keyof T = keyof T</span><br><span class="line">&gt; = CopyKeys&lt;Omit&lt;T, K&gt; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]-?: T[P]</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：实现思路参考<code>PartialByKeys</code>。</p><h3 id="Mutable-可改"><a href="#Mutable-可改" class="headerlink" title="Mutable(可改)"></a>Mutable(可改)</h3><p><link-and-solution num="2793"></link-and-solution></p><h4 id="用法-54"><a href="#用法-54" class="headerlink" title="用法"></a>用法</h4><p><code>Mutable</code>是用来让所有属性变为可改的(移除<code>readonly</code>关键词)，其用法为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123; name: string; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> MutableResult = MyMutable&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-54"><a href="#实现方式-54" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMutable&lt;T&gt; = &#123;</span><br><span class="line">  -readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：</p><ul><li><code>-readonly</code>：表示把<code>readonly</code>关键词去掉，去掉之后此字段变为可改的。</li></ul><h3 id="OmitByType-按类型移除"><a href="#OmitByType-按类型移除" class="headerlink" title="OmitByType(按类型移除)"></a>OmitByType(按类型移除)</h3><p><link-and-solution num="2852"></link-and-solution></p><p><code>OmitByType</code>的实现思路和<code>PickByType</code>类似。</p><h4 id="用法-55"><a href="#用法-55" class="headerlink" title="用法"></a>用法</h4><p><code>OmitByType</code>是用来按照类型移除的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">  isReadonly: <span class="built_in">boolean</span></span><br><span class="line">  isEnable: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ModelOmitBoolean &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelOmitBoolean</span></span><br><span class="line"><span class="keyword">type</span> result = OmitByType&lt;Model, <span class="built_in">boolean</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-55"><a href="#实现方式-55" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OmitByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> U <span class="keyword">extends</span> T[P] ? never : P]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：实现思路参考<code>PickByType</code>。</p><h3 id="ObjectEntries"><a href="#ObjectEntries" class="headerlink" title="ObjectEntries"></a>ObjectEntries</h3><p><link-and-solution num="2946"></link-and-solution></p><h4 id="用法-56"><a href="#用法-56" class="headerlink" title="用法"></a>用法</h4><p><code>ObjectEntries</code>是用来实现<code>JavaScript</code>中的<code>Object.entries()</code>方法，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Model &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  locations?: <span class="built_in">string</span>[] | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ModelEntries = [<span class="string">'name'</span>, <span class="built_in">string</span>] | [<span class="string">'age'</span>, <span class="built_in">number</span>] | [<span class="string">'locations'</span>, <span class="built_in">string</span>[] | <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：ModelEntries</span></span><br><span class="line"><span class="keyword">type</span> result = ObjectEntries&lt;Model&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-56"><a href="#实现方式-56" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RemoveUndefined&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="literal">undefined</span>] ? T : Exclude&lt;T, <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">type</span> ObjectEntries&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: &#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? [P, RemoveUndefined&lt;T[P]&gt;] : [P, T[P]]</span><br><span class="line">&#125;[keyof T]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>RemoveUndefined</code>：当<code>T</code>仅为<code>undefined</code>，表示原始类型就是<code>undefined</code>; 当<code>T</code>为联合类型时，移除联合类型中的<code>undefined</code>。</li><li><code>[P in keyof T]-?</code>:  表示移除可选属性。</li><li><code>{} extends Pick&lt;T, P&gt;</code>: 判断当前的<code>P</code>是否为可选属性，是的话就是使用<code>RemoveUndefined</code>移除其中的<code>undefined</code>，否则取原始类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果都为true</span></span><br><span class="line"><span class="keyword">type</span> result1 = &#123;&#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; name: <span class="built_in">string</span>; &#125; <span class="keyword">extends</span> Person ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Shift-数组shift方法"><a href="#Shift-数组shift方法" class="headerlink" title="Shift(数组shift方法)"></a>Shift(数组shift方法)</h3><p><link-and-solution num="3062"></link-and-solution></p><h4 id="用法-57"><a href="#用法-57" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift结果：[2, 3]</span></span><br><span class="line"><span class="keyword">type</span> shiftResult = Shift&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-57"><a href="#实现方式-57" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shift实现</span></span><br><span class="line"><span class="keyword">type</span> Shift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer F, ...infer R] ? R : []</span><br></pre></td></tr></table></figure><h3 id="TupleToNestedObject-元组转嵌套对象"><a href="#TupleToNestedObject-元组转嵌套对象" class="headerlink" title="TupleToNestedObject(元组转嵌套对象)"></a>TupleToNestedObject(元组转嵌套对象)</h3><p><link-and-solution num="3188"></link-and-solution></p><h4 id="用法-58"><a href="#用法-58" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToNestedObject</code>是用来将元组转成嵌套对象的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; a: &#123; b: string; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = TupleToNestedObject&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-58"><a href="#实现方式-58" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToNestedObject&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">    ? &#123; [P <span class="keyword">in</span> F &amp; <span class="built_in">string</span>]: TupleToNestedObject&lt;R, U&gt; &#125;</span><br><span class="line">    : U</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>F &amp; string</code>: 等价于如下代码：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &amp; <span class="built_in">string</span> = F <span class="keyword">extends</span> <span class="built_in">string</span> ? F : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p><link-and-solution num="3192"></link-and-solution></p><h4 id="用法-59"><a href="#用法-59" class="headerlink" title="用法"></a>用法</h4><p><code>Reverse</code>是用来实现数组的<code>reverse()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['b', 'a']</span></span><br><span class="line"><span class="keyword">type</span> result = Reverse&lt;[<span class="string">'a'</span>, <span class="string">'b'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-59"><a href="#实现方式-59" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reverse&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [...infer R, infer L]</span><br><span class="line">    ? [L, ...Reverse&lt;R&gt;]</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><h3 id="FlipArguments-反转函数参数类型"><a href="#FlipArguments-反转函数参数类型" class="headerlink" title="FlipArguments(反转函数参数类型)"></a>FlipArguments(反转函数参数类型)</h3><p><link-and-solution num="3196"></link-and-solution></p><p>借助上面的<code>Reverse</code>方法，可以很容易实现函数参数的反转。</p><h4 id="用法-60"><a href="#用法-60" class="headerlink" title="用法"></a>用法</h4><p><code>FlipArguments</code>是用来实现反转函数参数类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：(a: number, b: string) =&gt; string | number</span></span><br><span class="line"><span class="keyword">type</span> result = FlipArguments&lt;<span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-60"><a href="#实现方式-60" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlipArguments&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> (...args: infer A) =&gt; infer R</span><br><span class="line">    ? <span class="function">(<span class="params">...args: Reverse&lt;A&gt;</span>) =&gt;</span> R</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><h3 id="FlattenDepth-数组按深度降维"><a href="#FlattenDepth-数组按深度降维" class="headerlink" title="FlattenDepth(数组按深度降维)"></a>FlattenDepth(数组按深度降维)</h3><p><link-and-solution num="3243"></link-and-solution></p><h4 id="用法-61"><a href="#用法-61" class="headerlink" title="用法"></a>用法</h4><p><code>FlattenDepth</code>是用来按深度进行数组降维的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3, 4, [5]]</span></span><br><span class="line"><span class="keyword">type</span> result = FlattenDepth&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[[<span class="number">5</span>]]]], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-61"><a href="#实现方式-61" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlattenDepth&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">1</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? U[<span class="string">'length'</span>] <span class="keyword">extends</span> D</span><br><span class="line">    ? T</span><br><span class="line">    : F <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? [...FlattenDepth&lt;F, D, [<span class="number">0</span>, ...U]&gt;, ...FlattenDepth&lt;R, D&gt;]</span><br><span class="line">      : [F, ...FlattenDepth&lt;R, D, U&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure><p>代码详解：<code>FlattenDepth</code>的实现思路和<code>Flatten</code>基本一致，区别是按深度降维时需要一个数组去记录降维的次数(深度)。</p><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><link-and-solution num="3326"></link-and-solution></p><h4 id="用法-62"><a href="#用法-62" class="headerlink" title="用法"></a>用法</h4><p><code>BEM</code>是用来将字符串连接成CSS BEM格式的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'btn__primary--small' | 'btn__primary--mini' </span></span><br><span class="line"><span class="keyword">type</span> result = BEM&lt;<span class="string">'btn'</span>, [<span class="string">'primary'</span>], [<span class="string">'small'</span>, <span class="string">'mini'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-62"><a href="#实现方式-62" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArrayToString&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [] ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;T[<span class="built_in">number</span>]&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BEM&lt;</span><br><span class="line">  B <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="built_in">string</span>[],</span><br><span class="line">  M <span class="keyword">extends</span> <span class="built_in">string</span>[]</span><br><span class="line">&gt; = <span class="string">`<span class="subst">$&#123;B&#125;</span><span class="subst">$&#123;ArrayToString&lt;E, <span class="string">'--'</span>&gt;&#125;</span><span class="subst">$&#123;ArrayToString&lt;M, <span class="string">'__'</span>&gt;&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>代码详解：实现<code>BEM</code>的思路并不复杂，只需要记住如下两个知识点：</p><ul><li>判断是一个空数组，可以使用<code>T extends []</code>或者<code>T[&#39;length&#39;] extends 0</code>。</li><li><code>T[number]</code>会自动迭代数组，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果: 'A__B' | 'A__C' | 'A__D'</span></span><br><span class="line"><span class="keyword">type</span> result = <span class="string">`A__<span class="subst">$&#123;[<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>][<span class="built_in">number</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="InOrderTraversal-中序遍历"><a href="#InOrderTraversal-中序遍历" class="headerlink" title="InOrderTraversal(中序遍历)"></a>InOrderTraversal(中序遍历)</h3><p><link-and-solution num="3376"></link-and-solution></p><p><strong>先序遍历</strong>：<code>PreOrderTraversal</code>先访问根节点，然后访问左节点，最后访问右节点。<br><br><strong>中序遍历</strong>：<code>InOrderTraversal</code>先访问左节点，然后访问根节点，最后访问右节点。<br><br><strong>后序遍历</strong>：<code>PostOrderTraversal</code>先访问左节点，然后访问右节点，最后访问根节点。</p><h4 id="用法-63"><a href="#用法-63" class="headerlink" title="用法"></a>用法</h4><p><code>InOrderTraversal</code>是用来实现二叉树中序遍历的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  left: <span class="literal">null</span>,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: <span class="number">3</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果: [1, 3, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = InOrderTraversal&lt;<span class="keyword">typeof</span> tree&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-63"><a href="#实现方式-63" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个二叉树节点</span></span><br><span class="line"><span class="keyword">interface</span> TreeNode &#123;</span><br><span class="line">  val: <span class="built_in">number</span>;</span><br><span class="line">  left: TreeNode | <span class="literal">null</span>;</span><br><span class="line">  right: TreeNode | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PreOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [T[<span class="string">'val'</span>], ...PreOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PreOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 中序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> InOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...InOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, T[<span class="string">'val'</span>], ...InOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="comment">// 后序遍历实现</span></span><br><span class="line"><span class="keyword">type</span> PostOrderTraversal&lt;</span><br><span class="line">  T <span class="keyword">extends</span> TreeNode | <span class="literal">null</span></span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [TreeNode]</span><br><span class="line">  ? [...PostOrderTraversal&lt;T[<span class="string">'left'</span>]&gt;, ...PostOrderTraversal&lt;T[<span class="string">'right'</span>]&gt;, T[<span class="string">'val'</span>]]</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>[T] extends [TreeNode]</code>: 使用此形式而不用<code>T extends TreeNode</code>，这是因为<code>T</code>是一个<code>TreeNode | null</code>，在左侧会进行分布式条件类型，判断两次：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果Tree嵌套比较深的话，ts会报错</span></span><br><span class="line">TreeNode <span class="keyword">extends</span> TreeNode |</span><br><span class="line"><span class="literal">null</span> <span class="keyword">extends</span> TreeNode</span><br></pre></td></tr></table></figure></li><li><p>遍历方式：根据先序遍历<code>PreOrderTraversal</code>、中序遍历<code>InOrderTraversal</code>、后序遍历<code>PostOrderTraversal</code>的定义，只需要在递归的时候处理其访问顺序即可。</p></li></ul><h3 id="FlipObject-对象键值交换"><a href="#FlipObject-对象键值交换" class="headerlink" title="FlipObject(对象键值交换)"></a>FlipObject(对象键值交换)</h3><p><link-and-solution num="4179"></link-and-solution></p><h4 id="用法-64"><a href="#用法-64" class="headerlink" title="用法"></a>用法</h4><p><code>FlipObject</code>是用来将对象的键值交换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; pi: 'a' &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = FlipObject&lt;&#123; a: <span class="string">'pi'</span> &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-64"><a href="#实现方式-64" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> FlipObject&lt;T <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, BasicType&gt;&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;T[P]&#125;</span>`</span>]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fibonacci-斐波那契数列"><a href="#Fibonacci-斐波那契数列" class="headerlink" title="Fibonacci(斐波那契数列)"></a>Fibonacci(斐波那契数列)</h3><p><link-and-solution num="4182"></link-and-solution></p><p><strong>菲波那切数列</strong>：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…</p><h4 id="用法-65"><a href="#用法-65" class="headerlink" title="用法"></a>用法</h4><p><code>Fibonacci</code>是用来实现斐波那契数列的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = Fibonacci&lt;<span class="number">5</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-65"><a href="#实现方式-65" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fibonacci&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>],</span><br><span class="line">  Prev <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Current <span class="keyword">extends</span> <span class="built_in">any</span>[] = [<span class="number">1</span>]</span><br><span class="line">&gt; = Index[<span class="string">'length'</span>] <span class="keyword">extends</span> N</span><br><span class="line">  ? Current[<span class="string">'length'</span>]</span><br><span class="line">  : Fibonacci&lt;N, [...Index, <span class="number">1</span>], Current, [...Prev, ...Current]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Index</code>：标记当前数列是第几项，从1开始。</li><li><code>Prev</code>：存储数列上一次计算的值，从0开始。</li><li><code>Current</code>: 标记当前数列的值，根据数列的特点，第N项的值，等于<code>N - 1</code>项 + <code>N - 2</code>项的值，即：<code>Current = [...Prev, ...Current]</code></li></ul><h3 id="AllCombinations-全排列"><a href="#AllCombinations-全排列" class="headerlink" title="AllCombinations(全排列)"></a>AllCombinations(全排列)</h3><p><link-and-solution num="4260"></link-and-solution></p><h4 id="用法-66"><a href="#用法-66" class="headerlink" title="用法"></a>用法</h4><p><code>AllCombinations</code>是用来列举全部排列组合可能性的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'' | 'A' | 'AB' | 'B' | 'BA'</span></span><br><span class="line"><span class="keyword">type</span> result = AllCombinations&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-66"><a href="#实现方式-66" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">    ? F | StringToUnion&lt;R&gt;</span><br><span class="line">    : never</span><br><span class="line"><span class="keyword">type</span> Combination&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span>,</span><br><span class="line">  K = S</span><br><span class="line">&gt; = [S] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? U</span><br><span class="line">  : K <span class="keyword">extends</span> S</span><br><span class="line">    ? Combination&lt;Exclude&lt;S, K&gt;, U | <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;K&#125;</span>`</span>&gt;</span><br><span class="line">    : U</span><br><span class="line"><span class="keyword">type</span> AllCombinations&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Combination&lt;StringToUnion&lt;S&gt;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>StringToUnion</code>是用来将字符串变成一个联合类型的，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 'A' | 'B'</span></span><br><span class="line"><span class="keyword">type</span> result = StringToUnion&lt;<span class="string">'AB'</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Combination</code>是用来将联合类型进行排列组合的，以以上<code>&#39;A&#39; | &#39;B&#39;</code>这个联合类型为例，步骤如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：从'A' | 'B这个联合类型中排除当前迭代的字符'A'</span></span><br><span class="line">K = <span class="string">'A'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span>  =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'A'</span>&gt;</span><br><span class="line"><span class="comment">// 第一步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'B'</span>, <span class="string">''</span> | <span class="string">'A'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'A'</span>&#125;</span>B`</span> =&gt; <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'AB'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：从'A' | 'B'这个联合类型中排除当前迭代的字符'B'</span></span><br><span class="line">K = <span class="string">'B'</span> S = <span class="string">'A'</span> | <span class="string">'B'</span> =&gt; Exclude&lt;<span class="string">'A'</span> | <span class="string">'B'</span>, <span class="string">'B'</span>&gt;</span><br><span class="line"><span class="comment">// 第二步子递归：</span></span><br><span class="line">Combination&lt;<span class="string">'A'</span>, <span class="string">''</span> | <span class="string">'B'</span>&gt; =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">`<span class="subst">$&#123;<span class="string">''</span> | <span class="string">'B'</span>&#125;</span>A`</span> =&gt; <span class="string">''</span> | <span class="string">'B'</span> | <span class="string">'A'</span> | <span class="string">'BA'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：剔除相同元素</span></span><br><span class="line">result = <span class="string">''</span> | <span class="string">'A'</span> | <span class="string">'AB'</span> | <span class="string">'B'</span> | <span class="string">'BA'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="GreaterThan-大于"><a href="#GreaterThan-大于" class="headerlink" title="GreaterThan(大于)"></a>GreaterThan(大于)</h3><p><link-and-solution num="4425"></link-and-solution></p><h4 id="用法-67"><a href="#用法-67" class="headerlink" title="用法"></a>用法</h4><p><code>GreaterThan&lt;T, N&gt;</code>是来用判断正整数T是否大于正整数N的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = GreaterThan&lt;<span class="number">2</span>, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-67"><a href="#实现方式-67" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果比较的数比较大，会提示：Type instantiation is excessively deep and possibly infinite</span></span><br><span class="line"><span class="keyword">type</span> GreaterThan&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">Number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : N <span class="keyword">extends</span> R[<span class="string">'length'</span>]</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : GreaterThan&lt;T, N, [...R, <span class="number">0</span>]&gt;</span><br></pre></td></tr></table></figure><p>代码详解：使用一个空数组来辅助，每次递归添加一个元素，如果正整数<code>T</code>先等于这个数组的长度，则为<code>false</code>；如果正整数<code>N</code>先等于这个数组的长度，则为<code>true</code>。</p><h3 id="Zip-按位置匹配"><a href="#Zip-按位置匹配" class="headerlink" title="Zip(按位置匹配)"></a>Zip(按位置匹配)</h3><p><link-and-solution num="4471"></link-and-solution></p><h4 id="用法-68"><a href="#用法-68" class="headerlink" title="用法"></a>用法</h4><p><code>Zip</code>是用来将两个元组按照相同索引位置组合成一个新数组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, true], [2, false]]</span></span><br><span class="line"><span class="keyword">type</span> result = Zip&lt;[<span class="number">1</span>, <span class="number">2</span>], [<span class="literal">true</span>, <span class="literal">false</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-68"><a href="#实现方式-68" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zip&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? U <span class="keyword">extends</span> [infer Head, ...infer Tail]</span><br><span class="line">      ? [[First, Head], ...Zip&lt;Rest, Tail&gt;]</span><br><span class="line">      : []</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><h3 id="IsTuple-是否为元组"><a href="#IsTuple-是否为元组" class="headerlink" title="IsTuple(是否为元组)"></a>IsTuple(是否为元组)</h3><p><link-and-solution num="4484"></link-and-solution></p><h4 id="用法-69"><a href="#用法-69" class="headerlink" title="用法"></a>用法</h4><p><code>IsTuple</code>是用来判断是否为一个元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> result = IsTuple&lt;[<span class="built_in">number</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-69"><a href="#实现方式-69" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsTuple&lt;T&gt; =</span><br><span class="line">  [T] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? <span class="literal">false</span></span><br><span class="line">    : T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">      ? <span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码解析：以上代码中，比较关键的代码是<code>number extends T[&#39;length&#39;]</code>，这里不能写成<code>T[&#39;length&#39;] extends number</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1：需要返回false，因为它不定长，违反了元组的定义</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsTuple&lt;<span class="built_in">number</span>[]&gt;</span><br><span class="line"><span class="comment">// case2：需要返回true，因为它定长，只不过长度为0</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsTuple&lt;[]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case1计算逻辑，T['length']返回的是number，不是一个确定的值</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2计算逻辑，T['length']返回的是0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">'length'</span>]</span><br><span class="line">=&gt; <span class="built_in">number</span> <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">=&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="Chunk-lodash分割数组"><a href="#Chunk-lodash分割数组" class="headerlink" title="Chunk(lodash分割数组)"></a>Chunk(lodash分割数组)</h3><p><link-and-solution num="4499"></link-and-solution></p><p><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash Chunk</a>: 将一个数组分割成长度为N的多个小数组。</p><h4 id="用法-70"><a href="#用法-70" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[[1, 2], [3, 4]]</span></span><br><span class="line"><span class="keyword">type</span> result = Chunk&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-70"><a href="#实现方式-70" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chunk&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  Size <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> Size</span><br><span class="line">  ? [R, ...Chunk&lt;T, Size&gt;]</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Chunk&lt;L, Size, [...R, F]&gt;</span><br><span class="line">    : R[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? []</span><br><span class="line">      : [R]</span><br></pre></td></tr></table></figure><p>代码详解：实现<code>Chunk</code>大体思路是：借助一个辅助空数组，在遍历数组时往这个辅助数组中添加元素，一直到等于指定长度，然后进行下一次相同操作。</p><h3 id="Fill-数组fill方法"><a href="#Fill-数组fill方法" class="headerlink" title="Fill(数组fill方法)"></a>Fill(数组fill方法)</h3><p><link-and-solution num="4518"></link-and-solution></p><h4 id="用法-71"><a href="#用法-71" class="headerlink" title="用法"></a>用法</h4><p><code>Fill</code>是用来在一个数组中，用指定元素，替换开始索引和结束索引元素的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-71"><a href="#实现方式-71" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fill&lt;</span><br><span class="line">  T <span class="keyword">extends</span> unknown[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  Start <span class="keyword">extends</span> <span class="built_in">number</span> = <span class="number">0</span>,</span><br><span class="line">  End <span class="keyword">extends</span> <span class="built_in">number</span> = T[<span class="string">'length'</span>],</span><br><span class="line">  Count <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  Flag <span class="keyword">extends</span> <span class="built_in">boolean</span> = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> Start ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = Count[<span class="string">'length'</span>] <span class="keyword">extends</span> End</span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer L]</span><br><span class="line">    ? Flag <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">      ? [F, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>]&gt;]</span><br><span class="line">      : [N, ...Fill&lt;L, N, Start, End, [...Count, <span class="number">0</span>], <span class="literal">true</span>&gt;]</span><br><span class="line">    : T</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Count</code>: 遍历标志位，从数组第一项开始，当等于<code>End</code>时，结束替换。</li><li><code>Flag</code>：遍历标志位，从数组第一项开始，当等于<code>Start</code>是，开始替换。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, true, true]</span></span><br><span class="line"><span class="keyword">type</span> result = Fill&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="number">1</span>, <span class="number">3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次遍历 Count = [], Flag = false, T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 满足Flag extends false条件，Count = [0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次遍历 Count = [0], Flag = true(计算而言)，T = [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0], T = [1, true, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次遍历 Count = [0, 0], Flag = true(主动传递), T =[1, true, 3]</span></span><br><span class="line"><span class="comment">// 不满足Flag extends false条件，开始替换，Count = [0, 0, 0], T = [1, true, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次判断 Count = [0, 0, 0]，长度等于End，结束，T = [1, true, true]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Without-移除"><a href="#Without-移除" class="headerlink" title="Without(移除)"></a>Without(移除)</h3><p><link-and-solution num="5117"></link-and-solution></p><h4 id="用法-72"><a href="#用法-72" class="headerlink" title="用法"></a>用法</h4><p><code>Without</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[3]</span></span><br><span class="line"><span class="keyword">type</span> result = Without&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-72"><a href="#实现方式-72" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToUnion&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T</span><br><span class="line"><span class="keyword">type</span> Without&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  U = ToUnion&lt;F&gt;,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? First <span class="keyword">extends</span> U</span><br><span class="line">      ? Without&lt;Rest, F, U, [...R]&gt;</span><br><span class="line">      : Without&lt;Rest, F, U, [...R, First]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><p>代码详解：因为<code>F</code>支持单数字和数组，所以定义一个<code>ToUion</code>来统一处理成联合类型。随后直接遍历数组，如果当前迭代的元素在联合类型中，则直接跳过进行下一次迭代；否则，把当前迭代元素添加到<code>R</code>辅助数组中。</p><h3 id="Trunc-Math-trunc取整"><a href="#Trunc-Math-trunc取整" class="headerlink" title="Trunc(Math.trunc取整)"></a>Trunc(Math.trunc取整)</h3><p><link-and-solution num="5140"></link-and-solution></p><h4 id="用法-73"><a href="#用法-73" class="headerlink" title="用法"></a>用法</h4><p><code>Trunc</code>是用来实现<code>Math.trunc()</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：100</span></span><br><span class="line"><span class="keyword">type</span> result1 = Trunc&lt;<span class="number">100.32</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：0</span></span><br><span class="line"><span class="keyword">type</span> result2 = Trunc&lt;<span class="number">.3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-73"><a href="#实现方式-73" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trunc&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">&gt; =<span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer L&#125;</span>.<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">  ? L <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">    ? <span class="string">'0'</span></span><br><span class="line">    : L</span><br><span class="line">  : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><h3 id="IndexOf-数组indexOf方法"><a href="#IndexOf-数组indexOf方法" class="headerlink" title="IndexOf(数组indexOf方法)"></a>IndexOf(数组indexOf方法)</h3><p><link-and-solution num="5153"></link-and-solution></p><h4 id="用法-74"><a href="#用法-74" class="headerlink" title="用法"></a>用法</h4><p><code>IndexOf</code>是用来实现数组<code>indexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2</span></span><br><span class="line"><span class="keyword">type</span> result = IndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-74"><a href="#实现方式-74" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U,</span><br><span class="line">  Index <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;U, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Index[<span class="string">'length'</span>]</span><br><span class="line">    : IndexOf&lt;Rest, U, [...Index, <span class="number">0</span>]&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>代码详解：需要借助<code>IsEqual</code>来判断两个值是否相等，原因考虑如下案例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsEqual&lt;<span class="number">1</span>, <span class="built_in">number</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsEqual&lt;<span class="string">'a'</span>, <span class="built_in">string</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="Join-数组join方法"><a href="#Join-数组join方法" class="headerlink" title="Join(数组join方法)"></a>Join(数组join方法)</h3><p><link-and-solution num="5310"></link-and-solution></p><h4 id="用法-75"><a href="#用法-75" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现数组<code>join</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'a-p-p-l-e'</span></span><br><span class="line"><span class="keyword">type</span> result = Join&lt;[<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'p'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>], <span class="string">'-'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-75"><a href="#实现方式-75" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Join&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      : Join&lt;Rest, U, <span class="string">`<span class="subst">$&#123;R <span class="keyword">extends</span> <span class="string">''</span> ? <span class="string">''</span> : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>&#125;</span><span class="subst">$&#123;First&amp;<span class="built_in">string</span>&#125;</span>`</span>&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><h3 id="LastIndexOf-数组lastIndexOf方法"><a href="#LastIndexOf-数组lastIndexOf方法" class="headerlink" title="LastIndexOf(数组lastIndexOf方法)"></a>LastIndexOf(数组lastIndexOf方法)</h3><p><link-and-solution num="5317"></link-and-solution></p><p>借助<code>IndexOf</code>的实现思路，很容易实现<code>lastIndexOf</code>方法。</p><h4 id="用法-76"><a href="#用法-76" class="headerlink" title="用法"></a>用法</h4><p><code>LastIndexOf</code>是用来实现数组<code>lastIndexOf</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：3</span></span><br><span class="line"><span class="keyword">type</span> result = LastIndexOf&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-76"><a href="#实现方式-76" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; = </span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> LastIndexOf&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[], </span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [...infer Rest, infer Last]</span><br><span class="line">  ? IsEqual&lt;Last, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Rest[<span class="string">'length'</span>]</span><br><span class="line">    : LastIndexOf&lt;Rest, U&gt;</span><br><span class="line">  : <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="Unique-数组去重"><a href="#Unique-数组去重" class="headerlink" title="Unique(数组去重)"></a>Unique(数组去重)</h3><p><link-and-solution num="5360"></link-and-solution></p><h4 id="用法-77"><a href="#用法-77" class="headerlink" title="用法"></a>用法</h4><p><code>Unique</code>是用来实现数组去重的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result = Unique&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-77"><a href="#实现方式-77" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>IsEqual</code>和<code>Includes</code>，很容易实现<code>Unique</code>数组去重。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> Includes&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;Last, U&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unique&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Includes&lt;R, First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? Unique&lt;Last, R&gt;</span><br><span class="line">    : Unique&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure></p><h3 id="MapTypes-类型转换"><a href="#MapTypes-类型转换" class="headerlink" title="MapTypes(类型转换)"></a>MapTypes(类型转换)</h3><p><link-and-solution num="5821"></link-and-solution></p><h4 id="用法-78"><a href="#用法-78" class="headerlink" title="用法"></a>用法</h4><p><code>MapTypes</code>是用来根据指定类型进行替换的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：&#123; type: number; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = MapTypes&lt;&#123; <span class="keyword">type</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;, &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-78"><a href="#实现方式-78" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMapType&lt;</span><br><span class="line">  T, </span><br><span class="line">  R,</span><br><span class="line">  Type = R <span class="keyword">extends</span> &#123; mapFrom: T, mapTo: infer To &#125; ? To : never</span><br><span class="line">&gt; = [Type] <span class="keyword">extends</span> [never] ? T : Type</span><br><span class="line"><span class="keyword">type</span> MapTypes&lt;T, R&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: GetMapType&lt;T[P], R&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：在以上的实现中，最核心的代码是获取<code>Type</code>类型。</p><ul><li><code>R extends { mapFrom: T, mapTo: infer To }</code>：这段代码表示，<code>R</code>是不是右边的子类型，我们以以上案例来说明：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当P = 'type'时，</span></span><br><span class="line">T[P] = <span class="built_in">string</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">string</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; To = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; <span class="keyword">type</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当P = 'age'时</span></span><br><span class="line">T[P] = <span class="built_in">number</span>, R = &#123; mapFrom: <span class="built_in">string</span>;mapTo: <span class="built_in">number</span>; &#125;</span><br><span class="line">=&gt; &#123; mapFrom: <span class="built_in">string</span>; mapTo: <span class="built_in">number</span>; &#125; <span class="keyword">extends</span> &#123; mapFrom: <span class="built_in">number</span>, mapTo: infer To &#125;</span><br><span class="line">=&gt; never</span><br><span class="line">=&gt; GetMapType&lt;T[P], R&gt; = <span class="built_in">number</span></span><br><span class="line">=&gt; &#123; age: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ConstructTuple-构造元组"><a href="#ConstructTuple-构造元组" class="headerlink" title="ConstructTuple(构造元组)"></a>ConstructTuple(构造元组)</h3><p><link-and-solution num="7544"></link-and-solution></p><h4 id="用法-79"><a href="#用法-79" class="headerlink" title="用法"></a>用法</h4><p><code>ConstructTuple</code>是用来构造指定长度的元组的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[unknown, unknown]</span></span><br><span class="line"><span class="keyword">type</span> result = ConstructTuple&lt;<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-79"><a href="#实现方式-79" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConstructTuple&lt;</span><br><span class="line">  L <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = R[<span class="string">'length'</span>] <span class="keyword">extends</span> L</span><br><span class="line">  ? R</span><br><span class="line">  : ConstructTuple&lt;L, [...R, unknown]&gt;</span><br></pre></td></tr></table></figure><h3 id="NumberRange-限定范围数字"><a href="#NumberRange-限定范围数字" class="headerlink" title="NumberRange(限定范围数字)"></a>NumberRange(限定范围数字)</h3><p><link-and-solution num="8640"></link-and-solution></p><h4 id="用法-80"><a href="#用法-80" class="headerlink" title="用法"></a>用法</h4><p><code>NumberRange</code>是用来返回指定范围内的数字的，其返回的是一个联合类型，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"><span class="keyword">type</span> result = NumberRange&lt;<span class="number">2</span>, <span class="number">9</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-80"><a href="#实现方式-80" class="headerlink" title="实现方式"></a>实现方式</h4><p>实现思路参考：数组<code>Fill</code>方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberRange&lt;</span><br><span class="line">  L, </span><br><span class="line">  H,</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  F = I[<span class="string">'length'</span>] <span class="keyword">extends</span> L ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&gt; = I[<span class="string">'length'</span>] <span class="keyword">extends</span> H</span><br><span class="line">  ? I[<span class="built_in">number</span>] | H</span><br><span class="line">  : F <span class="keyword">extends</span> <span class="literal">false</span></span><br><span class="line">    ? NumberRange&lt;L, H, [...I, never]&gt;</span><br><span class="line">    : NumberRange&lt;L, H, [...I, I[<span class="string">'length'</span>]], <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Subsequence-元组子序列"><a href="#Subsequence-元组子序列" class="headerlink" title="Subsequence(元组子序列)"></a>Subsequence(元组子序列)</h3><p><link-and-solution num="8987"></link-and-solution></p><h4 id="用法-81"><a href="#用法-81" class="headerlink" title="用法"></a>用法</h4><p><code>Subsequence</code>是用来根据指定数组生成元组子序列的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[] | [1] | [2] | [1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result = Subsequence&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-81"><a href="#实现方式-81" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subsequence&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? Subsequence&lt;Last, R | [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>R | [...R, First]</code>: 在一个数组中，对一个联合类型的数组使用<code>...</code>扩展时，会自动进行元素分发，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：['a', 'b'] | ['a', 'c']</span></span><br><span class="line"><span class="keyword">type</span> result = [<span class="string">'a'</span>, ...([<span class="string">'b'</span>] | [<span class="string">'c'</span>])]</span><br></pre></td></tr></table></figure></li></ul><h3 id="CheckRepeatedChars-是否包含相同字符"><a href="#CheckRepeatedChars-是否包含相同字符" class="headerlink" title="CheckRepeatedChars(是否包含相同字符)"></a>CheckRepeatedChars(是否包含相同字符)</h3><p><link-and-solution num="9142"></link-and-solution></p><h4 id="用法-82"><a href="#用法-82" class="headerlink" title="用法"></a>用法</h4><p><code>CheckRepeatedChars</code>是用来检查字符串中是否存在重复字符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：false </span></span><br><span class="line"><span class="keyword">type</span> result1 = CheckRepeatedChars&lt;<span class="string">'abc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = CheckRepeatedChars&lt;<span class="string">'abb'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-82"><a href="#实现方式-82" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckRepeatedChars&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : CheckRepeatedChars&lt;Last&gt;</span><br><span class="line">  : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>${string}${First}${string}</code>：表示字符串包含<code>First</code>，也可以用<code>infer</code>来代替：<code>${infer Left}${First}${infer Right}</code>。</li></ul><h3 id="FirstUniqueCharIndex-字符串中第一个唯一字符"><a href="#FirstUniqueCharIndex-字符串中第一个唯一字符" class="headerlink" title="FirstUniqueCharIndex(字符串中第一个唯一字符)"></a>FirstUniqueCharIndex(字符串中第一个唯一字符)</h3><p><link-and-solution num="9286"></link-and-solution></p><h4 id="用法-83"><a href="#用法-83" class="headerlink" title="用法"></a>用法</h4><p><code>FirstUniqueCharIndex</code>是用来获取字符串中第一个唯一字符的索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： 0(字符l)</span></span><br><span class="line"><span class="keyword">type</span> result1 = FirstUniqueCharIndex&lt;<span class="string">'leetcode'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result2 = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-83"><a href="#实现方式-83" class="headerlink" title="实现方式"></a>实现方式</h4><p>借助<code>CheckRepeatedChars</code>的实现思路，很容易实现<code>FirstUniqueCharIndex</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FirstUniqueCharIndex&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? <span class="number">-1</span></span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? First <span class="keyword">extends</span> R[<span class="built_in">number</span>]</span><br><span class="line">      ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">      : Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">        ? FirstUniqueCharIndex&lt;Last, [...R, First]&gt;</span><br><span class="line">        : R[<span class="string">'length'</span>]</span><br><span class="line">    : <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>代码详解：此题的实现思路和<code>FirstUniqueCharIndex</code>类似，只是多了一层判断，以上面案例为例：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果： 2(字符v)</span></span><br><span class="line"><span class="keyword">type</span> result = FirstUniqueCharIndex&lt;<span class="string">'loveleetcode'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代时：S = loveleetcode R = [] R[number] = never First = l</span></span><br><span class="line">=&gt; <span class="string">'l'</span> <span class="keyword">extends</span> never 不满足，<span class="string">'oveleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>l<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代时：S = oveleetcode R = ['l'] R[number] = 'l' First = o</span></span><br><span class="line">=&gt; <span class="string">'o'</span> <span class="keyword">extends</span> <span class="string">'l'</span> 不满足，<span class="string">'veleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>o<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代时：S = veleetcode R = ['l', '0'] R[number] = 'l' | 'o' First = v</span></span><br><span class="line">=&gt; <span class="string">'v'</span> <span class="keyword">extends</span> <span class="string">'l'</span> | <span class="string">'o'</span> 不满足，<span class="string">'eleetcode'</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>v<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>不满足</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：R['length']</span></span><br><span class="line">=&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="ParseUrlParams-解析url路径参数"><a href="#ParseUrlParams-解析url路径参数" class="headerlink" title="ParseUrlParams(解析url路径参数)"></a>ParseUrlParams(解析url路径参数)</h3><p><link-and-solution num="9616"></link-and-solution></p><h4 id="用法-84"><a href="#用法-84" class="headerlink" title="用法"></a>用法</h4><p><code>ParseUrlParams</code>是用来解析<code>url</code>上参数名的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'id' | 'user'</span></span><br><span class="line"><span class="keyword">type</span> result = ParseUrlParams&lt;<span class="string">'posts/:id/:user'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-84"><a href="#实现方式-84" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseUrlParams&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>:<span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">  ? Last <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span>/<span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">    ? Left | ParseUrlParams&lt;Right&gt;</span><br><span class="line">    : Last</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure><h3 id="GetMiddleElement-数组中位数"><a href="#GetMiddleElement-数组中位数" class="headerlink" title="GetMiddleElement(数组中位数)"></a>GetMiddleElement(数组中位数)</h3><p><link-and-solution num="9896"></link-and-solution></p><h4 id="用法-85"><a href="#用法-85" class="headerlink" title="用法"></a>用法</h4><p><code>GetMiddleElement</code>是用来取数组中位数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result2 = GetMiddleElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-85"><a href="#实现方式-85" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetMiddleElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Middle, <span class="built_in">any</span>]</span><br><span class="line">    ? GetMiddleElement&lt;Middle&gt;</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>T[&#39;length&#39;] extends 0 | 1 | 2</code>：当数组长度小于等于而时，其中位数就是自身。</li><li><code>T extends [any, ...infer Middle, any]</code>: 当长度大于2时，每次迭代去掉首、尾元素，直至数组长度小于等于2，返回。</li></ul><h3 id="FindOnlyElements-数组只出现一次的元素"><a href="#FindOnlyElements-数组只出现一次的元素" class="headerlink" title="FindOnlyElements(数组只出现一次的元素)"></a>FindOnlyElements(数组只出现一次的元素)</h3><p><link-and-solution num="9898"></link-and-solution></p><h4 id="用法-86"><a href="#用法-86" class="headerlink" title="用法"></a>用法</h4><p><code>FindOnlyElements</code>是用来获取数组中只出现一次的元素，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： [1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2： [1]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindOnlyElements&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-86"><a href="#实现方式-86" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindOnlyElements&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> [...U, ...Last][<span class="built_in">number</span>]</span><br><span class="line">    ? FindOnlyElements&lt;Last, [...U, First], R&gt;</span><br><span class="line">    : FindOnlyElements&lt;Last, [...U, First], [...R, First]&gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><h3 id="CountArrayElement-计数数组中元素出现的次数"><a href="#CountArrayElement-计数数组中元素出现的次数" class="headerlink" title="CountArrayElement(计数数组中元素出现的次数)"></a>CountArrayElement(计数数组中元素出现的次数)</h3><p><link-and-solution num="9989"></link-and-solution></p><h4 id="用法-87"><a href="#用法-87" class="headerlink" title="用法"></a>用法</h4><p><code>CountArrayElement</code>是用来实现计算数组中元素出现次数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1: &#123; 1: 1, 2: 1, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result1 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="comment">// 结果2: &#123; 1: 2, 2: 2, 3: 1 &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = CountArrayElement&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-87"><a href="#实现方式-87" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Last]</span><br><span class="line">  ? [First] <span class="keyword">extends</span> [never]</span><br><span class="line">    ? Flatten&lt;Last, R&gt; </span><br><span class="line">    : First <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">      ? Flatten&lt;Last, [...R, ...Flatten&lt;First&gt;]&gt;</span><br><span class="line">      : Flatten&lt;Last, [...R, First]&gt;</span><br><span class="line">  : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjectCount&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">any</span>[]&gt; = &#123;&#125;</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>, ...infer Last]</span><br><span class="line">  ? First <span class="keyword">extends</span> keyof R</span><br><span class="line">    ? ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [...R[First], <span class="number">0</span>]&gt;&gt;</span><br><span class="line">    : ObjectCount&lt;Last, Omit&lt;R, First&gt; &amp; Record&lt;First, [<span class="number">0</span>]&gt;&gt;</span><br><span class="line">  : &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof R]: R[P][<span class="string">'length'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountArrayElement&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = ObjectCount&lt;Flatten&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Flatten</code>：实现<code>Flatten</code>，用来处理传递多维数组的情况，例如：<code>CountArrayElement&lt;[1, [1, 2], 3, [4, [5]]]&gt;</code></li><li><code>First extends keyof R</code>: 如果当前数组的遍历项是<code>R</code>对象中的一个键，则表明需要计数加一；如果不是，则代表是新项，需要计数为1；</li><li><code>[P in keyof R]: R[P][&#39;length&#39;]</code>: 因为最后结果需要返回数组，而非数组，所以迭代<code>R</code>对象，返回其每个属性的数组长度即可。</li></ul><h3 id="Integer-数字整数"><a href="#Integer-数字整数" class="headerlink" title="Integer(数字整数)"></a>Integer(数字整数)</h3><p><link-and-solution num="10969"></link-and-solution></p><h4 id="用法-88"><a href="#用法-88" class="headerlink" title="用法"></a>用法</h4><p><code>Integer</code>是用来返回数字的整数部分的，如果传入的数子包含小数，则返回<code>never</code>，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：1</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = Integer&lt;<span class="number">1.1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-88"><a href="#实现方式-88" class="headerlink" title="实现方式"></a>实现方式</h4><p>根据<code>JavaScript</code>中<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">BigInt</a>的用法，其不能包含小数。所以实现方式如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;bigint&#125;</span>`</span> ? T : never</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>${T}</code> extends <code>${bigint}</code>：这里转成字符串形式比较，不能直接比较，因为<code>number</code>和<code>bigint</code>是两个不同的类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：都是false</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">number</span> <span class="keyword">extends</span> bigint ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> result2 = bigint <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ToPrimitive-转化基本类型"><a href="#ToPrimitive-转化基本类型" class="headerlink" title="ToPrimitive(转化基本类型)"></a>ToPrimitive(转化基本类型)</h3><p><link-and-solution num="16259"></link-and-solution></p><h4 id="用法-89"><a href="#用法-89" class="headerlink" title="用法"></a>用法</h4><p><code>ToPrimitive</code>是用来返回一个对象的类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonInfo = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span></span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">  married: <span class="literal">false</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="string">'123456'</span></span><br><span class="line">    phone: <span class="string">'13111111111'</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="string">'sing'</span>, <span class="string">'dance'</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="string">'test'</span>]</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  married: <span class="built_in">boolean</span></span><br><span class="line">  addr: &#123;</span><br><span class="line">    home: <span class="built_in">string</span></span><br><span class="line">    phone: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  hobbies: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line">  readonlyArr: readonly [<span class="built_in">string</span>]</span><br><span class="line">  fn: <span class="built_in">Function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = ToPrimitive&lt;PersonInfo&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-89"><a href="#实现方式-89" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToPrimitive&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> object</span><br><span class="line">  ? T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">    ? <span class="built_in">Function</span></span><br><span class="line">    : &#123; [P <span class="keyword">in</span> keyof T]: ToPrimitive&lt;T[P]&gt; &#125;</span><br><span class="line">  : T <span class="keyword">extends</span> &#123; valueOf: <span class="function"><span class="params">()</span> =&gt;</span> infer R &#125; ? R : T</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>对于函数来说：当满足<code>T extends (...args: any[]) =&gt; any</code>条件时，直接返回<code>Function</code>。</li><li>对于嵌套对象来说，递归调用<code>ToPrimitive</code>即可。</li><li>对于普通类型来说，判断其是否满足<code>T extends { valueOf: () =&gt; infer R }</code>，是则返回其类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts中的valueOf是js中的valueOf一样</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(num.valueOf()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="DeepMutable-深度Mutable"><a href="#DeepMutable-深度Mutable" class="headerlink" title="DeepMutable(深度Mutable)"></a>DeepMutable(深度Mutable)</h3><p><link-and-solution num="17973"></link-and-solution></p><h4 id="用法-90"><a href="#用法-90" class="headerlink" title="用法"></a>用法</h4><p><code>DeepMutable</code>是用来深度移除属性<code>readonly</code>修饰符的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Test &#123;</span><br><span class="line">  readonly title: <span class="built_in">string</span></span><br><span class="line">  readonly description: <span class="built_in">string</span></span><br><span class="line">  readonly completed: <span class="built_in">boolean</span></span><br><span class="line">  readonly meta: &#123;</span><br><span class="line">    readonly author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Expected &#123;</span><br><span class="line">  title: <span class="built_in">string</span></span><br><span class="line">  description: <span class="built_in">string</span></span><br><span class="line">  completed: <span class="built_in">boolean</span></span><br><span class="line">  meta: &#123;</span><br><span class="line">    author: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = DeepMutable&lt;Test&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-90"><a href="#实现方式-90" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepMutable&lt;</span><br><span class="line">  T</span><br><span class="line">&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; - readonly [P <span class="keyword">in</span> keyof T]: DeepMutable&lt;T[P]&gt; &#125;</span><br></pre></td></tr></table></figure><h3 id="AllMatch-数组元素是否与给定元素完全相同"><a href="#AllMatch-数组元素是否与给定元素完全相同" class="headerlink" title="AllMatch(数组元素是否与给定元素完全相同)"></a>AllMatch(数组元素是否与给定元素完全相同)</h3><p><link-and-solution num="18142"></link-and-solution></p><h4 id="用法-91"><a href="#用法-91" class="headerlink" title="用法"></a>用法</h4><p><code>AllMatch</code>是用来判断，数组元素是否与给定元素完全相同的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = AllMatch&lt;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-91"><a href="#实现方式-91" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑边界情况，简易实现方法</span></span><br><span class="line"><span class="keyword">type</span> errTest1 = AllMatch&lt;[<span class="built_in">any</span>], unknown&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest2 = AllMatch&lt;[unknown], <span class="built_in">any</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> errTest3 = AllMatch&lt;[<span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T[<span class="built_in">number</span>] <span class="keyword">extends</span> U</span><br><span class="line">? <span class="literal">true</span></span><br><span class="line">: <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑边界情况：完整实现</span></span><br><span class="line"><span class="keyword">type</span> IsEqual&lt;X, Y&gt; =</span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> X ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">  (&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T <span class="keyword">extends</span> Y ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AllMatch&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  U</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? IsEqual&lt;First, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? AllMatch&lt;Rest, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  : <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Filter-数组过滤"><a href="#Filter-数组过滤" class="headerlink" title="Filter(数组过滤)"></a>Filter(数组过滤)</h3><p><link-and-solution num="18220"></link-and-solution></p><h4 id="用法-92"><a href="#用法-92" class="headerlink" title="用法"></a>用法</h4><p><code>Filter</code>是用来实现数组过滤方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[2]</span></span><br><span class="line"><span class="keyword">type</span> result1 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[1, 2]</span></span><br><span class="line"><span class="keyword">type</span> result2 = Filter&lt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span> | <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-92"><a href="#实现方式-92" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Filter&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  P</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> P</span><br><span class="line">    ? [First, ...Filter&lt;Rest, P&gt;]</span><br><span class="line">    : Filter&lt;Rest, P&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><h3 id="FindAllIndex-查找数组中给定元素所有索引"><a href="#FindAllIndex-查找数组中给定元素所有索引" class="headerlink" title="FindAllIndex(查找数组中给定元素所有索引)"></a>FindAllIndex(查找数组中给定元素所有索引)</h3><p><link-and-solution num="21104"></link-and-solution></p><h4 id="用法-93"><a href="#用法-93" class="headerlink" title="用法"></a>用法</h4><p><code>FindAllIndex</code>是用来返回字符串中所有匹配索引的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：[11]</span></span><br><span class="line"><span class="keyword">type</span> result1 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：[2, 13]</span></span><br><span class="line"><span class="keyword">type</span> result2 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">'pe'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：[]</span></span><br><span class="line"><span class="keyword">type</span> result3 = FindAllIndex&lt;<span class="string">'TypeScript type challenges'</span>, <span class="string">''</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-93"><a href="#实现方式-93" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FindAll&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  I <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">  ? []</span><br><span class="line">  : T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span><span class="subst">$&#123;infer Last&#125;</span>`</span></span><br><span class="line">    ? T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line">      ? FindAll&lt;Last, P, [...R, I[<span class="string">'length'</span>]], [...I, <span class="number">0</span>]&gt;</span><br><span class="line">      : FindAll&lt;Last, P, R, [...I, <span class="number">0</span>]&gt;</span><br><span class="line">    : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>I extends any[] = []</code>: 设置索引，字符串每迭代移除，<code>I</code>数组长度增加一。</li><li><code>T extends ${P}${string}</code>: 当满足条件时，向结果数组<code>R</code>中添加当前索引即可。</li></ul><h3 id="CombKeys-组合键"><a href="#CombKeys-组合键" class="headerlink" title="CombKeys(组合键)"></a>CombKeys(组合键)</h3><p><link-and-solution num="21106"></link-and-solution></p><h4 id="用法-94"><a href="#用法-94" class="headerlink" title="用法"></a>用法</h4><p><code>CombKeys</code>是用来实现组合键的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'cmd ctrl' | 'cmd opt' | 'cmd fn' | 'ctrl opt' | 'ctrl fn' | 'opt fn'</span></span><br><span class="line"><span class="keyword">type</span> result = CombKeys&lt;[<span class="string">'cmd'</span>, <span class="string">'ctrl'</span>, <span class="string">'opt'</span>, <span class="string">'fn'</span>]&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-94"><a href="#实现方式-94" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CombKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First <span class="keyword">extends</span> <span class="built_in">string</span>, ...infer Last <span class="keyword">extends</span> <span class="built_in">string</span>[]]</span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;First&#125;</span> <span class="subst">$&#123;Last[<span class="built_in">number</span>]&#125;</span>`</span> | CombKeys&lt;Last&gt;</span><br><span class="line">  : never</span><br></pre></td></tr></table></figure><h3 id="ReplaceFirst-替换元组中第一个匹配项"><a href="#ReplaceFirst-替换元组中第一个匹配项" class="headerlink" title="ReplaceFirst(替换元组中第一个匹配项)"></a>ReplaceFirst(替换元组中第一个匹配项)</h3><p><link-and-solution num="25170"></link-and-solution></p><h4 id="用法-95"><a href="#用法-95" class="headerlink" title="用法"></a>用法</h4><p><code>ReplaceFirst</code>是用来替换元组中第一个匹配项，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[1, 2, 4]</span></span><br><span class="line"><span class="keyword">type</span> result = ReplaceFirst&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-95"><a href="#实现方式-95" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplaceFirst&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly unknown[],</span><br><span class="line">  From,</span><br><span class="line">  To</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">  ? First <span class="keyword">extends</span> From</span><br><span class="line">    ? [To, ...Rest]</span><br><span class="line">    : [First, ...ReplaceFirst&lt;Rest, From, To&gt;]</span><br><span class="line">  : T</span><br></pre></td></tr></table></figure><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><h3 id="SimpleVue-简单Vue类型"><a href="#SimpleVue-简单Vue类型" class="headerlink" title="SimpleVue(简单Vue类型)"></a>SimpleVue(简单Vue类型)</h3><p><link-and-solution num="6"></link-and-solution></p><h4 id="用法-96"><a href="#用法-96" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-96"><a href="#实现方式-96" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Currying-柯里化"><a href="#Currying-柯里化" class="headerlink" title="Currying(柯里化)"></a>Currying(柯里化)</h3><p><link-and-solution num="17"></link-and-solution></p><p>在<code>JavaScript</code>中<code>Currying</code>是用来实现函数柯里化的，其用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> three = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = Currying(add)</span><br><span class="line"><span class="keyword">const</span> five = curriedAdd(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h4 id="用法-97"><a href="#用法-97" class="headerlink" title="用法"></a>用法</h4><p><code>Currying</code>是用来实现<code>JavaScript</code>中的柯里化的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = Currying(<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span>, c: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 结果：(a: string) =&gt; (a: number) =&gt; (a: boolean) =&gt; true</span></span><br><span class="line"><span class="keyword">type</span> funcType = <span class="keyword">typeof</span> func</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-97"><a href="#实现方式-97" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CurryFunction&lt;</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">  ? <span class="function"><span class="params">()</span> =&gt;</span> R</span><br><span class="line">  : P <span class="keyword">extends</span> [infer First, ...infer Rest]</span><br><span class="line">    ? Rest[<span class="string">'length'</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">      ? <span class="function">(<span class="params">a: First</span>) =&gt;</span> R</span><br><span class="line">      : <span class="function">(<span class="params">a: First</span>) =&gt;</span> CurryFunction&lt;Rest, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">Currying</span>&lt;<span class="title">F</span>&gt;(<span class="params">fn: F</span>):</span></span><br><span class="line"><span class="function">  <span class="title">F</span> <span class="title">extends</span> (<span class="params">...args: infer P</span>) =&gt; <span class="title">infer</span> <span class="title">R</span></span></span><br><span class="line"><span class="function">  ? <span class="title">CurryFunction</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="function">  : <span class="title">never</span></span></span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>P</code>：<code>P</code>为调用<code>Currying</code>函数时传递函数参数的参数数组，以上面为例，其值为：<code>[number, string, boolean]</code>。</li><li><code>P extends [infer First, ...infer Rest]</code>: 遍历参数列表，依次返回一个函数即可。</li></ul><h3 id="UnionToIntersection-元组取交集"><a href="#UnionToIntersection-元组取交集" class="headerlink" title="UnionToIntersection(元组取交集)"></a>UnionToIntersection(元组取交集)</h3><p><link-and-solution num="55"></link-and-solution></p><p>在实现<code>UnionToIntersection</code>之前，我们先来回顾一下<code>TS</code>中<code>&amp;</code>符号的作用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="number">1</span> &amp; <span class="string">'foo'</span> &amp; <span class="literal">true</span></span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; &amp; &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = <span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) &amp; (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)</span></span><br></pre></td></tr></table></figure></p><p>案例解析：</p><ul><li>案例一：因为<code>1</code>、<code>foo</code>以及<code>true</code>，没有交集部分，所以这里结果为<code>never</code>。</li><li>案例二：对于<code>a</code>和<code>c</code>属性而言，它们只存在于自身类型，所以交集部分是自身；对于<code>b</code>属性而言，它在两个类型中都存在，且其属性的类型存在交集部分，既：<code>number</code>。</li><li>案例三：对于函数的交叉类型，我们从函数参数、函数返回值这两个部分来说明。对于函数参数而言，取其联合类型；对于函数返回值而言，取其交叉类型。</li></ul><p>从以上几个案例中可以看出，<code>TS</code>中的<code>&amp;</code>符号是取交集的意思，也叫<strong>交叉类型</strong>。</p><h4 id="用法-98"><a href="#用法-98" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToIntersection</code>所做的事情和<code>&amp;</code>符号是一样的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToIntersection&lt;<span class="number">1</span> | <span class="string">'foo'</span> | <span class="literal">true</span>&gt;</span><br><span class="line"><span class="comment">// 结果：&#123; a: number; b: number; c: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToIntersection&lt;&#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; &#125; | &#123; b: <span class="built_in">string</span> | <span class="built_in">number</span>; c: <span class="built_in">boolean</span>; &#125;&gt;</span><br><span class="line"><span class="comment">// 结果：(a: boolean | number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToIntersection&lt;<span class="function">(<span class="params">(<span class="params">a: <span class="built_in">boolean</span></span>) =&gt; <span class="built_in">string</span> | <span class="built_in">number</span></span>) | (<span class="params">(<span class="params">a: <span class="built_in">number</span></span>) =&gt; <span class="built_in">string</span></span>)&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-98"><a href="#实现方式-98" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>U extends any ? X : Y</code>： 这里把<code>U</code>类型处理成<code>(x: U) =&gt; any</code>的函数类型。</li><li><code>T extends (x: infer V) =&gt; any ? V : never</code>：这里的<code>T</code>就是上一步的函数类型，如果<code>extends</code>成立，则返回<code>V</code>，此时的<code>V</code>必然满足<code>U &amp; V</code>。</li></ul><h3 id="RequiredKeys-所有必填字段"><a href="#RequiredKeys-所有必填字段" class="headerlink" title="RequiredKeys(所有必填字段)"></a>RequiredKeys(所有必填字段)</h3><p><link-and-solution num="89"></link-and-solution></p><h4 id="用法-99"><a href="#用法-99" class="headerlink" title="用法"></a>用法</h4><p><code>RequiredKeys</code>是用来返回一个类型中所有必填字段，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'name' | 'age'</span></span><br><span class="line"><span class="keyword">type</span> result = RequiredKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-99"><a href="#实现方式-99" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequiredKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? never : P)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>{} extends Pick&lt;T, P&gt; ? never : P</code>：是用来判断当前遍历键是否可选键的。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> result = &#123;&#125; <span class="keyword">extends</span> &#123;&#125; | &#123; sex: <span class="literal">undefined</span> &#125; ? never : <span class="string">'sex'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="GetRequired-必填字段组成的类型"><a href="#GetRequired-必填字段组成的类型" class="headerlink" title="GetRequired(必填字段组成的类型)"></a>GetRequired(必填字段组成的类型)</h3><p><link-and-solution num="57"></link-and-solution></p><h4 id="用法-100"><a href="#用法-100" class="headerlink" title="用法"></a>用法</h4><p><code>GetRequired</code>是用来取一个类型中那些由必填字段组成的一个新类型的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">  sex: <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; age: number; sex: undefined; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetRequired&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-100"><a href="#实现方式-100" class="headerlink" title="实现方式"></a>实现方式</h4><p>按照<code>RequiredKeys</code>的实现思路，能够很容易的实现<code>GetRequired</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? P : never)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码详解：</p><ul><li><code>T[P] extends Required&lt;T&gt;[P] ? P : never</code>：用来判断当前遍历键的类型是否一致，一致则是必填类型。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P为name时</span></span><br><span class="line"><span class="keyword">type</span> result1 = <span class="built_in">string</span> | <span class="literal">undefined</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">'name'</span> : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// P为age时</span></span><br><span class="line"><span class="keyword">type</span> result2 = <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'age'</span> : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="OptionalKeys-所有可选字段"><a href="#OptionalKeys-所有可选字段" class="headerlink" title="OptionalKeys(所有可选字段)"></a>OptionalKeys(所有可选字段)</h3><p><link-and-solution num="90"></link-and-solution></p><p><code>OptionalKeys</code>和<code>RequiredKeys</code>所做的事情相反，其获取的是所有可选字段。</p><h4 id="用法-101"><a href="#用法-101" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：'sex' | 'address'</span></span><br><span class="line"><span class="keyword">type</span> result = OptionalKeys&lt;Person&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-101"><a href="#实现方式-101" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionalKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (&#123;&#125; <span class="keyword">extends</span> Pick&lt;T, P&gt; ? P : never)]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：从上面代码中可以看出，它和<code>RequiredKeys</code>实现思路是一样的，区别只是在<code>extends</code>关键词后面的处理不同。</p><h3 id="GetOptional-可选字段组成的类型"><a href="#GetOptional-可选字段组成的类型" class="headerlink" title="GetOptional(可选字段组成的类型)"></a>GetOptional(可选字段组成的类型)</h3><p><link-and-solution num="59"></link-and-solution></p><h4 id="用法-102"><a href="#用法-102" class="headerlink" title="用法"></a>用法</h4><p>按照<code>OptionalKeys</code>的实现思路，能够很容易的实现<code>GetOptional</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="literal">undefined</span>;</span><br><span class="line">  address?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：&#123; sex?: undefined; address?: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result = GetOptional&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-102"><a href="#实现方式-102" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetOptional&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? never : P)]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CapitalizeWords-所有单词首字母大写"><a href="#CapitalizeWords-所有单词首字母大写" class="headerlink" title="CapitalizeWords(所有单词首字母大写)"></a>CapitalizeWords(所有单词首字母大写)</h3><p><link-and-solution num="112"></link-and-solution></p><h4 id="用法-103"><a href="#用法-103" class="headerlink" title="用法"></a>用法</h4><p><code>CapitalizeWords</code>是用来把一个字符串中所有单词，变为大写字母的，其中这个字符串以固定的分隔符分割，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'Foobar'</span></span><br><span class="line"><span class="keyword">type</span> t1 = CapitalizeWords&lt;<span class="string">'foobar'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：'Foo Bar.Hello,World'</span></span><br><span class="line"><span class="keyword">type</span> t2 = CapitalizeWords&lt;<span class="string">'foo bar.hello,world'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-103"><a href="#实现方式-103" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CapitalizeWords&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Uppercase&lt;First&gt; <span class="keyword">extends</span> Lowercase&lt;First&gt;</span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;Rest&gt;&#125;</span>`</span></span><br><span class="line">    : CapitalizeWords&lt;Rest, <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span>&gt;</span><br><span class="line">  : Capitalize&lt;R&gt;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>Uppercase&lt;First&gt; extends Lowercase&lt;First&gt;</code>：为了找到连串的大写字符串，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S = foo bar.hello,world</span></span><br><span class="line">R = <span class="string">'foo'</span> First = <span class="string">' '</span> Rest = <span class="string">'bar.hello,world'</span></span><br><span class="line">=&gt; <span class="string">`<span class="subst">$&#123;Capitalize&lt;<span class="string">`foo `</span>&gt;&#125;</span><span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&gt;&#125;</span>`</span></span><br><span class="line">=&gt; <span class="string">`Foo <span class="subst">$&#123;CapitalizeWords&lt;<span class="string">'bar.hello,world'</span>&#125;</span>`</span></span><br><span class="line">=&gt; ...</span><br><span class="line">=&gt; <span class="string">'Foo Bar.Hello,World'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CamelCase-下划线字符串转小驼峰"><a href="#CamelCase-下划线字符串转小驼峰" class="headerlink" title="CamelCase(下划线字符串转小驼峰)"></a>CamelCase(下划线字符串转小驼峰)</h3><p><link-and-solution num="114"></link-and-solution></p><h4 id="用法-104"><a href="#用法-104" class="headerlink" title="用法"></a>用法</h4><p>与<strong>中级</strong>章节实现不同，此章节中<code>CamelCase</code>是用来将下划线字符串转小驼峰的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'fooBarHelloWorld'</span></span><br><span class="line"><span class="keyword">type</span> result = CamelCase&lt;<span class="string">'foo_bar_hello_world'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-104"><a href="#实现方式-104" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsLetter&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = Uppercase&lt;S&gt; <span class="keyword">extends</span> Lowercase&lt;S&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> CamelCase&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? CamelCase&lt;</span><br><span class="line">      Rest,</span><br><span class="line">      IsLetter&lt;First&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">      ? R <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer P&#125;</span>_`</span></span><br><span class="line">        ? <span class="string">`<span class="subst">$&#123;P&#125;</span><span class="subst">$&#123;Uppercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">        : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;Lowercase&lt;First&gt;&#125;</span>`</span></span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;R&#125;</span><span class="subst">$&#123;First&#125;</span>`</span></span><br><span class="line">    &gt;</span><br><span class="line">  : R</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><p><code>IsLetter</code>: 用来判断是否为字母的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result1 = IsLetter&lt;<span class="string">'$'</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsLetter&lt;<span class="string">'A'</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>IsLetter&lt;L&gt; extends true</code>: 如果是字母的话，则根据是否以下划线结尾，如果是，则只需要紧邻下划线的字母<code>L</code>大写即可，否小写。</p></li></ul><h3 id="ParsePrintFormat-获取字符串格式化参数"><a href="#ParsePrintFormat-获取字符串格式化参数" class="headerlink" title="ParsePrintFormat(获取字符串格式化参数)"></a>ParsePrintFormat(获取字符串格式化参数)</h3><p><link-and-solution num="147"></link-and-solution></p><h4 id="用法-105"><a href="#用法-105" class="headerlink" title="用法"></a>用法</h4><p><code>ParsePrintFormat</code>是用来获取字符串格式化参数的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数映射表</span></span><br><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['string', 'dec']</span></span><br><span class="line"><span class="keyword">type</span> result = ParsePrintFormat&lt;<span class="string">'Hello %s: score is %d'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-105"><a href="#实现方式-105" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ControlMap = &#123;</span><br><span class="line">  <span class="string">'c'</span>: <span class="string">'char'</span>,</span><br><span class="line">  <span class="string">'s'</span>: <span class="string">'string'</span>,</span><br><span class="line">  <span class="string">'d'</span>: <span class="string">'dec'</span>,</span><br><span class="line">  <span class="string">'o'</span>: <span class="string">'oct'</span>,</span><br><span class="line">  <span class="string">'h'</span>: <span class="string">'hex'</span>,</span><br><span class="line">  <span class="string">'f'</span>: <span class="string">'float'</span>,</span><br><span class="line">  <span class="string">'p'</span>: <span class="string">'pointer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// way1: 借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Char <span class="keyword">extends</span> keyof ControlMap</span><br><span class="line">      ? ParsePrintFormat&lt;S2, [...R, ControlMap[Char]]&gt;</span><br><span class="line">      : ParsePrintFormat&lt;S2, R&gt;</span><br><span class="line">    : R</span><br><span class="line"></span><br><span class="line"><span class="comment">// way2: 不借助辅助数组</span></span><br><span class="line"><span class="keyword">type</span> ParsePrintFormat&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>%<span class="subst">$&#123;infer Char&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? Char <span class="keyword">extends</span> keyof ControlsMap</span><br><span class="line">    ? [ControlsMap[Char], ...ParsePrintFormat&lt;Rest&gt;]</span><br><span class="line">    : ParsePrintFormat&lt;Rest&gt;</span><br><span class="line">  : []</span><br></pre></td></tr></table></figure><p>代码详解：在以上实现方法中，借用了辅助数组的思想，拿上面案例来说，具体迭代分析如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">S满足条件 R = [] S1 = <span class="string">'Hello '</span> Char = <span class="string">'s'</span> S2 = <span class="string">': score is %d'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">S满足条件 R = [<span class="string">'string'</span>]  S1 = <span class="string">': score is '</span> Char = <span class="string">'d'</span> S2 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次迭代</span></span><br><span class="line">S不满足条件 R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">result = R = [<span class="string">'string'</span>, <span class="string">'dec'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="VueBasicProps-Vue的Props类型"><a href="#VueBasicProps-Vue的Props类型" class="headerlink" title="VueBasicProps(Vue的Props类型)"></a>VueBasicProps(Vue的Props类型)</h3><p><link-and-solution num="213"></link-and-solution></p><h4 id="用法-106"><a href="#用法-106" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-106"><a href="#实现方式-106" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsAny和NotAny"><a href="#IsAny和NotAny" class="headerlink" title="IsAny和NotAny"></a>IsAny和NotAny</h3><p><link-and-solution num="223"></link-and-solution></p><h4 id="用法-107"><a href="#用法-107" class="headerlink" title="用法"></a>用法</h4><p><code>IsAny</code>是用来判断一个类型是否为<code>any</code>的，<code>NotAny</code>和它做的事情相反。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = IsAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t2 = IsAny&lt;never&gt;     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> t3 = IsAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t4 = NotAny&lt;<span class="literal">undefined</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t5 = NotAny&lt;never&gt;     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> t6 = NotAny&lt;<span class="built_in">any</span>&gt;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h4 id="实现方式-107"><a href="#实现方式-107" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsAny&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> (<span class="number">1</span> &amp; T) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> NotAny&lt;T&gt; = <span class="literal">true</span> <span class="keyword">extends</span> IsAny&lt;T&gt; ? <span class="literal">false</span> : <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码详解：<code>1 &amp; T</code>的结果只能是：<code>1</code>、<code>never</code>或者<code>any</code>。当使用<code>0 extends</code>这三个结果的时候，只有<code>any</code>判断为真。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t1 = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t2 = <span class="number">0</span> <span class="keyword">extends</span> never ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 结果：true</span></span><br><span class="line"><span class="keyword">type</span> t3 = <span class="number">0</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="Get-字符串路径取值"><a href="#Get-字符串路径取值" class="headerlink" title="Get(字符串路径取值)"></a>Get(字符串路径取值)</h3><p><link-and-solution num="270"></link-and-solution></p><h4 id="用法-108"><a href="#用法-108" class="headerlink" title="用法"></a>用法</h4><p><code>Get</code>是用来进行字符串路径取值的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      value: <span class="string">'foobar'</span>,</span><br><span class="line">      count: <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    include: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'foo.baz'</span>: <span class="literal">false</span></span><br><span class="line">  hello: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：world</span></span><br><span class="line"><span class="keyword">type</span> t1 = Get&lt;Data, <span class="string">'hello'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：foobar</span></span><br><span class="line"><span class="keyword">type</span> t2 = Get&lt;Data, <span class="string">'foo.bar.value'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line"><span class="keyword">type</span> t3 = Get&lt;Data, <span class="string">'foo.baz'</span>&gt;</span><br><span class="line"><span class="comment">// 结果：never</span></span><br><span class="line"><span class="keyword">type</span> t4 = Get&lt;Data, <span class="string">'no.exits'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-108"><a href="#实现方式-108" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Get&lt;</span><br><span class="line">  T,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = K <span class="keyword">extends</span> keyof T</span><br><span class="line">  ? T[K]</span><br><span class="line">  : K <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line">    : T[K &amp; keyof T]</span><br></pre></td></tr></table></figure><p>代码详解：对于<code>Get</code>的实现，主要分为两部分：含有<code>.</code>符号的字符串和不含<code>.</code>符号的字符串。</p><ul><li><p>含有<code>.</code>符号的字符串：对于这种情况，我们先判断<code>.</code>符号左侧部分是否满足为<code>T</code>类型的某个<code>key</code>，如果满足，则递归调用<code>Get</code>；如果不满足，则直接返回<code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1如果是T的属性键，则返回S1；如果不是，则返回never</span></span><br><span class="line">Get&lt;T[S1 &amp; keyof T], S2&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S1 <span class="keyword">extends</span> keyof T ? Get&lt;T[S1], S2&gt; : never</span><br></pre></td></tr></table></figure></li><li><p>不含有<code>.</code>符号的字符串：对于这种情况，我们只需要判断它是否为<code>T</code>类型中的某个<code>key</code>，如果是，则直接取值；如果不是，则返回<code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K如果是T的属性键，则返回K；如果不是，则返回never</span></span><br><span class="line">T[K &amp; keyof T]</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">S <span class="keyword">extends</span> keyof T ? T[S] : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="StringToNumber-字符串数字转数字"><a href="#StringToNumber-字符串数字转数字" class="headerlink" title="StringToNumber(字符串数字转数字)"></a>StringToNumber(字符串数字转数字)</h3><p><link-and-solution num="300"></link-and-solution></p><h4 id="用法-109"><a href="#用法-109" class="headerlink" title="用法"></a>用法</h4><p><code>StringToNumber</code>是用来将字符串形式的数字转换成真正数字类型数字的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：123</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-109"><a href="#实现方式-109" class="headerlink" title="实现方式"></a>实现方式</h4><p>在<code>JavaScript</code>中，我们可以很方便的调用<code>Number()</code>方法或者<code>parseInt()</code>方法来将字符串类型的数字，转换成数字类型的数字。但在<code>TS</code>中，并没有这样的方法，需要我们来手动实现。</p><p><code>StringToNumber</code>的实现并不容易理解，我们需要将其进行拆分，一步步来完善，其实现思路如下：</p><ul><li><p>第一步：可以很容易获取字符串<code>&#39;123&#39;</code>中每一位字符，我们将其存储在辅助数组<code>T</code>中，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? StringToNumber&lt;S2, [...T, S1]&gt;</span><br><span class="line">    : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：['1', '2', '3']</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二步：我们需要将单个字符串类型的数字，转换成真正数字类型的数字，可以借助中间数组来帮忙，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> =&gt; [<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">1</span></span><br><span class="line"><span class="string">'2'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">2</span></span><br><span class="line"><span class="string">'3'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'9'</span> =&gt; [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>][<span class="string">'length'</span>] =&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure></li></ul><p>根据以上规律，我们封装一个<code>MakeArray</code>方法，它的实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> t1 = MakeArray&lt;<span class="string">'1'</span>&gt; <span class="comment">// [0]</span></span><br><span class="line"><span class="keyword">type</span> t2 = MakeArray&lt;<span class="string">'2'</span>&gt; <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="keyword">type</span> t3 = MakeArray&lt;<span class="string">'3'</span>&gt; <span class="comment">// [0, 0, 0]</span></span><br></pre></td></tr></table></figure></p><ul><li>第三步：现在有了百位，十位和个位的数字，我们应该运用算术把它们按照一定的规律累加起来，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> target = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 第二次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">1</span> + <span class="number">2</span> = <span class="number">12</span></span><br><span class="line"><span class="comment">// 第三次迭代</span></span><br><span class="line">target = <span class="number">10</span> * <span class="number">12</span> + <span class="number">3</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">// 迭代规律</span></span><br><span class="line">target = <span class="number">10</span> * target + N</span><br></pre></td></tr></table></figure></li></ul><p>根据以上思路，我们还需要一个乘十的工具函数，对应到实际需求，就是需要把一个数组<code>copy</code>十次，因此我们封装一个<code>Multiply10</code>工具，其实现代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result = Multiply10&lt;[<span class="number">1</span>]&gt; <span class="comment">// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></span><br></pre></td></tr></table></figure></p><ul><li><p>第四步：根据前几步的分析，把所有东西串联起来，<code>StringToNumber</code>完整实现代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Digital = <span class="string">'0'</span>|<span class="string">'1'</span>|<span class="string">'2'</span>|<span class="string">'3'</span>|<span class="string">'4'</span>|<span class="string">'5'</span>|<span class="string">'6'</span>|<span class="string">'7'</span>|<span class="string">'8'</span>|<span class="string">'9'</span></span><br><span class="line"><span class="keyword">type</span> Multiply10&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T]</span><br><span class="line"><span class="keyword">type</span> MakeArray&lt;N <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = N <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;T[<span class="string">'length'</span>]&#125;</span>`</span> ? T : MakeArray&lt;N, [...T, <span class="number">0</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StringToNumber&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> Digital</span><br><span class="line">      ? StringToNumber&lt;S2, [...Multiply10&lt;T&gt;, ...MakeArray&lt;S1&gt;]&gt;</span><br><span class="line">      : never</span><br><span class="line">    : T[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure></li><li><p>第五步：为了更好的理解递归的过程，我们拆解成如下步骤来说明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'123'</span> S1 = <span class="string">'1'</span> S2 = <span class="string">'23'</span> T = [<span class="number">0</span>] T[<span class="string">'length'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'23'</span>  S1 = <span class="string">'2'</span> S2 = <span class="string">'3'</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次递归，S满足$&#123;infer S1&#125;$&#123;infer S2&#125;， S1满足Digital</span></span><br><span class="line">S = <span class="string">'3'</span>  S1 = <span class="string">'3'</span> S2 = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四次递归，S不满足$&#123;infer S1&#125;$&#123;infer S2&#125; T['length']取值</span></span><br><span class="line">S = <span class="string">''</span> T = [<span class="number">0</span>,...<span class="number">.0</span>] T[<span class="string">'length'</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">type</span> result = StringToNumber&lt;<span class="string">'123'</span>&gt; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="FilterOut-数组元素过滤"><a href="#FilterOut-数组元素过滤" class="headerlink" title="FilterOut(数组元素过滤)"></a>FilterOut(数组元素过滤)</h3><p><link-and-solution num="399"></link-and-solution></p><h4 id="用法-110"><a href="#用法-110" class="headerlink" title="用法"></a>用法</h4><p><code>FilterOut</code>是用来从数组中移除指定元素的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：[2]</span></span><br><span class="line"><span class="keyword">type</span> result = FilterOut&lt;[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">2</span>], <span class="string">'a'</span> | <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-110"><a href="#实现方式-110" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterOut&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  F,</span><br><span class="line">  K <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer R, ...infer args]</span><br><span class="line">      ? [R] <span class="keyword">extends</span> [F]</span><br><span class="line">        ? FilterOut&lt;args, F, [...K]&gt;</span><br><span class="line">        : FilterOut&lt;args, F, [...K, R]&gt;</span><br><span class="line">      : K</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li>第一步：我们借用赋值函数来存放最后的结果。</li><li>第二步：迭代数组<code>T</code>，拿每一个元素去和指定的<code>F</code>进行判断，如果<code>R</code>是<code>F</code>的子类型，则不添加此元素到结果数组中，反之添加。</li><li>第三步：当迭代完毕时，直接返回结果数组<code>K</code>。</li></ul><h3 id="TupleToEnum-元组转枚举"><a href="#TupleToEnum-元组转枚举" class="headerlink" title="TupleToEnum(元组转枚举)"></a>TupleToEnum(元组转枚举)</h3><p><link-and-solution num="472"></link-and-solution></p><h4 id="用法-111"><a href="#用法-111" class="headerlink" title="用法"></a>用法</h4><p><code>TupleToEnum</code>是用来将元组转换为枚举的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OperatingSystem = [<span class="string">'macOs'</span>, <span class="string">'Windows'</span>, <span class="string">'Linux'</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> Expected1 = &#123;</span><br><span class="line">  readonly MacOs: <span class="string">'macOs'</span>;</span><br><span class="line">  readonly Windows: <span class="string">'Windows'</span>;</span><br><span class="line">  readonly Linux: <span class="string">'Linux'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected2 = &#123;</span><br><span class="line">  readonly MacOs: <span class="number">0</span>;</span><br><span class="line">  readonly Windows: <span class="number">1</span>;</span><br><span class="line">  readonly Linux: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected1</span></span><br><span class="line"><span class="keyword">type</span> result1 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br><span class="line"><span class="comment">// 结果：Expected2</span></span><br><span class="line"><span class="keyword">type</span> result2 = TupleToEnum&lt;<span class="keyword">typeof</span> OperatingSystem, <span class="literal">true</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-111"><a href="#实现方式-111" class="headerlink" title="实现方式"></a>实现方式</h4><p>在实现<code>TupleToEnum</code>之前，我们先来实现<code>TupleKeys</code>，它是用来获取所有元组索引组合成的联合类型的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleKeys&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> readonly [infer R, ...infer args]</span><br><span class="line">      ? TupleKeys&lt;args&gt; | args[<span class="string">'length'</span>]</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：0 | 1 | 2</span></span><br><span class="line"><span class="keyword">type</span> keys = TupleKeys&lt;<span class="keyword">typeof</span> OperatingSystem&gt;</span><br></pre></td></tr></table></figure></p><p>在有了以上<code>keys</code>后，就能很容易实现<code>TupleToEnum</code>了，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToEnum&lt;</span><br><span class="line">  T <span class="keyword">extends</span> readonly <span class="built_in">string</span>[],</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">&gt; = &#123;</span><br><span class="line">  readonly [K <span class="keyword">in</span> TupleKeys&lt;T&gt; <span class="keyword">as</span> Capitalize&lt;T[K]&gt;]: N <span class="keyword">extends</span> <span class="literal">true</span> ? K : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Format-字符串格式化函数类型"><a href="#Format-字符串格式化函数类型" class="headerlink" title="Format(字符串格式化函数类型)"></a>Format(字符串格式化函数类型)</h3><p><link-and-solution num="545"></link-and-solution></p><p><code>%s</code>表示格式化为<code>(x: string) =&gt; any</code>形式，<code>%d</code>表示格式化为<code>(x: number) =&gt; any</code>形式。</p><h4 id="用法-112"><a href="#用法-112" class="headerlink" title="用法"></a>用法</h4><p><code>Format</code>是将字符串格式化为指定函数类型的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：(x: string) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result1 = Format&lt;<span class="string">'a%sbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：(x: number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> result2 = Format&lt;<span class="string">'a%dbc'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：(x: number) =&gt; (x: string) =&gt; string&gt;</span></span><br><span class="line"><span class="keyword">type</span> result3 = Format&lt;<span class="string">'a%dbc%s'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-112"><a href="#实现方式-112" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FormatMaps = &#123;</span><br><span class="line">  <span class="string">'s'</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">'d'</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Format&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>%<span class="subst">$&#123;infer P&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">      ? P <span class="keyword">extends</span> keyof FormatMaps</span><br><span class="line">        ? <span class="function">(<span class="params">x: FormatMaps[P]</span>) =&gt;</span> Format&lt;S2&gt;</span><br><span class="line">        : <span class="built_in">string</span></span><br><span class="line">      : <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h3 id="LengthOfString-字符串的长度-1"><a href="#LengthOfString-字符串的长度-1" class="headerlink" title="LengthOfString(字符串的长度)"></a>LengthOfString(字符串的长度)</h3><p><link-and-solution num="651"></link-and-solution></p><p>我们之前在<strong>中级</strong>大章节中已经实现过<code>LengthOfString</code>，但它面临的问题是，如果字符有上百个，由于<code>TS</code>对于递归的次数存在限制，会提示嵌套过深。</p><h4 id="用法-113"><a href="#用法-113" class="headerlink" title="用法"></a>用法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：91</span></span><br><span class="line"><span class="keyword">type</span> result = LengthOfString&lt;<span class="string">'1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="实现方式-113"><a href="#实现方式-113" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LengthOfString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S0&#125;</span><span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span><span class="subst">$&#123;infer S3&#125;</span><span class="subst">$&#123;infer S4&#125;</span><span class="subst">$&#123;infer S5&#125;</span><span class="subst">$&#123;infer S6&#125;</span><span class="subst">$&#123;infer S7&#125;</span><span class="subst">$&#123;infer S8&#125;</span><span class="subst">$&#123;infer S9&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">      ? LengthOfString&lt;Rest, [...R, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&gt;</span><br><span class="line">      : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">          ? LengthOfString&lt;S2, [...R, S1]&gt;</span><br><span class="line">          : R[<span class="string">'length'</span>]</span><br></pre></td></tr></table></figure><p>代码解析：这里我们巧妙的使用占位的思想，<code>S extends ${infer S1}${infer S2}${infer S3}</code>，如果<code>S</code>满足这个占位形式，则表示<code>S</code>的长度至少为<code>2</code>，带入到上面的例子，解析步骤如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 第二弟递归</span></span><br><span class="line">S满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line"><span class="comment">// 最后一次递归</span></span><br><span class="line">S = <span class="string">'1'</span>不满足至少<span class="number">10</span>个字符的长度，R = [<span class="number">1</span>, ....., <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 最后结果</span></span><br><span class="line">R[<span class="string">'length'</span>] = <span class="number">91</span></span><br></pre></td></tr></table></figure></p><h3 id="UnionToTuple-联合类型转元组"><a href="#UnionToTuple-联合类型转元组" class="headerlink" title="UnionToTuple(联合类型转元组)"></a>UnionToTuple(联合类型转元组)</h3><p><link-and-solution num="730"></link-and-solution></p><h4 id="用法-114"><a href="#用法-114" class="headerlink" title="用法"></a>用法</h4><p><code>UnionToTuple</code>是用来将联合类型转成元组的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result1 = UnionToTuple&lt;<span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result2 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：['a', 'b']</span></span><br><span class="line"><span class="keyword">type</span> result3 = UnionToTuple&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | never&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-114"><a href="#实现方式-114" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = (</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">  ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">  : never</span><br><span class="line">) <span class="keyword">extends</span> (x: infer R) =&gt; <span class="built_in">any</span> </span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LastUnion&lt;U&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line">    : never</span><br><span class="line">&gt; <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span></span><br><span class="line">  ? R</span><br><span class="line">  : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnionToTuple&lt;</span><br><span class="line">  T,</span><br><span class="line">  Last = LastUnion&lt;T&gt;</span><br><span class="line">&gt; = [T] <span class="keyword">extends</span> [never]</span><br><span class="line">  ? []</span><br><span class="line">  : [...UnionToTuple&lt;Exclude&lt;T, Last&gt;&gt;, Last]</span><br></pre></td></tr></table></figure><p>代码详解：</p><ul><li><code>UnionToIntersection</code>: 联合类型取交集，在之前已经实现过，这里不再赘述。主要理解以下案例：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载结果</span></span><br><span class="line"><span class="comment">// function (x: 1): 0;</span></span><br><span class="line"><span class="comment">// function (x: 2): 0;</span></span><br><span class="line"><span class="keyword">type</span> result = UnionToIntersection&lt;f1 | f2&gt;</span><br></pre></td></tr></table></figure></li></ul><p>对于函数参数的交集而言，不是简单的把参数取交集，而是”联合”起来，也就是构造一个新的函数类型，即：<strong>函数重载</strong></p><ul><li><code>LastUnion</code>: 取联合类型最后的一个元素，如果一个函数存在重载的情况，<code>TS</code>会取最后一个函数签名，例如：<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f1 = <span class="function">(<span class="params">x: 1</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> f2 = <span class="function">(<span class="params">x: 2</span>) =&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：2</span></span><br><span class="line"><span class="keyword">type</span> result1 = f1 &amp; f2 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br><span class="line"><span class="comment">// 结果2：1</span></span><br><span class="line"><span class="keyword">type</span> result2 = f2 &amp; f1 <span class="keyword">extends</span> (x: infer R) =&gt; <span class="number">0</span> ? R : never</span><br></pre></td></tr></table></figure></li></ul><h3 id="Join-字符串拼接"><a href="#Join-字符串拼接" class="headerlink" title="Join(字符串拼接)"></a>Join(字符串拼接)</h3><p><link-and-solution num="847"></link-and-solution></p><h4 id="用法-115"><a href="#用法-115" class="headerlink" title="用法"></a>用法</h4><p><code>Join</code>是用来实现拼接字符串的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果1： ''</span></span><br><span class="line"><span class="keyword">const</span> Expected1 = join(<span class="string">'-'</span>)();</span><br><span class="line"><span class="comment">// 结果2： 'a'</span></span><br><span class="line"><span class="keyword">const</span> Expected2 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 结果3： 'abc'</span></span><br><span class="line"><span class="keyword">const</span> Expected3 = join(<span class="string">''</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 结果4： 'a-b-c'</span></span><br><span class="line"><span class="keyword">const</span> Expected4 = join(<span class="string">'-'</span>)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-115"><a href="#实现方式-115" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tail&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[]&gt; = T <span class="keyword">extends</span> [<span class="built_in">any</span>, ...infer Rest] ? Rest : []</span><br><span class="line"><span class="keyword">type</span> StringJoin&lt;</span><br><span class="line">  D <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">string</span>[] = []</span><br><span class="line">&gt; = P <span class="keyword">extends</span> []</span><br><span class="line">    ? <span class="string">''</span></span><br><span class="line">    : P <span class="keyword">extends</span> [infer Only]</span><br><span class="line">      ? Only</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;P[<span class="number">0</span>]&#125;</span><span class="subst">$&#123;D&#125;</span><span class="subst">$&#123;StringJoin&lt;D, Tail&lt;P&gt;&gt;&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">D</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">delimiter: D</span>): &lt;<span class="title">P</span> <span class="title">extends</span> <span class="title">string</span>[] = []&gt;(<span class="params">...parts: P</span>) =&gt; <span class="title">StringJoin</span>&lt;<span class="title">D</span>, <span class="title">P</span>&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="DeepPick-深层次Pick"><a href="#DeepPick-深层次Pick" class="headerlink" title="DeepPick(深层次Pick)"></a>DeepPick(深层次Pick)</h3><p><link-and-solution num="956"></link-and-solution></p><h4 id="用法-116"><a href="#用法-116" class="headerlink" title="用法"></a>用法</h4><p><code>DeepPick</code>是用来深层次获取属性值的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b: <span class="built_in">string</span>,</span><br><span class="line">  c:  <span class="built_in">boolean</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    d: <span class="built_in">number</span>,</span><br><span class="line">    e: <span class="built_in">string</span>,</span><br><span class="line">    f:  <span class="built_in">boolean</span>,</span><br><span class="line">    obj2: &#123;</span><br><span class="line">      g: <span class="built_in">number</span>,</span><br><span class="line">      h: <span class="built_in">string</span>,</span><br><span class="line">      i: <span class="built_in">boolean</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：Obj</span></span><br><span class="line"><span class="keyword">type</span> result1 = DeepPick&lt;Obj, <span class="string">''</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：&#123; a: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result2 = DeepPick&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果3：&#123; a: number; &#125; &amp; &#123; obj: &#123; d: number; &#125; &#125;</span></span><br><span class="line"><span class="keyword">type</span> result3 = DeepPick&lt;Obj, <span class="string">'a'</span>, <span class="string">'obj.d'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-116"><a href="#实现方式-116" class="headerlink" title="实现方式"></a>实现方式</h4><p>在之前，我们实现过根据属性路径取值<code>Get</code>，根据其思路我们很容易实现<code>DeepPick</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> </span><br><span class="line">    ? <span class="function">(<span class="params">x: U</span>) =&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    : never</span><br><span class="line">  ) <span class="keyword">extends</span> (x: infer V) =&gt; <span class="built_in">any</span> </span><br><span class="line">    ? V</span><br><span class="line">    : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetType&lt;T, S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>.<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S1]: GetType&lt;T[S1], S2&gt; &#125;</span><br><span class="line">      : never</span><br><span class="line">    : S <span class="keyword">extends</span> keyof T</span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> S]: T[K] &#125;</span><br><span class="line">      : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeepPick&lt;</span><br><span class="line">  T,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = UnionToIntersection&lt;</span><br><span class="line">  U <span class="keyword">extends</span> infer keys ? GetType&lt;T, keys&gt; : never</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Camelize-对象属性键转小驼峰"><a href="#Camelize-对象属性键转小驼峰" class="headerlink" title="Camelize(对象属性键转小驼峰)"></a>Camelize(对象属性键转小驼峰)</h3><p><link-and-solution num="1383"></link-and-solution></p><h4 id="用法-117"><a href="#用法-117" class="headerlink" title="用法"></a>用法</h4><p><code>Camelize</code>是用来将对象中的<code>key</code>全部转换为小驼峰的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  some_PROP: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123;</span><br><span class="line">    another_prop: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snake_case: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Expected = &#123;</span><br><span class="line">  someProp: <span class="built_in">string</span>;</span><br><span class="line">  prop: &#123; </span><br><span class="line">    anotherProp: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  array: [</span><br><span class="line">    &#123; snakeCase: <span class="built_in">string</span>; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：Expected</span></span><br><span class="line"><span class="keyword">type</span> result = Camelize&lt;Person&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-117"><a href="#实现方式-117" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CamelCase&lt;S&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span>_<span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;Lowercase&lt;S1&gt;&#125;</span><span class="subst">$&#123;CamelCase&lt;Capitalize&lt;Lowercase&lt;S2&gt;&gt;&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camelize&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> CamelCase&lt;K&gt;]: </span><br><span class="line">    T[K] <span class="keyword">extends</span> [infer R]</span><br><span class="line">      ? [Camelize&lt;R&gt;]</span><br><span class="line">      : T[K] <span class="keyword">extends</span> <span class="built_in">Object</span></span><br><span class="line">        ? Camelize&lt;T[K]&gt;</span><br><span class="line">        : T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：<code>CamelCase</code>的实现可以分为两个部分，第一部分来自于处理属性<code>key</code>转小驼峰的情况，第二部分来自于嵌套对象的情况。</p><ul><li>处理属性<code>key</code>：根据之前介绍过的<code>as</code>用法，我们可以在<code>in</code>迭代过程中使用<code>as</code>来进一步<strong>加工或者处理</strong>属性<code>key</code>，也就是<code>CamelCase</code>的部分。</li><li>处理嵌套对象：对于<code>T[P]</code>而言，我们考虑嵌套对象为数组和普通对象的情况，首先判断是否为数组类型，如果是则迭代数组递归调用<code>Camelize</code>；如果是普通对象，则直接调用<code>Camelize</code>；如果都不是，则直接返回<code>T[P]</code>即可。</li></ul><h3 id="DropString-移除全部字符"><a href="#DropString-移除全部字符" class="headerlink" title="DropString(移除全部字符)"></a>DropString(移除全部字符)</h3><p><link-and-solution num="2059"></link-and-solution></p><h4 id="用法-118"><a href="#用法-118" class="headerlink" title="用法"></a>用法</h4><p><code>DropString</code>是用来移除全部字符的，用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：'ooar!'</span></span><br><span class="line"><span class="keyword">type</span> result = DropString&lt;<span class="string">'foobar!'</span>, <span class="string">'fb'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-118"><a href="#实现方式-118" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StrngToUnion&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 | StrngToUnion&lt;S2&gt;</span><br><span class="line">    : S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DropString&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U = StrngToUnion&lt;R&gt;</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">    ? S1 <span class="keyword">extends</span> U</span><br><span class="line">      ? DropString&lt;S2, R&gt;</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;S1&#125;</span><span class="subst">$&#123;DropString&lt;S2, R&gt;&#125;</span>`</span></span><br><span class="line">    : S</span><br></pre></td></tr></table></figure><p>代码详解：实现<code>DropString</code>的核心是将指定的字符串转换为联合类型，转换之后只需要迭代字符串，判断当前迭代的字符是不是在联合类型中，如果是则直接丢弃，不是则原样保留。</p><h3 id="Split-字符串Split方法"><a href="#Split-字符串Split方法" class="headerlink" title="Split(字符串Split方法)"></a>Split(字符串Split方法)</h3><p><link-and-solution num="2822"></link-and-solution></p><h4 id="用法-119"><a href="#用法-119" class="headerlink" title="用法"></a>用法</h4><p><code>Split</code>是用来实现字符串<code>split</code>方法的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果：["Hi!", "How", "are", "you?"]</span></span><br><span class="line"><span class="keyword">type</span> result = Split&lt;<span class="string">'Hi! How are you?'</span>, <span class="string">' '</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-119"><a href="#实现方式-119" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Split&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  SEP <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer _&#125;</span>`</span></span><br><span class="line">      ? S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer S1&#125;</span><span class="subst">$&#123;SEP&#125;</span><span class="subst">$&#123;infer S2&#125;</span>`</span></span><br><span class="line">        ? Split&lt;S2, SEP, [...R, S1]&gt;</span><br><span class="line">        : S <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">          ? SEP <span class="keyword">extends</span> <span class="string">''</span></span><br><span class="line">            ? R</span><br><span class="line">            : [...R, S]</span><br><span class="line">          : [...R, S]</span><br><span class="line">      : <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure><h3 id="ClassPublicKeys-类的公共键"><a href="#ClassPublicKeys-类的公共键" class="headerlink" title="ClassPublicKeys(类的公共键)"></a>ClassPublicKeys(类的公共键)</h3><p><link-and-solution num="2828"></link-and-solution></p><h4 id="用法-120"><a href="#用法-120" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-120"><a href="#实现方式-120" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsRequiredKeys-是否为必填key"><a href="#IsRequiredKeys-是否为必填key" class="headerlink" title="IsRequiredKeys(是否为必填key)"></a>IsRequiredKeys(是否为必填key)</h3><p><link-and-solution num="2857"></link-and-solution></p><h4 id="用法-121"><a href="#用法-121" class="headerlink" title="用法"></a>用法</h4><p><code>IsRequiredKeys</code>是用来判断是否为必填<code>key</code>的，其用法如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>,</span><br><span class="line">  b?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果1：true</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsRequiredKeys&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：false</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsRequiredKeys&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="实现方式-121"><a href="#实现方式-121" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsRequiredKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T <span class="keyword">extends</span> Record&lt;K, T[K]&gt; ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>根据<code>IsRequiredKey</code>的实现思路，我们可以很容易实现<code>IsOptionalKey</code>，如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsOptionalKey&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;&#125; <span class="keyword">extends</span> &#123; [P <span class="keyword">in</span> K]: T[P] &#125; ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果1：false</span></span><br><span class="line"><span class="keyword">type</span> result1 = IsOptionalKey&lt;Obj, <span class="string">'a'</span>&gt;</span><br><span class="line"><span class="comment">// 结果2：true</span></span><br><span class="line"><span class="keyword">type</span> result2 = IsOptionalKey&lt;Obj, <span class="string">'b'</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="ObjectEntries-对象Object-entries方法"><a href="#ObjectEntries-对象Object-entries方法" class="headerlink" title="ObjectEntries(对象Object.entries方法)"></a>ObjectEntries(对象Object.entries方法)</h3><p><link-and-solution num="2949"></link-and-solution></p><h4 id="用法-122"><a href="#用法-122" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-122"><a href="#实现方式-122" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsPalindrome-是否为回文"><a href="#IsPalindrome-是否为回文" class="headerlink" title="IsPalindrome(是否为回文)"></a>IsPalindrome(是否为回文)</h3><p><link-and-solution num="4037"></link-and-solution></p><h4 id="用法-123"><a href="#用法-123" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-123"><a href="#实现方式-123" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="MutableKeys-所有可写键"><a href="#MutableKeys-所有可写键" class="headerlink" title="MutableKeys(所有可写键)"></a>MutableKeys(所有可写键)</h3><p><link-and-solution num="5181"></link-and-solution></p><h4 id="用法-124"><a href="#用法-124" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-124"><a href="#实现方式-124" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Intersection-交集"><a href="#Intersection-交集" class="headerlink" title="Intersection(交集)"></a>Intersection(交集)</h3><p><link-and-solution num="5423"></link-and-solution></p><h4 id="用法-125"><a href="#用法-125" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-125"><a href="#实现方式-125" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="BinaryToDecimal-二进制转十进制"><a href="#BinaryToDecimal-二进制转十进制" class="headerlink" title="BinaryToDecimal(二进制转十进制)"></a>BinaryToDecimal(二进制转十进制)</h3><p><link-and-solution num="6141"></link-and-solution></p><h4 id="用法-126"><a href="#用法-126" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-126"><a href="#实现方式-126" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectKeyPaths-对象属性键路径"><a href="#ObjectKeyPaths-对象属性键路径" class="headerlink" title="ObjectKeyPaths(对象属性键路径)"></a>ObjectKeyPaths(对象属性键路径)</h3><p><link-and-solution num="7258"></link-and-solution></p><h4 id="用法-127"><a href="#用法-127" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-127"><a href="#实现方式-127" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="TwoSum-LeetCode两数之和"><a href="#TwoSum-LeetCode两数之和" class="headerlink" title="TwoSum(LeetCode两数之和)"></a>TwoSum(LeetCode两数之和)</h3><p><link-and-solution num="8804"></link-and-solution></p><h4 id="用法-128"><a href="#用法-128" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-128"><a href="#实现方式-128" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ValidDate-校验是否为合法日期"><a href="#ValidDate-校验是否为合法日期" class="headerlink" title="ValidDate(校验是否为合法日期)"></a>ValidDate(校验是否为合法日期)</h3><p><link-and-solution num="9155"></link-and-solution></p><h4 id="用法-129"><a href="#用法-129" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-129"><a href="#实现方式-129" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Assign-对象Object-assign方法"><a href="#Assign-对象Object-assign方法" class="headerlink" title="Assign(对象Object.assign方法)"></a>Assign(对象Object.assign方法)</h3><p><link-and-solution num="9160"></link-and-solution></p><h4 id="用法-130"><a href="#用法-130" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-130"><a href="#实现方式-130" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="Maximum-数字中的最大值"><a href="#Maximum-数字中的最大值" class="headerlink" title="Maximum(数字中的最大值)"></a>Maximum(数字中的最大值)</h3><p><link-and-solution num="9384"></link-and-solution></p><h4 id="用法-131"><a href="#用法-131" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-131"><a href="#实现方式-131" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="DeepCapitalize-深度首字母大写"><a href="#DeepCapitalize-深度首字母大写" class="headerlink" title="DeepCapitalize(深度首字母大写)"></a>DeepCapitalize(深度首字母大写)</h3><p><link-and-solution num="9775"></link-and-solution></p><h4 id="用法-132"><a href="#用法-132" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-132"><a href="#实现方式-132" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="UnionReplace-联合类型替换"><a href="#UnionReplace-联合类型替换" class="headerlink" title="UnionReplace(联合类型替换)"></a>UnionReplace(联合类型替换)</h3><p><link-and-solution num="13580"></link-and-solution></p><h4 id="用法-133"><a href="#用法-133" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-133"><a href="#实现方式-133" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="FizzBuzz-Fizz和Buzz输出问题"><a href="#FizzBuzz-Fizz和Buzz输出问题" class="headerlink" title="FizzBuzz(Fizz和Buzz输出问题)"></a>FizzBuzz(Fizz和Buzz输出问题)</h3><p><link-and-solution num="14080"></link-and-solution></p><h4 id="用法-134"><a href="#用法-134" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-134"><a href="#实现方式-134" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="RLE-运行长度编码"><a href="#RLE-运行长度编码" class="headerlink" title="RLE(运行长度编码)"></a>RLE(运行长度编码)</h3><p><link-and-solution num="14188"></link-and-solution></p><h4 id="用法-135"><a href="#用法-135" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-135"><a href="#实现方式-135" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="ObjectPathArray-对象键路径数组"><a href="#ObjectPathArray-对象键路径数组" class="headerlink" title="ObjectPathArray(对象键路径数组)"></a>ObjectPathArray(对象键路径数组)</h3><p><link-and-solution num="15260"></link-and-solution></p><h4 id="用法-136"><a href="#用法-136" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-136"><a href="#实现方式-136" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="SnakeCase-字符串下划线连接"><a href="#SnakeCase-字符串下划线连接" class="headerlink" title="SnakeCase(字符串下划线连接)"></a>SnakeCase(字符串下划线连接)</h3><p><link-and-solution num="19458"></link-and-solution></p><h4 id="用法-137"><a href="#用法-137" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-137"><a href="#实现方式-137" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="IsNegativeNumber-是否为负数"><a href="#IsNegativeNumber-是否为负数" class="headerlink" title="IsNegativeNumber(是否为负数)"></a>IsNegativeNumber(是否为负数)</h3><p><link-and-solution num="25747"></link-and-solution></p><h4 id="用法-138"><a href="#用法-138" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-138"><a href="#实现方式-138" class="headerlink" title="实现方式"></a>实现方式</h4><h3 id="OptionalUndefined-按需转换为可选属性"><a href="#OptionalUndefined-按需转换为可选属性" class="headerlink" title="OptionalUndefined(按需转换为可选属性)"></a>OptionalUndefined(按需转换为可选属性)</h3><p><link-and-solution num="28143"></link-and-solution></p><h4 id="用法-139"><a href="#用法-139" class="headerlink" title="用法"></a>用法</h4><h4 id="实现方式-139"><a href="#实现方式-139" class="headerlink" title="实现方式"></a>实现方式</h4><h2 id="地狱"><a href="#地狱" class="headerlink" title="地狱"></a>地狱</h2><p>撰写中…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript进阶教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript教程(一)</title>
    <link href="/2024/08/01/TypeScript%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
    <id>/2024/08/01/TypeScript教程-一/</id>
    <published>2024-08-01T06:37:09.000Z</published>
    <updated>2024-08-12T01:14:32.310Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript基础教程<br><a id="more"></a></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p><code>TypeScript</code>是<code>JavaScript</code>的一个超集，主要提供了<strong>类型系统</strong>和对<strong>ES6</strong>的支持，它于2012年10月正式发布第一个版本。</p><p>优势：</p><ul><li>能在开发过程中更快的发现潜在问题。</li><li>对编辑器更友好的代码提示功能。</li><li>代码语义更清晰易懂。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>你首先需要在<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>按照你电脑的操作系统下载对应的<code>Node</code>版本进行安装。</p><h3 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>你需要使用如下命令全局安装<code>TypeScript</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">$ npm install -g typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后，查看版本号</span></span><br><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>如果你对具体版本有严格的要求，你同样可以按照指定版本号进行安装。</p></blockquote><p>如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按指定版本号进行安装</span></span><br><span class="line">$ npm install -g typescript@3.6.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕后，查看版本号</span></span><br><span class="line">$ tsc -v</span><br></pre></td></tr></table></figure></p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>在正式开始学习<code>TypeScript</code>之前，我们需要创建一个叫做<code>TypeScript</code>的文件夹：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">$ mkdir TypeScript</span><br></pre></td></tr></table></figure></p><p>随后在<code>TypeScript</code>文件夹中创建<code>demo.ts</code>文件，其代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello,world'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>.ts</code>中的代码一般而言是不能直接运行在浏览器的，需要我们把<code>typescript</code>代码进行编译成普通的<code>javascript</code>代码以后才能运行在浏览器，我们可以使用如下命令来进行编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译命令</span></span><br><span class="line">$ tsc demo.ts</span><br></pre></td></tr></table></figure></p><p>当编译完毕后，我们可以在文件夹中看到多出来了一个叫做<code>demo.js</code>文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- TypeScript</span><br><span class="line">|   |-- demo.js</span><br><span class="line">|   |-- demo.ts</span><br></pre></td></tr></table></figure></p><p>随后我们需要使用如下命令来执行我们编译后的<code>javascript</code>代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ node demo.js</span><br></pre></td></tr></table></figure></p><p>当执行完毕以上命令后，你可以在终端上看到输出一下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,world</span><br></pre></td></tr></table></figure></p><p><strong>简化过程</strong>：我们发现，如果要运行一个<code>.ts</code>文件，我们首先需要使用<code>tsc</code>命令去编译它，随后再使用<code>node</code>命令去执行它，那么有没有一种工具能够一个步骤就帮我们做完以上的事情呢？我们需要全局安装一个叫做<code>ts-node</code>的工具：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ts-node</span></span><br><span class="line">$ npm install ts-node -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完毕，查看版本号</span></span><br><span class="line">$ ts-node -v</span><br></pre></td></tr></table></figure></p><p>在<code>ts-node</code>安装完毕后，我们先删除<code>demo.js</code>文件，随后使用<code>ts-node</code>命令来编译并执行我们的代码：</p><blockquote><p>warning<br><code>ts-node</code>包有升级更新，如果运行<code>ts-node</code>命令报错，请按照<code>ts-node</code>最新文档进行处理。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除demo.js文件</span></span><br><span class="line">$ rm demo.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译并执行</span></span><br><span class="line">$ ts-node demo.ts</span><br></pre></td></tr></table></figure><p>以上命令执行完毕后，你将会看到与上面实例相同的输出结果。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>我们知道<code>JavaScript</code>分为<strong>原始数据类型</strong>和<strong>对象类型</strong>，原始数据类型包括：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>和<code>symbol</code>。<br>在<code>TypeScript</code>中，我们可以如下定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsNum: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> tsStr: <span class="built_in">string</span> = <span class="string">'AAA'</span></span><br><span class="line"><span class="keyword">let</span> tsFlag: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> tsNull: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> tsUndefined: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="void空值"><a href="#void空值" class="headerlink" title="void空值"></a>void空值</h4><p>我们知道在<code>JavaScript</code>中，是没有空值(<code>void</code>)的概念的，但在<code>TypeScript</code>中，可以使用<code>void</code>来表示一个没有返回值的函数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以定义一个<code>void</code>类型的变量，不过这样的变量并没有什么意义，因为我们只能给这种变量赋值为<code>null</code>或<code>undefined</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> voidValue1: <span class="built_in">void</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> voidValue2: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="void、null和undefined"><a href="#void、null和undefined" class="headerlink" title="void、null和undefined"></a>void、null和undefined</h4><p><code>void</code>和<code>null</code>与<code>undefined</code>是有一定区别的，在<code>TypeScript</code>中，<code>null</code>和<code>undefined</code>是所有类型的子类型，也就是说可以把<code>undefined</code>或<code>null</code>赋值给<code>number</code>等类型的变量:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsNumber1: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> tsNumber2: <span class="built_in">number</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>而对于<code>void</code>而言，它只能被赋值为<code>null</code>或者<code>undefined</code>：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两行代码会编译报错</span></span><br><span class="line"><span class="keyword">let</span> voidValue1: <span class="built_in">void</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> voidValue2: <span class="built_in">void</span> = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p>任意值<code>Any</code>用来表示可以接受任何类型的值。</p><p>在有以上内容的基础上，我们知道以下代码会报错：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量被定义为number，那么它只能接受number类型的值，不能改变其类型，会编译报错</span></span><br><span class="line"><span class="keyword">let</span> tsNumber: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line">tsNumber = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>但是如果一个变量被定义为<code>any</code>，那么代表它可以接受任何类型的值：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是正确的，编译成功</span></span><br><span class="line"><span class="keyword">let</span> tsAny: <span class="built_in">any</span> = <span class="number">123</span></span><br><span class="line">tsAny = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>现在我们来思考一个问题，如果我们定义了一个变量，没有指定其类型，也没有初始化，那么它默认为<code>any</code>类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是正确的，编译成功</span></span><br><span class="line"><span class="keyword">let</span> tsValue</span><br><span class="line">tsValue = <span class="number">123</span></span><br><span class="line">tsValue = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><h3 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h3><p>在以上的所有实例中，我们都为每一个变量提供了一个确定的类型，这种做法就叫做<strong>类型注解</strong>。而有些时候，当我们没有为其提供一个确定的类型，但提供了一个确定的值，那么<code>TypeScript</code>会根据我们给定的值的类型自动推断出这个变量的类型，这就叫<strong>类型推断</strong>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typescript会自动为num1变量推断为number</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typescript会自动为num4变量推断为number</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">456</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">789</span></span><br><span class="line"><span class="keyword">let</span> num4 = num2 + num3</span><br></pre></td></tr></table></figure></p><p>根据以上的案例，当我们给一个变量一个明确值的情况下，我们可以省略为其定义类型。但如果在函数参数中，则我们必须为其指定一个类型，如果不指定则默认为<code>any</code>:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者省略函数的返回值类型，因为typescript会基于num1和num1全部为number类型，从而推断出函数返回值为number类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>建议</strong>：始终为函数返回值提供一个确定的类型是有一个比较推荐的好习惯。</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p><strong>联合类型</strong>：表示取值可以为多种类型中的一种，多种类型使用<code>|</code>分隔开。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">value = <span class="number">123</span></span><br><span class="line">value = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>当我们使用联合类型的时候，因为<code>TypeScript</code>不确定到底是哪一个类型，所以我们只能访问此联合类型的所有类型公用的属性和方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span> (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码不会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueToStr</span> (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>warning<br>另外一个值得注意的地方就是，当联合类型被赋值后，<code>TypeScript</code>会根据类型推断来确定变量的类型，一旦确定后，则此变量只能使用这种类型的属性和方法。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tsValue: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">tsValue = <span class="string">'123'</span></span><br><span class="line"><span class="built_in">console</span>.log(tsValue.length) <span class="comment">// 编译正确</span></span><br><span class="line">tsValue = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(tsValue.length) <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在<code>TypeScript</code>中，接口<code>interface</code>是一个比较重要的概念，它是对行为的抽象，而具体的行为需要由类去实现，接口<code>interface</code>中的任何代码都不会被最后编译到<code>JavaScript</code>中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，<code>person</code>变量它是<code>Person</code>类型的，那么此变量只能接受接口规定的属性，且属性值的类型也必须和接口中规定的一致，多一个属性或者少一个属性在<code>TypeScript</code>中都不是被允许的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">let</span> person1: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">let</span> person2: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的任意属性"><a href="#接口中的任意属性" class="headerlink" title="接口中的任意属性"></a>接口中的任意属性</h4><p>以上一个例子为基础，假设我们接口只对<code>name</code>和<code>age</code>做规定，其它任何属性都是可以的，那么我们可以如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  <span class="comment">// 任意属性</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的可选属性"><a href="#接口中的可选属性" class="headerlink" title="接口中的可选属性"></a>接口中的可选属性</h4><p>现在假设，我们有一个接口，它只对<code>name</code>做规定，但是对于是否包含<code>age</code>不做要求，那么可以如下方式进行处理：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  <span class="comment">// age属性是可选的</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成功</span></span><br><span class="line"><span class="keyword">let</span> person1: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口中的只读属性"><a href="#接口中的只读属性" class="headerlink" title="接口中的只读属性"></a>接口中的只读属性</h4><p>最后我们要介绍的知识点是只读属性，一旦在接口中标记了属性为只读的， 那么其不能被赋值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  readonly age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">'why'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">person.age = <span class="number">32</span></span><br></pre></td></tr></table></figure></p><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>在<code>JavaScript</code>中，定义函数有三种表现形式：</p><ul><li>函数声明。</li><li>函数表达式。</li><li>箭头函数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> func2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> func3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数有参数，则必须在<code>TypeScript</code>中为其定义具体的类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">// 输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="string">'2'</span>))  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><h4 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h4><p>函数也可以使用接口来定义其类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AddInterface &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add: AddInterface = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure></p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>前面我们已经提到过，必须为具体的参数提供具体的类型，但如果一个函数接受一个参数，这个参数又是可选的，那么我们可以如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  b ? a * b : a * a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>))     <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>可选参数必须放在最后一个位置，否则会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">b?: <span class="built_in">number</span>, a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  b ? a * b : a * a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>在<code>JavaScript</code>中，函数允许我们给参数设置默认值，因此另外一种处理可选参数的方式是，为参数提供一个默认值，此时<code>TypeScript</code>将会把该参数识别为可选参数：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span> = 1</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>))     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>给一个参数设置了默认值后，就不再受<code>TypeScript</code>可选参数必须在最后一个位置的限制了。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">b: <span class="built_in">number</span> = 1, a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时必须显示的传递一个undefined进行占位</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="literal">undefined</span>,<span class="number">4</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="number">4</span>, <span class="number">5</span>))        <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>在<code>ES6</code>中，我们可以使用<code>...</code>符号进行收缩剩余参数，在<code>TypeScript</code>中，我们依然可以这么做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest是一个数组，我们可以使用数组的类型来定义它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span> (<span class="params">a: number, ...rest: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)    <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(rest) <span class="comment">// [2, 3, 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTotal(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,)</span><br></pre></td></tr></table></figure></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>因为在<code>JavaScript</code>中，并没有限制函数参数的个数或者类型，因此<code>JavaScript</code>没有函数重载的概念，在<code>TypeScript</code>中对于函数重载的理解是：只要函数参数的类型或者函数参数的数量不同时，就可以认为这是两个函数(重载)。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个为函数声明，最后一个才是函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">''</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'1'</span>, <span class="string">'2'</span>))  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>在有函数重载时，会优先从第一个进行逐一匹配，因此如果重载函数有包含关系，应该将最精准的函数定义写在最前面。</p></blockquote><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在上面联合类型中，我们知道可以变量可以是多个类型的，这可能会在代码编写的过程中带给我们一些困惑：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'student'</span></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'teacher'</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">person: Student | Teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 强制断言为Student类型</span></span><br><span class="line">    (person <span class="keyword">as</span> Student).sayHi()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 强制断言为Teacher类型</span></span><br><span class="line">    (person <span class="keyword">as</span> Teacher).sayHello()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> Student()</span><br><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> Teacher()</span><br><span class="line">print(stu)      <span class="comment">// student</span></span><br><span class="line">print(teacher)  <span class="comment">// teacher</span></span><br></pre></td></tr></table></figure></p><p>代码分析：在<code>print</code>函数中，我们接受的参数可以是<code>Student</code>或者<code>Teacher</code>，在此函数内部我们希望能够根据不同的类型来调用不同的方法。我们首先使用<code>instanceof</code>来判断参数是否为<code>Student</code>类的实例，是我们将<code>person</code>参数强制断言成<code>Student</code>类型，此时就可以安全的调用<code>sayHi</code>方法了，<code>Teacher</code>同理。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名用<code>type</code>关键字来给一个类型起一个新的名字，类型别名常用于联合类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> combineType = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> typeObj = &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> value1: combineType = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> obj: typeObj = &#123;</span><br><span class="line">  age: <span class="number">123</span>,</span><br><span class="line">  name: <span class="string">'why'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型用来表示一个变量只能取某几个字符串值中的一个。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eventName = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span> (<span class="params">event: eventName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="string">'click'</span>)    <span class="comment">// click</span></span><br><span class="line">handleEvent(<span class="string">'scroll'</span>)   <span class="comment">// scroll</span></span><br><span class="line">handleEvent(<span class="string">'dbclick'</span>)  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>和普通的变量一样，数组中的类型定义也有一定的规则：类型+方括号表示<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number类型</span></span><br><span class="line"><span class="keyword">let</span> numArray: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 只允许存储string类型</span></span><br><span class="line"><span class="keyword">let</span> strArray: <span class="built_in">string</span>[] = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>值得一提的是，以上案例还有一种泛型方式的写法：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number类型</span></span><br><span class="line"><span class="keyword">let</span> numArray: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 只允许存储string类型</span></span><br><span class="line"><span class="keyword">let</span> strArray: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>在数组中也可以使用联合类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储number和string类型的值</span></span><br><span class="line"><span class="keyword">let</span> tsArray: (<span class="built_in">number</span> | <span class="built_in">string</span>) [] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p>我们知道，在数组中不仅可以存储基础数据类型，还可以存储对象类型，如果需要存储对象类型，可以用如下方式进行定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许存储对象仅有name和age，且name为string类型，age为number类型的对象</span></span><br><span class="line"><span class="keyword">let</span> objArray: (&#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;)[] = [</span><br><span class="line">  &#123; name: <span class="string">'AAA'</span>, age: <span class="number">23</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>为了更加方便的撰写代码，我们可以使用类型别名的方式来管理以上类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objArray: person[] = [</span><br><span class="line">  &#123; name: <span class="string">'AAA'</span>, age: <span class="number">23</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>对元组的理解是：一个数组如果知道它确定的长度，且每个位置的值的类型也是确定的，那么就可以把这样的数组称为元组。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple数组只有2个元素，并且第一个元素类型为string，第二个元素类型为number</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'AAA'</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>warning<br>当访问元组中已知位置的索引时，将得到其对应正确的值；当访问元组中未知位置的索引时，会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'AAA'</span>, <span class="number">123</span>]</span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">1</span>]) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">2</span>]) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举<code>Enum</code>类型用来表示取值限定在指定的范围，例如一周只能有七天，颜色只能有红、绿、蓝等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors.red)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.green) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.blue)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>代码分析：我们定义一个<code>colors</code>的枚举类型，其取值只能是<code>red</code>、<code>green</code>、<code>blue</code>。我们可以在打印的内容发现，其输出值从0开始，依次累加1。这是枚举类型的默认行为，我们可以手动设置一个起始值：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red = <span class="number">10</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors.red)   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.green) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.blue)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><p>在枚举类型中，我们不仅可以正向的获取值，还可以通过值反向获取枚举：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> colors  &#123;</span><br><span class="line">  red = <span class="number">10</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">10</span>]) <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">11</span>]) <span class="comment">// green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">12</span>]) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>在<code>JavaScript</code>中，通过<code>extends</code>关键字来实现子类继承父类，子类也可以通过<code>super</code>关键字来访问父类的属性或者方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  sayTeacherHello () &#123;</span><br><span class="line">    <span class="comment">// 调用父类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sayHello()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> Teacher(<span class="string">'why'</span>)</span><br><span class="line">teacher.sayHello()        <span class="comment">// hello, why</span></span><br><span class="line">teacher.sayTeacherHello() <span class="comment">// hello, why</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>有一种关于类属性的简写方式，就是在类的构造函数中指明访问修饰符。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写形式</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>在<code>class</code>中，可以通过<code>getter</code>和<code>setter</code>来改变属性的读取和赋值行为。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="comment">// 私有属性，只能在类中进行访问</span></span><br><span class="line">  <span class="keyword">private</span> _name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// why</span></span><br><span class="line">person.name = <span class="string">'AAA'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// AAA</span></span><br></pre></td></tr></table></figure></p><h4 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h4><p>所谓静态属性和静态方法，就是只能通过类来进行访问，不能通过类的实例来进行访问。在众多设计模式中，有一种设计模式叫做单例设计模式，可以使用<code>static</code>静态方法来辅助我们完成单例设计模式。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> _instance: Person</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> getInstance () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>._instance = <span class="keyword">new</span> Person()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = Person.getInstance()</span><br><span class="line"><span class="keyword">const</span> person2 = Person.getInstance()</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h4 id="TypeScript类的访问修饰符"><a href="#TypeScript类的访问修饰符" class="headerlink" title="TypeScript类的访问修饰符"></a>TypeScript类的访问修饰符</h4><p>在以上的实例中，我们使用到了<code>TypeScript</code>中关于类的几种访问修饰符，它有三种：</p><ul><li><code>public</code>：公有的，在任何地方都可以访问到。</li><li><code>protected</code>：受保护的，只能在类的内部及其类的子类内部使用。</li><li><code>private</code>：私有的，只能在类的内部进行使用。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> age: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">protected</span> address: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">age: <span class="built_in">number</span>, address: <span class="built_in">string</span>, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.address = address</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my addresss is <span class="subst">$&#123;<span class="keyword">this</span>.address&#125;</span>`</span>) <span class="comment">// my address is 广东广州</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)        <span class="comment">// my name is why</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)          <span class="comment">// 编译报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">21</span>, <span class="string">'广东广州'</span>, <span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age)     <span class="comment">// 编译报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address) <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>可以使用<code>readonly</code>关键字来表示属性是只读的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> readonly name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'AAA'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// AAA</span></span><br><span class="line">person.name = <span class="string">'BBB'</span>       <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在<code>TypeScript</code>中，可以使用<code>abstract</code>关键字来定义抽象类以及抽象类中的抽象方法，在使用抽象类的过程中，有几点需要注意：</p><ul><li>抽象类不能被实例化，只能被继承。</li><li>抽象类中的抽象方法必须被子类实现。</li></ul><p>抽象类不能被实例化：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> Animal&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal() <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><p>抽象类中的抽象方法必须被子类实现：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> eat (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">  <span class="comment">// 子类必须实现抽象类中的抽象方法</span></span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'person is eating'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'why'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// why</span></span><br><span class="line">person.eat()                <span class="comment">// person is eating</span></span><br></pre></td></tr></table></figure></p><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><blockquote><p>tip<br>一个类可以实现一个或者多个接口，用逗号分隔。</p></blockquote><p>如果我们定义了一个接口，然后类去实现它，那么这个接口中的属性和方法，在类中必须全部都要存在，否则会编译报错。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>在上面的案例中，我们使用到了类实现接口，其实一个接口还可以继承自另外一个接口。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="comment">// Person接口继承了Animal，就拥有了Animal种所有的属性和方法</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Person &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayHello () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>在有些语言中，接口一般而言是不能继承类的，但在<code>TypeScript</code>中是可以继承的，接口继承类以后，就拥有类中所有的属性和方法。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  y: <span class="number">10</span>,</span><br><span class="line">  z: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(point3d)  <span class="comment">// &#123; x: 10, y: 10, z: 10 &#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型<code>generics</code>是指在定义函数、接口和类的时候，不预先指定其具体类型，而在使用的时候再去指定的一种特性。</p><h4 id="函数中的泛型"><a href="#函数中的泛型" class="headerlink" title="函数中的泛型"></a>函数中的泛型</h4><p>假设我们有如下一个函数，其中参数<code>a</code>和<code>b</code>接受的类型必须为相同的类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在没有了解到泛型之前，我们可以用联合类型来定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码分析：在以上的例子中，我们仅仅只是规定了<code>a</code>和<code>b</code>参数必须是<code>number</code>类型或者<code>string</code>类型，但并没有办法来限制<code>a</code>和<code>b</code>必须是同一个类型。这个时候我们可以使用泛型来表示：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>&gt; (<span class="params">a: T, b: T</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：我们在调用<code>join()</code>函数并进行传参的时候，<code>TypeScript</code>会自动帮我们推断参数的类型，以上三行代码也可以像如下方式进行撰写：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">string</span>&gt;(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>泛型可以是多个的。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt; (<span class="params">a: T, b: P</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 12    </span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(join(<span class="number">1</span>, <span class="string">'2'</span>))   <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>代码分析：在以上的案例中，<code>join</code>方法接受2个泛型类型，其中参数<code>a:T</code>，参数<code>b:p</code>，因此<code>console.log(join(1, &#39;2&#39;))</code>会正确被编译并输出12。</p><h4 id="类中的泛型"><a href="#类中的泛型" class="headerlink" title="类中的泛型"></a>类中的泛型</h4><p>泛型同样可以使用在类中。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CreateClass&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createNumber = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">createNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createString = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">createString.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createNumber.add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(createString.add(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><blockquote><p>tip<br>在<a href="mailto:`TypeScript@2.3" target="_blank" rel="noopener">`TypeScript@2.3</a>+`以后的版本，我们可以为泛型提供一个默认值。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CreateClass&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  zeroValue: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createNumber = <span class="keyword">new</span> CreateClass()</span><br><span class="line">createNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createString = <span class="keyword">new</span> CreateClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">createString.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createNumber.add(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(createString.add(<span class="string">'1'</span>, <span class="string">'2'</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>代码分析：在<code>CreateClass</code>类的定义部分，我们为泛型提供了一个默认值<code>number</code>，因此我们在实例<code>createNumber</code>初始化的时候就可以不用传递<code>number</code>了。</p><h4 id="接口中的泛型"><a href="#接口中的泛型" class="headerlink" title="接口中的泛型"></a>接口中的泛型</h4><p>像在类中一样，泛型可以存在于接口中。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArray &#123;</span><br><span class="line">  &lt;T&gt;(length: <span class="built_in">number</span>, value: T): T[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> createArrayFunc: CreateArray = <span class="function"><span class="keyword">function</span> (<span class="params">length, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    result[index] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createArrayFunc(<span class="number">3</span>, <span class="string">'AAA'</span>))  <span class="comment">// ['AAA', 'AAA', 'AAA']</span></span><br><span class="line"><span class="built_in">console</span>.log(createArrayFunc(<span class="number">2</span>, <span class="literal">true</span>))   <span class="comment">// [true, true]</span></span><br></pre></td></tr></table></figure></p><h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。<br>声明合并，我们在上面已经有实例的案例了，那就是函数的重载。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">''</span> + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'1'</span>, <span class="string">'2'</span>))  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><p>当重复定义同一个接口时，会进行接口合并：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p> warning<br>当合并的属性类型不一致时，会报错。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="comment">// 报错，name类型冲突</span></span><br><span class="line">  name: <span class="built_in">number</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在我们以上所有案例中，我们编写的代码大多数是运行在<code>Node</code>环境下的，接下来我们来编写一些代码，让其在浏览器环境中运行。</p><p>首先我们需要创建如下的项目以及目录结构：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-- TypeScript</span><br><span class="line">|   |-- dist</span><br><span class="line">|   |   |-- index.html</span><br><span class="line">|   |-- src</span><br><span class="line">|   |   |-- page.ts</span><br><span class="line">|   |-- tsconfig.json</span><br></pre></td></tr></table></figure></p><p>其中，<code>tsconfig.json</code>的配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                </span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist"</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./src"</span>, </span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在配置完<code>tsconfig.json</code>以后，我们来撰写<code>page.ts</code>中的代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Header &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Header'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Content &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Content'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Footer &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.innerHTML = <span class="string">'Footer'</span></span><br><span class="line">    <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Page &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Header()</span><br><span class="line">    <span class="keyword">new</span> Content()</span><br><span class="line">    <span class="keyword">new</span> Footer()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写完以上代码后，我们运行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译src下的*.ts文件到dist目录下</span></span><br><span class="line">$ tsc</span><br></pre></td></tr></table></figure></p><p>随后我们在<code>dist/index.html</code>中引用我们刚刚编译的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Page()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当我们在浏览器中运行<code>index.html</code>文件后，我们可以在浏览器下正确的看到我们想要的输出内容。</p><p>当我们在打开<code>page.js</code>文件时，我们可以发现：<br><img src="/2024/08/01/TypeScript教程-一/1.png" alt="page.js代码"></p><p><strong>在全局作用域环境下，我们一次性引入了四个全局变量</strong>：<code>Header</code>、<code>Content</code>、<code>Footer</code>和<code>Page</code>。要解决这个问题，我们可以使用<code>namespace</code>命令空间：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名空间包裹我们的代码并把Page类导出出去</span></span><br><span class="line"><span class="keyword">namespace</span> Home &#123;</span><br><span class="line">  <span class="keyword">class</span> Header &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Header'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> Content &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Content'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> Footer &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.innerHTML = <span class="string">'Footer'</span></span><br><span class="line">      <span class="built_in">document</span>.body.append(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Page &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> Header()</span><br><span class="line">      <span class="keyword">new</span> Content()</span><br><span class="line">      <span class="keyword">new</span> Footer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随后，再次使用<code>tsc</code>命令重新编译代码，编译后的<code>page.js</code>如下：<br><img src="/2024/08/01/TypeScript教程-一/2.png" alt="Page.js代码"></p><p>再次修改<code>index.html</code>中的代码，我们依然能够得到跟前面示例代码一样的输出结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./page.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Home.Page()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript基础教程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>electron基础入门</title>
    <link href="/2024/07/17/electron%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>/2024/07/17/electron基础入门/</id>
    <published>2024-07-17T01:22:37.000Z</published>
    <updated>2025-06-24T03:15:44.283Z</updated>
    
    <content type="html"><![CDATA[<p>electron+vue3+pinia构建一个桌面应用<br><a id="more"></a><br>Electron是使用JavaScript，HTML和CSS构建跨平台的桌面应用程序框架。Electron兼容Mac、Windows和Linux，可以构建出三个平台的应用程序。</p><p>本教程使用vite+vue3+pinia配合electron开发一个桌面应用。</p><blockquote><p>app应用功能，点击添加按钮，弹出dialog，填写内容后提交，将内容保存在<code>public/files</code>文件夹下，并且当前列表会展示出目前的文件列表。点击相应的文件会跳转到详情页展示。</p></blockquote><h1 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h1><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><h3 id="安装vue3"><a href="#安装vue3" class="headerlink" title="安装vue3"></a>安装vue3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>按照命令行提示输入项目名<code>base-tutorial</code>,之后选择<code>vue</code>项目，语言<code>javascript</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd base-tutorial</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>通过上边的命令可以启动vue3项目了。</p><h2 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h2><h3 id="安装electron"><a href="#安装electron" class="headerlink" title="安装electron"></a>安装electron</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron -D</span><br></pre></td></tr></table></figure><p>electron比较大，根据网络情况可能会安装失败，多尝试几次。</p><h3 id="安装nodemon"><a href="#安装nodemon" class="headerlink" title="安装nodemon"></a>安装nodemon</h3><p>开发方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon -D</span><br></pre></td></tr></table></figure></p><p>之后在<code>package.json</code>中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;nodemon --exec electron . --watch ./ --ext .js,.html,.css,.vue&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>监控<code>.js,.html,.css,.vue</code>这些文件变化，自动重启<code>electron</code>应用。</p><h3 id="安装electron-win-state"><a href="#安装electron-win-state" class="headerlink" title="安装electron-win-state"></a>安装electron-win-state</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-win-state --save</span><br></pre></td></tr></table></figure><p><code>electron-win-state</code>可以记录应用上次关闭前窗口大小和位置。</p><h3 id="编写electron应用"><a href="#编写electron应用" class="headerlink" title="编写electron应用"></a>编写electron应用</h3><p>在<code>package.json</code>中添加<code>electron</code>应用的主入口文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;main.js&quot;</span><br></pre></td></tr></table></figure></p><p>在项目根目录下新建<code>main.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; app, BrowserWindow &#125; from &apos;electron&apos;;</span><br><span class="line">import WinState from &apos;electron-win-state&apos;; // 保存窗口位置和大小的调整</span><br><span class="line"></span><br><span class="line">const createWindow = ()=&gt; &#123;</span><br><span class="line">  const winState = new WinState.default(&#123;</span><br><span class="line">    defaultWidth: 1000,</span><br><span class="line">    defaultHeight: 800,</span><br><span class="line">    electronStoreOptions: &#123;</span><br><span class="line">      name: &apos;window-state-main&apos; // 开启多个窗口的时候分别记录</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  const win = new BrowserWindow(&#123;</span><br><span class="line">    ...winState.winOptions,</span><br><span class="line">    show: false,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  win.loadURL(&apos;http://localhost:5173&apos;);</span><br><span class="line">  win.webContents.openDevTools();</span><br><span class="line">  winState.manage(win);</span><br><span class="line">  win.on(&apos;ready-to-show&apos;, ()=&gt; &#123;</span><br><span class="line">    win.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().then(()=&gt; &#123;</span><br><span class="line">  createWindow();</span><br><span class="line"></span><br><span class="line">  app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class="line">    if (BrowserWindow.getAllWindows().length === 0) &#123;</span><br><span class="line">      createWindow()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行<code>npm start</code>,app顺利启动<br>但是在调试工具打印台会看到<code>Electron Security Warning (Insecure Content-Security-Policy)</code>警告，解决办法是在index.html中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;self&apos;; img-src &apos;self&apos; data:; style-src &apos;self&apos; &apos;unsafe-inline&apos;&quot;&gt;</span><br></pre></td></tr></table></figure></p><h1 id="添加新功能"><a href="#添加新功能" class="headerlink" title="添加新功能"></a>添加新功能</h1><p>添加路由，状态管理，ui库，css预编译，css初始化，lodash等</p><h2 id="安装对应的库"><a href="#安装对应的库" class="headerlink" title="安装对应的库"></a>安装对应的库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router --save</span><br><span class="line">npm i stylus --save</span><br><span class="line">npm i pinia --save</span><br><span class="line">npm i normalize.css --save</span><br><span class="line">npm i lodash --save</span><br><span class="line">npm i element-plus --save</span><br></pre></td></tr></table></figure><h2 id="改造vue内容"><a href="#改造vue内容" class="headerlink" title="改造vue内容"></a>改造vue内容</h2><h3 id="修改App-vue"><a href="#修改App-vue" class="headerlink" title="修改App.vue"></a>修改App.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;electron基础入门&lt;/h1&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>添加路由插槽<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><h3 id="新建views"><a href="#新建views" class="headerlink" title="新建views"></a>新建views</h3><p>在<code>src</code>目录下，新建<code>views</code>文件夹<br>在<code>views</code>下新建<code>Home.vue，Detail.vue</code>文件</p><h3 id="新建router"><a href="#新建router" class="headerlink" title="新建router"></a>新建router</h3><p>在<code>src</code>目录下，新建<code>router</code>文件夹<br>在<code>router</code>下新建<code>index.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createRouter, createWebHashHistory &#125; from &apos;vue-router&apos;;</span><br><span class="line">import Home from &apos;@/views/Home.vue&apos;;</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    redirect: &apos;/home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/home&apos;,</span><br><span class="line">    name: &apos;home&apos;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/detail&apos;,</span><br><span class="line">    name: &apos;detail&apos;,</span><br><span class="line">    component: ()=&gt; import(&apos;@/views/Detail.vue&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure></p><h3 id="修改Home-vue"><a href="#修改Home-vue" class="headerlink" title="修改Home.vue"></a>修改Home.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted, nextTick &#125; from &apos;vue&apos;;</span><br><span class="line">import useLoadingStore from &apos;../store/loading&apos;;</span><br><span class="line">import List from &apos;./List.vue&apos;;</span><br><span class="line"></span><br><span class="line">const loadingSotate = useLoadingStore();</span><br><span class="line"></span><br><span class="line">const dialogVisible = ref(false);</span><br><span class="line">const list = ref([]);</span><br><span class="line">const refForm = ref(null);</span><br><span class="line">const form = reactive(&#123;</span><br><span class="line">  title: &apos;&apos;,</span><br><span class="line">  city: &apos;&apos;,</span><br><span class="line">  desc: &apos;&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">const rules = &#123;</span><br><span class="line">  title: [</span><br><span class="line">    &#123; required: true, message: &apos;请输入题目&apos;, trigger: &apos;blur&apos; &#125;  </span><br><span class="line">  ],</span><br><span class="line">  city: [</span><br><span class="line">    &#123; required: true, message: &apos;请选择城市&apos;, trigger: &apos;change&apos; &#125;  </span><br><span class="line">  ],</span><br><span class="line">  desc: [</span><br><span class="line">    &#123; required: true, message: &apos;请输入描述&apos;, trigger: &apos;blur&apos; &#125;  </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">const onAdd = ()=&gt; &#123;</span><br><span class="line">  dialogVisible.value = true;</span><br><span class="line">  nextTick(()=&gt; &#123;</span><br><span class="line">    refForm.value.resetFields();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const sunmitHandle = ()=&gt; &#123;</span><br><span class="line">  refForm.value.validate(async valid=&gt; &#123;</span><br><span class="line">    if(valid) &#123;</span><br><span class="line">      dialogVisible.value = false;</span><br><span class="line">      loadingSotate.set(true);</span><br><span class="line">      // 调用渲染进程提供的方法</span><br><span class="line">      await rendererApi.saveText(JSON.stringify(form));</span><br><span class="line">      loadingSotate.set(false);</span><br><span class="line">      getList();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const getList = async ()=&gt; &#123;</span><br><span class="line">  list.value = await rendererApi.getText();</span><br><span class="line">&#125;</span><br><span class="line">// 主进程调用vue侧的函数</span><br><span class="line">rendererApi.showAddDialog(()=&gt; &#123;</span><br><span class="line">  onAdd();</span><br><span class="line">&#125;);</span><br><span class="line">onMounted(async ()=&gt; &#123;</span><br><span class="line">  getList();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;onAdd&quot;&gt;+&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;List :listData=&quot;list&quot;&gt;&lt;/List&gt;</span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      v-model=&quot;dialogVisible&quot;</span><br><span class="line">      title=&quot;添加内容&quot;</span><br><span class="line">      width=&quot;80%&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;el-form :model=&quot;form&quot; ref=&quot;refForm&quot; :rules=&quot;rules&quot; label-width=&quot;auto&quot; style=&quot;max-width: 600px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;题目&quot; prop=&quot;title&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.title&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;城市&quot; prop=&quot;city&quot;&gt;</span><br><span class="line">        &lt;el-select v-model=&quot;form.city&quot; placeholder=&quot;请选择城市&quot;&gt;</span><br><span class="line">          &lt;el-option label=&quot;沈阳&quot; value=&quot;沈阳&quot; /&gt;</span><br><span class="line">          &lt;el-option label=&quot;大连&quot; value=&quot;大连&quot; /&gt;</span><br><span class="line">        &lt;/el-select&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;描述&quot; prop=&quot;desc&quot;&gt;</span><br><span class="line">        &lt;el-input v-model=&quot;form.desc&quot; type=&quot;textarea&quot; :row=&quot;5&quot; /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">      &lt;template #footer&gt;</span><br><span class="line">        &lt;div class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">          &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button type=&quot;primary&quot; @click=&quot;sunmitHandle&quot;&gt;</span><br><span class="line">            确定</span><br><span class="line">          &lt;/el-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="修改Detail-vue"><a href="#修改Detail-vue" class="headerlink" title="修改Detail.vue"></a>修改Detail.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useRoute, useRouter &#125; from &apos;vue-router&apos;;</span><br><span class="line"></span><br><span class="line">const route = useRoute();</span><br><span class="line">const router = useRouter();</span><br><span class="line">const query = route.query;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;go-back&quot;&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;router.go(-1)&quot;&gt;返回&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; query.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;来自-&#123;&#123; query.city &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;pre&gt;&#123;&#123; query.desc &#125;&#125;&lt;/pre&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.go-back &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="添加pinia"><a href="#添加pinia" class="headerlink" title="添加pinia"></a>添加pinia</h3><p>在<code>src</code>下新建<code>store</code>文件夹，新建<code>loading.js</code>文件。<br>此文件内容控制<code>Loading</code>组件显示隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &apos;pinia&apos;;</span><br><span class="line">const useLoadingStore = defineStore(&apos;websiteStore&apos;, &#123;</span><br><span class="line">state() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">bShow: false</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line">set(val) &#123;</span><br><span class="line">this.bShow = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">getBShow() &#123;</span><br><span class="line">      return this.bShow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">export default useLoadingStore;</span><br></pre></td></tr></table></figure></p><h3 id="添加loading"><a href="#添加loading" class="headerlink" title="添加loading"></a>添加loading</h3><p>在<code>App.vue</code>文件夹下添加<code>Loading</code>组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import useLoadingStore from &apos;../store/loading&apos;;</span><br><span class="line"></span><br><span class="line">const loadingSotate = useLoadingStore();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;loading-wrap&quot; v-if=&quot;loadingSotate.getBShow&quot;&gt;</span><br><span class="line">    &lt;svg class=&quot;circular&quot; viewBox=&quot;0 0 50 50&quot;&gt;&lt;circle class=&quot;path&quot; cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;20&quot; fill=&quot;none&quot;&gt;&lt;/circle&gt;&lt;/svg&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.loading-wrap &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background-color: rgba(255, 255, 255, .8);</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  .circular &#123;</span><br><span class="line">    stroke: #000000;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    animation: loading-rotate .5s linear infinite alternate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes loading-rotate &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">    opacity: 0</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(1.2);</span><br><span class="line">    opacity: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>比如在Home页面控制Loading组件显示隐藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loadingSotate.set(true);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  loadingSotate.set(false);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure></p><p>显示后3秒隐藏</p><h2 id="改造electron内容"><a href="#改造electron内容" class="headerlink" title="改造electron内容"></a>改造electron内容</h2><p><code>vue</code>侧提交内容后，需要将内容保存到文件里。需要修改<code>electron</code>的主进程和渲染进程</p><h3 id="electron主进程"><a href="#electron主进程" class="headerlink" title="electron主进程"></a>electron主进程</h3><h4 id="在main-js里新增"><a href="#在main-js里新增" class="headerlink" title="在main.js里新增"></a>在<code>main.js</code>里新增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webPreferences: &#123;</span><br><span class="line">  preload: path.resolve(__dirname, &apos;./preload/index.js&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>引入渲染进程文件。</p><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>在根目录下新建<code>controller</code>文件夹，再新建<code>saveText.js</code>文件，用于保存<code>vue</code>侧保存的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ipcMain &#125; from &apos;electron&apos;;</span><br><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import fs from &apos;fs&apos;;</span><br><span class="line">import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;</span><br><span class="line"></span><br><span class="line">ipcMain.handle(&apos;on-save-text-event&apos;, (e, str)=&gt; &#123;</span><br><span class="line">  const data = JSON.parse(str);</span><br><span class="line">  const filePath = path.resolve(__dirnameFn(import.meta.url), &apos;../public/files/&apos;, data.title + &apos;-&apos; + data.city + &apos;.txt&apos;);</span><br><span class="line">  fs.writeFileSync(filePath, data.desc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>ipcMain.handle</code>用来注册事件，渲染进程可以触发这个事件的回调函数。</p><h3 id="electron渲染进程"><a href="#electron渲染进程" class="headerlink" title="electron渲染进程"></a>electron渲染进程</h3><p>在根目录下新建<code>preload</code>文件夹，再新建<code>index.js</code>文件，这里都是渲染进程的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; contextBridge, ipcRenderer &#125; = require(&apos;electron&apos;)</span><br><span class="line"></span><br><span class="line">const saveText = async data=&gt; &#123;</span><br><span class="line">  let result = await ipcRenderer.invoke(&apos;on-save-text-event&apos;, data);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">contextBridge.exposeInMainWorld(&apos;myApi&apos;, &#123;</span><br><span class="line">  saveText,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>渲染进程将<code>saveText</code>这个方法暴露给vue侧，可以<code>window.saveText</code>来调用，调用时，渲染进程会触发主进程注册的对应事件的回调函数完成保存文件的功能。</p><blockquote><p>通过vue侧-&gt;渲染进程-&gt;主进程,也就是vue侧向主进程发起的通讯，后边还会实现electron主进程向vue侧发起的通讯。</p></blockquote><h2 id="后续修改略"><a href="#后续修改略" class="headerlink" title="后续修改略"></a>后续修改略</h2><p>之后还会对vue侧，渲染进程，主进程代码修改，这里就不一一列举。思路还是主进程注册事件，渲染进程暴漏给vue侧全局方法调用来触发主进程的事件回调函数。</p><h2 id="自定义Menu"><a href="#自定义Menu" class="headerlink" title="自定义Menu"></a>自定义Menu</h2><p>可以自定义<code>Menu</code>，这里为了使用主进程-&gt;渲染进程-&gt;vue侧的通讯，也就是在菜单中点击按钮，调用vue侧的一个方法。<br>这个流程与上面vue侧-&gt;渲染进程-&gt;主进程的调用正好相反。</p><h3 id="渲染进程新增事件注册"><a href="#渲染进程新增事件注册" class="headerlink" title="渲染进程新增事件注册"></a>渲染进程新增事件注册</h3><p>在preload的index.js中，新增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主进程触发渲染进程</span><br><span class="line">const showAddDialog = cb=&gt; ipcRenderer.on(&apos;on-show-add-dialog-event&apos;, (e, value)=&gt; &#123;</span><br><span class="line">  cb(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="vue侧调用"><a href="#vue侧调用" class="headerlink" title="vue侧调用"></a>vue侧调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主进程调用vue侧的函数</span><br><span class="line">rendererApi.showAddDialog(()=&gt; &#123;</span><br><span class="line">  onAdd();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="新建buildMenu-js"><a href="#新建buildMenu-js" class="headerlink" title="新建buildMenu.js"></a>新建buildMenu.js</h3><p>在<code>controller</code>下新建<code>buildMenu.js</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">import &#123; app, Menu, ipcMain &#125; from &apos;electron&apos;;</span><br><span class="line">import &#123; inject &#125; from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">const isMac = process.platform === &apos;darwin&apos;;</span><br><span class="line"></span><br><span class="line">let mainWindow = null;</span><br><span class="line"></span><br><span class="line">const template = [</span><br><span class="line">  // &#123; role: &apos;appMenu&apos; &#125;</span><br><span class="line">  ...(isMac</span><br><span class="line">    ? [&#123;</span><br><span class="line">        label: app.name,</span><br><span class="line">        submenu: [</span><br><span class="line">          &#123; role: &apos;about&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;services&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;hide&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;hideOthers&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;unhide&apos; &#125;,</span><br><span class="line">          &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">          &#123; role: &apos;quit&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;]</span><br><span class="line">    : []),</span><br><span class="line">  // &#123; role: &apos;fileMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;File&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      isMac ? &#123; role: &apos;close&apos; &#125; : &#123; role: &apos;quit&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;editMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;Edit&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;undo&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;redo&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;cut&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;copy&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;paste&apos; &#125;,</span><br><span class="line">      ...(isMac</span><br><span class="line">        ? [</span><br><span class="line">            &#123; role: &apos;pasteAndMatchStyle&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;delete&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;selectAll&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              label: &apos;Speech&apos;,</span><br><span class="line">              submenu: [</span><br><span class="line">                &#123; role: &apos;startSpeaking&apos; &#125;,</span><br><span class="line">                &#123; role: &apos;stopSpeaking&apos; &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        : [</span><br><span class="line">            &#123; role: &apos;delete&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;selectAll&apos; &#125;</span><br><span class="line">          ])</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;viewMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;View&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;reload&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;forceReload&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;toggleDevTools&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;resetZoom&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoomIn&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoomOut&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;togglefullscreen&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // &#123; role: &apos;windowMenu&apos; &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;Window&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123; role: &apos;minimize&apos; &#125;,</span><br><span class="line">      &#123; role: &apos;zoom&apos; &#125;,</span><br><span class="line">      ...(isMac</span><br><span class="line">        ? [</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;front&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;separator&apos; &#125;,</span><br><span class="line">            &#123; role: &apos;window&apos; &#125;</span><br><span class="line">          ]</span><br><span class="line">        : [</span><br><span class="line">            &#123; role: &apos;close&apos; &#125;</span><br><span class="line">          ])</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    role: &apos;help&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: &apos;Learn More&apos;,</span><br><span class="line">        click: async () =&gt; &#123;</span><br><span class="line">          const &#123; shell &#125; = require(&apos;electron&apos;)</span><br><span class="line">          await shell.openExternal(&apos;https://electronjs.org&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: &apos;actions&apos;,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: &apos;添加&apos;,</span><br><span class="line">        click: async ()=&gt; &#123;</span><br><span class="line">          // 触发renderer进程的on-show-add-dialog-event事件</span><br><span class="line">          mainWindow.webContents.send(&apos;on-show-add-dialog-event&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        accelerator: &apos;CommandOrControl+Alt+O&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const menu = Menu.buildFromTemplate(template)</span><br><span class="line">Menu.setApplicationMenu(menu)</span><br><span class="line">export const injectMainWindow = win=&gt; &#123;</span><br><span class="line">  mainWindow = win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在<code>vue</code>侧调用渲染进程暴露的函数，把需要执行的<code>vue</code>侧回调函数传进去。</li><li>渲染进程函数执行后注册了<code>on-show-add-dialog-event</code>这个渲染进程事件。</li><li><code>Menu</code>菜单点击后，主进程触发渲染进程事件，这个事件的回调函数中会执行<code>vue</code>侧提供的回调函数。</li></ul><p>通过上述步骤即可完成主进程-&gt;渲染进程-&gt;<code>vue</code>侧的通信</p><h1 id="托盘-amp-app图标"><a href="#托盘-amp-app图标" class="headerlink" title="托盘&amp;app图标"></a>托盘&amp;app图标</h1><h2 id="mac端"><a href="#mac端" class="headerlink" title="mac端"></a>mac端</h2><p>在<code>controller</code>下新建<code>tray.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 兼容mac电脑</span><br><span class="line">import &#123; Tray &#125; from &apos;electron&apos;;</span><br><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import &#123; __dirnameFn &#125; from &apos;../utils.js&apos;;</span><br><span class="line"></span><br><span class="line">const createTray = (app, win)=&gt; &#123;</span><br><span class="line">  const tray = new Tray(path.resolve(__dirnameFn(import.meta.url), &apos;../icon.png&apos;));</span><br><span class="line">  tray.setToolTip(&apos;electron-tutorial&apos;);</span><br><span class="line">  tray.on(&apos;click&apos;, e=&gt; &#123;</span><br><span class="line">    if(e.shiftKey) &#123;</span><br><span class="line">      app.quit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default createTray;</span><br></pre></td></tr></table></figure></p><p>在<code>main.js</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// tray 兼容mac托盘</span><br><span class="line">import createTray from &apos;./controller/tray.js&apos;;</span><br><span class="line"></span><br><span class="line">createTray(app, win);</span><br></pre></td></tr></table></figure></p><h2 id="window端"><a href="#window端" class="headerlink" title="window端"></a>window端</h2><p>在<code>main.js</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icon: nativeImage.createFromPath(path.resolve(__dirnameFn(import.meta.url), &apos;./icon.png&apos;)),</span><br></pre></td></tr></table></figure></p><h1 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h1><p>全屏功能可以应用在一些终端设备中，比如商场或者机场的自助终端。<br>在<code>main.js</code>中增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 取消浏览器头部菜单栏</span><br><span class="line">frame: false</span><br><span class="line">// 设置全屏</span><br><span class="line">win.maximize();</span><br></pre></td></tr></table></figure></p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @electron-forge/cli -D</span><br><span class="line">npm i @electron-forge/maker-squirrel -D</span><br></pre></td></tr></table></figure></p><h3 id="window端-1"><a href="#window端-1" class="headerlink" title="window端"></a>window端</h3><p>在根目录下新增<code>forge.config.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  makers: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;@electron-forge/maker-squirrel&apos;,</span><br><span class="line">      config: &#123;</span><br><span class="line">        certificateFile: &apos;./cert.pfx&apos;,</span><br><span class="line">        certificatePassword: process.env.CERTIFICATE_PASSWORD</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;make&quot;: &quot;electron-forge make&quot;</span><br></pre></td></tr></table></figure></p><p>执行<code>npm run make</code>,（网络不好有时会失败，重试几次），在根目录输出一个<code>out</code>文件夹。在里边找到项目名称的<code>exe</code>文件就是可执行app。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-packager -D</span><br></pre></td></tr></table></figure></p><h3 id="window端-2"><a href="#window端-2" class="headerlink" title="window端"></a>window端</h3><p>配置可以直接写在scripts脚本中,<code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;make2&quot;: &quot;electron-packager . godex-printer --platform=win32 --arch=x64 --icon=build/icon.ico --out=out --overwrite&quot;</span><br></pre></td></tr></table></figure></p><p>这个打包方式比第一个要快很多，<code>--icon=build/icon.ico</code>这个参数是生成的exe图标设置</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><blockquote><p>此方法可以打包生成安装文件</p></blockquote><p><code>electron</code>打包需要打包工具，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-builder -D</span><br></pre></td></tr></table></figure></p><p>在项目根目录下创建<code>electron-builder.yml</code>文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nsis:</span><br><span class="line">  oneClick: false # 创建一键安装程序还是辅助安装程序（默认是一键安装）</span><br><span class="line">  allowElevation: true # 是否允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序 （仅作用于辅助安装程序）</span><br><span class="line">  allowToChangeInstallationDirectory: true # 是否允许修改安装目录 （仅作用于辅助安装程序）</span><br><span class="line">  createStartMenuShortcut: true # 是否创建开始菜单快捷方式</span><br><span class="line">  artifactName: $&#123;productName&#125;-$&#123;version&#125;-$&#123;platform&#125;-$&#123;arch&#125;.$&#123;ext&#125;</span><br><span class="line">  shortcutName: $&#123;productName&#125;</span><br><span class="line">  uninstallDisplayName: $&#123;productName&#125;</span><br><span class="line">  createDesktopShortcut: always</span><br></pre></td></tr></table></figure></p><p>在<code>package.json</code>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;makebuilder&quot;: &quot;electron-builder --win --config&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>第一次执行打包时需要下载打包工具，根据网络实际情况可能会失败，多尝试几次。<br>打包后在<code>dist</code>目录下的<code>.exe</code>文件就是安装执行文件，双击下一步即可安装。</p><h2 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h2><p>开发调试时，<code>main.js</code>中，引入<code>vue</code>侧是<code>win.loadURL(&#39;http://localhost:5173&#39;);</code>这样引入的，这样打包的话，执行<code>app</code>应用时还需要启动<code>vue</code>项目才可以使用。<br>如果想直接把<code>vue</code>侧直接打到<code>app</code>应用包中，修改<code>main.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// win.loadURL(&apos;http://localhost:5173&apos;);</span><br><span class="line">win.loadFile(path.resolve(__dirnameFn(import.meta.url), &apos;./dist/index.html&apos;));</span><br></pre></td></tr></table></figure></p><p>还需要修改<code>dist/index.html</code>中引入的js和css的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="line">&lt;!-- &lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;/assets/index-CrynHw1J.css&quot;&gt; --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-W5Tu2U3a.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; crossorigin href=&quot;./assets/index-CrynHw1J.css&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>将绝对路径改成相对路径。</p><h2 id="打包后resources文件加密"><a href="#打包后resources文件加密" class="headerlink" title="打包后resources文件加密"></a>打包后resources文件加密</h2><p>在打包之后，输出的可执行exe文件夹下有一个resources文件夹，里边是源代码，因为执行时需要这些源代码文件，不能删除。但是，代码暴露了，为了安全，可以使用<code>asar</code>对源代码封装加密。</p><h3 id="安装asar"><a href="#安装asar" class="headerlink" title="安装asar"></a>安装asar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局安装</span><br><span class="line">npm i -g asar</span><br></pre></td></tr></table></figure><h3 id="执行asar封装源码"><a href="#执行asar封装源码" class="headerlink" title="执行asar封装源码"></a>执行asar封装源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asar pack src src.asar</span><br></pre></td></tr></table></figure><p>将src文件夹封装成了src.asar</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>比如，之前<code>main.js</code>文件需要调用<code>src</code>文件夹里的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./src/index.js&apos;;</span><br></pre></td></tr></table></figure></p><p>封装之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./src.asar/index.js&apos;;</span><br></pre></td></tr></table></figure></p><p>就这么简单，重新打包之后在resources下可以看到src.asar文件了，asar文件轻易破解不了的，起到了一定的安全性，这时可以把文件夹下src源代码删除，提供给客户使用。</p><h1 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h1><p>使用<code>electron-updater</code>实现应用更新<br>详情暂略</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上完成了一个简单的electron+vue的项目。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>本教程代码<a href="https://github.com/jinux7/study-collections/tree/master/electron/base-tutorial" target="_blank" rel="noopener">source</a></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>保存网站的app<br>代码<a href="https://github.com/jinux7/study-collections/tree/master/electron/readit" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;electron+vue3+pinia构建一个桌面应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
      <category term="electron" scheme="/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>pnpm创建monorepo项目</title>
    <link href="/2024/07/04/pnpm%E5%88%9B%E5%BB%BAmonorepo%E9%A1%B9%E7%9B%AE/"/>
    <id>/2024/07/04/pnpm创建monorepo项目/</id>
    <published>2024-07-04T08:15:46.000Z</published>
    <updated>2024-07-05T05:29:50.693Z</updated>
    
    <content type="html"><![CDATA[<p>使用pnpm工具创建monorepo项目<br><a id="more"></a><br>monorepo项目是当下非常流行的，例如React、Vue、Vite等项目都在使用。创建monorepo项目的方法很多，本文使用pnpm来创建。</p><h2 id="全局安装pnpm"><a href="#全局安装pnpm" class="headerlink" title="全局安装pnpm"></a>全局安装pnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>创建一个叫monorepo的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir monorepo</span><br></pre></td></tr></table></figure></p><h2 id="创建相关文件"><a href="#创建相关文件" class="headerlink" title="创建相关文件"></a>创建相关文件</h2><h3 id="初始化package-json"><a href="#初始化package-json" class="headerlink" title="初始化package.json"></a>初始化package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init</span><br></pre></td></tr></table></figure><h3 id="pnpm-workspace-yaml"><a href="#pnpm-workspace-yaml" class="headerlink" title="pnpm-workspace.yaml"></a>pnpm-workspace.yaml</h3><p>新建pnpm-workspace.yaml文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  - &apos;packages/*&apos;</span><br></pre></td></tr></table></figure></p><p>表示packages下是子项目</p><h3 id="npmignore"><a href="#npmignore" class="headerlink" title=".npmignore"></a>.npmignore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/</span><br></pre></td></tr></table></figure><p>这个文件设置发布的时候过滤掉node_modules文件夹的内容</p><h2 id="创建packages文件夹"><a href="#创建packages文件夹" class="headerlink" title="创建packages文件夹"></a>创建packages文件夹</h2><p>在packages下创建子项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir core utils api</span><br></pre></td></tr></table></figure></p><p>创建好三个子项目文件夹后，分别初始化package.json，之后需要修改package.json的name，加上npmjs上所对应的Organizations名字(名字前加@)。<br>再加上<code>&quot;publishConfig&quot;: {&quot;access&quot;: &quot;public&quot;}</code>，用来告诉npmjs这个是公开的（私有是收费的，发布的时候会报错）。<br>core package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/core&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;node ./index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@nux-monorepo/api&quot;: &quot;workspace:^&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>api package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/api&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@nux-monorepo/utils&quot;: &quot;workspace:^&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>utils package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@nux-monorepo/utils&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><h3 id="公共依赖"><a href="#公共依赖" class="headerlink" title="公共依赖"></a>公共依赖</h3><p>在monorepo目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add loadsh -w</span><br></pre></td></tr></table></figure></p><p><code>-w</code>表示在主项目目录下添加依赖</p><h3 id="局部依赖"><a href="#局部依赖" class="headerlink" title="局部依赖"></a>局部依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @nux-monorepo/utils -F @nux-monorepo/api</span><br></pre></td></tr></table></figure><p>表示给<code>@nux-monorepo/api</code>子项目添加了一个<code>@nux-monorepo/utils</code>的依赖。<br>再加一个依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add @nux-monorepo/api -F @nux-monorepo/core</span><br></pre></td></tr></table></figure></p><p>可以看上边的package.json文件,添加依赖后的效果。<br>上边公共依赖和局部依赖执行命令都是在项目的根目录下执行即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以在子项目中运行<code>npm run dev</code>去执行,也可以在主项目下直接执行,在主项目的package.json下添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev:core&quot;: &quot;pnpm -F @nux-monorepo/core dev&quot;</span><br></pre></td></tr></table></figure></p><p>运行结果跟在子项目中是一样的。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="普通发布"><a href="#普通发布" class="headerlink" title="普通发布"></a>普通发布</h3><ul><li>在npmjs官网有一个账号</li><li>在npmjs新建一个Organizations,这个名字就是子项目package.json中name的前缀,<code>@nux-monorepo/core</code>中的<code>nux-monorepo</code></li><li>进入到子项目,执行<code>pnpm publish</code>,注意,这里需要把npm的源设置成官网的<code>https://registry.npmjs.org/</code>(因为npmjs的官方源下载速度慢，平时都会切换国内的镜像地址，这里需要注意下)</li></ul><p>每次发布时需要修改version版本号，一样的话发布会失败。</p><h3 id="脚本发布"><a href="#脚本发布" class="headerlink" title="脚本发布"></a>脚本发布</h3><p>上面的发布需要进入到每个子项目进行发布，非常麻烦，可以编写一个脚本，进行批量发布。<br>这里还有一点，可以在脚本中修改版本号，可以根据不同的规则修改，本文简单起见，把子项目中的version版本号都设置成主项目里的version，但是发布前主项目的version需要手动修改一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const &#123; exec &#125; = require(&apos;child_process&apos;);</span><br><span class="line"></span><br><span class="line">const packagesRoot = &apos;./packages&apos;;</span><br><span class="line">const packageName = &apos;package.json&apos;;</span><br><span class="line">let version;</span><br><span class="line">// 获取主项目package.json中的version</span><br><span class="line">let packageData = fs.readFileSync(path.resolve(&apos;./&apos;, packageName), &apos;utf8&apos;);</span><br><span class="line">version = JSON.parse(packageData).version;</span><br><span class="line">// 发布的命令行执行函数</span><br><span class="line">function publishPackage(packageDir) &#123;</span><br><span class="line">    exec(`cd $&#123;packageDir&#125; &amp;&amp; pnpm publish`, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">      if (error) &#123;</span><br><span class="line">        console.error(`Error publishing $&#123;packageDir&#125;:`, error);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(`Published: $&#123;packageDir&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 扫描子项目函数</span><br><span class="line">function scanAndPublish(directory) &#123;</span><br><span class="line">  fs.readdir(directory, &#123; withFileTypes: true &#125;, (err, files) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      console.error(&apos;Error reading directory:&apos;, err);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files.forEach((file) =&gt; &#123;</span><br><span class="line">      if (file.isDirectory()) &#123;</span><br><span class="line">        // 修改package.json中的version</span><br><span class="line">        let packagePath = path.resolve(&apos;./&apos;, packagesRoot, file.name, packageName);</span><br><span class="line">        let packageData = JSON.parse(fs.readFileSync(packagePath, &apos;utf8&apos;));</span><br><span class="line">        packageData.version = version;</span><br><span class="line">        let writeData = JSON.stringify(packageData, null, 2);</span><br><span class="line">        fs.writeFileSync(packagePath, writeData, &apos;utf8&apos;);</span><br><span class="line">        // 发布</span><br><span class="line">        publishPackage(path.dirname(packagePath));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主入口</span><br><span class="line">scanAndPublish(packagesRoot);</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @nux-monorepo/core</span><br></pre></td></tr></table></figure><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/monorepo/pnpm" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用pnpm工具创建monorepo项目&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="npm" scheme="/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>从零打造一个Web地图引擎</title>
    <link href="/2024/07/03/%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AAWeb%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E/"/>
    <id>/2024/07/03/从零打造一个Web地图引擎/</id>
    <published>2024-07-03T01:19:47.000Z</published>
    <updated>2024-07-03T02:27:57.898Z</updated>
    
    <content type="html"><![CDATA[<p>从零开始，实现一个web地图，类似百度地图的效果<br><a id="more"></a><br>本文clone来至<a href="https://github.com/wanglin2/front-article/blob/main/%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AAWeb%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E.md?plain=1" target="_blank" rel="noopener">wanglin2</a></p><p>说到地图，大家一定很熟悉，平时应该都使用过百度地图、高德地图、腾讯地图等，如果涉及到地图相关的开发需求，也有很多选择，比如前面的几个地图都会提供一套<code>js API</code>，此外也有一些开源地图框架可以使用，比如<code>OpenLayers</code>、<code>Leaflet</code>等。</p><p>那么大家有没有想过这些地图是怎么渲染出来的呢，为什么根据一个经纬度就能显示对应的地图呢，不知道没关系，本文会带各位从零实现一个简单的地图引擎，来帮助大家了解<code>GIS</code>基础知识及<code>Web</code>地图的实现原理。</p><h1 id="选个经纬度"><a href="#选个经纬度" class="headerlink" title="选个经纬度"></a>选个经纬度</h1><p>首先我们去高德地图上选个经纬度，作为我们后期的地图中心点，打开<a href="https://lbs.amap.com/tools/picker" target="_blank" rel="noopener">高德坐标拾取</a>工具，随便选择一个点：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/1.png" alt="1.png"></p><p>笔者选择了杭州的雷峰塔，经纬度为：<code>[120.148732,30.231006]</code>。</p><h1 id="瓦片url分析"><a href="#瓦片url分析" class="headerlink" title="瓦片url分析"></a>瓦片url分析</h1><p>地图瓦片我们使用高德的在线瓦片，地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>目前各大地图厂商的瓦片服务遵循的规则是有不同的：</p><blockquote><p>谷歌XYZ规范：谷歌地图、OpenStreetMap、高德地图、geoq、天地图，坐标原点在左上角</p><p>TMS规范：腾讯地图，坐标原点在左下角</p><p>WMTS规范：原点在左上角，瓦片不是正方形，而是矩形，这个应该是官方标准</p><p>百度地图比较特立独行，投影、分辨率、坐标系都跟其他厂商不一样，原点在经纬度都为0的位置，也就是中间，向右为X正方向，向上为Y正方向</p></blockquote><p>谷歌和<code>TMS</code>的瓦片区别可以通过该地址可视化的查看：<a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#1/25.12/-0.61" target="_blank" rel="noopener">地图瓦片</a>。</p><p>虽然规范不同，但原理基本是一致的，都是把地球投影成一个巨大的正方形世界平面图，然后按照四叉树进行分层切割，比如第一层，只有一张瓦片，显示整个世界的信息，所以基本只能看到洲和海的名称和边界线，第二层，切割成四张瓦片，显示信息稍微多了一点，以此类推，就像一个金字塔一样，底层分辨率最高，显示的细节最多，瓦片数也最多，顶层分辨率最低，显示的信息很少，瓦片数量相对也最少：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/2.png" alt="2.png"></p><p>每一层的瓦片数量计算公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(Math.pow(2, n), 2)// 行*列：2^n * 2^n</span><br></pre></td></tr></table></figure><p>十八层就需要<code>68719476736</code>张瓦片，所以一套地图瓦片整体数量是非常庞大的。</p><p>瓦片切好以后，通过行列号和缩放层级来保存，所以可以看到瓦片地址中有三个变量：<code>x</code>、<code>y</code>、<code>z</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x：行号</span><br><span class="line">y：列号</span><br><span class="line">z：分辨率，一般为0-18</span><br></pre></td></tr></table></figure><p>通过这三个变量就可以定位到一张瓦片，比如下面这个地址，行号为<code>109280</code>，列号为<code>53979</code>，缩放层级为<code>17</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>对应的瓦片为：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/3.png" alt="3.png"></p><p>关于瓦片的更多信息可以阅读<a href="https://segmentfault.com/a/1190000011276788" target="_blank" rel="noopener">瓦片地图原理</a>。</p><h1 id="坐标系简介"><a href="#坐标系简介" class="headerlink" title="坐标系简介"></a>坐标系简介</h1><p>高德地图使用的是<code>GCJ-02坐标系</code>，也称火星坐标系，由中国国家测绘局在02年发布，是在GPS坐标（<code>WGS-84</code>坐标系）基础上经加密后而来，也就是增加了非线性的偏移，让你摸不准真实位置，为了国家安全，国内地图服务商都需要使用<code>GCJ-02坐标系</code>。</p><p><code>WGS-84</code>坐标系是国际通用的标准，<code>EPSG</code>编号为<code>EPSG:4326</code>，通常GPS设备获取到的原始经纬度和国外的地图厂商使用的都是<code>WGS-84</code>坐标系。</p><p>这两种坐标系都是地理坐标系，球面坐标，单位为<code>度</code>，这种坐标方便在地球上定位，但是不方便展示和进行面积距离计算，我们印象中的地图都是平面的，所以就有了另外一种平面坐标系，平面坐标系是通过投影的方式从地理坐标系中转换过来，所以也称为投影坐标系，通常单位为<code>米</code>，投影坐标系根据投影方式的不同存在多种，在<code>Web</code>开发的场景里通常使用的是<code>Web墨卡托投影</code>，编号为<code>EPSG:3857</code>，它基于<code>墨卡托投影</code>，把<code>WGS-84</code>坐标系投影成正方形：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/4.png" alt="4.png"></p><p>这是通过舍弃了南北<code>85.051129纬度</code>以上的地区实现的，因为它是正方形，所以一个大的正方形可以很方便的被分割为更小的正方形。</p><p>坐标系更详细的信息可参考<a href="https://juejin.cn/post/6924478988307922957" target="_blank" rel="noopener">GIS之坐标系统</a>，<code>EPSG:3857</code>的详细信息可参考<a href="http://epsg.io/3857" target="_blank" rel="noopener">EPSG:3857</a>。</p><h1 id="经纬度定位行列号"><a href="#经纬度定位行列号" class="headerlink" title="经纬度定位行列号"></a>经纬度定位行列号</h1><p>上一节里我们简单介绍了一下坐标系，按照<code>Web</code>地图的标准，我们的地图引擎也选择支持<code>EPSG:3857</code>投影，但是我们通过高德工具获取到的是火星坐标系的经纬度坐标，所以第一步要把经纬度坐标转换为<code>Web墨卡托</code>投影坐标，这里为了简单，先直接把火星坐标当做<code>WGS-84</code>坐标，后面再来看这个问题。</p><p>转换方法网上一搜就有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 角度转弧度</span></span><br><span class="line"><span class="keyword">const</span> angleToRad = <span class="function">(<span class="params">angle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> angle * (<span class="built_in">Math</span>.PI / <span class="number">180</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弧度转角度</span></span><br><span class="line"><span class="keyword">const</span> radToAngle = <span class="function">(<span class="params">rad</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rad * (<span class="number">180</span> / <span class="built_in">Math</span>.PI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地球半径</span></span><br><span class="line"><span class="keyword">const</span> EARTH_RAD = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4326转3857</span></span><br><span class="line"><span class="keyword">const</span> lngLat2Mercator = <span class="function">(<span class="params">lng, lat</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 经度先转弧度，然后因为 弧度 = 弧长 / 半径 ，得到弧长为 弧长 = 弧度 * 半径 </span></span><br><span class="line">    <span class="keyword">let</span> x = angleToRad(lng) * EARTH_RAD; </span><br><span class="line">    <span class="comment">// 纬度先转弧度</span></span><br><span class="line">    <span class="keyword">let</span> rad = angleToRad(lat)</span><br><span class="line">    <span class="comment">// 下面我就看不懂了，各位随意。。。</span></span><br><span class="line">    <span class="keyword">let</span> sin = <span class="built_in">Math</span>.sin(rad)</span><br><span class="line">    <span class="keyword">let</span> y = EARTH_RAD / <span class="number">2</span> * <span class="built_in">Math</span>.log((<span class="number">1</span> + sin) / (<span class="number">1</span> - sin))</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3857转4326</span></span><br><span class="line"><span class="keyword">const</span> mercatorTolnglat = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lng = radToAngle(x) / EARTH_RAD</span><br><span class="line">    <span class="keyword">let</span> lat = radToAngle((<span class="number">2</span> * <span class="built_in">Math</span>.atan(<span class="built_in">Math</span>.exp(y / EARTH_RAD)) - (<span class="built_in">Math</span>.PI / <span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> [lng, lat]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3857</code>坐标有了，它的单位是<code>米</code>，那么怎么转换成瓦片的行列号呢，这就涉及到<code>分辨率</code>的概念了，即地图上一像素代表实际多少米，分辨率如果能从地图厂商的文档里获取是最好的，如果找不到，也可以简单计算一下（如果使用计算出来的也不行，那就只能求助搜索引擎了），我们知道地球半径是<code>6378137</code>米，<code>3857</code>坐标系把地球当做正圆球体来处理，所以可以算出地球周长，投影是贴着地球赤道的：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/5.png" alt="5.png"></p><p>所以投影成正方形的世界平面图后的边长代表的就是地球的周长，前面我们也知道了每一层级的瓦片数量的计算方式，而一张瓦片的大小一般是<code>256*256</code>像素，所以用地球周长除以展开后的世界平面图的边长就知道了地图上每像素代表实际多少米：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地球周长</span></span><br><span class="line"><span class="keyword">const</span> EARTH_PERIMETER = <span class="number">2</span> * <span class="built_in">Math</span>.PI * EARTH_RAD</span><br><span class="line"><span class="comment">// 瓦片像素</span></span><br><span class="line"><span class="keyword">const</span> TILE_SIZE = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某一层级下的分辨率</span></span><br><span class="line"><span class="keyword">const</span> getResolution = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tileNums = <span class="built_in">Math</span>.pow(<span class="number">2</span>, n)</span><br><span class="line">    <span class="keyword">const</span> tileTotalPx = tileNums * TILE_SIZE</span><br><span class="line">    <span class="keyword">return</span> EARTH_PERIMETER / tileTotalPx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地球周长算出来是<code>40075016.68557849</code>，可以看到<code>OpenLayers</code>就是这么计算的：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/5-5.webp" alt="5-5.webp"></p><p><code>3857</code>坐标的单位是<code>米</code>，那么把坐标除以分辨率就可以得到对应的像素坐标，再除以<code>256</code>，就可以得到瓦片的行列号：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/6.png" alt="6.png"></p><p>函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据3857坐标及缩放层级计算瓦片行列号</span></span><br><span class="line"><span class="keyword">const</span> getTileRowAndCol = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resolution = getResolution(z)</span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">Math</span>.floor(x / resolution / TILE_SIZE)</span><br><span class="line">    <span class="keyword">let</span> col = <span class="built_in">Math</span>.floor(y / resolution / TILE_SIZE)</span><br><span class="line">    <span class="keyword">return</span> [row, col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们把层级固定为<code>17</code>，那么分辨率<code>resolution</code>就是<code>1.194328566955879</code>，雷峰塔的经纬度转成<code>3857</code>的坐标为：<code>[13374895.665697495, 3533278.205310311]</code>，使用上面的函数计算出来行列号为：<code>[43744, 11556]</code>，我们把这几个数据代入瓦片的地址里进行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=43744&amp;y=11556&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p><img src="/2024/07/03/从零打造一个Web地图引擎/7.png" alt="7.png"></p><p>一片空白，这是为啥呢，其实是因为原点不一样，<code>4326</code>和<code>3857</code>坐标系的原点在赤道和本初子午线相交点，非洲边上的海里，而瓦片的原点在左上角：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/8.png" alt="8.png"></p><p>再来看下图会更容易理解：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/9.png" alt="9.png"></p><p><code>3857</code>坐标系的原点相当于在世界平面图的中间，向右为<code>x</code>轴正方向，向上为<code>y</code>轴正方向，而瓦片地图的原点在左上角，所以我们需要根据图上【绿色虚线】的距离计算出【橙色实线】的距离，这也很简单，水平坐标就是水平绿色虚线的长度加上世界平面图的一半，垂直坐标就是世界平面图的一半减去垂直绿色虚线的长度，世界平面图的一半也就是地球周长的一半，修改<code>getTileRowAndCol</code>函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTileRowAndCol = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">  x += EARTH_PERIMETER / <span class="number">2</span>     <span class="comment">// ++</span></span><br><span class="line">  y = EARTH_PERIMETER / <span class="number">2</span> - y  <span class="comment">// ++</span></span><br><span class="line">  <span class="keyword">let</span> resolution = getResolution(z)</span><br><span class="line">  <span class="keyword">let</span> row = <span class="built_in">Math</span>.floor(x / resolution / TILE_SIZE)</span><br><span class="line">  <span class="keyword">let</span> col = <span class="built_in">Math</span>.floor(y / resolution / TILE_SIZE)</span><br><span class="line">  <span class="keyword">return</span> [row, col]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次计算出来的瓦片行列号为<code>[109280, 53979]</code>，代入瓦片地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webrd01.is.autonavi.com/appmaptile?x=109280&amp;y=53979&amp;z=17&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/10.png" alt="10.png"></p><p>可以看到雷峰塔出来了。</p><h1 id="瓦片显示位置计算"><a href="#瓦片显示位置计算" class="headerlink" title="瓦片显示位置计算"></a>瓦片显示位置计算</h1><p>我们现在能根据一个经纬度找到对应的瓦片，但是这还不够，我们的目标是要能在浏览器上显示出来，这就需要解决两个问题，一个是加载多少块瓦片，二是计算每一块瓦片的显示位置。</p><p>渲染瓦片我们使用<code>canvas</code>画布，模板如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"map"</span> <span class="attr">ref</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>地图画布容器<code>map</code>的大小我们很容易获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器大小</span></span><br><span class="line"><span class="keyword">let</span> &#123; width, height &#125; = <span class="keyword">this</span>.$refs.map.getBoundingClientRect()</span><br><span class="line"><span class="keyword">this</span>.width = width</span><br><span class="line"><span class="keyword">this</span>.height = height</span><br><span class="line"><span class="comment">// 设置画布大小</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="keyword">this</span>.$refs.canvas</span><br><span class="line">canvas.width = width</span><br><span class="line">canvas.height = height</span><br><span class="line"><span class="comment">// 获取绘图上下文</span></span><br><span class="line"><span class="keyword">this</span>.ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></table></figure><p>地图中心点我们设在画布中间，另外中心点的经纬度<code>center</code>和缩放层级<code>zoom</code>因为都是我们自己设定的，所以也是已知的，那么我们可以计算出中心坐标对应的瓦片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心点对应的瓦片</span></span><br><span class="line"><span class="keyword">let</span> centerTile = getTileRowAndCol(</span><br><span class="line">    ...lngLat2Mercator(...this.center),<span class="comment">// 4326转3857</span></span><br><span class="line">    <span class="keyword">this</span>.zoom<span class="comment">// 缩放层级</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>缩放层级还是设为<code>17</code>，中心点还是使用雷峰塔的经纬度，那么对应的瓦片行列号前面我们已经计算过了，为<code>[109280, 53979]</code>。</p><p>中心坐标对应的瓦片行列号知道了，那么该瓦片左上角在世界平面图中的像素位置我们也就知道了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心瓦片左上角对应的像素坐标</span></span><br><span class="line"><span class="keyword">let</span> centerTilePos = [centerTile[<span class="number">0</span>] * TILE_SIZE, centerTile[<span class="number">1</span>] * TILE_SIZE]</span><br></pre></td></tr></table></figure><p>计算出来为<code>[27975680, 13818624]</code>。这个坐标怎么转换到屏幕上呢，请看下图：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/11.png" alt="11.png"></p><p>中心经纬度的瓦片我们计算出来了，瓦片左上角的像素坐标也知道了，然后我们再计算出中心经纬度本身对应的像素坐标，那么和瓦片左上角的差值就可以计算出来，最后我们把画布的原点移动到画布中间（画布默认原点为左上角，x轴正方向向右，y轴正方向向下），也就是把中心经纬度作为坐标原点，那么中心瓦片的显示位置就是这个差值。</p><p>补充一下将经纬度转换成像素的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算4326经纬度对应的像素坐标</span></span><br><span class="line"><span class="keyword">const</span> getPxFromLngLat = <span class="function">(<span class="params">lng, lat, z</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [_x, _y] = lngLat2Mercator(lng, lat)<span class="comment">// 4326转3857</span></span><br><span class="line">  <span class="comment">// 转成世界平面图的坐标</span></span><br><span class="line">  _x += EARTH_PERIMETER / <span class="number">2</span></span><br><span class="line">  _y = EARTH_PERIMETER / <span class="number">2</span> - _y</span><br><span class="line">  <span class="keyword">let</span> resolution = resolutions[z]<span class="comment">// 该层级的分辨率</span></span><br><span class="line">  <span class="comment">// 米/分辨率得到像素</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">Math</span>.floor(_x / resolution)</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Math</span>.floor(_y / resolution)</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算中心经纬度对应的像素坐标：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心点对应的像素坐标</span></span><br><span class="line"><span class="keyword">let</span> centerPos = getPxFromLngLat(...this.center, <span class="keyword">this</span>.zoom)</span><br></pre></td></tr></table></figure><p>计算差值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心像素坐标距中心瓦片左上角的差值</span></span><br><span class="line"><span class="keyword">let</span> offset = [</span><br><span class="line">    centerPos[<span class="number">0</span>] - centerTilePos[<span class="number">0</span>],</span><br><span class="line">    centerPos[<span class="number">1</span>] - centerTilePos[<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后通过<code>canvas</code>来把中心瓦片渲染出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动画布原点到画布中间</span></span><br><span class="line"><span class="keyword">this</span>.ctx.translate(<span class="keyword">this</span>.width / <span class="number">2</span>, <span class="keyword">this</span>.height / <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 加载瓦片图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"><span class="comment">// 拼接瓦片地址</span></span><br><span class="line">img.src = getTileUrl(...centerTile, <span class="keyword">this</span>.zoom)</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 渲染到canvas</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.drawImage(img, -offset[<span class="number">0</span>], -offset[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先来看看<code>getTileUrl</code>方法的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接瓦片地址</span></span><br><span class="line"><span class="keyword">const</span> getTileUrl = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> domainIndexList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  <span class="keyword">let</span> domainIndex =</span><br><span class="line">    domainIndexList[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * domainIndexList.length)]</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`https://webrd0<span class="subst">$&#123;domainIndex&#125;</span>.is.autonavi.com/appmaptile?x=<span class="subst">$&#123;x&#125;</span>&amp;y=<span class="subst">$&#123;y&#125;</span>&amp;z=<span class="subst">$&#123;z&#125;</span>&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里随机了四个子域：<code>webrd01</code>、<code>webrd02</code>、<code>webrd03</code>、<code>webrd04</code>，这是因为浏览器对于同一域名同时请求的资源是有数量限制的，而当地图层级变大后需要加载的瓦片数量会比较多，那么均匀分散到各个子域下去请求可以更快的渲染出所有瓦片，减少排队等待时间，基本所有地图厂商的瓦片服务地址都支持多个子域。</p><p>为了方便看到中心点的位置，我们再额外渲染两条中心辅助线，效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/12.png" alt="12.png"></p><p>可以看到中心点确实是雷峰塔，当然这只是渲染了中心瓦片，我们要的是瓦片铺满整个画布，对于其他瓦片我们都可以根据中心瓦片计算出来，比如中心瓦片左边的一块，它的计算如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瓦片行列号，行号减1，列号不变</span></span><br><span class="line"><span class="keyword">let</span> leftTile = [centerTile[<span class="number">0</span>] - <span class="number">1</span>, centerTile[<span class="number">1</span>]]</span><br><span class="line"><span class="comment">// 瓦片显示坐标，x轴减去一个瓦片的大小，y轴不变</span></span><br><span class="line"><span class="keyword">let</span> leftTilePos = [</span><br><span class="line">    offset[<span class="number">0</span>] - TILE_SIZE * <span class="number">1</span>,</span><br><span class="line">    offset[<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以我们只要计算出中心瓦片四个方向各需要几块瓦片，然后用一个双重循环即可计算出画布需要的所有瓦片，计算需要的瓦片数量很简单，请看下图：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/13.png" alt="13.png"></p><p>画布宽高的一半减去中心瓦片占据的空间即可得到该方向剩余的空间，然后除以瓦片的尺寸就知道需要几块瓦片了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算瓦片数量</span></span><br><span class="line"><span class="keyword">let</span> rowMinNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.width / <span class="number">2</span> - offset[<span class="number">0</span>]) / TILE_SIZE)<span class="comment">// 左</span></span><br><span class="line"><span class="keyword">let</span> colMinNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.height / <span class="number">2</span> - offset[<span class="number">1</span>]) / TILE_SIZE)<span class="comment">// 上</span></span><br><span class="line"><span class="keyword">let</span> rowMaxNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.width / <span class="number">2</span> - (TILE_SIZE - offset[<span class="number">0</span>])) / TILE_SIZE)<span class="comment">// 右</span></span><br><span class="line"><span class="keyword">let</span> colMaxNum = <span class="built_in">Math</span>.ceil((<span class="keyword">this</span>.height / <span class="number">2</span> - (TILE_SIZE - offset[<span class="number">1</span>])) / TILE_SIZE)<span class="comment">// 下</span></span><br></pre></td></tr></table></figure><p>我们把中心瓦片作为原点，坐标为<code>[0, 0]</code>，来个双重循环扫描一遍即可渲染出所有瓦片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从上到下，从左到右，加载瓦片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = -colMinNum; j &lt;= colMaxNum; j++) &#123;</span><br><span class="line">        <span class="comment">// 加载瓦片图片</span></span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.src = getTileUrl(</span><br><span class="line">            centerTile[<span class="number">0</span>] + i,<span class="comment">// 行号</span></span><br><span class="line">            centerTile[<span class="number">1</span>] + j,<span class="comment">// 列号</span></span><br><span class="line">            <span class="keyword">this</span>.zoom</span><br><span class="line">        )</span><br><span class="line">        img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 渲染到canvas</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.drawImage(</span><br><span class="line">                img, </span><br><span class="line">                i * TILE_SIZE - offset[<span class="number">0</span>], </span><br><span class="line">                j * TILE_SIZE - offset[<span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/14.png" alt="14.png"></p><p>很完美。</p><h1 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h1><p>拖动可以这么考虑，前面已经实现了渲染指定经纬度的瓦片，当我们按住进行拖动时，可以知道鼠标滑动的距离，然后把该距离，也就是像素转换成经纬度的数值，最后我们再更新当前中心点的经纬度，并清空画布，调用之前的方法重新渲染，不停重绘造成是在移动的视觉假象。</p><p>监听鼠标相关事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">ref</span>=<span class="string">"canvas"</span> @<span class="attr">mousedown</span>=<span class="string">"onMousedown"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            isMousedown: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"mousemove"</span>, <span class="keyword">this</span>.onMousemove);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">"mouseup"</span>, <span class="keyword">this</span>.onMouseup);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标按下</span></span><br><span class="line">        onMousedown(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.which === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.isMousedown = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标移动</span></span><br><span class="line">        onMousemove(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isMousedown) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标松开</span></span><br><span class="line">        onMouseup() &#123;</span><br><span class="line">            <span class="keyword">this</span>.isMousedown = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onMousemove</code>方法里计算拖动后的中心经纬度及重新渲染画布：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算本次拖动的距离对应的经纬度数据</span></span><br><span class="line"><span class="keyword">let</span> mx = e.movementX * resolutions[<span class="keyword">this</span>.zoom];</span><br><span class="line"><span class="keyword">let</span> my = e.movementY * resolutions[<span class="keyword">this</span>.zoom];</span><br><span class="line"><span class="comment">// 把当前中心点经纬度转成3857坐标</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = lngLat2Mercator(...this.center);</span><br><span class="line"><span class="comment">// 更新拖动后的中心点经纬度</span></span><br><span class="line">center = mercatorToLngLat(x - mx, my + y);</span><br></pre></td></tr></table></figure><p><code>movementX</code>和<code>movementY</code>属性能获取本次和上一次鼠标事件中的移动值，兼容性不是很好，不过自己计算该值也很简单，详细请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/movementX" target="_blank" rel="noopener">MDN</a>。乘以当前分辨率把<code>像素</code>换算成<code>米</code>，然后把当前中心点经纬度也转成<code>3857</code>的<code>米</code>坐标，偏移本次移动的距离，最后再转回<code>4326</code>的经纬度坐标作为更新后的中心点即可。</p><p>为什么<code>x</code>是减，<code>y</code>是加呢，很简单，我们鼠标向右和向下移动时距离是正的，相应的地图会向右或向下移动，<code>4326</code>坐标系向右和向上为正方向，那么地图向右移动时，中心点显然是相对来说是向左移了，因为向右为正方向，所以中心点经度方向就是减少了，所以是减去移动的距离，而地图向下移动，中心点相对来说是向上移了，因为向上为正方向，所以中心点纬度方向就是增加了，所以加上移动的距离。</p><p>更新完中心经纬度，然后清空画布重新绘制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空画布</span></span><br><span class="line"><span class="keyword">this</span>.clear();</span><br><span class="line"><span class="comment">// 重新绘制，renderTiles方法就是上一节的代码逻辑封装</span></span><br><span class="line"><span class="keyword">this</span>.renderTiles();</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/15.gif" alt="15.gif"></p><p>可以看到已经凌乱了，这是为啥呢，其实是因为图片加载是一个异步的过程，我们鼠标移动过程中，会不断的计算出要加载的瓦片进行加载，但是可能上一批瓦片还没加载完成，鼠标已经移动到新的位置了，又计算出一批新的瓦片进行加载，此时上一批瓦片可能加载完成并渲染出来了，但是这些瓦片有些可能已经被移除画布，不需要显示，有些可能还在画布内，但是使用的还是之前的位置，渲染出来也是不对的，同时新的一批瓦片可能也加载完成并渲染出来，自然导致了最终显示的错乱。</p><p>知道原因就简单了，首先我们加个缓存对象，因为在拖动过程中，很多瓦片只是位置变了，不需要重新加载，同一个瓦片加载一次，后续只更新它的位置即可；另外再设置一个对象来记录当前画布上应该显示的瓦片，防止不应该出现的瓦片渲染出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缓存瓦片</span></span><br><span class="line">    tileCache: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 记录当前画布上需要的瓦片</span></span><br><span class="line">    currentTileCache: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为需要记录瓦片的位置、加载状态等信息，我们创建一个瓦片类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 瓦片类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opt = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 画布上下文</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx</span><br><span class="line">    <span class="comment">// 瓦片行列号</span></span><br><span class="line">    <span class="keyword">this</span>.row = row</span><br><span class="line">    <span class="keyword">this</span>.col = col</span><br><span class="line">    <span class="comment">// 瓦片层级</span></span><br><span class="line">    <span class="keyword">this</span>.zoom = zoom</span><br><span class="line">    <span class="comment">// 显示位置</span></span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">    <span class="comment">// 一个函数，判断某块瓦片是否应该渲染</span></span><br><span class="line">    <span class="keyword">this</span>.shouldRender = shouldRender</span><br><span class="line">    <span class="comment">// 瓦片url</span></span><br><span class="line">    <span class="keyword">this</span>.url = <span class="string">''</span></span><br><span class="line">    <span class="comment">// 缓存key</span></span><br><span class="line">    <span class="keyword">this</span>.cacheKey = <span class="keyword">this</span>.row + <span class="string">'_'</span> + <span class="keyword">this</span>.col + <span class="string">'_'</span> + <span class="keyword">this</span>.zoom</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">this</span>.img = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 图片是否加载完成</span></span><br><span class="line">    <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.createUrl()</span><br><span class="line">    <span class="keyword">this</span>.load()</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 生成url</span></span><br><span class="line">  createUrl() &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = getTileUrl(<span class="keyword">this</span>.row, <span class="keyword">this</span>.col, <span class="keyword">this</span>.zoom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载图片</span></span><br><span class="line">  load() &#123;</span><br><span class="line">    <span class="keyword">this</span>.img = <span class="keyword">new</span> Image()</span><br><span class="line">    <span class="keyword">this</span>.img.src = <span class="keyword">this</span>.url</span><br><span class="line">    <span class="keyword">this</span>.img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将图片渲染到canvas上</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.loaded || !<span class="keyword">this</span>.shouldRender(<span class="keyword">this</span>.cacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ctx.drawImage(<span class="keyword">this</span>.img, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 更新位置</span></span><br><span class="line">  updatePos(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改之前的双重循环渲染瓦片的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.currentTileCache = &#123;&#125;<span class="comment">// 清空缓存对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = -rowMinNum; i &lt;= rowMaxNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = -colMinNum; j &lt;= colMaxNum; j++) &#123;</span><br><span class="line">        <span class="comment">// 当前瓦片的行列号</span></span><br><span class="line">        <span class="keyword">let</span> row = centerTile[<span class="number">0</span>] + i</span><br><span class="line">        <span class="keyword">let</span> col = centerTile[<span class="number">1</span>] + j</span><br><span class="line">        <span class="comment">// 当前瓦片的显示位置</span></span><br><span class="line">        <span class="keyword">let</span> x = i * TILE_SIZE - offset[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> y = j * TILE_SIZE - offset[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 缓存key</span></span><br><span class="line">        <span class="keyword">let</span> cacheKey = row + <span class="string">'_'</span> + col + <span class="string">'_'</span> + <span class="keyword">this</span>.zoom</span><br><span class="line">        <span class="comment">// 记录画布当前需要的瓦片</span></span><br><span class="line">        <span class="keyword">this</span>.currentTileCache[cacheKey] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 该瓦片已加载过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tileCache[cacheKey]) &#123;</span><br><span class="line">            <span class="comment">// 更新到当前位置</span></span><br><span class="line">            <span class="keyword">this</span>.tileCache[cacheKey].updatePos(x, y).render()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未加载过</span></span><br><span class="line">            <span class="keyword">this</span>.tileCache[cacheKey] = <span class="keyword">new</span> Tile(&#123;</span><br><span class="line">                ctx: <span class="keyword">this</span>.ctx,</span><br><span class="line">                row,</span><br><span class="line">                col,</span><br><span class="line">                zoom: <span class="keyword">this</span>.zoom,</span><br><span class="line">                x,</span><br><span class="line">                y,</span><br><span class="line">                <span class="comment">// 判断瓦片是否在当前画布缓存对象上，是的话则代表需要渲染</span></span><br><span class="line">                shouldRender: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.currentTileCache[key]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/16.gif" alt="16.gif"></p><p>可以看到，拖动已经正常了，当然，上述实现还是很粗糙的，需要优化的地方很多，比如：</p><p>1.一般会先排个序，优先加载中心瓦片</p><p>2.缓存的瓦片越来越多肯定也会影响性能，所以还需要一些清除策略</p><p>这些问题有兴趣的可以自行思考。</p><h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><p>拖动是实时更新中心点经纬度，那么缩放自然更新缩放层级就行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 缩放层级范围</span></span><br><span class="line">            minZoom: <span class="number">3</span>,</span><br><span class="line">            maxZoom: <span class="number">18</span>,</span><br><span class="line">            <span class="comment">// 防抖定时器</span></span><br><span class="line">            zoomTimer: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'wheel'</span>, <span class="keyword">this</span>.onMousewheel)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标滚动</span></span><br><span class="line">        onMousewheel(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 层级变小</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &gt; <span class="keyword">this</span>.minZoom) <span class="keyword">this</span>.zoom--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 层级变大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &lt; <span class="keyword">this</span>.maxZoom) <span class="keyword">this</span>.zoom++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加个防抖，防止快速滚动加载中间过程的瓦片</span></span><br><span class="line">            <span class="keyword">this</span>.zoomTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.clear()</span><br><span class="line">                <span class="keyword">this</span>.renderTiles()</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/17.gif" alt="17.gif"></p><p>功能是有了，不过效果很一般，因为我们平常使用的地图缩放都是有一个放大或缩小的过渡动画，而这个是直接空白然后重新渲染，不仔细看都不知道是放大还是缩小。</p><p>所以我们不妨加个过渡效果，当我们鼠标滚动后，先将画布放大或缩小，动画结束后再根据最终的缩放值来渲染需要的瓦片。</p><p>画布默认缩放值为<code>1</code>，放大则在此基础上乘以<code>2</code>倍，缩小则除以<code>2</code>，然后动画到目标值，动画期间设置画布的缩放值及清空画布，重新绘制画布上的已有瓦片，达到放大或缩小的视觉效果，动画结束后再调用<code>renderTiles</code>重新渲染最终缩放值需要的瓦片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画使用popmotion库，https://popmotion.io/</span></span><br><span class="line"><span class="keyword">import</span> &#123; animate &#125; <span class="keyword">from</span> <span class="string">'popmotion'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            lastZoom: <span class="number">0</span>,</span><br><span class="line">            scale: <span class="number">1</span>,</span><br><span class="line">            scaleTmp: <span class="number">1</span>,</span><br><span class="line">            playback: <span class="literal">null</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 鼠标滚动</span></span><br><span class="line">        onMousewheel(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 层级变小</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &gt; <span class="keyword">this</span>.minZoom) <span class="keyword">this</span>.zoom--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 层级变大</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.zoom &lt; <span class="keyword">this</span>.maxZoom) <span class="keyword">this</span>.zoom++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 层级未发生改变</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastZoom === <span class="keyword">this</span>.zoom) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.lastZoom = <span class="keyword">this</span>.zoom</span><br><span class="line">            <span class="comment">// 更新缩放比例，也就是目标缩放值</span></span><br><span class="line">            <span class="keyword">this</span>.scale *= e.deltaY &gt; <span class="number">0</span> ? <span class="number">0.5</span> : <span class="number">2</span></span><br><span class="line">            <span class="comment">// 停止上一次动画</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.playback) &#123;</span><br><span class="line">                <span class="keyword">this</span>.playback.stop()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启动画</span></span><br><span class="line">            <span class="keyword">this</span>.playback = animate(&#123;</span><br><span class="line">                <span class="keyword">from</span>: <span class="keyword">this</span>.scaleTmp,<span class="comment">// 当前缩放值</span></span><br><span class="line">                to: <span class="keyword">this</span>.scale,<span class="comment">// 目标缩放值</span></span><br><span class="line">                onUpdate: <span class="function">(<span class="params">latest</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 实时更新当前缩放值</span></span><br><span class="line">                    <span class="keyword">this</span>.scaleTmp = latest</span><br><span class="line">                    <span class="comment">// 保存画布之前状态，原因有二：</span></span><br><span class="line">                    <span class="comment">// 1.scale方法是会在之前的状态上叠加的，比如初始是1，第一次执行scale(2,2)，第二次执行scale(3,3)，最终缩放值不是3，而是6，所以每次缩放完就恢复状态，那么就相当于每次都是从初始值1开始缩放，效果就对了</span></span><br><span class="line">                    <span class="comment">// 2.保证缩放效果只对重新渲染已有瓦片生效，不会对最后的renderTiles()造成影响</span></span><br><span class="line">                    <span class="keyword">this</span>.ctx.save()</span><br><span class="line">                    <span class="keyword">this</span>.clear()</span><br><span class="line">                    <span class="keyword">this</span>.ctx.scale(latest, latest)</span><br><span class="line">                    <span class="comment">// 刷新当前画布上的瓦片</span></span><br><span class="line">                    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.currentTileCache).forEach(<span class="function">(<span class="params">tile</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.tileCache[tile].render()</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">// 恢复到画布之前状态</span></span><br><span class="line">                    <span class="keyword">this</span>.ctx.restore()</span><br><span class="line">                &#125;,</span><br><span class="line">                onComplete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 动画完成后将缩放值重置为1</span></span><br><span class="line">                    <span class="keyword">this</span>.scale = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">this</span>.scaleTmp = <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 根据最终缩放值重新计算需要的瓦片并渲染</span></span><br><span class="line">                    <span class="keyword">this</span>.renderTiles()</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/17.gif" alt="17.gif"></p><p>虽然效果还是一般，不过至少能看出来是在放大还是缩小。</p><h1 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h1><p>前面还遗留了一个小问题，即我们把高德工具上选出的经纬度直接当做<code>4326</code>经纬度，前面也讲过，它们之间是存在偏移的，比如手机<code>GPS</code>获取到的经纬度一般都是<code>84</code>坐标，直接在高德地图显示，会发现和你实际位置不一样，所以就需要进行一个转换，有一些工具可以帮你做些事情，比如<a href="https://github.com/hujiulong/gcoord" target="_blank" rel="noopener">Gcoord</a>、<a href="https://github.com/wandergis/coordtransform" target="_blank" rel="noopener">coordtransform</a>等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述效果看着比较一般，其实只要在上面的基础上稍微加一点瓦片的淡出动画，效果就会好很多，目前一般都是使用<code>canvas</code>来渲染<code>2D</code>地图，如果自己实现动画不太方便，也有一些强大的<code>canvas</code>库可以选择，笔者最后使用<a href="https://konvajs.org/" target="_blank" rel="noopener">Konva.js</a>库重做了一版，加入了瓦片淡出动画，最终效果如下：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/18.gif" alt="18.gif"></p><p>另外只要搞清楚各个地图的瓦片规则，就能稍加修改支持更多的地图瓦片：</p><p><img src="/2024/07/03/从零打造一个Web地图引擎/19.webp" alt="19.webp"></p><p>具体实现限于篇幅不再展开，有兴趣的可以阅读本文源码。</p><p>本文详细的介绍了一个简单的<code>web</code>地图开发过程，上述实现原理仅是笔者的个人思路，不代表<code>openlayers</code>等框架的原理，因为笔者也是<code>GIS</code>的初学者，所以难免会有问题，或更好的实现，欢迎指出。</p><p>完整源码：<a href="https://github.com/jinux7/study-collections/tree/master/web%E5%9C%B0%E5%9B%BE%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">source</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从零开始，实现一个web地图，类似百度地图的效果&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
      <category term="canvas" scheme="/tags/canvas/"/>
    
  </entry>
  
</feed>
