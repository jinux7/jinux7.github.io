<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2023-04-06T06:21:11.927Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYSQL</title>
    <link href="/2023/04/04/MYSQL/"/>
    <id>/2023/04/04/MYSQL/</id>
    <published>2023-04-04T06:57:09.000Z</published>
    <updated>2023-04-06T06:21:11.927Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记整理<br><a id="more"></a></p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>在命令行连接 mysql 的参数如下：</p><table><thead><tr><th>选项</th><th>说明</th><th>默认</th></tr></thead><tbody><tr><td>-u</td><td>帐号</td><td>当前系统同名帐号</td></tr><tr><td>-p</td><td>密码</td></tr><tr><td>-P</td><td>连接端口</td><td>3306</td></tr><tr><td>-h</td><td>主机地址</td><td>127.0.0.1</td></tr><tr><td>-e</td><td>执行 sql 指令</td></tr></tbody></table><h4 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h4><p>连接服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -P3306 -h 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>连接本地数据库时可以使用默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></p><p>使用-e 执行 SQL 语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot -e&quot;show databases;&quot;</span><br></pre></td></tr></table></figure></p><p>退出连接<br>命令行下执行 exit 可通出当前连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></p><h4 id="执行与取消"><a href="#执行与取消" class="headerlink" title="执行与取消"></a>执行与取消</h4><p>每条 SQL 指令以;结束，按回车键后执行该条语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></p><p>放弃语句<br>在 SQL 后使用 \c表示取消本条 SQL，后面不需要写 ;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases \c</span><br></pre></td></tr></table></figure></p><h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>数据库列表<br>使用以下命令可以得到当前服务器中的所有数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></p><p>创建新库<br>下面是创建数据库 houdunren 并设置字符集为 utf8。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE houdunren CHARSET utf8;</span><br></pre></td></tr></table></figure></p><p>查看数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database houdunren;</span><br></pre></td></tr></table></figure></p><p>删除数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database houdunren;</span><br></pre></td></tr></table></figure></p><p>为了防止删除不存在的数据库报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists houdunren;</span><br></pre></td></tr></table></figure></p><p>选择数据库<br>数据库主要是对表操作，选择数据库后可以省掉每次指定数据库的麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use houdunren</span><br></pre></td></tr></table></figure></p><h4 id="导入语句"><a href="#导入语句" class="headerlink" title="导入语句"></a>导入语句</h4><p>有时需要把外部的 SQL 文件导入到服务器中，图像化的数据库管理软件都支持导入，下面我们介绍命令行的使用方法。<br>创建文件<br>下面我们创建 test.sql文件内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database hdcms charset utf8;</span><br><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure></p><p>外部导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt; test.sql</span><br></pre></td></tr></table></figure></p><p>连接后导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">&gt; source test.sql</span><br></pre></td></tr></table></figure></p><h3 id="数据表管理"><a href="#数据表管理" class="headerlink" title="数据表管理"></a>数据表管理</h3><p>可以把数据库理解为文件夹，数据表理解为文件，数据表是真正储存数据的地方。</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>创建数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table class (</span><br><span class="line">id int primary key AUTO_INCREMENT,</span><br><span class="line">cname varchar(30) NOT NULL,</span><br><span class="line">description varchar(100) default NULL)</span><br><span class="line">charset utf8;</span><br></pre></td></tr></table></figure></p><p>以上语句创建表 class 字段说明如下：</p><ul><li>字段 id 为主键自增</li><li>字段 cname 为字符串类型 varchar 并不允许为 null</li><li>字段 description 为可为 null 字符串</li><li>字符集为 utf8 ，如果不设置将继承数据库字符集</li></ul><p>添加测试数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO class (cname,description) VALUES(&apos;PHP&apos;,&apos;后盾人教你使用PHP快速开发网站&apos;);</span><br><span class="line">INSERT INTO class (cname) VALUES(&apos;Mysql&apos;);</span><br></pre></td></tr></table></figure></p><p>因为 description 设置为 null 所以第二个记录没有设置值时使用默认的 null 值。</p><h4 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h4><p>根据已经存在的表结构创建新表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table hdcms like class;</span><br></pre></td></tr></table></figure></p><p>复制其他表的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into hdcms select * from class;</span><br></pre></td></tr></table></figure></p><p>只复制批定字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into hdcms (cname) select cname from class;</span><br></pre></td></tr></table></figure></p><p>复制表时同时复制数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table hdjs select * from class;</span><br></pre></td></tr></table></figure></p><p>下面是只复制指定字段，并为不同名字段起别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table hd (id int primary key AUTO_INCREMENT,name varchar(30)) select id,cname as name from class;</span><br></pre></td></tr></table></figure></p><p>删除数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TEMPORARY TABLE IF EXISTS hd;</span><br></pre></td></tr></table></figure></p><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><p>临时表是用于储存临时数据表表，会在数据库连接中断时自动删除。</p><ul><li>可以与普通表同名，优先级高于普通表</li><li>连接终端时自动删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create TEMPORARY TABLE class_names SELECT * from class;</span><br><span class="line">select * from class_names;</span><br></pre></td></tr></table></figure></li></ul><p>删除临时表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TEMPORARY TABLE IF EXISTS class_names;</span><br></pre></td></tr></table></figure></p><blockquote><p>当然开发中我们更喜欢将临时数据放在缓存或会话中，以上只是介绍这个 mysql 特性。</p></blockquote><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="测试表"><a href="#测试表" class="headerlink" title="测试表"></a>测试表</h4><p>为了进行查询实例操作我们创建以下表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu (id int PRIMARY KEY AUTO_INCREMENT,sname char(30),class_id int default null,age smallint default null)</span><br><span class="line"></span><br><span class="line">INSERT INTO stu(sname,class_id,age) VALUES(&apos;小明&apos;,1,20),(&apos;张三&apos;,2,32),(&apos;李四&apos;,3,null),(&apos;小刘&apos;,null,46);</span><br></pre></td></tr></table></figure></p><h4 id="字段处理"><a href="#字段处理" class="headerlink" title="字段处理"></a>字段处理</h4><p>查询所有字估数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class;</span><br></pre></td></tr></table></figure></p><p>查询指定字段数据并排序字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select description,cname from class;</span><br></pre></td></tr></table></figure></p><h4 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h4><p>根据条件查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class where cname = &apos;php&apos;</span><br></pre></td></tr></table></figure></p><p>查询包含关键词的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class where description like &apos;%p%&apos;;</span><br></pre></td></tr></table></figure></p><p>合并列返回查询结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select CONCAT(id,cname) as &apos;class_info&apos; FROM class;</span><br></pre></td></tr></table></figure></p><p>指定多条件查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM class where id&gt;1 and cname = &apos;php&apos;</span><br></pre></td></tr></table></figure></p><p>查找一班或姓张的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where class_id =1 or sname like &apos;%张%&apos;</span><br></pre></td></tr></table></figure></p><p>介绍中不包含 php 的班级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from class WHERE description NOT LIKE &apos;%php%&apos;;</span><br></pre></td></tr></table></figure></p><p>查询学生所在班级编号，并去除重复值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT class_id from stu ;</span><br></pre></td></tr></table></figure></p><p>查询年龄在 20~35 岁的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age BETWEEN 20 and 35;</span><br></pre></td></tr></table></figure></p><p>查找不在 30~35 岁间的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age NOT BETWEEN 30 and 35;</span><br></pre></td></tr></table></figure></p><p>查找 2、3 班的所有同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu where class_id IN(2,3);</span><br></pre></td></tr></table></figure></p><p>查找除了 1、3 班的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where class_id NOT IN (1,3);</span><br></pre></td></tr></table></figure></p><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>查询没有分配班级的学生姓名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname from stu where class_id is null;</span><br></pre></td></tr></table></figure></p><p>查询已经分配班级的学生信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu where class_id is not null;</span><br></pre></td></tr></table></figure></p><p>查询结果中对没分配班级的学生显示未分配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sname,if(class_id is null,&apos;未分配&apos;,class_id) from stu;</span><br><span class="line"># 也可以使用IFNULl 函数简化操作</span><br><span class="line">select sname,ifnull (class_id ,&apos;未分配&apos;) from stu;</span><br></pre></td></tr></table></figure></p><h4 id="排序结果"><a href="#排序结果" class="headerlink" title="排序结果"></a>排序结果</h4><p>按学生年龄从大到小排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stu order by age desc;</span><br></pre></td></tr></table></figure></p><p>班级从大到小排序，相同班级的同学年龄从小到大排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu order by class_id DESC,age ASC;</span><br></pre></td></tr></table></figure></p><p>随机获取一名同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu order by RAND() limit 1;</span><br></pre></td></tr></table></figure></p><p>最后报名的同名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu order by id desc limit 1</span><br></pre></td></tr></table></figure></p><p>第二和第三报名的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Limit 是从零开始的</span><br><span class="line">SELECT * FROM stu order by id ASC limit 1,2;</span><br></pre></td></tr></table></figure></p><p>查找 2 班年龄最小的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu where class_id =2 and age is not null order by age asc limit 1;</span><br></pre></td></tr></table></figure></p><p>以上代码结果不准确，因为可能有同年龄的同学，所以可以使用子查询操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age = (SELECT age from stu where class_id =2 and age is not null order by age asc limit 1)</span><br></pre></td></tr></table></figure></p><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>将班级为 2 的学生改为班级 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu SET class_id = 3 WHERE class_id = 2;</span><br></pre></td></tr></table></figure></p><p>2 班年龄小于 20 岁的同学年龄设置为 NULL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu SET age = null WHERE class_id=2 AND age&lt;20;</span><br></pre></td></tr></table></figure></p><p>将年龄小于 20 岁的同学年龄加 10 岁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE stu SET age= age+20 WHERE age&lt;20;</span><br></pre></td></tr></table></figure></p><h4 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h4><p>删除所有年龄小于 20 的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM stu WHERE age&lt;20;</span><br></pre></td></tr></table></figure></p><p>删除所有年龄小在 30 并没有班级的同学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM stu WHERE class_id IS NULL;</span><br></pre></td></tr></table></figure></p><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>添加一条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu SET sname = &apos;小明&apos;,age=22,class_id=1;</span><br></pre></td></tr></table></figure></p><p>添加多条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu (sname,class_id,age) VALUES(&apos;小明&apos;,2,32),(&apos;小张&apos;,3,45);</span><br></pre></td></tr></table></figure></p><h2 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h2><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>修改表名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu RENAME stus;</span><br></pre></td></tr></table></figure></p><p>别一种操作方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE stus to stu;</span><br></pre></td></tr></table></figure></p><p>修改表字符集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE class charset gbk;</span><br></pre></td></tr></table></figure></p><p>删除表所有数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE stu;</span><br></pre></td></tr></table></figure></p><p>删除数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stu;</span><br></pre></td></tr></table></figure></p><h3 id="字段管理"><a href="#字段管理" class="headerlink" title="字段管理"></a>字段管理</h3><p>修改字段类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY sname char(30) not null;</span><br></pre></td></tr></table></figure></p><p>修改字段时同时更改字段名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu CHANGE sname name varchar(30) not null;</span><br></pre></td></tr></table></figure></p><p>添加字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD sex SMALLINT default null;</span><br></pre></td></tr></table></figure></p><p>在学生名称后添加邮箱字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD email varchar(50) AFTER sname;</span><br></pre></td></tr></table></figure></p><p>将字段添加到最前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD qq varchar(30) first;</span><br></pre></td></tr></table></figure></p><p>删除学生邮箱字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP email;</span><br></pre></td></tr></table></figure></p><h3 id="主键操作"><a href="#主键操作" class="headerlink" title="主键操作"></a>主键操作</h3><p>一般主键为自增字段，需要删除自增属性后才可以删除主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id int not null;</span><br></pre></td></tr></table></figure></p><p>删除主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu DROP PRIMARY key;</span><br></pre></td></tr></table></figure></p><p>添加表主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table stu2 add PRIMARY KEY(id);</span><br></pre></td></tr></table></figure></p><p>添加自增列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu2 MODIFY id int not null AUTO_INCREMENT;</span><br></pre></td></tr></table></figure></p><p>主键与自增列一起添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table stu3 modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</span><br></pre></td></tr></table></figure></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h4><p>下面是 mysql 支持的字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 字节</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 字节</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 字节</td><td>极大文本数据</td></tr></tbody></table><p>char 类型是定长类型，比如定义了 20 长度的char类型，只存一个字符也占用 20 个长度，char 好处是处理速度快，缺点是空间占用大，把手机号、邮箱、密码等长度相对固定的设置为 char 类型是不错的选择。<br>varchar 类型与 char 相反，点用空间受内容影响，可以把文章标题、介绍等设置为 varchar 类型更合适。</p><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><p>字符串分二进制与非二进制类型，二进制用于储存图片、声音等文件，非二进制用于储存文本数据。<br>非二进制文本受字符集和校对规则影响。</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同。常用的字符集有 GBK、BIG5、UTF8。<br>UTF8 字符包含文字内容更广，如韩文、日文、德文兼容度更高，也是推荐使用的字符集。<br>下面是查看服务器支持的字符集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CHARACTER SET;</span><br></pre></td></tr></table></figure></p><p>表不设置字符集继承数据库，字段不设置字符集继承表的</p><h4 id="校对规则"><a href="#校对规则" class="headerlink" title="校对规则"></a>校对规则</h4><p>是在字符集内用于字符比较和排序的一套规则，以_ci 结束的为大小写不敏感、_bin 结束的为区分大小写。<br>下面是查看系统支持的校对规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show COLLATION;</span><br></pre></td></tr></table></figure></p><p>当使用不区分大小写的校对规则时 A 与 a 是相同的，否则则不相同，这会影响到排序与比对。<br>如果使用utf8_bin 校对规则时，下面的查询将匹配不到大写的PHP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from class WHERE cname = &apos;php&apos;;</span><br></pre></td></tr></table></figure></p><blockquote><p>修改表校对规则，对表的原字段将不影响，只对新增字段影响。</p></blockquote><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>大小写转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT UPPER(cname) as cname,LOWER(description) as `desc` from class;</span><br></pre></td></tr></table></figure></p><p>Left&amp;right<br>left 与 right 函数用于取左或右指定数量的字符，下面是取班级介绍前 8 个字符并用… 连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(LEFT(description,8),&apos;...&apos;) FROM class;</span><br></pre></td></tr></table></figure></p><p>mid<br>从中间取字符串，参数二为起始，参数三为取的字符数量。下面是获取从第二个字符取两个字符值为hp的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from class where mid(cname,2,2) = &apos;hp&apos;;</span><br></pre></td></tr></table></figure></p><p>substring<br>从指定位置开始向右取所有字符串，下面是获取从第二个位置开始的字符值为hp的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from class where SUBSTRING(cname,2) = &apos;hp&apos;;</span><br></pre></td></tr></table></figure></p><p>char_length<br>获取字符串数量</p><p>concat<br>连接字符串使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat(&apos;编号:&apos;,id) as id,concat(&apos;班级:&apos;,cname) as name FROM class;</span><br></pre></td></tr></table></figure></p><p>将所有班级前加上后盾人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE class SET cname = CONCAT(&apos;后盾人:&apos;,cname);</span><br></pre></td></tr></table></figure></p><p>截取班级介绍，超过 8 个字符的后面连接…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">if(CHAR_LENGTH(description)&gt;8,CONCAT(LEFT(description,8),&apos;...&apos;),LEFT(description,8)) as name</span><br><span class="line">FROM class;</span><br></pre></td></tr></table></figure></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>Mysql 支持正则表达式操作，可用于处理复杂的匹配操作。<br>查找第二个字符为h的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM class WHERE cname REGEXP &apos;^.h&apos;;</span><br></pre></td></tr></table></figure></p><p>查找班级名称中包含php 或 mysql的记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM class WHERE cname REGEXP &apos;php|mysql&apos;;</span><br></pre></td></tr></table></figure></p><p>所有介绍中包含 php 与 mysql 的课程名前加上后盾人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update class set cname = REPLACE(cname,cname,concat(&apos;后盾人：&apos;,cname))</span><br><span class="line">where description REGEXP  &apos;php|mysql&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><p>在 LIKE 表达式中 % 用于匹配任意多个字符，_ 用于匹配一个字符。<br>查找第二个字符为 h 的班级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT *  FROM class WHERE cname LIKE &apos;_h%&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整型</p><table><thead><tr><th>MySQL 数据类型</th><th>范围（有符号）</th><th>范围（无符号）</th></tr></thead><tbody><tr><td>tinyint(m)</td><td>1 个字节 范围(-128~127)</td><td>(0，255)</td></tr><tr><td>smallint(m)</td><td>2 个字节 范围(-32768~32767)</td><td>(0，65 535)</td></tr><tr><td>mediumint(m)</td><td>3 个字节 范围(-8388608~8388607)</td><td>(0，16 777 215)</td></tr><tr><td>int(m)</td><td>4 个字节 范围(-2147483648~2147483647)</td><td>(0，4 294 967 295)</td></tr><tr><td>bigint(m)</td><td>8 个字节 范围(+-9.22*10 的 18 次方)</td><td>(0，18 446 744 073 709 551 615)</td></tr></tbody></table><ul><li>取值范围如果加了 unsigned，则最大值翻倍，如 tinyint unsigned 的取值范围为(0~256)。</li><li>m 的含义不是允许字段的长度，而是显示长度，在为字段设置 zerofill 时有效。</li></ul><p>添加有前导零的字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE class ADD stu_count smallint(6) ZEROFILL default null;</span><br></pre></td></tr></table></figure></p><p>在命令行查看（有些 GUI 软件不显示前导零)，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------------------------------------------+-----------+</span><br><span class="line">| id | cname | description                                | stu_count |</span><br><span class="line">+----+-------+--------------------------------------------+-----------+</span><br><span class="line">|  4 | Mysql | 数据库                                     |    000001 |</span><br><span class="line">|  5 | PHP   | 后盾人教你使用PHP快速开发网站              |      NULL |</span><br><span class="line">+----+-------+--------------------------------------------+-----------+</span><br></pre></td></tr></table></figure></p><p>浮点型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th></tr></thead><tbody><tr><td>FLOAT</td><td>4 字节</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td></tr><tr><td>DECIMAL</td><td>DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td><td>依赖于 M 和 D 的值</td><td>依赖于 M 和 D 的值</td></tr></tbody></table><p>下面是检测浮点数精度的示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table class add e FLOAT(10,2);</span><br><span class="line">update class set e = 12345678.66 where id=11;</span><br></pre></td></tr></table></figure></p><p>查看结果时会发布浮点数结果不精确。</p><ul><li>float：2^23 = 8388608，一共七位，这意味着最多能有 7 位有效数字，但绝对能保证的为 6 位，即 float 的精度为 6~7 位有效数字</li><li>double：2^52 = 4503599627370496，一共 16 位，double 的精度为 15~16 位</li><li>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值</li><li>decimal(m,d) 参数 m&lt;65 是总个数，d&lt;30 且 d&lt;m 是小数位</li><li>对货币等对精度敏感的数据，应该用定点数 decimal 存储</li></ul><h3 id="ENUM-SET"><a href="#ENUM-SET" class="headerlink" title="ENUM/SET"></a>ENUM/SET</h3><h4 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h4><p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。换个枚举最大可以有 65535 个成员值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stu ADD sex ENUM(&apos;男&apos;,&apos;女&apos;) DEFAULT NULL;</span><br></pre></td></tr></table></figure></p><p>可以使用索引或值添加 enum 数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu (sname,class_id,sex) VALUES(&apos;李岗&apos;,1,&apos;男&apos;);</span><br><span class="line">INSERT INTO stu (sname,class_id,sex) VALUES(&apos;李玉&apos;,1,2);</span><br></pre></td></tr></table></figure></p><p>可以使用值与索引检索 ENUM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from stu WHERE sex=&apos;女&apos;;</span><br><span class="line">SELECT * from stu WHERE sex=2;</span><br></pre></td></tr></table></figure></p><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。一个 SET 类型最多可以包含 64 项元素。<br>使用 SET 类型添加文章属性字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD flag SET(&apos;推荐&apos;,&apos;置顶&apos;,&apos;图文&apos;,&apos;热门&apos;);</span><br></pre></td></tr></table></figure></p><p>添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO article (title,status,flag)VALUES(&apos;后盾人&apos;,1,&apos;图文,推荐,置顶&apos;);</span><br></pre></td></tr></table></figure></p><p>使用 find_in_set 查找数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE find_in_set(&apos;图文&apos;,flag);</span><br></pre></td></tr></table></figure></p><p>使用like 查找数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE flag like &apos;%置顶%&apos;</span><br></pre></td></tr></table></figure></p><p>二进制比较<br>可以使用二进制方式对 SET 类型进行模糊筛选。</p><table><thead><tr><th>SET 成员</th><th>十进制值</th><th>二进制值</th></tr></thead><tbody><tr><td>推荐</td><td>1</td><td>0001</td></tr><tr><td>置顶</td><td>2</td><td>0010</td></tr><tr><td>图文</td><td>4</td><td>0100</td></tr><tr><td>热门</td><td>8</td><td>1000</td></tr></tbody></table><p>获取包含图文与推荐的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE flag &amp; 5;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记整理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="数据库" scheme="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的AI工具</title>
    <link href="/2023/04/04/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84AI%E5%B7%A5%E5%85%B7/"/>
    <id>/2023/04/04/提高效率的AI工具/</id>
    <published>2023-04-04T06:24:59.000Z</published>
    <updated>2023-04-04T06:46:44.338Z</updated>
    
    <content type="html"><![CDATA[<p>工作中提高效率的AI工具<br><a id="more"></a></p><h2 id="5款腾讯免费AI工具"><a href="#5款腾讯免费AI工具" class="headerlink" title="5款腾讯免费AI工具"></a>5款腾讯免费AI工具</h2><h3 id="Effidit-智能创作助手"><a href="#Effidit-智能创作助手" class="headerlink" title="Effidit 智能创作助手"></a><a href="https://effidit.qq.com/" target="_blank" rel="noopener">Effidit 智能创作助手</a></h3><blockquote><p>「Effidit」是一款免费的人工智能写作助手，提供多种实用功能，包括文本纠错、文本润色、文本改写、文本扩写、词语推荐、句子推荐与生成等。使用 Effidit 可以轻松完成中英文写作，提高写作效率。</p></blockquote><h3 id="腾讯交互翻译"><a href="#腾讯交互翻译" class="headerlink" title="腾讯交互翻译"></a><a href="https://yi.qq.com/" target="_blank" rel="noopener">腾讯交互翻译</a></h3><blockquote><p>「腾讯交互翻译」是一款免费跨平台人工智能翻译神器，目前支持 20 种语言互译，翻译精准。它最大的特色在于融合了腾讯自研的 AI 技术。</p></blockquote><h3 id="帮小忙"><a href="#帮小忙" class="headerlink" title="帮小忙"></a><a href="https://tool.browser.qq.com/" target="_blank" rel="noopener">帮小忙</a></h3><blockquote><p>「帮小忙」是一款所有功能完全免费的万能工具箱，涵盖了“图片”、“数据换算”、“生活娱乐”、“教育”、“文本工具”、“文档转换”、“开发工具”、“视频”和“PDF 转换工具”等 9 大类在线工具，目前共有 122 款，功能超级全面，最重要的还是免费的。</p></blockquote><h3 id="ARC-实验室"><a href="#ARC-实验室" class="headerlink" title="ARC 实验室"></a><a href="https://arc.tencent.com/zh/ai-demos/faceRestoration" target="_blank" rel="noopener">ARC 实验室</a></h3><blockquote><p>「ARC 实验室」是腾讯专门探索前沿科技的团队，被称为腾讯 PCG 的“侦察兵”、“特种兵”，目前 ARC 实验室公布了三款主要工具：“人像修复”、“人像抠图”和“动漫增强”，完全免费。</p></blockquote><h3 id="腾讯智影"><a href="#腾讯智影" class="headerlink" title="腾讯智影"></a><a href="https://zenvideo.qq.com/" target="_blank" rel="noopener">腾讯智影</a></h3><blockquote><p>「腾讯智影」是一款云端智能视频创作工具，无需下载即可通过 PC 浏览器访问，支持视频云剪辑、素材库、文本配音、数字人播报、自动字幕识别等功能，帮助用户更好地进行视频化的表达。</p></blockquote><h2 id="国外流行AI工具-有些需要科学上网"><a href="#国外流行AI工具-有些需要科学上网" class="headerlink" title="国外流行AI工具(有些需要科学上网)"></a>国外流行AI工具(有些需要科学上网)</h2><h3 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a><a href="https://chat.openai.com/chat" target="_blank" rel="noopener">ChatGPT</a></h3><blockquote><p> ChatGPT 是最近特别火爆的一款 AI 工具，它能够通过理解和学习人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文等任务。</p></blockquote><h3 id="Midjourney"><a href="#Midjourney" class="headerlink" title="Midjourney"></a><a href="https://www.midjourney.com/" target="_blank" rel="noopener">Midjourney</a></h3><blockquote><p>Midjourney 是一个由 Midjourney 研究实验室开发的人工智能程序，它可以根据你输入的文本智能生成图片，当然你也可以使用使用图片去生成与该图片类似的图片（图生图）。</p></blockquote><h3 id="Writesonic"><a href="#Writesonic" class="headerlink" title="Writesonic"></a><a href="https://writesonic.com/" target="_blank" rel="noopener">Writesonic</a></h3><blockquote><p>Writesonic 是一个人工智能作家，它可以以 10 倍的速度为您的博客、广告、电子邮件和网站创建 SEO 优化且无抄袭的内容。</p></blockquote><h3 id="remove-bg"><a href="#remove-bg" class="headerlink" title="remove.bg"></a><a href="https://www.remove.bg/" target="_blank" rel="noopener">remove.bg</a></h3><blockquote><p>使用 remove.bg 智能 AI 工具，您只需轻点一下，就可以在 5 秒钟内完全自动地去除背景。这将为您节省大量编辑时间，同时增加更多的乐趣。remove.bg 支持通过上传图片、拖拽图片和粘贴图片地址的方式选择图片进行处理。</p></blockquote><h3 id="beauiful-ai"><a href="#beauiful-ai" class="headerlink" title="beauiful.ai"></a><a href="https://www.beautiful.ai/" target="_blank" rel="noopener">beauiful.ai</a></h3><blockquote><p>beautiful.ai 提供了大量智能 PPT 模版，您可以自由选择模版，轻松生成您的 PPT，让您可以在几分钟内创建专业 PPT，而不是几个小时。</p></blockquote><h3 id="Galileo-AI"><a href="#Galileo-AI" class="headerlink" title="Galileo AI"></a><a href="https://www.usegalileo.ai/" target="_blank" rel="noopener">Galileo AI</a></h3><blockquote><p>Galileo AI 是一个生成式人工智能，它只需要您输入一个文本提示，即可生成令人惊叹、完全可编辑的 UI 设计，使您能够以超乎想象的速度进行设计。此外，它还提供许多由人工智能生成的插图和图像，供您添加到您的产品中。</p></blockquote><h3 id="Excel-Formula-Bot"><a href="#Excel-Formula-Bot" class="headerlink" title="Excel Formula Bot"></a><a href="https://excelformulabot.com/" target="_blank" rel="noopener">Excel Formula Bot</a></h3><blockquote><p>Excel Formula Bot 借助 AI 能力，让您几秒钟内快速将文本指令转化为 Excel 公式，帮助您解决所有电子表格问题。</p></blockquote><h3 id="Auto-Draw"><a href="#Auto-Draw" class="headerlink" title="Auto Draw"></a><a href="https://www.autodraw.com/" target="_blank" rel="noopener">Auto Draw</a></h3><blockquote><p>AutoDraw 是一种来自谷歌创意实验室的完全免费的 AI 智能自动绘图工具。它将机器学习与天才艺术家的画作配对，帮助每个人快速创建任何视觉效果。并且它可以在任何地方使用：手机、平板电脑、笔记本电脑、台式机等。</p></blockquote><h3 id="TLDR-this"><a href="#TLDR-this" class="headerlink" title="TLDR-this"></a><a href="https://tldrthis.com/" target="_blank" rel="noopener">TLDR-this</a></h3><blockquote><p>TLDR 可帮助您将任何一段文本总结为简洁、易于理解的内容。将自己从信息过载中解放出来。</p></blockquote><h3 id="Fliki"><a href="#Fliki" class="headerlink" title="Fliki"></a><a href="https://fliki.ai/" target="_blank" rel="noopener">Fliki</a></h3><blockquote><p>Fliki 可以将文本转换为带有 AI 语音短视频，您可以在 1 分钟内用人工智能的声音创建音频和视频内容。有了 Fliki，您就可以将您的博客文章或任何基于文本的内容转换成视频、播客或有声读物的配音。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中提高效率的AI工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="AI" scheme="/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>前端枚举</title>
    <link href="/2023/03/31/%E5%89%8D%E7%AB%AF%E6%9E%9A%E4%B8%BE/"/>
    <id>/2023/03/31/前端枚举/</id>
    <published>2023-03-31T05:16:16.000Z</published>
    <updated>2023-03-31T06:17:14.623Z</updated>
    
    <content type="html"><![CDATA[<p>前端枚举的简单入门<br><a id="more"></a></p><blockquote><p>枚举在类似java等语言中很基础，但是js中却没有，即使现在的es6也没有把枚举加进来。但是，typescript中是有枚举供使用的。</p></blockquote><h2 id="typescript中枚举示例"><a href="#typescript中枚举示例" class="headerlink" title="typescript中枚举示例"></a>typescript中枚举示例</h2><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ts</span><br><span class="line">enum demo1 &#123;</span><br><span class="line">  Up = 1,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var demo1;</span><br><span class="line">(function (demo1) &#123;</span><br><span class="line">  demo1[demo1[&quot;Up&quot;] = 1] = &quot;Up&quot;;</span><br><span class="line">  demo1[demo1[&quot;Down&quot;] = 2] = &quot;Down&quot;;</span><br><span class="line">  demo1[demo1[&quot;Left&quot;] = 3] = &quot;Left&quot;;</span><br><span class="line">  demo1[demo1[&quot;Right&quot;] = 4] = &quot;Right&quot;;</span><br><span class="line">&#125;)(demo1 || (demo1 = &#123;&#125;));</span><br><span class="line"></span><br><span class="line">// console</span><br><span class="line">&#123;</span><br><span class="line">  &quot;1&quot;: &quot;Up&quot;,</span><br><span class="line">  &quot;2&quot;: &quot;Down&quot;,</span><br><span class="line">  &quot;3&quot;: &quot;Left&quot;,</span><br><span class="line">  &quot;4&quot;: &quot;Right&quot;,</span><br><span class="line">  &quot;Up&quot;: 1,</span><br><span class="line">  &quot;Down&quot;: 2,</span><br><span class="line">  &quot;Left&quot;: 3,</span><br><span class="line">  &quot;Right&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ts</span><br><span class="line">enum demo2 &#123;</span><br><span class="line">  Up = &quot;UP&quot;,</span><br><span class="line">  Down = &quot;DOWN&quot;,</span><br><span class="line">  Left = &quot;LEFT&quot;,</span><br><span class="line">  Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var demo2;</span><br><span class="line">(function (demo2) &#123;</span><br><span class="line">  demo2[&quot;Up&quot;] = &quot;UP&quot;;</span><br><span class="line">  demo2[&quot;Down&quot;] = &quot;DOWN&quot;;</span><br><span class="line">  demo2[&quot;Left&quot;] = &quot;LEFT&quot;;</span><br><span class="line">  demo2[&quot;Right&quot;] = &quot;RIGHT&quot;;</span><br><span class="line">&#125;)(demo2 || (demo2 = &#123;&#125;));</span><br><span class="line"></span><br><span class="line">// console</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Up&quot;: &quot;UP&quot;,</span><br><span class="line">  &quot;Down&quot;: &quot;DOWN&quot;,</span><br><span class="line">  &quot;Left&quot;: &quot;LEFT&quot;,</span><br><span class="line">  &quot;Right&quot;: &quot;RIGHT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ts</span><br><span class="line">enum demo3 &#123;</span><br><span class="line">  No = 0,</span><br><span class="line">  Yes = &quot;YES&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var demo3;</span><br><span class="line">(function (demo3) &#123;</span><br><span class="line">  demo3[demo3[&quot;No&quot;] = 0] = &quot;No&quot;;</span><br><span class="line">  demo3[&quot;Yes&quot;] = &quot;YES&quot;;</span><br><span class="line">&#125;)(demo3 || (demo3 = &#123;&#125;));</span><br><span class="line"></span><br><span class="line">// console</span><br><span class="line">&#123;</span><br><span class="line">  &quot;0&quot;: &quot;No&quot;,</span><br><span class="line">  &quot;No&quot;: 0,</span><br><span class="line">  &quot;Yes&quot;: &quot;YES&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面3个例子，ts部分是在typescript中的写法，js部分是typescript编译后的写法。可以发现，枚举中的数字类型和字符串类型编译后的结果稍有区别，在使用时也可以灵活使用。</p><h2 id="前端中枚举的作用"><a href="#前端中枚举的作用" class="headerlink" title="前端中枚举的作用"></a>前端中枚举的作用</h2><p>不难看出，枚举被编译后的结果就是一个js对象，那直接使用对象不是更好？<br>其实，枚举主要作用是减少代码的错误，比如这样一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum demo &#123;</span><br><span class="line">  Up = &quot;UP&quot;,</span><br><span class="line">  Down = &quot;DOWN&quot;,</span><br><span class="line">  Left = &quot;LEFT&quot;,</span><br><span class="line">  Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用1</span><br><span class="line">demo.Up</span><br><span class="line">// 使用2</span><br><span class="line">demo.Upp</span><br></pre></td></tr></table></figure></p><p>上述代码的使用2，在编译阶段就会报错，如果不使用ts的话，只能在运行时才能发现错误，可以提高代码正确率。</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>vue3的源码中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export const enum ShapeFlags &#123;</span><br><span class="line">  ELEMENT = 1,</span><br><span class="line">  FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1,</span><br><span class="line">  STATEFUL_COMPONENT = 1 &lt;&lt; 2,</span><br><span class="line">  TEXT_CHILDREN = 1 &lt;&lt; 3,</span><br><span class="line">  ARRAY_CHILDREN = 1 &lt;&lt; 4,</span><br><span class="line">  SLOTS_CHILDREN = 1 &lt;&lt; 5,</span><br><span class="line">  TELEPORT = 1 &lt;&lt; 6,</span><br><span class="line">  SUSPENSE = 1 &lt;&lt; 7,</span><br><span class="line">  COMPONENT_SHOULD_KEEP_ALIVE = 1 &lt;&lt; 8,</span><br><span class="line">  COMPONENT_KEPT_ALIVE = 1 &lt;&lt; 9,</span><br><span class="line">  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一段代码，简单些理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const study =  &#123;</span><br><span class="line">    html: 1,</span><br><span class="line">    css: 1 &lt;&lt; 1,</span><br><span class="line">    js: 1 &lt;&lt; 2,</span><br><span class="line">    svg: 1 &lt;&lt; 3,</span><br><span class="line">    canvas: 1 &lt;&lt; 4</span><br><span class="line">&#125;</span><br><span class="line">function isStudy(studentNum, ...enumStudyArr) &#123;</span><br><span class="line">    // 1 00000001 代表html</span><br><span class="line">    // 2 00000010 代表css</span><br><span class="line">    // 4 00000100 代表js</span><br><span class="line">    // 8 00001000 代表svg</span><br><span class="line">    // 16 00010000 代表canvas</span><br><span class="line">    return enumStudyArr.every(item=&gt; &#123;</span><br><span class="line">        return studentNum &amp; item;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 使用：</span><br><span class="line">* 假设mike会html和svg，那么他的num就是1+8=9;</span><br><span class="line">* isStudy(9, study.html, study.svg);</span><br><span class="line">* 如果都会的话，1+2+4+8+16=31;</span><br><span class="line">* isStudy(31, study.html, study.css, study.js, study.svg, study.canvas);</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">let mikeNum = 9;</span><br><span class="line">console.log(&apos;1-&gt;:&apos;, isStudy(mikeNum, study.html, study.svg));</span><br><span class="line">console.log(&apos;2-&gt;:&apos;, isStudy(mikeNum, study.html, study.css, study.js, study.svg, study.canvas));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端枚举的简单入门&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="typescript" scheme="/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的执行上下文和调用栈</title>
    <link href="/2023/03/15/javascript%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <id>/2023/03/15/javascript中的执行上下文和调用栈/</id>
    <published>2023-03-15T06:59:07.000Z</published>
    <updated>2023-03-15T07:15:57.124Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript中你必须理解的执行上下文和调用栈<br><a id="more"></a></p><blockquote><p>执行上下文在 JavaScript 是非常重要的基础知识，想要理解 JavaScript 的执行过程，执行上下文 是你必须要掌握的知识。否则只能是知其然不知其所以然。<br>理解执行上下文有什么好处呢？<br>它可以帮助你更好的理解代码的执行过程，作用域，闭包等关键知识点。特别是闭包它是 JavaScript 中的一个难点，当你理解了执行上下文在回头看闭包时，应该会有豁然开朗的感觉。<br>这篇文章我们将深入了解 执行上下文，读完文章之后你应该可以清楚的了解到 JavaScript 解释器到底做了什么，为什么可以在一些函数和变量之前使用它，以及它们的值是如何确定的。</p></blockquote><h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>在 JavaScript 中运行代码时，代码的执行环境非常重要，通常是下列三种情况：</p><ul><li>Global code：代码第一次执行时的默认环境。</li><li>Function code：函数体中的代码</li><li>Eval code：eval 函数内执行的文本（实际开发中很少使用，所以见到的情况不多）</li></ul><p>在网上你可以读到很多关于作用域的文章，为了便于理解本文的内容，我们将 执行上下文 当作代码的 执行环境/作用域。现在就让我们看一个例子：它包括 全局和函数/本地执行上下文。<br><img src="/2023/03/15/javascript中的执行上下文和调用栈/1.image" alt="img"><br>上面的例子我们看到，紫色的框代表全局上下文，绿色、蓝色、橙色代表三个不同的函数上下文。全局上下文执行有一个，它可以被其他上下文访问到。<br>你可以有任意数量的函数上下文，每个函数在调用时都会创建一个新的上下文，它是一个私有范围，函数内部声明的所有东西都不能在函数作用域外访问到。<br>上面的例子中，函数内部可以访问当前上下文之外声明的变量，但是外部却不能访问函数内部的变量/函数。这到底是为什么？其中的代码是如何执行的？</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>浏览器中的 JavaScript 解释器是单线程实现的。这意味着在浏览器中一次只能做一件事情。而其他的行为或事件都会在执行栈中排队等待。如图：<br><img src="/2023/03/15/javascript中的执行上下文和调用栈/2.image" alt="img"><br>我们知道，当浏览器第一次加载脚本时，默认情况下，它会进入全局上下文。如果在全局代码中调用了一个函数，则代码的执行会进入函数中，此时会创建一个新的执行上下文，它会被推到执行上下文栈中。<br>如果在这个过程中函数内部调用了另一个函数，会发生同样的事情，代码的执行会进入函数中，然后创建一个新的执行上下文，它会被推到上下文栈 的顶部。浏览器始终执行栈顶部的执行上下文。<br>一旦函数完成执行，当前的执行上下文将从栈的顶部弹出，然后继续执行下面的，下面程序演示了一个递归函数的执行上下文情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function foo(i) &#123;</span><br><span class="line">    if (i === 3) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        foo(++i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(0));</span><br></pre></td></tr></table></figure></p><p><img src="/2023/03/15/javascript中的执行上下文和调用栈/3.image" alt="img"><br>自己调用自己三次，每次将 i 递增 1，每次函数 foo 被调用的时候，就会创建一个新的执行上下文。一旦当前上下文执行完毕之后，它就会从栈中弹出并转移到下面的上下文中，直到全局上下。</p><p>执行上下文栈的 5 个关键点：</p><ul><li>单线程</li><li>同步执行</li><li>只有一个全局上下文</li><li>任意数量的函数上下文</li><li>每个函数调用都会创建一个新的执行上下文，包括自己调用自己</li></ul><h2 id="详解执行上下文"><a href="#详解执行上下文" class="headerlink" title="详解执行上下文"></a>详解执行上下文</h2><p>到此，我们知道每次调用一个函数时，都会创建一个新的执行上下文。但是在 JavaScript 解释器中，每次调用执行上下文会有两个阶段：<br>1.创建阶段</p><ul><li>创建作用域链</li><li>创建变量，函数，arguments列表。</li><li>确定 this 的指向</li></ul><p>2.执行阶段</p><ul><li>赋值，寻找函数引用，解释/执行代码</li></ul><p>执行上下文可以抽象为一个对象它具备三个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">    &apos;scopeChain&apos;: &#123; /* variableObject + all parent execution context&apos;s variableObject */ &#125;,</span><br><span class="line">    &apos;variableObject&apos;: &#123; /* function arguments / parameters, inner variable and function declarations */&#125;,</span><br><span class="line">    &apos;this&apos;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="活动-变量对象-AO-VO"><a href="#活动-变量对象-AO-VO" class="headerlink" title="活动/变量对象[AO/VO]"></a>活动/变量对象[AO/VO]</h2><p>executionContextObj 对象在函数调用时创建，但它是在函数真正执行之前就创建的，这就是我们所说的第一个阶段 创建阶段，此时解释器通过扫描函数的传入参数，arguments，本地函数声明，局部变量声明来创建executionContextObj 对象。将结果变成 variableObject 放入 executionContextObj 中。</p><p>解释器执行代码时的大致描述：<br>1.调用函数<br>2.在执行代码时，创建执行上下文<br>3.进入创建阶段</p><ul><li>初始化作用域链</li><li>创建变量对象（variableObject）</li><li>创建参数对象（arguments object），检查参数的上下文，初始化名称和值，并创建引用副本</li><li>扫描上下文中的函数声明</li><li>每发现一个函数，就会在 variableObject 中创建一个名称，保存函数的引用</li><li>如果名称已经存在，则覆盖引用</li><li>扫描上下文中的变量声明</li><li>每发现一个变量，就在 variableObject 中创建一个名称，并初始化值为 undefined</li><li>如果变量名已经存在，什么都不做，继续扫描</li><li>确定上下文中的 this 指向</li></ul><p>4.执行代码阶段</p><ul><li>在上下文中执行/解释代码，在代码逐行执行时进行变量复赋值</li></ul><p>让我们看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(i) &#123;</span><br><span class="line">    var a = &apos;hello&apos;;</span><br><span class="line">    var b = function privateB() &#123;&#125;;</span><br><span class="line">    function c() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(22);</span><br></pre></td></tr></table></figure></p><p>foo(22) 函数执行的时候，创建阶段如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 22,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 22,</span><br><span class="line">        c: pointer to function c()</span><br><span class="line">        a: undefined,</span><br><span class="line">        b: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    this: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所述，除了形参 i 和 arguments外，在创建阶段我们只把变量进行声明而不进行赋值。<br>在创建阶段完成后，程序会进入函数中执行代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">    scopeChain: &#123; ... &#125;,</span><br><span class="line">    variableObject: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 22,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 22,</span><br><span class="line">        c: pointer to function c()</span><br><span class="line">        a: &apos;hello&apos;,</span><br><span class="line">        b: pointer to function privateB()</span><br><span class="line">    &#125;,</span><br><span class="line">    this: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h2><p>网上很多关于声明提前的内容，它是用来解释变量和函数在声明时会被提前到作用域的顶部。但是并没有人详细解释为什么会发生这种情况，有了刚才关于解释器如何创建活动对象（AO）的认知，我们将很容易看出原因。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    console.log(typeof foo); // function pointer</span><br><span class="line">    console.log(typeof bar); // undefined</span><br><span class="line">    var foo = &apos;hello&apos;,</span><br><span class="line">        bar = function() &#123;</span><br><span class="line">            return &apos;world&apos;;</span><br><span class="line">        &#125;;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return &apos;hello&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></p><p>我们现在可以回答如下问题：<br>为什么我们可以在声明之前访问foo？<br>在执行阶段之前，我们已经完成了创建阶段，此时变量/函数已经被创建，所以当函数执行的时候 foo 可以被访问到。<br>foo 被声明了两次，为什么 foo 显示的是 function 而不是 undefined 或者 string？<br>虽然 foo 被声明了两次，但是我们在创建阶段中说到，函数是在变量之前创建在变量对象中，当变量对象中名称已经存在时，变量声明什么也不做。<br>因此 foo 会被先创建为函数 function foo() 的引用，当执行到 var foo时发现变量对象中已将存在了，所以此时什么也不做，而是继续扫描。<br>为什么 bar 是 undefined？<br>bar 实际上是一个变量只不过它的值是函数，而变量在创建阶段的值为 undefined。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们再来梳理下重要的知识点：</p><ul><li>首先在程序执行时会创建一个全局的执行上下文，有且只有一个。</li><li>函数在每次调用时就会创建一个函数上下文，可以有很多。</li><li>函数上下文可以访问全局上下文的内容，反之则不行。</li><li>创建的上下文会被推入到上下文栈中，然后从顶部开始依次执行。</li><li>执行上下文会分为两个阶段：创建阶段和执行阶段。</li><li>创建阶段会先进行函数声明和变量声明提前。</li><li>创建阶段会先进行函数声明，然后进行变量声明，同时会被放入变量对象中，如果变量对象中已经存在：函数则进行引用的覆盖，变量则什么都不做。</li><li>执行阶段才会进行赋值和运行。</li></ul><p>希望你已经理解了 JavaScript 解释器是如何执行你的代码的。理解执行上下文和 执行上下文栈能够让你清楚的知道你的代码为什么和预期的值不一样。<br>你认为了解，解释器的内部原理是多余还是必须的知识？它是否能够帮助你更好的编写 JavaScript 代码？欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript中你必须理解的执行上下文和调用栈&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>for循环中var与let深入理解</title>
    <link href="/2023/03/15/for%E5%BE%AA%E7%8E%AF%E4%B8%ADvar%E4%B8%8Elet%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>/2023/03/15/for循环中var与let深入理解/</id>
    <published>2023-03-15T06:32:29.000Z</published>
    <updated>2023-03-15T06:53:14.739Z</updated>
    
    <content type="html"><![CDATA[<p>for循环中var与let作用域不同的原理<br><a id="more"></a></p><h2 id="for中的var和let的使用"><a href="#for中的var和let的使用" class="headerlink" title="for中的var和let的使用"></a>for中的var和let的使用</h2><h3 id="var使用"><a href="#var使用" class="headerlink" title="var使用"></a>var使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用var声明，得到3个3</span><br><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[0](); //3</span><br><span class="line">a[1](); //3</span><br><span class="line">a[2](); //3</span><br></pre></td></tr></table></figure><h3 id="let使用"><a href="#let使用" class="headerlink" title="let使用"></a>let使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用let声明，得到0,1,2</span><br><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[0](); //0</span><br><span class="line">a[1](); //1</span><br><span class="line">a[2](); //2</span><br></pre></td></tr></table></figure><h2 id="for循环的展开"><a href="#for循环的展开" class="headerlink" title="for循环的展开"></a>for循环的展开</h2><p>for循序的执行顺序是这样的：设置循环变量(var i = 0)  ==&gt; 循环判断(i&lt;3)  ==&gt; 满足执行循环体 ==&gt; 循环变量自增(i++)</p><h3 id="var展开"><a href="#var展开" class="headerlink" title="var展开"></a>var展开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">&#123;</span><br><span class="line">  //我是父作用域</span><br><span class="line">  var i = 0;</span><br><span class="line">  if (0 &lt; 3) &#123;</span><br><span class="line">    a[0] = function () &#123;</span><br><span class="line">      //我是子作用域</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为1</span><br><span class="line">  if (1 &lt; 3) &#123;</span><br><span class="line">    a[1] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为2</span><br><span class="line">  if (2 &lt; 3) &#123;</span><br><span class="line">    a[2] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为3</span><br><span class="line">  // 跳出循环</span><br><span class="line">&#125;</span><br><span class="line">//调用N次指向都是最终的3</span><br><span class="line">a[0](); //3</span><br><span class="line">a[1](); //3</span><br><span class="line">a[2](); //3</span><br></pre></td></tr></table></figure><h3 id="let展开"><a href="#let展开" class="headerlink" title="let展开"></a>let展开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">&#123;</span><br><span class="line">  //我是父作用域</span><br><span class="line">  let i = 0;</span><br><span class="line">  if (0 &lt; 3) &#123;</span><br><span class="line">    a[0] = function () &#123;</span><br><span class="line">      //我是子作用域</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为1</span><br><span class="line">  if (1 &lt; 3) &#123;</span><br><span class="line">    a[1] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为2</span><br><span class="line">  if (2 &lt; 3) &#123;</span><br><span class="line">    a[2] = function () &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为3</span><br><span class="line">  // 跳出循环</span><br><span class="line">&#125;</span><br><span class="line">//调用N次指向都是最终的3</span><br><span class="line">a[0](); //3</span><br><span class="line">a[1](); //3</span><br><span class="line">a[2](); //3</span><br></pre></td></tr></table></figure><blockquote><p>但是，let这样写的结果跟var是一样的。其实浏览器底层的实现跟上边的实现是不一样，详细情况不解释，只写最后实现代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var a = []; </span><br><span class="line">&#123;</span><br><span class="line">  //我是父作用域</span><br><span class="line">  let i = 0;</span><br><span class="line">  if (i &lt; 3) &#123;</span><br><span class="line">    //这一步模拟底层实现</span><br><span class="line">    let k = i;</span><br><span class="line">    a[k] = function () &#123;</span><br><span class="line">      //我是子作用域</span><br><span class="line">      console.log(k);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为1</span><br><span class="line">  if (i &lt; 3) &#123;</span><br><span class="line">    let k = i;</span><br><span class="line">    a[k] = function () &#123;</span><br><span class="line">      console.log(k);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为2</span><br><span class="line">  if (i &lt; 3) &#123;</span><br><span class="line">    let k = i;</span><br><span class="line">    a[k] = function () &#123;</span><br><span class="line">      console.log(k);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++; //为3</span><br><span class="line">  // 跳出循环</span><br><span class="line">&#125;</span><br><span class="line">a[0](); //0</span><br><span class="line">a[1](); //1</span><br><span class="line">a[2](); //2</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.cnblogs.com/echolun/p/10584703.html" target="_blank" rel="noopener">参考-听风是风</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;for循环中var与let作用域不同的原理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>递归深入理解</title>
    <link href="/2023/01/09/%E9%80%92%E5%BD%92%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>/2023/01/09/递归深入理解/</id>
    <published>2023-01-09T02:46:19.000Z</published>
    <updated>2023-01-11T06:08:35.997Z</updated>
    
    <content type="html"><![CDATA[<p>深入的理解递归算法<br><a id="more"></a><br>【<a href="/2019/07/02/js中的递归总结/">递归浅析</a>】这篇文章简单的介绍了递归算法，本编会对递归进行深入的理解。</p><h2 id="递归原理"><a href="#递归原理" class="headerlink" title="递归原理"></a>递归原理</h2><h3 id="什么是递归，它是如何工作的？"><a href="#什么是递归，它是如何工作的？" class="headerlink" title="什么是递归，它是如何工作的？"></a>什么是递归，它是如何工作的？</h3><blockquote><p>递归(recursion)是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。<br>简单说程序调用自身的编程技巧叫递归。递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。</p></blockquote><p>使用递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含2个属性：</p><ul><li>基本情况（bottom cases），基本情况用于保证程序调用及时返回，不在继续递归，保证了程序可终止。</li><li>递推关系（recurrentce relation），可将所有其他情况拆分到基本案例。</li></ul><p>简单的示例：以相反的顺序打印字符串。<br>可以使用迭代的办法轻而易举地解决这个问题，即从字符串的最后一个字符开始遍历字符串。但是如何递归地解决它呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  helper(<span class="number">0</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">index, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!str || index&gt;str.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  helper(index+<span class="number">1</span>, str);</span><br><span class="line">  <span class="built_in">console</span>.log(str[index]);</span><br><span class="line">&#125;</span><br><span class="line">printReverse(<span class="string">'abcdefg'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="递归的程序特征"><a href="#递归的程序特征" class="headerlink" title="递归的程序特征"></a>递归的程序特征</h3><p>优雅性</p><blockquote><p>相比其他解法（比如迭代法），使用递归法，会发现只需少量程序就可描述出解题过程，大大减少了程序的代码量，而且很好理解。递归的能力在于用有限的语句来定义对象的无限集合。</p></blockquote><p>反向性</p><blockquote><p>由于递归调用程序需要维护调用栈，而栈具有后进先出的特征，因此递归程序适合满足取反类需求。</p></blockquote><p>递推关系</p><blockquote><p>递归程序可以较明显的发现递推关系，反过来也可以这么说，具有递推关系的问题基本都可以通过递归求解（当然也许有性能更佳的解法，但递归绝对是一种选择）。递推关系常见问题有杨辉三角、阶乘计算等。</p></blockquote><h3 id="什么时候考虑递归"><a href="#什么时候考虑递归" class="headerlink" title="什么时候考虑递归"></a>什么时候考虑递归</h3><p>具有以下特征的问题可考虑递归求解：</p><ul><li>当问题和子问题具有递推关系，比如杨辉三角、计算阶乘。</li><li>具有递归性质的数据结构，比如链表、树、图。</li><li>反向性问题，比如取反。</li></ul><p>总结下来，最根本的还是要抓住问题本身是否可以通过层层拆解到最小粒度来得解。</p><h2 id="递归的递推性质"><a href="#递归的递推性质" class="headerlink" title="递归的递推性质"></a>递归的递推性质</h2><p>上一节说了，在实现递归函数之前，需要弄明白2件事：</p><ul><li>​递推关系​： 一个问题的结果与其子问题的结果之间的关系。</li><li>​基本情况​: 不需要进一步的递归调用就可以直接计算答案的情况。 它们往往是问题被减少到最小规模的情况，也就是如果将问题划分为子问题是一种自上而下的方式的最下层。</li></ul><p>一旦计算出以上两个元素，再想要实现一个递归函数，就只需要根据​递推关系​调用函数本身，直到其抵达​基本情况​。<br>为了解释以上几点，来看一个经典问题：杨辉三角（也叫帕斯卡三角）。</p><h3 id="帕斯卡三角"><a href="#帕斯卡三角" class="headerlink" title="帕斯卡三角"></a>帕斯卡三角</h3><blockquote><p>帕斯卡三角形是排列成三角形的一系列数字。 在帕斯卡三角形中，每一行的最左边和最右边的数字总是 <code>1</code>。 对于其余的每个数字都是前一行中直接位于它上面的两个数字之和。</p></blockquote><p>下面的插图给出了一个 <code>5</code> 行的帕斯卡三角：<br><img src="/2023/01/09/递归深入理解/1.gif" alt="img"></p><h4 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h4><p>从帕斯卡三角形内的递推关系开始。<br>首先，定义一个函数 <code>f(i,j)</code>，它将会返回帕斯卡三角形​第 <code>i</code> 行​、​第 <code>j</code> 列​的数字。<br>可以用下面的公式来表示这一递推关系：<br><code>f(i,j)=f(i−1,j−1)+f(i−1,j)</code></p><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>可以看到，每行的最左边和最右边的数字是​基本情况​，在这个问题中，它总是等于 1。<br>因此，可以将基本情况定义如下:<br><code>f(i,j)=1wherej=1orj=i</code></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>一旦定义了 ​递推关系​ 和 ​基本情况​，递归函数的实现变得更加直观，特别是在用数学公式表示出这两个元素之后。<br>下面给出一个例子，展示如何用这个公式递归地计算 <code>f(5,3)</code>, 也就是 帕斯卡三角形​第 <code>5</code> 行​中的​第 <code>3</code> 个​数。<br><img src="/2023/01/09/递归深入理解/2.gif" alt="img"><br>可以将 <code>f(5,3)</code> 分解为 <code>f(5,3)=f(4,2)+f(4,3)</code>，然后递归地调用 <code>f(4,2)</code> 和 <code>f(4,3)</code>：<br>对于调用的 <code>f(4,2)</code>，可以进一步展开它，直到到达基本情况，正如下面所描述的：<br><code>f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3</code><br>对于调用的 <code>f(4,3)</code>，类似地，可以将其分解为：<br><code>f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3</code><br>最后，结合上述子问题的结果：<br><code>f(5,3)=f(4,2)+f(4,3)=3+3=6</code><br>可能已经注意到递归解决方案可能会导致一些重复的计算，​例如​，重复计算相同的中间数以获得最后一行中的数字。 举例说明，为了得到 <code>f(5,3)</code> 的结果，在 <code>f(4,2)</code> 和 <code>f(4,3)</code> 的调用中计算了 <code>f(3,2)</code> 两次，这样重复计算效率肯定不高，下一节会给出优化方案来避免重复计算（即记忆术）。</p><h2 id="递归复杂性分析"><a href="#递归复杂性分析" class="headerlink" title="递归复杂性分析"></a>递归复杂性分析</h2><h3 id="递归时间复杂度计算"><a href="#递归时间复杂度计算" class="headerlink" title="递归时间复杂度计算"></a>递归时间复杂度计算</h3><p>给出一个递归算法，其时间复杂度 <code>O(T)</code> 通常是递归调用的数量（记作 <code>R</code>）和计算的时间复杂度的乘积（表示为 <code>O(s)</code>）的乘积：<br><code>O(T)=R∗O(s)</code></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在反转字符串问题中，需要以相反的顺序打印字符串，解决问题的递归关系可以表示如下：<br><code>​printReverse(str) = printReverse(str[1...n]) + print(str[0])</code><br>​其中 <code>​str[1...n]</code>​ 是输入字符串 ​str​ 的子串，仅不含前导字符 ​<code>str[0]​</code>。<br>该函数将被递归调用 n 次，其中 n 是输入字符串的大小。在每次递归结束时，只是打印前导字符，因此该特定操作的时间复杂度是恒定的，即 <code>O(1)</code>。<br>总而言之，递归函数 <code>​printReverse(str)</code>​ 的总体时间复杂度为 <code>O(printReverse)=n∗O(1)=O(n)</code>。</p><h4 id="执行树分析递归调用数量"><a href="#执行树分析递归调用数量" class="headerlink" title="执行树分析递归调用数量"></a>执行树分析递归调用数量</h4><p>在分析递归的时间复杂度时，递归调用的数量不一定和N成线性关系，比如斐波那契数的计算（见第五部分），其递推关系被定义为​<code>f(n) = f(n-1) + f(n-2)</code>​。乍一看，在执行斐波那契函数期间计算递归调用的数量似乎并不简单。<br>执行树定义</p><blockquote><p>执行树是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。</p></blockquote><p>递归函数的执行树将形成 <code>​n</code> 叉树​，其中 ​<code>n</code>​ 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 <code>​f(4)</code>​ 的执行树。<br><img src="/2023/01/09/递归深入理解/3.webp" alt="img"><br>在 n 层的完全二叉树中，节点的总数为 <code>2n−1</code>。因此 <code>​f(n)</code>​ 中递归数目的上限（尽管不严格）也是 <code>2n−1</code>。那么我们可以估计 ​<code>f(n)</code>​ 的时间复杂度为 <code>O(2n)</code>。</p><h3 id="递归空间复杂性分析"><a href="#递归空间复杂性分析" class="headerlink" title="递归空间复杂性分析"></a>递归空间复杂性分析</h3><p>在计算递归算法的空间复杂度时，应该考虑造成空间消耗的两个部分：递归相关空间（​recursion related space）和非递归相关空间​（​non-recursion related space​）。</p><h4 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h4><p>递归相关空间是指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈。为了完成典型的函数调用，系统应该在栈中分配一些空间来保存三个重要信息：</p><ul><li>函数调用的返回地址。一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点。</li><li>传递给函数调用的参数。</li><li>函数调用中的局部变量。</li></ul><p>栈中的这个空间是函数调用期间产生的最小成本。然而，一旦完成函数调用，就会释放该空间。<br>对于递归算法，函数调用将连续链接直到它们到达基本情况（也称为 底层情况）。这意味着用于每个函数调用的空间也会累积。<br>对于递归算法，如果没有产生其他内存消耗，则此递归引起的空间将是算法的空间上限。<br>例如，在本文一开始提到了反转字符串示例中，没有使用额外的内存，因为仅仅是打印一个字符。对于每个递归调用，假设它可能需要一个最大为某一常量值的空间。并且递归调用最多可以链接 <code>​n</code>​ 次，其中 ​<code>n</code>​ 是输入字符串的大小。因此，该递归算法的空间复杂度就是 <code>O(n)</code>。<br>为了更好地说明这一点，接下来将会展示递归调用​ <code>f(x1) -&gt; f(x2) -&gt; f(x3)</code>​ 的执行顺序以及栈空间的分配情况。<br><img src="/2023/01/09/递归深入理解/4.webp" alt="img"><br>栈中的空间将会分配给 ​<code>f(x1)</code>​ 来调用 ​<code>f(x2)</code>​。类似的情况也同样发生在 <code>​f(x2)</code>​ 中，系统会为 <code>​f(x3)</code> 的调用分配另一个空间，最后在​ ​<code>f(x3)</code>​ 中，我们到达基本情况，因此在 ​<code>f(x3)</code>​ 中没有进行进一步的递归调用。<br>正是由于这些与递归相关的空间消耗，有时可能会遇到称为堆栈溢出的情况，其中为程序分配的堆栈达到其最大空间限制并导致程序最终失败。在设计递归算法时，应该仔细评估在输入规模扩大时是否存在堆栈溢出的可能性，栈溢出是非常容易出错的点，在下一节将讨论优化策略。</p><h4 id="非递归相关空间"><a href="#非递归相关空间" class="headerlink" title="非递归相关空间"></a>非递归相关空间</h4><p>正如名称所示，非递归相关空间指的是与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间（通常在堆中）。<br>不管是否递归，都可能需要在任何函数调用之前将问题的输入存储为全局变量。可能还需要保存递归调用的中间结果（也就是即将讨论的记忆化技术）。例如，在使用带有记忆化技术的递归算法解决斐波那契数问题时,使用映射<code>（map）</code>来跟踪在递归调用期间产生的所有中间斐波那契数。因此，在分析空间复杂度时，应该考虑到因采用记忆化技术所导致的空间成本。</p><h2 id="递归的优化策略"><a href="#递归的优化策略" class="headerlink" title="递归的优化策略"></a>递归的优化策略</h2><h3 id="时间优化策略：记忆化"><a href="#时间优化策略：记忆化" class="headerlink" title="时间优化策略：记忆化"></a>时间优化策略：记忆化</h3><p>递归是一种直观而有效的实现算法的方法。 但是，如果不明智地使用它，可能会给性能带来一些不希望的损失，例如重复计算。 在前面提到了帕斯卡三角的重复计算问题，其中一些中间结果被多次计算。<br>在本文中，将进一步研究递归可能出现的重复计算问题。 然后将提出一种常用的技术，称为​记忆化（memoization）​，可以用来避免这个问题。<br>为了演示重复计算的另一个问题，看一个大多数人可能都很熟悉的例子，斐波那契数。 如果定义函数 <code>​F(n)</code>​ 表示在索引 <code>​n</code>​ 处的斐波那契数，那么可以推导出如下的递推关系：<br>​<code>F(n) = F(n - 1) + F(n - 2)</code>​<br>基本情况：<br>​<code>F(0) = 0, F(1) = 1</code><br>​根据斐波那契数列的定义，可以实现下面的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，如果想知道 ​<code>F(4)</code>​ 是多少，可以应用上面的公式并进行展开：<br>​<code>F(4) = F(3) + F(2) = (F(2) + F(1)) + F(2)</code><br>为了得到 <code>f(4)</code> 的结果，需要在上述推导之后计算两次数 <code>​F(2)</code>​ : 第一次在 <code>​F(4)</code>​ 的第一次展开中，第二次在中间结果 ​<code>F(3)</code>​ 中。<br>下面的树显示了在计算 ​<code>F(4)</code>​ 时发生的所有重复计算（按颜色分组）。<br><img src="/2023/01/09/递归深入理解/5.webp" alt="img"><br>为了消除上述情况中的重复计算，正如许多人已经指出的那样，其中一个想法是将中间结果存储在缓存中，以便以后可以重用它们，而不需要重新计算。<br>这个想法也被称为记忆化，这是一种经常与递归一起使用的技术。​<br><strong>记忆化定义</strong></p><blockquote><p>记忆化是一种优化技术，主要用于加快计算机程序的速度，方法是存储昂贵的函数调用的结果，并在相同的输入再次出现时返回缓存的结果。</p></blockquote><p>回到斐波那契函数 <code>​F(n)</code>​。 可以使用哈希表来跟踪每个以 ​<code>n​</code> 为键的 <code>​F(n)</code>​ 的结果。 散列表作为一个缓存，可以避免重复计算。 记忆化技术是一个很好的例子，它演示了如何通过增加额外的空间以减少计算时间。<br>为了便于比较，下面提供了带有记忆化功能的斐波那契数列解决方案的实现。<br>作为一种练习，可以尝试使记忆化更加通用和非侵入性，即应用记忆化技术而不改变原来的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cache.has(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">    result = n;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    result = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  cache.set(n, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>斐波那契数应用的一个经典问题是爬楼梯，在第五节再分析。<br>通过记忆化技术，保存每个索引 <code>​n</code>​ 对应的的斐波那契数的结果。确信每个斐波那契数的计算只会发生一次。而从递推关系来看，斐波纳契数 ​<code>f(n)</code>​ 将取决于其所有 <code>​n-1</code>​ 个先验斐波纳契数。结果，计算 <code>​f(n)</code>​ 的递归将被调用 ​<code>n-1</code>​ 次以计算它所依赖的所有先验数字。<br>现在，可以计算一下采用了记忆化技术优化后的时间复杂度，即 <code>O(1)∗n=O(n)</code>。可以得出记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。</p><h3 id="空间优化策略：尾递归"><a href="#空间优化策略：尾递归" class="headerlink" title="空间优化策略：尾递归"></a>空间优化策略：尾递归</h3><p>上一节讨论了递归空间复杂性分析话题，从中了解到递归调用在系统调用栈上会产生额外空间，如果递归调用层级很深，程序执行过程中很可能导致栈溢出。针对这种情况，有一种称为尾递归的特殊递归，它可以控制递归导致空间开销的影响。<br><strong>尾递归定义</strong></p><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。</p></blockquote><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）。<br>第五部分将看到尾递归优化阶乘运算的例子。</p><h2 id="采用递归解法的几个经典问题"><a href="#采用递归解法的几个经典问题" class="headerlink" title="采用递归解法的几个经典问题"></a>采用递归解法的几个经典问题</h2><blockquote><p>递归在递推关系的数学问题上应用广泛，使用递归法可以解决很多趣味问题，下面来看看都有哪些经典问题。</p></blockquote><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 ​<code>char[]</code>​ 的形式给出。<br>不要给另外的数组分配额外的空间，必须原地修改输入数组、使用 <code>O(1)</code> 的额外空间解决这一问题。<br>可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入：[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line">输出：[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入：[<span class="string">"H"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"h"</span>]</span><br><span class="line">输出：[<span class="string">"h"</span>,<span class="string">"a"</span>,<span class="string">"n"</span>,<span class="string">"n"</span>,<span class="string">"a"</span>,<span class="string">"H"</span>]</span><br></pre></td></tr></table></figure></p><p>分析：此问题是根据递归调用栈的特性做后进先出反转。<br>code:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">arrStr</span>) </span>&#123;</span><br><span class="line">  help(arrStr, <span class="number">0</span>, arrStr.length<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> arrStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">arrStr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">let</span> temp = arrStr[left];</span><br><span class="line">      arrStr[left] = arrStr[right];</span><br><span class="line">      arrStr[right] = temp;</span><br><span class="line">  help(arrStr, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">reverseString([<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'0'</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="comment">// 你应该返回</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link5 = &#123;<span class="attr">val</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="number">5</span>, <span class="attr">next</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> link4 = &#123;<span class="attr">val</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="number">4</span>, <span class="attr">next</span>: link5&#125;;</span><br><span class="line"><span class="keyword">const</span> link3 = &#123;<span class="attr">val</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="number">3</span>, <span class="attr">next</span>: link4&#125;;</span><br><span class="line"><span class="keyword">const</span> link2 = &#123;<span class="attr">val</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="number">2</span>, <span class="attr">next</span>: link3&#125;;</span><br><span class="line"><span class="keyword">const</span> link1 = &#123;<span class="attr">val</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">next</span>: link2&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapPairs</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> temp = head.val;</span><br><span class="line">  head.val = head.next.val;</span><br><span class="line">  head.next.val = temp;</span><br><span class="line">  swapPairs(head.next.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swapPairs(link1);</span><br><span class="line"><span class="built_in">console</span>.log(link1);</span><br><span class="line"><span class="built_in">console</span>.log(link2);</span><br><span class="line"><span class="built_in">console</span>.log(link3);</span><br><span class="line"><span class="built_in">console</span>.log(link4);</span><br><span class="line"><span class="built_in">console</span>.log(link5);</span><br></pre></td></tr></table></figure></p><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><img src="/2023/01/09/递归深入理解/1.gif" alt="img"><br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>分析：典型的具有递推关系的数据问题，注意通过记忆化优化。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = []; <span class="comment">// 缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传入数字不是整数，返回空数组</span></span><br><span class="line">  <span class="keyword">if</span>(numRows&lt;=<span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=numRows; i++) &#123;</span><br><span class="line">    arr[i<span class="number">-1</span>] = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">      arr[i<span class="number">-1</span>].push(makeNum(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNum</span>(<span class="params">row, column</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!cache[row]) &#123;</span><br><span class="line">    cache[row]=[];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有缓存，直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(cache[row][column]) <span class="keyword">return</span> cache[row][column]; </span><br><span class="line">  <span class="comment">// 这里是递归的基本情况</span></span><br><span class="line">  <span class="keyword">if</span>(row===column||column==<span class="number">1</span>) &#123;</span><br><span class="line">    cache[row][column] = <span class="number">1</span>; <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记忆化</span></span><br><span class="line">  cache[row][column] = makeNum(row<span class="number">-1</span>, column<span class="number">-1</span>) + makeNum(row<span class="number">-1</span>, column); </span><br><span class="line">  <span class="keyword">return</span> cache[row][column];</span><br><span class="line">&#125;</span><br><span class="line">generate(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数，通常用 ​<code>F(n)</code>​ 表示，形成的序列称为斐波那契数列。该数列由 ​<code>0</code>​ 和 <code>​1</code>​ 开始，后面的每一项数字都是前面两项数字的和。也就是：<br><code>F(0) = 0, F(1) = 1</code><br><code>F(N) = F(N - 1) + F(N - 2)</code>, 其中 <code>N &gt; 1</code><br>给定 ​<code>N</code>​，计算 ​<code>F(N)</code>​。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入：<span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：F(<span class="number">2</span>) = F(<span class="number">1</span>) + F(<span class="number">0</span>) = <span class="number">1</span> + <span class="number">0</span> = <span class="number">1.</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：F(<span class="number">3</span>) = F(<span class="number">2</span>) + F(<span class="number">1</span>) = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2.</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：F(<span class="number">4</span>) = F(<span class="number">3</span>) + F(<span class="number">2</span>) = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure></p><p>分析：递归考虑记忆化优化<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用记忆化版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">return</span> fib(num<span class="number">-1</span>) + fib(num<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">50</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用记忆化版本</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 记忆化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(cache.has(num)) <span class="keyword">return</span> cache.get(num);</span><br><span class="line">  <span class="keyword">let</span> result = fib(num<span class="number">-1</span>) + fib(num<span class="number">-2</span>);</span><br><span class="line">  cache.set(num, result);</span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面两个版本，一个做了记忆化，一个没有，求50的斐波那契数，没做记忆化的用浏览器运行直接卡死，而做了记忆化的瞬间出结果。</p></blockquote><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设爬楼梯。需要 <code>n</code> 阶才能到达楼顶。<br>每次可以爬 <code>1</code> 或 <code>2</code> 个台阶。有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 <code>n</code> 是一个正整数。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>) <span class="number">2</span> 阶</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3</span>) <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure></p><p>分析：该问题通过规律发现递推关系就是斐波那契数。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">stepNum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="keyword">return</span> help(stepNum, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">stepNum, cache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(stepNum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(cache[stepNum]) <span class="keyword">return</span> cache[stepNum];</span><br><span class="line">  <span class="keyword">if</span>(stepNum &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    cache[stepNum] = stepNum;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    cache[stepNum] = help(stepNum<span class="number">-1</span>, cache) + help(stepNum<span class="number">-2</span>, cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[stepNum];</span><br><span class="line">&#125;</span><br><span class="line">climbStairs(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> binTree = &#123;</span><br><span class="line">  left: &#123;</span><br><span class="line">    left: &#123;</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: &#123; <span class="attr">left</span>: <span class="literal">null</span>, <span class="attr">right</span>: <span class="literal">null</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: &#123;</span><br><span class="line">      left: &#123;</span><br><span class="line">        left: <span class="literal">null</span>,</span><br><span class="line">        right: &#123;</span><br><span class="line">          left: &#123;</span><br><span class="line">            left: <span class="literal">null</span>,</span><br><span class="line">            right: &#123;</span><br><span class="line">              left: <span class="literal">null</span>,</span><br><span class="line">              right: &#123;</span><br><span class="line">                left: <span class="literal">null</span>,</span><br><span class="line">                right: <span class="literal">null</span>,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          right: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">返回的最大深度是<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>分析：二叉树是典型的具有递归属性的数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">binTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!binTree) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(!binTree.left &amp;&amp; !binTree.right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(binTree.left), maxDepth(binTree.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxDepth(binTree);</span><br></pre></td></tr></table></figure></p><h3 id="计算-x-的-n-次幂函数"><a href="#计算-x-的-n-次幂函数" class="headerlink" title="计算 x 的 n 次幂函数"></a>计算 x 的 n 次幂函数</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">输入: 2, 10</span><br><span class="line">输出: 1024</span><br><span class="line">// 2</span><br><span class="line">输入: 2.1, 3</span><br><span class="line">输出: 9.261</span><br></pre></td></tr></table></figure></p><p>说明：<br><code>-100.0 &lt; x &lt; 100.0</code><br><code>n</code> 是 <code>32</code> 位有符号整数，其数值范围是 <code>[−231, 231 − 1]</code><br>分析：n可能很大，需要防止栈溢出，可思考尾递归实现。<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n&gt;<span class="number">0</span> ? help(x, n) : <span class="number">1</span>/help(x, -n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">help</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x * help(x, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">myPow(<span class="number">2</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><h3 id="第K个语法符号"><a href="#第K个语法符号" class="headerlink" title="第K个语法符号"></a>第K个语法符号</h3><p>在第一行写上一个<code>0</code>​。接下来的每一行，将前一行中的​<code>0</code>​替换为​<code>01</code>​，<code>​1</code>​替换为​<code>10</code>​。<br>给定行数<code>N</code>和序数<code>​K</code>​，返回第<code>​N</code>行中第<code>​K</code>​个字符。（<code>​K</code>​从<code>1</code>开始）<br>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">输入: N = <span class="number">1</span>, K = <span class="number">1</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">输入: N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">输入: N = <span class="number">2</span>, K = <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">输入: N = <span class="number">4</span>, K = <span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">第一行: <span class="number">0</span></span><br><span class="line">第二行: <span class="number">01</span></span><br><span class="line">第三行: <span class="number">0110</span></span><br><span class="line">第四行: <span class="number">0110100</span></span><br></pre></td></tr></table></figure></p><p>注意：<br>​N​ 的范围 ​[1, 30]​.<br>​K​ 的范围 ​[1, 2^(N-1)]​.<br>分析：识别具有递归关系问题<br>code：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNStr</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">return</span> getNStr(n<span class="number">-1</span>).replace(<span class="regexp">/0|1/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">'01'</span>;</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'1'</span>) <span class="keyword">return</span> <span class="string">'10'</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKChar</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getNStr(n).charAt(k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getKChar(<span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，更加相信递归是一种强大的技术，它能够以一种优雅而有效的方式解决许多问题。同时，它也不是解决任务问题的灵丹妙药。由于时间或空间的限制，并不是所有的问题都可以用递归来解决。递归本身可能会带来一些不希望看到的副作用，如栈溢出。<br>有时，在解决实际问题时乍一看，并不清楚是否可以应用递归算法来解决问题。然而，由于递归的递推性质与所熟悉的数学非常接近，用数学公式来推导某些关系总是有帮助的，也就是说写出递推关系和基本情况是使用递归算法的前置条件。<br>只要有可能，就应用记忆化。在起草递归算法时，可以从最简单的策略开始。有时，在递归过程中，可能会出现重复计算的情况，例如斐波纳契数（Fibonacci）。在这种情况下，可以尝试应用 Memoization 技术，它将中间结果存储在缓存中供以后重用，它可以在空间复杂性上稍加折中，从而极大地提高时间复杂性，因为它可以避免代价较高的重复计算。<br>当堆栈溢出时，尾递归可能会有所帮助。<br>使用递归实现算法通常有几种方法。尾递归是实现递归的一种特殊形式。与记忆化技术不同的是，尾递归通过消除递归带来的堆栈开销，优化了算法的空间复杂度。更重要的是，有了尾递归，就可以避免经常伴随一般递归而来的堆栈溢出问题，而尾递归的另一个优点是，与非尾递归相比，尾部递归更容易阅读和理解。这是由于尾递归不存在调用后依赖（即递归调用是函数中的最后一个动作），这一点不同于非尾递归，因此，只要有可能，就应该尽量运用尾递归。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入的理解递归算法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="算法" scheme="/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-VUE模板编译概览</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-VUE%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%A6%82%E8%A7%88/"/>
    <id>/2023/01/04/前端编译原理-VUE模板编译概览/</id>
    <published>2023-01-04T09:01:05.000Z</published>
    <updated>2023-01-06T02:32:30.454Z</updated>
    
    <content type="html"><![CDATA[<p>VUE模板编译工作流程简介<br><a id="more"></a></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>VUE的模板是要被转换成js渲染函数，在运行时执行的。</p><h2 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h2><p><code>模板</code>-&gt;<code>parse(str)</code>-&gt;<code>模板AST</code>-&gt;<code>transform(ast)</code>-&gt;<code>javascript AST</code>-&gt;<code>generate(JSAST)</code>-&gt;<code>渲染函数</code></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><blockquote><p>词法分析是把字符串解析成tokens</p></blockquote><p>模板字符串转化后的tokens：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;div&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;text&apos;, content: &apos;Vue&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tag&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;text&apos;, content: &apos;Template&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;p&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;tagEnd&apos;, name: &apos;div&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>实现code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">const State = &#123;</span><br><span class="line">  initial: 1,</span><br><span class="line">  tagOpen: 2,</span><br><span class="line">  tagName: 3,</span><br><span class="line">  text: 4,</span><br><span class="line">  tagEnd: 5,</span><br><span class="line">  tagEndName: 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isAlpha(char) &#123;</span><br><span class="line">  return char &gt;= &apos;a&apos; &amp;&amp; char &lt;= &apos;z&apos; || char &gt;= &apos;A&apos; &amp;&amp; char &lt;= &apos;Z&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tokenize(str) &#123;</span><br><span class="line">  let currentState = State.initial</span><br><span class="line">  const chars = []</span><br><span class="line">  const tokens = []</span><br><span class="line">  while(str) &#123;</span><br><span class="line">    const char = str[0]</span><br><span class="line">    switch (currentState) &#123;</span><br><span class="line">      case State.initial:</span><br><span class="line">        if (char === &apos;&lt;&apos;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.text</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagOpen:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;/&apos;) &#123;</span><br><span class="line">          currentState = State.tagEnd</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&gt;&apos;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;tag&apos;,</span><br><span class="line">            name: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.text:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&lt;&apos;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;text&apos;,</span><br><span class="line">            content: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagEnd:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagEndName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case State.tagEndName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &apos;&gt;&apos;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &apos;tagEnd&apos;,</span><br><span class="line">            name: chars.join(&apos;&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><blockquote><p>语法分析是把词法分析出来的tokens解析成AST</p></blockquote><p>模板AST：<br><a href="#模板AST">⬇⬇⬇</a><br>实现code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function parse(str) &#123;</span><br><span class="line">  const tokens = tokenize(str)</span><br><span class="line"></span><br><span class="line">  const root = &#123;</span><br><span class="line">    type: &apos;Root&apos;,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;</span><br><span class="line">  const elementStack = [root]</span><br><span class="line"></span><br><span class="line">  while (tokens.length) &#123;</span><br><span class="line">    const parent = elementStack[elementStack.length - 1]</span><br><span class="line">    const t = tokens[0]</span><br><span class="line">    switch (t.type) &#123;</span><br><span class="line">      case &apos;tag&apos;:</span><br><span class="line">        const elementNode = &#123;</span><br><span class="line">          type: &apos;Element&apos;,</span><br><span class="line">          tag: t.name,</span><br><span class="line">          children: []</span><br><span class="line">        &#125;</span><br><span class="line">        parent.children.push(elementNode)</span><br><span class="line">        elementStack.push(elementNode)</span><br><span class="line">        break</span><br><span class="line">      case &apos;text&apos;:</span><br><span class="line">        const textNode = &#123;</span><br><span class="line">          type: &apos;Text&apos;,</span><br><span class="line">          content: t.content</span><br><span class="line">        &#125;</span><br><span class="line">        parent.children.push(textNode)</span><br><span class="line">        break</span><br><span class="line">      case &apos;tagEnd&apos;:</span><br><span class="line">        elementStack.pop()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    tokens.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模板AST"><a href="#模板AST" class="headerlink" title="模板AST"></a>模板AST</h3><blockquote><p>通过parse步骤后得到的模板AST：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Root&quot;,</span><br><span class="line">  &quot;children&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">      &quot;tag&quot;: &quot;div&quot;,</span><br><span class="line">      &quot;children&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">          &quot;tag&quot;: &quot;p&quot;,</span><br><span class="line">          &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Text&quot;,</span><br><span class="line">              &quot;content&quot;: &quot;Vue&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Element&quot;,</span><br><span class="line">          &quot;tag&quot;: &quot;p&quot;,</span><br><span class="line">          &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Text&quot;,</span><br><span class="line">              &quot;content&quot;: &quot;Template&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><blockquote><p>将模板AST转换成javascript AST，此处使用了插件结构，处理转换节点的函数是单独出来的</p></blockquote><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function transform(ast) &#123;</span><br><span class="line">  const context = &#123;</span><br><span class="line">    currentNode: null,</span><br><span class="line">    parent: null,</span><br><span class="line">    replaceNode(node) &#123;</span><br><span class="line">      context.currentNode = node</span><br><span class="line">      context.parent.children[context.childIndex] = node</span><br><span class="line">    &#125;,</span><br><span class="line">    removeNode() &#123;</span><br><span class="line">      if (context.parent) &#123;</span><br><span class="line">        context.parent.children.splice(context.childIndex, 1)</span><br><span class="line">        context.currentNode = null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nodeTransforms: [</span><br><span class="line">      transformRoot,</span><br><span class="line">      transformElement,</span><br><span class="line">      transformText</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用 traverseNode 完成转换</span><br><span class="line">  traverseNode(ast, context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseNode(ast, context) &#123;</span><br><span class="line">  context.currentNode = ast</span><br><span class="line"></span><br><span class="line">  const exitFns = []</span><br><span class="line">  const transforms = context.nodeTransforms</span><br><span class="line">  for (let i = 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">    const onExit = transforms[i](context.currentNode, context)</span><br><span class="line">    if (onExit) &#123;</span><br><span class="line">      exitFns.push(onExit)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!context.currentNode) return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const children = context.currentNode.children</span><br><span class="line">  if (children) &#123;</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      context.parent = context.currentNode</span><br><span class="line">      context.childIndex = i</span><br><span class="line">      traverseNode(children[i], context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let i = exitFns.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    exitFns[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插件工具函数"><a href="#插件工具函数" class="headerlink" title="插件工具函数"></a>插件工具函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">function transformText(node) &#123;</span><br><span class="line">  if (node.type !== &apos;Text&apos;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node.jsNode = createStringLiteral(node.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function transformElement(node) &#123;</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    if (node.type !== &apos;Element&apos;) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const callExp = createCallExpression(&apos;h&apos;, [</span><br><span class="line">      createStringLiteral(node.tag)</span><br><span class="line">    ])</span><br><span class="line">    node.children.length === 1</span><br><span class="line">      ? callExp.arguments.push(node.children[0].jsNode)</span><br><span class="line">      : callExp.arguments.push(</span><br><span class="line">        createArrayExpression(node.children.map(c =&gt; c.jsNode))</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    node.jsNode = callExp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformRoot(node) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    if (node.type !== &apos;Root&apos;) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const vnodeJSAST = node.children[0].jsNode</span><br><span class="line"></span><br><span class="line">    node.jsNode = &#123;</span><br><span class="line">      type: &apos;FunctionDecl&apos;,</span><br><span class="line">      id: &#123; type: &apos;Identifier&apos;, name: &apos;render&apos; &#125;,</span><br><span class="line">      params: [],</span><br><span class="line">      body: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &apos;ReturnStatement&apos;,</span><br><span class="line">          return: vnodeJSAST</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createStringLiteral(value) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;StringLiteral&apos;,</span><br><span class="line">    value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createIdentifier(name) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;Identifier&apos;,</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createArrayExpression(elements) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;ArrayExpression&apos;,</span><br><span class="line">    elements</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCallExpression(callee, arguments) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;CallExpression&apos;,</span><br><span class="line">    callee: createIdentifier(callee),</span><br><span class="line">    arguments</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="javascript-AST"><a href="#javascript-AST" class="headerlink" title="javascript AST"></a>javascript AST</h3><blockquote><p>模板字符串经过转换后生成的javascript AST:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;FunctionDecl&quot;,</span><br><span class="line">  &quot;id&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;render&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;params&quot;: [],</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line">      &quot;return&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">        &quot;callee&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;arguments&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;div&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ArrayExpression&quot;,</span><br><span class="line">            &quot;elements&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">                &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;h&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;p&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;Vue&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">                &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;h&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;p&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;Template&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><blockquote><p>得到转换后的javascript AST后，生成渲染函数字符串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">function generate(node) &#123;</span><br><span class="line">  const context = &#123;</span><br><span class="line">    code: &apos;&apos;,</span><br><span class="line">    push(code) &#123;</span><br><span class="line">      context.code += code</span><br><span class="line">    &#125;,</span><br><span class="line">    currentIndent: 0,</span><br><span class="line">    newline() &#123;</span><br><span class="line">      context.code += &apos;\n&apos; + `  `.repeat(context.currentIndent)</span><br><span class="line">    &#125;,</span><br><span class="line">    indent() &#123;</span><br><span class="line">      context.currentIndent++</span><br><span class="line">      context.newline()</span><br><span class="line">    &#125;,</span><br><span class="line">    deIndent() &#123;</span><br><span class="line">      context.currentIndent--</span><br><span class="line">      context.newline()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  genNode(node, context)</span><br><span class="line"></span><br><span class="line">  return context.code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNode(node, context) &#123;</span><br><span class="line">  switch (node.type) &#123;</span><br><span class="line">    case &apos;FunctionDecl&apos;:</span><br><span class="line">      genFunctionDecl(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;ReturnStatement&apos;:</span><br><span class="line">      genReturnStatement(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;CallExpression&apos;:</span><br><span class="line">      genCallExpression(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;StringLiteral&apos;:</span><br><span class="line">      genStringLiteral(node, context)</span><br><span class="line">      break</span><br><span class="line">    case &apos;ArrayExpression&apos;:</span><br><span class="line">      genArrayExpression(node, context)</span><br><span class="line">      break</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genFunctionDecl(node, context) &#123;</span><br><span class="line">  const &#123; push, indent, deIndent &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`function $&#123;node.id.name&#125; `)</span><br><span class="line">  push(`(`)</span><br><span class="line">  genNodeList(node.params, context)</span><br><span class="line">  push(`) `)</span><br><span class="line">  push(`&#123;`)</span><br><span class="line">  indent()</span><br><span class="line"></span><br><span class="line">  node.body.forEach(n =&gt; genNode(n, context))</span><br><span class="line"></span><br><span class="line">  deIndent()</span><br><span class="line">  push(`&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNodeList(nodes, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    const node = nodes[i]</span><br><span class="line">    genNode(node, context)</span><br><span class="line">    if (i &lt; nodes.length - 1) &#123;</span><br><span class="line">      push(&apos;, &apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genReturnStatement(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`return `)</span><br><span class="line">  genNode(node.return, context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genCallExpression(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  const &#123; callee, arguments: args &#125; = node</span><br><span class="line">  push(`$&#123;callee.name&#125;(`)</span><br><span class="line">  genNodeList(args, context)</span><br><span class="line">  push(`)`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genStringLiteral(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line"></span><br><span class="line">  push(`&apos;$&#123;node.value&#125;&apos;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genArrayExpression(node, context) &#123;</span><br><span class="line">  const &#123; push &#125; = context</span><br><span class="line">  push(&apos;[&apos;)</span><br><span class="line">  genNodeList(node.elements, context)</span><br><span class="line">  push(&apos;]&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><blockquote><p>经过transform转换后生成的渲染函数字符串：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function render () &#123;</span><br><span class="line">  return h(&apos;div&apos;, [h(&apos;p&apos;, &apos;Vue&apos;), h(&apos;p&apos;, &apos;Template&apos;)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function compile(template) &#123;</span><br><span class="line">  // 模板AST</span><br><span class="line">  const ast = parse(template);</span><br><span class="line">  // 将模板AST转换为javascript AST</span><br><span class="line">  transform(ast);</span><br><span class="line">  // 代码生成</span><br><span class="line">  const code = generate(ast.jsNode);</span><br><span class="line"></span><br><span class="line">  return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本篇内容摘取《VUE设计与实现》的第15章，简单的介绍了前端模板的编译解析步骤。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/VUE%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">本篇code</a><br><a href="https://github.com/HcySunYang/code-for-vue-3-book" target="_blank" rel="noopener">VUE设计与实现code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VUE模板编译工作流程简介&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-有限状态机</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>/2023/01/04/前端编译原理-有限状态机/</id>
    <published>2023-01-04T03:34:48.000Z</published>
    <updated>2023-01-04T07:01:49.030Z</updated>
    
    <content type="html"><![CDATA[<p>有限状态机在词法分析中的应用<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。</p></blockquote><p>有限状态机在计算机领域的应用非常多，本篇文章主要介绍下在词法解析方面的应用。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>将字符串<br><code>100+200-300</code><br>转化成如下tokens<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;100&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Punctuator&apos;, value: &apos;+&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;200&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Punctuator&apos;, value: &apos;-&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;Numeric&apos;, value: &apos;300&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 四则运算字符串</span><br><span class="line">const inputStr = &apos;100+200-300&apos;;</span><br><span class="line"></span><br><span class="line">// 匹配数字的正则</span><br><span class="line">const NumReg = /[0-9]/</span><br><span class="line">// 匹配标点符号的正则规则</span><br><span class="line">const PunctuatorReg = /[\+\-\*\/]/</span><br><span class="line"></span><br><span class="line">// 最终输出的所有tokens合集</span><br><span class="line">const tokens = []</span><br><span class="line"></span><br><span class="line">// 当前状态机中正在处理的token</span><br><span class="line">let currentToken = &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 词法分析函数</span><br><span class="line"> * @param &#123;*&#125; inputStr </span><br><span class="line"> * @returns tokens</span><br><span class="line"> */</span><br><span class="line">function stateMachine(inputStr) &#123;</span><br><span class="line">  // 定义状态机的初始状态判断函数</span><br><span class="line">  let state = start</span><br><span class="line">  // 依次迭代输入的字符串</span><br><span class="line">  // while(inputStr) &#123;</span><br><span class="line">  //   state = state(inputStr[0]);</span><br><span class="line">  //   inputStr = inputStr.slice(1);</span><br><span class="line">  // &#125;</span><br><span class="line">  inputStr.split(&quot;&quot;).forEach(char =&gt; &#123;</span><br><span class="line">      // 此处的char是每一个字符</span><br><span class="line">      // 调用state函数 并且传入char</span><br><span class="line">      state = state(char)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 遍历结束后仍然需要发送一次最后</span><br><span class="line">  tokens.push(currentToken)</span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 状态机初始函数</span><br><span class="line"> * @param &#123;*&#125; char 输入的字符</span><br><span class="line"> * @return &#123;*&#125; </span><br><span class="line"> */</span><br><span class="line">function start (char) &#123;</span><br><span class="line">  if(NumReg.test(char)) &#123;</span><br><span class="line">      // 首个输入的char是数字 初始化token为numeric</span><br><span class="line">      currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125;</span><br><span class="line">      // 返回的是一个nunmer的处理函数</span><br><span class="line">      return numeric</span><br><span class="line">  &#125;else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">      // 首个输入的char是标点符号 初始化current为punctuator</span><br><span class="line">      currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">      // 返回的是一个punctuator的处理函数</span><br><span class="line">      return punctuator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数字处理函数</span><br><span class="line">function numeric(char) &#123;</span><br><span class="line">  if(NumReg.test(char)) &#123;</span><br><span class="line">      // 如果当前输入是数字 不分词 连续累加value值</span><br><span class="line">      currentToken.value += char</span><br><span class="line">      // 返回numeric函数赋给state</span><br><span class="line">      return numeric</span><br><span class="line">  &#125;else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">      // 如果是标点符号 分词</span><br><span class="line">      // 如果当前输入的标点符号 进行分词</span><br><span class="line">      // 首先将旧的token输入到tokens中</span><br><span class="line">      emitToken(currentToken)</span><br><span class="line">      // 修改当前token</span><br><span class="line">      currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">      // 返回punctuator处理函数</span><br><span class="line">      return punctuator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标点符号状态处理函数</span><br><span class="line">function punctuator(char) &#123;</span><br><span class="line">  // 无论如何都要发射 因为标点符号在分词阶段不会被拼接起来</span><br><span class="line">  emitToken(currentToken)</span><br><span class="line">  if (NumReg.test(char)) &#123;</span><br><span class="line">    currentToken = &#123; type: &apos;Numeric&apos;, value: char &#125;</span><br><span class="line">    return numeric</span><br><span class="line">  &#125; else if (PunctuatorReg.test(char)) &#123;</span><br><span class="line">    currentToken = &#123; type: &apos;Punctuator&apos;, value: char &#125;</span><br><span class="line">    return punctuator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return punctuator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将token放入tokens中</span><br><span class="line">function emitToken(token) &#123;</span><br><span class="line">  // 重制 currentToken</span><br><span class="line">  currentToken = &#123; type: &apos;&apos;, value: &apos;&apos; &#125;</span><br><span class="line">  // 将上一次传入的token参数保存到最终输入的tokens中</span><br><span class="line">  tokens.push(token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(stateMachine(inputStr));</span><br></pre></td></tr></table></figure><h3 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 四则运算字符串</span><br><span class="line">const inputStr = &apos;100+200-300&apos;;</span><br><span class="line">// 匹配数字的正则</span><br><span class="line">const NumReg = /[0-9]/</span><br><span class="line">// 匹配标点符号的正则规则</span><br><span class="line">const PunctuatorReg = /[\+\-\*\/]/</span><br><span class="line">// 最终输出的所有tokens合集</span><br><span class="line">const tokens = []</span><br><span class="line">// 当前状态机中正在处理的token</span><br><span class="line">let currentToken = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">let type = &apos;start&apos;;</span><br><span class="line">function start(char, i, str) &#123;</span><br><span class="line">  if( type===&apos;start&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    type = &apos;Numberic&apos;;</span><br><span class="line">    currentToken += char;</span><br><span class="line">  &#125;else if(type===&apos;Numberic&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    currentToken += char;</span><br><span class="line">  &#125;else if(type===&apos;Numberic&apos;&amp;&amp;PunctuatorReg.test(char)) &#123;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Numberic&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    type = &apos;Punctuator&apos;;</span><br><span class="line">    currentToken = char;</span><br><span class="line">  &#125;else if(type===&apos;Punctuator&apos;&amp;&amp;NumReg.test(char)) &#123;</span><br><span class="line">    type = &apos;Numberic&apos;;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Punctuator&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    currentToken = char;</span><br><span class="line">  &#125;</span><br><span class="line">  if(type===&apos;Numberic&apos;&amp;&amp;i===(str.length-1)) &#123;</span><br><span class="line">    tokens.push(&#123;</span><br><span class="line">      type: &apos;Numberic&apos;,</span><br><span class="line">      value: currentToken</span><br><span class="line">    &#125;);</span><br><span class="line">    currentToken = &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stateMachine(str) &#123;</span><br><span class="line">  for(let i=0; i&lt;str.length; i++) &#123;</span><br><span class="line">    start(str[i], i, str);</span><br><span class="line">  &#125;</span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line">console.log(stateMachine(inputStr));</span><br></pre></td></tr></table></figure><p>上面两个案例结果一样，但是过程不同。案例一的状态变化是以返回函数的形式，对代码进行了抽象解耦。案例二有点面向过程的写法，代码冗余，逻辑复杂的话，肯定是第一种方法好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章只是简单的介绍下，有限状态机在编译的词法分析阶段的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有限状态机在词法分析中的应用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>前端编译原理-编译器流程</title>
    <link href="/2022/12/30/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
    <id>/2022/12/30/前端编译原理-编译器流程/</id>
    <published>2022-12-30T02:44:56.000Z</published>
    <updated>2022-12-30T08:53:48.922Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍前端编译器的工作流程<br><a id="more"></a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本篇文章主要针对前端的JSX语法标签进行编译解析。<br>接下来将使用 Esprima 结合一个简单的 Demo 来实现串通整个编译器的工作流程。</p><h2 id="解析阶段-Parsing"><a href="#解析阶段-Parsing" class="headerlink" title="解析阶段 (Parsing)"></a>解析阶段 (Parsing)</h2><p>首先，在编译器的初始阶段会接受一段代码，通常会是一串字符串。<br>如下JSX代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>编译器拿到这段字符串代码之后会进入解析阶段，在解析阶段主要会做以下两件事：词法分析和语法分析</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>当编译器接受到上边的字符串时，首先会将传入的字符串按照词法效果分割成为一系列被称为 Token 的东西，这一步通常被称为分词。<br>先来看看利用 Esprima Api 查看将上述代码进行词法分析后的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parse1.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 配置支持jsx和tokens 利用parseScript Api 打印对应的tokens</span><br><span class="line">const &#123; tokens &#125; = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true, tokens: true &#125;);</span><br><span class="line">console.log(tokens,&apos;tokens&apos;)</span><br></pre></td></tr></table></figure></p><p>此时上方的语句经过词法分析会被一步一步拆分成为这样的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;id&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;=&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;String&quot;,&quot;value&quot;: &quot;\&quot;app\&quot;&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;, </span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Hello&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;p&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXText&quot;,&quot;value&quot;: &quot;Jue Jin&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&lt;&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;/&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;JSXIdentifier&quot;,&quot;value&quot;: &quot;div&quot;&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;Punctuator&quot;,&quot;value&quot;: &quot;&gt;&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到针对上方传入的 JSX 语法被解析成为了一个 Token 组成的数组，数组中每一个对象即代表一个 Token 。<br>每个 Token 都是拥有对应的 type 属性表示它的类型以及 value 属性表示它的值。<br>这一步通过解析阶段的词法分析将传入的代码分割成为了一个个 Token ，通常使用有限状态机是词法分析的最佳途径。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上一步通过词法分析将输入的代码分割成为了一个 tokens 的数组，在这之后需要将 tokens 进行语法分析从而转化成为真正的抽象语法树（AST）形式。<br>所谓抽象语法树，你可以将它理解成为一颗圣诞树。上述 tokens 中每一个 token 都可以看作成为该圣诞树中的一个节点。<br>语法分析正式将上述分成的每个 Token 抽象成为一棵树，从而描述每个 Token 节点之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parse2.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 调用parseScript获得输入代码生成的抽象语法树</span><br><span class="line">const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);</span><br><span class="line">console.log(ast, &apos;ast&apos;)</span><br></pre></td></tr></table></figure></p><p>上述的 Token 在经过语法分析后会变成这样的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;body&quot;: [&#123;</span><br><span class="line">    &quot;type&quot;: &quot;ExpressionStatement&quot;,</span><br><span class="line">    &quot;expression&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">      &quot;openingElement&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;div&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;selfClosing&quot;: false,</span><br><span class="line">        &quot;attributes&quot;: [&#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXAttribute&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;id&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;value&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;app&quot;,</span><br><span class="line">            &quot;raw&quot;: &quot;\&quot;app\&quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;children&quot;: [&#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">        &quot;openingElement&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;p&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;selfClosing&quot;: false,</span><br><span class="line">          &quot;attributes&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;children&quot;: [&#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXText&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;Hello&quot;,</span><br><span class="line">          &quot;raw&quot;: &quot;Hello&quot;</span><br><span class="line">        &#125;],</span><br><span class="line">        &quot;closingElement&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXClosingElement&quot;,</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;p&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXText&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;Jue Jin&quot;,</span><br><span class="line">        &quot;raw&quot;: &quot;Jue Jin&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      &quot;closingElement&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;JSXClosingElement&quot;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">          &quot;name&quot;: &quot;div&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所谓的语法分析阶段其实就是将 Tokens 经过一系列语法分析成为这颗树，树中的每个节点都会保存各自节点对应的信息。<br>同时因为树形的数据结构也很好的反应出了各个节点之间的关系。</p><h2 id="转化阶段-Transformaiton"><a href="#转化阶段-Transformaiton" class="headerlink" title="转化阶段 (Transformaiton)"></a>转化阶段 (Transformaiton)</h2><p>编译器首先经过转移阶段后将输入的代码转变成为 AST 。之后会进入转化阶段，所谓转化阶段本质上就是对于抽象语法树的一个深度遍历过程。<br>在转化阶段，会遍历这颗抽象语法树从而对于匹配节点进行增删改查从而修改树形结构。<br>比如想为 p 节点上添加一个 id 为 text 的属性，那么此时在遍历 AST 的过程中遍历到对应节点时修改对应的节点属性即可，当然也可以直接粗暴的替换整个节点。</p><blockquote><p>关于 Estraverse ，它是针对 Esprima 生成的抽象语法树进行深度遍历的一个工具库。因为 Estraverse 这个库不支持 JSX 语法，所以这里使用它的一个拓展工具库 estraverse-fb 来实现 JSX 转化的抽象语法树的遍历。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// transform.js</span><br><span class="line">const esprima = require(&apos;esprima&apos;);</span><br><span class="line">// 深度遍历AST的工具库</span><br><span class="line">const esTraverseFb = require(&apos;estraverse-fb&apos;)</span><br><span class="line">// 生成AST节点的工具</span><br><span class="line">const &#123; builders &#125; = require(&apos;ast-types&apos;)</span><br><span class="line"></span><br><span class="line">const ast = esprima.parseScript(&apos;&lt;div id=&quot;app&quot;&gt;&lt;p&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;&apos;, &#123; jsx: true &#125;);</span><br><span class="line"></span><br><span class="line">// 深度优先的方式</span><br><span class="line">esTraverseFb.traverse(ast, &#123;</span><br><span class="line">  // 进入每个节点时都会出发enter函数</span><br><span class="line">  enter: function (node) &#123;</span><br><span class="line">    const &#123; type, openingElement &#125; = node</span><br><span class="line">    // 判断当前进入的节点是否是匹配的p节点</span><br><span class="line">    if (type === &apos;JSXElement&apos; &amp;&amp; openingElement.name.name === &apos;p&apos;) &#123;</span><br><span class="line">      // 生成当前需要添加的属性节点</span><br><span class="line">      const attribute = builders.jsxAttribute(</span><br><span class="line">        // 第一个参数是name</span><br><span class="line">        builders.jsxIdentifier(&apos;id&apos;),</span><br><span class="line">        // 第二个参数是value</span><br><span class="line">        builders.literal(&apos;text&apos;)</span><br><span class="line">      )</span><br><span class="line">      // 为该节点的开始标签中添加生成的属性 id=&apos;text&apos;</span><br><span class="line">      openingElement.attributes.push(attribute)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 离开每个节点时会触发leave函数</span><br><span class="line">  leave: function () &#123;</span><br><span class="line">    // nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ast);</span><br></pre></td></tr></table></figure><p>此时经过上述的转化，我们更改了原本的 AST 结构。我们将原始的 p 标签对应的节点修改成为了这样的结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;JSXElement&quot;,</span><br><span class="line">  &quot;openingElement&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;JSXOpeningElement&quot;,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;p&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;selfClosing&quot;: false,</span><br><span class="line">    // 这里我们为attributes中添加了一个属性节点</span><br><span class="line">    &quot;attributes&quot;: [&#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">        &quot;loc&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;JSXIdentifier&quot;,</span><br><span class="line">        &quot;comments&quot;: null,</span><br><span class="line">        &quot;optional&quot;: false,</span><br><span class="line">        &quot;typeAnnotation&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;value&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;loc&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">        &quot;comments&quot;: null,</span><br><span class="line">        &quot;regex&quot;: null</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;loc&quot;: null,</span><br><span class="line">      &quot;type&quot;: &quot;JSXAttribute&quot;,</span><br><span class="line">      &quot;comments&quot;: null</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生成阶段-Code-Generation"><a href="#生成阶段-Code-Generation" class="headerlink" title="生成阶段 (Code Generation)"></a>生成阶段 (Code Generation)</h2><p>上述经过解析阶段 (Parsing) 将输入的字符串转化成了抽象语法树 AST 结构。<br>之后经过转化阶段 (Transformaiton) 对于生成的抽象语法树进行深度遍历节点，从而对于某些节点进行了修改。‘<br>此时编译器拥有了经过处理后的抽象语法树，此时需要做的当然是将所谓的树形结构的抽象语法树转化成为新的代码。<br>这一步通常称为生成阶段(Code Generation)：通过抽象语法树反向转化成为生成的代码，此时最新的代码是根据修改后的 AST 生成的代码。<br>在生成阶段本质上就是遍历抽象语法树，根据抽象语法树上每个节点的类型和属性递归调用从而生成对应的字符串代码。<br>在代码生成阶段，可以借助 EscodeGen 将 AST 转化成为新的字符串代码。</p><blockquote><p>因为 EscodeGen 对于 JSX 语法并不支持，所以这里具体就不详细演示用法了，有兴趣的朋友可以自行尝试。</p></blockquote><p>上方将代码修改的抽象语法树会生成新的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;p id=&quot;text&quot;&gt;hello&lt;/p&gt;Jue Jin&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，一次编译器工作流程中包括解析、转化、生成这三个步骤。<br>如果自己想实现，请参考本站的<a href="/2020/07/20/the-super-tiny-compiler/">【tiny编译工具】</a><br><a href="https://github.com/jinux7/study-collections/tree/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">上面例子代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍前端编译器的工作流程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="编译" scheme="/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>\r与\n区别</title>
    <link href="/2022/12/26/r%E4%B8%8E-n%E5%8C%BA%E5%88%AB/"/>
    <id>/2022/12/26/r与-n区别/</id>
    <published>2022-12-26T06:30:06.000Z</published>
    <updated>2022-12-26T06:46:54.103Z</updated>
    
    <content type="html"><![CDATA[<p>\r回车与\n换行的区别<br><a id="more"></a></p><h2 id="回车和换行来源"><a href="#回车和换行来源" class="headerlink" title="回车和换行来源"></a>回车和换行来源</h2><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意儿，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。<br>这就是”回车”和”换行”的来历，从它们的英语名字上也可以看出一二。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>\r是回车，英文是Carriage return，缩写是CR，作用：使光标到行首。<br>\n是换行，英文是New line/line feed，缩写是LF，作用：使光标下移一行。</p><blockquote><p>如果用过机械打字机，就知道回车和换行的区别了。<br>回车就是把水平位置复位，不卷动滚筒。<br>换行就是把滚筒卷一格，不改变水平位置。<br>我们平时所说的键盘Enter键换行实则应该叫做叫做回车换行(\r\n)</p></blockquote><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>✪ Windows系统里面，每行结尾是 回车+换行(CR+LF)，即“\r\n”；<br>✪ Unix系统里，每行结尾只有 换行CR，即“\n”；<br>✪ Mac系统里，每行结尾是 回车CR 即’\r’；<br>直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p><h2 id="兼容处理"><a href="#兼容处理" class="headerlink" title="兼容处理"></a>兼容处理</h2><p>在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。<br>在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化。<br>如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;\r回车与\n换行的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>javascript常用中英文惯译法</title>
    <link href="/2022/12/06/javascript%E5%B8%B8%E7%94%A8%E4%B8%AD%E8%8B%B1%E6%96%87%E6%83%AF%E8%AF%91%E6%B3%95/"/>
    <id>/2022/12/06/javascript常用中英文惯译法/</id>
    <published>2022-12-06T03:07:18.000Z</published>
    <updated>2022-12-07T01:57:58.553Z</updated>
    
    <content type="html"><![CDATA[<p>javascript常用中英文惯译法<br><a id="more"></a></p><h2 id="语法或词法分析"><a href="#语法或词法分析" class="headerlink" title="语法或词法分析"></a>语法或词法分析</h2><blockquote><p>标识符（identifier）<br>标签（label）<br>关键字，保留字（keyword,reserved words）<br>符号（symbol）<br>标记，记号（token）<br>数据类型（types,data types）<br>无类型的（untype-）<br>变量（variable）<br>声明（declare）<br>赋值（assignment）<br>解构赋值（destructuring assignment）<br>未赋值变量（unassigned variable）<br>未声明变量（undeclared variable）<br>值（values）<br>常量，常数，常值（constant,const）<br>直接量，字面量（literal,literal constant,manifest constant）<br>指数计数法，科学计数法（exponential notation）<br>定点计数法（fixed-point notation）<br>代码逻辑行，物理行（logical line,physical line）<br>语句（statements）<br>语句块（statement block）<br>简单语句（simple statements）<br>单行语句（single line statements）<br>复合语句（compound statements）<br>条件（condition）<br>表达式（expression）<br>一元运算符，单目运算符（unary operator）<br>二元运算符（binary operator）<br>运算符优先级（precedence）<br>运算符，操作符，操作数（operator）</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数组（array）<br>关联数组（associative array）<br>索引数组（index array）<br>多维数组（multidimensional array）<br>动态数组（dynamic arry）<br>变长数组（variable length array）<br>元素（element）<br>索引，下标（index）<br>字符串（string）<br>Unicode 字符串（Unicode string）<br>转义序列（escape sequence）</p></blockquote><h2 id="编程范型（面向对象，函数式等）"><a href="#编程范型（面向对象，函数式等）" class="headerlink" title="编程范型（面向对象，函数式等）"></a>编程范型（面向对象，函数式等）</h2><blockquote><p>编程范型（programming paradigm）<br>多范型语言（multi-paradigm language）<br>动态绑定（dynamic bind）<br>作用域（scope）<br>引用（reference）<br>域，成员，字段（member,field）<br>类（class）<br>继承（inheritance）<br>多态（polymorphism）<br>封装（encapsulation）<br>类方法（class method）<br>虚方法（virtual method）<br>纯虚方法，抽象方法（abstract method）<br>覆盖（override）<br>对象（object）<br>实例（instance）<br>原型（prototype）<br>构造器，构造函数（constructor,constructor function）<br>属性（property）<br>方法（method）<br>用户定义属性（user-defined properties）<br>预定义属性（pre-defined properties）<br>内部（内建）属性/方法/成员（build-in properties/method/member）<br>事件（event）<br>事件句柄，事件处理器，事件处理代码（event handle）<br>特性，性质，属性（attribute）<br>特性（feature）<br>函数（function）<br>参数（arguments）<br>外部局部变量（external local variable,upvalue）<br>lambda运算（lambda calculus）<br>闭包（closure）</p></blockquote><h2 id="编译、执行及其他"><a href="#编译、执行及其他" class="headerlink" title="编译、执行及其他"></a>编译、执行及其他</h2><blockquote><p>解释器（interpreter）<br>运行期（runtime）<br>宿主（host）<br>上下文（context）<br>环境（environment）<br>执行环境，执行上下文（execution context）<br>异常（exception）<br>错误（error）<br>正则表达式（regular expression）<br>全局（global）<br>局部（local）<br>全局对象（global object）<br>全局变量（global variable）<br>局部变量（local variable）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript常用中英文惯译法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GPU和CSS硬件加速</title>
    <link href="/2022/10/21/GPU%E5%92%8CCSS%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    <id>/2022/10/21/GPU和CSS硬件加速/</id>
    <published>2022-10-21T06:38:55.000Z</published>
    <updated>2022-10-21T06:48:54.352Z</updated>
    
    <content type="html"><![CDATA[<p>彻底搞懂GPU和CSS硬件加速<br><a id="more"></a></p><h2 id="从-cpu-聊起"><a href="#从-cpu-聊起" class="headerlink" title="从 cpu 聊起"></a>从 cpu 聊起</h2><p>cpu (central process) 是计算机的大脑，它提供了一套指令集，我们写的程序最终会通过 cpu 指令来控制的计算机的运行。</p><p>cpu 会对指令进行译码，然后通过逻辑电路执行该指令。整个执行的流程分为了多个阶段，叫做流水线。指令流水线包括取指令、译码、执行、取数、写回五步，这是一个指令周期。cpu 会不断的执行指令周期来完成各种任务。</p><p>指令和数据都会首先加载到内存中，在程序运行时依次取到 cpu 里。cpu 访问内存虽然比较快，但比起 cpu 执行速度来说还是比较慢的，为了缓解这种速度矛盾，cpu 设计了 3 级缓存，也就是 L1、L2、L3 的缓存。<br><img src="/2022/10/21/GPU和CSS硬件加速/1.webp" alt="img"><br>如图，多核 cpu 各核心都有自有独立的 L1、L2 缓存，然后共享 L3 缓存，这 3 级缓存容量是逐渐递增的，但是速度是逐渐下降的，但是也会比访问内存快一些。</p><p>有了这 3 级缓存以后，cpu 执行速度和访问内存速度的矛盾就可以得到缓解，不需要一直访问内存，cpu 每次会加载一个缓存行，也就是 64 字节大小的数据到缓存中。这样访问临近的数据的时候就可以直接访问缓存。</p><p>从内存中把数据和指令加载到 cpu 的缓存中，然后通过控制器控制指令的译码、执行，通过运算器进行运算，之后把结果写回内存。这就是 cpu 的工作流程。</p><p>cpu 每个核只有一个线程，也就是单控制流、单数据流。这样的架构导致 cpu 在一些场景下效率是不高的，比如 3d 渲染的场景。</p><h2 id="3d-渲染流程"><a href="#3d-渲染流程" class="headerlink" title="3d 渲染流程"></a>3d 渲染流程</h2><p>3d 的渲染首先是建立 3d 的模型，它由一系列三维空间中的顶点构成，3 个顶点构成一个三角形，然后所有的顶点构成的三角形拼接起来就是 3d 模型。<br><img src="/2022/10/21/GPU和CSS硬件加速/2.webp" alt="img"><br>顶点、三角形，这是 3d 的基础。3d 引擎首先要计算顶点数据，确定 3d 图形的形状。之后还要对每个面进行贴图，可以在每个三角形画上不同的纹理。</p><p>3d 图形要显示在二维的屏幕上就要做投影，这个投影的过程叫做光栅化。（光栅是一种光学仪器，在这里就代表 3d 投影到 2d 屏幕的过程）<br><img src="/2022/10/21/GPU和CSS硬件加速/3.webp" alt="img"><br>光栅化要计算 3d 图形投影到屏幕的每一个像素的颜色，计算完所有的像素之后会写到显存的帧缓冲区，完成了一帧的渲染，之后会继续这样计算下一帧。</p><p>也就是说，3d 渲染的流程是：</p><blockquote><p>计算顶点数据，构成 3d 的图形<br>给每个三角形贴图，画上纹理<br>投影到二维的屏幕，计算每个像素的颜色（光栅化）<br>把一帧的数据写入显存的帧缓冲区</p></blockquote><p>顶点的数量是非常庞大的，而 cpu 只能顺序的一个个计算，所以处理这种 3d 渲染会特别费劲，于是就出现了专门用于这种 3d 数据的并行计算的硬件，也就是 GPU。</p><h2 id="GPU-的构成"><a href="#GPU-的构成" class="headerlink" title="GPU 的构成"></a>GPU 的构成</h2><p>和 cpu 的一个一个数据计算不同，gpu 是并行的，有成百上千个核心用于并行计算。<br><img src="/2022/10/21/GPU和CSS硬件加速/4.webp" alt="img"><br>gpu 也是有着指令、译码、执行的流程，只不过，每个指令会并行执行 n 个计算，是单控制流多数据流的，而 cpu 是单控制流单数据流。</p><p>所以，对于 3d 渲染这种要计算成万个顶点数据和像素点的场景，GPU 会比 CPU 高效很多。</p><p>但是，gpu 全是优点么？也不是。</p><h2 id="cpu-和-gpu-的区别"><a href="#cpu-和-gpu-的区别" class="headerlink" title="cpu 和 gpu 的区别"></a>cpu 和 gpu 的区别</h2><p>cpu 是通用的，能够执行各种逻辑和运算，而 gpu 则是主要是用于并行计算大批量的重复任务，不能处理复杂逻辑。</p><p>如上图，cpu 中控制器和缓存占据了很大一部分，而 gpu 中这两部分则很少，但是有更多的核心用于计算。</p><p>两者对比的话，cpu 相当于一个大学生，能够解决各种难题，但是计算 1 万个加法就没那么快，而 gpu 就像一帮小学生，解决不了难题，但是计算加法这种就很快，因为人多。</p><p>也就是说如果逻辑复杂，那么只能用 cpu，如果只是计算量大，并且每个计算都比较重复，那就比较适合 gpu。</p><p>3d 的渲染中有大量这种重复却简单的计算，比如顶点数据和光栅化的像素数据，通过 gpu 就可以并发的一次计算成百上千个。</p><h2 id="opengl、webgl、css-硬件加速"><a href="#opengl、webgl、css-硬件加速" class="headerlink" title="opengl、webgl、css 硬件加速"></a>opengl、webgl、css 硬件加速</h2><p>显卡中集成了 gpu，提供了驱动，使用 gpu 能力需要使用驱动的 api。 gpu 的 api 有一套开源标准叫做 opengl，有三百多个函数，用于各种图形的绘制。（在 windows 下有一套自己的标准叫做 DirectX）</p><p>我们在网页中绘制 3d 图形是使用 webgl 的 api，而浏览器在实现 webgl 的时候也是基于 opengl 的 api，最终会驱动 gpu 进行渲染。</p><p>css 大部分样式还是通过 cpu 来计算的，但 css 中也有一些 3d 的样式和动画的样式，计算这些样式同样有很多重复且大量的计算任务，可以交给 gpu 来跑。</p><p>浏览器在处理下面的 css 的时候，会使用 gpu 渲染：</p><blockquote><p>transform<br>opacity<br>filter<br>will-change</p></blockquote><p>浏览器是把内容分到不同的图层分别渲染的，最后合并到一起，而触发 gpu 渲染会新建一个图层，把该元素样式的计算交给 gpu。</p><p>opacity 需要改变每个像素的值，符合重复且大量的特点，会新建图层，交给 gpu 渲染。transform 是动画，每个样式值的计算也符合重复且大量的特点，也默认会使用 gpu 加速。同理 fiter 也是一样。</p><p>这里要注意的是 gpu 硬件加速是需要新建图层的，而把该元素移动到新图层是个耗时操作，界面可能会闪一下，所以最好提前做。will-change 就是提前告诉浏览器在一开始就把元素放到新的图层，方便后面用 gpu 渲染的时候，不需要做图层的新建。</p><p>当然，有的时候我们想强制触发硬件渲染，就可以通过上面的属性，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">will-change: transform;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform:translate3d(0, 0, 0);</span><br></pre></td></tr></table></figure></p><p>chrome devtools 可以看到是 cpu 渲染还是 gpu 渲染，打开 rendering 面板，勾选 layer borders，会发现蓝色和黄色的框。蓝色的是 cpu 渲染的，而黄色的是 gpu 渲染的。</p><p>比如这段文字，现在没有单独一个图层：<br><img src="/2022/10/21/GPU和CSS硬件加速/5.webp" alt="img"><br>添加一个 will-change: transform 的属性，浏览器会新建图层来渲染该元素，然后使用 gpu 渲染：<br><img src="/2022/10/21/GPU和CSS硬件加速/6.webp" alt="img"><br>gpu 硬件加速能减轻 cpu 压力，使得渲染更流畅，但是也会增加内存的占用，对于 transform、opacity、filter 默认会开启硬件加速。其余情况，建议只在必要的时候用。</p><h2 id="opencl-和神经网络"><a href="#opencl-和神经网络" class="headerlink" title="opencl 和神经网络"></a>opencl 和神经网络</h2><p>重复且大量的计算任务只有 3d 渲染一种场景么？</p><p>不是的，AI 领域的机器学习也很典型，它的特点是大量的神经元需要计算，但是每个计算都比较简单，也很适合用 gpu 来跑。</p><p>现在的 gpu 不只是能跑图形渲染，也提供了一些编程能力，这部分 api 有 opencl 标准。可以通过 gpu 的并行计算能力来跑一些有大量计算但是没有很多逻辑的的任务，会比 cpu 效率更高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cpu 提供了指令集，会不断的执行取指令、译码、执行、取数、写回的指令周期，控制着计算机的运转。</p><p>cpu 计算的速度比较快，而访问内存比较慢，为了缓和两者的矛盾，引入了 L1、L2、L3 的多级缓存体系，L1、L2、L3 是容器逐渐变大，访问速度逐渐变慢的关系，但还是比访问内存快。内存会通过一个缓存行（64 字节）的大小为单位来读入缓存，供 cpu 访问。</p><p>3d 渲染的流程是计算每一个顶点的数据，连成一个个三角形，然后进行纹理贴图，之后计算投影到二维屏幕的每一个像素的颜色，也就是光栅化，最后写入显存帧缓冲区，这样进行一帧帧的渲染。</p><p>cpu 的计算是一个个串行执行的，对于 3d 渲染这种涉及大量顶点、像素要计算的场景就不太合适，于是出现了 gpu。</p><p>gpu 可以并行执行大量重复的计算，有成百上千个计算单元，相比 cpu 虽然执行不了复杂逻辑，但是却能执行大量重复的运算。提供了 opengl 的标准 api。</p><p>css 中可以使用 gpu 加速渲染来减轻 cpu 压力，使得页面体验更流畅，默认 transform、opacity、filter 都会新建新的图层，交给 gpu 渲染。对于这样的元素可以使用 will-change: 属性名; 来告诉浏览器在最开始就把该元素放到新图层渲染。</p><p>gpu 的并行计算能力不只是 3d 渲染可以用，机器学习也有类似的场景，可以通过 opencl 的 api 来控制 gpu 进行计算。</p><p>gpu 和前端的关系还是挺密切的，不管是 webgl，还是 css 硬件加速，或者网页的性能都与之相关。希望这篇文章能够帮大家了解 gpu 的原理和应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;彻底搞懂GPU和CSS硬件加速&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="web图形" scheme="/tags/web%E5%9B%BE%E5%BD%A2/"/>
    
      <category term="3D" scheme="/tags/3D/"/>
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>css中的单位</title>
    <link href="/2022/10/21/css%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BD%8D/"/>
    <id>/2022/10/21/css中的单位/</id>
    <published>2022-10-21T05:39:28.000Z</published>
    <updated>2022-10-21T06:30:28.148Z</updated>
    
    <content type="html"><![CDATA[<p>css中的一些单位<br><a id="more"></a><br>说起CSS单位，我们最熟悉的可能就是像素单位（px），它是一个绝对单位，也就是说一个10px的文字，放在哪里都是一样大的。单位可以影响颜色、距离、尺寸等一系列的属性。CSS中单位的形式有很多种，下面就分别来看看这些单位。<br><img src="/2022/10/21/css中的单位/1.webp" alt="img"></p><h2 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h2><p>相对单位就是相对于另一个长度的长度。CSS中的相对单位主要分为两大类：</p><blockquote><p>字体相对单位，他们都是根据font-size来进行计算的。常见的字体相对单位有：em、rem、ex、ch；<br>视窗相对单位，他们都是根据视窗大小来决定的。常见的视窗相对单位有vw、vh、vmax、vmin。</p></blockquote><h3 id="em-和-rem"><a href="#em-和-rem" class="headerlink" title="em 和 rem"></a>em 和 rem</h3><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>em是最常见的相对长度单位，适合基于特定的字号进行排版。根据CSS的规定，1em 等于元素的font-size属性的值。<br>em 是相对于父元素的字体大小进行计算的。如果当前对行内文本的字体尺寸未进行显示设置，则相对于浏览器的默认字体尺寸。当DOM元素嵌套加深时，并且同时给很多层级显式的设置了font-size的值的单位是em，那么就需要层层计算，复杂度会很高。<br><strong>如果自身元素是没有设置字体大小的，那么就会根据其父元素的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算。</strong><br>em单位除了可以作用于 font-size之外，还可以运用于其他使用长度的属性，比如border-width、width、height、margin、padding、text-shadow等。<br>所以，em的使用还是比较复杂的，它可能会继承任意一级父元素的字体大小。需要谨慎使用。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem相对于em就简单了很多，它是根据页面的根元素（根元素）的字体大小来计算的。<br>如果没有对根元素设定字号的话，font-size: 1rem的作用与font-size: initial相同。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>使用 em 和 rem 可以让我们灵活的够控制元素整体的放大和缩小，而不是固定大小。那何时应使用 em，何时应使用 rem 呢？可以根据两者的差异来进行选择：</p><blockquote><p>两者在客户端中计算出来的样式都会以px的形式显示；<br>rem是相对于根元素html的font-size计算，em 相对于元素的font-size计算；<br>当需要根据浏览器的font-size设置缩放时，应该使用 rem；<br>使用 em 应该根据组件的font-size来定，而不是根元素的font-size来定；<br>rem 可以从浏览器字体设置中继承 font-size 值， em 可能受任何继承过来的父元素 font-size 的影响。</p></blockquote><h3 id="ex-和-ch"><a href="#ex-和-ch" class="headerlink" title="ex 和 ch"></a>ex 和 ch</h3><p>ex 和 ch 都是排版用的单位，它们的大小取决于元素的font-size 和 font-family属性。</p><blockquote><p>ex 指的是所用字体中小写字母 x 的高度。因此，如果两个字体不一样，那么 ex 的值是不一样的。因为每种字体的小写 x 的高度是不一样的。<br>ch 和 ex 类似，不过它是基于数字 0 的宽度计算的。会随着字体的变化而变化。而0 的宽度通常是对字体的平均字符宽度，它是一个估计值。由于 ch 是一个近似等宽的单元，所以在设置容器的宽度时很有用，比如一个容器想要显示指定个数的字符串时，就可以使用这个单位。</p></blockquote><h3 id="vw、vh、vmax-和-vmin"><a href="#vw、vh、vmax-和-vmin" class="headerlink" title="vw、vh、vmax 和 vmin"></a>vw、vh、vmax 和 vmin</h3><p>这四个单位都是视窗单位，所谓的视窗，在web端指的就是可视区域，移动端的视窗指的就是布局视窗。如果视窗大小发生了变化，那么这些值都会随之变化。这四个单位指的是：</p><blockquote><p>vw：视窗宽度的百分比；<br>vh：视窗高度的百分比；<br>vmax：较大的 vh 和 vw；<br>vmin：较小的 vh 和 vw。</p></blockquote><p>假如一个浏览器的高度是800px，那么1vh的值就是8px。vh和vw的大小总是和视窗的高度和宽度有关。 ​<br>vmin 和 vmax 与视窗宽度和高度的最大值和最小值有关。假如一个浏览器高度为500px，宽度为1200px，那么1vmin就是5px，1vmax就是12px。</p><h2 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h2><p>在 CSS 中，绝对单位包括： px 、pt 、pc、 cm 、 mm 、in 等。绝对单位是一个固定的值，它反应了一个真实的物理尺寸。它不会受屏幕大小或者字体的影响。它们的大小取决于值以及屏幕的分辨率（DPI，每英寸的点数）。px就是我们最常用的绝对单位之一。这些绝对单位的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1in = 25.4mm = 2.54cm = 6pc = 72pt =96px</span><br></pre></td></tr></table></figure></p><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>px 全称为 Pixels，表示像素，它并不严格等于显示器的像素，尤其在高清屏下。尽管CSS单位会根据浏览器、操作系统或者硬件适当缩放，在某些设备或者用户的分辨率设置下也会发生变化，但是96px通常等于一个物理英寸的大小。<br>CSS 将光栅图像(如照片等)的显示方式定义为默认每一个图像大小为1px。 一个“600x400”解析度的照片的长宽分别为“600px”和“400px”，所以照片本身的像素并不会与显示装置像素一致，而是与 px 单位一致。如此就可以将图像完整的与网页的其它元素排列起来。 ​<br>很多时候， px 也常被称为 CSS 像素。它是一个绝对单位，但也可以被视为相对单位，因为像素单位相对的是设备像素。在同一个设备上，每 1 个 CSS 像素所代表的物理像素是可以变化的；在不同的设备之间，每 1 个 CSS 像素所代表的物理像素是可以变化的。</p><h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>pt 全称为 Point，表示点。常用于软件设计和排版印刷行业（笔者做的前端系统，最终的产物就是一个需要拿去印刷的PDF，所以会经常用到这个单位）。当使用这个单位时，无论显示器的分辨率是多少，打印在纸上的结果都是一样的。 ​<br>如果单纯为了网页的显示，建议就使用px像素单位，如果需要输出印刷产品，就可以考虑使用pt。</p><h3 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h3><p>pc 全程为 Picas，表示派卡。相当于我国新四号铅字的尺寸。派卡也是印刷的术语，1派卡等于12点。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1pc = 16px</span><br></pre></td></tr></table></figure></p><h3 id="cm"><a href="#cm" class="headerlink" title="cm"></a>cm</h3><p>cm 全称为 Centimeters，表示厘米。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1cm = 37.8px</span><br></pre></td></tr></table></figure></p><h3 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h3><p>mm 全称为 Millimeters，表示毫米。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1mm = 3.78px</span><br></pre></td></tr></table></figure></p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>in 全称为 Inches，表示英寸。它和 px 的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1in = 96px</span><br></pre></td></tr></table></figure></p><h2 id="频率单位"><a href="#频率单位" class="headerlink" title="频率单位"></a>频率单位</h2><p>CSS中的频率单位有两个：赫兹（Hz）和千赫兹（kHz）。它们的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1kHz = 1000Hz</span><br></pre></td></tr></table></figure></p><p>通常情况下，频率单位使用在听或说级联样式表中。频率可以被用来改变一个语音阅读文本的音调。低频率就是低音，高频率就是高音。<br>需要注意，当数值为0时，单位对值没有影响，但是单位是不能省略的。也就是说0、0Hz、0kHz是不一样的。所以，在使用频率单位时，不要直接写0。另外，这两个单位是不区分大小写的。</p><h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>CSS中的时间单位有两个：秒（s）和毫秒（ms）。这两个时间单位都是CSS新增的单位。这两个单位的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1s = 1000ms</span><br></pre></td></tr></table></figure></p><p>时间单位主要用于过度和动画中，用于定义持续时间或延迟时间。</p><h2 id="分辨率单位"><a href="#分辨率单位" class="headerlink" title="分辨率单位"></a>分辨率单位</h2><p>CSS中的分辨率单位有三个：dpi、dpcm、dppx。这三个单位都是CSS3中华新增的单位。他们都是正值，不允许为负值。这三个单位的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1dppx = 96dpi</span><br><span class="line">1dpi ≈ 0.39dpcm</span><br><span class="line">1dpcm ≈ 2.54dpi</span><br></pre></td></tr></table></figure></p><p>分辨率单位主要用于媒体查询等操作。</p><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>dpi 全称为 dots per inch，表示每英寸包含的点的数量。普通屏幕通常包含 72或96个点，大于 192dpi 的屏幕被称为高分屏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-resolution: 96dpi) &#123; ... &#125;</span><br><span class="line">@media print and (min-resolution: 300dpi) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h3 id="dpcm"><a href="#dpcm" class="headerlink" title="dpcm"></a>dpcm</h3><p>dpcm 全称为 dots per centimeter，表示每厘米包含的点的数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-resolution: 28dpcm) &#123; ... &#125;</span><br><span class="line">@media print and (min-resolution: 118dpcm) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h3 id="dppx"><a href="#dppx" class="headerlink" title="dppx"></a>dppx</h3><p>dppx 全称为 dots per pixel，表示每像素（px）包含点的数量。由于CSS px的固定比率为1:96，因此1dppx相当于96dpi。它对应于由图像分辨率定义的CSS中显示的图像的默认分辨率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-resolution: 2dppx) &#123; ... &#125;</span><br><span class="line">@media screen and (min-resolution: 1dppx) and (max-resolution: 1.9dppx) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h2 id="角度单位"><a href="#角度单位" class="headerlink" title="角度单位"></a>角度单位</h2><p>CSS中的角度单位有四个：deg、grad、rad、turn。这些角度单位都是CSS3中新增的单位。它们的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90deg = 100grad = 0.25turn ≈ 1.570796326794897rad</span><br></pre></td></tr></table></figure></p><p>一般这些角度单位用于元素的旋转操作，包括2D旋转、3D旋转等。</p><blockquote><p>当旋转值为正值时，元素会顺时针旋转；<br>当旋转值为负值时，元素会逆时针旋转。</p></blockquote><p>通常情况下，一个完整的旋转就是360度。所以，所有的角度都在0-360度之间。但是，超出这个范围的值也是允许的，只不过都会归到0-360度之间。比如，顺时针旋转450度（450deg）、逆时针旋转270度（-270deg）、顺时针旋转90度（90deg）都是一样的效果，都会归为90deg。但是当使用动画时，这些角度值就非常重要了。<br>CSS的旋转主要依赖于 transform 属性中的 rotate() 、rotate3d、 skew() 等方法。只需给它们传递旋转的角度即可。 ​<br>除了旋转会使用角度之外，线性渐变也会经常使用角度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(45deg, #000, #fff);</span><br></pre></td></tr></table></figure></p><h3 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h3><p>deg 全称为 Degress，表示度，一个圆总共360度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(2deg);</span><br></pre></td></tr></table></figure></p><h3 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h3><p>grad 全称为 Gradians，表示梯度，一个圆总共400梯度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(2grad);</span><br></pre></td></tr></table></figure></p><h3 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h3><p>rad 全称为 Radians，表示弧度，一个圆总共2π弧度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(2rad);</span><br></pre></td></tr></table></figure></p><h3 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h3><p>turn 全称为 Turns，表示圈（转），一个圆总共一圈（转）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform:rotate(.5turn);</span><br></pre></td></tr></table></figure></p><h2 id="百分比单位"><a href="#百分比单位" class="headerlink" title="百分比单位"></a>百分比单位</h2><p>百分比（%）也是我们比较常用的单位之一，所有接受长度值的属性都可以使用百分比单位。但是不同属性使用该单位的效果可能并不一样。但是都需要有一个参照值，也就是说百分比值是一个相对的值。 ​</p><h3 id="盒模型中的百分比"><a href="#盒模型中的百分比" class="headerlink" title="盒模型中的百分比"></a>盒模型中的百分比</h3><p>在CSS中的盒模型包含的属性有：width、max-width、min-width、height、max-height、min-height、padding、margin等。这些属性在使用百分比时，参照物不尽相同：</p><blockquote><p>width、max-width、min-width：值为百分比时，其相对于包含块的 width 进行计算；<br>height、max-height、min-height：值为百分比时，其相对于包含块的 height 进行计算；<br>padding、margin：值为百分比时，如果是水平的值，就是相对于包含块的 width 进行计算；如果是垂直的值，也是相对于包含块的 width 进行计算。</p></blockquote><h3 id="文本中的百分比"><a href="#文本中的百分比" class="headerlink" title="文本中的百分比"></a>文本中的百分比</h3><p>在CSS中文本控制的属性有font-size、line-height 、vertical-align、 text-indent等。这些属性在使用百分比时，参照物不尽相同：</p><blockquote><p>font-size：根据父元素的font-size 进行计算；<br>line-height：根据font-size进行计算；<br>vertical-align：根据line-height进行计算；<br>text-indent：如果是水平的，则根据width进行计算，如果是垂直的，则根据 height 进行计算。</p></blockquote><h3 id="定位中的百分比"><a href="#定位中的百分比" class="headerlink" title="定位中的百分比"></a>定位中的百分比</h3><p>在CSS中用控制 position 位置的top、right、bottom、left都可以使用百分比作为单位。其参照物就是包含块的同方向的width和height。不同定位的包含块不尽相同：</p><blockquote><p>如果元素为静态（ static ）或相对定位（ relative ），包含块一般是其父容器；<br>如果元素为绝对定位（ absolute ），包含块应该是离它最近的 position 为 absolute 、 relative 或 fixed 的祖先元素；<br>如果元素为固定定位（ fixed ），包含块就是视窗（ viewport ）。</p></blockquote><h3 id="变换中的百分比"><a href="#变换中的百分比" class="headerlink" title="变换中的百分比"></a>变换中的百分比</h3><p>CSS 中的 transform 属性中的 translate 和 transform-origin 值也可以设置百分比。</p><blockquote><p>translateX() 根据容器的 width 计算<br>translateY() 根据容器的 height 计算<br>transform-origin 中横坐标（ x ）相对于容器的 width 计算；纵坐标（ y ）相对于容器的 height 计算</p></blockquote><p>注意，在 translate 还有一个 z 轴的函数 translateZ() 。它是不接受百分比为单位的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css中的一些单位&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>github工作流</title>
    <link href="/2022/10/14/github%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>/2022/10/14/github工作流/</id>
    <published>2022-10-14T03:21:29.000Z</published>
    <updated>2022-10-14T03:26:14.090Z</updated>
    
    <content type="html"><![CDATA[<p>常用的一种github工作流<br><a id="more"></a></p><blockquote><p>1.git clone // 到本地<br>2.git checkout -b xxx 切换至新分支xxx<br>（相当于复制了remote的仓库到本地的xxx分支上<br>3.修改或者添加本地代码（部署在硬盘的源文件上）<br>4.git diff 查看自己对代码做出的改变<br>5.git add 上传更新后的代码至暂存区<br>6.git commit 可以将暂存区里更新后的代码更新到本地git<br>7.git push origin xxx 将本地的xxxgit分支上传至github上的git</p></blockquote><blockquote><p>（如果在写自己的代码过程中发现远端GitHub上代码出现改变）<br>1.git checkout main 切换回main分支<br>2.git pull origin master(main) 将远端修改过的代码再更新到本地<br>3.git checkout xxx 回到xxx分支<br>4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容<br>（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）<br>5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上<br>（-f —》强行）<br>6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit</p></blockquote><blockquote><p>远端完成更新后<br>1.git branch -d xxx 删除本地的git分支<br>2.git pull origin master 再把远端的最新代码拉至本地</p></blockquote><p><a href="https://www.bilibili.com/video/BV19e4y1q7JJ/?spm_id_from=333.1007.tianma.2-2-4.click&amp;vd_source=52fb49cd12021ddab3266f637619f33b" target="_blank" rel="noopener">视频教程地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的一种github工作流&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="github" scheme="/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>企业信息化常用系统</title>
    <link href="/2022/10/12/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>/2022/10/12/企业信息化常用系统/</id>
    <published>2022-10-12T03:15:40.000Z</published>
    <updated>2022-10-12T03:31:34.247Z</updated>
    
    <content type="html"><![CDATA[<p>企业信息化常用系统的英文缩写<br><a id="more"></a></p><h2 id="企业资源计划（ERP）"><a href="#企业资源计划（ERP）" class="headerlink" title="企业资源计划（ERP）"></a>企业资源计划（ERP）</h2><p><img src="/2022/10/12/企业信息化常用系统/1.png" alt="img"></p><h2 id="客户关系管理（CRM）"><a href="#客户关系管理（CRM）" class="headerlink" title="客户关系管理（CRM）"></a>客户关系管理（CRM）</h2><p><img src="/2022/10/12/企业信息化常用系统/2.png" alt="img"></p><h2 id="供应链管理（SCM）"><a href="#供应链管理（SCM）" class="headerlink" title="供应链管理（SCM）"></a>供应链管理（SCM）</h2><p><img src="/2022/10/12/企业信息化常用系统/3.png" alt="img"></p><h2 id="商业智能（BI）"><a href="#商业智能（BI）" class="headerlink" title="商业智能（BI）"></a>商业智能（BI）</h2><p><img src="/2022/10/12/企业信息化常用系统/4.png" alt="img"></p><h2 id="决策支持系统（DSS）"><a href="#决策支持系统（DSS）" class="headerlink" title="决策支持系统（DSS）"></a>决策支持系统（DSS）</h2><p><img src="/2022/10/12/企业信息化常用系统/5.png" alt="img"></p><h2 id="业务流程重组（BPR）"><a href="#业务流程重组（BPR）" class="headerlink" title="业务流程重组（BPR）"></a>业务流程重组（BPR）</h2><p><img src="/2022/10/12/企业信息化常用系统/6.png" alt="img"></p><h2 id="业务流程管理（BPM）"><a href="#业务流程管理（BPM）" class="headerlink" title="业务流程管理（BPM）"></a>业务流程管理（BPM）</h2><p><img src="/2022/10/12/企业信息化常用系统/7.png" alt="img"></p><h2 id="企业应用集成（EAI）"><a href="#企业应用集成（EAI）" class="headerlink" title="企业应用集成（EAI）"></a>企业应用集成（EAI）</h2><p><img src="/2022/10/12/企业信息化常用系统/8.png" alt="img"></p><h2 id="企业门户"><a href="#企业门户" class="headerlink" title="企业门户"></a>企业门户</h2><p><img src="/2022/10/12/企业信息化常用系统/9.png" alt="img"></p><h2 id="电子政务与电子商务简称"><a href="#电子政务与电子商务简称" class="headerlink" title="电子政务与电子商务简称"></a>电子政务与电子商务简称</h2><blockquote><p>政府 Government<br>  企业 Business<br>  公民 Citizen<br>  线上 Online<br>  线下 Offline<br>  G2G G2B B2C C2C等<br>  O2O</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;企业信息化常用系统的英文缩写&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="软考" scheme="/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>h5禁止微信字体设置</title>
    <link href="/2022/10/10/h5%E7%A6%81%E6%AD%A2%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/"/>
    <id>/2022/10/10/h5禁止微信字体设置/</id>
    <published>2022-10-10T02:28:42.000Z</published>
    <updated>2022-10-10T02:40:12.030Z</updated>
    
    <content type="html"><![CDATA[<p>解除微信字体大小设置，对h5页面的影响<br><a id="more"></a><br>在开发微信公众号，或者用微信打开一个h5页面，如果调整了微信的字体大小，页面的布局会发生改变，这样就做不到统一。<br>IOS和安卓用不同的方法禁止了微信字体的调整，见下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;微信字体大小设置&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  /* iOS禁止微信调整字体大小 */</span><br><span class="line">  body &#123;</span><br><span class="line">    -webkit-text-size-adjust: 100% !important;</span><br><span class="line">    text-size-adjust: 100% !important;</span><br><span class="line">    -moz-text-size-adjust: 100% !important;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;h1字体大小测试微信&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;h2字体大小测试微信&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;h3字体大小测试微信&lt;/h3&gt;</span><br><span class="line">  &lt;h4&gt;h4字体大小测试微信&lt;/h4&gt;</span><br><span class="line">  &lt;h5&gt;h5字体大小测试微信&lt;/h5&gt;</span><br><span class="line">  &lt;h6&gt;h6字体大小测试微信&lt;/h6&gt;</span><br><span class="line">  &lt;div style=&quot;font-size:14px;&quot;&gt;div字体大小测试微信px&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;font-size:2rem;&quot;&gt;div字体大小测试微信rem&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 对安卓手机有效</span><br><span class="line">  // 强制禁止用户修改微信客户端的字体大小</span><br><span class="line">  (function() &#123;</span><br><span class="line">    if (typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot;) &#123;</span><br><span class="line">    handleFontSize();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (document.addEventListener) &#123;</span><br><span class="line">    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, handleFontSize, false);</span><br><span class="line">  &#125; else if (document.attachEvent) &#123;</span><br><span class="line">    document.attachEvent(&quot;WeixinJSBridgeReady&quot;, handleFontSize);</span><br><span class="line">    document.attachEvent(&quot;onWeixinJSBridgeReady&quot;, handleFontSize);  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function handleFontSize() &#123;</span><br><span class="line">    // 设置网页字体为默认大小</span><br><span class="line">    WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;);</span><br><span class="line">    // 重写设置网页字体大小的事件</span><br><span class="line">    WeixinJSBridge.on(&apos;menu:setfont&apos;, function() &#123;</span><br><span class="line">      WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos; : 0 &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解除微信字体大小设置，对h5页面的影响&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="微信" scheme="/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>canvas-html属性width与css的width区别</title>
    <link href="/2022/09/15/canvas-html%E5%B1%9E%E6%80%A7width%E4%B8%8Ecss%E7%9A%84width%E5%8C%BA%E5%88%AB/"/>
    <id>/2022/09/15/canvas-html属性width与css的width区别/</id>
    <published>2022-09-15T06:45:32.000Z</published>
    <updated>2022-09-15T07:08:41.895Z</updated>
    
    <content type="html"><![CDATA[<p>canvas中标签属性的width，height与css的width，height的区别<br><a id="more"></a><br>canvas中，如果不写width和height，会默认width=300，height=150。</p><blockquote><p>标签属性中的width和height可以理解为虚拟画布的宽高，比如设置width=3000，height=1000，在js中对其进行绘图时，都是在这个宽3000，高1000的画布上进行绘制。<br>而css的width和height是绘制好的这块画布在实际的页面中显示的具体宽高，可以把画布理解为一张宽3000，高1000的图片，当设置其css宽高时，这张图片会根据实际的宽高进行变化。</p></blockquote><p>附上一段代码，可以更改width和height观察其变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;canvas&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  canvas &#123;</span><br><span class="line">    border: 1px solid blue;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id=&quot;mycanvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;浏览器不支持Canvas,请升级或改用其它浏览器！&lt;/canvas&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var canvas = document.getElementById(&quot;mycanvas&quot;),</span><br><span class="line">        ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    ctx.moveTo(0,0);</span><br><span class="line">    ctx.lineTo(300,150);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas中标签属性的width，height与css的width，height的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="canvas" scheme="/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发</title>
    <link href="/2022/09/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    <id>/2022/09/05/微信公众号开发/</id>
    <published>2022-09-05T06:31:44.000Z</published>
    <updated>2022-09-06T07:11:06.471Z</updated>
    
    <content type="html"><![CDATA[<p>微信公众号开发简介<br><a id="more"></a><br>微信公众号开发比较繁琐，先来看一下大致架构：<br><img src="/2022/09/05/微信公众号开发/1.png" alt="img"><br>服务器鉴权这块，应该是比较难的。<br>这里有两个需要鉴权的地方，一个是基本配置里的URL接入鉴权，另一个是JS-SDK的鉴权。</p><h2 id="URL接入鉴权"><a href="#URL接入鉴权" class="headerlink" title="URL接入鉴权"></a>URL接入鉴权</h2><p><img src="/2022/09/05/微信公众号开发/2.png" alt="img"><br>上图中的这个URL是微信公众平台接入到自己的后台服务器的接口鉴权，URL可以写成这样<code>http://jinux.top/weixinapi</code>。<br>看一看微信公众平台的定义：</p><blockquote><p>开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：<br>1）将token、timestamp、nonce三个参数进行字典序排序<br>2）将三个参数字符串拼接成一个字符串进行sha1加密<br>3）开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信</p></blockquote><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html" target="_blank" rel="noopener">官网文档地址</a><br>验证signature的示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function checkSignature() &#123;</span><br><span class="line">  let &#123; signature, timestamp, nonce, echostr &#125; = req.query;</span><br><span class="line">  let token = &apos;testweixin&apos;; // 这个token是上图中的填写的Token</span><br><span class="line">  let array = [timestamp, nonce, token];</span><br><span class="line">  array.sort(); // 字典排序</span><br><span class="line">  let str = array.join(&apos;&apos;);</span><br><span class="line">  let resultStr = sha1(str); // 对字符串进行sha1加密，需要const sha1 = require(&apos;sha1&apos;)</span><br><span class="line">  if(resultStr === signature) &#123;</span><br><span class="line">    res.send(echostr);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    res.send(&apos;Error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JS-SDK使用"><a href="#JS-SDK使用" class="headerlink" title="JS-SDK使用"></a>JS-SDK使用</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62" target="_blank" rel="noopener">官方文档地址</a><br>js-sdk使用流程图：<br><img src="/2022/09/05/微信公众号开发/3.png" alt="img"><br>在网页中调用微信赋予的功能时，需要config 接口注入权限验证配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。</span><br><span class="line">  appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class="line">  timestamp: , // 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class="line">  signature: &apos;&apos;,// 必填，签名</span><br><span class="line">  jsApiList: [] // 必填，需要使用的 JS 接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>timestamp, nonceStr, signature</code>需要后台生成。<br>接下来，看一下生成流程</p><h3 id="获取ticket"><a href="#获取ticket" class="headerlink" title="获取ticket"></a>获取ticket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function getTicket() &#123;</span><br><span class="line">  let tokenUrl = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;appid&#125;&amp;secret=$&#123;secret&#125;`;</span><br><span class="line">  let token_data = await axios.get(tokenUrl);</span><br><span class="line">  let access_token = token_data.data.access_token; // 得到access_token</span><br><span class="line">  let ticketUrl = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=$&#123;access_token&#125;&amp;type=jsapi`;</span><br><span class="line">  let ticket_data = await axios.get(ticketUrl);</span><br><span class="line">  let ticket = ticket_data.data.ticket; // 获取jsp_ticket</span><br><span class="line">  return ticket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成nonceStr"><a href="#生成nonceStr" class="headerlink" title="生成nonceStr"></a>生成nonceStr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function createNonceStr() &#123;</span><br><span class="line">  return Math.random().toString(36).subStr(2, 15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成timestamp"><a href="#生成timestamp" class="headerlink" title="生成timestamp"></a>生成timestamp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function createTimestamp() &#123;</span><br><span class="line">  return parseInt(new Date().getTime() / 1000) + &apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成signature"><a href="#生成signature" class="headerlink" title="生成signature"></a>生成signature</h3><blockquote><p>签名生成规则如下：<br>1）参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。<br>2）对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用 URL 键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1。<br>3）这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 处理数据格式</span><br><span class="line">function row(obj) &#123;</span><br><span class="line">  let keys = Object.keys(obj);</span><br><span class="line">  keys = keys.sort(); // 字典排序</span><br><span class="line">  let newObj = &#123;&#125;;</span><br><span class="line">  keys.forEach(key=&gt; &#123;</span><br><span class="line">    newObj[key] = obj[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  let string = &apos;&apos;;</span><br><span class="line">  for(let k in newObj) &#123;</span><br><span class="line">    string += &apos;&amp;&apos; + k + &apos;=&apos; + newObj[k];</span><br><span class="line">  &#125;</span><br><span class="line">  string = string.subStr(1);</span><br><span class="line">  return string;</span><br><span class="line">&#125;</span><br><span class="line">// 生成signature签名方法</span><br><span class="line">async function getSignature(url) &#123;</span><br><span class="line">  let jsapi_ticket = await getTicket();</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    jsapi_ticket,</span><br><span class="line">    nonceStr: createNonceStr(),</span><br><span class="line">    timestamp: createTimestamp(),</span><br><span class="line">    url</span><br><span class="line">  &#125;</span><br><span class="line">  let str = row(obj);</span><br><span class="line">  let signature = sha1(str);</span><br><span class="line">  obj.signature = signature;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="人脸识别认证"><a href="#人脸识别认证" class="headerlink" title="人脸识别认证"></a>人脸识别认证</h2><p>微信是提供了人脸识别验证接口的，该接口目前是免费的，并且是适用公众号的。由于该接口属于未开放接口，所以在微信JS-SDK说明文档是无法查看到该接口文档的，需要写邮件给腾讯进行申请审核，如果申请通过，腾讯会回复邮件，开通对应公众号的调用权限，并会发送接口文档。<br><a href="https://blog.csdn.net/weixin_36463040/article/details/112664578" target="_blank" rel="noopener">开通人脸识别方法</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是简单的列举了URL接入鉴权和JS-SDK的鉴权，这两个也是公众号中最繁琐的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公众号开发简介&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="微信" scheme="/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>nodejs path模块详解</title>
    <link href="/2022/08/23/nodejs-path%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/"/>
    <id>/2022/08/23/nodejs-path模块详解/</id>
    <published>2022-08-23T02:50:19.000Z</published>
    <updated>2022-08-23T05:51:10.889Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs的path模块用法<br><a id="more"></a><br>nodejs的path模块包含一系列处理和转换文件路径的工具集</p><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h2><p>规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.normalize(&apos;a/b/c/../user/bin&apos;));// a\b\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c///../user/bin/&apos;));// a\b\user\bin\</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin&apos;));// a\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/.././///../user/bin/..&apos;));// a\user</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin/../../&apos;));// a\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../&apos;));// ..\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../../../&apos;));// ..\..\..\</span><br><span class="line">console.log(path.normalize(&apos;./a/.././user/bin/./&apos;));// user\bin\</span><br></pre></td></tr></table></figure></p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>path.join([path1], [path2], […])<br>将多个路径结合在一起，并转换为规范化路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.join(&apos;////./a&apos;, &apos;b////c&apos;, &apos;user/&apos;));// \a\b\c\user</span><br><span class="line">console.log(path.join(&apos;./a&apos;, &apos;b//c&apos;, &apos;user&apos;));// a\b\c\user</span><br><span class="line">console.log(path.join(&apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// ..\user\</span><br><span class="line">console.log(path.join(__dirname, &apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// E:\jinux\node\study\user\</span><br></pre></td></tr></table></figure></p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>从源地址 from 到目的地址 to 的绝对路径</p><blockquote><p>类似在shell里执行一系列的cd命令<br>path.resolve(‘foo/bar’, ‘/tmp/file/‘, ‘..’, ‘a/../subfile’)<br>类似于:<br>cd foo/bar<br>cd /tmp/file/<br>cd ..<br>cd a/../subfile<br>pwd<br>[注意]如果某个from或to参数是绝对路径（比如 ‘E:/abc’，或是以“/”开头的路径），则将忽略之前的from参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.resolve(&apos;.&apos;, &apos;testFiles/..&apos;, &apos;trdLayer&apos;));// E:\jinux\node\study\path模块\trdLayer</span><br><span class="line">console.log(path.resolve(&apos;..&apos;, &apos;testFiles&apos;, &apos;a.txt&apos;));// E:\jinux\node\study\testFiles\a.txt</span><br><span class="line">console.log(path.resolve(&apos;D:&apos;, &apos;abc&apos;, &apos;D:/a&apos;));// D:\a</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;ok.gif&apos;));// E:\jinux\node\study\path模块\abc\ok.gif</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)); // E:\jinux\node\study\path模块\subfile</span><br><span class="line">console.log(path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)); // E:\b\c</span><br></pre></td></tr></table></figure><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><p>path.relative(from, to)<br>获取从 from 到 to 的相对路径，可以看作 path.resolve 的相反实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.relative(&apos;C:\\\test&apos;, &apos;C:\\\impl\\bbb&apos;));//..\impl\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;C:/bbb&apos;));//..\..\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;D:/bbb&apos;));//D:\bbb</span><br></pre></td></tr></table></figure></p><h2 id="isAbsolute"><a href="#isAbsolute" class="headerlink" title="isAbsolute"></a>isAbsolute</h2><p>path.isAbsolute(path)<br>path是一个绝对路径(比如 ‘E:/abc’)，或者是以“/”开头的路径，二者都会返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.isAbsolute(&apos;../testFiles/secLayer&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;./join.js&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;temp&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;/temp/../..&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;E:/github/nodeAPI/abc/efg&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;///temp123&apos;));// true</span><br></pre></td></tr></table></figure></p><h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h2><p>path.dirname(p)<br>返回路径p所在的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // /foo/bar/baz/asdf</span><br><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/&apos;)); // /foo/bar/baz</span><br><span class="line">console.log(path.dirname(&apos;C:/test/aaa&apos;)); // C:/test</span><br><span class="line">console.log(path.dirname(__dirname)); // E:\jinux\node\study</span><br></pre></td></tr></table></figure></p><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p>path.basename(p[, ext])<br>返回路径的最后一个部分，即文件名。参数ext为需要截掉的后缀内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // a.txt</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;,&apos;.txt&apos;)); // a</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/&apos;)); // asdf</span><br><span class="line">console.log(path.basename(&apos;C:/test/aaa&apos;)); // aaa</span><br></pre></td></tr></table></figure></p><h2 id="extname"><a href="#extname" class="headerlink" title="extname"></a>extname</h2><p>path.extname(p)<br>返回路径p的扩展名，从最后一个’.’到字符串的末尾。如果最后一个部分没有’.’，或者路径是以’.’开头，则返回空字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // .txt</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt.b&apos;)); // .b</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.&apos;)); // .</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa/.&apos;)); // &apos;&apos;</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa&apos;)); // &apos;&apos;</span><br></pre></td></tr></table></figure></p><h2 id="sep"><a href="#sep" class="headerlink" title="sep"></a>sep</h2><p>返回对应平台下的文件分隔符，win下为’\’，linux下为’/‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.sep); // win下为\，linux下为/</span><br><span class="line">console.log(&apos;foo\\bar\\baz&apos;.split(path.sep)); // [ &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos; ]</span><br><span class="line">console.log(&apos;foo/bar/baz&apos;.split(path.sep)); // win下返回[&apos;foo/bar/baz&apos;]，但在linux系统下会返回[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]</span><br></pre></td></tr></table></figure></p><h2 id="delimiter"><a href="#delimiter" class="headerlink" title="delimiter"></a>delimiter</h2><p>返回对应平台下的路径分隔符，win下为’;’ linux下为’:’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(path.delimiter); //win下为“;” linux下为“:”</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所有代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">// 当前文件路径</span><br><span class="line">console.log(&apos;当前文件夹路径&apos;, process.cwd());</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.normalize</span><br><span class="line"> * 规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠　</span><br><span class="line"> */</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../user/bin&apos;));// a\b\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c///../user/bin/&apos;));// a\b\user\bin\</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin&apos;));// a\user\bin</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/.././///../user/bin/..&apos;));// a\user</span><br><span class="line">console.log(path.normalize(&apos;a/b/c/../../user/bin/../../&apos;));// a\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../&apos;));// ..\</span><br><span class="line">console.log(path.normalize(&apos;a/../../user/bin/../../../../&apos;));// ..\..\..\</span><br><span class="line">console.log(path.normalize(&apos;./a/.././user/bin/./&apos;));// user\bin\</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.join</span><br><span class="line"> * path.join([path1], [path2], [...])</span><br><span class="line"> * 将多个路径结合在一起，并转换为规范化路径</span><br><span class="line"> */</span><br><span class="line">console.log(path.join(&apos;////./a&apos;, &apos;b////c&apos;, &apos;user/&apos;));// \a\b\c\user</span><br><span class="line">console.log(path.join(&apos;./a&apos;, &apos;b//c&apos;, &apos;user&apos;));// a\b\c\user</span><br><span class="line">console.log(path.join(&apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// ..\user\</span><br><span class="line">console.log(path.join(__dirname, &apos;a&apos;, &apos;../../&apos;, &apos;user/&apos;));// E:\jinux\node\study\user\</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.resolve</span><br><span class="line"> * path.resolve([from ...], to)</span><br><span class="line"> * 从源地址 from 到目的地址 to 的绝对路径，类似在shell里执行一系列的cd命令</span><br><span class="line"> * path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</span><br><span class="line"> * 类似于:</span><br><span class="line"> * cd foo/bar</span><br><span class="line"> * cd /tmp/file/</span><br><span class="line"> * cd ..</span><br><span class="line"> * cd a/../subfile</span><br><span class="line"> * pwd</span><br><span class="line"> * [注意]如果某个from或to参数是绝对路径（比如 &apos;E:/abc&apos;，或是以“/”开头的路径），则将忽略之前的from参数</span><br><span class="line"> */</span><br><span class="line">console.log(path.resolve(&apos;.&apos;, &apos;testFiles/..&apos;, &apos;trdLayer&apos;));// E:\jinux\node\study\path模块\trdLayer</span><br><span class="line">console.log(path.resolve(&apos;..&apos;, &apos;testFiles&apos;, &apos;a.txt&apos;));// E:\jinux\node\study\testFiles\a.txt</span><br><span class="line">console.log(path.resolve(&apos;D:&apos;, &apos;abc&apos;, &apos;D:/a&apos;));// D:\a</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;ok.gif&apos;));// E:\jinux\node\study\path模块\abc\ok.gif</span><br><span class="line">console.log(path.resolve(&apos;abc&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)); // E:\jinux\node\study\path模块\subfile</span><br><span class="line">console.log(path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)); // E:\b\c</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.relative</span><br><span class="line"> * path.relative(from, to)</span><br><span class="line"> * 获取从 from 到 to 的相对路径，可以看作 path.resolve 的相反实现</span><br><span class="line"> */</span><br><span class="line">console.log(path.relative(&apos;C:\\\test&apos;, &apos;C:\\\impl\\bbb&apos;));//..\impl\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;C:/bbb&apos;));//..\..\bbb</span><br><span class="line">console.log(path.relative(&apos;C:/test/aaa&apos;, &apos;D:/bbb&apos;));//D:\bbb</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.dirname</span><br><span class="line"> * path.dirname(p)</span><br><span class="line"> * 返回路径p所在的目录</span><br><span class="line"> */</span><br><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // /foo/bar/baz/asdf</span><br><span class="line">console.log(path.dirname(&apos;/foo/bar/baz/asdf/&apos;)); // /foo/bar/baz</span><br><span class="line">console.log(path.dirname(&apos;C:/test/aaa&apos;)); // C:/test</span><br><span class="line">console.log(path.dirname(__dirname)); // E:\jinux\node\study</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.basename</span><br><span class="line"> * path.basename(p[, ext])</span><br><span class="line"> * 返回路径的最后一个部分，即文件名。参数ext为需要截掉的后缀内容</span><br><span class="line"> */</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // a.txt</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/a.txt&apos;,&apos;.txt&apos;)); // a</span><br><span class="line">console.log(path.basename(&apos;/foo/bar/baz/asdf/&apos;)); // asdf</span><br><span class="line">console.log(path.basename(&apos;C:/test/aaa&apos;)); // aaa</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.extname</span><br><span class="line"> * path.extname(p)</span><br><span class="line"> * 返回路径p的扩展名，从最后一个&apos;.&apos;到字符串的末尾。如果最后一个部分没有&apos;.&apos;，或者路径是以&apos;.&apos;开头，则返回空字符串</span><br><span class="line"> */</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt&apos;)); // .txt</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.txt.b&apos;)); // .b</span><br><span class="line">console.log(path.extname(&apos;/foo/bar/baz/asdf/a.&apos;)); // .</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa/.&apos;)); // &apos;&apos;</span><br><span class="line">console.log(path.extname(&apos;C:/test/aaa&apos;)); // &apos;&apos;</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.sep</span><br><span class="line"> * 返回对应平台下的文件分隔符，win下为&apos;\&apos;，linux下为&apos;/&apos;</span><br><span class="line"> */</span><br><span class="line">console.log(path.sep); // win下为\，linux下为/</span><br><span class="line">console.log(&apos;foo\\bar\\baz&apos;.split(path.sep)); // [ &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos; ]</span><br><span class="line">console.log(&apos;foo/bar/baz&apos;.split(path.sep)); // win下返回[&apos;foo/bar/baz&apos;]，但在linux系统下会返回[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.delimiter</span><br><span class="line"> * 返回对应平台下的路径分隔符，win下为&apos;;&apos; linux下为&apos;:&apos;</span><br><span class="line"> */</span><br><span class="line">console.log(path.delimiter); //win下为“;” linux下为“:”</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br><span class="line">/**</span><br><span class="line"> * path.isAbsolute</span><br><span class="line"> * path.isAbsolute(path)</span><br><span class="line"> * path是一个绝对路径(比如 &apos;E:/abc&apos;)，或者是以“/”开头的路径，二者都会返回true</span><br><span class="line"> */</span><br><span class="line">console.log(path.isAbsolute(&apos;../testFiles/secLayer&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;./join.js&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;temp&apos;));// false</span><br><span class="line">console.log(path.isAbsolute(&apos;/temp/../..&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;E:/github/nodeAPI/abc/efg&apos;));// true</span><br><span class="line">console.log(path.isAbsolute(&apos;///temp123&apos;));// true</span><br><span class="line">console.log(&apos;-------------------------------------------------------------&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs的path模块用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CSS设计模式</title>
    <link href="/2022/08/15/CSS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>/2022/08/15/CSS设计模式/</id>
    <published>2022-08-15T06:00:04.000Z</published>
    <updated>2022-08-15T07:27:03.736Z</updated>
    
    <content type="html"><![CDATA[<p>CSS设计模式<br><a id="more"></a><br>css的设计模式有OOCSS，BEM，SMACSS，ACSS这几种，接下来逐一介绍。</p><h2 id="设计模式-OOCSS"><a href="#设计模式-OOCSS" class="headerlink" title="设计模式:OOCSS"></a>设计模式:OOCSS</h2><p>OOCSS是比较基础的设计模式，其他设计模式或多或少都有OOCSS的影子,OO就是面向对象，也就是用面向对象的思维来写CSS。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>大家都很熟悉面向对象，我们简单看下下面这一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    void study () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher extends Person &#123;</span><br><span class="line">    void study () &#123;&#125;</span><br><span class="line">    void teach () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    void study () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个Person类，它有一些方法，Teacher和Student都继承Person，并且进行了一些修订和扩展。那么我们可以把Person类看成是别人写代码，在不改变别人源码的情况下,新增Teacher和Student对源码进行修订和扩展。这种写法是完全可以应用到CSS上面的。我们看下面一段代码场景:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;menu fix&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;</span><br><span class="line">.menu &#123;</span><br><span class="line">   color: green;</span><br><span class="line">   font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">.fix &#123;</span><br><span class="line">   color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>设计师只想让我们改变其中一个盒子的样式，其他的不变。<br>这时不能轻易改变menu，因为一旦改变就会影响不需要改变的地方。那么我们可以直接利用面向对象的思想，在后面单独添加一个类进行修订和扩展。这样一看我们平时在写的CSS，不就是面向对象吗？<br>当然，OOCSS是有具体的原则的。那么它有哪些原则且个原则的具体是什么呢？我们来看一下：</p><h3 id="原则一-容器与内容分离"><a href="#原则一-容器与内容分离" class="headerlink" title="原则一:容器与内容分离"></a>原则一:容器与内容分离</h3><p>容器与内容分离顾名思义，直接看一个代码案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;post&quot;&gt; </span><br><span class="line">  &lt;p class=&quot;metadata&quot;&gt;</span><br><span class="line">    &lt;a&gt;Hello&lt;/a&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;comment&quot;&gt; </span><br><span class="line">  &lt;p class=&quot;metadata&quot;&gt;</span><br><span class="line">    &lt;a&gt;Hello&lt;/a&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// ---------code 1-----------</span><br><span class="line">.post .metadata &#123;</span><br><span class="line">  // css code</span><br><span class="line">&#125;</span><br><span class="line">// ---------code 2-----------</span><br><span class="line">.post &#123;&#125;</span><br><span class="line">.metadata &#123;</span><br><span class="line">  // css code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>两个不同容器中的内容相同<br>先看样式的code 1，这样显然不好，容器和内容是嵌套依赖关系，并没有做到容器与内容分离。内容的样式无法复用。样式的code 2做到了容器与内容分离，内容在不同的容器中可以复用。</p><h3 id="原则二-结构与皮肤分离"><a href="#原则二-结构与皮肤分离" class="headerlink" title="原则二:结构与皮肤分离"></a>原则二:结构与皮肤分离</h3><p>结构可以看做是一个基础对象,而皮肤可以看做是另外一个对象,也就是对象与对象要分离。基础对象不能改,不断的分离出皮肤对象达到对基础对象的修正和扩展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;menu fix&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 基础对象</span><br><span class="line">.menu &#123;</span><br><span class="line">  color: green;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">// 皮肤</span><br><span class="line">.fix &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="OOCSS与Vue的关系"><a href="#OOCSS与Vue的关系" class="headerlink" title="OOCSS与Vue的关系"></a>OOCSS与Vue的关系</h3><p>我们每天都在写OOCSS，Vue的组件就是OOCSS。我们下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// -------------定义组件-----------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;menu&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;MateData&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">// 基础对象</span><br><span class="line">.menu &#123;</span><br><span class="line">   color: green;</span><br><span class="line">   font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">// -----------使用组件-------------------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;mate-data class=&quot;fix1&quot;&gt;&lt;/mate-data&gt;</span><br><span class="line">  &lt;mate-data class=&quot;fix2&quot;&gt;&lt;/mate-data&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">// 皮肤</span><br><span class="line">.fix1 &#123;</span><br><span class="line">   color: red;</span><br><span class="line">&#125;</span><br><span class="line">.fix2 &#123;</span><br><span class="line">   font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h2 id="设计模式-BEM"><a href="#设计模式-BEM" class="headerlink" title="设计模式:BEM"></a>设计模式:BEM</h2><h3 id="BEM是什么"><a href="#BEM是什么" class="headerlink" title="BEM是什么"></a>BEM是什么</h3><p>BEM即块(Block)、元素(Element)、修饰符(Modifier) 是由Yandex（俄罗斯最著名的互联网企业）的开发团队提出的前端开发理论。BEM通过Block、Element、Modifier来描述页面(关键就是为了解决多人协作的命名问题)。<br>Block是页面中独立存在的区块，可以在不同场合下使用。每个页面都可以看做是多个Block组成。<br>Element是构成Block的元素，只有在对应Block内部才具有意义，是依赖于Block的存在。<br>Modifier是描述Block或Element的属性或状态。同一Block或Element可以有多个Modifier，Modifier不可以单独存在。<br>在命名时，Block作为起始开头，不同 Block 和 Element 用 _ 两个底线区隔开来，不同的 Modifier 则用 – 区隔。<br><img src="/2022/08/15/CSS设计模式/1.jpg" alt="img"></p><h3 id="进阶版的OOCSS"><a href="#进阶版的OOCSS" class="headerlink" title="进阶版的OOCSS"></a>进阶版的OOCSS</h3><p>BEM就是进阶版的OOCSS，我们看下图所示:<br><img src="/2022/08/15/CSS设计模式/2.jpg" alt="img"></p><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>页面两个tab栏，整体布局相似,只有细节部分不同<br>那么使用BEM写样式时，就会定义一个块menu，下面包含元素menu_tab，完成整体布局，细微部分使用修饰符menu_tab-style1进行微调。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BEM --&gt;</span><br><span class="line">&lt;div class=&quot;menu menu-style1&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;menu_tab menu_tab-style2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>通过上面代码可以看出BEM就是OOCSS。<br>对BEM感兴趣的话，可以访问<a href="https://en.bem.info/methodology/css/" target="_blank" rel="noopener">BEM的官网</a></p><h2 id="设计模式-SMACSS"><a href="#设计模式-SMACSS" class="headerlink" title="设计模式:SMACSS"></a>设计模式:SMACSS</h2><p>SMACSS is a way to examine your design process and as a way to fit those rigid frameworks into a flexible thought process. (SMACSS通过一个灵活的思维过程来检查你的设计过程和方式是否符合你的架构，更像一种规范~)</p><h3 id="核心思想-分类"><a href="#核心思想-分类" class="headerlink" title="核心思想:分类"></a>核心思想:分类</h3><ul><li>SMACSS的核心就是分类，它主要要求分为五大类分别是：Base、Layout、Modules、State、Theme</li><li>Base是对浏览器默认样式的重置，常见的<a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">normalize.css</a>就属于此。这里样式只会对标签元素本身做设定，不会出现任何 class 或id，但是可以有属性选择器或是伪类.</li><li>Layout对页面布局的一些功能，属于较高的一层，它可以作为层级较低的Module Rules元素的容器。左右分栏、栅格系统等都属于布局规范。SMACSS还约定命名使用l-/layout-前缀来标识布局的class。</li><li>Modules公共复用的小模块，模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。SMACSS中的模块具有自己的一个命名，隶属于模块下的类皆以该模块为前缀，例如：.menu .menu-title等。</li><li>State对不同的展示效果，例如显示、隐藏，与BEM抽取修饰类的方式的不同，SMACSS是抽取更高级别的样式类，得到更强的复用性，命名全都以is-前缀,如:is-hidden。</li><li>Theme对不同主题皮肤的维护，可以修改前面4个类别的样式，且应和前面4个类别分离开来（便于切换，也就是“换肤”）。命名规范需要添加theme-前缀。</li></ul><h3 id="最小适配深度原则"><a href="#最小适配深度原则" class="headerlink" title="最小适配深度原则"></a>最小适配深度原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* depth 1 */</span><br><span class="line">.sidebar ul h3 &#123;&#125;</span><br><span class="line">/* depth 2 */</span><br><span class="line">.sub-title &#123;&#125;</span><br></pre></td></tr></table></figure><p>两段css的区别在于html和css的耦合度(这一点上和OOCSS的分离容器和内容的原则不谋而合)。可以想到，由于上面的样式规则使用了继承选择符，因此对于html的结构实际是有一定依赖的。如果html发生重构，就有可能不再具有这些样式。对应的，下面的样式规则只有一个选择符，因此不依赖于特定html结构，只要为元素添加class，就可以获得对应样式。<br>当然，继承选择符是有用的，它可以减少因相同命名引发的样式冲突（常发生于多人协作开发）。但是，我们不应过度使用，在不造成样式冲突的允许范围之内，尽可能使用短的、不限定html结构的选择符。这就是SMACSS的最小化适配深度的意义。<br>在项目中使用SMACSS时，每一个分类都是一个目录，但是在Vue中，Layout和Modules不需要单独维护目录，因为我们写的布局组件和模块组件就相当于这两个分类了。<br>如果想要对SMACSS更详细的了解可以访问<a href="https://smacss-zh.vercel.app/preface.html" target="_blank" rel="noopener">SMACSS</a></p><h2 id="设计模式-ITCSS"><a href="#设计模式-ITCSS" class="headerlink" title="设计模式:ITCSS"></a>设计模式:ITCSS</h2><p>这是由<a href="https://csswizardry.com/" target="_blank" rel="noopener">csswizardry</a>提倡的一个 CSS 设计方法论，它可以让CSS更好的管理和维护。<br>使用ITCSS主要可以帮助我们以下几点:</p><ul><li>Manages source order.(管理 CSS 代码的书写顺序)</li><li>Filters explicitness.(过滤器的明确性，是说分层来明确每层 CSS 的作用)</li><li>Tames the cascade.(控制好 CSS 的权重)</li><li>Sanitises inheritance.(安全地使用继承)</li></ul><h3 id="核心思想-分层"><a href="#核心思想-分层" class="headerlink" title="核心思想:分层"></a>核心思想:分层</h3><p>TCSS的核心是分层,主要分为七层, 与SMACSS的分类相比更加精细，层次分的更细主要有:</p><table><thead><tr><th>Layer</th><th>作用</th></tr></thead><tbody><tr><td>Settings</td><td>项目使用的全局变量</td></tr><tr><td>Tools</td><td>mixin，function</td></tr><tr><td>Generic</td><td>最基本的设定 normalize.css，reset</td></tr><tr><td>Base</td><td>type selector</td></tr><tr><td>Objects</td><td>不经过装饰 (Cosmetic-free) 的设计模式，相当于SMACSS的Layout</td></tr><tr><td>Components</td><td>UI 组件</td></tr><tr><td>Trumps</td><td>helper 唯一可以使用 !important 的地方</td></tr></tbody></table><p>下面就是ITCSS的架构模型:<br><img src="/2022/08/15/CSS设计模式/3.jpg" alt="img"><br>从这个模型可以看出来，越往下就越具体，越局限于使用在某个具体的东西。另外它的下一层永远继承上一层的所有样式。</p><h3 id="各个分层例子"><a href="#各个分层例子" class="headerlink" title="各个分层例子"></a>各个分层例子</h3><h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4><p>全局变量，比如颜色，字体大小等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$yellow: #FAAF00;</span><br><span class="line">$yellow-bright: #FAF7F0;</span><br></pre></td></tr></table></figure></p><h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><p>mixin，function 等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@mixin sample-mixin () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到 Tools 为止，不会生成具体的 css</p><h4 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h4><p>reset，normalize 等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*,</span><br><span class="line">*::before,</span><br><span class="line">*::after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors" target="_blank" rel="noopener">type selector</a> 比如 link, p 等等，只有这一层才使用 type selector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  margin: 0</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h4><p>Cosmetic-free，不使用比如 color、border-color、background-color 之类的<br>使用这个 CSS 你在浏览器上面只可以看一片空白<br>主要用来做画面的 layout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.o-container &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><p>UI 组件<br>到这个部分，根据UI分析具体有哪些组件需要实现，可以分给多个人来同时实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># button组件</span><br><span class="line">.c-btn &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  ...</span><br><span class="line">  &amp;--primary &#123;</span><br><span class="line">    background-color: #ff5959;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;--large &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    padding: 16px 14px;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HTML 类似这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=&quot;c-btn c-btn--primary&quot; href=&quot;#&quot;&gt;sample&lt;/a&gt;</span><br><span class="line">&lt;a class=&quot;c-btn c-btn--primary c-btn--large&quot; href=&quot;#&quot;&gt;sample&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Trumps"><a href="#Trumps" class="headerlink" title="Trumps"></a>Trumps</h4><p>放各种 helper<br>最主要的作用是用在不适合或者不容易放在 Component 的时候<br>比如 margin，很可能不应该放 Component，这时候可以用 Trumps 来微调<br>这样可以防止你的 Component 变得非常大<br>只有这一层才可以使用! important，以此来避免多个! important 的混乱局面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.u-color &#123;</span><br><span class="line">  &amp;--white &#123;</span><br><span class="line">    color: $white !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.u-hidden &#123;</span><br><span class="line">  display: hidden !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在使用时，每个分层都维护为一个文件夹。在Vue中使用时，Objects和Components相当于我们的组件，不需要单独维护。<br>另外值得注意的是，无论是SMACSS的分类还是ITCSS的分层，都是一种思想，我们可以根据实际项目来动态的添加或者删除某一个分类或者分层，不能生搬硬套。</p></blockquote><h2 id="设计模式-ACSS"><a href="#设计模式-ACSS" class="headerlink" title="设计模式:ACSS"></a>设计模式:ACSS</h2><p>ACSS使用了紧密的类名库。 这些类名通常被缩写，并与它们影响的内容分开。 在ACSS系统中，我们可以知道类名的作用； 但是类名称与内容类型之间没有关系,即每一个样式对应一个类，也称原子类CSS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.float-left &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">.float-right &#123;</span><br><span class="line">  float: right;</span><br><span class="line">&#125;</span><br><span class="line">.z-0 &#123;</span><br><span class="line">  z-index: 0;</span><br><span class="line">&#125;</span><br><span class="line">.z-auto &#123;</span><br><span class="line">  z-index: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中，可以看到ACSS有极强的复用性,维护成本低，但是破坏了css命名的语义化。最终很可能代码会成为下面这样。但是存在即合理，ACSS也有其作用，继续往下看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;grid grid-cols-3 gap-2 place-content-center h-48 ...&quot;&gt;</span><br><span class="line">  &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><a href="https://tailwindcss.com/" target="_blank" rel="noopener">tailwindcss</a>是一个典型的ACSS框架。</p><h2 id="混合使用CSS设计模式"><a href="#混合使用CSS设计模式" class="headerlink" title="混合使用CSS设计模式"></a>混合使用CSS设计模式</h2><p>在进行一个项目的设计时,我们可以针对多种CSS设计模式进行选型，结合不同设计模式的优点和缺点，设计一个完整银杏的CSS架构。<br>假如我们选择ITCSS、BEM、ACSS进行组合，设计一个CSS架构。<br>在我们设计CSS架构时,我们首先想到的一定是SMACSS和ITCSS,因为它们两个对CSS进行了分类分层的划分。</p><table><thead><tr><th>SMACSS</th><th>ITCSS</th></tr></thead><tbody><tr><td>Base</td><td>Setting</td></tr><tr><td>Layout</td><td>Tools</td></tr><tr><td>Modules</td><td>Generic</td></tr><tr><td>State</td><td>Base</td></tr><tr><td>Theme</td><td>Objects</td></tr><tr><td></td><td>Components</td></tr><tr><td></td><td>Trumps</td></tr></tbody></table><p>根据上表我们可以看出ITCSS分层更加精细，所以我们选择ITCSS，接着我们继续看ITCSS的Objects和Components层，它就相当于OOCSS且相当于开发Vue组件，所以我们在开发组件时使用选择OOCSS的进阶版BEM。我们知道如果一个项目全部使用ACSS的缺点跟明显，那么我们选择ACSS的原因是因为项目中可能会存在向字体大小的这种的样式,所以我们可以把这一类样式维护在ACSS目录中。Generic和Base类似所以只保留Base即可，我假设Trumps用不到,所以也去掉这一层。所以我们的架构现在就是下面这样。</p><table><thead><tr><th>ITCSS+BEM+ACSS</th></tr></thead><tbody><tr><td>Setting</td></tr><tr><td>Tools</td></tr><tr><td>Base</td></tr><tr><td>Objects</td></tr><tr><td>Components</td></tr><tr><td>ACSS</td></tr></tbody></table><p>目录结构就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-|comments</span><br><span class="line">-|styles</span><br><span class="line">--|acss</span><br><span class="line">--|base</span><br><span class="line">--|settings</span><br><span class="line">--|tools</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSS设计模式听起来很深奥，但是大家在日常开发时，已经不知不觉的在使用，只不过是没有概念而已。在开发中熟练的使用CSS设计模式，可以使代码结构思路清晰，易于阅读，维护，如果想真正的在项目中写好CSS,CSS设计模式是必不可少的，也是我们开发者应该掌握的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS设计模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="/categories/css/"/>
    
    
      <category term="样式" scheme="/tags/%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
